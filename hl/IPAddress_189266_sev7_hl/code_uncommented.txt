package inet.ipaddr;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.format.validate.HostIdentifierStringValidator;
import inet.ipaddr.format.validate.IPAddressProvider;
import inet.ipaddr.format.validate.Validator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.mac.MACAddress;
public class IPAddressString implements HostIdentifierString, Comparable<IPAddressString> {
	private static final long serialVersionUID = 4L;
	public static final IPAddressStringParameters DEFAULT_VALIDATION_OPTIONS = new IPAddressStringParameters.Builder().toParams();
	private static final IPAddressString ipv4MappedPrefix = new IPAddressString("::ffff:0:0/96");
	final IPAddressStringParameters validationOptions;
	final String fullAddr;
	private AddressStringException validateException;
	private IPAddressProvider addressProvider = IPAddressProvider.NO_TYPE_PROVIDER;
	public IPAddressString(String addr) {
		this(addr, DEFAULT_VALIDATION_OPTIONS);
	}
	public IPAddressString(String addr, IPAddressStringParameters valOptions) {
		if(addr == null) {
			fullAddr = addr = "";
		} else {
			addr = addr.trim();
			fullAddr = addr;
		}
		this.validationOptions = valOptions;
	}
	IPAddressString(String addrString, IPAddress address, IPAddressStringParameters valOptions) {
		validationOptions = valOptions; 
		fullAddr = addrString;
		addressProvider = address.getProvider();
	}
	void cacheAddress(IPAddress address) {
		if(addressProvider.isUninitialized()) {
			addressProvider = address.getProvider();
		}
	}
	public IPAddressStringParameters getValidationOptions() {
		return validationOptions;
	}
	public boolean isPrefixed() {
		return getNetworkPrefixLength() != null;
	}
	public Integer getNetworkPrefixLength() {
		if(isValid()) {
			return addressProvider.getProviderNetworkPrefixLength();
		}
		return null;
	}
	public IPAddress getMask() {
		if(isValid()) {
			return addressProvider.getProviderMask();
		}
		return null;
	}
	public boolean isIPAddress() {
		return isValid() && addressProvider.isProvidingIPAddress();
	}
	public boolean isAllAddresses() {
		return isValid() && addressProvider.isProvidingAllAddresses();
	}
	public boolean isPrefixOnly() {
		return isValid() && addressProvider.isProvidingPrefixOnly();
	}
	public boolean isEmpty() {
		return isValid() && addressProvider.isProvidingEmpty();
	}
	public boolean isIPv4() {
		return isValid() && addressProvider.isProvidingIPv4();
	}
	public boolean isIPv6() {
		return isValid() && addressProvider.isProvidingIPv6();
	}
	public boolean isIPv4Mapped() {
		return isIPv6() && ipv4MappedPrefix.prefixEquals(this);
	}
	public boolean isMixedIPv6() {
		return isIPv6() && addressProvider.isProvidingMixedIPv6();
	}
	public boolean isBase85IPv6() {
		return isIPv6() && addressProvider.isProvidingBase85IPv6();
	}
	public IPVersion getIPVersion() {
		if(isValid()) {
			return addressProvider.getProviderIPVersion();
		}
		return null;
	}
	public boolean isLoopback() {
		IPAddress val = getAddress();
		return val != null && val.isLoopback();
	}
	public boolean isZero() {
		IPAddress value = getAddress();
		return value != null && value.isZero();
	}
	public boolean isValid() {
		if(addressProvider.isUninitialized()) {
			try {
				validate();
				return true;
			} catch(AddressStringException e) {
				return false;
			}
		}
		return !addressProvider.isInvalid();
	}
	public AddressStringException getAddressStringException() {
		if(!addressProvider.isInvalid()) { 
			try {
				validate();
			} catch(AddressStringException e) { 
				return e;
			}
		}
		return validateException;
	}
	public void validateIPv4() throws AddressStringException {
		validate(IPVersion.IPV4);
		checkIPv4Exception();
	}
	public void validateIPv6() throws AddressStringException {
		validate(IPVersion.IPV6);
		checkIPv6Exception();
	}
	@Override
	public void validate() throws AddressStringException {
		validate(null);
	}
	private void checkIPv4Exception() throws AddressStringException {
		IPVersion version = addressProvider.getProviderIPVersion();
		if(version != null && version.isIPv6()) {
			throw new AddressStringException("ipaddress.error.address.is.ipv6");
		} else if(validateException != null) {
			throw validateException;
		}
	}
	private void checkIPv6Exception() throws AddressStringException {
		IPVersion version = addressProvider.getProviderIPVersion();
		if(version != null && version.isIPv4()) {
			throw new AddressStringException("ipaddress.error.address.is.ipv4");
		} else if(validateException != null) {
			throw validateException;
		}
	}
	private boolean isValidated(IPVersion version) throws AddressStringException {
		if(!addressProvider.isUninitialized()) {
			if(version == null) {
				if(validateException != null) {
					throw validateException; 
				}
			} else if(version.isIPv4()) {
				checkIPv4Exception();
			} else if(version.isIPv6()) {
				checkIPv6Exception();
			}
			return true;
		}
		return false;
	}
	protected HostIdentifierStringValidator getValidator() {
		return Validator.VALIDATOR;
	}
	private void validate(IPVersion version) throws AddressStringException {
		if(isValidated(version)) {
			return;
		}
		synchronized(this) {
			if(isValidated(version)) {
				return;
			}
			try {
				addressProvider = getValidator().validateAddress(this);
			} catch(AddressStringException e) {
				validateException = e;
				addressProvider = IPAddressProvider.INVALID_PROVIDER;
				throw e;
			} 
		}
	}
	public static int validateNetworkPrefixLength(IPVersion ipVersion, CharSequence networkPrefixLength) throws PrefixLenException {
		try {
			return Validator.VALIDATOR.validatePrefix(networkPrefixLength, ipVersion);
		} catch(AddressStringException e) {
			throw new PrefixLenException(networkPrefixLength, ipVersion, e);
		}
	}
	public static void validateNetworkPrefix(IPVersion ipVersion, int networkPrefixLength, boolean allowPrefixesBeyondAddressSize) throws PrefixLenException {
		boolean asIPv4 = (ipVersion != null && ipVersion.isIPv4());
		if(networkPrefixLength > (asIPv4 ? IPv4Address.BIT_COUNT : IPv6Address.BIT_COUNT)) {
			throw new PrefixLenException(networkPrefixLength, ipVersion);
		}
	}
	@Override
	public int hashCode() {
		if(isValid()) {
			try {
				return addressProvider.providerHashCode();
			} catch(IncompatibleAddressException e) {}
		}
		return toString().hashCode();
	}
	@Override
	public int compareTo(IPAddressString other) {
		if(this == other) {
			return 0;
		}
		boolean isValid = isValid();
		boolean otherIsValid = other.isValid();
		if(isValid || otherIsValid) {
			try {
				return addressProvider.providerCompare(other.addressProvider);
			} catch(IncompatibleAddressException e) {}
		}
		return toString().compareTo(other.toString());
	}
	public boolean prefixEquals(IPAddressString other) {
		if(other == this && !isPrefixOnly()) {
			return true;
		}
		if(!isValid()) {
			return false;
		}
		if(other.addressProvider.isUninitialized()) { 
			Boolean directResult = addressProvider.prefixEquals(other.fullAddr);
			if(directResult != null) {
				return directResult.booleanValue();
			}
		}
		if(other.isValid()) {
			Boolean directResult = addressProvider.prefixEquals(other.addressProvider); 
			if(directResult != null) {
				return directResult.booleanValue();
			}
			IPAddress thisAddress = getAddress();
			if(thisAddress != null) {
				IPAddress otherAddress = other.getAddress();
				if(otherAddress != null) {
					return thisAddress.prefixEquals(otherAddress);
				}
			}
		}
		return false;
	}
	public boolean prefixContains(IPAddressString other) {
		if(other == this && !isPrefixOnly()) {
			return true;
		}
		if(!isValid()) {
			return false;
		}
		if(other.addressProvider.isUninitialized()) { 
			Boolean directResult = addressProvider.prefixContains(other.fullAddr);
			if(directResult != null) {
				return directResult.booleanValue();
			}
		}
		if(other.isValid()) {
			Boolean directResult = addressProvider.prefixContains(other.addressProvider); 
			if(directResult != null) {
				return directResult.booleanValue();
			}
			IPAddress thisAddress = getAddress();
			if(thisAddress != null) {
				IPAddress otherAddress = other.getAddress();
				if(otherAddress != null) {
					return thisAddress.prefixContains(otherAddress);
				}
			}
		}
		return false;
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof IPAddressString) {
			IPAddressString other = (IPAddressString) o;	
			boolean stringsMatch = toString().equals(other.toString());
			if(stringsMatch && validationOptions == other.validationOptions) {
				return true;
			}
			if(isValid()) {
				if(other.isValid()) {
					Boolean directResult = addressProvider.parsedEquals(other.addressProvider);
					if(directResult != null) {
						return directResult.booleanValue();
					}
					try {
						return addressProvider.providerEquals(other.addressProvider);
					} catch(IncompatibleAddressException e) {
						return stringsMatch;
					}
				}
			} else if(!other.isValid()) {
				return stringsMatch; 
			}
		}
		return false;
	}
	public boolean contains(IPAddressString other) {
		if(isValid()) {
			if(other == this) {
				return true;
			}
			if(other.addressProvider.isUninitialized()) { 
				Boolean directResult = addressProvider.contains(other.fullAddr);
				if(directResult != null) {
					return directResult.booleanValue();
				}
			}
			if(other.isValid()) {
				Boolean directResult = addressProvider.contains(other.addressProvider);
				if(directResult != null) {
					return directResult.booleanValue();
				}
				IPAddress addr = getAddress();
				if(addr != null) {
					IPAddress otherAddress = other.getAddress();
					if(otherAddress != null) {
						return addr.contains(otherAddress);
					}
				}
			}
		}
		return false;
	}
	public IPAddress getHostAddress() {
		if(!addressProvider.isInvalid()) { 
			try {
				return toHostAddress();
			} catch(AddressStringException e) { 
			} catch(IncompatibleAddressException e) {  }
		}
		return null;
	}
	public IPAddress getAddress(IPVersion version) {
		if(!addressProvider.isInvalid()) { 
			try {
				return toAddress(version);
			} catch(AddressStringException e) { 
			} catch(IncompatibleAddressException e) {  }
		}
		return null;
	}
	@Override
	public IPAddress getAddress() {
		if(!addressProvider.isInvalid()) { 
			try {
				return toAddress();
			} catch(AddressStringException e) { 
			} catch(IncompatibleAddressException e) {  }
		}
		return null;
	}
	public boolean isSequential() {
		return isValid() && addressProvider.isSequential();
	}
	public IPAddressDivisionSeries getDivisionGrouping() {
		if(!addressProvider.isInvalid()) { 
			try {
				validate();
				return addressProvider.getDivisionGrouping();
			} catch(AddressStringException e) { 
			} catch(IncompatibleAddressException e) {  }
		}
		return null;
	}
	public IPAddressSeqRange getSequentialRange() {
		if(!addressProvider.isInvalid()) { 
			try {
				validate();
				return addressProvider.getProviderSeqRange();
			} catch(AddressStringException e) {  }
		}
		return null;
	}
	public IPAddressDivisionSeries toDivisionGrouping() throws AddressStringException, IncompatibleAddressException {
		validate();
		return addressProvider.getDivisionGrouping();
	}
	public IPAddressSeqRange toSequentialRange() throws AddressStringException {
		validate();
		return addressProvider.getProviderSeqRange();
	}
	public IPAddress toHostAddress() throws AddressStringException, IncompatibleAddressException {
		validate(); 
		return addressProvider.getProviderHostAddress();
	}
	public IPAddress toAddress(IPVersion version) throws AddressStringException, IncompatibleAddressException {
		validate(); 
		return addressProvider.getProviderAddress(version);
	}
	@Override
	public IPAddress toAddress() throws AddressStringException, IncompatibleAddressException {
		validate(); 
		return addressProvider.getProviderAddress();
	}
	public IPAddressString adjustPrefixBySegment(boolean nextSegment) {
		if(isPrefixOnly()) {
			int bitsPerSegment = IPv4Address.BITS_PER_SEGMENT;
			int existingPrefixLength = getNetworkPrefixLength();
			int newBits;
			if(nextSegment) {
				int adjustment = existingPrefixLength % bitsPerSegment;
				newBits = Math.min(IPv6Address.BIT_COUNT, existingPrefixLength + bitsPerSegment - adjustment);
			} else {
				int adjustment = ((existingPrefixLength - 1) % bitsPerSegment) + 1;
				newBits = Math.max(0, existingPrefixLength - adjustment);
			}
			return new IPAddressString(IPAddressNetwork.getPrefixString(newBits), validationOptions);
		}
		IPAddress address = getAddress();
		if(address == null) {
			return null;
		}
		Integer prefix = address.getNetworkPrefixLength();
		if(!nextSegment && prefix != null && prefix == 0 && address.isMultiple() && address.isPrefixBlock()) {
			return new IPAddressString(IPAddress.SEGMENT_WILDCARD_STR, validationOptions);
		}
		return address.adjustPrefixBySegment(nextSegment).toAddressString();
	}
	public IPAddressString adjustPrefixLength(int adjustment) {
		if(isPrefixOnly()) {
			int newBits = adjustment > 0 ? Math.min(IPv6Address.BIT_COUNT, getNetworkPrefixLength() + adjustment) : Math.max(0, getNetworkPrefixLength() + adjustment);
			return new IPAddressString(IPAddressNetwork.getPrefixString(newBits), validationOptions);
		}
		IPAddress address = getAddress();
		if(address == null) {
			return null;
		}
		if(adjustment == 0 && isPrefixed()) {
			return this;
		}
		Integer prefix = address.getNetworkPrefixLength();
		if(prefix != null && prefix + adjustment < 0 && address.isPrefixBlock()) {
			return new IPAddressString(IPAddress.SEGMENT_WILDCARD_STR, validationOptions);
		}
		return address.adjustPrefixLength(adjustment).toAddressString();
	}
	public static int countDelimitedAddresses(String str) {
		int segDelimitedCount = 0;
		int result = 1;
		for(int i = 0; i < str.length(); i++) {
			char c = str.charAt(i);
			if(isDelimitedBoundary(c)) {
				if(segDelimitedCount > 0) {
					result *= segDelimitedCount + 1;
					segDelimitedCount = 0;
				}
			} else if(c == SEGMENT_VALUE_DELIMITER) {
				segDelimitedCount++;
			}
		}
		if(segDelimitedCount > 0) {
			result *= segDelimitedCount + 1;
		}
		return result;
	}
	private static boolean isDelimitedBoundary(char c) {
		return c == IPv4Address.SEGMENT_SEPARATOR ||
				c == IPv6Address.SEGMENT_SEPARATOR ||
				c == Address.RANGE_SEPARATOR ||
				c == MACAddress.DASHED_SEGMENT_RANGE_SEPARATOR;
	}
	public static Iterator<String> parseDelimitedSegments(String str) { 
		List<List<String>> parts = null;
		int lastSegmentStartIndex = 0;
		int lastPartIndex = 0;
		int lastDelimiterIndex = 0;
		boolean anyDelimited = false;
		List<String> delimitedList = null;
		for(int i = 0; i < str.length(); i++) {
			char c = str.charAt(i);
			if(isDelimitedBoundary(c)) {
				if(delimitedList != null) {
					if(parts == null) {
						parts = new ArrayList<List<String>>(8);
					}
					addParts(str, parts, lastSegmentStartIndex, lastPartIndex, lastDelimiterIndex, delimitedList, i);
					lastPartIndex = i;
					delimitedList = null;
				}
				lastSegmentStartIndex = lastDelimiterIndex = i + 1; 
			} else if(c == SEGMENT_VALUE_DELIMITER) {
				anyDelimited = true;
				if(delimitedList == null) {
					delimitedList = new ArrayList<String>();
				}
				String sub = str.substring(lastDelimiterIndex, i);
				delimitedList.add(sub);
				lastDelimiterIndex = i + 1;
			}
		}
		if(anyDelimited) {
			if(delimitedList != null) {
				if(parts == null) {
					parts = new ArrayList<List<String>>(8);
				}
				addParts(str, parts, lastSegmentStartIndex, lastPartIndex, lastDelimiterIndex, delimitedList, str.length());
			} else {
				parts.add(Arrays.asList(new String[] {str.substring(lastPartIndex, str.length())}));
			}
			return iterator(parts);
		}
		return new Iterator<String>() {
			boolean done;
			@Override
			public boolean hasNext() {
				return !done;
			}
		    @Override
			public String next() {
		    	if(done) {
		    		throw new NoSuchElementException();
		    	}
		    	done = true;
		    	return str;
		    }
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	private static Iterator<String> iterator(List<List<String>> parts) {
		return new Iterator<String>() {
			private boolean done;
			final int partCount = parts.size();
			@SuppressWarnings("unchecked")
			private final Iterator<String> variations[] = new Iterator[partCount];
			private String nextSet[] = new String[partCount];  {
				updateVariations(0);
			}
			private void updateVariations(int start) {
				for(int i = start; i < partCount; i++) {
					variations[i] = parts.get(i).iterator();
					nextSet[i] = variations[i].next();
				}
			}
			@Override
			public boolean hasNext() {
				return !done;
			}
		    @Override
			public String next() {
		    	if(done) {
		    		throw new NoSuchElementException();
		    	}
		    	StringBuilder result = new StringBuilder();
		    	for(int i = 0; i < partCount; i++) {
		    		result.append(nextSet[i]);
		    	}
		    	increment();
		    	return result.toString();
		    }
		    private void increment() {
		    	for(int j = partCount - 1; j >= 0; j--) {
		    		if(variations[j].hasNext()) {
		    			nextSet[j] = variations[j].next();
		    			updateVariations(j + 1);
		    			return;
		    		}
		    	}
		    	done = true;
		    }
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	private static void addParts(String str, List<List<String>> parts, int lastSegmentStartIndex, int lastPartIndex,
			int lastDelimiterIndex, List<String> delimitedList, int i) {
		String sub = str.substring(lastDelimiterIndex, i);
		delimitedList.add(sub);
		if(lastPartIndex != lastSegmentStartIndex) {
			parts.add(Arrays.asList(new String[] {str.substring(lastPartIndex, lastSegmentStartIndex)}));
		}
		parts.add(delimitedList);
	}
	public String convertToPrefixLength() throws AddressStringException {
		IPAddress address = getAddress();
		Integer prefix;
		if(address == null) {
			prefix = getNetworkPrefixLength(); 
			if(prefix == null) {
				return null;
			}
		} else {
			prefix = address.getBlockMaskPrefixLength(true);
			if(prefix == null) {
				return null;
			}
		}
		return IPAddressSegment.toUnsignedString(prefix, 10, 
				new StringBuilder(IPAddressSegment.toUnsignedStringLength(prefix, 10) + 1).append(IPAddress.PREFIX_LEN_SEPARATOR)).toString();
	}
	private static String toNormalizedString(IPAddressProvider addressProvider) throws IncompatibleAddressException {
		String result;
		if(addressProvider.isProvidingAllAddresses()) {
			result = IPAddress.SEGMENT_WILDCARD_STR;
		} else if(addressProvider.isProvidingEmpty()) {
			result = "";
		} else if(addressProvider.isProvidingPrefixOnly()) {
			result = IPAddressNetwork.getPrefixString(addressProvider.getProviderNetworkPrefixLength());
		} else if(addressProvider.isProvidingIPAddress()) {
			result = addressProvider.getProviderAddress().toNormalizedString();
		} else {
			result = null;
		}
		return result;
	}
	@Override
	public String toNormalizedString() {
		if(isValid()) {
			try {
				return toNormalizedString(addressProvider);
			} catch(IncompatibleAddressException e) {}
		}
		return toString();
	}
	@Override
	public String toString() {
		return fullAddr;
	}
}
package inet.ipaddr.format.validate;
import java.io.Serializable;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.util.Arrays;
import java.util.Objects;
import inet.ipaddr.HostIdentifierString;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSeqRange;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.format.large.IPAddressLargeDivision;
import inet.ipaddr.format.large.IPAddressLargeDivisionGrouping;
import inet.ipaddr.format.standard.IPAddressBitsDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.format.validate.ParsedIPAddress.CachedIPAddresses;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
public interface IPAddressProvider extends Serializable {
	enum IPType {
		INVALID, EMPTY, IPV4, IPV6, PREFIX_ONLY, ALL;
		static IPAddressProvider.IPType from(IPVersion version) {
			switch(version) {
				case IPV4:
					return IPV4;
				case IPV6:
					return IPV6;
				default:
					return null;
			}
		}
	}
	@SuppressWarnings("serial")
	public static final NullProvider INVALID_PROVIDER = new NullProvider(IPType.INVALID) {
		@Override
		public boolean isInvalid() {
			return true;
		}
	};
	@SuppressWarnings("serial")
	public static final NullProvider NO_TYPE_PROVIDER = new NullProvider(null) {
		@Override
		public boolean isUninitialized() {
			return true;
		}
	};
	@SuppressWarnings("serial")
	static final NullProvider EMPTY_PROVIDER = new NullProvider(IPType.EMPTY) {
		@Override
		public boolean isProvidingEmpty() {
			return true;
		}
	};
	IPAddressProvider.IPType getType();
	IPAddress getProviderHostAddress() throws IncompatibleAddressException;
	IPAddress getProviderAddress() throws IncompatibleAddressException;
	IPAddress getProviderAddress(IPVersion version) throws IncompatibleAddressException;
	default boolean isSequential() {
		try {
			IPAddress addr = getProviderAddress();
			if(addr != null) {
				return addr.isSequential();
			}
		} catch(IncompatibleAddressException e) {}
		return false;
	}
	default IPAddressSeqRange getProviderSeqRange() {
		IPAddress addr = getProviderAddress();
		if(addr != null) {
			return addr.toSequentialRange();
		}
		return null;
	}
	default IPAddress getProviderMask() {
		return null;
	}
	default IPAddressDivisionSeries getDivisionGrouping() throws IncompatibleAddressException {
		return getProviderAddress();
	}
	default int providerCompare(IPAddressProvider other) throws IncompatibleAddressException {
		if(this == other) {
			return 0;
		}
		IPAddress value = getProviderAddress();
		if(value != null) {
			IPAddress otherValue = other.getProviderAddress();
			if(otherValue != null) {
				return value.compareTo(otherValue);
			}
		}
		IPType thisType = getType(), otherType = other.getType();
		if(thisType == null) {
			return otherType == null ? 0 : -1;
		} else if(otherType == null) {
			return 1;
		}
		return thisType.ordinal() - otherType.ordinal();
	}
	default boolean providerEquals(IPAddressProvider other) throws IncompatibleAddressException {
		if(this == other) {
			return true;
		}
		IPAddress value = getProviderAddress();
		if(value != null) {
			IPAddress otherValue = other.getProviderAddress();
			if(otherValue != null) {
				return value.equals(otherValue);
			} else {
				return false;
			}
		}
		return getType() == other.getType();
	}
	default int providerHashCode() throws IncompatibleAddressException {
		IPAddress value = getProviderAddress();
		if(value != null) {
			return value.hashCode();
		}
		return Objects.hashCode(getType());
	}
	default IPVersion getProviderIPVersion() {
		return null;
	}
	default boolean isProvidingIPAddress() {
		return false;
	}
	default boolean isProvidingIPv4() {
		return false;
	}
	default boolean isProvidingIPv6() {
		return false;
	}
	default boolean isProvidingPrefixOnly() {
		return false;
	}
	default boolean isProvidingAllAddresses() {
		return false;
	}
	default boolean isProvidingEmpty() {
		return false;
	}
	default boolean isProvidingMixedIPv6() {
		return false;
	}
	default boolean isProvidingBase85IPv6() {
		return false;
	}
	default Integer getProviderNetworkPrefixLength() {
		return null;
	}
	default boolean isInvalid() {
		return false;
	}
	default boolean isUninitialized() {
		return false;
	}
	default Boolean contains(IPAddressProvider other) {
		return null;
	}
	default Boolean contains(String other) {
		return null;
	}
	default Boolean prefixEquals(String other) {
		return null;
	}
	default Boolean prefixEquals(IPAddressProvider other) {
		return null;
	}
	default Boolean prefixContains(String other) {
		return null;
	}
	default Boolean prefixContains(IPAddressProvider other) {
		return null;
	}
	default Boolean parsedEquals(IPAddressProvider other) {
		return null;
	}
	default boolean hasPrefixSeparator() {
		return getProviderNetworkPrefixLength() != null;
	}
	default IPAddressStringParameters getParameters() {
		return null;
	}
	abstract static class NullProvider implements IPAddressProvider {
		private static final long serialVersionUID = 4L;
		private IPType type;
		public NullProvider(IPAddressProvider.IPType type) {
			this.type = type;
		}
		@Override
		public IPAddressProvider.IPType getType() {
			return type;
		}
		@Override
		public IPAddress getProviderHostAddress() {
			return null;
		}
		@Override
		public IPAddress getProviderAddress() {
			return null;
		}
		@Override
		public IPAddress getProviderAddress(IPVersion version) {
			return null;
		}
		@Override
		public int providerHashCode() {
			return Objects.hashCode(getType());
		}
		@Override
		public boolean providerEquals(IPAddressProvider o) {
			if(this == o) {
				return true;
			}
			if(o instanceof NullProvider) {
				NullProvider other = (NullProvider) o;
				return getType() == other.getType();
			}
			return false;
		}
		@Override
		public String toString() {
			return String.valueOf(getType());
		}
	}
	public static IPAddressProvider getProviderFor(IPAddress address, IPAddress hostAddress) {
		return new CachedAddressProvider(address, hostAddress);
	}
	static class CachedAddressProvider implements IPAddressProvider {
		private static final long serialVersionUID = 4L;
		CachedIPAddresses<?> values;
		CachedAddressProvider() {}
		private CachedAddressProvider(IPAddress address, IPAddress hostAddress) {
			this.values = new CachedIPAddresses<IPAddress>(address, hostAddress);
		}
		@Override
		public IPAddress getProviderAddress(IPVersion version) {
			IPVersion thisVersion = getProviderIPVersion();
			if(!version.equals(thisVersion)) {
				return null;
			}
			return getProviderAddress();
		}
		CachedIPAddresses<?> createAddresses() {
			 return null;
		}
		private CachedIPAddresses<?> getCachedAddresses()  {
			CachedIPAddresses<?> val = values;
			if(val == null) {
				synchronized(this) {
					val = values;
					if(val == null) {
						values = val = createAddresses();
					}
				}
			}
			return val;
		}
		@Override
		public IPAddress getProviderHostAddress()  {
			return getCachedAddresses().getHostAddress();
		}
		@Override
		public IPAddress getProviderAddress()  {
			return getCachedAddresses().getAddress();
		}
		@Override
		public Integer getProviderNetworkPrefixLength() {
			return getProviderAddress().getNetworkPrefixLength();
		}
		@Override
		public IPVersion getProviderIPVersion() {
			return getProviderAddress().getIPVersion();
		}
		@Override
		public IPAddressProvider.IPType getType() {
			return IPType.from(getProviderIPVersion());
		}
		@Override
		public boolean isProvidingIPAddress() {
			return true;
		}
		@Override
		public boolean isProvidingIPv4() {
			return getProviderAddress().isIPv4();
		}
		@Override
		public boolean isProvidingIPv6() {
			return getProviderAddress().isIPv6();
		}
		@Override
		public String toString() {
			return String.valueOf(getProviderAddress());
		}
	}
	static abstract class VersionedAddressCreator extends CachedAddressProvider {
		private static final long serialVersionUID = 4L;
		IPAddress versionedValues[];
		protected final IPAddressStringParameters options;
		VersionedAddressCreator(IPAddressStringParameters options) {
			this.options = options;
		}
		@Override
		public IPAddressStringParameters getParameters() {
			return options;
		}
		private IPAddress checkResult(IPVersion version, int index) {
			IPAddress result = versionedValues[index];
			if(result == null) {
				versionedValues[index] = result = createVersionedAddress(version);
			}
			return result;
		}
		@Override
		public IPAddress getProviderAddress(IPVersion version) {
			int index = version.ordinal();
			IPAddress result;
			if(versionedValues == null) {
				synchronized(this) {
					if(versionedValues == null) {
						versionedValues = new IPAddress[IPVersion.values().length];
						versionedValues[index] = result = createVersionedAddress(version);
					} else {
						result = checkResult(version, index);
					}
				}
			} else {
				result = versionedValues[index];
				if(result == null) {
					synchronized(this) {
						result = checkResult(version, index);
					}
				}
			}
			return result;
		}
		abstract IPAddress createVersionedAddress(IPVersion version);
	}
	static abstract class AdjustedAddressCreator extends VersionedAddressCreator {
		private static final long serialVersionUID = 4L;
		protected final IPVersion adjustedVersion;
		protected final Integer networkPrefixLength;
		AdjustedAddressCreator(Integer networkPrefixLength, IPAddressStringParameters options) {
			this(networkPrefixLength, null, options);
		}
		AdjustedAddressCreator(Integer networkPrefixLength, IPVersion adjustedVersion, IPAddressStringParameters options) {
			super(options);
			this.networkPrefixLength = networkPrefixLength;
			this.adjustedVersion = adjustedVersion;
		}
		@Override
		public boolean isProvidingIPAddress() {
			return adjustedVersion != null;
		}
		@Override
		public boolean isProvidingIPv4() {
			return isProvidingIPAddress() && adjustedVersion.isIPv4();
		}
		@Override
		public boolean isProvidingIPv6() {
			return isProvidingIPAddress() && adjustedVersion.isIPv6();
		}
		@Override
		public IPVersion getProviderIPVersion() {
			return adjustedVersion;
		}
		@Override
		public Integer getProviderNetworkPrefixLength() {
			return networkPrefixLength;
		}
		@Override
		public IPAddress getProviderAddress()  {
			if(adjustedVersion == null) {
				return null;
			}
			return super.getProviderAddress();
		}
		@Override
		public IPAddress getProviderHostAddress()  {
			if(adjustedVersion == null) {
				return null;
			}
			return super.getProviderHostAddress();
		}
	}
	static class MaskCreator extends AdjustedAddressCreator {
		private static final long serialVersionUID = 4L;
		MaskCreator(Integer networkPrefixLength, IPAddressStringParameters options) {
			super(networkPrefixLength, options);
		}
		MaskCreator(Integer networkPrefixLength, IPVersion adjustedVersion, IPAddressStringParameters options) {
			super(networkPrefixLength, adjustedVersion, options);
		}
		@Override
		public int providerHashCode() {
			if(adjustedVersion == null) {
				return getProviderNetworkPrefixLength();
			}
			return getProviderAddress().hashCode();
		}
		@Override
		public boolean providerEquals(IPAddressProvider valueProvider) {
			if(valueProvider == this) {
				return true;
			}
			if(adjustedVersion == null) {
				if(valueProvider.getType() == IPType.PREFIX_ONLY) {
					return valueProvider.getProviderNetworkPrefixLength().intValue() == getProviderNetworkPrefixLength().intValue();
				}
				return false;
			}
			return super.providerEquals(valueProvider);
		}
		@Override
		public int providerCompare(IPAddressProvider other) throws IncompatibleAddressException {
			if(this == other) {
				return 0;
			}
			if(adjustedVersion == null) {
				if(other.getType() == IPType.PREFIX_ONLY) {
					return other.getProviderNetworkPrefixLength().intValue() - getProviderNetworkPrefixLength().intValue();
				}
				return IPType.PREFIX_ONLY.ordinal() - other.getType().ordinal();
			}
			IPAddress otherValue = other.getProviderAddress();
			if(otherValue != null) {
				return getProviderAddress().compareTo(otherValue);
			}
			return IPType.from(adjustedVersion).ordinal() - other.getType().ordinal();
		}
		private IPAddress createVersionedMask(IPVersion version, int bits, boolean withPrefixLength) {
			IPAddressNetwork<?, ?, ?, ?, ?> network = version.isIPv4() ? options.getIPv4Parameters().getNetwork() : options.getIPv6Parameters().getNetwork();
			return withPrefixLength ? network.getNetworkAddress(bits) : network.getNetworkMask(bits, false);
		}
		@Override
		IPAddress createVersionedAddress(IPVersion version) {
			return createVersionedMask(version, getProviderNetworkPrefixLength(), true);
		}
		@Override
		public IPAddressProvider.IPType getType() {
			if(adjustedVersion != null) {
				return IPType.from(adjustedVersion);
			}
			return IPType.PREFIX_ONLY;
		}
		@Override
		public boolean isProvidingPrefixOnly() {
			return adjustedVersion == null;
		}
		@Override
		CachedIPAddresses<?> createAddresses() {
			return new CachedIPAddresses<IPAddress>(
					createVersionedMask(adjustedVersion, getProviderNetworkPrefixLength(), true),
					createVersionedMask(adjustedVersion, getProviderNetworkPrefixLength(), false));
		}
	}
	static class LoopbackCreator extends VersionedAddressCreator {
		private static final long serialVersionUID = 4L;
		private final CharSequence zone;
		LoopbackCreator(IPAddressStringParameters options) {
			this(null, options);
		}
		LoopbackCreator(CharSequence zone, IPAddressStringParameters options) {
			super(options);
			this.zone = zone;
		}
		@Override
		IPAddress createVersionedAddress(IPVersion version) {
			if(values != null && version.equals(values.getAddress().getIPVersion())) {
				return values.getAddress();
			}
			IPAddressNetwork<? extends IPAddress, ?, ?, ?, ?> network = version.isIPv4() ? options.getIPv4Parameters().getNetwork() : options.getIPv6Parameters().getNetwork();
			IPAddress address = network.getLoopback();
			if(zone != null && zone.length() > 0 && version.isIPv6()) {
				ParsedAddressCreator<? extends IPAddress, ?, ?, ?> addressCreator = network.getAddressCreator();
				return addressCreator.createAddressInternal(address.getBytes(), zone);
			}
			return address;
		}
		@Override
		CachedIPAddresses<IPAddress> createAddresses() {
			InetAddress loopback = InetAddress.getLoopbackAddress();
			boolean isIPv6 = loopback instanceof Inet6Address;
			IPAddress result;
			if(zone != null && zone.length() > 0 && isIPv6) {
				ParsedAddressCreator<? extends IPAddress, ?, ?, ?> addressCreator = options.getIPv6Parameters().getNetwork().getAddressCreator();
				result = addressCreator.createAddressInternal(loopback.getAddress(), zone);
			} else if(isIPv6) {
				result = options.getIPv6Parameters().getNetwork().getLoopback();
			} else {
				result = options.getIPv4Parameters().getNetwork().getLoopback();
			}
			return new CachedIPAddresses<IPAddress>(result);
		}
		@Override
		public Integer getProviderNetworkPrefixLength() {
			return null;
		}
	}
	static class AllCreator extends AdjustedAddressCreator {
		private static final long serialVersionUID = 4L;
		HostIdentifierString originator;
		ParsedHostIdentifierStringQualifier qualifier;
		AllCreator(ParsedHostIdentifierStringQualifier qualifier, HostIdentifierString originator, IPAddressStringParameters options) {
			super(qualifier.getEquivalentPrefixLength(), options);
			this.originator = originator;
			this.qualifier = qualifier;
		}
		AllCreator(ParsedHostIdentifierStringQualifier qualifier, IPVersion adjustedVersion, HostIdentifierString originator, IPAddressStringParameters options) {
			super(qualifier.getEquivalentPrefixLength(), adjustedVersion, options);
			this.originator = originator;
			this.qualifier = qualifier;
		}
		@Override
		IPAddress createVersionedAddress(IPVersion version) {
			return ParsedIPAddress.createAllAddress(version, qualifier, originator, options);
		}
		@Override
		public IPAddressProvider.IPType getType() {
			if(adjustedVersion != null) {
				return IPType.from(adjustedVersion);
			}
			return IPType.ALL;
		}
		@Override
		public Boolean contains(IPAddressProvider otherProvider) {
			if(otherProvider.isInvalid()) {
				return Boolean.FALSE;
			} else if(adjustedVersion == null) {
				return Boolean.TRUE;
			}
			return adjustedVersion == otherProvider.getProviderIPVersion();
		}
		@Override
		public boolean isProvidingAllAddresses() {
			return adjustedVersion == null;
		}
		@Override
		public Integer getProviderNetworkPrefixLength() {
			return qualifier.getEquivalentPrefixLength();
		}
		@Override
		public int providerHashCode() {
			if(adjustedVersion == null) {
				return IPAddress.SEGMENT_WILDCARD_STR.hashCode();
			}
			return super.hashCode();
		}
		@Override
		CachedIPAddresses<?> createAddresses() {
			if(qualifier.equals(ParsedHost.NO_QUALIFIER)) {
				return new CachedIPAddresses<IPAddress>(ParsedIPAddress.createAllAddress(adjustedVersion, qualifier, originator, options));
			}
			return new CachedIPAddresses<IPAddress>(ParsedIPAddress.createAllAddress(adjustedVersion, qualifier, originator, options),
					ParsedIPAddress.createAllAddress(adjustedVersion, qualifier.getZone() != null ? new ParsedHostIdentifierStringQualifier(qualifier.getZone()) : ParsedHost.NO_QUALIFIER, originator, options));
		}
		@Override
		public IPAddress getProviderMask() {
			return qualifier.getMaskLower();
		}
		@Override
		public IPAddressSeqRange getProviderSeqRange() {
			if(isProvidingAllAddresses()) {
				return null;
			}
			IPAddress mask = getProviderMask();
			if(mask != null && mask.getBlockMaskPrefixLength(true) == null) {
				IPAddress all = ParsedIPAddress.createAllAddress(adjustedVersion, ParsedHost.NO_QUALIFIER, null, options);
				IPAddress upper = all.getUpper().mask(mask);
				IPAddress lower = all.getLower();
				return lower.spanWithRange(upper);
			}
			return super.getProviderSeqRange();
		}
		@Override
		public boolean isSequential() {
			return !isProvidingAllAddresses();
		}
		@Override
		public IPAddressDivisionSeries getDivisionGrouping() throws IncompatibleAddressException {
			if(isProvidingAllAddresses()) {
				return null;
			}
			IPAddressNetwork<?, ?, ?, ?, ?> network = adjustedVersion.isIPv4() ?
					options.getIPv4Parameters().getNetwork() : options.getIPv6Parameters().getNetwork();
			IPAddress mask = getProviderMask();
			if(mask != null && mask.getBlockMaskPrefixLength(true) == null) {
				Integer hostMaskPrefixLen = mask.getBlockMaskPrefixLength(false);
				if(hostMaskPrefixLen == null) { 
					throw new IncompatibleAddressException(getProviderAddress(), mask, "ipaddress.error.maskMismatch");
				}
				IPAddress hostMask = network.getHostMask(hostMaskPrefixLen);
				return hostMask.toPrefixBlock();
			}
			IPAddressDivisionSeries grouping;
			if(adjustedVersion.isIPv4()) {
				grouping = new IPAddressDivisionGrouping(new IPAddressBitsDivision[] {
							new IPAddressBitsDivision(0, IPv4Address.MAX_VALUE, IPv4Address.BIT_COUNT, IPv4Address.DEFAULT_TEXTUAL_RADIX, network, qualifier.getEquivalentPrefixLength())
						}, network);
			} else if(adjustedVersion.isIPv6()) {
				byte upperBytes[] = new byte[16];
				Arrays.fill(upperBytes, (byte) 0xff);
				grouping = new IPAddressLargeDivisionGrouping(new IPAddressLargeDivision[] {new IPAddressLargeDivision(new byte[IPv6Address.BYTE_COUNT], upperBytes, IPv6Address.BIT_COUNT, IPv6Address.DEFAULT_TEXTUAL_RADIX, network, qualifier.getEquivalentPrefixLength())}, network);
			} else {
				grouping = null;
			}
			return grouping;
		}
	}
}
package inet.ipaddr;
import java.io.IOException;
import java.io.Serializable;
public interface HostIdentifierString extends Serializable {
	static final char SEGMENT_VALUE_DELIMITER = ',';
	String toNormalizedString();
	void validate() throws HostIdentifierException;
	Address getAddress();
	Address toAddress() throws IOException, HostIdentifierException;
	@Override
	String toString();
}
package inet.ipaddr;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.function.Supplier;
import java.util.stream.Stream;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.IPStringCache;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.format.standard.AddressDivision;
import inet.ipaddr.format.standard.IPAddressDivision;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressStringWriter;
import inet.ipaddr.format.validate.ParsedIPAddress.BitwiseOrer;
import inet.ipaddr.format.validate.ParsedIPAddress.Masker;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
public abstract class IPAddressSegment extends IPAddressDivision implements AddressSegment {
	private static final long serialVersionUID = 4L;
	private final int value; 
	private final int upperValue; 
	protected IPAddressSegment(int value) {
		if(value < 0) {
			throw new AddressValueException(value);
		}
		this.value = this.upperValue = value;
	}
	protected IPAddressSegment(int value, Integer segmentPrefixLength) {
		this(value, value, segmentPrefixLength);
	}
	protected IPAddressSegment(int lower, int upper, Integer segmentPrefixLength) {
		super(segmentPrefixLength);
		if(lower < 0 || upper < 0) {
			throw new AddressValueException(lower < 0 ? lower : upper);
		}
		if(lower > upper) {
			int tmp = lower;
			lower = upper;
			upper = tmp;
		}
		segmentPrefixLength = getSegmentPrefixLength();
		if(segmentPrefixLength == null || segmentPrefixLength >= getBitCount() || !getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			this.value = lower;
			this.upperValue = upper;
		} else {
			int mask = getSegmentNetworkMask(segmentPrefixLength);
			this.value = lower & mask;
			this.upperValue = upper | getSegmentHostMask(segmentPrefixLength);
		}
	}
	@Override
	public abstract IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	public boolean isIPv4() {
		return false;
	}
	public boolean isIPv6() {
		return false;
	}
	public abstract IPVersion getIPVersion();
	protected static Integer getSplitSegmentPrefix(int bitsPerSegment, Integer networkPrefixLength, int segmentIndex) {
		return IPAddressSection.getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, segmentIndex);
	}
	@Override
	protected long getDivisionNetworkMask(int bits) {
		return getSegmentNetworkMask(bits);
	}
	@Override
	protected long getDivisionHostMask(int bits) {
		return getSegmentHostMask(bits);
	}
	protected abstract int getSegmentNetworkMask(int bits);
	protected abstract int getSegmentHostMask(int bits);
	@Override
	public int getMinPrefixLengthForBlock() {
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getSegmentPrefixLength() == 0) {
			return 0;
		}
		return super.getMinPrefixLengthForBlock();
	}
	public static int getMaxSegmentValue(IPVersion version) {
		return version.isIPv4() ? IPv4Address.MAX_VALUE_PER_SEGMENT : IPv6Address.MAX_VALUE_PER_SEGMENT;
	}
	protected boolean isChangedByPrefix(Integer bits, boolean smallerOnly) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		if(smallerOnly) {
			if(isPrefixed()) {
				return hasBits && bits < getSegmentPrefixLength();
			}
		} else {
			if(isPrefixed()) {
				return !hasBits || bits != getSegmentPrefixLength().intValue();
			}
		}
		return hasBits;
	}
	protected <S extends IPAddressSegment> S toPrefixedSegment(Integer segmentPrefixLength, AddressSegmentCreator<S> creator) {
		int lower = getSegmentValue();
		int upper = getUpperSegmentValue();
		boolean hasBits = (segmentPrefixLength != null);
		if(lower != upper) {
			if(!hasBits) {
				return creator.createSegment(lower, upper, null);
			}
			return creator.createSegment(lower, upper, segmentPrefixLength);
		}
		return hasBits ? creator.createSegment(lower, segmentPrefixLength) : creator.createSegment(lower);
	}
	@Override
	public boolean isPrefixBlock() {
		return (isPrefixed() && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) || super.isPrefixBlock();
	}
	protected boolean isNetworkChangedByPrefix(Integer bits, boolean withPrefixLength) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		withPrefixLength &= hasBits;
		boolean thisHasPrefix = isPrefixed();
		if(withPrefixLength != thisHasPrefix) {
			return true;
		}
		if(!hasBits || bits != getDivisionPrefixLength()) {
			return true;
		}
		return
			!containsPrefixBlock(bits);
	}
	protected boolean isNetworkChangedByPrefixNonNull(int prefixBitCount) {
		return !isPrefixed() || prefixBitCount != getDivisionPrefixLength() || !containsPrefixBlock(prefixBitCount);
	}
	public IPAddressSegment toNetworkSegment(Integer segmentPrefixLength) {
		return toNetworkSegment(segmentPrefixLength, true);
	}
	public abstract IPAddressSegment toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength);
	protected <S extends IPAddressSegment> S toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength, AddressSegmentCreator<S> creator) {
		int newLower = getSegmentValue();
		int newUpper = getUpperSegmentValue();
		boolean hasPrefLen = segmentPrefixLength != null;
		if(hasPrefLen) {
			int mask = getSegmentNetworkMask(segmentPrefixLength);
			newLower &= mask;
			newUpper |= getSegmentHostMask(segmentPrefixLength);
		}
		withPrefixLength = withPrefixLength && hasPrefLen;
		if(newLower != newUpper) {
			if(!withPrefixLength) {
				return creator.createSegment(newLower, newUpper, null);
			}
			return creator.createSegment(newLower, newUpper, segmentPrefixLength);
		}
		return withPrefixLength ? creator.createSegment(newLower, segmentPrefixLength) : creator.createSegment(newLower);
	}
	public abstract IPAddressSegment toHostSegment(Integer segmentPrefixLength);
	protected <S extends IPAddressSegment> S toHostSegment(Integer segmentPrefixLength, AddressSegmentCreator<S> creator) {
		int mask = (segmentPrefixLength == null) ? 0 : getSegmentHostMask(segmentPrefixLength);
		int lower = getSegmentValue();
		int upper = getUpperSegmentValue();
		Masker masker = maskRange(lower, upper, mask, getMaxValue());
		int newLower = (int) masker.getMaskedLower(lower, mask);
		int newUpper = (int) masker.getMaskedUpper(upper, mask);
		if(newLower != newUpper) {
			return creator.createSegment(newLower, newUpper, null);
		}
		return creator.createSegment(newLower);
	}
	protected boolean isHostChangedByPrefix(Integer bits) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		if(isPrefixed()) {
			return true;
		}
		int mask = !hasBits ? 0 : getSegmentHostMask(bits);
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		return value != (value & mask) || upperValue != (upperValue & mask);
	}
	protected boolean isChangedBy(int newValue, int newUpperValue, Integer segmentPrefixLength) throws IncompatibleAddressException {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		return value != newValue ||
				upperValue != newUpperValue ||
						(isPrefixed() ? !getSegmentPrefixLength().equals(segmentPrefixLength) : (segmentPrefixLength != null));
	}
	protected static Masker maskRange(long value, long upperValue, long maskValue, long maxValue) {
		return AddressDivision.maskRange(value, upperValue, maskValue, maxValue);
	}
	public MaskResult maskRange(int maskValue) {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		Masker masker = AddressDivision.maskRange(value, upperValue, maskValue, getMaxSegmentValue());
		return new MaskResult(value, upperValue, maskValue, masker);
	}
	protected static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue, long maxValue) {
		return AddressDivision.bitwiseOrRange(value, upperValue, maskValue, maxValue);
	}
	public BitwiseOrResult bitwiseOrRange(int maskValue) {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		BitwiseOrer orer = AddressDivision.bitwiseOrRange(value, upperValue, maskValue, getMaxSegmentValue());
		return new BitwiseOrResult(value, upperValue, maskValue, orer);
	}
	@Override
	public abstract IPAddressSegment getLower();
	@Override
	public abstract IPAddressSegment getUpper();
	protected static <S extends IPAddressSegment> S getLowestOrHighest(S original, AddressSegmentCreator<S> segmentCreator, boolean lowest) {
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(!original.isMultiple() && !(isAllSubnets && original.isPrefixed())) {
			return original;
		}
		return segmentCreator.createSegment(lowest ? original.getSegmentValue() : original.getUpperSegmentValue(), 
				isAllSubnets ? null : original.getSegmentPrefixLength());
	}
	@Override
	public abstract Iterable<? extends IPAddressSegment> getIterable();
	@Override
	public abstract Iterator<? extends IPAddressSegment> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> spliterator();
	@Override
	public abstract Stream<? extends IPAddressSegment> stream();
	public abstract Iterator<? extends IPAddressSegment> prefixBlockIterator();
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixBlockSpliterator();
	public abstract Stream<? extends IPAddressSegment> prefixBlockStream();
	public abstract Iterator<? extends IPAddressSegment> prefixIterator();
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixSpliterator();
	protected static <S extends IPAddressSegment> AddressComponentSpliterator<S> prefixSpliterator(
			S seg, int segPrefLength,
			IPAddressCreator<?, ?, ?, S, ?> creator,
			Supplier<Iterator<S>> iteratorProvider) {
		int bitCount = seg.getBitCount();
		int shiftAdjustment = bitCount - segPrefLength;
		int shiftMask, upperShiftMask;
		if(shiftAdjustment > 0) {
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftMask = ~0;
			upperShiftMask = 0;
		}
		int originalValue = seg.getSegmentValue();
		int originalUpperValue = seg.getUpperSegmentValue();
		int originalValuePrefix = originalValue >>> shiftAdjustment;
		int originalUpperValuePrefix = originalUpperValue >>> shiftAdjustment;
		Integer segPrefixLength = IPAddressSection.cacheBits(segPrefLength);
		IntBinaryIteratorProvider<S> subIteratorProvider = (isLowest, isHighest, value, upperValue) -> {
			if(isLowest || isHighest) {
				value = isLowest ? originalValue : value << shiftAdjustment;
				upperValue = isHighest ?  originalUpperValue : ((upperValue << shiftAdjustment) | upperShiftMask);
				return iterator(null, value, upperValue, bitCount, creator, segPrefixLength, true, false);
			}
			return iterator(null, value << shiftAdjustment, upperValue << shiftAdjustment, bitCount, creator, segPrefixLength, true, true);
		};
		return createSegmentSpliterator(
				seg,
				originalValuePrefix,
				originalUpperValuePrefix,
				iteratorProvider,
				subIteratorProvider,
				(value, upperValue) -> {
					value = (value == originalValuePrefix) ? originalValue : value << shiftAdjustment;
					upperValue = (upperValue == originalUpperValuePrefix) ? 
							originalUpperValue : ((upperValue << shiftAdjustment) | upperShiftMask);
					return creator.createSegment(value, upperValue, segPrefLength);
				});
	}
	public abstract Stream<? extends IPAddressSegment> prefixStream();
	public abstract Iterator<? extends IPAddressSegment> prefixBlockIterator(int prefixLength);
	protected static <S extends IPAddressSegment> AddressComponentSpliterator<S> prefixBlockSpliterator(
			S seg, int segPrefLength,
			IPAddressCreator<?, ?, ?, S, ?> creator,
			Supplier<Iterator<S>> iteratorProvider) {
		int bitCount = seg.getBitCount();
		int shiftAdjustment = bitCount - segPrefLength;
		int shiftMask, upperShiftMask;
		if(shiftAdjustment > 0) {
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftMask = ~0;
			upperShiftMask = 0;
		}
		Integer segmentPrefixLength = IPAddressSection.cacheBits(segPrefLength);
		return createSegmentSpliterator(
				seg,
				seg.getSegmentValue() >>> shiftAdjustment,
				seg.getUpperSegmentValue() >>> shiftAdjustment,
				iteratorProvider,
				(isLowest, isHighest, value, upperValue) -> iterator(
							null,
							value << shiftAdjustment,
							(upperValue << shiftAdjustment) | upperShiftMask,
							bitCount,
							creator,
							segmentPrefixLength,
							true,
							true),
				(value, upperValue) -> creator.createSegment(
						value << shiftAdjustment,
						(upperValue << shiftAdjustment) | upperShiftMask,
						segmentPrefixLength));
	}
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixBlockSpliterator(int prefixLength);
	public abstract Stream<? extends IPAddressSegment> prefixBlockStream(int prefixLength);
	public static int getBitCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BITS_PER_SEGMENT : IPv6Address.BITS_PER_SEGMENT;
	}
	public static int getByteCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
	}
	public static int getDefaultTextualRadix(IPVersion version) {
		return version.isIPv4() ? IPv4Address.DEFAULT_TEXTUAL_RADIX : IPv6Address.DEFAULT_TEXTUAL_RADIX;
	}
	@Override
	public boolean matches(int value) {
		return super.matches(value);
	}
	public boolean matchesWithPrefixMask(int value, Integer segmentPrefixLength) {
		return super.matchesWithPrefixMask(value, segmentPrefixLength);
	}
	@Override
	public boolean matchesWithMask(int value, int mask) {
		return super.matchesWithMask(value, mask);
	}
	@Override
	public boolean matchesWithMask(int lowerValue, int upperValue, int mask) {
		return super.matchesWithMask(lowerValue, upperValue, mask);
	}
	@Override
	public int getValueCount() {
		return getUpperSegmentValue() - getSegmentValue() + 1;
	}
	public int getPrefixValueCount() {
		Integer prefixLength = getSegmentPrefixLength();
		if(prefixLength == null) {
			return (int) getValueCount();
		}
		return getPrefixValueCount(this, prefixLength);
	}
	@Override
	public BigInteger getCount() {
		return BigInteger.valueOf(getValueCount());
	}
	@Override
	public BigInteger getPrefixCount(int segmentPrefixLength) {
		return BigInteger.valueOf(getPrefixValueCount(segmentPrefixLength));
	}
	@Override
	public int getPrefixValueCount(int segmentPrefixLength) {
		if(segmentPrefixLength < 0) {
			throw new PrefixLenException(this, segmentPrefixLength);
		}
		int bitCount = getBitCount();
		if(bitCount <= segmentPrefixLength) {
			return getValueCount();
		}
		int shiftAdjustment = bitCount - segmentPrefixLength;
		return (getUpperSegmentValue() >>> shiftAdjustment) - (getSegmentValue() >>> shiftAdjustment) + 1;
	}
	protected int highByte() {
		return highByte(getSegmentValue());
	}
	protected int lowByte() {
		return lowByte(getSegmentValue());
	}
	protected static int highByte(int value) {
		return value >> 8;
	}
	protected static int lowByte(int value) {
		return value & 0xff;
	}
	@Override
	public long getMaxValue() {
		return getMaxSegmentValue();
	}
	@Override
	public boolean isMultiple() {
		return getSegmentValue() != getUpperSegmentValue();
	}
	@Override
	public int getSegmentValue() {
		return value;
	}
	@Override
	public int getUpperSegmentValue() {
		return upperValue;
	}
	@Override
	public long getDivisionValue() {
		return getSegmentValue();
	}
	@Override
	public long getUpperDivisionValue() {
		return getUpperSegmentValue();
	}
	@Override
	public abstract IPAddressSegment reverseBits(boolean perByte);
	@Override
	public abstract IPAddressSegment reverseBytes();
	@Deprecated
	public abstract IPAddressSegment removePrefixLength();
	public abstract IPAddressSegment toZeroHost();
	@Deprecated
	public abstract IPAddressSegment removePrefixLength(boolean zeroed);
	public abstract IPAddressSegment withoutPrefixLength();
	protected static <S extends IPAddressSegment> S toZeroHost(S original, AddressSegmentCreator<S> creator) {
		if(original.isPrefixed()) {
			int lower = original.getSegmentValue();
			int upper = original.getUpperSegmentValue();
			Integer segmentPrefixLength = original.getSegmentPrefixLength();
			int mask = original.getSegmentNetworkMask(segmentPrefixLength);
			int newLower = lower & mask;
			int newUpper = upper & mask;
			boolean allPrefsSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
			if(allPrefsSubnets) {
				return creator.createSegment(newLower, newUpper, null);
			}
			if(newLower == lower && newUpper == upper) {
				return original;
			}
			return creator.createSegment(newLower, newUpper, segmentPrefixLength);
		} else if(original.isZero()) {
			return original;
		}
		return creator.createSegment(0, null);
	}
	protected static <S extends IPAddressSegment> S removePrefix(S original, boolean zeroed, AddressSegmentCreator<S> creator) {
		if(original.isPrefixed()) {
			int lower = original.getSegmentValue();
			int upper = original.getUpperSegmentValue();
			if(zeroed) {
				int maskBits = original.getSegmentNetworkMask(original.getSegmentPrefixLength());
				long value = original.getDivisionValue();
				long upperValue = original.getUpperDivisionValue();
				long maxValue = original.getMaxValue();
				Masker masker = maskRange(value, upperValue, maskBits, maxValue);
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(original, maskBits, "ipaddress.error.maskMismatch");
				}
				return creator.createSegment((int) masker.getMaskedLower(lower, maskBits), (int) masker.getMaskedUpper(upper, maskBits), null);
			}
			return creator.createSegment(lower, upper, null);
		}
		return original;
	}
	@Override
	public boolean isBoundedBy(int value) {
		return getUpperSegmentValue() < value;
	}
	public Integer getSegmentPrefixLength() {
		return getDivisionPrefixLength();
	}
	@Override
	public int hashCode() {
		return hash(getSegmentValue(), getUpperSegmentValue(), getBitCount());
	}
	static int hash(int lower, int upper, int bitCount) {
		return lower | (upper << bitCount);
	}
	protected boolean isSameValues(AddressSegment otherSegment) {
		return getSegmentValue() == otherSegment.getSegmentValue() && getUpperSegmentValue() == otherSegment.getUpperSegmentValue();
	}
	public boolean prefixEquals(IPAddressSegment other) {
		Integer prefLength = getSegmentPrefixLength();
		if(prefLength == null) {
			return equals(other);
		}
		return prefixEquals(other, prefLength);
	}
	@Override
	public boolean prefixEquals(AddressSegment other, int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int shift = getBitCount() - prefixLength;
		if(shift <= 0) {
			return isSameValues(other);
		}
		return (other.getSegmentValue() >>> shift) == (getSegmentValue() >>> shift) && 
				(other.getUpperSegmentValue() >>> shift) == (getUpperSegmentValue() >>> shift);
	}
	public boolean prefixContains(IPAddressSegment other) {
		Integer prefLength = getSegmentPrefixLength();
		if(prefLength == null) {
			return equals(other);
		}
		return prefixContains(other, prefLength);
	}
	public boolean prefixContains(IPAddressSegment other, int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int shift = getBitCount() - prefixLength;
		if(shift <= 0) {
			return contains(other);
		}
		return (other.getSegmentValue() >>> shift) >= (getSegmentValue() >>> shift) && 
				(other.getUpperSegmentValue() >>> shift) <= (getUpperSegmentValue() >>> shift);
	}
	protected boolean containsSeg(AddressSegment other) {
		return other.getSegmentValue() >= getSegmentValue() && other.getUpperSegmentValue() <= getUpperSegmentValue();
	}
	protected boolean overlapsSeg(AddressSegment other) {
		return other.getSegmentValue() <= getUpperSegmentValue() && other.getUpperSegmentValue() >= getSegmentValue();
	}
	@Override
	public boolean includesZero() {
		return getSegmentValue() == 0;
	}
	@Override
	public boolean includesMax() {
		return getUpperSegmentValue() == getMaxSegmentValue();
	}
	boolean containsPrefixBlock(int lowerVal, int upperVal, int divisionPrefixLen) {
		return isPrefixBlock(lowerVal, upperVal, divisionPrefixLen);
	}
	boolean containsSinglePrefixBlock(int lowerVal, int upperVal, int divisionPrefixLen) {
		return isSinglePrefixBlock(lowerVal, upperVal, divisionPrefixLen);
	}
	@Override
	protected String getDefaultSegmentWildcardString() {
		return Address.SEGMENT_WILDCARD_STR;
	}
	@Override
	public String toHexString(boolean with0xPrefix) {
		return toNormalizedString(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams);
	}
	@Override
	public String toNormalizedString() {
		return toNormalizedString(IPStringCache.canonicalSegmentParams);
	}
	public String toNormalizedString(IPStringOptions options) {
		IPAddressStringWriter<IPAddressStringDivisionSeries> params =  IPAddressSection.toIPParams(options);
		StringBuilder builder = new StringBuilder(params.getDivisionStringLength(this));
		return params.appendDivision(builder, this).toString();
	}
	protected static int toUnsignedStringLength(int value, int radix) {
		return AddressDivision.toUnsignedStringLength(value, radix);
	}
	protected static StringBuilder toUnsignedString(int value, int radix, StringBuilder appendable) {
		return toUnsignedStringCased(value, radix, 0, false, appendable);
	}
	void setStandardString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int originalLowerValue) {
		if(cachedString == null && isStandardString && originalLowerValue == getDivisionValue()) {
			cachedString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	void setWildcardString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int lowerValue) {
		if(cachedWildcardString == null && isStandardString && lowerValue == getDivisionValue() && lowerValue == getUpperDivisionValue()) {
			cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	void setStandardString(
			CharSequence addressStr, 
			boolean isStandardString,
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedString == null) {
			if(isSinglePrefixBlock()) {
				if(isStandardString && rangeLower == getDivisionValue()) {
					cachedString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
				}
			} else if(isFullRange()) {
				cachedString = IPAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue()) {
				long upper = getUpperDivisionValue();
				if(isPrefixed()) {
					upper &= getDivisionNetworkMask(getDivisionPrefixLength());
				}
				if(rangeUpper == upper) {
					cachedString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
				}
			}
		}
	}
	void setWildcardString(
			CharSequence addressStr, 
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedWildcardString == null) {
			if(isFullRange()) {
				cachedWildcardString = IPAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue() && rangeUpper == getUpperDivisionValue()) {
				cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
			}
		}
	}
}
package inet.ipaddr;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.IPAddressConverter.DefaultAddressConverter;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSection.TriFunction;
import inet.ipaddr.format.IPAddressRange;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.sql.IPAddressSQLTranslator;
import inet.ipaddr.format.validate.IPAddressProvider;
import inet.ipaddr.format.validate.ParsedHost;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
public abstract class IPAddress extends Address implements IPAddressSegmentSeries, IPAddressRange {
	private static final long serialVersionUID = 4L;
	public static enum IPVersion {
		IPV4,
		IPV6;
		public boolean isIPv4() {
			return this == IPV4;
		}
		public boolean isIPv6() {
			return this == IPV6;
		}
		@Override
		public String toString() {
			return isIPv4() ? "IPv4" : "IPv6";
		}
	}
	public static interface IPAddressValueProvider extends AddressValueProvider {
		IPVersion getIPVersion();
		default Integer getPrefixLength() {
			return null;
		}
		default String getZone() {
			return null;
		}
	}
	public static final char PREFIX_LEN_SEPARATOR = '/';
	public static final String BINARY_STR_PREFIX = "0b";
	public static final IPAddressConverter DEFAULT_ADDRESS_CONVERTER = new DefaultAddressConverter();
	HostName fromHost;
	private HostName canonicalHost;
	protected IPAddress(IPAddressSection section) {
		super(section);
	}
	protected IPAddress(Function<Address, AddressSection> supplier) {
		super(supplier);
	}
	@Override
	public IPAddressString toAddressString() {
		if(fromString == null) {
			IPAddressStringParameters params = createFromStringParams();
			fromString = new IPAddressString(toCanonicalString(), this, params); 
		}
		return getAddressfromString();
	}
	protected abstract IPAddressStringParameters createFromStringParams();
	protected IPAddressString getAddressfromString() {
		return (IPAddressString) fromString;
	}
	public HostName toHostName() {
		HostName host = fromHost;
		if(host == null) {
			fromHost = host = toCanonicalHostName();
		}
		return host;
	}
	void cache(HostIdentifierString string) {
		if(string instanceof HostName) {
			fromHost = (HostName) string;
			fromString = new IPAddressString(fromHost.toString(), this, fromHost.validationOptions.addressOptions);
		} else if(string instanceof IPAddressString) {
			fromString = (IPAddressString) string;
		}
	}
	protected IPAddressProvider getProvider() {
		if(isPrefixed()) {
			if(getNetwork().getPrefixConfiguration().prefixedSubnetsAreExplicit() || !isPrefixBlock()) {
				return IPAddressProvider.getProviderFor(this, withoutPrefixLength()); 
			}
			return IPAddressProvider.getProviderFor(this, toZeroHost(true).withoutPrefixLength());
		}
		return IPAddressProvider.getProviderFor(this, this);
	}
	public HostName toCanonicalHostName() {
		HostName host = canonicalHost;
		if(host == null) {
			if(isMultiple()) {
				throw new IncompatibleAddressException(this, "ipaddress.error.unavailable.numeric");
			}
			InetAddress inetAddress = toInetAddress();
			String hostStr = inetAddress.getCanonicalHostName();
			if(hostStr.equals(inetAddress.getHostAddress())) {
				host = new HostName(hostStr, new ParsedHost(hostStr, getProvider()));
				host.resolvedAddresses = new IPAddress[] {this};
			} else {
				host = new HostName(hostStr);
			}
		}
		return host;
	}
	@Override
	public abstract IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	@Override
	public IPAddressSection getSection() {
		return (IPAddressSection) super.getSection();
	}
	@Override
	public IPAddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPAddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return new IPAddressStringDivisionSeries[] { getSection() };
	}
	@Override
	public int getMaxSegmentValue() {
		return IPAddressSegment.getMaxSegmentValue(getIPVersion());
	}
	static int getMaxSegmentValue(IPVersion version) {
		return IPAddressSegment.getMaxSegmentValue(version);
	}
	@Override
	public BigInteger getNonZeroHostCount() {
		return getSection().getNonZeroHostCount();
	}
	@Override
	public int getBytesPerSegment() {
		return IPAddressSegment.getByteCount(getIPVersion());
	}
	static int getBytesPerSegment(IPVersion version) {
		return IPAddressSegment.getByteCount(version);
	}
	@Override
	public int getBitsPerSegment() {
		return IPAddressSegment.getBitCount(getIPVersion());
	}
	static int getBitsPerSegment(IPVersion version) {
		return IPAddressSegment.getBitCount(version);
	}
	@Override
	public int getByteCount() {
		return getSection().getByteCount();
	}
	public static int getByteCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BYTE_COUNT : IPv6Address.BYTE_COUNT;
	}
	public static int getSegmentCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.SEGMENT_COUNT : IPv6Address.SEGMENT_COUNT;
	}
	public static int getBitCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BIT_COUNT : IPv6Address.BIT_COUNT;
	}
	protected abstract IPAddress convertArg(IPAddress arg) throws AddressConversionException;
	public <V> V applyToBounds(BiFunction<? super IPAddress, ? super IPAddress, V> func, IPAddress ...series) {
		AddressComparator lowComparator = Address.ADDRESS_LOW_VALUE_COMPARATOR;
		AddressComparator highComparator = Address.ADDRESS_HIGH_VALUE_COMPARATOR;
		IPAddress lowest = this;
		IPAddress highest = this;
		for(int i = 0; i < series.length; i++) {
			IPAddress next = series[i];
			if(next == null) {
				continue;
			}
			next = convertArg(next);
			if(lowComparator.compare(next, lowest) < 0) {
				lowest = next;
			}
			if(highComparator.compare(next, highest) > 0) {
				highest = next;
			}
		}
		return func.apply(lowest.getLower(), highest.getUpper());
	}
	@Override
	public abstract IPAddress getLowerNonZeroHost();
	@Override
	public abstract IPAddress getLower();
	@Override
	public abstract IPAddress getUpper();
	@Override
	public abstract IPAddress reverseBits(boolean perByte);
	@Override
	public abstract IPAddress reverseBytes();
	@Override
	public abstract IPAddress reverseBytesPerSegment();
	@Override
	public abstract IPAddress reverseSegments();
	@Override
	public abstract Iterator<? extends IPAddress> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> spliterator();
	@Override
	public abstract Stream<? extends IPAddress> stream();
	@Override
	public abstract Iterator<? extends IPAddress> nonZeroHostIterator();
	@Override
	public abstract Iterator<? extends IPAddress> prefixIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> prefixSpliterator();
	@Override
	public abstract Stream<? extends IPAddress> prefixStream();
	@Override
	public abstract Iterator<? extends IPAddress> prefixBlockIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends IPAddress> prefixBlockStream();
	@Override
	public abstract Iterator<? extends IPAddress> blockIterator(int segmentCount);
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> blockSpliterator(int segmentCount);
	@Override
	public abstract Stream<? extends IPAddress> blockStream(int segmentCount);
	@Override
	public Iterator<? extends IPAddress> sequentialBlockIterator() {
		return blockIterator(getSequentialBlockIndex());
	}
	@Override
	public AddressComponentSpliterator<? extends IPAddress> sequentialBlockSpliterator() {
		return blockSpliterator(getSequentialBlockIndex());
	}
	@Override
	public Stream<? extends IPAddress> sequentialBlockStream() {
		return blockStream(getSequentialBlockIndex());
	}
	@Override
	public BigInteger getSequentialBlockCount() {
		return getSection().getSequentialBlockCount();
	}
	@Override
	public abstract Iterable<? extends IPAddress> getIterable();
	@Override
	public abstract IPAddress increment(long increment) throws AddressValueException;
	@Override
	public abstract IPAddress incrementBoundary(long increment) throws AddressValueException;
	@Override
	public boolean isIPAddress() {
		return true;
	}
	@Override
	public IPAddress toIPAddress() {
		return this;
	}
	public boolean isIPv4() {
		return false;
	}
	public boolean isIPv6(){
		return false;
	}
	@Override
	public IPVersion getIPVersion() {
		return getSection().getIPVersion();
	}
	public IPv4Address toIPv4() {
		return null;
	}
	public IPv6Address toIPv6() {
		return null;
	}
	public abstract boolean isIPv4Convertible();
	public abstract boolean isIPv6Convertible();
	public abstract boolean isLinkLocal();
	@Override
	public abstract boolean isLocal();
	public boolean isUnspecified() {
		return isZero();
	}
	public boolean isAnyLocal() {
		return isZero();
	}
	public abstract boolean isLoopback();
	public InetAddress toUpperInetAddress() {
		return getUpper().toInetAddress();
	}
	public InetAddress toInetAddress() {
		return getSection().toInetAddress(this);
	}
	protected InetAddress toInetAddressImpl() {
		try {
			return InetAddress.getByAddress(getSection().getBytesInternal());
		} catch(UnknownHostException e) {  return null; }
	}
	@Override
	public abstract IPAddressSeqRange toSequentialRange();
	@Deprecated
	public abstract IPAddressSeqRange toSequentialRange(IPAddress other) throws AddressConversionException;
	public boolean matches(IPAddressString otherString) {
		if(isFromSameString(otherString)) {
			return true;
		}
		IPAddress otherAddr = otherString.getAddress();
		return otherAddr != null && isSameAddress(otherAddr);
	}
	@Override
	protected boolean isFromSameString(HostIdentifierString other) {
		if(fromString != null && other instanceof IPAddressString) {
			IPAddressString fromString = (IPAddressString) this.fromString;
			IPAddressString otherString = (IPAddressString) other;
			return (fromString == otherString || 
					(fromString.fullAddr.equals(otherString.fullAddr) &&
					fromString.validationOptions == otherString.validationOptions));
		}
		return false;
	}
	@Override
	public boolean overlaps(IPAddress other) {
		return super.overlaps(other);
	}
	@Override
	public boolean overlaps(IPAddressSeqRange other) {
		return other.overlaps(this);
	}
	@Override
	public boolean contains(IPAddress other) {
		return super.contains(other);
	}
	public boolean containsNonZeroHosts(IPAddress other) {
		if(other == this) {
			return true;
		}
		return getSection().containsNonZeroHosts(other.getSection());
	}
	@Override
	public abstract BigInteger enumerate(IPAddress other);
	public boolean prefixContains(IPAddress other) {
		if(other == this) {
			return true;
		}
		return getSection().prefixContains(other.getSection());
	}
	public boolean isZeroHost() {
		return getSection().isZeroHost();
	}
	public boolean isZeroHost(int networkPrefixLength) {
		return getSection().isZeroHost(networkPrefixLength);
	}
	@Override
	public boolean contains(IPAddressSeqRange otherRange) {
		return otherRange.isContainedBy(this);
	}
	public boolean matchesWithMask(IPAddress other, IPAddress mask) {
		return getSection().matchesWithMask(other.getSection(), mask.getSection());
	}
	public static void toNormalizedString(IPAddressValueProvider provider, StringBuilder builder) {
		IPVersion version = provider.getIPVersion();
		if(version.isIPv4()) {
			toNormalizedString(defaultIpv4Network().getPrefixConfiguration(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), IPv4Address.SEGMENT_COUNT,  IPv4Address.BYTES_PER_SEGMENT,  IPv4Address.BITS_PER_SEGMENT,  IPv4Address.MAX_VALUE_PER_SEGMENT,  IPv4Address.SEGMENT_SEPARATOR,  IPv4Address.DEFAULT_TEXTUAL_RADIX, null, builder);
		} else if(version.isIPv6()) {
			toNormalizedString(defaultIpv6Network().getPrefixConfiguration(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), IPv6Address.SEGMENT_COUNT, IPv6Address.BYTES_PER_SEGMENT, IPv6Address.BITS_PER_SEGMENT, IPv6Address.MAX_VALUE_PER_SEGMENT, IPv6Address.SEGMENT_SEPARATOR, IPv6Address.DEFAULT_TEXTUAL_RADIX, provider.getZone(), builder);
		} else {
			throw new IllegalArgumentException();
		}
	}
	public static String toNormalizedString(IPAddressValueProvider provider) {
		IPVersion version = provider.getIPVersion();
		if(version.isIPv4()) {
			return IPv4Address.toNormalizedString(defaultIpv4Network(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength());
		} else if(version.isIPv6()) {
			return IPv6Address.toNormalizedString(defaultIpv6Network(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), provider.getZone());
		}
		throw new IllegalArgumentException();
	}
	protected static String toNormalizedString(
			PrefixConfiguration prefixConfiguration,
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			Integer prefixLength,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			char separator,
			int radix,
			CharSequence zone) {
		int length = toNormalizedString(
				prefixConfiguration,
				lowerValueProvider,
				upperValueProvider,
				prefixLength,
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				segmentMaxValue,
				separator,
				radix,
				zone,
				null);
		StringBuilder builder = new StringBuilder(length);
		toNormalizedString(
				prefixConfiguration,
				lowerValueProvider,
				upperValueProvider,
				prefixLength,
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				segmentMaxValue,
				separator,
				radix,
				zone,
				builder);
		IPAddressSection.checkLengths(length, builder);
		return builder.toString();
	}
	protected static int toNormalizedString(
			PrefixConfiguration prefixConfiguration,
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			Integer prefixLength,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			char separator,
			int radix,
			CharSequence zone,
			StringBuilder builder) {
		int segmentIndex, count;
		segmentIndex = count = 0;
		boolean adjustByPrefixLength;
		if(prefixLength != null && prefixConfiguration.allPrefixedAddressesAreSubnets()) {
			if(prefixLength <= 0) {
				adjustByPrefixLength = true;
			} else {
				int totalBitCount = (bitsPerSegment == 8) ? segmentCount << 3 : ((bitsPerSegment == 16) ? segmentCount << 4 : segmentCount * bitsPerSegment);
				adjustByPrefixLength = prefixLength < totalBitCount;
			}
		} else {
			adjustByPrefixLength = false;
		}
		while(true) {
			Integer segmentPrefixLength = IPAddressSection.getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
			if(adjustByPrefixLength && segmentPrefixLength != null && segmentPrefixLength == 0) {
				if(builder == null) {
					count++;
				} else {
					builder.append('0');
				}
			} else {
				int value = 0, value2 = 0;
				if(lowerValueProvider == null) {
					value = upperValueProvider.getValue(segmentIndex);
				} else {
					value = lowerValueProvider.getValue(segmentIndex);
					if(upperValueProvider != null) {
						value2 = upperValueProvider.getValue(segmentIndex);
					}
				}
				if(lowerValueProvider == null || upperValueProvider == null) {
					if(adjustByPrefixLength && segmentPrefixLength != null) {
						value &= ~0 << (bitsPerSegment - segmentPrefixLength);
					}
					if(builder == null) {
						count += IPAddressSegment.toUnsignedStringLength(value, radix);
					} else {
						IPAddressSegment.toUnsignedString(value, radix, builder);
					}
				} else {
					if(adjustByPrefixLength && segmentPrefixLength != null) {
						int mask = ~0 << (bitsPerSegment - segmentPrefixLength);
						value &= mask;
						value2 &= mask;
					}
					if(value == value2) {
						if(builder == null) {
							count += IPAddressSegment.toUnsignedStringLength(value, radix);
						} else {
							IPAddressSegment.toUnsignedString(value, radix, builder);
						}
					} else {
						if(value > value2) {
							int tmp = value2;
							value2 = value;
							value = tmp;
						} 
						if(value == 0 && value2 == segmentMaxValue) {
							if(builder == null) {
								count += IPAddress.SEGMENT_WILDCARD_STR.length();
							} else {
								builder.append(IPAddress.SEGMENT_WILDCARD_STR);
							}
						} else {
							if(builder == null) {
								count += IPAddressSegment.toUnsignedStringLength(value, radix) + 
										IPAddressSegment.toUnsignedStringLength(value2, radix) + 
										IPAddress.RANGE_SEPARATOR_STR.length();
							} else {
								IPAddressSegment.toUnsignedString(value2, radix, IPAddressSegment.toUnsignedString(value, radix, builder).append(IPAddress.RANGE_SEPARATOR_STR));
							}
						}
					}
				}
			}
			if(++segmentIndex >= segmentCount) {
				break;
			}
			if(builder != null) {
				builder.append(separator);
			} 
		}
		if(builder == null) {
			count += segmentCount; 
			--count; 
		}
		if(zone != null && zone.length() > 0) {
			if(builder == null) {
				count += zone.length() + 1;
			} else {
				builder.append(IPv6Address.ZONE_SEPARATOR).append(zone);
			}
		}
		if(prefixLength != null) {
			if(builder == null) {
				count += IPAddressSegment.toUnsignedStringLength(prefixLength, 10) + 1;
			} else {
				builder.append(IPAddress.PREFIX_LEN_SEPARATOR).append(prefixLength);
			}
		} 
		return count;
	}
	@Override
	public String toFullString() {
		return getSection().toFullString();
	}
	protected void cacheNormalizedString(String str) {
		getSection().cacheNormalizedString(str);
	}
	@Override
	public String toSubnetString() {
		return getSection().toSubnetString();
	}
	@Override
	public String toNormalizedWildcardString() {
		return getSection().toNormalizedWildcardString();
	}
	@Override
	public String toCanonicalWildcardString() {
		return getSection().toCanonicalWildcardString();
	}
	@Override
	public String toCompressedWildcardString() {
		return getSection().toCompressedWildcardString();
	}
	@Override
	public String toSQLWildcardString() {
		 return getSection().toSQLWildcardString();
	}
	@Override
	public String toPrefixLengthString() {
		return getSection().toPrefixLengthString();
	}
	public String toConvertedString() {
		return toNormalizedString();
	}
	public abstract String toUNCHostName();
	@Override
	public String toReverseDNSLookupString() {
		return getSection().toReverseDNSLookupString();
	}
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		return getSection().toBinaryString();
	}
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {
		return getSection().toOctalString(with0Prefix);
	}
	@Override
	public String toNormalizedString(IPStringOptions params) {
		return getSection().toNormalizedString(params);
	}
	public String[] toStandardStrings() {
		return toStandardStringCollection().toStrings();
	}
	public String[] toAllStrings() {
		return toAllStringCollection().toStrings();
	}
	public String[] toStrings(IPStringBuilderOptions options) {
		return toStringCollection(options).toStrings();
	}
	public IPAddressPartStringCollection toStandardStringCollection() {
		return getSection().toStandardStringCollection();
	}
	public IPAddressPartStringCollection toAllStringCollection() {
		return getSection().toAllStringCollection();
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions options) {
		return getSection().toStringCollection(options);
	}
	public static String toDelimitedSQLStrs(String strs[]) {
		if(strs.length == 0) {
			return "";
		}
		StringBuilder builder = new StringBuilder();
		for(String str : strs) {
			builder.append('\'').append(str).append('\'').append(',');
		}
		return builder.substring(0, builder.length() - 1);
	}
	@Override
	public Integer getNetworkPrefixLength() {
		return getSection().getNetworkPrefixLength();
	}
	@Override
	public IPAddress getHostMask() {
		Integer prefLength = getNetworkPrefixLength();
		return getNetwork().getHostMask(prefLength == null ? 0 : prefLength);
	}
	@Override
	public IPAddress getNetworkMask() {
		Integer prefLength = getNetworkPrefixLength();
		return getNetwork().getNetworkMask(prefLength == null ? getBitCount() : prefLength);
	}
	@Override
	public boolean includesZeroHost() {
		return getSection().includesZeroHost();
	}
	@Override
	public boolean includesZeroHost(int networkPrefixLength) {
		return getSection().includesZeroHost(networkPrefixLength);
	}
	@Override
	public abstract IPAddress toZeroHost(int prefixLength);
	@Override
	public abstract IPAddress toZeroHost();
	protected abstract IPAddress toZeroHost(boolean boundariesOnly);
	@Override
	public abstract IPAddress toZeroNetwork();
	@Override
	public abstract IPAddress toMaxHost(int prefixLength);
	@Override
	public abstract IPAddress toMaxHost();
	@Override
	public boolean includesMaxHost() {
		return getSection().includesMaxHost();
	}
	@Override
	public boolean includesMaxHost(int networkPrefixLength) {
		return getSection().includesMaxHost(networkPrefixLength);
	}
	public boolean isSingleNetwork() {
		return getSection().isSingleNetwork();
	}
	protected static <T extends IPAddress> T[] getSpanningPrefixBlocks(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator,
			UnaryOperator<T> prefixAdder,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		T result = checkPrefixBlockContainment(first, other, prefixAdder);
		if(result != null) {
			T resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		List<IPAddressSegmentSeries> blocks = 
				IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, (orig, one, two) -> IPAddressSection.splitIntoPrefixBlocks(one, two));
		return blocks.toArray(arrayProducer.apply(blocks.size()));
	}
	private static <T extends IPAddress> T checkPrefixBlockContainment(
			T first,
			T other,
			UnaryOperator<T> prefixAdder) {
		if(first.contains(other)) {
			return checkPrefixBlockFormat(first, other, true, prefixAdder);
		} else if(other.contains(first)) {
			return checkPrefixBlockFormat(other, first, false, prefixAdder);
		}
		return null;
	}
	static <T extends IPAddressSegmentSeries> T checkPrefixBlockFormat(
			T container,
			T contained,
			boolean checkEqual,
			UnaryOperator<T> prefixAdder) {
		T result = null;
		if(container.isPrefixed() && container.isSinglePrefixBlock()) {
			result = container;
		} else if(checkEqual && contained.isPrefixed() && container.isMore(contained) == 0 && contained.isSinglePrefixBlock()) {
			result = contained;
		} else {
			result = prefixAdder.apply(container); 
		}
		return result;
	}
	protected static <T extends IPAddress, S extends IPAddressSegment> T[] getSpanningSequentialBlocks(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator,
			UnaryOperator<T> prefixRemover,
			IPAddressCreator<T, ?, ?, S, ?> creator) {
		T[] result = checkSequentialBlockContainment(first, other, prefixRemover, creator::createAddressArray);
		if(result != null) {
			return result;
		}
		SeriesCreator seriesCreator = creator::createSequentialBlockAddress;
		TriFunction<T, List<IPAddressSegmentSeries>> operatorFunctor = (orig, one, two) -> IPAddressSection.splitIntoSequentialBlocks(one, two, seriesCreator);
		List<IPAddressSegmentSeries> blocks = IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, operatorFunctor);
		return blocks.toArray(creator.createAddressArray(blocks.size()));
	}
	private static <T extends IPAddress> T[] checkSequentialBlockContainment(
			T first,
			T other,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		if(first.contains(other)) {
			return checkSequentialBlockFormat(first, other, true, prefixRemover, arrayProducer);
		} else if(other.contains(first)) {
			return checkSequentialBlockFormat(other, first, false, prefixRemover, arrayProducer);
		}
		return null;
	}
	static <T extends IPAddressSegmentSeries> T[] checkSequentialBlockFormat(
			T container,
			T contained,
			boolean checkEqual,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		T result = null;
		if(!container.isPrefixed()) {
			if(container.isSequential()) {
				result = container;
			}
		} else if(checkEqual && !contained.isPrefixed() && container.equals(contained)) {
			if(contained.isSequential()) {
				result = contained;
			}
		} else if(container.isSequential()) {
			result = prefixRemover.apply(container);
		}
		if(result != null) {
			T resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		return null;
	}
	@Override
	public abstract IPAddress toPrefixBlock();
	@Override
	public abstract IPAddress toPrefixBlock(int networkPrefixLength) throws PrefixLenException;
	@Override
	public IPAddress assignPrefixForSingleBlock() {
		Integer newPrefix = getPrefixLengthForSingleBlock();
		return newPrefix == null ? null : setPrefixLength(newPrefix, false);
	}
	@Override
	public IPAddress assignMinPrefixForBlock() {
		return setPrefixLength(getMinPrefixLengthForBlock(), false);
	}
	public Integer getBlockMaskPrefixLength(boolean network) {
		return getSection().getBlockMaskPrefixLength(network);
	}
	public int getTrailingBitCount(boolean network) {
		return getSection().getTrailingBitCount(network);
	}
	public int getLeadingBitCount(boolean network) {
		return getSection().getLeadingBitCount(network);
	}
	public abstract IPAddress coverWithPrefixBlock(IPAddress other) throws AddressConversionException;
	public abstract IPAddress[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException;
	public abstract IPAddress[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException;
	protected List<? extends IPAddressSegmentSeries> spanWithBlocks(boolean prefixBlocks) {
		return spanWithBlocks(this, prefixBlocks);
	}
	static List<? extends IPAddressSegmentSeries> spanWithBlocks(IPAddressSegmentSeries orig, boolean prefixBlocks) {
		ArrayList<IPAddressSegmentSeries> list = new ArrayList<IPAddressSegmentSeries>();
		Iterator<? extends IPAddressSegmentSeries> iterator = orig.sequentialBlockIterator();
		while(iterator.hasNext()) {
			IPAddressSegmentSeries sequential = iterator.next();
			if(prefixBlocks) {
				Collections.addAll(list, sequential.spanWithPrefixBlocks());	
			} else {
				Collections.addAll(list, sequential);
			}
		}
		return list;
	}
	public abstract IPAddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException;
	public abstract IPAddress[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException;
	protected static List<IPAddressSegmentSeries> getMergedPrefixBlocks(IPAddressSegmentSeries sections[]) {
		return IPAddressSection.getMergedPrefixBlocks(sections);
	}
	private static final IPv6Address EMPTY_IPV6_ADDRESS[] = {};
	private static final IPv4Address EMPTY_IPV4_ADDRESS[] = {};
	public static class DualIPv4Pv6Arrays {
		public final IPv4Address addressesIPv4[];
		public final IPv6Address addressesIPv6[];
		DualIPv4Pv6Arrays(IPv4Address addressesIPv4[], IPv6Address addressesIPv6[]) {
			this.addressesIPv4 = addressesIPv4;
			this.addressesIPv6 = addressesIPv6;
		}
	}
	public static DualIPv4Pv6Arrays mergeToDualSequentialBlocks(IPAddress ...addresses) {
		Function<IPAddressSegmentSeries[], List<IPAddressSegmentSeries>> merger = (series) -> {
			SeriesCreator seriesCreator = ((IPAddress) series[0]).getSequentialSeriesCreator();
			return IPAddressSection.getMergedSequentialBlocks(series, seriesCreator);
		};
		return mergeToBlocks(addresses, merger);
	}
	protected abstract SeriesCreator getSequentialSeriesCreator();
	public static DualIPv4Pv6Arrays mergeToDualPrefixBlocks(IPAddress ...addresses) {
		return mergeToBlocks(addresses, IPAddressSection::getMergedPrefixBlocks);
	}
	private static DualIPv4Pv6Arrays mergeToBlocks(
			IPAddress addresses[], 
			Function<IPAddressSegmentSeries[], List<IPAddressSegmentSeries>> merger) {
		ArrayList<IPAddress> ipv4List = null;
		ArrayList<IPAddress> ipv6List = null;
		for(int i = 0; i < addresses.length; i++) {
			IPAddress addr = addresses[i];
			if(addr != null) {
				if(addr.isIPv4()) {
					if(ipv4List == null) {
						ipv4List = new ArrayList<IPAddress>(addresses.length);
					}
					ipv4List.add(addr);
				} else if(addr.isIPv6()) {
					if(ipv6List == null) {
						ipv6List = new ArrayList<IPAddress>(addresses.length);
					}
					ipv6List.add(addr);
				}
			}
		}
		IPv4Address addressesIPv4[];
		if(ipv4List != null){
			List<IPAddressSegmentSeries> blocks = merger.apply(ipv4List.toArray(new IPAddressSegmentSeries[ipv4List.size()]));
			addressesIPv4 = blocks.toArray(new IPv4Address[blocks.size()]);
		} else {
			addressesIPv4 = EMPTY_IPV4_ADDRESS;
		}
		IPv6Address addressesIPv6[];
		if(ipv6List != null){
			List<IPAddressSegmentSeries> blocks = merger.apply(ipv6List.toArray(new IPAddressSegmentSeries[ipv6List.size()]));
			addressesIPv6 = blocks.toArray(new IPv6Address[blocks.size()]);
		} else {
			addressesIPv6 = EMPTY_IPV6_ADDRESS;
		}
		return new DualIPv4Pv6Arrays(addressesIPv4, addressesIPv6);
	}
	public abstract IPAddress[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException;
	protected static <T extends IPAddress, S extends IPAddressSegment> List<IPAddressSegmentSeries> getMergedSequentialBlocks(IPAddressSegmentSeries sections[], IPAddressCreator<T, ?, ?, S, ?> creator) {
		return IPAddressSection.getMergedSequentialBlocks(sections, creator::createSequentialBlockAddress);
	}
	public abstract IPAddress intersect(IPAddress other) throws AddressConversionException;
	public abstract IPAddress[] subtract(IPAddress other) throws AddressConversionException;
	public abstract IPAddress mask(IPAddress mask) throws AddressConversionException, IncompatibleAddressException;
	public abstract IPAddress mask(IPAddress mask, boolean retainPrefix) throws AddressConversionException, IncompatibleAddressException;
	public abstract IPAddress maskNetwork(IPAddress mask, int networkPrefixLength) throws AddressConversionException, IncompatibleAddressException;
	public abstract IPAddress bitwiseOr(IPAddress mask) throws AddressConversionException, IncompatibleAddressException;
	public abstract IPAddress bitwiseOr(IPAddress mask, boolean retainPrefix) throws AddressConversionException, IncompatibleAddressException;
	public abstract IPAddress bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws AddressConversionException, IncompatibleAddressException;
	@Override @Deprecated
	public abstract IPAddress removePrefixLength();
	@Override @Deprecated
	public abstract IPAddress removePrefixLength(boolean zeroed);
	@Override
	public abstract IPAddress withoutPrefixLength();
	@Override
	public abstract IPAddress adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract IPAddress adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	@Override
	public abstract IPAddress adjustPrefixLength(int adjustment);
	@Override
	public abstract IPAddress adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	public abstract IPAddress setPrefixLength(int prefixLength);
	@Override
	public abstract IPAddress setPrefixLength(int prefixLength, boolean zeroed);
	public abstract IPAddress setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock);
	@Deprecated
	@Override
	public abstract IPAddress applyPrefixLength(int networkPrefixLength);
	public void getMatchesSQLClause(StringBuilder builder, String sqlExpression) {
		getSection().getStartsWithSQLClause(builder, sqlExpression);
	}
	public void getMatchesSQLClause(StringBuilder builder, String sqlExpression, IPAddressSQLTranslator translator) {
		getSection().getStartsWithSQLClause(builder, sqlExpression, translator);
	}
	public IPAddress removeBitCountPrefixLength() {
		if(isPrefixed() && getNetworkPrefixLength() == getBitCount()) {
			return this.withoutPrefixLength();
		}
		return this;
	}
}
package inet.ipaddr.format.validate;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.Objects;
import inet.ipaddr.Address;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.HostIdentifierString;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.IPAddressSeqRange;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.format.AddressItem;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.format.large.IPAddressLargeDivision;
import inet.ipaddr.format.large.IPAddressLargeDivisionGrouping;
import inet.ipaddr.format.standard.IPAddressBitsDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv4.IPv4AddressSegment;
import inet.ipaddr.ipv4.IPv4AddressSeqRange;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.ipv6.IPv6AddressSegment;
public class ParsedIPAddress extends IPAddressParseData implements IPAddressProvider {
	private static final long serialVersionUID = 4L;
	private static final ExtendedMasker DEFAULT_MASKER = new ExtendedMasker(true);
	private static final ExtendedMasker DEFAULT_NON_SEQUENTIAL_MASKER = new ExtendedMasker(false);
	private static final ExtendedFullRangeMasker EXTENDED_FULL_RANGE_MASKERS[] = new ExtendedFullRangeMasker[(Long.SIZE << 1) + 1];
	private static final ExtendedFullRangeMasker EXTENDED_SEQUENTIAL_FULL_RANGE_MASKERS[] = new ExtendedFullRangeMasker[(Long.SIZE << 1) + 1];
	private static final WrappedMasker WRAPPED_FULL_RANGE_MASKERS[] = new WrappedMasker[Long.SIZE + 1];
	private static final WrappedMasker WRAPPED_SEQUENTIAL_FULL_RANGE_MASKERS[] = new WrappedMasker[Long.SIZE + 1];
	private static final FullRangeMasker FULL_RANGE_MASKERS[] = new FullRangeMasker[Long.SIZE + 1];
	private static final FullRangeMasker SEQUENTIAL_FULL_RANGE_MASKERS[] = new FullRangeMasker[Long.SIZE + 1];
	private static final BitwiseOrer DEFAULT_OR_MASKER = new BitwiseOrer(true);
	private static final BitwiseOrer DEFAULT_NON_SEQUENTIAL_OR_MASKER = new BitwiseOrer(false);
	private static final FullRangeBitwiseOrer FULL_RANGE_OR_MASKERS[] = new FullRangeBitwiseOrer[Long.SIZE + 1];
	private static final FullRangeBitwiseOrer SEQUENTIAL_FULL_RANGE_OR_MASKERS[] = new FullRangeBitwiseOrer[Long.SIZE + 1];
	private static final BigInteger ONE_EXTENDED = new BigInteger(1, new byte[] {1, 0, 0, 0, 0, 0, 0, 0, 0});
	private static final BigInteger HIGH_BIT = new BigInteger(1, new byte[] {(byte) 0x80, 0, 0, 0, 0, 0, 0, 0});
	private static final BigInteger ONE_SHIFTED[] = new BigInteger[64];
	private static final BigInteger ONE_SHIFTED_EXTENDED[] = new BigInteger[64];
	private static final BigInteger NETWORK_MASK_EXTENDED[] = new BigInteger[64];
	private static final BigInteger HOST_MASK_EXTENDED[] = new BigInteger[64];
	static class CachedIPAddresses<T extends IPAddress> implements Serializable {
		private static final long serialVersionUID = 4L;
		protected T address, hostAddress;
		CachedIPAddresses() {}
		public CachedIPAddresses(T address) {
			this(address, address);
		}
		public CachedIPAddresses(T address, T hostAddress) {
			this.address = address;
			this.hostAddress = hostAddress;
		}
		public T getAddress() {
			return address;
		}
		public T getHostAddress() {
			return hostAddress;
		}
	}
	abstract class TranslatedResult<T extends IPAddress, R extends IPAddressSection> extends CachedIPAddresses<T> {
		private static final long serialVersionUID = 4L;
		private R section, hostSection, lowerSection, upperSection;
		private IncompatibleAddressException joinHostException, joinAddressException , mixedException, maskException;
		private IPAddressSeqRange range;
		private T rangeLower, rangeUpper;
		private IPAddressDivisionSeries series;
		abstract ParsedAddressCreator<T, R, ?, ?> getCreator();
		@Override
		public T getAddress() {
			if(address == null) {
				if(range == null) {
					address = getCreator().createAddressInternal(section, getZone(), originator);
				} else {
					address = getCreator().createAddressInternal(section, getZone(), originator, rangeLower, rangeUpper);
				}
			}
			return address;
		}
		boolean hasLowerSection() {
			return lowerSection != null;
		}
		boolean hasHostAddress() {
			return hostAddress != null;
		}
		boolean hasAddress() {
			return address != null;
		}
		@Override
		public T getHostAddress() {
			if(hostSection == null) {
				return getAddress();
			}
			if(hostAddress == null) {
				hostAddress = getCreator().createAddressInternal(hostSection, getZone(), null);
			}
			return hostAddress;
		}
		R getSection() {
			return section;
		}
		private CharSequence getZone() {
			return getQualifier().getZone();
		}
		boolean withoutSections() {
			return section == null;
		}
		boolean withoutAddressException() {
			return joinAddressException == null && mixedException == null && maskException == null;
		}
		boolean withoutRange() {
			return range == null;
		}
		boolean withoutGrouping() {
			return series == null;
		}
		IPAddressSeqRange createRange() {
			rangeLower = getCreator().createAddressInternal(lowerSection, getZone(), null);
			rangeUpper = upperSection == null ? rangeLower : getCreator().createAddressInternal(upperSection, getZone(), null);
			return range = rangeLower.spanWithRange(rangeUpper);
		}
		IPAddress getValForMask() {
			return getCreator().createAddressInternal(lowerSection, null, null);
		}
	}
	private final IPAddressStringParameters options;
	private final HostIdentifierString originator;
	private TranslatedResult<?,?> values;
	private Masker maskers[];
	private Masker mixedMaskers[];
	ParsedIPAddress(
			HostIdentifierString from, 
			CharSequence addressString,
			IPAddressStringParameters options) {
		super(addressString);
		this.options = options;
		this.originator = from;
	}
	private IPv6AddressCreator getIPv6AddressCreator() {
		return getParameters().getIPv6Parameters().getNetwork().getAddressCreator();
	}
	private IPv4AddressCreator getIPv4AddressCreator() {
		return getParameters().getIPv4Parameters().getNetwork().getAddressCreator();
	}
	@Override
	public boolean isProvidingIPAddress() {
		return true;
	}
	@Override
	public IPAddressProvider.IPType getType() {
		return IPType.from(getProviderIPVersion());
	}
	@Override
	public IPAddressStringParameters getParameters() {
		return options;
	}
	void createSections(boolean doAddress, boolean doRangeBoundaries, boolean withUpper) {
		IPVersion version = getProviderIPVersion();
		if(version.isIPv4()) {
			createIPv4Sections(doAddress, doRangeBoundaries, withUpper);
		} else if(version.isIPv6()) {
			createIPv6Sections(doAddress, doRangeBoundaries, withUpper);
		}
	}
	@Override
	public IPAddressSeqRange getProviderSeqRange() {
		TranslatedResult<?,?> val = values;
		if(val == null || val.range == null) {
			synchronized(this) {
				val = values;
				if(val == null || val.range == null) {
					if(val != null && !val.withoutSections() && val.withoutAddressException()) {
						val.range = val.getAddress().toSequentialRange();
					} else {
						createSections(false, true, true);
						val = values;
						val.createRange();
						if(isDoneTranslating()) {
							releaseSegmentData();
						}
					}
				}
			}
		}
		return val.range;
	}
	IPAddress getValForMask() {
		TranslatedResult<?,?> val = values;
		if(val == null || !val.hasLowerSection()) {
			synchronized(this) {
				val = values;
				if(val == null || !val.hasLowerSection()) {
					createSections(false, true, false);
					val = values;
					releaseSegmentData(); 
				}
			}
		}
		return val.getValForMask();
	}
	@Override
	public IPAddress getProviderMask() {
		return getQualifier().getMaskLower();
	}
	boolean isDoneTranslating() {
		TranslatedResult<?,?> val = values;
		return !val.withoutSections()  && 
				(val.withoutAddressException() 
						|| !val.withoutRange() ) &&
				!val.withoutGrouping();
	}
	TranslatedResult<?,?> getCachedAddresses(boolean forHostAddr)  {
		TranslatedResult<?,?> val = values;
		if(val == null || val.withoutSections()) {
			synchronized(this) {
				val = values;
				if(val == null || val.withoutSections()) {
					createSections(true, false, false);
					val = values;
					if(isDoneTranslating()) {
						releaseSegmentData();
					}
				} 
				if(forHostAddr) {
					val.getHostAddress();
				} else {
					val.getAddress();
				}
			}
		} else {
			if(forHostAddr ? !val.hasHostAddress() : !val.hasAddress()) {
				synchronized(this) {
					if(forHostAddr) {
						val.getHostAddress();
					} else {
						val.getAddress();
					}
				}
			}
		}
		return val;
	}
	@Override
	public IPAddress getProviderHostAddress() throws IncompatibleAddressException {
		TranslatedResult<?,?> addrs = getCachedAddresses(true);
		if(addrs.mixedException != null) {
			throw addrs.mixedException;
		} else if(addrs.joinHostException != null) {
			throw addrs.joinHostException;
		}
		return addrs.getHostAddress();
	}
	@Override
	public IPAddress getProviderAddress() throws IncompatibleAddressException {
		TranslatedResult<?,?> addrs = getCachedAddresses(false);
		if(addrs.mixedException != null) {
			throw addrs.mixedException;
		} else if(addrs.maskException != null) {
			throw addrs.maskException;
		} else if(addrs.joinAddressException != null) {
			throw addrs.joinAddressException;
		}
		return addrs.getAddress();
	}
	@Override
	public IPAddress getProviderAddress(IPVersion version) throws IncompatibleAddressException {
		IPVersion thisVersion = getProviderIPVersion();
		if(!version.equals(thisVersion)) {
			return null;
		}
		return getProviderAddress();
	}
	@Override
	public IPAddressDivisionSeries getDivisionGrouping() throws IncompatibleAddressException {
		TranslatedResult<?,?> val = values;
		IPAddressDivisionSeries grouping = null;
		if(val != null) {
			grouping = val.series;
			if(grouping != null) {
				return grouping;
			}
		}		
		if(val == null || (val.withoutSections() && val.withoutRange())) {
			synchronized(this) {
				val = values;
				if(val == null || (val.withoutSections() && val.withoutRange())) {
					createSections(true, false, false); 
				}
			}
		}
		val = values;
		grouping = val.series;
		if(grouping == null) {
			synchronized(val) {
				grouping = val.series;
				if(grouping == null) {
					ParsedHostIdentifierStringQualifier qualifier = getQualifier();
					IPVersion version = getProviderIPVersion();
					int defaultRadix;
					IPAddressNetwork<?, ?, ?, ?, ?> network;
					if(version.isIPv4()) {
						defaultRadix = IPv4Address.DEFAULT_TEXTUAL_RADIX;
						network = getParameters().getIPv4Parameters().getNetwork();
					} else {
						defaultRadix = IPv6Address.DEFAULT_TEXTUAL_RADIX;
						network = getParameters().getIPv6Parameters().getNetwork();
					}
					PrefixConfiguration prefixConfiguration = network.getPrefixConfiguration();
					boolean mixed = isProvidingMixedIPv6();
					AddressParseData addrParseData = getAddressParseData();
					int segmentCount = addrParseData.getSegmentCount();
					int totalCount = segmentCount;
					if(mixed) {
						totalCount += mixedParsedAddress.getSegmentCount();
					}
					Integer prefLength = getPrefixLength(qualifier);
					IPAddress mask = getProviderMask();
					if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
						mask = null;
					}
					boolean hasMask = mask != null;
					boolean isPrefixSubnet = false;
					if(prefLength != null) {
						if(prefixConfiguration.allPrefixedAddressesAreSubnets()) {
							isPrefixSubnet = true;
						} else if(prefixConfiguration.zeroHostsAreSubnets()) {
							if(mixed) {
								int k = segmentCount;
								isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_LOWER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_LOWER)),
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_EXTENDED_LOWER)),
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_UPPER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_UPPER)),
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_EXTENDED_UPPER)),
										i -> (i < k ? addrParseData.getBitLength(i) : mixedParsedAddress.getBitLength(i - k)),
										totalCount,
										prefLength,
										prefixConfiguration,
										false);
							} else {
								isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
										i -> addrParseData.getValue(i, AddressParseData.KEY_LOWER),
										i -> addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER),
										i -> addrParseData.getValue(i, AddressParseData.KEY_UPPER),
										i -> addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER),
										i -> addrParseData.getBitLength(i),
										totalCount,
										prefLength,
										prefixConfiguration,
										false);
							}
						} else {
							isPrefixSubnet = false;
						}
					}
					boolean isLarge = false;
					for(int i = 0; i < segmentCount; i++) {
						int bitLength = addrParseData.getBitLength(i);
						if(bitLength >= Long.SIZE) {
							isLarge = true;
							break;
						}
					}
					boolean isMergedMixed;
					if(mixed && (isMergedMixed = addrParseData.isMergedMixed(segmentCount - 1))) {
						totalCount--;
						segmentCount--;
						if(!isLarge && addrParseData.getBitLength(segmentCount) + mixedParsedAddress.getBitLength(0) >= Long.SIZE) {
							isLarge = true;
						}
					} else {
						isMergedMixed = false;
					}
					long maskVal = 0, extendedMaskVal = 0;
					int maskBits = 0;
					if(hasMask) {
						int bitsPerSegment = mask.getBitsPerSegment();
						for(int i = 0; i < IPv4Address.SEGMENT_COUNT; i++) {
							maskVal = (maskVal << bitsPerSegment) | mask.getSegment(i).getSegmentValue();
						}
						if(mask.isIPv6()) {
							extendedMaskVal = maskVal; maskVal = 0;
							int remainingSegs = IPv6Address.SEGMENT_COUNT >> 1;
							for(int i = 0; i < remainingSegs; i++) {
								maskVal = (maskVal << bitsPerSegment) | mask.getSegment(i + IPv4Address.SEGMENT_COUNT).getSegmentValue();
							}
							maskBits = bitsPerSegment * IPv6Address.SEGMENT_COUNT;
						} else {
							maskBits = bitsPerSegment * IPv4Address.SEGMENT_COUNT;
						}
					}
					int bitsSoFar = 0;
					int divRadix;
					if(isLarge) {
						IPAddressLargeDivision divs[] = new IPAddressLargeDivision[totalCount];
						for(int i = 0; i < totalCount; i++) {
							long lower, upper, extendedLower, extendedUpper;
							int bitLength;
							boolean isExtended;
							boolean isNotMixed = i < segmentCount;
							if(isNotMixed) {
								bitLength = addrParseData.getBitLength(i);
								isExtended = bitLength > Long.SIZE;
								if(addrParseData.isWildcard(i)) {
									extendedLower = lower = 0;
									if(isExtended) {
										upper = 0xffffffffffffffffL;
										int shift = bitLength - Long.SIZE;
										extendedUpper = shift == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << shift);
									} else {
										extendedUpper = 0;
										upper = bitLength == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << bitLength);
									}
								} else {
									lower = addrParseData.getValue(i, AddressParseData.KEY_LOWER);
									upper = addrParseData.getValue(i, AddressParseData.KEY_UPPER);
									extendedLower = addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER);
									extendedUpper = addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER);
								}
								divRadix = defaultRadix;
							} else if(isMergedMixed && i == segmentCount) {
								isNotMixed = true;
								bitLength = addrParseData.getBitLength(i) + mixedParsedAddress.getBitLength(0);
								extendedLower = lower = 0;
								isExtended = bitLength > Long.SIZE;
								if(isExtended) {
									upper = 0xffffffffffffffffL;
									int shift = bitLength - Long.SIZE;
									extendedUpper = shift == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << shift);
								} else {
									upper = bitLength == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << bitLength);
									extendedUpper = 0;
								}
								divRadix = defaultRadix;
							} else {
								int adjusted = i - segmentCount;
								bitLength = mixedParsedAddress.getBitLength(adjusted);
								isExtended = false;
								extendedLower = extendedUpper = 0;
								if(mixedParsedAddress.isWildcard(adjusted)) {
									lower = 0;
									upper =  ~(~0L << bitLength);
								} else {
									lower = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_LOWER);
									upper = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_UPPER);
								}
								divRadix = IPv4Address.DEFAULT_TEXTUAL_RADIX;
							}
							Integer divPrefixLength;
							if(prefLength == null) {
								divPrefixLength = null;
								if(hasMask) {
									ExtendedMasker masker = (ExtendedMasker) (isNotMixed ? maskers[i] : mixedParsedAddress.maskers[i]);
									if(!masker.isSequential()) {
										throw new IncompatibleAddressException(lower, upper, (extendedMaskVal << 64) | maskVal, "ipaddress.error.maskMismatch");
									}
									long divMask;
									if(isExtended) {
										int extraMaskBits = maskBits - bitLength;
										long extendedDivMask = extendedMaskVal >>> extraMaskBits;
										divMask = (maskVal >>> extraMaskBits) | (extendedMaskVal << (Long.SIZE - extraMaskBits));
										extendedLower = masker.getExtendedMaskedLower(extendedLower, extendedDivMask);
										extendedUpper = masker.getExtendedMaskedUpper(extendedUpper, extendedDivMask);
										lower = masker.getMaskedLower(lower, divMask);
										upper = masker.getMaskedUpper(upper, divMask);
									} else {
										if(maskBits > Long.SIZE) {
											int extendedBits = maskBits - Long.SIZE;
											if(extendedBits >= bitLength) {
												divMask = extendedMaskVal >>> (extendedBits - bitLength);
											} else {
												int shortBits = bitLength - extendedBits;
												divMask = (extendedMaskVal << (shortBits)) | (maskVal >> (Long.SIZE - shortBits));
											}
										} else {
											divMask = maskVal >>> (maskBits - bitLength);
										}
										lower = masker.getMaskedLower(lower, divMask);
										upper = masker.getMaskedUpper(upper, divMask);
									}
									maskBits -= bitLength;
								}
							} else {
								divPrefixLength = ParsedAddressGrouping.getDivisionPrefixLength(bitLength, prefLength - bitsSoFar);
								if(isPrefixSubnet && divPrefixLength != null && divPrefixLength < bitLength) {
									int unextendedBitLength, unextendedDivPrefixLength;
									if(isExtended) {
										int extendedDivBitLength = bitLength - Long.SIZE;
										unextendedBitLength = Long.SIZE;
										if(divPrefixLength > extendedDivBitLength) {
											unextendedDivPrefixLength = divPrefixLength - extendedDivBitLength;
										} else {
											unextendedDivPrefixLength = 0;
											int shift = extendedDivBitLength - divPrefixLength;
											if(shift == Long.SIZE) {
												extendedLower = 0;
												extendedUpper = 0xffffffffffffffffL;
											} else {
												long networkMask = ~0L << shift;
												extendedLower = extendedLower & networkMask;
												extendedUpper = extendedUpper | ~networkMask;
											}
										}
									} else {
										unextendedBitLength = bitLength;
										unextendedDivPrefixLength = divPrefixLength;
									}
									int shift = unextendedBitLength - unextendedDivPrefixLength;
									if(shift == Long.SIZE) {
										lower = 0;
										upper = 0xffffffffffffffffL;
									} else {
										long networkMask = ~0L << shift;
										lower = lower & networkMask;
										upper = upper | ~networkMask;
									}
								}
							}
							int numBytes = (bitLength + 7) / Byte.SIZE;
							byte lowerBytes[] = toBytes(lower, extendedLower, numBytes);
							byte upperBytes[] = toBytes(upper, extendedUpper, numBytes);
							divs[i] = new IPAddressLargeDivision(lowerBytes, upperBytes, bitLength, divRadix, network, divPrefixLength);
							bitsSoFar += bitLength;
						}
						grouping = new IPAddressLargeDivisionGrouping(divs, network);
					} else {
						IPAddressBitsDivision divs[] = new IPAddressBitsDivision[totalCount];
						for(int i = 0; i < totalCount; i++) {
							long lower, upper;
							int bitLength;
							if(i < segmentCount) {
								bitLength = addrParseData.getBitLength(i);
								if(addrParseData.isWildcard(i)) {
									lower = 0;
									upper = ~(~0L << bitLength);
								} else {
									lower = addrParseData.getValue(i, AddressParseData.KEY_LOWER);
									upper = addrParseData.getValue(i, AddressParseData.KEY_UPPER);
								}
								divRadix = defaultRadix;
							} else if(isMergedMixed && i == segmentCount) {
								bitLength = addrParseData.getBitLength(i) + mixedParsedAddress.getBitLength(0);
								lower = 0;
								upper = ~(~0L << bitLength);
								divRadix = defaultRadix;
							} else {
								int adjusted = i - segmentCount;
								bitLength = mixedParsedAddress.getBitLength(adjusted);
								if(mixedParsedAddress.isWildcard(adjusted)) {
									lower = 0;
									upper =  ~(~0L << bitLength);
								} else {
									lower = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_LOWER);
									upper = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_UPPER);
								}
								divRadix = IPv4Address.DEFAULT_TEXTUAL_RADIX;
							}
							Integer divPrefixLength;
							if(prefLength == null) {
								divPrefixLength = null;
								if(hasMask) {
									Masker masker = maskers[i];
									if(!masker.isSequential()) {
										throw new IncompatibleAddressException(lower, upper, maskVal, "ipaddress.error.maskMismatch");
									}
									long divMask;
									if(maskBits > Long.SIZE) {
										int extendedBits = maskBits - Long.SIZE;
										if(extendedBits >= bitLength) {
											divMask = extendedMaskVal >>> (extendedBits - bitLength);
										} else {
											int shortBits = bitLength - extendedBits;
											divMask = (extendedMaskVal << (shortBits)) | (maskVal >> (Long.SIZE - shortBits));
										}
									} else {
										divMask = maskVal >>> (maskBits - bitLength);
									}	
									maskBits -= bitLength;
									lower = masker.getMaskedLower(lower, divMask);
									upper = masker.getMaskedUpper(upper, divMask);
								}
							} else {
								divPrefixLength = ParsedAddressGrouping.getDivisionPrefixLength(bitLength, prefLength - bitsSoFar);
								if(isPrefixSubnet && divPrefixLength != null) {
									long networkMask = ~0L << (bitLength - divPrefixLength);
									lower = lower & networkMask;
									upper = upper | ~networkMask;
								}
							}
							divs[i] = new IPAddressBitsDivision(lower, upper, bitLength, divRadix, network, divPrefixLength);
							bitsSoFar += bitLength;
						}
						grouping = new IPAddressDivisionGrouping(divs, network);
					}
					val.series = grouping;
					if(isDoneTranslating()) {
						releaseSegmentData();
					}
				}
			}
		}
		return grouping;
	}
	public static class BitwiseOrer implements Serializable {
		private static final long serialVersionUID = 1L;
		private final boolean isSequential;
		public BitwiseOrer(boolean isSequential) {
			this.isSequential = isSequential;
		}
		public long getOredLower(long value, long maskValue) {
			return value | maskValue;
		}
		public long getOredUpper(long upperValue, long maskValue) {
			return upperValue | maskValue;
		}
		public boolean isSequential() {
			return isSequential;
		}
	}
	public static class FullRangeBitwiseOrer extends BitwiseOrer {
		private static final long serialVersionUID = 1L;
		private final long upperMask;
		public final int fullRangeBit;
		public FullRangeBitwiseOrer(int fullRangeBit, boolean isSequential) {
			super(isSequential);
			this.fullRangeBit = fullRangeBit;
			upperMask = ~0L >>> fullRangeBit;
		}
		@Override
		public long getOredLower(long value, long maskValue) {
			return super.getOredLower(value & ~upperMask, maskValue);
		}
		@Override
		public long getOredUpper(long upperValue, long maskValue) {
			return super.getOredUpper(upperValue | upperMask, maskValue);
		}
	}
	public static class SpecificValueBitwiseOrer extends BitwiseOrer {
		private static final long serialVersionUID = 1L;
		private final long lower, upper;
		public SpecificValueBitwiseOrer(long lower, long upper) {
			super(false);
			this.lower = lower;
			this.upper = upper;
		}
		@Override
		public long getOredLower(long value, long maskValue) {
			return super.getOredLower(lower, maskValue);
		}
		@Override
		public long getOredUpper(long upperValue, long maskValue) {
			return super.getOredUpper(upper, maskValue);
		}
	}
	public static abstract class Masker implements Serializable {
		private static final long serialVersionUID = 1L;
		private final boolean isSequential;
		public Masker(boolean isSequential) {
			this.isSequential = isSequential;
		}
		public long getMaskedLower(long value, long maskValue) {
			return value & maskValue;
		}
		public long getMaskedUpper(long upperValue, long maskValue) {
			return upperValue & maskValue;
		}
		public boolean isSequential() {
			return isSequential;
		}
	}
	public static class FullRangeMasker extends Masker {
		private static final long serialVersionUID = 1L;
		private final long upperMask;
		public final int fullRangeBit;
		public FullRangeMasker(int fullRangeBit, boolean isSequential) {
			super(isSequential);
			this.fullRangeBit = fullRangeBit;
			upperMask = ~0L >>> fullRangeBit;
		}
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(value & ~upperMask, maskValue);
		}
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upperValue | upperMask, maskValue);
		}
	}
	public static class SpecificValueMasker extends Masker {
		private static final long serialVersionUID = 1L;
		private final long lower, upper;
		public SpecificValueMasker(long lower, long upper) {
			super(false);
			this.lower = lower;
			this.upper = upper;
		}
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(lower, maskValue);
		}
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upper, maskValue);
		}
	}
	public static class ExtendedMasker extends Masker {
		private static final long serialVersionUID = 1L;
		public ExtendedMasker(boolean isSequential) {
			super(isSequential);
		}
		@Deprecated
		public long getExtendedLowerMasked(long extendedValue, long extendedMaskValue) {
			return getExtendedMaskedLower(extendedValue, extendedMaskValue);
		}
		@Deprecated
		public long getExtendedUpperMasked(long extendedUpperValue, long extendedMaskValue) {
			return getExtendedMaskedUpper(extendedUpperValue, extendedMaskValue);
		}
		public long getExtendedMaskedLower(long extendedValue, long extendedMaskValue) {
			return extendedValue & extendedMaskValue;
		}
		public long getExtendedMaskedUpper(long extendedUpperValue, long extendedMaskValue) {
			return extendedUpperValue & extendedMaskValue;
		}
	}
	public static class ExtendedFullRangeMasker extends ExtendedMasker {
		private static final long serialVersionUID = 1L;
		private final long upperMask, extendedUpperMask;
		ExtendedFullRangeMasker(int fullRangeBit, boolean isSequential) {
			super(isSequential);
			if(fullRangeBit >= Long.SIZE) {
				extendedUpperMask = 0;
				upperMask = ~0L >>> (fullRangeBit - Long.SIZE);
			} else {
				extendedUpperMask = ~0L >>> fullRangeBit;
				upperMask = 0xffffffffffffffffL;
			}
		}
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(value & ~upperMask, maskValue);
		}
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upperValue | upperMask, maskValue);
		}
		@Override
		public long getExtendedMaskedLower(long extendedValue, long extendedMaskValue) {
			return super.getExtendedMaskedLower(extendedValue & ~extendedUpperMask, extendedMaskValue);
		}
		@Override
		public long getExtendedMaskedUpper(long extendedUpperValue, long extendedMaskValue) {
			return super.getMaskedUpper(extendedUpperValue | extendedUpperMask, extendedMaskValue);
		}
	}
	public static class ExtendedSpecificValueMasker extends ExtendedMasker {
		private static final long serialVersionUID = 1L;
		private final long extendedLower, lower, extendedUpper, upper;
		public ExtendedSpecificValueMasker(long extendedLower, long lower, long extendedUpper, long upper) {
			super(false);
			this.lower = lower;
			this.upper = upper;
			this.extendedLower = extendedLower;
			this.extendedUpper = extendedUpper;
		}
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(lower, maskValue);
		}
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upper, maskValue);
		}
		@Override
		public long getExtendedMaskedLower(long extendedValue, long extendedMaskValue) {
			return super.getExtendedMaskedLower(extendedLower, extendedMaskValue);
		}
		@Override
		public long getExtendedMaskedUpper(long extendedUpperValue, long extendedMaskValue) {
			return super.getExtendedMaskedUpper(extendedUpper, extendedMaskValue);
		}
	}
	public static class WrappedMasker extends ExtendedMasker {
		private static final long serialVersionUID = 1L;
		private final Masker masker;
		WrappedMasker(Masker masker) {
			super(masker.isSequential());
			this.masker = masker;
		}
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return masker.getMaskedLower(value, maskValue);
		}
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return masker.getMaskedUpper(upperValue, maskValue);
		}
	}
	@Deprecated
	public static ExtendedMasker maskRange(
			long value, long extendedValue, 
			long upperValue, long extendedUpperValue, 
			long maskValue, long extendedMaskValue, 
			long maxValue, long extendedMaxValue) {
		return maskExtendedRange(value, extendedValue, 
				upperValue, extendedUpperValue, 
				maskValue, extendedMaskValue, 
				maxValue, extendedMaxValue);
	}
	public static ExtendedMasker maskExtendedRange(
			long value, long extendedValue, 
			long upperValue, long extendedUpperValue, 
			long maskValue, long extendedMaskValue, 
			long maxValue, long extendedMaxValue) {
		long extendedDiffering = extendedValue ^ extendedUpperValue;
		if(extendedDiffering == 0) {
			Masker masker = maskRange(value, upperValue, maskValue, maxValue);
			if(masker == DEFAULT_MASKER) {
				return DEFAULT_MASKER;
			}
			if(masker instanceof FullRangeMasker) {
				int fullRangeBit = ((FullRangeMasker) masker).fullRangeBit;
				WrappedMasker cache[] = masker.isSequential() ? WRAPPED_SEQUENTIAL_FULL_RANGE_MASKERS : WRAPPED_FULL_RANGE_MASKERS;
				WrappedMasker result = cache[fullRangeBit];
				if(result == null) {
					cache[fullRangeBit] = result = new WrappedMasker(masker);
				}
				return result;
			}
			return new WrappedMasker(masker);
		}
		if(extendedValue > extendedUpperValue) {
			throw new IllegalArgumentException("value > upper value");
		}
		if((maskValue == maxValue && extendedMaskValue == extendedMaxValue ) ||
				(maskValue == 0 && extendedMaskValue == 0 )) {
			return DEFAULT_MASKER;
		}
		int highestDifferingBitInRange = Long.numberOfLeadingZeros(extendedDiffering);
		long extendedDifferingMasked = extendedMaskValue & (~0L >>> highestDifferingBitInRange);
		int highestDifferingBitMasked;
		if(extendedDifferingMasked != 0) {
			boolean differingIsLowestBit = (extendedDifferingMasked == 1);
			highestDifferingBitMasked = Long.numberOfLeadingZeros(extendedDifferingMasked);
			boolean maskedIsSequential;
			long hostMask = ~0L >>> (highestDifferingBitMasked + 1);
			if(!differingIsLowestBit) { 
				maskedIsSequential = (extendedMaskValue & hostMask) == hostMask && maskValue == maxValue; 
			} else {
				maskedIsSequential = maskValue == maxValue;
			}
			if(value == 0 && extendedValue == 0 && 
					upperValue == maxValue && extendedUpperValue == extendedMaxValue) {
				if(maskedIsSequential) {
					return DEFAULT_MASKER;
				} else {
					return DEFAULT_NON_SEQUENTIAL_MASKER;
				}
			}
			if(highestDifferingBitMasked > highestDifferingBitInRange) {
				if(maskedIsSequential) {
					int shift = Long.SIZE - highestDifferingBitMasked; 
					BigInteger countRequiredForSequential = ONE_SHIFTED_EXTENDED[shift];
					if(countRequiredForSequential == null) {
						countRequiredForSequential = ONE_SHIFTED_EXTENDED[shift] = BigInteger.valueOf(1L << shift).shiftLeft(Long.SIZE);
					}
					BigInteger upperBig = new BigInteger(1, toBytesSizeAdjusted(upperValue, extendedUpperValue, 16));
					BigInteger lowerBig = new BigInteger(1, toBytesSizeAdjusted(value, extendedValue, 16));
					BigInteger count = upperBig.subtract(lowerBig).add(BigInteger.ONE);
					maskedIsSequential = count.compareTo(countRequiredForSequential) >= 0;
				}
				ExtendedFullRangeMasker cache[] = maskedIsSequential ? EXTENDED_SEQUENTIAL_FULL_RANGE_MASKERS : EXTENDED_FULL_RANGE_MASKERS;
				ExtendedFullRangeMasker result = cache[highestDifferingBitMasked];
				if(result == null) {
					cache[highestDifferingBitMasked] = result = new ExtendedFullRangeMasker(highestDifferingBitMasked, maskedIsSequential);
				}
				return result;
			} else if(!maskedIsSequential) {
				BigInteger bigHostMask = HOST_MASK_EXTENDED[highestDifferingBitMasked];
				if(bigHostMask == null) {
					bigHostMask = BigInteger.valueOf(hostMask);
					bigHostMask = bigHostMask.shiftLeft(Long.SIZE);
					byte b = (byte) 0xff;
					bigHostMask = bigHostMask.or(new BigInteger(1, new byte[] {b, b, b, b, b, b, b, b}));
					HOST_MASK_EXTENDED[highestDifferingBitMasked] = bigHostMask;
				}
				BigInteger bigHostZeroed = NETWORK_MASK_EXTENDED[highestDifferingBitMasked];
				if(bigHostZeroed == null) {
					bigHostZeroed = NETWORK_MASK_EXTENDED[highestDifferingBitMasked] = bigHostMask.not();
				}
				BigInteger upperBig = new BigInteger(1, toBytesSizeAdjusted(upperValue, extendedUpperValue, 16));
				BigInteger lowerBig = new BigInteger(1, toBytesSizeAdjusted(value, extendedValue, 16));
				BigInteger upperToBeMaskedBig = upperBig.and(bigHostZeroed);
				BigInteger lowerToBeMaskedBig = lowerBig.or(bigHostMask);
				BigInteger maskBig = new BigInteger(1, toBytesSizeAdjusted(maskValue, extendedMaskValue, 16));
				for(int nextBit = 128 - (highestDifferingBitMasked + 1) - 1; nextBit >= 0; nextBit--) {
					if(maskBig.testBit(nextBit)) {
						BigInteger candidate = upperToBeMaskedBig.setBit(nextBit);
						if(candidate.compareTo(upperBig) <= 0) {
							upperToBeMaskedBig = candidate;
						}
						candidate = lowerToBeMaskedBig.clearBit(nextBit);
						if(candidate.compareTo(lowerBig) >= 0) {
							lowerToBeMaskedBig = candidate;
						}
					} 
				}
				return new ExtendedSpecificValueMasker(
						lowerToBeMaskedBig.shiftRight(Long.SIZE).longValue(), 
						lowerToBeMaskedBig.longValue(), 
						upperToBeMaskedBig.shiftRight(Long.SIZE).longValue(), 
						upperToBeMaskedBig.longValue());
			}
			return DEFAULT_MASKER;
		}
		if(maskValue == 0) {
			return DEFAULT_MASKER;
		}
		boolean maskedIsSequential = true;
		int highestDifferingBitMaskedLow = Long.numberOfLeadingZeros(maskValue);
		if(maskValue != maxValue && highestDifferingBitMaskedLow < Long.SIZE - 1) {
			long hostMask = ~0L >>> (highestDifferingBitMaskedLow + 1); 
			maskedIsSequential = (maskValue & hostMask) == hostMask; 
		}
		if(maskedIsSequential) {
			BigInteger countRequiredForSequential;
			if(highestDifferingBitMaskedLow == 0) {
				countRequiredForSequential = ONE_EXTENDED;
			} else if(highestDifferingBitMaskedLow == 1) { 
				countRequiredForSequential = HIGH_BIT;
			} else {
				int shift = Long.SIZE - highestDifferingBitMaskedLow;
				countRequiredForSequential = ONE_SHIFTED[shift];
				if(countRequiredForSequential == null) {
					countRequiredForSequential = ONE_SHIFTED[shift] = BigInteger.valueOf(1L << shift);
				}
			}
			BigInteger upperBig = new BigInteger(1, toBytesSizeAdjusted(upperValue, extendedUpperValue, 16));
			BigInteger lowerBig = new BigInteger(1, toBytesSizeAdjusted(value, extendedValue, 16));
			BigInteger count = upperBig.subtract(lowerBig).add(BigInteger.ONE);
			maskedIsSequential = count.compareTo(countRequiredForSequential) >= 0;
		}
		highestDifferingBitMasked = highestDifferingBitMaskedLow + Long.SIZE;
		ExtendedFullRangeMasker cache[] = maskedIsSequential ? EXTENDED_SEQUENTIAL_FULL_RANGE_MASKERS : EXTENDED_FULL_RANGE_MASKERS;
		ExtendedFullRangeMasker result = cache[highestDifferingBitMasked];
		if(result == null) {
			cache[highestDifferingBitMasked] = result = new ExtendedFullRangeMasker(highestDifferingBitMasked, maskedIsSequential);
		}
		return result;
	}
	public static Masker maskRange(long value, long upperValue, long maskValue) {
		return maskRange(value, upperValue, maskValue, -1);
	}
	public static Masker maskRange(long value, long upperValue, long maskValue, long maxValue) {
		if(value == upperValue) {
			return DEFAULT_MASKER;
		}
		if(value > upperValue) {
			throw new IllegalArgumentException("value > upper value");
		}
		if(maskValue == 0 || maskValue == maxValue) {
			return DEFAULT_MASKER;
		}
		long differing = value ^ upperValue;
		if(differing != 1) {
			int highestDifferingBitInRange = Long.numberOfLeadingZeros(differing);
			long maskMask = ~0L >>> highestDifferingBitInRange;
			long differingMasked = maskValue & maskMask;
			boolean foundDiffering = (differingMasked != 0);
			if(foundDiffering) {
				int highestDifferingBitMasked = Long.numberOfLeadingZeros(differingMasked); 
				long hostMask = (highestDifferingBitMasked == Long.SIZE - 1) ? 0 : ~0L >>> (highestDifferingBitMasked + 1);
				boolean maskedIsSequential = (maskValue & hostMask) == hostMask;
				if(maxValue == -1 && 
						(!maskedIsSequential || highestDifferingBitMasked > highestDifferingBitInRange)) {
					int highestOneBit = Long.numberOfLeadingZeros(upperValue);
					maxValue = ~0L >>> highestOneBit;
				}
				if(value == 0 && upperValue == maxValue) {
					if(maskedIsSequential) {
						return DEFAULT_MASKER;
					} else {
						return DEFAULT_NON_SEQUENTIAL_MASKER;
					}
				}
				if(highestDifferingBitMasked > highestDifferingBitInRange) {
					if(maskedIsSequential) {
						if(highestDifferingBitMasked < Long.SIZE - 1) {
							long count = upperValue - value + 1;
							long countRequiredForSequential = 1L << (Long.SIZE - highestDifferingBitMasked);
							if(count < countRequiredForSequential) {
								maskedIsSequential = false;
							}
						} 
					}
					FullRangeMasker cache[] = maskedIsSequential ? SEQUENTIAL_FULL_RANGE_MASKERS : FULL_RANGE_MASKERS;
					FullRangeMasker result = cache[highestDifferingBitMasked];
					if(result == null) {
						cache[highestDifferingBitMasked] = result = new FullRangeMasker(highestDifferingBitMasked, maskedIsSequential);
					}
					return result;
				} else if(!maskedIsSequential) {
					long hostZeroed = ~hostMask;
					long upperToBeMasked = upperValue & hostZeroed;
					long lowerToBeMasked = value | hostMask;
					for(long nextBit = (1 << (Long.SIZE - (highestDifferingBitMasked + 1) - 1)); nextBit != 0; nextBit >>>= 1) {
						if((maskValue & nextBit) != 0) {
							long candidate = upperToBeMasked | nextBit;
							if(candidate <= upperValue) {
								upperToBeMasked = candidate;
							}
							candidate = lowerToBeMasked & ~nextBit;
							if(candidate >= value) {
								lowerToBeMasked = candidate;
							}
						} 
					}
					return new SpecificValueMasker(lowerToBeMasked, upperToBeMasked);
				} 
			} 
		} 
		return DEFAULT_MASKER;
	}
	public static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue) {
		return bitwiseOrRange(value, upperValue, maskValue, -1);
	}
	public static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue, long maxValue) {
		if(value == upperValue) {
			return DEFAULT_OR_MASKER;
		}
		if(value > upperValue) {
			throw new IllegalArgumentException("value > upper value");
		}
		if(maskValue == 0 || maskValue == maxValue) {
			return DEFAULT_OR_MASKER;
		}
		long differing = value ^ upperValue;
		if(differing != 1) {
			int highestDifferingBitInRange = Long.numberOfLeadingZeros(differing);
			long maskMask = ~0L >>> highestDifferingBitInRange;
			long differingMasked = maskValue & maskMask;
			boolean foundDiffering = (differingMasked != maskMask);
			if(foundDiffering) {
				int highestDifferingBitMasked = Long.numberOfLeadingZeros(~differingMasked & maskMask); 
				long hostMask = (highestDifferingBitMasked == Long.SIZE - 1) ? 0 : ~0L >>> (highestDifferingBitMasked + 1); 
				boolean maskedIsSequential = (maskValue & hostMask) == 0;
				if(maxValue == -1 && 
						(!maskedIsSequential || highestDifferingBitMasked > highestDifferingBitInRange)) {
					int highestOneBit = Long.numberOfLeadingZeros(upperValue);
					maxValue = ~0L >>> highestOneBit;
				}
				if(value == 0 && upperValue == maxValue) {
					if(maskedIsSequential) {
						return DEFAULT_OR_MASKER;
					} else {
						return DEFAULT_NON_SEQUENTIAL_OR_MASKER;
					}
				}
				if(highestDifferingBitMasked > highestDifferingBitInRange) {
					if(maskedIsSequential) {
						if(highestDifferingBitMasked < Long.SIZE - 1) {
							long count = upperValue - value + 1;
							long countRequiredForSequential = 1L << (Long.SIZE - highestDifferingBitMasked);
							if(count < countRequiredForSequential) {
								maskedIsSequential = false;
							}
						}
					}
					FullRangeBitwiseOrer cache[] = maskedIsSequential ? SEQUENTIAL_FULL_RANGE_OR_MASKERS : FULL_RANGE_OR_MASKERS;
					FullRangeBitwiseOrer result = cache[highestDifferingBitMasked];
					if(result == null) {
						cache[highestDifferingBitMasked] = result = new FullRangeBitwiseOrer(highestDifferingBitMasked, maskedIsSequential);
					}
					return result;
				} else if(!maskedIsSequential) {
					long hostZeroed = ~hostMask;
					long upperToBeMasked = upperValue & hostZeroed;
					long lowerToBeMasked = value | hostMask;
					for(long nextBit = (1L << (Long.SIZE - (highestDifferingBitMasked + 1) - 1)); nextBit != 0; nextBit >>>= 1) {
						if((maskValue & nextBit) == 0) {
							long candidate = upperToBeMasked | nextBit;
							if(candidate <= upperValue) {
								upperToBeMasked = candidate;
							}
							candidate = lowerToBeMasked & ~nextBit;
							if(candidate >= value) {
								lowerToBeMasked = candidate;
							}
						} 
					}
					return new SpecificValueBitwiseOrer(lowerToBeMasked, upperToBeMasked);
				}
			}
		}
		return DEFAULT_OR_MASKER;
	}
	static byte[] toBytesSizeAdjusted(long val, long extended, int numBytes) {
		int adjustedNumBytes = numBytes;
		for(int j = 1, boundary = numBytes - 8, adj = numBytes + boundary; j <= numBytes; j++) {
			byte b;
			if(j <= boundary) {
				b = (byte) (extended >>> ((numBytes - j) << 3));
			} else {
				b = (byte) (val >>> ((adj - j) << 3));
			}
			if(b != 0) {
				break;
			}
			adjustedNumBytes--;
		}
		return toBytes(val, extended, adjustedNumBytes);
	}
	static byte[] toBytes(long val, long extended, int numBytes) {
		byte bytes[] = new byte[numBytes];
		for(int j = numBytes - 1, boundary = numBytes - 8; j >= 0; j--) {
			if(j >= boundary) {
				bytes[j] = (byte) (val & 0xff);
				val >>>= Byte.SIZE;
			} else {
				bytes[j] = (byte) (extended & 0xff);
				extended >>>= Byte.SIZE;
			}
		}
		return bytes;
	}
	private boolean groupingIsSequential() {
		try {
			return getDivisionGrouping().isSequential();
		} catch(IncompatibleAddressException e) {
			return false;
		}
	}
	@Override
	public boolean isSequential() {
		TranslatedResult<?,?> val = values;
		if(val != null) {
			if(!val.withoutSections()) {
				if(val.withoutAddressException()) {
					return val.getAddress().isSequential();
				}
				return groupingIsSequential();
			}
			if(!val.withoutGrouping()) {
				return groupingIsSequential();
			}
		}
		val = getCachedAddresses(false);
		if(val.withoutAddressException()) {
			return val.getAddress().isSequential();
		}
		return groupingIsSequential();
	}
	private boolean skipContains(boolean skipMixed) {
		AddressParseData parseData = getAddressParseData();
		int segmentCount = parseData.getSegmentCount();
		if(isProvidingIPv4()) {
			if(segmentCount != IPv4Address.SEGMENT_COUNT) { 
				return true;
			}
		} else {
			int expectedSegmentCount;
			if(isProvidingMixedIPv6()) {
				if(skipMixed) {
					return true;
				}
				expectedSegmentCount = IPv6Address.SEGMENT_COUNT - 2;
			} else {
				expectedSegmentCount = IPv6Address.SEGMENT_COUNT;
			}
			if(segmentCount != expectedSegmentCount && !isCompressed()) { 
				return true;
			}
		}
		IPAddress mask = getProviderMask();
		if(mask != null && mask.getBlockMaskPrefixLength(true) == null) { 
			return true;
		}
		return false;
	}
	@Override
	public Boolean contains(String other) {
		AddressParseData parseData = getAddressParseData();
		int segmentData[] = parseData.getSegmentData(); 
		if(segmentData == null) {
			return null;
		}
		if(skipContains(true)) {
			return null;
		}
		if(has_inet_aton_value || hasIPv4LeadingZeros || isBinary) {
			return null;
		}
		Integer pref = getProviderNetworkPrefixLength();
		IPAddressStringParameters options = getParameters();
		IPAddressNetwork<? extends IPAddress, ?, ?, ?, ?> network = (isProvidingIPv4() ? options.getIPv4Parameters() : options.getIPv6Parameters()).getNetwork();
		if(pref != null && !isPrefixSubnet(pref, network, segmentData)) {
			return null;
		}
		return matchesPrefix(other, segmentData);
	}
	@Override
	public Boolean prefixContains(String other) {
		Boolean b = prefixEquals(other);
		if(b != null && b.booleanValue()) {
			return b;
		}
		return null;
	}
	@Override
	public Boolean prefixEquals(String other) {
		AddressParseData parseData = getAddressParseData();
		int segmentData[] = parseData.getSegmentData(); 
		if(segmentData == null) {
			return null;
		}
		if(skipContains(true)) {
			return null;
		}
		if(has_inet_aton_value || hasIPv4LeadingZeros || isBinary) {
			return null;
		}
		return matchesPrefix(other, segmentData);
	}
	private Boolean matchesPrefix(String other, int segmentData[]) {
		int otherLen = other.length();
		boolean isIPv4 = isProvidingIPv4();
		if(otherLen >= 4)	{
			char prefixLenSep = IPAddress.PREFIX_LEN_SEPARATOR;
			if(other.charAt(otherLen - 2) == prefixLenSep || other.charAt(otherLen - 3) == prefixLenSep) {
				return null;
			}
			if(!isIPv4) {
				if(other.charAt(otherLen - 4) == prefixLenSep) {
					return null;
				}
			}
		}
		AddressParseData parseData = getAddressParseData();
		Integer pref = getProviderNetworkPrefixLength();
		int expectedCount;
		boolean compressedAlready = false;
		boolean networkSegIsCompressed = false;
		boolean prefixIsMidSegment;
		int prefixEndCharIndex, remainingSegsCharIndex, networkSegIndex, networkSegCharIndex, networkSegsCount, adjustment; 
		remainingSegsCharIndex = networkSegCharIndex = networkSegIndex = networkSegsCount = adjustment = 0;
		if(pref == null) {
			expectedCount = isIPv4 ? IPv4Address.SEGMENT_COUNT : IPv6Address.SEGMENT_COUNT;
			networkSegIndex = expectedCount - 1;
			prefixEndCharIndex = getIndex(networkSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData);
			if(otherLen > prefixEndCharIndex) {
				return null;
			}
			prefixIsMidSegment = false;
		} else if(pref == 0) {
			prefixIsMidSegment = false;
			expectedCount = isIPv4 ? IPv4Address.SEGMENT_COUNT : IPv6Address.SEGMENT_COUNT;
			prefixEndCharIndex = 0;
		} else {
			if(isIPv4) {
				expectedCount = IPv4Address.SEGMENT_COUNT;
				int bitsPerSegment = IPv4Address.BITS_PER_SEGMENT;
				int bytesPerSegment = IPv4Address.BYTES_PER_SEGMENT;
				networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
				prefixEndCharIndex = getIndex(networkSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData);
				Integer segPrefLength = ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, pref, networkSegIndex);
				prefixIsMidSegment = segPrefLength != bitsPerSegment;
				networkSegsCount = networkSegIndex + 1;
				remainingSegsCharIndex = prefixEndCharIndex + 1;
				if(prefixIsMidSegment) {
					networkSegCharIndex = getIndex(networkSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
				}
			} else {
				expectedCount = IPv6Address.SEGMENT_COUNT;
				int bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
				int bytesPerSegment = IPv6Address.BYTES_PER_SEGMENT;
				networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
				int missingSegmentCount = IPv6Address.SEGMENT_COUNT - parseData.getSegmentCount();
				int compressedSegIndex = getConsecutiveSeparatorSegmentIndex();
				compressedAlready = compressedSegIndex <= networkSegIndex;
				networkSegIsCompressed = compressedAlready && compressedSegIndex + missingSegmentCount >= networkSegIndex;
				Integer segPrefLength = ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, pref, networkSegIndex);
				if(networkSegIsCompressed) {
					prefixIsMidSegment = segPrefLength != bitsPerSegment;
					networkSegsCount = networkSegIndex + 1;
					prefixEndCharIndex = getIndex(compressedSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData) + 1; 
					if (prefixIsMidSegment && compressedSegIndex > 0) {
						networkSegCharIndex = getIndex(compressedSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
					}
					remainingSegsCharIndex = prefixEndCharIndex + 1;
				} else {
					int actualNetworkSegIndex;
					if(compressedSegIndex < networkSegIndex) {
						actualNetworkSegIndex = networkSegIndex - missingSegmentCount;
					} else {
						actualNetworkSegIndex = networkSegIndex;
					}
					prefixEndCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData);
					adjustment = IPv6AddressSegment.MAX_CHARS - ((segPrefLength + 3) >> 2); 
					if(adjustment > 0) {
						prefixIsMidSegment = true;
						remainingSegsCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_UPPER_STR_START_INDEX, segmentData);
						if(remainingSegsCharIndex + adjustment > prefixEndCharIndex) {
							adjustment = prefixEndCharIndex - remainingSegsCharIndex;
						}
						prefixEndCharIndex -= adjustment;
						networkSegsCount = networkSegIndex;
						networkSegCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
					} else {
						prefixIsMidSegment = segPrefLength != bitsPerSegment;
						networkSegsCount = actualNetworkSegIndex + 1;
						remainingSegsCharIndex = prefixEndCharIndex + 1;
						if(prefixIsMidSegment) {
							networkSegCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
						}
					}
				}
			}
		}
		CharSequence str = this.str;
		int otherSegmentCount = 0;
		boolean currentSegHasNonZeroDigits = false;
		for(int i = 0; i < prefixEndCharIndex; i++) {
			char c = str.charAt(i);
			char otherChar;
			if(i < otherLen) {
				otherChar = other.charAt(i);
			} else {
				otherChar = 0;
			}
			if(c != otherChar) {
				if(c >= '1' && c <= '9') {
				} else if(c >= 'a' && c <= 'f') {
				} else if(c >= 'A' && c <= 'F') {
					char adjustedChar = (char) (c - ('A' - 'a'));
					if(c == adjustedChar) {
						continue;
					}
				} else if(c <= Address.RANGE_SEPARATOR && c >= Address.SEGMENT_SQL_WILDCARD) {
					if(c == Address.SEGMENT_WILDCARD || c == Address.RANGE_SEPARATOR || c == Address.SEGMENT_SQL_WILDCARD) {
						return null;
					}
				} else if(c == Address.SEGMENT_SQL_SINGLE_WILDCARD) {
					return null;
				}
				if(otherChar >= 'A' && otherChar <= 'F') {
					char adjustedChar = (char) (otherChar - ('A' - 'a'));
					if(otherChar == adjustedChar) {
						continue;
					}
				} 
				if(prefixIsMidSegment && (i >= networkSegCharIndex || networkSegCharIndex == 1)) { 
					return null;
				}
				if(hasRange(otherSegmentCount)) {
					return null;
				}
				if(otherChar >= '1' && otherChar <= '9') {
				} else if(otherChar >= 'a' && otherChar <= 'f') {
				} else {
					if(otherChar <= Address.RANGE_SEPARATOR && otherChar >= Address.SEGMENT_SQL_WILDCARD) {
						if(otherChar == Address.SEGMENT_WILDCARD || otherChar == Address.RANGE_SEPARATOR || otherChar == Address.SEGMENT_SQL_WILDCARD) {
							return null;
						}
					} else if(otherChar == Address.SEGMENT_SQL_SINGLE_WILDCARD) {
						return null;
					}
					if(!currentSegHasNonZeroDigits) {
						if(c == '0') {
							if(otherChar == IPv6Address.SEGMENT_SEPARATOR || otherChar == 0) {
								return null;
							}
							int k = i + 1;
							if(k < str.length()) {
								char nextChar = str.charAt(k);
								if(nextChar != IPv4Address.SEGMENT_SEPARATOR  && nextChar != IPv6Address.SEGMENT_SEPARATOR) {
									return null;
								}
							}
						} else if(otherChar == '0') {
							if(c == IPv6Address.SEGMENT_SEPARATOR) {
								return null;
							}
							int k = i + 1;
							if(k < otherLen) {
								char nextChar = other.charAt(k);
								if(nextChar != IPv4Address.SEGMENT_SEPARATOR  && nextChar != IPv6Address.SEGMENT_SEPARATOR) {
									return null;
								}
							}
							return Boolean.FALSE;
						}
					}
					if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
						return Boolean.FALSE; 
					} else if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
						if(!isIPv4) {
							return null; 
						}
						otherSegmentCount++;
					}
				}
				for(int k = i + 1; k < otherLen; k++) {
					otherChar = other.charAt(k);
					if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
						return Boolean.FALSE;
					} else if(otherChar <= IPAddress.PREFIX_LEN_SEPARATOR && otherChar >= Address.SEGMENT_SQL_WILDCARD) {
						if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
							if(!isIPv4) {
								return null; 
							}
							otherSegmentCount++;
						} else {
							if(otherChar == IPAddress.PREFIX_LEN_SEPARATOR || otherChar == Address.SEGMENT_WILDCARD || 
									otherChar == Address.RANGE_SEPARATOR || otherChar == Address.SEGMENT_SQL_WILDCARD ||
									otherChar == Address.SEGMENT_SQL_SINGLE_WILDCARD) {
								return null;
							}
						}
					}
				}
				if(isIPv4) {
					if(otherSegmentCount + 1 == IPv4Address.SEGMENT_COUNT) {
						return Boolean.FALSE;
					}
				} else {
					if(otherSegmentCount > 0) {
						return Boolean.FALSE;
					}
				}
				return null;
			}
			if(c != '0') {
				boolean isSegmentEnd = c == IPv6Address.SEGMENT_SEPARATOR || c == IPv4Address.SEGMENT_SEPARATOR;
				if(isSegmentEnd) {
					otherSegmentCount++;
					currentSegHasNonZeroDigits = false;
				} else {
					currentSegHasNonZeroDigits = true;
				}
			}
		}
		if(pref != null) {
			if(prefixEndCharIndex == otherLen) {  
				if(networkSegsCount != expectedCount) {
					if(!compressedAlready || networkSegsCount > expectedCount) {
						return null;
					}
				}
			} else {
				if(isIPv4) {
					if(pref != 0) {
						int segmentEndIndex = prefixEndCharIndex + adjustment;
						if(otherLen < segmentEndIndex) {
							return null;
						}
						if(otherLen != segmentEndIndex && other.charAt(segmentEndIndex) != IPv4Address.SEGMENT_SEPARATOR) {
							return null;
						}
						for(int n = prefixEndCharIndex; n < segmentEndIndex; n++) {
							char otherChar = other.charAt(n);
							if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
								return null;
							}
						}
					}
					int digitCount = 0;
					int remainingSegCount = 0;
					boolean firstIsHighIPv4 = false;
					int i = remainingSegsCharIndex;
					for(; i < otherLen; i++) {
						char otherChar = other.charAt(i);
						if(otherChar <= '9' && otherChar >= '0') {
							if(digitCount == 0 && otherChar >= '3') {
								firstIsHighIPv4 = true;
							}
							++digitCount;
						} else if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
							if(digitCount == 0) {
								return Boolean.FALSE;
							}
							if(firstIsHighIPv4) {
								if(digitCount >= IPv4AddressSegment.MAX_CHARS) {
									return Boolean.FALSE;
								}
							} else if(digitCount > IPv4AddressSegment.MAX_CHARS) {
								return null;
							}
							digitCount = 0;
							remainingSegCount++;
							firstIsHighIPv4 = false;
						} else { 
							return null; 
						}
					} 
					if(digitCount == 0) {
						return Boolean.FALSE;
					}
					if(digitCount > IPv4AddressSegment.MAX_CHARS) {
						return null;
					} else if(firstIsHighIPv4 && digitCount == IPv4AddressSegment.MAX_CHARS) {
						return null;
					}
					int totalSegCount = networkSegsCount + remainingSegCount + 1;
					if(totalSegCount != expectedCount) {
						return null;
					}
				} else {
					if(pref != 0) {
						int segmentEndIndex = prefixEndCharIndex + adjustment;
						if(otherLen < segmentEndIndex) {
							return null;
						}
						if(otherLen != segmentEndIndex && other.charAt(segmentEndIndex) != IPv6Address.SEGMENT_SEPARATOR) {
							return null;
						}
						for(int n = prefixEndCharIndex; n < segmentEndIndex; n++) {
							char otherChar = other.charAt(n);
							if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
								return null;
							}
						}
					}
					int digitCount = 0;
					int remainingSegCount = 0;
					int i = remainingSegsCharIndex;
					for(; i < otherLen; i++) {
						char otherChar = other.charAt(i);		
						if(otherChar <= '9' && otherChar >= '0') {
							++digitCount;
						} else if((otherChar >= 'a' && otherChar <= 'f') || (otherChar >= 'A' && otherChar <= 'F')) {
							++digitCount;
						} else if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
							return null; 
						} else if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
							if(digitCount > IPv6AddressSegment.MAX_CHARS) {
								return null;
							}
							if(digitCount == 0) {
								if(compressedAlready) {
									return Boolean.FALSE;
								}
								compressedAlready = true;
							} else {
								digitCount = 0;
							}
							remainingSegCount++;
						} else { 
							return null; 
						}
					} 
					if(digitCount == 0) {
						int prevIndex = i - 1;
						if(prevIndex < 0) {
							return Boolean.FALSE;
						}
						char prevChar = other.charAt(prevIndex);
						if(prevChar != IPv6Address.SEGMENT_SEPARATOR) { 
							return Boolean.FALSE;
						}
					} else if(digitCount > IPv6AddressSegment.MAX_CHARS) {
						return null;
					}
					int totalSegCount = networkSegsCount + remainingSegCount + 1;
					if(totalSegCount > expectedCount || (totalSegCount < expectedCount && !compressedAlready)) {
						return null;
					}
					if(networkSegIsCompressed && expectedCount - remainingSegCount <= networkSegIndex) {
						return null;
					}
				}
			}
		}
		return Boolean.TRUE;
	}
	@Override
	public Boolean contains(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				return contains((ParsedIPAddress) other, false, false);
			} 
		}
		return null;
	}
	@Override
	public Boolean parsedEquals(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				ParsedIPAddress parsedOther = (ParsedIPAddress) other;
				Boolean result = contains(parsedOther, false, true);
				if(result != null) {
					return result && Objects.equals(getQualifier().getZone(), parsedOther.getQualifier().getZone());
				} 
			}
		}
		return null;
	}
	@Override
	public Boolean prefixContains(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				return contains((ParsedIPAddress) other, true, false);
			} 
		}
		return null;
	}
	@Override
	public Boolean prefixEquals(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				return contains((ParsedIPAddress) other, true, true);
			} 
		}
		return null;
	}
	private Boolean contains(ParsedIPAddress other, boolean networkOnly, boolean equals) {
		AddressParseData parseData = getAddressParseData();
		AddressParseData otherParseData = other.getAddressParseData();
		int segmentData[] = parseData.getSegmentData(); 
		int otherSegmentData[] = otherParseData.getSegmentData(); 
		if(segmentData == null || otherSegmentData == null) {
			return null;
		}
		Integer pref = getProviderNetworkPrefixLength();
		boolean skipMixed = !networkOnly || pref == null || pref > (IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT << 4);
		if(skipContains(skipMixed) || other.skipContains(skipMixed)) { 
			return null;
		}
		IPVersion ipVersion = getProviderIPVersion();
		if(!ipVersion.equals(other.getProviderIPVersion())) {
			return Boolean.FALSE;
		}
		int max;
		IPAddressNetwork<? extends IPAddress, ?, ?, ?, ?> network;
		boolean compressedAlready, otherCompressedAlready;
		int expectedSegCount, expectedOtherSegCount, bitsPerSegment, bytesPerSegment;
		IPAddressStringParameters options = getParameters();
		int segmentCount = parseData.getSegmentCount();
		int otherSegmentCount = otherParseData.getSegmentCount();
		if(isProvidingIPv4()) {
			max = IPv4Address.MAX_VALUE_PER_SEGMENT;
			expectedSegCount = expectedOtherSegCount = IPv4Address.SEGMENT_COUNT;
			bitsPerSegment = IPv4Address.BITS_PER_SEGMENT;
			bytesPerSegment = IPv4Address.BYTES_PER_SEGMENT;
			network = options.getIPv4Parameters().getNetwork();
			compressedAlready = true;
			otherCompressedAlready = true;
		} else {
			max = IPv6Address.MAX_VALUE_PER_SEGMENT;
			expectedSegCount = expectedOtherSegCount = IPv6Address.SEGMENT_COUNT;
			if(isProvidingMixedIPv6()) {
				expectedSegCount -= 2;
			}
			if(other.isProvidingMixedIPv6()) {
				expectedOtherSegCount -= 2;
			}
			bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
			bytesPerSegment = IPv6Address.BYTES_PER_SEGMENT;
			network = options.getIPv6Parameters().getNetwork();
			compressedAlready = expectedSegCount == segmentCount;
			otherCompressedAlready = expectedOtherSegCount == otherSegmentCount;
		}
		PrefixConfiguration prefConf = network.getPrefixConfiguration();
		boolean zeroHostsAreSubnets = prefConf.zeroHostsAreSubnets();
		boolean allPrefixedAddressesAreSubnets = prefConf.allPrefixedAddressesAreSubnets();
		Integer otherPref = other.getProviderNetworkPrefixLength();
		int networkSegIndex, hostSegIndex, endIndex, otherHostAllSegIndex, hostAllSegIndex;
		endIndex = segmentCount;
		Integer adjustedOtherPref = null;
		if(pref == null) {
			networkOnly = false;
			hostAllSegIndex = hostSegIndex = expectedSegCount;
			otherHostAllSegIndex = expectedOtherSegCount;
			networkSegIndex = hostSegIndex - 1;
		} else if(networkOnly) {
			hostAllSegIndex = otherHostAllSegIndex = hostSegIndex = ParsedAddressGrouping.getHostSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			adjustedOtherPref = pref;
		} else {
			otherHostAllSegIndex = expectedOtherSegCount;
			hostSegIndex = ParsedAddressGrouping.getHostSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			if(allPrefixedAddressesAreSubnets || 
					(zeroHostsAreSubnets && isPrefixSubnet(pref, network, segmentData))) {
				hostAllSegIndex = hostSegIndex;
				if(!equals) {
					networkOnly = true;
				}
			} else {
				hostAllSegIndex = expectedSegCount;
			}
		}
		if(otherPref != null) {
			int otherPrefLen = otherPref.intValue();
			if (adjustedOtherPref == null || otherPrefLen < adjustedOtherPref) {
				int otherHostIndex = ParsedAddressGrouping.getHostSegmentIndex(otherPrefLen, bytesPerSegment, bitsPerSegment);
				if(otherHostIndex < otherHostAllSegIndex &&
						(allPrefixedAddressesAreSubnets || (zeroHostsAreSubnets && other.isPrefixSubnet(otherPrefLen, network, otherSegmentData)))) {
					otherHostAllSegIndex = otherHostIndex;
				}
			} else {
				otherPref = adjustedOtherPref;
			}
		} else {
			otherPref = adjustedOtherPref;
		}
		int i = 0, j = 0, normalizedCount = 0;
		int compressedCount, otherCompressedCount;
		compressedCount = otherCompressedCount = 0;
		while(i < endIndex || compressedCount > 0) {
			if(networkOnly && normalizedCount > networkSegIndex) {
				break;
			}		
			long lower, upper;
		    if(compressedCount > 0) {
		    	lower = upper = 0;
		    } else {
		    	lower = getValue(i, AddressParseData.KEY_LOWER, segmentData);
		    	upper = getValue(i, AddressParseData.KEY_UPPER, segmentData);
		    }
		    if(normalizedCount >= hostAllSegIndex) { 
			   	Integer segPrefLength = ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, pref, normalizedCount);
				lower &= network.getSegmentNetworkMask(segPrefLength);
				upper |= network.getSegmentHostMask(segPrefLength);
			}
			long otherLower, otherUpper;
			if(normalizedCount > otherHostAllSegIndex) {
				otherLower = 0;
				otherUpper = max;
			} else {
				if(otherCompressedCount > 0) {
					otherLower = otherUpper = 0;
				} else {
					otherLower = getValue(j, AddressParseData.KEY_LOWER, otherSegmentData);
					otherUpper = getValue(j, AddressParseData.KEY_UPPER, otherSegmentData);
				}
				if(normalizedCount == otherHostAllSegIndex) { 
					Integer segPrefLength = ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, otherPref, normalizedCount);
					otherLower &= network.getSegmentNetworkMask(segPrefLength);
					otherUpper |= network.getSegmentHostMask(segPrefLength);
				}
			}
			if(equals ? (lower != otherLower || upper != otherUpper) : (lower > otherLower || upper < otherUpper)) {
				return Boolean.FALSE;
			}
			if(!compressedAlready) {
				if(compressedCount > 0) {
					if(--compressedCount == 0) {
						compressedAlready = true;
					}
				} else if(isCompressed(i, segmentData)) {
					i++;
					compressedCount = expectedSegCount - segmentCount;
				} else {
					i++;
				}
			} else {
				i++;
			}
			if(!otherCompressedAlready) {
				if(otherCompressedCount > 0) {
					if(--otherCompressedCount == 0) {
						otherCompressedAlready = true;
					}
				} else if(other.isCompressed(j, otherSegmentData)) {
					j++;
					otherCompressedCount = expectedOtherSegCount - otherSegmentCount;
				} else {
					j++;
				}
			} else {
				j++;
			}
			normalizedCount++;
		}
		return Boolean.TRUE;
	}
	protected boolean isPrefixSubnet(Integer networkPrefixLength, IPAddressNetwork<?, ?, ?, ?, ?> network, int segmentData[]) {
		IPVersion version = network.getIPVersion();
		int bytesPerSegment = IPAddressSection.bytesPerSegment(version);
		int bitsPerSegment = IPAddressSection.bitsPerSegment(version);
		int max = IPAddressSegment.getMaxSegmentValue(version);
		PrefixConfiguration prefConf = network.getPrefixConfiguration();
		AddressParseData addressParseData = getAddressParseData();
		int segmentCount = addressParseData.getSegmentCount();
		if(isCompressed()) {
			int compressedCount = IPv6Address.SEGMENT_COUNT - segmentCount;
			int compressedIndex = addressParseData.getConsecutiveSeparatorSegmentIndex();
			return ParsedAddressGrouping.isPrefixSubnet(
					segmentIndex -> {
						if(segmentIndex >= compressedIndex) {
							if(segmentIndex - compressedIndex < compressedCount) {
								return 0;
							}
							segmentIndex -= compressedCount;
						}
						return (int) getValue(segmentIndex, AddressParseData.KEY_LOWER, segmentData);
					},
					segmentIndex -> {
						if(segmentIndex >= compressedIndex) {
							if(segmentIndex - compressedIndex < compressedCount) {
								return 0;
							}
							segmentIndex -= compressedCount;
						}
						return (int) getValue(segmentIndex, AddressParseData.KEY_UPPER, segmentData);
					},
					segmentCount + compressedCount,
					bytesPerSegment,
					bitsPerSegment,
					max,
					networkPrefixLength,
					prefConf,
					false);
		}
		return ParsedAddressGrouping.isPrefixSubnet(
				segmentIndex -> (int) getValue(segmentIndex, AddressParseData.KEY_LOWER, segmentData),
				segmentIndex -> (int) getValue(segmentIndex, AddressParseData.KEY_UPPER, segmentData),
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				max,
				networkPrefixLength,
				prefConf,
				false);
	}
	@Override 
	public Integer getProviderNetworkPrefixLength() {
		return getQualifier().getEquivalentPrefixLength();
	}
	private static <S extends IPAddressSegment> S[] allocateSegments(
			S segments[],
			S originalSegments[],
			AddressSegmentCreator<S> creator,
			int segmentCount,
			int originalCount) {
		if(segments == null) {
			segments = creator.createSegmentArray(segmentCount);
			if(originalCount > 0) {
				System.arraycopy(originalSegments, 0, segments, 0, originalCount);
			}
		}
		return segments;
	}
	private void createIPv4Sections(boolean doAddress, boolean doRangeBoundaries, boolean withUpper) {
		ParsedHostIdentifierStringQualifier qualifier = getQualifier();
		IPAddress mask = getProviderMask();
		if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
			mask = null; 
		}
		boolean hasMask = mask != null;
		AddressParseData addrParseData = getAddressParseData();
		int segmentCount = addrParseData.getSegmentCount();
		if(hasMask && maskers == null) {
			maskers = new Masker[segmentCount];
		}
		IPv4AddressCreator creator = getIPv4AddressCreator();
		int ipv4SegmentCount = IPv4Address.SEGMENT_COUNT;
		int missingCount = ipv4SegmentCount - segmentCount;
		IPv4AddressSegment[] hostSegments, segments, lowerSegments, upperSegments = null;
		hostSegments = upperSegments = null;
		if(doAddress) {
			segments = creator.createSegmentArray(ipv4SegmentCount);
			lowerSegments = null;
		} else if(doRangeBoundaries) {
			lowerSegments = creator.createSegmentArray(ipv4SegmentCount);
			segments = null;
		} else {
			return;
		}
		@SuppressWarnings("unchecked")
		TranslatedResult<IPv4Address, IPv4AddressSection> finalResult = 
				(TranslatedResult<IPv4Address, IPv4AddressSection>) values;
		if(values == null) {
			values = finalResult = new TranslatedResult<IPv4Address, IPv4AddressSection>() {
				private static final long serialVersionUID = 1L;
				@Override
				ParsedAddressCreator<IPv4Address, IPv4AddressSection, ?, ?> getCreator() {
					return getIPv4AddressCreator();
				}
			};
		}
		boolean expandedSegments = (missingCount <= 0);
		int expandedStart, expandedEnd;
		expandedStart = expandedEnd = -1;
		CharSequence addressString = str;
		boolean maskedIsDifferent = false;
		for(int i = 0, normalizedSegmentIndex = 0; i < segmentCount; i++) {
			long lower = addrParseData.getValue(i, AddressParseData.KEY_LOWER);
			long upper = addrParseData.getValue(i, AddressParseData.KEY_UPPER);
			if(!expandedSegments) {
				boolean isLastSegment = i == segmentCount - 1;
				boolean isWildcard = addrParseData.isWildcard(i);
				expandedSegments = isLastSegment;
				if(!expandedSegments) {
					expandedSegments = !is_inet_aton_joined() && isWildcard;
					if(expandedSegments) {
						for(int j = i + 1; j < segmentCount; j++) {
							if(addrParseData.isWildcard(j)) {
								expandedSegments = false;
								break;
							}
						}
					}
				} 
				if(expandedSegments) {
					if(isWildcard) {
						upper = 0xffffffff >>> ((3 - missingCount) << 3);
					} else {
						expandedStart = i;
						expandedEnd = i + missingCount;
					}
					int bits = IPv4Address.BITS_PER_SEGMENT * (missingCount + 1);
					long maskedLower, maskedUpper;
					if(hasMask) {
						long divMask = 0;
						for(int k = 0; k <= missingCount; k++) {
							divMask = (divMask << IPv4Address.BITS_PER_SEGMENT) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
						}
						Masker masker = maskers[i];
						if(masker == null) {
							long maxValue = (bits == Integer.SIZE) ? 0xffffffffL : ~(~0 << bits);
							maskers[i] = masker = maskRange(lower, upper, divMask, maxValue);
						}
						if(!masker.isSequential() && finalResult.maskException == null) {
							finalResult.maskException = new IncompatibleAddressException(lower, upper, divMask, "ipaddress.error.maskMismatch");
						}
						maskedLower = masker.getMaskedLower(lower, divMask);
						maskedUpper = masker.getMaskedUpper(upper, divMask);
						maskedIsDifferent = maskedIsDifferent || maskedLower != lower || maskedUpper != upper;
					} else {
						maskedLower = lower;
						maskedUpper = upper;
					}
					int shift = bits;
					int count = missingCount;
					while(count >= 0) { 
						shift -= IPv4Address.BITS_PER_SEGMENT;
						Integer currentPrefix = getSegmentPrefixLength(normalizedSegmentIndex, IPv4Address.BITS_PER_SEGMENT, qualifier);
						int segmentBitsMask = IPv4Address.MAX_VALUE_PER_SEGMENT;
						int hostSegLower = (int) (lower >>> shift) & segmentBitsMask;
						int hostSegUpper = (lower == upper) ? hostSegLower : (int) (upper >>> shift) & segmentBitsMask;
						int maskedSegLower, maskedSegUpper;
						if(hasMask) {
							maskedSegLower = (int) (maskedLower >>> shift) & segmentBitsMask;
							maskedSegUpper = (maskedLower == maskedUpper) ? maskedSegLower : (int) (maskedUpper >>> shift) & segmentBitsMask;
						} else {
							maskedSegLower = hostSegLower;
							maskedSegUpper = hostSegUpper;
						}
						if(doAddress) {
							if(maskedIsDifferent || currentPrefix != null) {
								hostSegments = allocateSegments(hostSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
								hostSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV4,
										hostSegLower,
										hostSegUpper,
										false,
										i,
										null,
										creator);
							}
							segments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV4,
								maskedSegLower,
								maskedSegUpper,
								false,
								i,
								currentPrefix,
								creator);
						}
						if(doRangeBoundaries) {
							boolean isRange = maskedSegLower != maskedSegUpper;
							if(!doAddress || isRange) {
								if(doAddress) {
									lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
								} 
								lowerSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV4,
										maskedSegLower,
										maskedSegLower,
										false,
										i,
										currentPrefix,
										creator);
							} else if(lowerSegments != null) {
								lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
							}
							if(withUpper) {
								if(isRange) {
									upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv4SegmentCount, normalizedSegmentIndex);
									upperSegments[normalizedSegmentIndex] = createSegment(
											addressString,
											IPVersion.IPV4,
											maskedSegUpper,
											maskedSegUpper,
											false,
											i,
											currentPrefix,
											creator);
								} else if(upperSegments != null) {
									upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
								}
							}
						}
						++normalizedSegmentIndex;
						count--;
					}
					addrParseData.setBitLength(i, bits);
					continue;
				} 
			}
			long hostLower = lower, hostUpper = upper;
			Masker masker = null;
			boolean unmasked = true;
			if(hasMask) {
				masker = maskers[i];
				int maskInt = mask.getSegment(normalizedSegmentIndex).getSegmentValue();
				if(masker == null) {
					maskers[i] = masker = maskRange(lower, upper, maskInt, creator.getMaxValuePerSegment());
				}
				if(!masker.isSequential() && finalResult.maskException == null) {
					finalResult.maskException = new IncompatibleAddressException(lower, upper, maskInt, "ipaddress.error.maskMismatch");
				}
				lower = (int) masker.getMaskedLower(lower, maskInt);
				upper = (int) masker.getMaskedUpper(upper, maskInt);
				unmasked = hostLower == lower && hostUpper == upper;
				maskedIsDifferent = maskedIsDifferent || !unmasked;
			}
			Integer segmentPrefixLength = getSegmentPrefixLength(normalizedSegmentIndex, IPv4Address.BITS_PER_SEGMENT, qualifier);
			if(doAddress) {
				if(maskedIsDifferent || segmentPrefixLength != null) {
					hostSegments = allocateSegments(hostSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
					hostSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV4,
							(int) hostLower,
							(int) hostUpper,
							true,
							i,
							null,
							creator);
				}
				segments[normalizedSegmentIndex] = createSegment(
						addressString,
						IPVersion.IPV4,
						(int) lower,
						(int) upper,
						unmasked,
						i,
						segmentPrefixLength,
						creator);
			}
			if(doRangeBoundaries) {
				boolean isRange = lower != upper;
				if(!doAddress || isRange) {
					if(doAddress) {
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
					} 
					lowerSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV4,
							(int) lower,
							(int) lower,
							false,
							i,
							segmentPrefixLength,
							creator);
				} else if(lowerSegments != null) {
					lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
				}
				if(withUpper) {
					if(isRange) {
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv4SegmentCount, normalizedSegmentIndex);
						upperSegments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV4,
								(int) upper,
								(int) upper,
								false,
								i,
								segmentPrefixLength,
								creator);
					} else if(upperSegments != null) {
						upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
					}
				}
			}
			normalizedSegmentIndex++;
			addrParseData.setBitLength(i, IPv4Address.BITS_PER_SEGMENT);
		}
		ParsedAddressCreator<IPv4Address, IPv4AddressSection, ?, IPv4AddressSegment> addressCreator = creator;
		Integer prefLength = getPrefixLength(qualifier);
		IPv4AddressSection result, hostResult = null;
		if(doAddress) {
			finalResult.section = result = addressCreator.createPrefixedSectionInternal(segments, prefLength);
			if(hostSegments != null) {
				finalResult.hostSection = hostResult = addressCreator.createSectionInternal(hostSegments);
				if(checkExpandedValues(hostResult, expandedStart, expandedEnd)) {
					finalResult.joinHostException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				}
			}
			if(checkExpandedValues(result, expandedStart, expandedEnd)) {
				finalResult.joinAddressException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				if(hostResult == null) {
					finalResult.joinHostException = finalResult.joinAddressException;
				}
			}
		}
		if(doRangeBoundaries) {
			Integer prefixLength = getPrefixLength(qualifier);
			boolean isPrefixSubnet;
			if(prefixLength != null) {
				IPAddressNetwork<?, ?, ?, ?, ?> network = getParameters().getIPv4Parameters().getNetwork();
				IPv4AddressSegment[] lowerSegs, upperSegs;
				if(doAddress) {
					lowerSegs = upperSegs = segments;
				} else {
					lowerSegs = lowerSegments;
					upperSegs = (upperSegments == null) ? lowerSegments : upperSegments;
				}
				isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
						segmentIndex -> lowerSegs[segmentIndex].getSegmentValue(),
						segmentIndex -> upperSegs[segmentIndex].getUpperSegmentValue(),
						lowerSegs.length,
						IPv4Address.BYTES_PER_SEGMENT,
						IPv4Address.BITS_PER_SEGMENT,
						IPv4Address.MAX_VALUE_PER_SEGMENT,
						prefixLength,
						network.getPrefixConfiguration(),
						false);
				if(isPrefixSubnet) {
					if(lowerSegments == null) {
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv4SegmentCount, ipv4SegmentCount);
					}
					if(upperSegments == null) {
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv4SegmentCount, ipv4SegmentCount);
					}
				}
			} else {
				isPrefixSubnet = false;
			}
			if(lowerSegments != null) {
				finalResult.lowerSection = addressCreator.createPrefixedSectionInternal(lowerSegments, prefLength, true).getLower();
			}
			if(upperSegments != null) {
				IPv4AddressSection section = addressCreator.createPrefixedSectionInternal(upperSegments, prefLength);
				if(isPrefixSubnet) {
					section = section.toPrefixBlock();
				}
				finalResult.upperSection = section.getUpper();
			}
		}
	}
	private void createIPv6Sections(boolean doAddress, boolean doRangeBoundaries, boolean withUpper) {
		ParsedHostIdentifierStringQualifier qualifier = getQualifier();
		IPAddress mask = getProviderMask();
		if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
			mask = null;
		}
		boolean hasMask = mask != null;
		AddressParseData addressParseData = getAddressParseData();
		int segmentCount = addressParseData.getSegmentCount();
		if(hasMask && maskers == null) {
			maskers = new Masker[segmentCount];
		}
		IPv6AddressCreator creator = getIPv6AddressCreator();
		int ipv6SegmentCount = IPv6Address.SEGMENT_COUNT;
		IPv6AddressSegment[] hostSegments, segments, lowerSegments, upperSegments = null;
		hostSegments = upperSegments = null;
		if(doAddress) {
			segments = creator.createSegmentArray(ipv6SegmentCount);
			lowerSegments = null;
		} else if(doRangeBoundaries) {
			lowerSegments = creator.createSegmentArray(ipv6SegmentCount);
			segments = null;
		} else {
			return;
		}
		@SuppressWarnings("unchecked")
		TranslatedResult<IPv6Address,IPv6AddressSection> finalResult = 
				(TranslatedResult<IPv6Address, IPv6AddressSection>) values;
		if(values == null) {
			values = finalResult = new TranslatedResult<IPv6Address,IPv6AddressSection>() {
				private static final long serialVersionUID = 1L;
				@Override
				ParsedAddressCreator<IPv6Address, IPv6AddressSection, ?, ?> getCreator() {
					return getIPv6AddressCreator();
				}
			};
		}
		boolean mixed = isProvidingMixedIPv6();
		int normalizedSegmentIndex = 0;
		int missingSegmentCount = (mixed ? IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT : ipv6SegmentCount) - segmentCount;
		boolean expandedSegments = (missingSegmentCount <= 0);
		int expandedStart, expandedEnd;
		expandedStart = expandedEnd = -1;
		CharSequence addressString = str;
		boolean maskedIsDifferent = false;
		for(int i = 0; i < segmentCount; i++) {
			long lower = addressParseData.getValue(i, AddressParseData.KEY_LOWER);
			long upper = addressParseData.getValue(i, AddressParseData.KEY_UPPER);
			if(!expandedSegments) {
				boolean isLastSegment = i == segmentCount - 1;
				boolean isWildcard = addressParseData.isWildcard(i);
				boolean isCompressed = isCompressed(i);
				expandedSegments = isLastSegment || isCompressed;
				if(!expandedSegments) {
					if(expandedSegments = isWildcard) {
						for(int j = i + 1; j < segmentCount; j++) {
							if(addressParseData.isWildcard(j) || isCompressed(j)) {
								expandedSegments = false;
								break;
							}
						}
					}
				} 
				if(expandedSegments) {
					long lowerHighBytes, upperHighBytes;
					boolean hostIsRange;
					 if(isCompressed) {
						lower = upper = lowerHighBytes = upperHighBytes = 0;
						hostIsRange = false;
					} else if(isWildcard) {
						if(missingSegmentCount > 3) {
							upperHighBytes = 0xffffffffffffffffL >>> ((7 - missingSegmentCount) << 4);
							upper = 0xffffffffffffffffL;
						} else {
							upperHighBytes = 0;
							upper = 0xffffffffffffffffL >>> ((3 - missingSegmentCount) << 4);
						}
						lower = lowerHighBytes = 0;
						hostIsRange = true;
					} else {
						if(missingSegmentCount > 3) {
							lowerHighBytes = addressParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER);
							upperHighBytes = addressParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER);
							hostIsRange = (lower != upper) || (lowerHighBytes != upperHighBytes);
						} else {
							lowerHighBytes = upperHighBytes = 0;
							hostIsRange = (lower != upper);
						}
						expandedStart = i;
						expandedEnd = i + missingSegmentCount;
					}
					int bits = IPv6Address.BITS_PER_SEGMENT * (missingSegmentCount + 1);
					long maskedLower, maskedUpper, maskedLowerHighBytes, maskedUpperHighBytes;
					boolean maskedIsRange;
					if(hasMask) {
						if(isCompressed) {
							maskers[i] = DEFAULT_MASKER;
							maskedLower = maskedUpper = maskedLowerHighBytes = maskedUpperHighBytes = 0;
							maskedIsRange = false;
						} else {
							int bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
							long maskVal = 0;
							if(missingSegmentCount >= 4) {
								ExtendedMasker masker = (ExtendedMasker) maskers[i];
								long extendedMaskVal = 0;
								int extendedCount = missingSegmentCount - 3;
								for(int k = 0; k < extendedCount; k++) {
									extendedMaskVal = (extendedMaskVal << bitsPerSegment) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
								}
								for(int k = extendedCount; k <= missingSegmentCount; k++) {
									maskVal = (maskVal << bitsPerSegment) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
								}
								if(masker == null) {
									long extendedMaxValue = bits == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << (bits - Long.SIZE));
									maskers[i] = masker = maskExtendedRange(
											lower, lowerHighBytes, 
											upper, upperHighBytes, 
											maskVal, extendedMaskVal, 
											0xffffffffffffffffL, extendedMaxValue);
								}
								if(!masker.isSequential() && finalResult.maskException == null) {
									int byteCount = (missingSegmentCount + 1) * IPv6Address.BYTES_PER_SEGMENT;
									finalResult.maskException = new IncompatibleAddressException(
										new BigInteger(1, toBytesSizeAdjusted(lower, lowerHighBytes, byteCount)).toString(), 
										new BigInteger(1, toBytesSizeAdjusted(upper, upperHighBytes, byteCount)).toString(), 
										new BigInteger(1, toBytesSizeAdjusted(maskVal, extendedMaskVal, byteCount)).toString(),
										"ipaddress.error.maskMismatch");
								}
								maskedLowerHighBytes = masker.getExtendedMaskedLower(lowerHighBytes, extendedMaskVal);
								maskedUpperHighBytes = masker.getExtendedMaskedUpper(upperHighBytes, extendedMaskVal);
								maskedLower = masker.getMaskedLower(lower, maskVal);
								maskedUpper = masker.getMaskedUpper(upper, maskVal);
								maskedIsRange = (maskedLower != maskedUpper) || (maskedLowerHighBytes != maskedUpperHighBytes);
								maskedIsDifferent = maskedIsDifferent || maskedLower != lower || maskedUpper != upper|| maskedLowerHighBytes != lowerHighBytes || maskedUpperHighBytes != upperHighBytes;
							} else {
								Masker masker = maskers[i];
								for(int k = 0; k <= missingSegmentCount; k++) {
									maskVal = (maskVal << bitsPerSegment) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
								}
								if(masker == null) {
									long maxValue = bits == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << bits);
									maskers[i] = masker = maskRange(lower, upper, maskVal, maxValue);
								}
								if(!masker.isSequential() && finalResult.maskException == null) {
									finalResult.maskException = new IncompatibleAddressException(lower, upper, maskVal, "ipaddress.error.maskMismatch");
								}
								maskedLowerHighBytes = maskedUpperHighBytes = 0;
								maskedLower = masker.getMaskedLower(lower, maskVal);
								maskedUpper = masker.getMaskedUpper(upper, maskVal);
								maskedIsRange = maskedLower != maskedUpper;
								maskedIsDifferent = maskedIsDifferent || maskedLower != lower || maskedUpper != upper;
							}
						}
					} else {
						maskedLowerHighBytes = lowerHighBytes;
						maskedUpperHighBytes = upperHighBytes;
						maskedLower = lower;
						maskedUpper = upper;
						maskedIsRange = hostIsRange;
					}
					int shift = bits;
					int count = missingSegmentCount;
					while(count >= 0) { 
						Integer currentPrefix = getSegmentPrefixLength(normalizedSegmentIndex, IPv6Address.BITS_PER_SEGMENT, qualifier);
						int hostSegLower, hostSegUpper, maskedSegLower, maskedSegUpper;
						if(isCompressed) {
							hostSegLower = hostSegUpper = maskedSegLower = maskedSegUpper = 0;
						} else {
							shift -= IPv6Address.BITS_PER_SEGMENT;
							int segmentBitsMask = IPv6Address.MAX_VALUE_PER_SEGMENT;
							if(count >= 4) {
								int shorterShift = shift - (IPv6Address.BITS_PER_SEGMENT << 2);
								hostSegLower = (int) (lowerHighBytes >>> shorterShift) & segmentBitsMask;
								hostSegUpper = hostIsRange ? (int) (upperHighBytes >>> shorterShift) & segmentBitsMask : hostSegLower;
								if(hasMask) {
									maskedSegLower = (int) (maskedLowerHighBytes >>> shorterShift) & segmentBitsMask;
									maskedSegUpper = maskedIsRange ? (int) (maskedUpperHighBytes >>> shorterShift) & segmentBitsMask : maskedSegLower;
								} else {
									maskedSegLower = hostSegLower;
									maskedSegUpper = hostSegUpper;
								}
							} else {
								hostSegLower = (int) (lower >>> shift) & segmentBitsMask;
								hostSegUpper = hostIsRange ? (int) (upper >>> shift) & segmentBitsMask : hostSegLower;
								if(hasMask) {
									maskedSegLower = (int) (maskedLower >>> shift) & segmentBitsMask;
									maskedSegUpper = maskedIsRange ? (int) (maskedUpper >>> shift) & segmentBitsMask : maskedSegLower;
								} else {
									maskedSegLower = hostSegLower;
									maskedSegUpper = hostSegUpper;
								}
							}
						}
						if(doAddress) {
							if(maskedIsDifferent || currentPrefix != null) {
								hostSegments = allocateSegments(hostSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
								hostSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV6,
										hostSegLower,
										hostSegUpper,
										false,
										i,
										null,
										creator);
							}
							segments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV6,
								maskedSegLower,
								maskedSegUpper,
								false,
								i,
								currentPrefix,
								creator);
						}
						if(doRangeBoundaries) {
							boolean isSegRange = maskedSegLower != maskedSegUpper;
							if(!doAddress || isSegRange) {
								if(doAddress) {
									lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
								} 
								lowerSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV6,
										maskedSegLower,
										maskedSegLower,
										false,
										i,
										currentPrefix,
										creator);
							} else if(lowerSegments != null) {
								lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
							}
							if(withUpper) {
								if(isSegRange) {
									upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, normalizedSegmentIndex);
									upperSegments[normalizedSegmentIndex] = createSegment(
											addressString,
											IPVersion.IPV6,
											maskedSegUpper,
											maskedSegUpper,
											false,
											i,
											currentPrefix,
											creator);
								} else if(upperSegments != null) {
									upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
								}
							}
						}
						++normalizedSegmentIndex;
						count--;
					}
					addressParseData.setBitLength(i, bits);
					continue;
				} 
			}
			long hostLower = lower, hostUpper = upper;
			Masker masker = null;
			boolean unmasked = true;
			if(hasMask) {
				masker = maskers[i];
				int maskInt = mask.getSegment(normalizedSegmentIndex).getSegmentValue();
				if(masker == null) {
					maskers[i] = masker = maskRange(lower, upper, maskInt, creator.getMaxValuePerSegment());
				}
				if(!masker.isSequential() && finalResult.maskException == null) {
					finalResult.maskException = new IncompatibleAddressException(lower, upper, maskInt, "ipaddress.error.maskMismatch");
				}
				lower = (int) masker.getMaskedLower(lower, maskInt);
				upper = (int) masker.getMaskedUpper(upper, maskInt);
				unmasked =  hostLower == lower && hostUpper == upper;
				maskedIsDifferent = maskedIsDifferent || !unmasked;
			}
			Integer segmentPrefixLength = getSegmentPrefixLength(normalizedSegmentIndex, IPv6Address.BITS_PER_SEGMENT, qualifier);
			if(doAddress) {
				if(maskedIsDifferent || segmentPrefixLength != null) {
					hostSegments = allocateSegments(hostSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
					hostSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV6,
							(int) hostLower,
							(int) hostUpper,
							true,
							i,
							null,
							creator);
				}
				segments[normalizedSegmentIndex] = createSegment(
					addressString,
					IPVersion.IPV6,
					(int) lower,
					(int) upper,
					unmasked,
					i,
					segmentPrefixLength,
					creator);
			}
			if(doRangeBoundaries) {
				boolean isRange = lower != upper;
				if(!doAddress || isRange) {
					if(doAddress) {
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
					} 
					lowerSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV6,
							(int) lower,
							(int) lower,
							false,
							i,
							segmentPrefixLength,
							creator);
				} else if(lowerSegments != null) {
					lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
				}
				if(withUpper) {
					if(isRange) {
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, normalizedSegmentIndex);
						upperSegments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV6,
								(int) upper,
								(int) upper,
								false,
								i,
								segmentPrefixLength,
								creator);
					} else if(upperSegments != null) {
						upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
					}
				}
			}
			normalizedSegmentIndex++;
			addressParseData.setBitLength(i, IPv6Address.BITS_PER_SEGMENT);
		}
		ParsedAddressCreator<?, IPv6AddressSection, IPv4AddressSection, IPv6AddressSegment> addressCreator = creator;
		Integer prefLength = getPrefixLength(qualifier);
		if(mixed) {
			IPv4AddressSeqRange ipv4Range = (IPv4AddressSeqRange) mixedParsedAddress.getProviderSeqRange();
			if(hasMask && mixedMaskers == null) {
				mixedMaskers = new Masker[IPv4Address.SEGMENT_COUNT];
			}
			for(int n = 0; n < 2; n++) {
				int m = n << 1;
				Integer segmentPrefixLength = getSegmentPrefixLength(normalizedSegmentIndex, IPv6Address.BITS_PER_SEGMENT, qualifier);
				IPv4AddressSegment oneLow = ipv4Range.getLower().getSegment(m);
				int o = m + 1;
				IPv4AddressSegment twoLow = ipv4Range.getLower().getSegment(o);
				IPv4AddressSegment oneUp = ipv4Range.getUpper().getSegment(m);
				IPv4AddressSegment twoUp = ipv4Range.getUpper().getSegment(o);
				int oneLower = oneLow.getSegmentValue();
				int twoLower = twoLow.getSegmentValue();
				int oneUpper = oneUp.getSegmentValue();
				int twoUpper = twoUp.getSegmentValue();
				int originalOneLower = oneLower;
				int originalTwoLower = twoLower;
				int originalOneUpper = oneUpper;
				int originalTwoUpper = twoUpper;
				if(hasMask) {
					int maskInt = mask.getSegment(normalizedSegmentIndex).getSegmentValue();
					int shift = IPv4Address.BITS_PER_SEGMENT;
					int shiftedMask = maskInt >> shift;
					Masker masker = mixedMaskers[m];
					if(masker == null) {
						mixedMaskers[m] = masker = maskRange(oneLower, oneUpper, shiftedMask, IPv4Address.MAX_VALUE_PER_SEGMENT);
					}
					if(!masker.isSequential() && finalResult.maskException == null) {
						finalResult.maskException = new IncompatibleAddressException(oneLower, oneUpper, shiftedMask, "ipaddress.error.maskMismatch");
					}
					oneLower = (int) masker.getMaskedLower(oneLower, shiftedMask);
					oneUpper = (int) masker.getMaskedUpper(oneUpper, shiftedMask);
					masker = mixedMaskers[m + 1];
					if(masker == null) {
						mixedMaskers[m + 1] = masker = maskRange(twoLower, twoUpper, maskInt, IPv4Address.MAX_VALUE_PER_SEGMENT);
					}
					if(!masker.isSequential() && finalResult.maskException == null) {
						finalResult.maskException = new IncompatibleAddressException(twoLower, twoUpper, maskInt, "ipaddress.error.maskMismatch");
					}
					twoLower = (int) masker.getMaskedLower(twoLower, maskInt);
					twoUpper = (int) masker.getMaskedUpper(twoUpper, maskInt);
					maskedIsDifferent = maskedIsDifferent || oneLower != originalOneLower || oneUpper != originalOneUpper ||
							twoLower != originalTwoLower || twoUpper != originalTwoUpper;
				}
				boolean isRange = oneLower != oneUpper || twoLower != twoUpper;
				if(doAddress) {
					boolean doHostSegment = maskedIsDifferent || segmentPrefixLength != null;
					if(doHostSegment) {
						hostSegments = allocateSegments(hostSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
					}
					if(!isRange) {
						if(doHostSegment) {
							hostSegments[normalizedSegmentIndex] = createIPv6Segment(originalOneLower, originalTwoLower, null, creator);
						}
						segments[normalizedSegmentIndex] = createIPv6Segment(
								oneLower,
								twoLower,
								segmentPrefixLength,
								creator);
					} else {
						if(doHostSegment) {
							hostSegments[normalizedSegmentIndex] = createIPv6RangeSegment(
									finalResult,
									ipv4Range,
									originalOneLower,
									originalOneUpper,
									originalTwoLower,
									originalTwoUpper,
									null,
									creator);
						}
						segments[normalizedSegmentIndex] = createIPv6RangeSegment(
								finalResult,
								ipv4Range,
								oneLower,
								oneUpper,
								twoLower,
								twoUpper,
								segmentPrefixLength,
								creator);
					}
				}
				if(doRangeBoundaries) {
					if(!doAddress || isRange) {
						if(doAddress) {
							lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
						} 
						lowerSegments[normalizedSegmentIndex] = createIPv6Segment(
								oneLower,
								twoLower,
								segmentPrefixLength,
								creator);
					} else if(lowerSegments != null) {
						lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
					}
					if(withUpper) {
						if(isRange) {
							upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, normalizedSegmentIndex);
							upperSegments[normalizedSegmentIndex] = createIPv6Segment(
									oneUpper,
									twoUpper,
									segmentPrefixLength, 
									creator);
						} else if(upperSegments != null) {
							upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
						}
					}
				}
				normalizedSegmentIndex++;
			}
		}
		IPv6AddressSection result, hostResult = null;
		if(doAddress) {
			if(hostSegments != null) {
				finalResult.hostSection = hostResult = addressCreator.createSectionInternal(hostSegments);
				if(checkExpandedValues(hostResult, expandedStart, expandedEnd)) {
					finalResult.joinHostException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				}
			}
			finalResult.section = result = addressCreator.createPrefixedSectionInternal(segments, prefLength);
			if(checkExpandedValues(result, expandedStart, expandedEnd)) {
				finalResult.joinAddressException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				if(hostResult == null) {
					finalResult.joinHostException = finalResult.joinAddressException;
				}
			}
		}
		if(doRangeBoundaries) {
			Integer prefixLength = getPrefixLength(qualifier);
			boolean isPrefixSubnet;
			if(prefixLength != null) {
				IPAddressNetwork<?, ?, ?, ?, ?> network = getParameters().getIPv6Parameters().getNetwork();
				IPv6AddressSegment[] lowerSegs, upperSegs;
				if(doAddress) {
					lowerSegs = upperSegs = segments;
				} else {
					lowerSegs = lowerSegments;
					upperSegs = (upperSegments == null) ? lowerSegments : upperSegments;
				}
				isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
						segmentIndex -> lowerSegs[segmentIndex].getSegmentValue(),
						segmentIndex -> upperSegs[segmentIndex].getUpperSegmentValue(),
						lowerSegs.length,
						IPv6Address.BYTES_PER_SEGMENT,
						IPv6Address.BITS_PER_SEGMENT,
						IPv6Address.MAX_VALUE_PER_SEGMENT,
						prefixLength,
						network.getPrefixConfiguration(),
						false);
				if(isPrefixSubnet) {
					if(lowerSegments == null) {
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, ipv6SegmentCount);
					}
					if(upperSegments == null) {
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, ipv6SegmentCount);
					}
				}
			} else {
				isPrefixSubnet = false;
			}
			if(lowerSegments != null) {
				finalResult.lowerSection = addressCreator.createPrefixedSectionInternal(lowerSegments, prefLength, true).getLower(); 
			}
			if(upperSegments != null) {
				IPv6AddressSection section = addressCreator.createPrefixedSectionInternal(upperSegments, prefLength);
				if(isPrefixSubnet) {
					section = section.toPrefixBlock();
				}
				finalResult.upperSection = section.getUpper();
			}
		}
	}
	private static boolean checkExpandedValues(IPAddressSection section, int start, int end) {
		if(section != null && start < end) {
			IPAddressSegment seg = section.getSegment(start);
			boolean lastWasRange = seg.isMultiple();
			do {
				seg = section.getSegment(++start);
				if(lastWasRange) {
					if(!seg.isFullRange()) {
						return true;
					}
				} else {
					lastWasRange = seg.isMultiple();
				}
			} while(start < end);
		}
		return false;
	}
	private <S extends IPAddressSegment> S createSegment(
			CharSequence addressString,
			IPVersion version,
			int val,
			int upperVal,
			boolean useFlags,
			int parsedSegIndex,
			Integer segmentPrefixLength,
			ParsedAddressCreator<?, ?, ?, S> creator) {
		AddressParseData parseData = getAddressParseData();
		if(val != upperVal) {
			return createRangeSeg(addressString, version, val, upperVal,
					useFlags, parseData, parsedSegIndex,
					segmentPrefixLength, creator);
		}
		S result;
		if(!useFlags) {
			result = creator.createSegment(val, val, segmentPrefixLength);
		} else {
			result = creator.createSegmentInternal(
				val,
				segmentPrefixLength,
				addressString,
				val,
				parseData.getFlag(parsedSegIndex, AddressParseData.KEY_STANDARD_STR),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_END_INDEX));
		}
		return result;
	}
	private IPv6AddressSegment createIPv6Segment(int value1, int value2, Integer segmentPrefixLength, IPv6AddressCreator creator) {
		int value = (value1 << IPv4Address.BITS_PER_SEGMENT) | value2;
		IPv6AddressSegment result = creator.createSegment(value, segmentPrefixLength);
		return result;
	}
	private static IPv6AddressSegment createIPv6RangeSegment(
			TranslatedResult<?,?> finalResult,
			AddressItem item,
			int upperRangeLower,
			int upperRangeUpper,
			int lowerRangeLower,
			int lowerRangeUpper,
			Integer segmentPrefixLength,
			IPv6AddressCreator creator) {
		int shift = IPv4Address.BITS_PER_SEGMENT;
		if(upperRangeLower != upperRangeUpper) {
			if(segmentPrefixLength != null && creator.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				if(segmentPrefixLength > shift) {
					int lowerPrefixLength = segmentPrefixLength - shift;
					int fullMask = ~(~0 << shift); 
					int networkMask = fullMask & (fullMask << (shift - lowerPrefixLength));
					int hostMask = ~networkMask & fullMask;
					lowerRangeLower &= networkMask;
					lowerRangeUpper |= hostMask;
					if(finalResult.mixedException == null && lowerRangeLower != 0 || lowerRangeUpper != IPv4Address.MAX_VALUE_PER_SEGMENT) {
						finalResult.mixedException = new IncompatibleAddressException(item, "ipaddress.error.invalidMixedRange");
					}
				} else {
					lowerRangeLower = 0;
					lowerRangeUpper = IPv4Address.MAX_VALUE_PER_SEGMENT;
				}
			} else if(finalResult.mixedException == null && lowerRangeLower != 0 || lowerRangeUpper != IPv4Address.MAX_VALUE_PER_SEGMENT) {
				finalResult.mixedException = new IncompatibleAddressException(item, "ipaddress.error.invalidMixedRange");
			}
		}
		return creator.createSegment(
				(upperRangeLower << shift) | lowerRangeLower,
				(upperRangeUpper << shift) | lowerRangeUpper,
				segmentPrefixLength);
	}
	private static <S extends IPAddressSegment> S createRangeSeg(
			CharSequence addressString,
			IPVersion version,
			int stringLower,
			int stringUpper,
			boolean useFlags,
			AddressParseData parseData,
			int parsedSegIndex,
			Integer segmentPrefixLength,
			ParsedAddressCreator<?, ?, ?, S> creator) {
		int lower = stringLower, upper = stringUpper;
		S result;
		if(!useFlags) {
			result = creator.createSegment(lower, upper, segmentPrefixLength);
		} else {
			result = creator.createRangeSegmentInternal(
				lower,
				upper,
				segmentPrefixLength,
				addressString,
				stringLower,
				stringUpper,
				parseData.getFlag(parsedSegIndex, AddressParseData.KEY_STANDARD_STR),
				parseData.getFlag(parsedSegIndex, AddressParseData.KEY_STANDARD_RANGE_STR),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_END_INDEX),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX));
		}
		return result;
	}
	private static <S extends IPAddressSegment> S createFullRangeSegment(
			IPVersion version,
			int stringLower,
			int stringUpper,
			int parsedSegIndex,
			Integer segmentPrefixLength,
			Integer mask,
			ParsedAddressCreator<?, ?, ?, S> creator) {
		boolean hasMask = (mask != null);
		if(hasMask) {
			int maskInt = mask.intValue();
			Masker masker = maskRange(stringLower, stringUpper, maskInt, creator.getMaxValuePerSegment());
			if(!masker.isSequential()) {
				throw new IncompatibleAddressException(stringLower, stringUpper, maskInt, "ipaddress.error.maskMismatch");
			}
			stringLower = (int) masker.getMaskedLower(stringLower, maskInt);
			stringUpper = (int) masker.getMaskedUpper(stringUpper, maskInt);
		}
		S result = createRangeSeg(null, version, stringLower, stringUpper,
				false, null, parsedSegIndex, segmentPrefixLength, creator);
		return result;
	}
	static IPAddress createAllAddress(
			IPVersion version,
			ParsedHostIdentifierStringQualifier qualifier,
			HostIdentifierString originator, 
			IPAddressStringParameters options) {
		int segmentCount = IPAddress.getSegmentCount(version);
		IPAddress mask = qualifier.getMaskLower();
		if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
			mask = null;
		}
		boolean hasMask = mask != null;
		Integer prefLength = getPrefixLength(qualifier);
		if(version.isIPv4()) {
			ParsedAddressCreator<IPv4Address, IPv4AddressSection, ?, IPv4AddressSegment> creator = options.getIPv4Parameters().getNetwork().getAddressCreator();
			IPv4AddressSegment segments[] = creator.createSegmentArray(segmentCount);
			for(int i = 0; i < segmentCount; i++) {
				Integer segmentMask = hasMask ? cacheSegmentMask(mask.getSegment(i).getSegmentValue()) : null;
				segments[i] = createFullRangeSegment(
						version,
						0,
						IPv4Address.MAX_VALUE_PER_SEGMENT,
						i,
						getSegmentPrefixLength(i, version, qualifier),
						segmentMask,
						creator);
			}
			return creator.createAddressInternal(segments, originator, prefLength);
		} else {
			ParsedAddressCreator<IPv6Address, IPv6AddressSection, ?, IPv6AddressSegment> creator = options.getIPv6Parameters().getNetwork().getAddressCreator();
			IPv6AddressSegment segments[] = creator.createSegmentArray(segmentCount);
			for(int i = 0; i < segmentCount; i++) {
				Integer segmentMask = hasMask ? cacheSegmentMask(mask.getSegment(i).getSegmentValue()) : null;
				segments[i] = createFullRangeSegment(
						version,
						0,
						IPv6Address.MAX_VALUE_PER_SEGMENT,
						i,
						getSegmentPrefixLength(i, version, qualifier),
						segmentMask,
						creator);
			}
			return creator.createAddressInternal(segments, qualifier.getZone(), originator, prefLength);
		}
	}
	private static Integer getPrefixLength(ParsedHostIdentifierStringQualifier qualifier) {
		return qualifier.getEquivalentPrefixLength();
	}
	private static Integer getSegmentPrefixLength(int segmentIndex, int bitsPerSegment, ParsedHostIdentifierStringQualifier qualifier) {
		Integer bits = getPrefixLength(qualifier);
		return ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, bits, segmentIndex);
	}
	private static Integer getSegmentPrefixLength(int segmentIndex, IPVersion version, ParsedHostIdentifierStringQualifier qualifier) {
		return getSegmentPrefixLength(segmentIndex, IPAddressSection.bitsPerSegment(version), qualifier);
	}
	private static Integer cacheSegmentMask(int i) {
		return ParsedAddressGrouping.cache(i);
	}
}
package inet.ipaddr.ipv6;
import java.io.Serializable;
import java.net.Inet6Address;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.BiFunction;
import java.util.function.Function;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.HostIdentifierString;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv6.IPv6Address.IPv6Zone;
import inet.ipaddr.ipv6.IPv6AddressSection.EmbeddedIPv6AddressSection;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressSection;
public class IPv6AddressNetwork extends IPAddressNetwork<IPv6Address, IPv6AddressSection, IPv4AddressSection, IPv6AddressSegment, Inet6Address> {
	private static final long serialVersionUID = 4L;
	private static PrefixConfiguration defaultPrefixConfiguration = AddressNetwork.getDefaultPrefixConfiguration();
	static final IPv6AddressSegment EMPTY_SEGMENTS[] = {};
	private static final IPv6AddressSection EMPTY_SECTION[] = {};
	private static final IPv6Address EMPTY_ADDRESS[] = {};
	private static boolean CACHE_SEGMENTS_BY_PREFIX = true;
	private IPv6AddressSection linkLocalPrefix;
	public static class IPv6AddressCreator extends IPAddressCreator<IPv6Address, IPv6AddressSection, IPv4AddressSection, IPv6AddressSegment, Inet6Address> {
		private static final long serialVersionUID = 4L;
		protected static class Cache implements Serializable {
			private static final long serialVersionUID = 1L;
			private transient IPv6AddressSegment ZERO_PREFIX_SEGMENT, ALL_RANGE_SEGMENT;
			private transient IPv6AddressSegment segmentCache[][];
			private transient IPv6AddressSegment segmentPrefixCache[][][];
			private transient IPv6AddressSegment allPrefixedCache[];
			private static final int MAX_ZONE_ENTRIES = 100;
			@SuppressWarnings("serial")
			private transient LinkedHashMap<String, IPv6Zone> zoneInterfaceCache = new LinkedHashMap<String, IPv6Zone>(16, 0.75f, true) {
				@Override
				protected boolean removeEldestEntry(Map.Entry<String, IPv6Zone> eldest) {
					return size() > MAX_ZONE_ENTRIES;
				}
			};
			private ReadWriteLock zoneInterfaceCacheLock = new ReentrantReadWriteLock();
			private transient IPv6Zone scopedZoneCache[] = new IPv6Zone[256];
			void clear() {
				segmentCache = null;
				allPrefixedCache = null;
				segmentPrefixCache = null;
				ZERO_PREFIX_SEGMENT = null;
				ALL_RANGE_SEGMENT = null;
				IPv6Zone scopedZoneCache2[] = scopedZoneCache;
				scopedZoneCache = new IPv6Zone[256];
				Arrays.fill(scopedZoneCache2, null);
				Lock lock = zoneInterfaceCacheLock.writeLock();
				lock.lock();
				zoneInterfaceCache.clear();
				lock.unlock();
			}
		}
		Cache cache;
		boolean useSegmentCache = true;
		public IPv6AddressCreator(IPv6AddressNetwork network) {
			super(network);
			cache = new Cache();
		}
		protected IPv6AddressCreator(IPv6AddressNetwork network, Cache cache) {
			super(network);
			this.cache = cache;
		}
		@Override
		public void clearCaches() {
			super.clearCaches();
			cache.clear();
		}
		@Override
		public void setSegmentCaching(boolean enable) {
			useSegmentCache = enable;
		}
		@Override
		public IPv6AddressNetwork getNetwork() {
			return (IPv6AddressNetwork) super.getNetwork();
		}
		@Override
		public int getMaxValuePerSegment() {
			return IPv6Address.MAX_VALUE_PER_SEGMENT;
		}
		@Override
		protected int getAddressSegmentCount() {
			return IPv6Address.SEGMENT_COUNT;
		}
		@Override
		public IPv6AddressSegment[] createSegmentArray(int length) {
			if(length == 0) {
				return EMPTY_SEGMENTS;
			}
			return new IPv6AddressSegment[length];
		}
		@Override
		public IPv6AddressSegment createSegment(int value) {
			if(useSegmentCache && value >= 0 && value <= IPv6Address.MAX_VALUE_PER_SEGMENT) {
				IPv6AddressSegment result, block[], cache[][] = this.cache.segmentCache;
				int blockIndex = value >>> 8; 
				int resultIndex = value - (blockIndex << 8); 
				if(cache == null) {
					this.cache.segmentCache = cache = new IPv6AddressSegment[((2 * IPv6Address.MAX_VALUE_PER_SEGMENT) - 1) / 0x100][];
					cache[blockIndex] = block = new IPv6AddressSegment[0x100];
					result = block[resultIndex] = new IPv6AddressSegment(value);
				} else {
					block = cache[blockIndex];
					if(block == null) {
						cache[blockIndex] = block = new IPv6AddressSegment[0x100];
						result = block[resultIndex] = new IPv6AddressSegment(value);
					} else {
						result = block[resultIndex];
						if(result == null) {
							result = block[resultIndex] = new IPv6AddressSegment(value);
						}
					}
				}
				return result;
			}
			return new IPv6AddressSegment(value);
		}
		@Override
		public IPv6AddressSegment createSegment(int value, Integer segmentPrefixLength) {
			if(segmentPrefixLength == null) {
				return createSegment(value);
			}
			if(useSegmentCache && value >= 0 && value <= IPv6Address.MAX_VALUE_PER_SEGMENT && segmentPrefixLength >= 0 && segmentPrefixLength <= IPv6Address.BIT_COUNT) {
				if(segmentPrefixLength == 0 && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
					IPv6AddressSegment result = cache.ZERO_PREFIX_SEGMENT;
					if(result == null) {
						cache.ZERO_PREFIX_SEGMENT = result = new IPv6AddressSegment(0, 0);
					}
					return result;
				}
				if(CACHE_SEGMENTS_BY_PREFIX) {
					int prefixIndex = segmentPrefixLength;
					int valueIndex;
					boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
					if(isAllSubnets) {
						int mask = getNetwork().getSegmentNetworkMask(segmentPrefixLength);
						value &= mask;
						valueIndex = value >>> (IPv6Address.BITS_PER_SEGMENT- segmentPrefixLength);
					} else {
						valueIndex = value;
					}
					IPv6AddressSegment result, block[], prefixCache[][], cache[][][] = this.cache.segmentPrefixCache;
					int blockIndex = valueIndex >>> 8; 
					int resultIndex = valueIndex - (blockIndex << 8); 
					if(cache == null) {
						this.cache.segmentPrefixCache = cache = new IPv6AddressSegment[IPv6Address.BITS_PER_SEGMENT + 1][][];
						prefixCache = null;
						block = null;
						result = null;
					} else {
						prefixCache = cache[prefixIndex];
						if(prefixCache != null) {
							block = prefixCache[blockIndex];
							if(block != null) {
								result = block[resultIndex];
							} else {
								result = null;
							}
						} else {
							block = null;
							result = null;
						}
					}
					if(prefixCache == null) {
						int prefixCacheSize = isAllSubnets ? 1 << segmentPrefixLength : IPv6Address.MAX_VALUE_PER_SEGMENT + 1;
						cache[prefixIndex] = prefixCache = new IPv6AddressSegment[(prefixCacheSize + 0x100 - 1) >>> 8][];
					}
					if(block == null) {
						int prefixCacheSize = isAllSubnets ? 1 << segmentPrefixLength : IPv6Address.MAX_VALUE_PER_SEGMENT + 1;
						int highestIndex = prefixCacheSize >>> 8; 
						if(valueIndex >>> 8 == highestIndex) { 
							block = new IPv6AddressSegment[prefixCacheSize - (highestIndex << 8)]; 
						} else { 
							block = new IPv6AddressSegment[0x100];
						}
						prefixCache[blockIndex] = block;
					}
					if(result == null) {
						block[resultIndex] = result = new IPv6AddressSegment(value, segmentPrefixLength);
					}
					return result;
				}
			}
			IPv6AddressSegment result = new IPv6AddressSegment(value, segmentPrefixLength);
			return result;
		}
		@Override
		public IPv6AddressSegment createSegment(int lower, int upper, Integer segmentPrefixLength) {
			if(segmentPrefixLength == null) {
				if(lower == upper) {
					return createSegment(lower);
				}
				if(useSegmentCache && lower == 0 && upper == IPv6Address.MAX_VALUE_PER_SEGMENT) {
					IPv6AddressSegment result = cache.ALL_RANGE_SEGMENT;
					if(result == null) {
						cache.ALL_RANGE_SEGMENT = result = new IPv6AddressSegment(0, IPv6Address.MAX_VALUE_PER_SEGMENT, null);
					}
					return result;
				}
			} else {
				if(lower == upper) {
					return createSegment(lower, segmentPrefixLength);
				}
				if(useSegmentCache && lower >= 0 && lower <= IPv6Address.MAX_VALUE_PER_SEGMENT && 
					upper >= 0 && upper <= IPv6Address.MAX_VALUE_PER_SEGMENT && 
						segmentPrefixLength >= 0 && segmentPrefixLength <= IPv6Address.BIT_COUNT) {
					if(segmentPrefixLength == 0 && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
						return createSegment(0, segmentPrefixLength);
					}
					if(CACHE_SEGMENTS_BY_PREFIX) {
						int bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
						if(segmentPrefixLength > bitsPerSegment) {
							segmentPrefixLength = bitsPerSegment;
						}
						if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
							int mask = getNetwork().getSegmentNetworkMask(segmentPrefixLength);
							lower &= mask;
							if((upper & mask) == lower) {
								return createSegment(lower, segmentPrefixLength);
							}
							int hostMask = getNetwork().getSegmentHostMask(segmentPrefixLength);
							upper |= hostMask;
						}
						if(lower == 0 && upper == IPv6Address.MAX_VALUE_PER_SEGMENT) {
							int prefixIndex = segmentPrefixLength;
							IPv6AddressSegment result, cache[] = this.cache.allPrefixedCache;
							if(cache == null) {
								this.cache.allPrefixedCache = cache = new IPv6AddressSegment[IPv6Address.BITS_PER_SEGMENT + 1];
								cache[prefixIndex] = result = new IPv6AddressSegment(0, IPv6Address.MAX_VALUE_PER_SEGMENT, segmentPrefixLength);
							} else {
								result = cache[prefixIndex];
								if(result == null) {
									cache[prefixIndex] = result = new IPv6AddressSegment(0, IPv6Address.MAX_VALUE_PER_SEGMENT, segmentPrefixLength);
								}
							}
							return result;
						}
					}
				}
			}
			IPv6AddressSegment result = new IPv6AddressSegment(lower, upper, segmentPrefixLength);
			return result;
		}
		@Override
		public IPv6AddressSection createFullSectionInternal(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix) {
			return new IPv6AddressSection(lowerValueProvider, upperValueProvider, IPv6Address.SEGMENT_COUNT, prefix);
		}
		@Override
		protected IPv6AddressSection createSectionInternal(byte[] bytes, int segmentCount, Integer prefix, boolean singleOnly) {
			return new IPv6AddressSection(bytes, segmentCount, prefix, false, singleOnly);
		}
		@Override
		protected IPv6AddressSection createSectionInternal(IPv6AddressSegment segments[]) {
			return new IPv6AddressSection(segments, 0, false);
		}
		@Override
		protected IPv6AddressSection createPrefixedSectionInternal(IPv6AddressSegment segments[], Integer prefix, boolean singleOnly) {
			return new IPv6AddressSection(segments, 0, false, prefix, singleOnly);
		}
		@Override
		protected IPv6AddressSection createSectionInternal(IPv6AddressSegment segments[], IPv4AddressSection embeddedSection) {
			IPv6AddressSection result = new IPv6AddressSection(segments, 0, false);
			result.embeddedIPv4Section = embeddedSection;
			return result;
		}
		@Override
		protected IPv6AddressSection createSectionInternal(IPv6AddressSegment segments[], IPv4AddressSection embeddedSection, Integer prefix) {
			IPv6AddressSection result = new IPv6AddressSection(segments, 0, false, prefix, false);
			result.embeddedIPv4Section = embeddedSection;
			return result;
		}
		@Override
		protected IPv6AddressSection createSectionInternal(IPv6AddressSegment segments[], IPv4AddressSection embeddedSection, Integer prefix, boolean singleOnly) {
			IPv6AddressSection result = new IPv6AddressSection(segments, 0, false, prefix, singleOnly);
			result.embeddedIPv4Section = embeddedSection;
			return result;
		}
		protected IPv6AddressSection createEmbeddedSectionInternal(IPv6AddressSection encompassingSection, IPv6AddressSegment segments[], int startIndex) {
			return new EmbeddedIPv6AddressSection(encompassingSection, segments, startIndex);
		}
		@Override
		protected IPv6AddressSection createEmbeddedSectionInternal(IPAddressSection encompassingSection, IPv6AddressSegment segments[]) {
			return new EmbeddedIPv6AddressSection((IPv6AddressSection) encompassingSection, segments, 0);
		}
		protected IPv6AddressSection createSectionInternal(IPv6AddressSegment segments[], int startIndex) {
			return new IPv6AddressSection(segments, startIndex, false);
		}
		@Override
		protected IPv6AddressSection createSectionInternal(IPv6AddressSegment[] segments, int startIndex, boolean extended) {
			return new IPv6AddressSection(segments, startIndex, false);
		}
		@Override
		protected IPv6AddressSection[] createSectionArray(int length) {
			if(length == 0) {
				return EMPTY_SECTION;
			}
			return new IPv6AddressSection[length];
		}
		@Override
		public IPv6AddressSection createSection(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix) {
			return new IPv6AddressSection(bytes, byteStartIndex, byteEndIndex, -1, prefix, true, false);
		}
		@Override
		protected IPv6AddressSection createSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer prefix) {
			return new IPv6AddressSection(bytes, byteStartIndex, byteEndIndex, segmentCount, prefix, true, false);
		}
		protected IPv6AddressSection createSection(long highBytes, long lowBytes, int segmentCount, Integer prefix) {
			return new IPv6AddressSection(highBytes, lowBytes, segmentCount, prefix);
		}
		@Override
		public IPv6AddressSection createSection(byte bytes[], Integer prefix) {
			return new IPv6AddressSection(bytes, prefix);
		}
		@Override
		public IPv6AddressSection createSection(IPv6AddressSegment segments[]) {
			return new IPv6AddressSection(segments);
		}
		@Override
		public IPv6AddressSection createSection(IPv6AddressSegment segments[], Integer networkPrefixLength) {
			return new IPv6AddressSection(segments, networkPrefixLength);
		}
		public IPv6AddressSection createSection(MACAddress eui) {
			return new IPv6AddressSection(eui);
		}
		public IPv6AddressSection createSection(MACAddressSection eui) {
			return new IPv6AddressSection(eui);
		}
		@Override
		protected IPv6Address[] createAddressArray(int length) {
			if(length == 0) {
				return EMPTY_ADDRESS;
			}
			return new IPv6Address[length];
		}
		@Override
		protected IPv6Address createAddressInternal(IPv6AddressSegment segments[]) {
			return super.createAddressInternal(segments);
		}
		@Override
		protected IPv6Address createAddressInternal(IPv6AddressSection section, CharSequence zone) {
			if(zone == null || zone.length() == 0) {
				return createAddress(section);
			}
			String zoneStr = zone.toString().trim();
			if(zoneStr.length() == 0) {
				return createAddress(section);
			}
			IPv6Zone zoneObj = getCacheZoneObj(zoneStr);
			return createAddress(section, zoneObj);
		}
		private IPv6Zone getCacheZoneObj(String zoneStr) {
			int scope = IPv6Zone.checkIfScope(zoneStr);
			IPv6Zone zoneObj;
			if(scope >= 0) {
				if(scope < cache.scopedZoneCache.length) {
					zoneObj = cache.scopedZoneCache[scope];
					if(zoneObj == null) {
						zoneObj = new IPv6Zone(scope);
						cache.scopedZoneCache[scope] = zoneObj;
					}
				} else {
					zoneObj = new IPv6Zone(scope);
				}
				zoneObj.zoneStr = zoneStr;
			} else {
				Lock readLock = cache.zoneInterfaceCacheLock.readLock();
				readLock.lock();
				zoneObj = cache.zoneInterfaceCache.get(zoneStr);
				readLock.unlock();
				if(zoneObj == null) {
					IPv6Zone newZoneObj = new IPv6Zone(zoneStr);
					Lock writeLock = cache.zoneInterfaceCacheLock.writeLock();
					writeLock.lock();
					zoneObj = cache.zoneInterfaceCache.get(zoneStr);
					if(zoneObj == null) {
						zoneObj = newZoneObj;
						cache.zoneInterfaceCache.put(zoneStr, zoneObj);
					}
					writeLock.unlock();
				}
			}
			return zoneObj;
		}
		public IPv6Address createAddress(IPv6AddressSegment segments[], IPv6Zone zone) {
			if(zone == null) {
				return createAddressInternal(segments);
			}
			return createAddress(createSectionInternal(segments), zone);
		}
		public IPv6Address createAddress(IPv6AddressSection section, IPv6Zone zone) {
			if(zone == null) {
				return createAddress(section);
			}
			return new IPv6Address(section, zone);
		}
		@Override
		protected IPv6Address createAddressInternal(IPv6AddressSection section, CharSequence zone, HostIdentifierString from, IPv6Address lower, IPv6Address upper) {
			IPv6Address result = createAddressInternal(section, zone, from);
			result.cache(lower, upper);
			return result;
		}
		@Override
		public IPv6Address createAddress(IPv6AddressSection section) {
			return new IPv6Address(section);
		}
		@Override
		public IPv6Address createAddress(Inet6Address addr, Integer networkPrefixLength) {
			return new IPv6Address(addr, networkPrefixLength);
		}
		@Override
		public IPv6Address createAddress(Inet6Address addr) {
			return new IPv6Address(addr);
		}
	};
	public IPv6AddressNetwork() {
		super(IPv6Address.class);
	}
	@Override
	public PrefixConfiguration getPrefixConfiguration() {
		return defaultPrefixConfiguration;
	}
	public static void setDefaultPrefixConfiguration(PrefixConfiguration config) {
		defaultPrefixConfiguration = config;
	}
	public static PrefixConfiguration getDefaultPrefixConfiguration() {
		return defaultPrefixConfiguration;
	}
	protected boolean isCompatible(IPv6AddressNetwork other) {
		return super.isCompatible(other);
	}
	@Override
	protected BiFunction<IPv6Address, Integer, IPv6AddressSegment> getSegmentProducer() {
		return (address, index) -> address.getSegment(index);
	}
	@Override
	protected Function<IPv6Address, IPv6AddressSection> getSectionProducer() {
		return IPv6Address::getSection;
	}
	@Override
	protected IPv6AddressCreator createAddressCreator() {
		return new IPv6AddressCreator(this);
	}
	@Override
	protected IPv6Address createLoopback() {
		IPv6AddressCreator creator = getAddressCreator();
		IPv6AddressSegment zero = creator.createSegment(0);
		IPv6AddressSegment segs[] = creator.createSegmentArray(IPv6Address.SEGMENT_COUNT);
		segs[0] = segs[1] = segs[2] = segs[3] = segs[4] = segs[5] = segs[6] = zero;
		segs[7] = creator.createSegment(1);
		return creator.createAddressInternal(segs); 
	}
	public IPv6AddressSection getLinkLocalPrefix() {
		if(linkLocalPrefix == null) {
			synchronized(this) {
				if(linkLocalPrefix == null) {
					linkLocalPrefix = createLinkLocalPrefix();
				}
			}
		}
		return linkLocalPrefix;
	}
	private IPv6AddressSection createLinkLocalPrefix() {
		IPv6AddressCreator creator = getAddressCreator();
		IPv6AddressSegment zeroSeg = creator.createSegment(0);
		IPv6AddressSection linkLocalPrefix = creator.createSectionInternal(new IPv6AddressSegment[] {
				creator.createSegment(0xfe80),
				zeroSeg,
				zeroSeg,
				zeroSeg});
		return linkLocalPrefix;
	}
	@Override
	public IPv6AddressCreator getAddressCreator() {
		return (IPv6AddressCreator) super.getAddressCreator();
	}
	@Override
	public boolean isIPv6() {
		return true;
	}
	@Override
	public IPVersion getIPVersion() {
		return IPVersion.IPV6;
	}
}
package inet.ipaddr.ipv4;
import java.math.BigInteger;
import java.net.Inet4Address;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressConverter;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4AddressCache;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringBuilderOptions;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringCollection;
import inet.ipaddr.ipv4.IPv4AddressTrie.IPv4TrieNode.IPv4TrieKeyData;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6Address.IPv6AddressConverter;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.ipv6.IPv6AddressSegment;
public class IPv4Address extends IPAddress implements Iterable<IPv4Address> {
	private static final long serialVersionUID = 4L;
	public static final char SEGMENT_SEPARATOR = '.';
	public static final int BITS_PER_SEGMENT = 8;
	public static final int BYTES_PER_SEGMENT = 1;
	public static final int SEGMENT_COUNT = 4;
	public static final int BYTE_COUNT = 4;
	public static final int BIT_COUNT = 32;
	public static final int DEFAULT_TEXTUAL_RADIX = 10;
	public static final int MAX_VALUE_PER_SEGMENT = 0xff;
	public static final int MAX_VALUE = 0xffffffff;
	public static final String REVERSE_DNS_SUFFIX = ".in-addr.arpa";
	transient IPv4AddressCache addressCache;
	private transient IPv4TrieKeyData cachedTrieKeyData;
	public IPv4Address(IPv4AddressSegment[] segments) throws AddressValueException {
		this(segments, null);
	}
	public IPv4Address(IPv4AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(segments, networkPrefixLength));
		if(getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv4.invalid.segment.count", getSegmentCount());
		}
	}
	public IPv4Address(IPv4AddressSection section) throws AddressValueException {
		super(section);
		if(section.getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv4.invalid.segment.count", section.getSegmentCount());
		}
	}
	public IPv4Address(int address) {
		this(address, null);
	}
	public IPv4Address(int address, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSectionInternal(address, networkPrefixLength));
	}
	public IPv4Address(Inet4Address inet4Address, Integer networkPrefixLength) {
		this(inet4Address, inet4Address.getAddress(), networkPrefixLength);
	}
	public IPv4Address(Inet4Address inet4Address) {
		this(inet4Address, inet4Address.getAddress(), null);
	}
	private IPv4Address(Inet4Address inet4Address, byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(bytes, 0, bytes.length, IPv4Address.SEGMENT_COUNT, networkPrefixLength));
		getSection().setInetAddress(inet4Address);
	}
	public IPv4Address(byte[] bytes) throws AddressValueException {
		this(bytes, null);
	}
	public IPv4Address(byte[] bytes, int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, null);
	}
	public IPv4Address(byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, 0, bytes.length, networkPrefixLength);
	}
	public IPv4Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(bytes, byteStartIndex, byteEndIndex, IPv4Address.SEGMENT_COUNT, networkPrefixLength));
	}
	public IPv4Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createFullSectionInternal(lowerValueProvider, upperValueProvider, networkPrefixLength));
	}
	public IPv4Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, null);
	}
	public IPv4Address(SegmentValueProvider valueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, networkPrefixLength);
	}
	public IPv4Address(SegmentValueProvider valueProvider) {
		this(valueProvider, (Integer) null);
	}
	@Override
	public IPv4AddressSection getSection() {
		return (IPv4AddressSection) super.getSection();
	}
	@Override
	public IPv4AddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPv4AddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	@Override
	public IPv4AddressSegment getDivision(int index) {
		return getSegment(index);
	}
	@Override
	public IPv4AddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	@Override
	public IPv4AddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv4StringBuilderOptions.from(options));
	}
	public IPAddressStringDivisionSeries[] getParts(IPv4StringBuilderOptions options) {
		IPAddressStringDivisionSeries parts[] = getSection().getParts(options);
		IPv6Address ipv6Addr = getConverted(options);
		if(ipv6Addr != null) {
			IPAddressStringDivisionSeries ipv6Parts[] = ipv6Addr.getParts(options.ipv6ConverterOptions);
			IPAddressStringDivisionSeries tmp[] = parts;
			parts = new IPAddressStringDivisionSeries[tmp.length + ipv6Parts.length];
			System.arraycopy(tmp, 0, parts, 0, tmp.length);
			System.arraycopy(ipv6Parts,  0, parts, tmp.length, ipv6Parts.length);
		}
		return parts;
	}
	@Override
	public int getSegmentCount() {
		return SEGMENT_COUNT;
	}
	@Override
	public int getByteCount() {
		return BYTE_COUNT;
	}
	@Override
	public int getBitCount() {
		return BIT_COUNT;
	}
	@Override
	public boolean isIPv4() {
		return true;
	}
	@Override
	public IPv4Address toIPv4() {
		return this;
	}
	@Override
	public boolean isIPv4Convertible() {
		return true;
	}
	public IPv6Address getIPv6Address(IPv6AddressSegment segs[]) {
		IPv6AddressCreator creator = getIPv6Network().getAddressCreator();
		return creator.createAddress(IPv6AddressSection.createSection(creator, segs, this)); 
	}
	public IPv6Address getIPv4MappedAddress() {
		IPv6AddressCreator creator = getIPv6Network().getAddressCreator();
		IPv6AddressSegment zero = creator.createSegment(0);
		IPv6AddressSegment segs[] = creator.createSegmentArray(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT);
		segs[0] = segs[1] = segs[2] = segs[3] = segs[4] = zero;
		segs[5] = creator.createSegment(IPv6Address.MAX_VALUE_PER_SEGMENT);
		return getIPv6Address(segs);
	}
	@Override
	public boolean isIPv6Convertible() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.isIPv6Convertible(this);
	}
	@Override
	public IPv6Address toIPv6() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.toIPv6(this);
	}
	public IPv4Address toBroadcastAddress() {
		return toMaxHost();
	}
	public IPv4Address toNetworkAddress() {
		return toZeroHost();
	}
	void cache(IPv4Address lower, IPv4Address upper) {
		getSection().cache(this, lower, upper);
	}
	@Override
	public IPv4Address getLowerNonZeroHost() {
		return getSection().getLowestOrHighest(this, true, true);
	}
	@Override
	public IPv4Address getLower() {
		return getSection().getLowestOrHighest(this, true, false);
	}
	@Override
	public IPv4Address getUpper() {
		return getSection().getLowestOrHighest(this, false, false);
	}
	public int intValue() {
		return getSection().intValue();
	}
	public int upperIntValue() {
		return getSection().upperIntValue();
	}
	public long longValue() {
		return getSection().longValue();
	}
	public long upperLongValue() {
		return getSection().upperLongValue();
	}
	IPv4TrieKeyData getTrieKeyCache() {
		IPv4TrieKeyData keyData = cachedTrieKeyData;
		if(keyData == null) {
			keyData = new IPv4TrieKeyData();
			Integer prefLen = getPrefixLength();
			keyData.prefixLength = prefLen;
			keyData.uint32Val = intValue();
			if(prefLen != null) {
				int bits = prefLen;
				keyData.nextBitMask32Val = 0x80000000 >>> bits;
				keyData.mask32Val = getNetwork().getNetworkMask(bits, false).intValue();
			}
			cachedTrieKeyData = keyData;
		}
		return keyData;
	}
	public IPv4Address replace(int startIndex, int endIndex, IPv4Address replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	public IPv4Address replace(int startIndex, IPv4AddressSection replacement) {
		int replacementCount = Math.min(IPv4Address.SEGMENT_COUNT - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	@Override
	public IPv4Address reverseBits(boolean perByte) {
		return checkIdentity(getSection().reverseBits(perByte));
	}
	@Override
	public IPv4Address reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	@Override
	public IPv4Address reverseBytesPerSegment() {
		return this;
	}
	@Override
	public IPv4Address reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	private IPv4Address checkIdentity(IPv4AddressSection newSection) {
		IPv4AddressSection section = getSection();
		if(newSection == section) {
			return this;
		}
		return getAddressCreator().createAddress(newSection);
	}
	@Override
	public IPv4Address adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	@Override
	public IPv4Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public IPv4Address adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	@Override
	public IPv4Address adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength) {
		return setPrefixLength(prefixLength, true);
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength, boolean zeroed) {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed, zeroHostIsBlock));
	}
	@Deprecated
	@Override
	public IPv4Address applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().applyPrefixLength(networkPrefixLength));
	}
	@Override @Deprecated
	public IPv4Address removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	@Override
	public IPv4Address withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override
	@Deprecated
	public IPv4Address removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsNonZeroHostIterator() {
		return getSection().segmentsNonZeroHostIterator();
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	@Override
	public AddressComponentRangeSpliterator<IPv4Address, IPv4AddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getAddressCreator());
	}
	@Override
	public Stream<IPv4AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> iterator() {
		return getSection().iterator(this, getAddressCreator(), null);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> spliterator() {
		return getSection().spliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<IPv4Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> nonZeroHostIterator() {
		Predicate<IPv4AddressSegment[]> excludeFunc = null;
		if(includesZeroHost()) {
			int prefLength = getNetworkPrefixLength();
			excludeFunc = s -> getSection().isZeroHost(s, prefLength);
		}
		return getSection().iterator(this, getAddressCreator(), excludeFunc);
	}
	@Override
	public Iterator<IPv4Address> prefixBlockIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), true);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), true);
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixBlockIterator(int prefixLength) {
		return getSection().prefixIterator(this, getAddressCreator(), true, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixBlockSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getAddressCreator(), true, prefixLength);
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream(int prefixLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv4Address> prefixIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), false);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<IPv4Address> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixIterator(int prefixLength) {
		return getSection().prefixIterator(this, getAddressCreator(), false, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getAddressCreator(), false, prefixLength);
	}
	@Override
	public Stream<IPv4Address> prefixStream(int prefixLength) {
		return StreamSupport.stream(prefixSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv4Address> blockIterator(int segmentCount) {
		return getSection().blockIterator(this, getAddressCreator(), segmentCount);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> blockSpliterator(int segmentCount) {
		return getSection().blockSpliterator(this, getAddressCreator(), segmentCount);
	}
	@Override
	public Stream<IPv4Address> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4Address> sequentialBlockIterator() {
		return (Iterator<IPv4Address>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv4Address> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv4Address>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv4Address> sequentialBlockStream() {
		return (Stream<IPv4Address>) super.sequentialBlockStream();
	}
	@Override
	public Iterable<IPv4Address> getIterable() {
		return this;
	}
	@Override
	public IPv4Address increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv4Address incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	public Long enumerateIPv4(IPv4Address other){
		return IPv4AddressSection.enumerateIPv4(getSection(), other.getSection());
	}
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof IPv4Address) {
			return IPv4AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	public BigInteger enumerate(IPAddress other) {
		if(other.isIPv4()) {
			return IPv4AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	IPv4AddressCreator getAddressCreator() {
		return getNetwork().getAddressCreator();
	}
	@Override
	public IPv4AddressNetwork getNetwork() {
		return defaultIpv4Network();
	}
	public IPv6AddressNetwork getIPv6Network() {
		return defaultIpv6Network();
	}
	@Override
	protected IPv4Address convertArg(IPAddress arg) throws AddressConversionException {
		IPv4Address converted = arg.toIPv4();
		if(converted == null) {
			throw new AddressConversionException(this, arg);
		}
		return converted;
	}
	@Override
	public IPv4Address intersect(IPAddress other) throws AddressConversionException {
		IPv4AddressSection thisSection = getSection();
		IPv4AddressSection section = thisSection.intersect(convertArg(other).getSection());
		if(section == null) {
			return null;
		}
		IPv4AddressCreator creator = getAddressCreator();
		IPv4Address result = creator.createAddress(section); 
		return result;
	}
	@Override
	public IPv4Address[] subtract(IPAddress other)  throws AddressConversionException {
		IPv4AddressSection thisSection = getSection();
		IPv4AddressSection sections[] = thisSection.subtract(convertArg(other).getSection());
		if(sections == null) {
			return null;
		}
		IPv4AddressCreator creator = getAddressCreator();
		IPv4Address result[] = new IPv4Address[sections.length];
		for(int i = 0; i < result.length; i++) {
			result[i] = creator.createAddress(sections[i]); 
		}
		return result;
	}
	@Override
	public IPv4Address toZeroHost() {
		return toZeroHost(false);
	}
	@Override
	protected IPv4Address toZeroHost(boolean boundariesOnly) {
		if(!isPrefixed()) {
			IPv4AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv4Address addr = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				addr = addr.getLower();
			}
			return addr;
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();
		}
		return checkIdentity(getSection().createZeroHost(boundariesOnly));
	}
	@Override
	public IPv4Address toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		return checkIdentity(getSection().toZeroHost(prefixLength));
	}
	@Override
	public IPv4Address toZeroNetwork() {
		if(!isPrefixed()) {
			return getNetwork().getHostMask(getBitCount());
		}
		return checkIdentity(getSection().createZeroNetwork());
	}
	@Override
	public IPv4Address toMaxHost() {
		if(!isPrefixed()) {
			IPv4Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix;
			}
			return resultNoPrefix.setPrefixLength(0);
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();
		}
		return checkIdentity(getSection().createMaxHost());
	}
	@Override
	public IPv4Address toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		return checkIdentity(getSection().toMaxHost(prefixLength));
	}
	@Override
	public IPv4Address mask(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().mask(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv4Address mask(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return mask(mask, false);
	}
	@Override
	public IPv4Address maskNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().maskNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv4Address bitwiseOr(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOr(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv4Address bitwiseOr(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return bitwiseOr(mask, false);
	}
	@Override
	public IPv4Address bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOrNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv4Address getHostMask() {
		return (IPv4Address) super.getHostMask();
	}
	@Override
	public IPv4Address getNetworkMask() {
		return (IPv4Address) super.getNetworkMask();
	}
	@Override
	public IPv4AddressSection getNetworkSection() {
		return getSection().getNetworkSection();
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength);
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength, withPrefixLength);
	}
	@Override
	public IPv4AddressSection getHostSection() {
		return getSection().getHostSection();
	}
	@Override
	public IPv4AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getHostSection(networkPrefixLength);
	}
	@Override
	public IPv4Address toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv4Address toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().toPrefixBlock(networkPrefixLength));
	}
	@Override
	public IPv4Address assignPrefixForSingleBlock() {
		return (IPv4Address) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv4Address assignMinPrefixForBlock() {
		return (IPv4Address) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv4Address coverWithPrefixBlock() {
		return (IPv4Address) IPv4AddressSection.coverWithPrefixBlock(this, getLower(), getUpper());
	}
	@Override
	public IPv4Address coverWithPrefixBlock(IPAddress other) throws AddressConversionException {
		return IPv4AddressSection.coverWithPrefixBlock(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	@Override
	public IPv4Address[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv4Address[] {this};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4Address> list = (ArrayList<IPv4Address>) spanWithBlocks(true);
		return list.toArray(new IPv4Address[list.size()]);
	}
	@Override
	public IPv4Address[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningPrefixBlocks(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4Address::assignPrefixForSingleBlock,
				IPv4Address::withoutPrefixLength,
				getAddressCreator()::createAddressArray);
	}
	@Override
	public IPv4Address[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv4Address[] { withoutPrefixLength() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4Address> list = (ArrayList<IPv4Address>) spanWithBlocks(false);
		return list.toArray(new IPv4Address[list.size()]);
	}
	@Override
	public IPv4Address[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningSequentialBlocks(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4Address::withoutPrefixLength,
				getAddressCreator());
	}
	@Override
	public IPv4AddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException {
		return toSequentialRange(other);
	}
	@Override
	public IPv4Address[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSinglePrefixBlock()) {
				return new IPv4Address[] {this};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv4Address[blocks.size()]);
	}
	private IPAddress[] getConverted(IPAddress... addresses) {
		IPAddress converted[] = new IPAddress[addresses.length + 1];
		for(int i = 0, j = 1; i < addresses.length; i = j++) {
			converted[j] = convertArg(addresses[i]);
		}
		converted[0] = this;
		return converted;
	}
	@Override
	public IPv4Address[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSequential()) {
				return new IPv4Address[] {this};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getAddressCreator());
		return blocks.toArray(new IPv4Address[blocks.size()]);
	}
	@Override
	protected SeriesCreator getSequentialSeriesCreator() {
		return getAddressCreator()::createSequentialBlockAddress;
	}
	@Override
	public Inet4Address toUpperInetAddress() {
		return (Inet4Address) super.toUpperInetAddress();
	}
	@Override
	public Inet4Address toInetAddress() {
		return (Inet4Address) super.toInetAddress();
	}
	@Override
	@Deprecated
	public IPv4AddressSeqRange toSequentialRange(IPAddress other) {
		return new IPv4AddressSeqRange(this, convertArg(other));
	}
	@Override
	public IPv4AddressSeqRange toSequentialRange() {
		IPv4Address thiz = withoutPrefixLength();
		return new IPv4AddressSeqRange(thiz.getLower(), thiz.getUpper(), true);
	}
	@Override
	public boolean isLocal() {
		if(isMulticast()) {
			IPv4AddressSegment seg0 = getSegment(0);
			if(seg0.matches(239)) {
				return true;
			}
			IPv4AddressSegment seg1 = getSegment(1), seg2 = getSegment(2);
			return 
					(seg0.matches(224) && seg1.isZero() && seg2.isZero())
					|| (seg0.matches(232) && !(seg1.isZero() && seg2.isZero()));
		}
		return isLinkLocal() || isPrivate() || isAnyLocal();
	}
	@Override
	public boolean isLinkLocal() {
		if(isMulticast()) {
			return getSegment(0).matches(224) && getSegment(1).isZero() && getSegment(2).isZero() &&  getSegment(3).matches(252);
		}
		return getSegment(0).matches(169) && getSegment(1).matches(254);
	}
	public boolean isPrivate() {
		IPv4AddressSegment seg0 = getSegment(0);
		IPv4AddressSegment seg1 = getSegment(1);
		return seg0.matches(10)
			|| (seg0.matches(172) && seg1.matchesWithPrefixMask(16, 4))
			|| (seg0.matches(192) && seg1.matches(168));
	}
	@Override
	public boolean isMulticast() {
		return getSegment(0).matchesWithPrefixMask(0xe0, 4);
	}
	@Override
	public boolean isLoopback() {
		return getSegment(0).matches(127);
	}
	public interface IPv4AddressConverter {
		IPv4Address toIPv4(IPAddress address);
	}
	@Override
	protected IPAddressStringParameters createFromStringParams() {
		return new IPAddressStringParameters.Builder().
				getIPv4AddressParametersBuilder().setNetwork(getNetwork()).getParentBuilder().
				getIPv6AddressParametersBuilder().setNetwork(getIPv6Network()).getParentBuilder().toParams();
	}
	public static String toNormalizedString(IPv4AddressNetwork network, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
		return toNormalizedString(network.getPrefixConfiguration(), lowerValueProvider, upperValueProvider, prefixLength, SEGMENT_COUNT, BYTES_PER_SEGMENT, BITS_PER_SEGMENT, MAX_VALUE_PER_SEGMENT, SEGMENT_SEPARATOR, DEFAULT_TEXTUAL_RADIX, null);
	}
	public static enum inet_aton_radix {
		OCTAL, HEX, DECIMAL;
		int getRadix() {
			if(this == OCTAL) {
				return 8;
			} else if(this == HEX) {
				return 16;
			}
			return 10;
		}
		String getSegmentStrPrefix() {
			if(this == OCTAL) {
				return "0";
			} else if(this == HEX) {
				return "0x";
			}
			return null;
		}
		@Override
		public String toString() {
			if(this == OCTAL) {
				return "octal";
			} else if(this == HEX) {
				return "hexadecimal";
			}
			return "decimal";
		}
	}
	public String toInetAtonString(IPv4Address.inet_aton_radix radix) {
		return getSection().toInetAtonString(radix);
	}
	public String toInetAtonString(IPv4Address.inet_aton_radix radix, int joinedCount) throws IncompatibleAddressException {
		return getSection().toInetAtonString(radix, joinedCount);
	}
	@Override
	public String toSegmentedBinaryString() {
		return getSection().toSegmentedBinaryString();
	}
	@Override
	public String toUNCHostName() {
		return super.toCanonicalString();
	}
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.ALL_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv4StringBuilderOptions.from(opts));
	}
	private IPv6Address getConverted(IPv4StringBuilderOptions opts) {
		if(opts.includes(IPv4StringBuilderOptions.IPV6_CONVERSIONS)) {
			IPv6AddressConverter converter = opts.converter;
			return converter.toIPv6(this);
		}
		return null;
	}
	public IPAddressPartStringCollection toStringCollection(IPv4StringBuilderOptions opts) {
		IPv4StringCollection coll = new IPv4StringCollection();
		IPAddressPartStringCollection sectionColl = getSection().toStringCollection(opts);
		coll.addAll(sectionColl);
		IPv6Address ipv6Addr = getConverted(opts);
		if(ipv6Addr != null) {
			IPAddressPartStringCollection ipv6StringCollection = ipv6Addr.toStringCollection(opts.ipv6ConverterOptions);
			coll.addAll(ipv6StringCollection);
		}
		return coll;
	}
}
package inet.ipaddr;
import java.math.BigInteger;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Stream;
import inet.ipaddr.AddressComparator.CountComparator;
import inet.ipaddr.AddressComparator.ValueComparator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
public abstract class Address implements AddressSegmentSeries {
	private static final long serialVersionUID = 4L;
	public static interface AddressValueProvider {
		int getSegmentCount();
		SegmentValueProvider getValues();
		default SegmentValueProvider getUpperValues() {
			return getValues();
		}
	}
	@FunctionalInterface
	public static interface SegmentValueProvider {
		int getValue(int segmentIndex);
	}
	public static final String HEX_PREFIX = "0x";
	public static final String OCTAL_PREFIX = "0";
	public static final char RANGE_SEPARATOR = '-';
	public static final String RANGE_SEPARATOR_STR = String.valueOf(RANGE_SEPARATOR);
	public static final char ALTERNATIVE_RANGE_SEPARATOR = '\u00bb'; 
	public static final String ALTERNATIVE_RANGE_SEPARATOR_STR = String.valueOf(ALTERNATIVE_RANGE_SEPARATOR);
	public static final char SEGMENT_WILDCARD = '*';
	public static final String SEGMENT_WILDCARD_STR = String.valueOf(SEGMENT_WILDCARD);
	public static final String ALTERNATIVE_SEGMENT_WILDCARD_STR = "¿";
	public static final char SEGMENT_SQL_WILDCARD = '%';
	public static final String SEGMENT_SQL_WILDCARD_STR = String.valueOf(SEGMENT_SQL_WILDCARD);
	public static final char SEGMENT_SQL_SINGLE_WILDCARD = '_';
	public static final String SEGMENT_SQL_SINGLE_WILDCARD_STR = String.valueOf(SEGMENT_SQL_SINGLE_WILDCARD);
	public static final AddressComparator DEFAULT_ADDRESS_COMPARATOR = new CountComparator(true);
	public static final AddressComparator ADDRESS_LOW_VALUE_COMPARATOR = new ValueComparator(true, false);
	public static final AddressComparator ADDRESS_HIGH_VALUE_COMPARATOR = new ValueComparator(true, true);
	private static MACAddressNetwork macNetwork;
	private static IPv6AddressNetwork ipv6Network;
	private static IPv4AddressNetwork ipv4Network;
	final AddressSection addressSection;
	protected HostIdentifierString fromString;
	protected Address(AddressSection section) {
		addressSection = section;
		if(!getNetwork().isCompatible(addressSection.getNetwork())) {
			throw new NetworkMismatchException(addressSection);
		}
	}
	protected Address(Function<Address, AddressSection> supplier) {
		addressSection = supplier.apply(this);
		if(!getNetwork().isCompatible(addressSection.getNetwork())) {
			throw new NetworkMismatchException(addressSection);
		}
	}
	public static IPv6AddressNetwork defaultIpv6Network() {
		if(ipv6Network == null) {
			synchronized(Address.class) {
				if(ipv6Network == null) {
					ipv6Network = new IPv6AddressNetwork();
				}
			}
		}
		return ipv6Network;
	}
	public static IPv4AddressNetwork defaultIpv4Network() {
		if(ipv4Network == null) {
			synchronized(Address.class) {
				if(ipv4Network == null) {
					ipv4Network = new IPv4AddressNetwork();
				}
			}
		}
		return ipv4Network;
	}
	public static MACAddressNetwork defaultMACNetwork() {
		if(macNetwork == null) {
			synchronized(Address.class) {
				if(macNetwork == null) {
					macNetwork = new MACAddressNetwork();
				}
			}
		}
		return macNetwork;
	}
	protected static String getMessage(String key) {
		return HostIdentifierException.getMessage(key);
	}
	@Override
	public int getSegmentCount() {
		return getSection().getSegmentCount();
	}
	@Override
	public int getDivisionCount() {
		return getSection().getDivisionCount();
	}
	@Override
	public int getBitCount() {
		return getSection().getBitCount();
	}
	@Override
	public int getByteCount() {
		return getSection().getByteCount();
	}
	@Override
	public AddressSection getSection() {
		return addressSection;
	}
	@Override
	public void getSegments(AddressSegment segs[]) {
		getSection().getSegments(segs);
	}
	@Override
	public void getSegments(int start, int end, AddressSegment segs[], int index) {
		getSection().getSegments(start, end, segs, index);
	}
	@Override
	public abstract Iterable<? extends Address> getIterable();
	@Override
	public abstract Iterator<? extends Address> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends Address> spliterator();
	@Override
	public abstract Stream<? extends Address> stream();
	@Override
	public abstract Iterator<? extends Address> prefixIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends Address> prefixSpliterator();
	@Override
	public abstract Stream<? extends Address> prefixStream();
	@Override
	public abstract Iterator<? extends Address> prefixBlockIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends Address> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends Address> prefixBlockStream();
	@Override
	public abstract Address increment(long increment) throws AddressValueException;
	@Override
	public abstract Address incrementBoundary(long increment) throws AddressValueException;
	@Override
	public abstract Address getLower();
	@Override
	public abstract Address getUpper();
	@Override
	public boolean isMultiple() {
		return getSection().isMultiple();
	}
	@Override
	public boolean isPrefixed() {
		return getSection().isPrefixed();
	}
	public boolean isIPAddress() {
		return false;
	}
	public boolean isMACAddress() {
		return false;
	}
	public IPAddress toIPAddress() {
		return null;
	}
	public MACAddress toMACAddress() {
		return null;
	}
	@Override
	public Integer getPrefixLength() {
		return getSection().getPrefixLength();
	}
	@Override
	public int getMinPrefixLengthForBlock() {
		return getSection().getMinPrefixLengthForBlock();
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		return getSection().getPrefixLengthForSingleBlock();
	}
	public abstract boolean isMulticast();
	@Override
	public BigInteger getCount() {
		return getSection().getCount();
	}
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		return getSection().getPrefixCount(prefixLength);
	}
	@Override
	public BigInteger getPrefixCount() {
		return getSection().getPrefixCount();
	}
	@Override
	public BigInteger getBlockCount(int segmentCount) {
		return getSection().getBlockCount(segmentCount);
	}
	@Override
	public byte[] getBytes() {
		return getSection().getBytes();
	}
	@Override
	public byte[] getBytes(byte bytes[]) {
		return getSection().getBytes(bytes);
	}
	@Override
	public byte[] getBytes(byte bytes[], int index) {
		return getSection().getBytes(bytes, index);
	}
	@Override
	public byte[] getUpperBytes() {
		return getSection().getUpperBytes();
	}
	@Override
	public byte[] getUpperBytes(byte bytes[]) {
		return getSection().getUpperBytes(bytes);
	}
	@Override
	public byte[] getUpperBytes(byte bytes[], int index) {
		return getSection().getUpperBytes(bytes, index);
	}
	@Override
	public BigInteger getValue() {
		return getSection().getValue();
	}
	@Override
	public BigInteger getUpperValue() {
		return getSection().getUpperValue();
	}
	@Override
	public boolean isZero() {
		return getSection().isZero();
	}
	@Override
	public boolean includesZero() {
		return getSection().includesZero();
	}
	@Override
	public boolean isMax() {
		return getSection().isMax();
	}
	@Override
	public boolean includesMax() {
		return getSection().includesMax();
	}
	@Override
	public boolean isFullRange() {
		return getSection().isFullRange();
	}
	public abstract boolean isLocal();
	@Override
	public int hashCode() {
		return getSection().hashCode();
	}
	protected abstract boolean isFromSameString(HostIdentifierString otherString);
	public boolean isSameAddress(Address other) {
		return other == this || getSection().equals(other.getSection());
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof Address) {
			Address other = (Address) o;
			if(isFromSameString(other.fromString)) {
				return true;
			}
			return isSameAddress(other);
		}
		return false;
	}
	public boolean prefixEquals(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().prefixEquals(other.getSection());
	}
	public boolean overlaps(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().overlaps(other.getSection());
	}
	public boolean contains(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().contains(other.getSection());
	}
	public abstract BigInteger enumerate(Address other);
	@Override
	public boolean isSequential() {
		return getSection().isSequential();
	}
	public HostIdentifierString toAddressString() {
		return fromString;
	}
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {
		return getSection().toHexString(with0xPrefix);
	}
	@Override
	public String toNormalizedString() {
		return getSection().toNormalizedString();
	}
	@Override
	public String toCanonicalString() {
		return getSection().toCanonicalString();
	}
	@Override
	public String toCompressedString() {
		return getSection().toCompressedString();
	}
	@Override
	public String toString() {
		return toCanonicalString();
	}
	@Override
	public String[] getDivisionStrings() {
		return getSection().getDivisionStrings();
	}
	@Override
	public String[] getSegmentStrings() {
		return getSection().getSegmentStrings();
	}
	@Override
	public abstract Address reverseSegments();
	@Override
	public abstract Address reverseBits(boolean perByte);
	@Override
	public abstract Address reverseBytes();
	@Override
	public abstract Address reverseBytesPerSegment();
	@Override
	public boolean isPrefixBlock() {
		return getSection().isPrefixBlock();
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		return getSection().containsPrefixBlock(prefixLength);
	}
	@Override
	public boolean isSinglePrefixBlock() {
		return getSection().isSinglePrefixBlock();
	}
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		return getSection().containsSinglePrefixBlock(prefixLength);
	}
	@Override
	public abstract Address toPrefixBlock();
	@Override @Deprecated
	public abstract Address removePrefixLength();
	@Override
	public abstract Address withoutPrefixLength();
	@Override @Deprecated
	public abstract Address removePrefixLength(boolean zeroed);
	@Override
	public abstract Address adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	@Override
	public abstract Address adjustPrefixLength(int adjustment);
	@Override
	public abstract Address adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	public abstract Address setPrefixLength(int prefixLength);
	@Override
	public abstract Address setPrefixLength(int prefixLength, boolean zeroed);
	@Deprecated
	@Override
	public abstract Address applyPrefixLength(int networkPrefixLength);
	public static boolean matchUnordered(Address addrs1[], Address addrs2[]) {
		int len1 = addrs1 == null ? 0 : addrs1.length;
		int len2 = addrs2 == null ? 0 : addrs2.length;
		boolean sameLen = len1 == len2;
		boolean result;
		if(len1 == 0 || len2 == 0) {
			result = sameLen;
		} else if(len1 == 1 && sameLen) {
			result = addrs1[0].equals(addrs2[0]);
		} else if(len1 == 2 && sameLen) {
			if(addrs1[0].equals(addrs2[0])) {
				result = addrs1[1].equals(addrs2[1]);
			} else if(result = addrs1[0].equals(addrs2[1])) {
				result = addrs1[1].equals(addrs2[0]);
			}
		} else {
			result = Objects.equals(asSet(addrs1), asSet(addrs2));
		}
		return result;
	}
	private static HashSet<Address> asSet(Address addrs[])  {
		int addrLen = addrs.length;
		if(addrLen > 0) {
			HashSet<Address> result = new HashSet<>();
			for(int i = 0; i < addrs.length; i++) {
				Address addr = addrs[i];
				result.add(addr);
			}
			return result;
		}
		return null;
	}
	public static boolean matchOrdered(Address addrs1[], Address addrs2[]) {
		int len1 = addrs1 == null ? 0 : addrs1.length;
		int len2 = addrs2 == null ? 0 : addrs2.length;
		if(len1 != len2) {
			return false;
		}
		for(int i = 0; i < len1; i++) {
			if(!addrs1[i].equals(addrs2[i])) {
				return false;
			}
		}
		return true;
	}
}
package inet.ipaddr;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.format.AddressItem;
public class PrefixLenException extends AddressValueException {
	private static final long serialVersionUID = 1L;
	static String getMessage(String key) {
		return AddressStringException.getMessage(key);
	}
	public PrefixLenException(int prefixLength) {
		super(errorMessage + " " + getMessage("ipaddress.error.prefixSize"));
	}
	public PrefixLenException(AddressItem one, int prefixLength) {
		super(one + ", " + errorMessage + " " + getMessage("ipaddress.error.prefixSize"));
	}
	public PrefixLenException(int prefixLength, IPVersion version) {
		super(version + " /" + prefixLength + ", " + errorMessage + " " + getMessage("ipaddress.error.prefixSize"));
	}
	public PrefixLenException(CharSequence prefixLength, IPVersion version, Throwable cause) {
		super(version + " /" + prefixLength + ", " + errorMessage + " " + getMessage("ipaddress.error.invalidCIDRPrefix"), cause);
	}
}
package inet.ipaddr;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InterfaceAddress;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.Function;
import inet.ipaddr.Address.AddressValueProvider;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.IPAddress.IPAddressValueProvider;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping.RangeList;
import inet.ipaddr.format.validate.HostIdentifierStringValidator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
public abstract class IPAddressNetwork<
		T extends IPAddress, 
		R extends IPAddressSection,
		E extends IPAddressSection,
		S extends IPAddressSegment,
		J extends InetAddress> 
	extends AddressNetwork<S> {
	private static final long serialVersionUID = 4L;
	private final T subnetsMasksWithPrefix[];
	private final T subnetMasks[];
	private final T networkAddresses[];
	private final T hostMasks[];
	private final int networkSegmentMasks[];
	private final int hostSegmentMasks[];
	private transient T loopback;
	private transient String loopbackStrings[];
	public static abstract class IPAddressCreator<T extends IPAddress, R extends IPAddressSection, E extends IPAddressSection, S extends IPAddressSegment, J extends InetAddress> extends AddressCreator<T, R, E, S> {
		private static final long serialVersionUID = 4L;
		private IPAddressNetwork<T, R, E, S, J> owner;
		protected IPAddressCreator(IPAddressNetwork<T, R, E, S, J> owner) {
			this.owner = owner;
		}
		@Override
		public IPAddressNetwork<T, R, E, S, J> getNetwork() {
			return owner;
		}
		@Override
		protected S createSegmentInternal(int value, Integer segmentPrefixLength, CharSequence addressStr, int originalVal, boolean isStandardString, int lowerStringStartIndex, int lowerStringEndIndex) {
			S segment = createSegment(value, segmentPrefixLength);
			segment.setStandardString(addressStr, isStandardString, lowerStringStartIndex, lowerStringEndIndex, originalVal);
			segment.setWildcardString(addressStr, isStandardString, lowerStringStartIndex, lowerStringEndIndex, originalVal);
			return segment;
		}
		@Override
		protected S createRangeSegmentInternal(int lower, int upper, Integer segmentPrefixLength, CharSequence addressStr, int originalLower, int originalUpper, boolean isStandardString, boolean isStandardRangeString, int lowerStringStartIndex, int lowerStringEndIndex, int upperStringEndIndex) {
			S segment = createSegment(lower, upper, segmentPrefixLength);
			segment.setStandardString(addressStr, isStandardString,  isStandardRangeString, lowerStringStartIndex, lowerStringEndIndex, upperStringEndIndex, originalLower, originalUpper);
			segment.setWildcardString(addressStr, isStandardRangeString, lowerStringStartIndex, upperStringEndIndex, originalLower, originalUpper);
			return segment;
		}
		protected abstract R[] createSectionArray(int length);
		@Override
		protected abstract R createSectionInternal(S segments[]);
		protected abstract R createEmbeddedSectionInternal(IPAddressSection encompassingSection, S segments[]);
		@Override
		protected R createPrefixedSectionInternal(S segments[], Integer prefix) {
			return createPrefixedSectionInternal(segments, prefix, false);
		}
		@Override
		protected abstract R createPrefixedSectionInternal(S segments[], Integer prefix, boolean singleOnly);
		public abstract R createFullSectionInternal(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix);
		public abstract R createSection(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix);
		public abstract R createSection(byte bytes[], Integer prefix);
		public abstract R createSection(S segments[], Integer networkPrefixLength);
		public abstract R createSection(S segments[]);
		protected abstract T[] createAddressArray(int length);
		public T createAddress(S segments[]) {
			return createAddress(createSection(segments));
		}
		public T createAddress(S segments[], Integer prefix) {
			return createAddress(createSection(segments, prefix));
		}
		@Override
		protected T createAddressInternal(S segments[]) {
			return createAddress(createSectionInternal(segments));
		}
		@Override
		protected T createAddressInternal(S segments[], Integer prefix, boolean singleOnly) {
			return createAddress(createPrefixedSectionInternal(segments, prefix, singleOnly));
		}
		@Override
		protected T createAddressInternal(S segments[], Integer prefix) {
			return createAddress(createPrefixedSectionInternal(segments, prefix));
		}
		protected T createAddressInternal(S segments[], CharSequence zone) {
			return createAddressInternal(createSectionInternal(segments), zone);
		}
		public T createAddress(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix) {
			return createAddress(createFullSectionInternal(lowerValueProvider, upperValueProvider, prefix));
		}
		public T createAddress(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix, CharSequence zone) {
			return createAddressInternal(createFullSectionInternal(lowerValueProvider, upperValueProvider, prefix), zone);
		}
		protected R createSectionInternal(byte bytes[], int segmentCount, Integer prefix) {
			return createSectionInternal(bytes, segmentCount, prefix, false);
		}
		protected abstract R createSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer prefix);
		public T createAddress(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix) {
			return createAddress(createSection(bytes, byteStartIndex, byteEndIndex, getAddressSegmentCount(), prefix));
		}
		public T createAddress(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix, CharSequence zone) {
			return createAddressInternal(createSection(bytes, byteStartIndex, byteEndIndex, getAddressSegmentCount(), prefix), zone);
		}
		protected T createAddressInternal(byte bytes[], Integer prefix) {
			return createAddress(createSectionInternal(bytes, getAddressSegmentCount(), prefix));
		}
		protected T createAddressInternal(byte bytes[], Integer prefix, CharSequence zone) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), prefix), zone);
		}
		@Override
		protected T createAddressInternal(byte bytes[], CharSequence zone) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), null), zone);
		}
		protected T createAddressInternal(byte bytes[], Integer prefix, CharSequence zone, HostName fromHost) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), prefix), zone, fromHost);
		}
		protected T createAddressInternal(byte bytes[], Integer prefix, HostName fromHost) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), prefix), fromHost);
		}
		public T createAddress(byte bytes[], Integer prefix) {
			return createAddress(createSection(bytes, prefix));
		}
		public T createAddress(byte bytes[]) {
			return createAddress(createSection(bytes, null));
		}
		@Override
		protected T createAddressInternal(R section, CharSequence zone, HostIdentifierString from) {
			T result = createAddressInternal(section, zone);
			result.cache(from);
			return result;
		}
		@Override
		protected T createAddressInternal(R section, HostIdentifierString from) {
			T result = createAddress(section);
			result.cache(from);
			return result;
		}
		protected abstract T createAddress(J inetAddress);
		protected abstract T createAddress(J inetAddress, Integer networkPrefixLength);
		protected abstract T createAddressInternal(R section, CharSequence zone);
		@Override
		public abstract T createAddress(R section);
		protected abstract int getAddressSegmentCount();
		public T createSequentialBlockAddress(IPAddressSegmentSeries address, int index, int lowerVal, int upperVal) {
			S[] segments = createSequentialBlockSegments(address, index, lowerVal, upperVal);
			return createAddressInternal(segments);
		}
		public R createSequentialBlockSection(IPAddressSegmentSeries series, int index, int lowerVal, int upperVal) {
			S[] segments = createSequentialBlockSegments(series, index, lowerVal, upperVal);
			return createSectionInternal(segments);
		}
		private S[] createSequentialBlockSegments(IPAddressSegmentSeries series, int index, int lowerVal, int upperVal) {
			S segments[] = createSegmentArray(series.getSegmentCount());
			series.getSegments(0, index, segments, 0);
			segments[index] = createSegment(lowerVal, upperVal, null);
			if(++index < segments.length) {
				S allRangeSegment = createSegment(0, getMaxValuePerSegment(), null);
				do {
					segments[index] = allRangeSegment;
				} while(++index < segments.length);
			}
			return segments;
		}
	}
	private IPAddressCreator<T, R, E, S, J> creator;
	@SuppressWarnings("unchecked")
	protected IPAddressNetwork(Class<T> addressType) {
		IPVersion version = getIPVersion();
		int bitSize = IPAddress.getBitCount(version);
		this.subnetsMasksWithPrefix = (T[]) Array.newInstance(addressType, bitSize + 1);
		this.subnetMasks = this.subnetsMasksWithPrefix.clone();
		this.networkAddresses = this.subnetsMasksWithPrefix.clone();
		this.hostMasks = this.subnetsMasksWithPrefix.clone();
		this.creator = createAddressCreator();
		int segmentBitSize = IPAddressSegment.getBitCount(version);
		int fullMask = ~(~0 << segmentBitSize); 
		networkSegmentMasks = new int[segmentBitSize + 1];
		hostSegmentMasks = networkSegmentMasks.clone();
		for(int i = 0; i <= segmentBitSize; i++) {
			int networkMask = this.networkSegmentMasks[i] = fullMask & (fullMask << (segmentBitSize - i));
			this.hostSegmentMasks[i] = ~networkMask & fullMask;
		}
	}
	@Override
	public void clearCaches() {
		Arrays.fill(subnetsMasksWithPrefix, null);
		Arrays.fill(subnetMasks, null);
		Arrays.fill(networkAddresses, null);
		Arrays.fill(hostMasks, null);
		loopback = null;
		loopbackStrings = null;
		super.clearCaches();
	}
	public boolean isIPv4() {
		return false;
	}
	public boolean isIPv6() {
		return false;
	}
	public abstract IPVersion getIPVersion();
	protected abstract BiFunction<T, Integer, S> getSegmentProducer();
	protected abstract Function<T, R> getSectionProducer();
	protected abstract IPAddressCreator<T, R, E, S, J> createAddressCreator();
	@Override
	public IPAddressCreator<T, R, E, S, J> getAddressCreator() {
		return creator;
	}
	public T getLoopback() {
		if(loopback == null) {
			synchronized(this) {
				if(loopback == null) {
					loopback = createLoopback();
				}
			}
		}
		return loopback;
	}
	protected abstract T createLoopback();
	public String[] getStandardLoopbackStrings() {
		if(loopbackStrings == null) {
			synchronized(this) {
				if(loopbackStrings == null) {
					loopbackStrings = getLoopback().toStandardStrings();
				}
			}
		}
		return loopbackStrings;
	}
	public int getSegmentNetworkMask(int segmentPrefixLength) {
		return (int) networkSegmentMasks[segmentPrefixLength];
	}
	public int getSegmentHostMask(int segmentPrefixLength) {
		return (int) hostSegmentMasks[segmentPrefixLength];
	}
	public T getNetworkMask(int networkPrefixLength) {
		return getNetworkMask(networkPrefixLength, true);
	}
	public T getNetworkAddress(int networkPrefixLength) {
		return getMask(networkPrefixLength, networkAddresses, true, true, true);
	}
	public T getNetworkMask(int networkPrefixLength, boolean withPrefixLength) {
		return getMask(networkPrefixLength, withPrefixLength ? subnetsMasksWithPrefix : subnetMasks, true, withPrefixLength, false);
	}
	public R getNetworkMaskSection(int networkPrefixLength) {
		return getSectionProducer().apply(getNetworkMask(networkPrefixLength, true));
	}
	public T getHostMask(int networkPrefixLength) {
		return getMask(networkPrefixLength, hostMasks, false, false, false);
	}
	public R getHostMaskSection(int networkPrefixLength) {
		return getSectionProducer().apply(getHostMask(networkPrefixLength));
	}
	@SuppressWarnings("unchecked")
	private T getMask(int networkPrefixLength, T cache[], boolean network, boolean withPrefixLength, boolean networkAddress) {
		int bits = networkPrefixLength;
		IPVersion version = getIPVersion();
		int addressBitLength = IPAddress.getBitCount(version);
		if(bits < 0 || bits > addressBitLength) {
			throw new PrefixLenException(bits, version);
		}
		int cacheIndex = bits;
		T subnet = cache[cacheIndex];
		if(subnet == null) {
			int onesSubnetIndex, zerosSubnetIndex;
			if(network) {
				onesSubnetIndex = addressBitLength;
				zerosSubnetIndex = 0;
			} else {
				onesSubnetIndex = 0;
				zerosSubnetIndex = addressBitLength;
			}
			T onesSubnet = cache[onesSubnetIndex];
			T zerosSubnet = cache[zerosSubnetIndex];
			if(onesSubnet == null || zerosSubnet == null) {
				synchronized(cache) {
					int segmentCount = IPAddress.getSegmentCount(version);
					int bitsPerSegment = IPAddress.getBitsPerSegment(version);
					int bytesPerSegment = IPAddress.getBytesPerSegment(version);
					onesSubnet = cache[onesSubnetIndex];
					if(onesSubnet == null) {
						IPAddressCreator<T, ?, ?, S, ?> creator = getAddressCreator();
						S newSegments[] = creator.createSegmentArray(segmentCount);
						int maxSegmentValue = IPAddress.getMaxSegmentValue(version);
						if(network && withPrefixLength) {
							S segment = creator.createSegment(maxSegmentValue, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, addressBitLength)  );
							Arrays.fill(newSegments, 0, newSegments.length - 1, segment);
							S lastSegment = creator.createSegment(maxSegmentValue, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, bitsPerSegment)  );
							newSegments[newSegments.length - 1] = lastSegment;
							onesSubnet = creator.createAddressInternal(newSegments, cacheBits(addressBitLength)); 
						} else {
							S segment = creator.createSegment(maxSegmentValue);
							Arrays.fill(newSegments, segment);
							onesSubnet = creator.createAddressInternal(newSegments); 
						}
						initMaskCachedValues(onesSubnet.getSection(), network, withPrefixLength, networkAddress, addressBitLength, onesSubnetIndex, segmentCount, bitsPerSegment, bytesPerSegment);
						cache[onesSubnetIndex] = onesSubnet;
					}
					zerosSubnet = cache[zerosSubnetIndex];
					if(zerosSubnet == null) {
						IPAddressCreator<T, ?, ?, S, ?> creator = getAddressCreator();
						S newSegments[] = creator.createSegmentArray(segmentCount);
						S seg;
						if(network && withPrefixLength) {
							seg = creator.createSegment(0, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, 0) );
							Arrays.fill(newSegments, seg);
							zerosSubnet = creator.createAddressInternal(newSegments, cacheBits(0)); 
							if(getPrefixConfiguration().zeroHostsAreSubnets() && !networkAddress) {
								zerosSubnet = (T) zerosSubnet.getLower();
							}
						} else {
							seg = creator.createSegment(0);
							Arrays.fill(newSegments, seg);
							zerosSubnet = creator.createAddressInternal(newSegments); 
						}
						initMaskCachedValues(zerosSubnet.getSection(), network, withPrefixLength, networkAddress, addressBitLength, zerosSubnetIndex, segmentCount, bitsPerSegment, bytesPerSegment);
						cache[zerosSubnetIndex] = zerosSubnet;
					}
				}
			}
			synchronized(cache) {
				subnet = cache[cacheIndex];
				if(subnet == null) {			
					BiFunction<T, Integer, S> segProducer = getSegmentProducer();				
					int segmentCount = IPAddress.getSegmentCount(version);
					int bitsPerSegment = IPAddress.getBitsPerSegment(version);
					int bytesPerSegment = IPAddress.getBytesPerSegment(version);
					int prefix = bits;
					S onesSegment = segProducer.apply(onesSubnet, 0);
					S zerosSegment = segProducer.apply(zerosSubnet, 0);
					IPAddressCreator<T, ?, ?, S, ?> creator = getAddressCreator();
					ArrayList<S> segmentList = new ArrayList<S>(segmentCount);
					int i = 0;
					for(; bits > 0; i++, bits -= bitsPerSegment) {
						if(bits <= bitsPerSegment) {
							S segment = null;
							int offset = ((bits - 1) % bitsPerSegment) + 1;
							for(int j = 0, entry = offset; j < segmentCount; j++, entry += bitsPerSegment) {
								if(entry != cacheIndex) { 
									T prev = cache[entry];
									if(prev != null) {
										segment = segProducer.apply(prev, j);
										break;
									}
								}
							}
							if(segment == null) {
								int mask = getSegmentNetworkMask(bits);
								if(network) {
									if(withPrefixLength) {
										segment = creator.createSegment(mask, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, bits));
									} else {
										segment = creator.createSegment(mask);
									}
								} else {
									segment = creator.createSegment(getSegmentHostMask(bits));
								}
							}
							segmentList.add(segment);
						} else {
							segmentList.add(network ? onesSegment : zerosSegment);
						}
					}
					for(; i<segmentCount; i++) {
						segmentList.add(network ? zerosSegment : onesSegment);
					}
					S newSegments[] = creator.createSegmentArray(segmentList.size());
					segmentList.toArray(newSegments);
					if(network && withPrefixLength) {
						subnet = creator.createAddressInternal(newSegments, cacheBits(prefix)); 
						if(getPrefixConfiguration().zeroHostsAreSubnets() && !networkAddress) {
							subnet = (T) subnet.getLower();
						}
					} else {
						subnet = creator.createAddressInternal(newSegments); 
					}
					initMaskCachedValues(subnet.getSection(), network, withPrefixLength, networkAddress, addressBitLength, prefix, segmentCount, bitsPerSegment, bytesPerSegment);
					cache[cacheIndex] = subnet; 
				} 
			} 
		} 
		return subnet;
	}
	private void initMaskCachedValues(
			IPAddressSection section, 
			boolean network,
			boolean withPrefixLength,
			boolean networkAddress,
			int addressBitLength, 
			int networkPrefixLength,
			int segmentCount, 
			int bitsPerSegment,
			int bytesPerSegment) {
		Integer cachedNetworkPrefix, cachedMinPrefix, cachedEquivalentPrefix;
		BigInteger cachedCount;
		RangeList zeroSegments, zeroRanges;
		boolean hasZeroRanges = network ? addressBitLength - networkPrefixLength >= bitsPerSegment : networkPrefixLength >= bitsPerSegment;
		RangeList noZeros = IPAddressSection.getNoZerosRange();
		if(hasZeroRanges) {
			int rangeIndex, rangeLen;
			if(network) {
				int segmentIndex = IPAddressSection.getNetworkSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment) + 1;
				rangeIndex = segmentIndex;
				rangeLen = segmentCount - segmentIndex;
			} else {
				rangeIndex = 0;
				rangeLen = IPAddressSection.getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
			}
			zeroRanges = IPAddressSection.getSingleRange(rangeIndex, rangeLen);
			zeroSegments = (network && withPrefixLength && !getPrefixConfiguration().prefixedSubnetsAreExplicit()) ? noZeros : zeroRanges;
		} else {
			zeroSegments = zeroRanges = noZeros;
		}
		Integer npl = cacheBits(networkPrefixLength);
		if(network && withPrefixLength) {
			if(getPrefixConfiguration().prefixedSubnetsAreExplicit() || (getPrefixConfiguration().zeroHostsAreSubnets() && !networkAddress)) {
				cachedEquivalentPrefix = cachedMinPrefix = cacheBits(addressBitLength);
				cachedNetworkPrefix = npl;
				cachedCount = BigInteger.ONE;
			} else {
				cachedEquivalentPrefix = cachedMinPrefix = cachedNetworkPrefix = npl;
				cachedCount = BigInteger.valueOf(2).pow(addressBitLength - networkPrefixLength);
			}
		} else {
			cachedEquivalentPrefix = cachedMinPrefix = cacheBits(addressBitLength);
			cachedNetworkPrefix = null;
			cachedCount = BigInteger.ONE;
		}
		section.initCachedValues(npl, network, cachedNetworkPrefix, cachedMinPrefix, cachedEquivalentPrefix, cachedCount, zeroSegments, zeroRanges);
	}
	protected static Integer cacheBits(int i) {
		return IPAddressSection.cacheBits(i);
	}
	public static String getPrefixString(int networkPrefixLength) {
		return new StringBuilder(HostIdentifierStringValidator.MAX_PREFIX_CHARS + 1).append(IPAddress.PREFIX_LEN_SEPARATOR).append(networkPrefixLength).toString();
	}
	public static class IPAddressGenerator implements Serializable {
		private static final long serialVersionUID = 4L;
		protected final IPAddressStringParameters options;
		public IPAddressGenerator() {
			this(null);
		}
		public IPAddressGenerator(IPv4AddressNetwork ipv4Network, IPv6AddressNetwork ipv6Network) {
			this(new IPAddressStringParameters.Builder().
						getIPv4AddressParametersBuilder().setNetwork(ipv4Network).
						getParentBuilder().
						getIPv6AddressParametersBuilder().setNetwork(ipv6Network).
							getEmbeddedIPv4AddressParametersBuilder().setNetwork(ipv4Network).
							getEmbeddedIPv4AddressParentBuilder().
						getParentBuilder().
					toParams());
		}
		public IPAddressGenerator(IPAddressStringParameters options) {
			if(options == null) {
				options = IPAddressString.DEFAULT_VALIDATION_OPTIONS;
			}
			this.options = options;
		}
		protected String toNormalizedString(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			if(version == IPVersion.IPV4) {
				IPv4AddressNetwork network = options.getIPv4Parameters().getNetwork();
				return IPv4Address.toNormalizedString(network, lowerValueProvider, upperValueProvider, prefixLength);
			}
			if(version == IPVersion.IPV6) {
				IPv6AddressNetwork network = options.getIPv6Parameters().getNetwork();
				return IPv6Address.toNormalizedString(network, lowerValueProvider, upperValueProvider, prefixLength, zone);
			}
			throw new IllegalArgumentException();
		}
		public IPAddress from(InetAddress inetAddress) {
			if(inetAddress instanceof Inet4Address) {
				return getIPv4Creator().createAddress((Inet4Address) inetAddress);
			} else if(inetAddress instanceof Inet6Address) {
				return getIPv6Creator().createAddress((Inet6Address) inetAddress);
			}
			return null;
		}
		public IPAddress from(InetAddress inetAddress, Integer prefixLength) {
			if(inetAddress instanceof Inet4Address) {
				return getIPv4Creator().createAddress((Inet4Address) inetAddress, prefixLength);
			} else if(inetAddress instanceof Inet6Address) {
				return getIPv6Creator().createAddress((Inet6Address) inetAddress, prefixLength);
			}
			return null;
		}
		public IPAddress from(InterfaceAddress interfaceAddress) {
			InetAddress inetAddress = interfaceAddress.getAddress();
			if(inetAddress instanceof Inet4Address) {
				return getIPv4Creator().createAddress((Inet4Address) inetAddress, cacheBits(interfaceAddress.getNetworkPrefixLength()));
			} else if(inetAddress instanceof Inet6Address) {
				return getIPv6Creator().createAddress((Inet6Address) inetAddress, cacheBits(interfaceAddress.getNetworkPrefixLength()));
			}
			return null;
		}
		public IPAddress from(byte bytes[]) {
			return from(bytes, 0, bytes.length, null, null);
		}
		public IPAddress from(byte bytes[], int byteStartIndex, int byteEndIndex) {
			return from(bytes, byteStartIndex, byteEndIndex, null, null);
		}
		public IPAddress from(byte bytes[], int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) {
			return from(bytes, byteStartIndex, byteEndIndex, networkPrefixLength, null);
		}
		public IPAddress from(byte bytes[], Integer prefixLength) {
			return from(bytes, 0, bytes.length, prefixLength, null);
		}
		private IPAddress from(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefixLength, CharSequence zone) {
			if(byteEndIndex - byteStartIndex < IPv6Address.BYTE_COUNT) {
				return getIPv4Creator().createAddress(bytes, byteStartIndex, byteEndIndex, prefixLength);
			}
			return getIPv6Creator().createAddress(bytes, byteStartIndex, byteEndIndex, prefixLength, zone);
		}
		public IPAddress from(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return from(version, lowerValueProvider, upperValueProvider, prefixLength, null);
		}
		private IPv4AddressCreator getIPv4Creator() {
			IPv4AddressNetwork network = options.getIPv4Parameters().getNetwork();
			IPv4AddressCreator addressCreator = network.getAddressCreator();
			return addressCreator;
		}
		private IPv6AddressCreator getIPv6Creator() {
			IPv6AddressNetwork network = options.getIPv6Parameters().getNetwork();
			IPv6AddressCreator addressCreator = network.getAddressCreator();
			return addressCreator;
		}
		private IPAddress from(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			if(version == IPVersion.IPV4) {
				return getIPv4Creator().createAddress(lowerValueProvider, upperValueProvider, prefixLength);
			}
			if(version == IPVersion.IPV6) {
				return getIPv6Creator().createAddress(lowerValueProvider, upperValueProvider, prefixLength, zone);
			}
			throw new IllegalArgumentException();
		}
	}
	public static abstract class HostIDStringAddressGenerator<T extends HostIdentifierString> implements Serializable {
		private static final long serialVersionUID = 4L;
		private final IPAddressGenerator addressGenerator;
		protected final Map<String, T> backingMap;
		public HostIDStringAddressGenerator() {
			this(null, null);
		}
		public HostIDStringAddressGenerator(IPAddressStringParameters options) {
			this(null, options);
		}
		public HostIDStringAddressGenerator(Map<String, T> backingMap) {
			this(backingMap, null);
		}
		public HostIDStringAddressGenerator(Map<String, T> backingMap, IPAddressStringParameters options) {
			this.backingMap = backingMap;
			this.addressGenerator = new IPAddressGenerator(options);
		}
		public Map<String, T> getBackingMap() {
			return backingMap;
		}
		public static SegmentValueProvider getValueProvider(byte bytes[]) {
			int segmentByteCount = (bytes.length == IPv4Address.BYTE_COUNT) ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
			return getValueProvider(bytes, segmentByteCount);
		}
		public static SegmentValueProvider getValueProvider(byte bytes[], int segmentByteCount) {
			return segmentIndex -> {	
				int value = 0;
				for(int start = segmentIndex * segmentByteCount, end = start + segmentByteCount; start < end; start++) {
					value = (value << 8) | (0xff & bytes[start]);
				}
				return value;
			};
		}
		public T get(byte bytes[]) {
			IPVersion version = bytes.length == IPv4Address.BYTE_COUNT ? IPVersion.IPV4 : IPVersion.IPV6;
			int segmentByteCount = version.isIPv4() ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
			return get(version, getValueProvider(bytes, segmentByteCount), null, null, null);
		}
		public T get(AddressValueProvider addressProvider) {
			if(addressProvider instanceof IPAddressValueProvider) {
				return get((IPAddressValueProvider) addressProvider);
			}
			return get(addressProvider.getSegmentCount() == IPv4Address.SEGMENT_COUNT ? IPVersion.IPV4 : IPVersion.IPV6, 
					addressProvider.getValues(), addressProvider.getUpperValues(), null, null);	
		}
		public T get(IPAddressValueProvider addressProvider) {
			return get(addressProvider.getIPVersion(), addressProvider.getValues(), addressProvider.getUpperValues(), addressProvider.getPrefixLength(), addressProvider.getZone());
		}
		public T get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return get(version, lowerValueProvider, upperValueProvider, prefixLength, null);
		}
		public T get(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return get(IPVersion.IPV6, lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
		private T get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			if(backingMap == null) {
				IPAddress addr = addressGenerator.from(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
				return create(addr);
			}
			String key = toNormalizedString(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
			T result = backingMap.get(key);
			if(result == null) {
				IPAddress addr = addressGenerator.from(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
				addr.cacheNormalizedString(key);
				result = create(addr);
				T existing = backingMap.putIfAbsent(key, result);
				if(existing == null) {
					added(result);
				} else {
					result = existing;
				}
			}
			return result;
		}
		protected String toNormalizedString(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return addressGenerator.toNormalizedString(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
		protected abstract T create(IPAddress addr);
		protected abstract void cache(T result, IPAddress addr);
		protected abstract void added(T added);
	}
	public static class IPAddressStringGenerator extends HostIdentifierStringGenerator<IPAddressString> {
		private static final long serialVersionUID = 4L;
		private final HostIDStringAddressGenerator<IPAddressString> addressGenerator;
		@SuppressWarnings("serial")
		public IPAddressStringGenerator(Map<String, IPAddressString> backingMap, IPAddressStringParameters options) {
			super(backingMap);
			addressGenerator = new HostIDStringAddressGenerator<IPAddressString>(backingMap, options) {
				@Override
				protected IPAddressString create(IPAddress addr) {
					return addr.toAddressString();
				}
				@Override
				protected void cache(IPAddressString result, IPAddress addr) {
					result.cacheAddress(addr);
				}
				@Override
				protected void added(IPAddressString added) {
					IPAddressStringGenerator.this.added(added);
				}
			};
		}
		public IPAddressStringGenerator(Map<String, IPAddressString> backingMap) {
			this(backingMap, null);
		}
		public IPAddressStringGenerator(IPAddressStringParameters options) {
			this(null, options);
		}
		public IPAddressStringGenerator() {
			this(null, null);
		}
		@Override
		protected IPAddressString create(String addressString) {
			IPAddressStringParameters options = addressGenerator.addressGenerator.options;
			return options == null ? new IPAddressString(addressString) : new IPAddressString(addressString, options);
		}
		public static SegmentValueProvider getValueProvider(byte bytes[]) {
			return HostIDStringAddressGenerator.getValueProvider(bytes);
		}
		@Override
		public IPAddressString get(byte bytes[]) {
			return addressGenerator.get(bytes);
		}
		public IPAddressString get(IPAddressValueProvider addressProvider) {
			return addressGenerator.get(addressProvider);
		}
		@Override
		public IPAddressString get(AddressValueProvider addressProvider) {
			return addressGenerator.get(addressProvider);
		}
		public IPAddressString get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return addressGenerator.get(version, lowerValueProvider, upperValueProvider, prefixLength);
		}
		public IPAddressString get(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return addressGenerator.get(lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
	}
	public static class HostNameGenerator extends HostIdentifierStringGenerator<HostName> {
		private static final long serialVersionUID = 4L;
		private final HostIDStringAddressGenerator<HostName> addressGenerator;
		private final HostNameParameters options;
		@SuppressWarnings("serial")
		public HostNameGenerator(Map<String, HostName> backingMap, HostNameParameters options, boolean reverseLookup) {
			super(backingMap);
			addressGenerator = new HostIDStringAddressGenerator<HostName>(backingMap, options.addressOptions) {
				@Override
				protected HostName create(IPAddress addr) {
					if(reverseLookup) {
						return new HostName(addr.toInetAddress().getHostName());
					}
					return new HostName(addr);
				}
				@Override
				protected void cache(HostName result, IPAddress addr) {
					result.cacheAddress(addr);
				}
				@Override
				protected void added(HostName added) {
					HostNameGenerator.this.added(added);
				}
			};
			this.options = options;
		}
		public HostNameGenerator(Map<String, HostName> backingMap) {
			this(backingMap, HostName.DEFAULT_VALIDATION_OPTIONS, false);
		}
		public HostNameGenerator(HostNameParameters options) {
			this(null, options, false);
		}
		public HostNameGenerator() {
			this(null, null, false);
		}
		@Override
		protected HostName create(String key) {
			return options == null ? new HostName(key) : new HostName(key, options);
		}
		public static SegmentValueProvider getValueProvider(byte bytes[]) {
			return HostIDStringAddressGenerator.getValueProvider(bytes);
		}
		@Override
		public HostName get(byte bytes[]) {
			return addressGenerator.get(bytes);
		}
		@Override
		public HostName get(AddressValueProvider addressProvider) {
			return addressGenerator.get(addressProvider);
		}
		public HostName get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return addressGenerator.get(version, lowerValueProvider, upperValueProvider, prefixLength);
		}
		public HostName get(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return addressGenerator.get(lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
	}
}
package inet.ipaddr;
import java.io.Serializable;
public class HostNameParameters implements Cloneable, Comparable<HostNameParameters>, Serializable {
	private static final long serialVersionUID = 4L;
	public static final boolean DEFAULT_ALLOW_EMPTY = true;
	public static final boolean DEFAULT_EMPTY_IS_LOOPBACK = true; 
	public static final boolean DEFAULT_ACCEPT_BRACKETED_IPV6 = true;
	public static final boolean DEFAULT_ACCEPT_BRACKETED_IPV4 = true;
	public static final boolean DEFAULT_NORMALIZE_TO_LOWER_CASE = true;
	public static final boolean DEFAULT_ALLOW_IP_ADDRESS = true;
	public static final boolean DEFAULT_ALLOW_PORT = true;
	public static final boolean DEFAULT_EXPECT_PORT = false; 
	public static final boolean DEFAULT_ALLOW_SERVICE = true;
	public final boolean allowEmpty;
	public final boolean emptyIsLoopback;
	public final boolean allowBracketedIPv4;
	public final boolean allowBracketedIPv6;
	public final boolean normalizeToLowercase;
	public final boolean allowIPAddress;
	public final boolean allowPort;
	public final boolean allowService;
	public final boolean expectPort;
	public final IPAddressStringParameters addressOptions;
	public HostNameParameters(
			IPAddressStringParameters addressOptions,
			boolean allowEmpty,
			boolean emptyIsLoopback,
			boolean allowBracketedIPv6,
			boolean allowBracketedIPv4,
			boolean normalizeToLowercase,
			boolean allowIPAddress,
			boolean allowPort,
			boolean expectPort,
			boolean allowService) {
		this.allowEmpty = allowEmpty;
		this.emptyIsLoopback = emptyIsLoopback;
		this.allowBracketedIPv6 = allowBracketedIPv6;
		this.allowBracketedIPv4 = allowBracketedIPv4;
		this.normalizeToLowercase = normalizeToLowercase;
		this.allowIPAddress = allowIPAddress;
		this.allowPort = allowPort;
		this.expectPort = expectPort;
		this.allowService = allowService;
		this.addressOptions = addressOptions;
	}
	public Builder toBuilder() {
		Builder builder = new Builder();
		builder.allowEmpty = allowEmpty;
		builder.emptyIsLoopback = emptyIsLoopback;
		builder.allowBracketedIPv4 = allowBracketedIPv4;
		builder.allowBracketedIPv6 = allowBracketedIPv6;
		builder.normalizeToLowercase = normalizeToLowercase;
		builder.allowIPAddress = allowIPAddress;
		builder.allowPort = allowPort;
		builder.allowService = allowService;
		builder.addressOptionsBuilder = toAddressOptionsBuilder();
		return builder;
	}
	public IPAddressStringParameters.Builder toAddressOptionsBuilder() {
		return addressOptions.toBuilder();
	}
	public static class Builder {
		private boolean allowEmpty = DEFAULT_ALLOW_EMPTY;
		private boolean emptyIsLoopback = DEFAULT_EMPTY_IS_LOOPBACK;
		private boolean allowBracketedIPv6 = DEFAULT_ACCEPT_BRACKETED_IPV6;
		private boolean allowBracketedIPv4 = DEFAULT_ACCEPT_BRACKETED_IPV4;
		private boolean normalizeToLowercase = DEFAULT_NORMALIZE_TO_LOWER_CASE;
		private boolean allowIPAddress = DEFAULT_ALLOW_IP_ADDRESS;
		private boolean allowPort = DEFAULT_ALLOW_PORT;
		private boolean expectPort = DEFAULT_EXPECT_PORT;
		private boolean allowService = DEFAULT_ALLOW_SERVICE;
		private IPAddressStringParameters.Builder addressOptionsBuilder;
		public Builder() {}
		public Builder allowPort(boolean allow) {
			allowPort = allow;
			return this;
		}
		public Builder expectPort(boolean expect) {
			expectPort = expect;
			return this;
		}
		public Builder allowService(boolean allow) {
			allowService = allow;
			return this;
		}
		public Builder allowIPAddress(boolean allow) {
			allowIPAddress = allow;
			return this;
		}
		public Builder allowEmpty(boolean allow) {
			allowEmpty = allow;
			return this;
		}
		public Builder setEmptyAsLoopback(boolean bool) {
			emptyIsLoopback = bool;
			return this;
		}
		public Builder allowBracketedIPv6(boolean allow) {
			allowBracketedIPv6 = allow;
			return this;
		}
		public Builder allowBracketedIPv4(boolean allow) {
			allowBracketedIPv4 = allow;
			return this;
		}
		public Builder setNormalizeToLowercase(boolean bool) {
			normalizeToLowercase = bool;
			return this;
		}
		public IPAddressStringParameters.Builder getAddressOptionsBuilder() {
			if(addressOptionsBuilder == null) {
				addressOptionsBuilder = new IPAddressStringParameters.Builder();
			}
			addressOptionsBuilder.parent = this;
			return addressOptionsBuilder;
		}
		public HostNameParameters toParams() {
			IPAddressStringParameters addressOpts;
			if(addressOptionsBuilder == null) {
				addressOpts = IPAddressString.DEFAULT_VALIDATION_OPTIONS;
			} else {
				addressOpts = addressOptionsBuilder.toParams();
			}
			return new HostNameParameters(
					addressOpts,
					allowEmpty,
					emptyIsLoopback,
					allowIPAddress && allowBracketedIPv6,
					allowIPAddress && allowBracketedIPv4,
					normalizeToLowercase,
					allowIPAddress,
					allowPort,
					expectPort,
					allowService);
		}
	}
	@Override
	public HostNameParameters clone() {
		try {
			return (HostNameParameters) super.clone();
		} catch (CloneNotSupportedException e) {}
		return null;
	}
	@Override
	public int compareTo(HostNameParameters o) {
		int result = Boolean.compare(allowEmpty, o.allowEmpty);
		if(result == 0) {
			result = Boolean.compare(allowBracketedIPv6, o.allowBracketedIPv6);
			if(result == 0) {
				result = Boolean.compare(allowBracketedIPv4, o.allowBracketedIPv4);
				if(result == 0) {
					result = Boolean.compare(normalizeToLowercase, o.normalizeToLowercase);
					if(result == 0) {
						result = Boolean.compare(allowIPAddress, o.allowIPAddress);
						if(result == 0) {
							result = Boolean.compare(allowPort, o.allowPort);
							if(result == 0) {
								result = Boolean.compare(expectPort, o.expectPort);
								if(result == 0) {
									result = Boolean.compare(allowService, o.allowService);
									if(result == 0) {
										result = addressOptions.compareTo(o.addressOptions);
									}
								}
							}
						}
					}
				}
			}
		}
		return result;
	}
	@Override
	public boolean equals(Object o) {
		if(o instanceof HostNameParameters) {
			HostNameParameters other = (HostNameParameters) o;
			return allowEmpty == other.allowEmpty &&
					allowBracketedIPv6 == other.allowBracketedIPv6 &&
					allowBracketedIPv4 == other.allowBracketedIPv4 &&
					normalizeToLowercase == other.normalizeToLowercase &&
					allowIPAddress == other.allowIPAddress &&
					allowPort == other.allowPort &&
					expectPort == other.expectPort &&
					allowService == other.allowService &&
					addressOptions.equals(other.addressOptions);
		}
		return false;
	}
	@Override
	public int hashCode() {
		int hash = allowIPAddress ? addressOptions.hashCode() : 0;
		if(allowEmpty) {
			hash |= 0x20000000;
		}
		if(allowIPAddress) {
			if(allowBracketedIPv6 || allowBracketedIPv4) {
				hash |= 0x80000000;
			}
		}
		if(allowPort || allowService || expectPort) {
			hash |= 0x40000000;
		}
		return hash;
	}
}
package inet.ipaddr;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.ipv4.IPv4AddressStringParameters;
import inet.ipaddr.ipv6.IPv6AddressStringParameters;
public class IPAddressStringParameters extends AddressStringParameters implements Comparable<IPAddressStringParameters> {
	private static final long serialVersionUID = 4L;
	public static final boolean DEFAULT_ALLOW_PREFIX_ONLY = true;
	public static final boolean DEFAULT_EMPTY_IS_LOOPBACK = true; 
	public static final boolean DEFAULT_ALLOW_PREFIX = true;
	public static final boolean DEFAULT_ALLOW_MASK = true;
	public static final boolean DEFAULT_ALLOW_IPV4 = true;
	public static final boolean DEFAULT_ALLOW_IPV6 = true;
	public final boolean allowPrefixOnly;
	public final boolean emptyIsLoopback;
	public final boolean allowPrefix;
	public final boolean allowMask;
	public final boolean allowIPv6;
	public final boolean allowIPv4;
	private IPv6AddressStringParameters ipv6Options;
	private IPv4AddressStringParameters ipv4Options;
	public IPVersion inferVersion() {
		if(allowIPv6) {
			if(!allowIPv4) {
				return IPVersion.IPV6;
			}
		} else if(allowIPv4) {
				return IPVersion.IPV4;
		}
		return null;
	}
	public static class Builder extends AddressStringParameters.BuilderBase {
		private boolean emptyIsLoopback = DEFAULT_EMPTY_IS_LOOPBACK;
		private boolean allowPrefix = DEFAULT_ALLOW_PREFIX;
		private boolean allowMask = DEFAULT_ALLOW_MASK;
		private boolean allowPrefixOnly = DEFAULT_ALLOW_PREFIX_ONLY;
		private boolean allowIPv4 = DEFAULT_ALLOW_IPV4;
		private boolean allowIPv6 = DEFAULT_ALLOW_IPV6;
		IPv4AddressStringParameters.Builder ipv4Builder;
		static private IPv4AddressStringParameters DEFAULT_IPV4_OPTS = new IPv4AddressStringParameters.Builder().toParams();
		IPv6AddressStringParameters.Builder ipv6Builder;
		static private IPv6AddressStringParameters DEFAULT_IPV6_OPTS = new IPv6AddressStringParameters.Builder().toParams();
		HostNameParameters.Builder parent;
		public Builder() {}
		public HostNameParameters.Builder getParentBuilder() {
			return parent;
		}
		@Override
		public Builder allowEmpty(boolean allow) {
			return (Builder) super.allowEmpty(allow);
		}
		@Override
		public Builder allowSingleSegment(boolean allow) {
			return (Builder) super.allowSingleSegment(allow);
		}
		public Builder setEmptyAsLoopback(boolean bool) {
			emptyIsLoopback = bool;
			return this;
		}
		public Builder allowPrefix(boolean allow) {
			allowPrefix = allow;
			return this;
		}
		public Builder allowMask(boolean allow) {
			allowMask = allow;
			return this;
		}
		public Builder allowPrefixOnly(boolean allow) {
			allowPrefixOnly = allow;
			return this;
		}
		@Override
		public Builder allowAll(boolean allow) {
			return (Builder) super.allowAll(allow);
		}
		public Builder allowIPv4(boolean allow) {
			allowIPv4 = allow;
			return this;
		}
		public Builder allowIPv6(boolean allow) {
			allowIPv6 = allow;
			return this;
		}
		public Builder allowWildcardedSeparator(boolean allow) {
			getIPv4AddressParametersBuilder().allowWildcardedSeparator(allow);
			getIPv6AddressParametersBuilder().allowWildcardedSeparator(allow);
			return this;
		}
		public Builder setRangeOptions(RangeParameters rangeOptions) {
			getIPv4AddressParametersBuilder().setRangeOptions(rangeOptions);
			getIPv6AddressParametersBuilder().setRangeOptions(rangeOptions);
			return this;
		}
		public Builder allow_inet_aton(boolean allow) {
			getIPv4AddressParametersBuilder().allow_inet_aton(allow);
			getIPv6AddressParametersBuilder().allow_mixed_inet_aton(allow);
			return this;
		}
		public void setIPv6AddressParameters(IPv6AddressStringParameters params) {
			ipv6Builder = params.toBuilder();
		}
		public IPv6AddressStringParameters.Builder getIPv6AddressParametersBuilder() {
			if(ipv6Builder == null) {
				ipv6Builder = new IPv6AddressStringParameters.Builder();
			}
			((IPAddressStringFormatParameters.BuilderBase) ipv6Builder).parent = this;
			return ipv6Builder;
		}
		public void setIPv4AddressParameters(IPv4AddressStringParameters params) {
			ipv4Builder = params.toBuilder();
		}
		public IPv4AddressStringParameters.Builder getIPv4AddressParametersBuilder() {
			if(ipv4Builder == null) {
				ipv4Builder = new IPv4AddressStringParameters.Builder();
			}
			((IPAddressStringFormatParameters.BuilderBase) ipv4Builder).parent = this;
			return ipv4Builder;
		}
		public IPAddressStringParameters toParams() {
			IPv4AddressStringParameters ipv4Opts;
			if(ipv4Builder == null) {
				ipv4Opts = DEFAULT_IPV4_OPTS;
			} else {
				ipv4Opts = ipv4Builder.toParams();
			}
			IPv6AddressStringParameters ipv6Opts;
			if(ipv6Builder == null) {
				ipv6Opts = DEFAULT_IPV6_OPTS;
			} else {
				ipv6Opts = ipv6Builder.toParams();
			}
			return new IPAddressStringParameters(allowEmpty, allowAll, allowSingleSegment, emptyIsLoopback, allowPrefix, allowMask, allowPrefixOnly, allowIPv4, allowIPv6, ipv4Opts, ipv6Opts);
		}
	}
	public abstract static class IPAddressStringFormatParameters extends AddressStringFormatParameters {
		private static final long serialVersionUID = 4L;
		public static final boolean DEFAULT_ALLOW_PREFIX_LENGTH_LEADING_ZEROS = true;
		public static final boolean DEFAULT_ALLOW_PREFIX_BEYOND_ADDRESS_SIZE = false;
		public static final boolean DEFAULT_ALLOW_BINARY = true;
		public final boolean allowBinary;
		public final boolean allowPrefixesBeyondAddressSize; 
		public final boolean allowPrefixLengthLeadingZeros;
		@Deprecated
		public IPAddressStringFormatParameters(
				boolean allowLeadingZeros,
				boolean allowPrefixLengthLeadingZeros,
				boolean allowUnlimitedLeadingZeros,
				RangeParameters rangeOptions,
				boolean allowWildcardedSeparator,
				boolean allowPrefixesBeyondAddressSize) {
			this(
				false, 
				allowLeadingZeros,
				allowPrefixLengthLeadingZeros,
				allowUnlimitedLeadingZeros,
				rangeOptions,
				allowWildcardedSeparator,
				allowPrefixesBeyondAddressSize);
		}
		public IPAddressStringFormatParameters(
				boolean allowBinary,
				boolean allowLeadingZeros,
				boolean allowPrefixLengthLeadingZeros,
				boolean allowUnlimitedLeadingZeros,
				RangeParameters rangeOptions,
				boolean allowWildcardedSeparator,
				boolean allowPrefixesBeyondAddressSize) {
			super(allowLeadingZeros, allowUnlimitedLeadingZeros, rangeOptions, allowWildcardedSeparator);
			this.allowBinary = allowBinary;
			this.allowPrefixLengthLeadingZeros = allowPrefixLengthLeadingZeros;
			this.allowPrefixesBeyondAddressSize = allowPrefixesBeyondAddressSize;
		}
		protected BuilderBase toBuilder(BuilderBase builder) {
			super.toBuilder(builder);
			builder.allowPrefixLengthLeadingZeros = allowPrefixLengthLeadingZeros;
			builder.allowPrefixesBeyondAddressSize = allowPrefixesBeyondAddressSize;
			builder.allowBinary = allowBinary;
			return builder;
		}
		protected static class BuilderBase extends AddressStringFormatParameters.BuilderBase {
			protected boolean allowPrefixesBeyondAddressSize = DEFAULT_ALLOW_PREFIX_BEYOND_ADDRESS_SIZE;
			protected boolean allowPrefixLengthLeadingZeros = DEFAULT_ALLOW_PREFIX_LENGTH_LEADING_ZEROS;
			protected boolean allowBinary = DEFAULT_ALLOW_BINARY;
			IPAddressStringParameters.Builder parent;
			public IPAddressStringParameters.Builder getParentBuilder() {
				return parent;
			}
			@Override
			public BuilderBase setRangeOptions(RangeParameters rangeOptions) {
				return (BuilderBase) super.setRangeOptions(rangeOptions);
			}
			public BuilderBase allowPrefixesBeyondAddressSize(boolean allow) {
				allowPrefixesBeyondAddressSize = allow;
				return this;
			}
			public BuilderBase allowBinary(boolean allow) {
				allowBinary = allow;
				return this;
			}
			@Override
			public BuilderBase allowWildcardedSeparator(boolean allow) {
				return (BuilderBase) super.allowWildcardedSeparator(allow);
			}
			@Override
			public BuilderBase allowLeadingZeros(boolean allow) {
				return (BuilderBase) super.allowLeadingZeros(allow);
			}
			public BuilderBase allowPrefixLengthLeadingZeros(boolean allow) {
				allowPrefixLengthLeadingZeros = allow;
				return this;
			}
			@Override
			public BuilderBase allowUnlimitedLeadingZeros(boolean allow) {
				return (BuilderBase) super.allowUnlimitedLeadingZeros(allow);
			}
			protected static void setMixedParentInst(IPv6AddressStringParameters.Builder parent, IPv4AddressStringParameters.Builder embedded) {
				BuilderBase base = embedded;
				base.setMixedParent(parent);
			}
			protected void setMixedParent(IPv6AddressStringParameters.Builder parent) {}
		}
		public abstract IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
		protected int compareTo(IPAddressStringFormatParameters o) {
			int result = super.compareTo(o);
			if(result == 0) {
				result = Boolean.compare(allowPrefixesBeyondAddressSize, o.allowPrefixesBeyondAddressSize);
				if(result == 0) {
					result = Boolean.compare(allowPrefixLengthLeadingZeros, o.allowPrefixLengthLeadingZeros);
					if(result == 0) {
						result = Boolean.compare(allowBinary, o.allowBinary);
					}
				}
			}
			return result;
		}
		@Override
		public boolean equals(Object o) {
			if(o instanceof IPAddressStringFormatParameters) {
				IPAddressStringFormatParameters other = (IPAddressStringFormatParameters) o;
				return super.equals(o) &&
						allowPrefixesBeyondAddressSize == other.allowPrefixesBeyondAddressSize
						&& allowBinary == other.allowBinary
						&& allowPrefixLengthLeadingZeros == other.allowPrefixLengthLeadingZeros;
			}
			return false;
		}
		@Override
		public int hashCode() {
			int hash = super.hashCode();
			if(allowPrefixesBeyondAddressSize) {
				hash |= 0x8;
			}
			return hash;
		}
	}
	public Builder toBuilder() {
		return toBuilder(false);
	}
	public Builder toBuilder(boolean isMixed) {
		Builder builder = new Builder();
		super.toBuilder(builder);
		builder.allowPrefixOnly = allowPrefixOnly;
		builder.emptyIsLoopback = emptyIsLoopback;
		builder.allowPrefix = allowPrefix;
		builder.allowMask = allowMask;
		builder.allowIPv6 = allowIPv6;
		builder.allowIPv4 = allowIPv4;
		builder.ipv4Builder = ipv4Options.toBuilder();
		builder.ipv6Builder = ipv6Options.toBuilder(isMixed);
		builder.allowSingleSegment = allowSingleSegment;
		builder.allowEmpty = allowEmpty;
		builder.allowAll = allowAll;
		return builder;
	}
	public IPAddressStringParameters(
			boolean allowEmpty,
			boolean allowAll,
			boolean allowSingleSegment,
			boolean emptyIsLoopback,
			boolean allowPrefix,
			boolean allowMask,
			boolean allowPrefixOnly,
			boolean allowIPv4,
			boolean allowIPv6,
			IPv4AddressStringParameters ipv4Options,
			IPv6AddressStringParameters ipv6Options) {
		super(allowEmpty, allowAll, allowSingleSegment);
		this.allowPrefixOnly = allowPrefixOnly;
		this.emptyIsLoopback = emptyIsLoopback;
		this.allowPrefix = allowPrefix;
		this.allowMask = allowMask;
		this.allowIPv4 = allowIPv4;
		this.allowIPv6 = allowIPv6;
		this.ipv6Options = ipv6Options;
		this.ipv4Options = ipv4Options;
	}
	public IPv6AddressStringParameters getIPv6Parameters() {
		return ipv6Options;
	}
	public IPv4AddressStringParameters getIPv4Parameters() {
		return ipv4Options;
	}
	@Override
	public IPAddressStringParameters clone() {
		IPAddressStringParameters result = (IPAddressStringParameters) super.clone();
		result.ipv4Options = ipv4Options.clone();
		result.ipv6Options = ipv6Options.clone();
		return result;
	}
	@Override
	public int compareTo(IPAddressStringParameters o) {
		int result = super.compareTo(o);
		if(result == 0) {
			result = ipv4Options.compareTo(o.ipv4Options);
			if(result == 0) {
				result = ipv6Options.compareTo(o.ipv6Options);
				if(result == 0) {
					result = Boolean.compare(emptyIsLoopback, o.emptyIsLoopback);
					if(result == 0) {
						result = Boolean.compare(allowPrefix, o.allowPrefix);
						if(result == 0) {
							result = Boolean.compare(allowPrefixOnly, o.allowPrefixOnly);
							if(result == 0) {
								result = Boolean.compare(allowMask, o.allowMask);
								if(result == 0) {
									result = Boolean.compare(allowIPv6, o.allowIPv6);
									if(result == 0) {
										result = Boolean.compare(allowIPv4, o.allowIPv4);
									}
								}
							}
						}
					}
				}
			}
		}
		return result;
	}
	@Override
	public boolean equals(Object o) {
		if(o instanceof IPAddressStringParameters) {
			IPAddressStringParameters other = (IPAddressStringParameters) o;
			return super.equals(o)
					&& ipv4Options.equals(other.ipv4Options) 
					&& ipv6Options.equals(other.ipv6Options) 
					&& emptyIsLoopback == other.emptyIsLoopback 
					&& allowPrefix == other.allowPrefix 
					&& allowPrefixOnly == other.allowPrefixOnly 
					&& allowMask == other.allowMask
					&& allowIPv6 == other.allowIPv6
					&& allowIPv4 == other.allowIPv4;
		}
		return false;
	}
	@Override
	public int hashCode() {
		int hash = ipv4Options.hashCode();
		hash |= ipv6Options.hashCode() << 9;
		if(emptyIsLoopback) {
			hash |= 0x8000000;
		}
		if(allowPrefix) {
			hash |= 0x10000000;
		}
		if(allowMask) {
			hash |= 0x20000000;
		}
		if(allowEmpty) {
			hash |= 0x40000000;
		}
		if(allowSingleSegment) {
			hash |= 0x80000000;
		}
		return hash;
	}
}
package inet.ipaddr.format.string;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.format.standard.AddressDivision;
public interface IPAddressStringDivisionSeries extends AddressStringDivisionSeries {
	IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	@Override
	IPAddressStringDivision getDivision(int index);
	boolean isPrefixBlock();
	boolean isPrefixed();
	Integer getPrefixLength();
}
package inet.ipaddr.ipv6;
import java.util.Objects;
import inet.ipaddr.Address;
import inet.ipaddr.AddressStringParameters.RangeParameters;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IPAddressStringParameters.IPAddressStringFormatParameters;
import inet.ipaddr.ipv4.IPv4AddressStringParameters;
public class IPv6AddressStringParameters extends IPAddressStringFormatParameters implements Comparable<IPv6AddressStringParameters> {
	private static final long serialVersionUID = 4L;
	public static final boolean DEFAULT_ALLOW_MIXED = true;
	public static final boolean DEFAULT_ALLOW_ZONE = true;
	public static final boolean DEFAULT_ALLOW_EMPTY_ZONE = true;
	public static final boolean DEFAULT_ALLOW_BASE85 = true;
	public final boolean allowMixed;
	public final boolean allowZone;
	public final boolean allowEmptyZone;
	public final boolean allowBase85;
	private final IPv6AddressNetwork network;
	private IPAddressStringParameters embeddedIPv4Options;
	@Deprecated
	public IPv6AddressStringParameters(
			boolean allowLeadingZeros,
			boolean allowCIDRPrefixLeadingZeros,
			boolean allowUnlmitedLeadingZeros,
			boolean allowMixed,
			IPAddressStringParameters mixedOptions,
			boolean allowZone,
			boolean allowBase85,
			RangeParameters rangeOptions,
			boolean allowWildcardedSeparator,
			boolean allowPrefixesBeyondAddressSize,
			IPv6AddressNetwork network) {
		this(allowLeadingZeros,
				allowCIDRPrefixLeadingZeros,
				allowUnlmitedLeadingZeros,
				allowMixed,
				mixedOptions,
				allowZone,
				true, 
				allowBase85,
				rangeOptions,
				allowWildcardedSeparator,
				allowPrefixesBeyondAddressSize,
				false, 
				network);
	}
	public IPv6AddressStringParameters(
			boolean allowLeadingZeros,
			boolean allowCIDRPrefixLeadingZeros,
			boolean allowUnlmitedLeadingZeros,
			boolean allowMixed,
			IPAddressStringParameters mixedOptions,
			boolean allowZone,
			boolean allowEmptyZone,
			boolean allowBase85,
			RangeParameters rangeOptions,
			boolean allowWildcardedSeparator,
			boolean allowPrefixesBeyondAddressSize,
			boolean allowBinary,
			IPv6AddressNetwork network) {
		super(allowBinary, allowLeadingZeros, allowCIDRPrefixLeadingZeros, allowUnlmitedLeadingZeros, rangeOptions, allowWildcardedSeparator, allowPrefixesBeyondAddressSize);
		this.allowMixed = allowMixed;
		this.allowZone = allowZone;
		this.allowEmptyZone = allowEmptyZone;
		this.allowBase85 = allowBase85;
		this.embeddedIPv4Options = mixedOptions;
		this.network = network;
	}
	public Builder toBuilder() {
		return toBuilder(false);
	}
	public Builder toBuilder(boolean isMixed) {
		Builder builder = new Builder();
		builder.allowMixed = allowMixed;
		builder.allowZone = allowZone;
		builder.allowEmptyZone = allowEmptyZone;
		builder.allowBase85 = allowBase85;
		builder.network = network;
		if(!isMixed) {
			builder.embeddedIPv4OptionsBuilder = embeddedIPv4Options.toBuilder(true);
		}
		return (Builder) toBuilder(builder);
	}
	public static class Builder extends IPAddressStringFormatParameters.BuilderBase {
		private boolean allowMixed = DEFAULT_ALLOW_MIXED;
		private boolean allowZone = DEFAULT_ALLOW_ZONE;
		private boolean allowEmptyZone = DEFAULT_ALLOW_EMPTY_ZONE;
		private boolean allowBase85 = DEFAULT_ALLOW_BASE85;
		private IPAddressStringParameters.Builder embeddedIPv4OptionsBuilder;
		private IPv6AddressNetwork network;
		static private IPAddressStringParameters DEFAULT_MIXED_OPTS = 
				new IPAddressStringParameters( false,  false, false, 
						 false, 
						 false,  false,  false, 
						 true,  false, 
						new IPv4AddressStringParameters.Builder().toParams(), 
						new IPv6AddressStringParameters(
								 false,
								 false,
								 false,
								 false,
								 null,
								 true,
								 false,
								 false,
								 DEFAULT_RANGE_OPTIONS,
								 false,
								 false,
								 false,
								 null));
		public Builder() {}
		public Builder allowBase85(boolean allow) {
			allowBase85 = allow;
			return this;
		}
		public Builder allowZone(boolean allow) {
			getEmbeddedIPv4ParametersBuilder().getIPv6AddressParametersBuilder().allowZone = allow;
			allowZone = allow;
			return this;
		}
		public Builder allowEmptyZone(boolean allow) {
			getEmbeddedIPv4ParametersBuilder().getIPv6AddressParametersBuilder().allowEmptyZone = allow;
			allowEmptyZone = allow;
			return this;
		}
		public Builder allow_mixed_inet_aton(boolean allow) {
			if(allow) {
				allowMixed(allow);
			}
			getEmbeddedIPv4ParametersBuilder().getIPv4AddressParametersBuilder().allow_inet_aton(allow);
			return this;
		}
		public Builder allowMixed(boolean allow) {
			allowMixed = allow;
			return this;
		}
		public IPv4AddressStringParameters.Builder getEmbeddedIPv4AddressParametersBuilder() {
			return getEmbeddedIPv4ParametersBuilder().getIPv4AddressParametersBuilder();
		}
		IPAddressStringParameters.Builder getEmbeddedIPv4ParametersBuilder() {
			if(embeddedIPv4OptionsBuilder == null) {
				embeddedIPv4OptionsBuilder = new IPAddressStringParameters.Builder().
						allowEmpty(false).allowPrefix(false).allowMask(false).allowPrefixOnly(false).allowAll(false).allowIPv6(false);
				embeddedIPv4OptionsBuilder.getIPv6AddressParametersBuilder().allowZone = allowZone;
				embeddedIPv4OptionsBuilder.getIPv6AddressParametersBuilder().allowEmptyZone = allowEmptyZone;
			}
			setMixedParentInst(this, embeddedIPv4OptionsBuilder.getIPv4AddressParametersBuilder());
			return embeddedIPv4OptionsBuilder;
		}
		public Builder setNetwork(IPv6AddressNetwork network) {
			this.network = network;
			return this;
		}
		@Override
		public Builder allowBinary(boolean allow) {
			getEmbeddedIPv4AddressParametersBuilder().allowBinary(allow);
			super.allowBinary(allow);
			return this;
		}
		@Override
		public Builder allowWildcardedSeparator(boolean allow) {
			getEmbeddedIPv4AddressParametersBuilder().allowWildcardedSeparator(allow);
			super.allowWildcardedSeparator(allow);
			return this;
		}
		@Override
		public Builder allowLeadingZeros(boolean allow) {
			getEmbeddedIPv4AddressParametersBuilder().allowLeadingZeros(allow);
			super.allowLeadingZeros(allow);
			return this;
		}
		@Override
		public Builder allowUnlimitedLeadingZeros(boolean allow) {
			getEmbeddedIPv4AddressParametersBuilder().allowUnlimitedLeadingZeros(allow);
			super.allowUnlimitedLeadingZeros(allow);
			return this;
		}
		@Override
		public Builder setRangeOptions(RangeParameters rangeOptions) {
			getEmbeddedIPv4ParametersBuilder().getIPv4AddressParametersBuilder().setRangeOptions(rangeOptions);
			super.setRangeOptions(rangeOptions);
			return this;
		}
		@Override
		public Builder allowPrefixesBeyondAddressSize(boolean allow) {
			super.allowPrefixesBeyondAddressSize(allow);
			return this;
		}
		@Override
		public Builder allowPrefixLengthLeadingZeros(boolean allow) {
			super.allowPrefixLengthLeadingZeros(allow);
			return this;
		}
		public IPv6AddressStringParameters toParams() {
			IPAddressStringParameters mixedOptions;
			if(embeddedIPv4OptionsBuilder == null) {
				mixedOptions = DEFAULT_MIXED_OPTS;
			} else {
				mixedOptions = embeddedIPv4OptionsBuilder.toParams();
			}
			return new IPv6AddressStringParameters(
					allowLeadingZeros,
					allowPrefixLengthLeadingZeros,
					allowUnlimitedLeadingZeros,
					allowMixed,
					mixedOptions,
					allowZone,
					allowEmptyZone,
					allowBase85,
					rangeOptions,
					allowWildcardedSeparator,
					allowPrefixesBeyondAddressSize,
					allowBinary,
					network);
		}
	}
	@Override
	public IPv6AddressNetwork getNetwork() {
		if(network == null) {
			return Address.defaultIpv6Network();
		}
		return network;
	}
	@Override
	public IPv6AddressStringParameters clone() {
		try {
			IPv6AddressStringParameters result = (IPv6AddressStringParameters) super.clone();
			result.embeddedIPv4Options = embeddedIPv4Options.clone();
			return result;
		} catch (CloneNotSupportedException e) {}
		return null;
	}
	public IPAddressStringParameters getMixedParameters() {
		return embeddedIPv4Options;
	}
	@Override
	public int compareTo(IPv6AddressStringParameters o) {
		int result = super.compareTo(o);
		if(result == 0) {
			result = embeddedIPv4Options.getIPv4Parameters().compareTo(o.embeddedIPv4Options.getIPv4Parameters());
			if(result == 0) {
				result = Boolean.compare(allowMixed, o.allowMixed);
				if(result == 0) {
					result = Boolean.compare(allowZone, o.allowZone);
					if(result == 0) {
						result = Boolean.compare(allowEmptyZone, o.allowEmptyZone);
						if(result == 0) {
							result = Boolean.compare(allowBase85, o.allowBase85);
						}
					}
				}
			}
		}
		return result;
	}
	@Override
	public boolean equals(Object o) {
		if(o instanceof IPv6AddressStringParameters) {
			if(super.equals(o)) {
				IPv6AddressStringParameters other = (IPv6AddressStringParameters) o;
				return Objects.equals(embeddedIPv4Options.getIPv4Parameters(), other.embeddedIPv4Options.getIPv4Parameters())
					&& allowMixed == other.allowMixed
					&& allowZone == other.allowZone
					&& allowEmptyZone == other.allowEmptyZone
					&& allowBase85 == other.allowBase85;
			}
		}
		return false;
	}
	@Override
	public int hashCode() {
		int hash = super.hashCode();
		hash |= embeddedIPv4Options.getIPv4Parameters().hashCode() << 6;
		if(allowMixed) {
			hash |= 0x8000;
		}
		if(allowZone) {
			hash |= 0x10000;
		}
		if(allowBase85) {
			hash |= 0x20000;
		}
		return hash;
	}
}
package inet.ipaddr.ipv4;
import inet.ipaddr.Address;
import inet.ipaddr.AddressStringParameters;
import inet.ipaddr.AddressStringParameters.RangeParameters;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IPAddressStringParameters.IPAddressStringFormatParameters;
import inet.ipaddr.ipv6.IPv6AddressStringParameters;
public class IPv4AddressStringParameters extends IPAddressStringFormatParameters implements Comparable<IPv4AddressStringParameters> {
	private static final long serialVersionUID = 4L;
	public static final boolean DEFAULT_ALLOW_IPV4_INET_ATON = true;
	public static final boolean DEFAULT_ALLOW_IPV4_INET_ATON_SINGLE_SEGMENT_MASK = false; 
	public static final boolean DEFAULT_ALLOW_IPV4_inet_aton_extraneous_digits = false;
	public final boolean inet_aton_hex;
	public final boolean inet_aton_octal;
	public final boolean inet_aton_leading_zeros;
	public final boolean inet_aton_joinedSegments;
	public final boolean inet_aton_single_segment_mask;
	public final boolean inet_aton_extraneous_digits;
	private final IPv4AddressNetwork network;
	@Deprecated
	public IPv4AddressStringParameters(
			boolean allowLeadingZeros,
			boolean allowCIDRPrefixLeadingZeros,
			boolean allowUnlimitedLeadingZeros,
			RangeParameters rangeOptions,
			boolean allowWildcardedSeparator,
			boolean allowPrefixesBeyondAddressSize,
			boolean inet_aton_hex,
			boolean inet_aton_octal,
			boolean inet_aton_leading_zeros,
			boolean inet_aton_joinedSegments,
			boolean inet_aton_single_segment_mask,
			IPv4AddressNetwork network) {
		this(allowLeadingZeros,
			allowCIDRPrefixLeadingZeros,
			allowUnlimitedLeadingZeros,
			rangeOptions,
			allowWildcardedSeparator,
			allowPrefixesBeyondAddressSize,
			false, 
			inet_aton_hex,
			inet_aton_octal,
			inet_aton_leading_zeros,
			inet_aton_joinedSegments,
			inet_aton_single_segment_mask,
			false,
			network);
	}
	public IPv4AddressStringParameters(
			boolean allowLeadingZeros,
			boolean allowCIDRPrefixLeadingZeros,
			boolean allowUnlimitedLeadingZeros,
			RangeParameters rangeOptions,
			boolean allowWildcardedSeparator,
			boolean allowPrefixesBeyondAddressSize,
			boolean allowBinary,
			boolean inet_aton_hex,
			boolean inet_aton_octal,
			boolean inet_aton_leading_zeros,
			boolean inet_aton_joinedSegments,
			boolean inet_aton_single_segment_mask,
			boolean inet_aton_extraneous_digits,
			IPv4AddressNetwork network) {
		super(allowBinary, allowLeadingZeros, allowCIDRPrefixLeadingZeros, allowUnlimitedLeadingZeros, rangeOptions, allowWildcardedSeparator, allowPrefixesBeyondAddressSize);
		this.inet_aton_hex = inet_aton_hex;
		this.inet_aton_octal = inet_aton_octal;
		this.inet_aton_leading_zeros = inet_aton_leading_zeros;
		this.inet_aton_joinedSegments = inet_aton_joinedSegments;
		this.inet_aton_single_segment_mask = inet_aton_single_segment_mask;
		this.inet_aton_extraneous_digits = inet_aton_extraneous_digits;
		this.network = network;
	}
	public Builder toBuilder() {
		Builder builder = new Builder();
		builder.inet_aton_hex = inet_aton_hex;
		builder.inet_aton_octal = inet_aton_octal;
		builder.inet_aton_joinedSegments = inet_aton_joinedSegments;
		builder.inet_aton_single_segment_mask = inet_aton_single_segment_mask;
		builder.inet_aton_extraneous_digits = inet_aton_extraneous_digits;
		builder.network = network;
		return (Builder) toBuilder(builder);
	}
	public static class Builder extends IPAddressStringFormatParameters.BuilderBase {
		private boolean inet_aton_hex = DEFAULT_ALLOW_IPV4_INET_ATON;
		private boolean inet_aton_octal = DEFAULT_ALLOW_IPV4_INET_ATON;
		private boolean inet_aton_leading_zeros = DEFAULT_ALLOW_IPV4_INET_ATON;
		private boolean inet_aton_joinedSegments = DEFAULT_ALLOW_IPV4_INET_ATON;
		private boolean inet_aton_single_segment_mask = DEFAULT_ALLOW_IPV4_INET_ATON_SINGLE_SEGMENT_MASK;
		private boolean inet_aton_extraneous_digits = DEFAULT_ALLOW_IPV4_inet_aton_extraneous_digits;
		private IPv4AddressNetwork network;
		IPv6AddressStringParameters.Builder mixedParent;
		@Override
		protected void setMixedParent(IPv6AddressStringParameters.Builder parent) {
			mixedParent = parent;
		}
		public IPv6AddressStringParameters.Builder getEmbeddedIPv4AddressParentBuilder() {
			return mixedParent;
		}
		public Builder allow_inet_aton(boolean allow) {
			inet_aton_joinedSegments = inet_aton_octal = inet_aton_hex = allow;
			super.allowUnlimitedLeadingZeros(allow);
			return this;
		}
		@Override
		public Builder allowBinary(boolean allow) {
			super.allowBinary(allow);
			return this;
		}
		public Builder allow_inet_aton_hex(boolean allow) {
			inet_aton_hex = allow;
			return this;
		}
		public Builder allow_inet_aton_octal(boolean allow) {
			inet_aton_octal = allow;
			return this;
		}
		public Builder allow_inet_aton_leading_zeros(boolean allow) {
			inet_aton_leading_zeros = allow;
			return this;
		}
		public Builder allow_inet_aton_joined_segments(boolean allow) {
			inet_aton_joinedSegments = allow;
			return this;
		}
		public Builder allow_inet_aton_single_segment_mask(boolean allow) {
			inet_aton_single_segment_mask = allow;
			return this;
		}
		public Builder allow_inet_aton_extraneous_digits(boolean allow) {
			inet_aton_extraneous_digits = allow;
			return this;
		}
		public Builder setNetwork(IPv4AddressNetwork network) {
			this.network = network;
			return this;
		}
		@Override
		public Builder setRangeOptions(RangeParameters rangeOptions) {
			super.setRangeOptions(rangeOptions);
			return this;
		}
		@Override
		public Builder allowPrefixesBeyondAddressSize(boolean allow) {
			super.allowPrefixesBeyondAddressSize(allow);
			return this;
		}
		@Override
		public Builder allowWildcardedSeparator(boolean allow) {
			super.allowWildcardedSeparator(allow);
			return this;
		}
		@Override
		public Builder allowLeadingZeros(boolean allow) {
			super.allowLeadingZeros(allow);
			return this;
		}
		@Override
		public Builder allowPrefixLengthLeadingZeros(boolean allow) {
			super.allowPrefixLengthLeadingZeros(allow);
			return this;
		}
		@Override
		public Builder allowUnlimitedLeadingZeros(boolean allow) {
			super.allowUnlimitedLeadingZeros(allow);
			return this;
		}
		public IPv4AddressStringParameters toParams() {
			return new IPv4AddressStringParameters(
					allowLeadingZeros,
					allowPrefixLengthLeadingZeros,
					allowUnlimitedLeadingZeros,
					rangeOptions, 
					allowWildcardedSeparator,
					allowPrefixesBeyondAddressSize,
					allowBinary,
					inet_aton_hex,
					inet_aton_octal,
					inet_aton_leading_zeros,
					inet_aton_joinedSegments,
					inet_aton_single_segment_mask,
					inet_aton_extraneous_digits,
					network);
		}
	}
	@Override
	public IPv4AddressNetwork getNetwork() {
		if(network == null) {
			return Address.defaultIpv4Network();
		}
		return network;
	}
	@Override
	public IPv4AddressStringParameters clone() {
		try {
			return (IPv4AddressStringParameters) super.clone();
		} catch (CloneNotSupportedException e) {}
		return null;
	}
	@Override
	public int compareTo(IPv4AddressStringParameters o) {
		int result = super.compareTo(o);
		if(result == 0) {
			result = Boolean.compare(inet_aton_hex, o.inet_aton_hex);
			if(result == 0) {
				result = Boolean.compare(inet_aton_octal, o.inet_aton_octal);
				if(result == 0) {
					result = Boolean.compare(inet_aton_joinedSegments, o.inet_aton_joinedSegments);
					if(result == 0) {
						result = Boolean.compare(inet_aton_leading_zeros, o.inet_aton_leading_zeros);
						if(result == 0) {
							result = Boolean.compare(inet_aton_single_segment_mask, o.inet_aton_single_segment_mask);
							if(result == 0) {
								result = Boolean.compare(inet_aton_extraneous_digits, o.inet_aton_extraneous_digits);
							}
						}
					}
				}
			}
		}
		return result;
	}
	@Override
	public boolean equals(Object o) {
		if(o instanceof IPv4AddressStringParameters) {
			if(super.equals(o)) {
				IPv4AddressStringParameters other = (IPv4AddressStringParameters) o;
				return inet_aton_hex == other.inet_aton_hex
						&& inet_aton_octal == other.inet_aton_octal
						&& inet_aton_joinedSegments == other.inet_aton_joinedSegments
						&& inet_aton_leading_zeros == other.inet_aton_leading_zeros
						&& inet_aton_single_segment_mask == other.inet_aton_single_segment_mask
						&& inet_aton_extraneous_digits == other.inet_aton_extraneous_digits;
				}
		}
		return false;
	}
	@Override
	public int hashCode() {
		int hash = super.hashCode();
		if(inet_aton_hex) {
			hash |= 0x40;
		}
		if(inet_aton_octal) {
			hash |= 0x80;
		}
		if(inet_aton_joinedSegments) {
			hash |= 0x100;
		}
		return hash;
	}
}
package inet.ipaddr;
import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.InterfaceAddress;
import java.net.UnknownHostException;
import java.util.Objects;
import java.util.function.Function;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.format.validate.HostIdentifierStringValidator;
import inet.ipaddr.format.validate.ParsedHost;
import inet.ipaddr.format.validate.ParsedHostIdentifierStringQualifier;
import inet.ipaddr.format.validate.Validator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
public class HostName implements HostIdentifierString, Comparable<HostName> {
	private static final long serialVersionUID = 4L;
	private static  IPAddress EMPTY_ADDRS[] = new IPAddress[0];
	public static final char LABEL_SEPARATOR = '.';
	public static final char IPV6_START_BRACKET = '[', IPV6_END_BRACKET = ']';
	public static final char PORT_SEPARATOR = ':';
	public static final HostNameParameters DEFAULT_VALIDATION_OPTIONS = new HostNameParameters.Builder().toParams();
	private static final HostNameParameters DEFAULT_SOCKET_ADDR_VALIDATION_OPTIONS = DEFAULT_VALIDATION_OPTIONS.toBuilder().expectPort(true).toParams();
	private final String host;
	private transient String normalizedString, normalizedWildcardString;
	private ParsedHost parsedHost;
	private HostNameException validationException;
	IPAddress resolvedAddresses[];
	final HostNameParameters validationOptions;
	public HostName(IPAddress addr) {
		host = addr.toNormalizedString();
		parsedHost = new ParsedHost(host, addr.getProvider());
		validationOptions = null;
	}
	public HostName(IPAddress addr, int port) {
		ParsedHostIdentifierStringQualifier qualifier = new ParsedHostIdentifierStringQualifier(null, port);
		host = toNormalizedString(addr, port);
		parsedHost = new ParsedHost(host, addr.getProvider(), qualifier);
		validationOptions = null;
	}
	public HostName(InetSocketAddress inetSocketAddr) {
		if(!inetSocketAddr.isUnresolved()) {
			resolvedAddresses = new IPAddress[] {toIPAddress(inetSocketAddr.getAddress(), IPAddressString.DEFAULT_VALIDATION_OPTIONS)};
		}
		int port = inetSocketAddr.getPort();
		String hostStr = inetSocketAddr.getHostString().trim();
		StringBuilder builder = new StringBuilder(hostStr.length() + 6); 
		toNormalizedString(port, builder.append(hostStr));
		host = builder.toString();
		validationOptions = DEFAULT_SOCKET_ADDR_VALIDATION_OPTIONS; 
	}
	public HostName(InetAddress inetAddr, Integer prefixLength) {
		this(toIPAddress(inetAddr, IPAddressString.DEFAULT_VALIDATION_OPTIONS, prefixLength));
	}
	public HostName(InterfaceAddress interfaceAddr) {
		this(interfaceAddr.getAddress(), IPAddressNetwork.cacheBits(interfaceAddr.getNetworkPrefixLength()));
	}
	public HostName(InetAddress inetAddr) {
		this(inetAddr, IPAddressString.DEFAULT_VALIDATION_OPTIONS);
	}
	public HostName(InetAddress inetAddr, IPAddressStringParameters addressOptions) {
		this(toIPAddress(inetAddr, addressOptions));
	}
	private static IPAddress toIPAddress(InetAddress inetAddr, IPAddressStringParameters addressOptions) {
		return inetAddr instanceof Inet4Address ?
				addressOptions.getIPv4Parameters().getNetwork().getAddressCreator().createAddress((Inet4Address) inetAddr) :
				addressOptions.getIPv6Parameters().getNetwork().getAddressCreator().createAddress((Inet6Address) inetAddr);
	}
	private static IPAddress toIPAddress(InetAddress inetAddr, IPAddressStringParameters addressOptions, Integer prefixLength) {
		return inetAddr instanceof Inet4Address ?
				addressOptions.getIPv4Parameters().getNetwork().getAddressCreator().createAddress((Inet4Address) inetAddr, prefixLength) :
				addressOptions.getIPv6Parameters().getNetwork().getAddressCreator().createAddress((Inet6Address) inetAddr, prefixLength);
	}
	HostName(String hostStr, ParsedHost parsed) {
		host = hostStr;
		parsedHost = parsed;
		validationOptions = null;
	}
	public HostName(String host) {
		this(host, DEFAULT_VALIDATION_OPTIONS);
	}
	public HostName(String host, HostNameParameters options) {
		if(options == null) {
			throw new NullPointerException();
		}
		validationOptions = options;
		this.host = (host == null) ? "" : host.trim();
	}
	void cacheAddress(IPAddress addr) {
		if(parsedHost == null) {
			parsedHost = new ParsedHost(host, addr.getProvider());
		}
	}
	public HostNameParameters getValidationOptions() {
		return validationOptions;
	}
	@Override
	public void validate() throws HostNameException {
		if(parsedHost != null) {
			return;
		}
		if(validationException != null) {
			throw validationException;
		}
		synchronized(this) {
			if(parsedHost != null) {
				return;
			} else if(validationException != null) {
				throw validationException;
			}
			try {
				parsedHost = getValidator().validateHost(this);
			} catch(HostNameException e) {
				validationException = e;
				throw e;
			}
		}
	}
	protected HostIdentifierStringValidator getValidator() {
		return Validator.VALIDATOR;
	}
	public boolean isValid() {
		if(parsedHost != null) {
			return true;
		} else if(validationException != null) {
			return false;
		}
		try {
			validate();
			return true;
		} catch(HostNameException e) {
			return false;
		}
	}
	public boolean resolvesToSelf() {
		return isSelf() || (getAddress() != null && resolvedAddresses[0].isLoopback());
	}
	public boolean isSelf() {
		return isLocalHost() || isLoopback();
	}
	public boolean isLocalHost() {
		return isValid() && host.equalsIgnoreCase("localhost");
	}
	public boolean isLoopback() {
		return isAddress() && asAddress().isLoopback();
	}
	public InetAddress toInetAddress() throws HostNameException, UnknownHostException {
		validate();
		return toAddress().toInetAddress();
	}
	@Override
	public String toNormalizedString() {
		String result = normalizedString;
		if(result == null) {
			normalizedString = result = toNormalizedString(false);
		}
		return result;
	}
	private String toNormalizedWildcardString() {
		String result = normalizedWildcardString;
		if(result == null) {
			normalizedWildcardString = result = toNormalizedString(true);
		}
		return result;
	}
	private static void translateReserved(IPv6Address addr, String str, StringBuilder builder) {
		if(!addr.hasZone()) {
			builder.append(str);
			return;
		}
		int index = str.indexOf(IPv6Address.ZONE_SEPARATOR);
		StringBuilder translated = builder;
		translated.append(str, 0, index);
		translated.append("%25");
		for(int i = index + 1; i < str.length(); i++) {
			char c = str.charAt(i);
			if(Validator.isReserved(c)) {
				translated.append('%');
				IPAddressSegment.toUnsignedString(c, 16, translated);
			} else {
				translated.append(c);
			}
		}
		return;
	}
	private static String toNormalizedString(IPAddress addr, int port) {
		StringBuilder builder = new StringBuilder();
		toNormalizedString(addr, false, builder);
		toNormalizedString(port, builder);
		return builder.toString();
	}
	private String toNormalizedString(boolean wildcard) {
		if(isValid()) {
			StringBuilder builder = new StringBuilder();
			if(isAddress()) {
				toNormalizedString(asAddress(), wildcard, builder);
			} else if(isAddressString()) {
				builder.append(asAddressString().toNormalizedString());
			} else {
				builder.append(parsedHost.getHost());
				Integer networkPrefixLength = parsedHost.getEquivalentPrefixLength();
				if(networkPrefixLength != null) {
					builder.append(IPAddress.PREFIX_LEN_SEPARATOR);
					IPAddressSegment.toUnsignedString(networkPrefixLength, 10, builder);
				} else {
					IPAddress mask = parsedHost.getMask();
					if(mask != null) {
						builder.append(IPAddress.PREFIX_LEN_SEPARATOR).append(mask.toNormalizedString());
					}
				}
			}
			Integer port = parsedHost.getPort();
			if(port != null) {
				toNormalizedString(port, builder);
			} else {
				String service = parsedHost.getService();
				if(service != null) {
					builder.append(PORT_SEPARATOR).append(service);
				}
			}
			return builder.toString();
		}
		return host;
	}
	private static void toNormalizedString(int port, StringBuilder builder) {
		builder.append(PORT_SEPARATOR);
		IPAddressSegment.toUnsignedString(port, 10, builder);
	}
	private static void toNormalizedString(IPAddress addr, boolean wildcard, StringBuilder builder) {
		if(addr.isIPv6()) {
			if(!wildcard && addr.isPrefixed()) {
				builder.append(IPV6_START_BRACKET);
				String normalized = addr.toNormalizedString();
				int index = normalized.indexOf(IPAddress.PREFIX_LEN_SEPARATOR);
				translateReserved(addr.toIPv6(), normalized.substring(0, index), builder);
				builder.append(IPV6_END_BRACKET).append(normalized.substring(index));
			} else {
				builder.append(IPV6_START_BRACKET);
				translateReserved(addr.toIPv6(), addr.toNormalizedWildcardString(), builder);
				builder.append(IPV6_END_BRACKET);
			}
		} else {
			builder.append(wildcard ? addr.toNormalizedWildcardString() : addr.toNormalizedString());
		}
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof HostName && matches((HostName) o);
	}
	@Override
	public int hashCode() {
		return toNormalizedWildcardString().hashCode();
	}
	public String[] getNormalizedLabels() {
		if(isValid()) {
			return parsedHost.getNormalizedLabels();
		} else if(host.length() == 0) {
			return new String[0];
		}
		return new String[] {host};
	}
	public String getHost() {
		if(isValid()) {
			return parsedHost.getHost();
		}
		return null;
	}
	public boolean matches(HostName host) {
		if(this == host) {
			return true;
		}
		if(isValid()) {
			if(host.isValid()) {
				ParsedHost parsedHost = this.parsedHost;
				ParsedHost otherParsedHost = host.parsedHost;
				if(parsedHost.isAddressString()) {
					return otherParsedHost.isAddressString()
							&& parsedHost.asGenericAddressString().equals(otherParsedHost.asGenericAddressString())
							&& Objects.equals(parsedHost.getPort(), otherParsedHost.getPort())
							&& Objects.equals(parsedHost.getService(), otherParsedHost.getService());
				}
				if(otherParsedHost.isAddressString()) {
					return false;
				}
				String thisHost = parsedHost.getHost();
				String otherHost = otherParsedHost.getHost();
				if(!thisHost.equals(otherHost)) {
					return false;
				}
				return Objects.equals(parsedHost.getEquivalentPrefixLength(), otherParsedHost.getEquivalentPrefixLength()) &&
						Objects.equals(parsedHost.getMask(), otherParsedHost.getMask()) &&
						Objects.equals(parsedHost.getPort(), otherParsedHost.getPort()) &&
						Objects.equals(parsedHost.getService(), otherParsedHost.getService());
			}
			return false;
		}
		return !host.isValid() && toString().equals(host.toString());
	}
	@Override
	public int compareTo(HostName other) {
		if(isValid()) {
			if(other.isValid()) {
				ParsedHost parsedHost = this.parsedHost;
				ParsedHost otherParsedHost = other.parsedHost;
				if(parsedHost.isAddressString()) {
					if(otherParsedHost.isAddressString()) {
						int result = parsedHost.asGenericAddressString().compareTo(otherParsedHost.asGenericAddressString());
						if(result != 0) {
							return result;
						}
					} else {
						return -1;
					}
				} else if(otherParsedHost.isAddressString()) {
					return 1;
				} else {
					String normalizedLabels[] = parsedHost.getNormalizedLabels();
					String otherNormalizedLabels[] = otherParsedHost.getNormalizedLabels();
					int oneLen = normalizedLabels.length;
					int twoLen = otherNormalizedLabels.length;
					for(int i = 1, minLen = Math.min(oneLen, twoLen); i <= minLen; i++) {
						String one = normalizedLabels[oneLen - i];
						String two = otherNormalizedLabels[twoLen - i];
						int result = one.compareTo(two);
						if(result != 0) {
							return result;
						}
					}
					if(oneLen != twoLen) {
						return oneLen - twoLen;
					}
					Integer networkPrefixLength = parsedHost.getEquivalentPrefixLength();
					Integer otherPrefixLength = otherParsedHost.getEquivalentPrefixLength();
					if(networkPrefixLength != null) {
						if(otherPrefixLength != null) {
							if(networkPrefixLength.intValue() != otherPrefixLength.intValue()) {
								return otherPrefixLength - networkPrefixLength;
							}
						} else {
							return 1;
						}
					} else {
						if(otherPrefixLength != null) {
							return -1;
						}
						IPAddress mask = parsedHost.getMask();
						IPAddress otherMask = otherParsedHost.getMask();
						if(mask != null) {
							if(otherMask != null) {
								int ret = mask.compareTo(otherMask);
								if(ret != 0) {
									return ret;
								}
							} else {
								return 1;
							}
						} else {
							if(otherMask != null) {
								return -1;
							}
						}
					}
				}
				Integer portOne = parsedHost.getPort();
				Integer portTwo = otherParsedHost.getPort();
				if(portOne != null) {
					if(portTwo != null) {
						int ret = portOne - portTwo;
						if(ret != 0) {
							return ret;
						}
					} else {
						return 1;
					}
				} else if(portTwo != null) {
					return -1;
				}
				String serviceOne = parsedHost.getService();
				String serviceTwo = otherParsedHost.getService();
				if(serviceOne != null) {
					if(serviceTwo != null) {
						int ret = serviceOne.compareTo(serviceTwo);
						if(ret != 0) {
							return ret;
						}
					} else {
						return 1;
					}
				} else if(serviceTwo != null) {
					return -1;
				}
				return 0;
			} else {
				return 1;
			}
		} else if(other.isValid()) {
			return -1;
		}
		return toString().compareTo(other.toString());
	}
	@Deprecated
	public boolean isAddress(IPVersion version) {
		return isValid() && parsedHost.isAddressString() && parsedHost.asAddress(version) != null;
	}
	public boolean isAddress() {
		return isAddressString() && parsedHost.asAddress() != null; 
	}
	public boolean isAddressString() {
		return isValid() && parsedHost.isAddressString();
	}
	public boolean isAllAddresses() {
		return isAddressString() && parsedHost.getAddressProvider().isProvidingAllAddresses();
	}
	public boolean isPrefixOnly() {
		return isAddressString() && parsedHost.getAddressProvider().isProvidingPrefixOnly();
	}
	public boolean isEmpty() {
		return isAddressString() && parsedHost.getAddressProvider().isProvidingEmpty();
	}
	public Integer getPort() {
		return isValid() ? parsedHost.getPort() : null;
	}
	public String getService() {
		return isValid() ? parsedHost.getService() : null;
	}
	public AddressStringException getAddressStringException() {
		if(isValid()) {
			return parsedHost.getAddressStringException();
		}
		return null;
	}
	public boolean isUNCIPv6Literal() {
		return isValid() && parsedHost.isUNCIPv6Literal();
	}
	public boolean isReverseDNS() {
		return isValid() && parsedHost.isReverseDNS();
	}
	public IPAddressString asAddressString() {
		if(isAddressString()) {
			return parsedHost.asGenericAddressString(); 
		}
		return null;
	}
	public IPAddress asAddress() {
		if(isAddress()) {
			return parsedHost.asAddress();
		}
		return null;
	}
	@Deprecated
	public IPAddress asAddress(IPVersion version) {
		if(isAddress(version)) {
			return parsedHost.asAddress(version);
		}
		return null;
	}
	public Integer getNetworkPrefixLength() {
		if(isAddress()) {
			return parsedHost.asAddress().getNetworkPrefixLength();
		} else if(isAddressString()) {
			return parsedHost.asGenericAddressString().getNetworkPrefixLength();
		}
		return isValid() ? parsedHost.getEquivalentPrefixLength() : null;
	}
	public IPAddress getMask() {
		if(isValid()) {
			if(parsedHost.isAddressString()) {
				return parsedHost.getAddressProvider().getProviderMask();
			}
			return parsedHost.getMask();
		}
		return null;
	}
	public InetAddress asInetAddress() {
		if(isValid() && isAddressString()) {
			IPAddress ipAddr = asAddress();
            if(ipAddr != null) {
            	return ipAddr.toInetAddress();
            }
		}
		return null;
	}
	public InetSocketAddress asInetSocketAddress(Function<String, Integer> serviceMapper) {
		if(isValid()) {
			Integer port = getPort();
			if(port == null && serviceMapper != null) {
				String service = getService();
				if(service != null) {
					port = serviceMapper.apply(service);
				}
			}
			if(port != null) {
				IPAddress ipAddr;
				if(isAddressString() && (ipAddr = asAddress()) != null) {
					return new InetSocketAddress(ipAddr.toInetAddress(), port);
				} else {
					return new InetSocketAddress(getHost(), port);
				}
			}
		}
		return null;
	}
	public InetSocketAddress asInetSocketAddress() {
		return asInetSocketAddress(null);
	}
	public IPAddress[] toAllAddresses() throws UnknownHostException, HostNameException {
		return toAddresses();
	}
	@Override
	public IPAddress toAddress() throws UnknownHostException, HostNameException {
		IPAddress addrs[] = toAddresses();
		return addrs.length == 0 ? null : addrs[0];
	}
	private IPAddress[] toAddresses() throws UnknownHostException, HostNameException {
		IPAddress addrs[] = resolvedAddresses;
		if(addrs == null) {
			validate();
			synchronized(this) {
				addrs = resolvedAddresses;
				if(addrs == null) {
					if(parsedHost.isAddressString()) {
						addrs = new IPAddress[] {parsedHost.asAddress()};
					} else {
						String strHost = parsedHost.getHost();
						if(strHost.length() == 0 && !validationOptions.emptyIsLoopback) {
							addrs = EMPTY_ADDRS;
						} else {
							InetAddress inetAddresses[] = InetAddress.getAllByName(strHost);
							addrs = new IPAddress[inetAddresses.length];
							for(int j = 0; j < inetAddresses.length; j++) {
								InetAddress inetAddress = inetAddresses[j];
								byte bytes[] = inetAddress.getAddress();
								Integer networkPrefixLength = parsedHost.getNetworkPrefixLength();
								if(networkPrefixLength == null) {
									IPAddress mask = parsedHost.getMask();
									if(mask != null) {
										byte maskBytes[] = mask.getBytes();
										if(maskBytes.length == bytes.length) {
											for(int i = 0; i < bytes.length; i++) {
												bytes[i] &= maskBytes[i];
											}
											networkPrefixLength = mask.getBlockMaskPrefixLength(true);
										}
									}
								}
								IPAddressStringParameters addressParams = validationOptions.addressOptions;
								if(bytes.length == IPv6Address.BYTE_COUNT) {
									IPv6AddressCreator creator = addressParams.getIPv6Parameters().getNetwork().getAddressCreator();
									addrs[j] = creator.createAddressInternal(bytes, networkPrefixLength, null, this); 
								} else {
									if(networkPrefixLength != null && networkPrefixLength > IPv4Address.BIT_COUNT) {
										networkPrefixLength = IPAddressSection.cacheBits(IPv4Address.BIT_COUNT);
									}
									IPv4AddressCreator creator = addressParams.getIPv4Parameters().getNetwork().getAddressCreator();
									addrs[j] = creator.createAddressInternal(bytes, networkPrefixLength, this); 
								}
							}
						}
					}
					resolvedAddresses = addrs;
				}
			}
		}
		return addrs;
	}
	@Override
	public IPAddress getAddress() {
		try {
			return toAddress();
		} catch(HostNameException | UnknownHostException e) {
		}
		return null;
	}
	@Override
	public String toString() {
		return host;
	}
}
package inet.ipaddr.ipv6;
import java.io.Serializable;
import java.math.BigInteger;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressPositionException;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressConverter;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.validate.Validator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4Address.IPv4AddressConverter;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6AddressCache;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringBuilderOptions;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCache;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCollection;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringOptions;
import inet.ipaddr.ipv6.IPv6AddressTrie.IPv6TrieNode.IPv6TrieKeyData;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
import inet.ipaddr.mac.MACAddressNetwork.MACAddressCreator;
import inet.ipaddr.mac.MACAddressSection;
import inet.ipaddr.mac.MACAddressSegment;
public class IPv6Address extends IPAddress implements Iterable<IPv6Address> {
	private static final long serialVersionUID = 4L;
	public static final char SEGMENT_SEPARATOR = ':';
	public static final char ZONE_SEPARATOR = '%';
	public static final char ALTERNATIVE_ZONE_SEPARATOR = '\u00a7';
	public static final char UNC_SEGMENT_SEPARATOR = '-';
	public static final char UNC_ZONE_SEPARATOR = 's';
	public static final char UNC_RANGE_SEPARATOR = ALTERNATIVE_RANGE_SEPARATOR;
	public static final String UNC_RANGE_SEPARATOR_STR = String.valueOf(UNC_RANGE_SEPARATOR);
	public static final String UNC_SUFFIX = ".ipv6-literal.net";
	public static final String REVERSE_DNS_SUFFIX = ".ip6.arpa";
	public static final String REVERSE_DNS_SUFFIX_DEPRECATED = ".ip6.int";
	public static final int BITS_PER_SEGMENT = 16;
	public static final int BYTES_PER_SEGMENT = 2;
	public static final int SEGMENT_COUNT = 8;
	public static final int MIXED_REPLACED_SEGMENT_COUNT = 2; 
	public static final int MIXED_ORIGINAL_SEGMENT_COUNT = 6; 
	public static final int BYTE_COUNT = 16;
	public static final int BIT_COUNT = 128;
	public static final int DEFAULT_TEXTUAL_RADIX = 16;
	public static final int BASE_85_RADIX = 85;
	public static final int MAX_VALUE_PER_SEGMENT = 0xffff;
	private final IPv6Zone zone;
	public static class IPv6Zone implements Serializable {
		private static final long serialVersionUID = 1L;
		String zoneStr;
		private int scopeId;
		private transient NetworkInterface networkInterface;
		private Boolean referencesInterface;
		public IPv6Zone(String zoneStr) {
			if(zoneStr == null) {
				throw new NullPointerException();
			}
			this.zoneStr = zoneStr.trim();
			scopeId = -1;
		}
		public IPv6Zone(int scopeId) {
			if(scopeId < 0) {
				throw new IllegalArgumentException();
			}
			this.scopeId = scopeId;
			referencesInterface = Boolean.FALSE;
		}
		public IPv6Zone(NetworkInterface networkInterface) {
			if(networkInterface == null) {
				throw new NullPointerException();
			}
			this.networkInterface = networkInterface;
			referencesInterface = Boolean.TRUE;
			scopeId = -1;
			zoneStr = networkInterface.getName();
		}
		public boolean referencesIntf() {
			if(referencesInterface == null) {
				scopeId = checkIfScope(zoneStr);
				referencesInterface = scopeId < 0;
			}
			return referencesInterface;
		}
		public boolean referencesScopeId() {
			return !referencesIntf();
		}
		public NetworkInterface getAssociatedIntf() {
			try {
				if(referencesIntf()) {
					if(networkInterface == null) {
						networkInterface = NetworkInterface.getByName(zoneStr);
					}
				} else {
					if(networkInterface == null) {
						Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
						top:
						while(interfaces.hasMoreElements()) {
							NetworkInterface nif = interfaces.nextElement();
							Enumeration<InetAddress> addrs = nif.getInetAddresses();
							while(addrs.hasMoreElements()) {
								InetAddress addr = addrs.nextElement();
								if(addr instanceof Inet6Address) {
									Inet6Address inetAddr = (Inet6Address) addr;
									if(inetAddr.getScopeId() == scopeId) {
										networkInterface = nif;
										break top;
									}
								}
							}
						}
					}
				}
			} catch(SocketException e) {}
			return networkInterface;
		}
		public MACAddress getAssociatedIntfMacAddr() {
			NetworkInterface intf = getAssociatedIntf();
			try {
				if(intf != null) {
					byte bytes[] = intf.getHardwareAddress();
					if(bytes != null) {
						return new MACAddress(bytes);
					}
				}
			} catch(SocketException e) {}
			return null;
		}
		public int getAssociatedScopeId() {
			if(referencesIntf()) {
				if(scopeId == -1) {
					NetworkInterface nif = getAssociatedIntf();
					if(nif != null) {
						Enumeration<InetAddress> addrs = nif.getInetAddresses();
						int newScopeId = -1;
						while(addrs.hasMoreElements()) {
							InetAddress addr = addrs.nextElement();
							if(addr instanceof Inet6Address) {
								Inet6Address inetAddr = (Inet6Address) addr;
								int sid = inetAddr.getScopeId();
								if(sid != 0) {
									if(newScopeId != -1 && sid != newScopeId) {
										newScopeId = -1;
										break;
									}
									newScopeId = sid;
								}
							}
						}
						if(newScopeId != -1) {
							this.scopeId = newScopeId;
						}
					}
				}
			}
			return scopeId;
		}
		@Override
		public int hashCode() {
			return toString().hashCode();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv6Zone && toString().equals(o.toString());
		}
		public String getName() {
			if(zoneStr == null) {
				if(referencesIntf()) {
					zoneStr = networkInterface.getName();
				} else {
					zoneStr = IPv6AddressSegment.toUnsignedString(scopeId, 10,
							new StringBuilder(IPv6AddressSegment.toUnsignedStringLength(scopeId, 10))).toString();
				}
			}
			return zoneStr;
		}
		@Override
		public String toString() {
			return getName();
		}
		static int checkIfScope(String zoneStr) {
			long digits = 0;
			for(int i = 0, len = zoneStr.length(); i < len; i++) {
				char c = zoneStr.charAt(i);
				int digit = Character.digit(c, 10);
				if(digit < 0) {
					return -1;
				}
				digits = (digits * 10) + digit;
				if(digits > Integer.MAX_VALUE) {
					return -1;
				}
			}
			return (int) digits;
		}
	}
	private transient IPv6StringCache stringCache;
	private transient IPv6TrieKeyData cachedTrieKeyData;
	transient IPv6AddressCache addressCache;
	IPv6Address(IPv6AddressSection section, CharSequence zone, boolean checkZone) throws AddressValueException {
		this(section, checkZone ? 
					checkZone(zone) : 
					(zone != null && zone.length() > 0 ? 
							new IPv6Zone(zone.toString()) :
							null));
	}
	public IPv6Address(IPv6AddressSection section, IPv6Zone zone) throws AddressValueException {
		super(section);
		if(section.getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv6.invalid.segment.count", section.getSegmentCount());
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section.addressSegmentIndex);
		}
		this.zone = zone;
	}
	@Deprecated
	public IPv6Address(IPv6AddressSection section, CharSequence zone) throws AddressValueException {
		this(section, zone, true);
	}
	public IPv6Address(IPv6AddressSection section) throws AddressValueException {
		this(section, (CharSequence) null);
	}
	public IPv6Address(IPv6AddressSegment[] segments) throws AddressValueException {
		this(segments, null, null);
	}
	public IPv6Address(IPv6AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		this(segments, networkPrefixLength, null);
	}
	@Deprecated
	public IPv6Address(IPv6AddressSegment[] segments, CharSequence zone) throws AddressValueException {
		this(segments, checkZone(zone));
	}
	public IPv6Address(IPv6AddressSegment[] segments, IPv6Zone zone) throws AddressValueException {
		this(segments, null, zone);
	}
	private IPv6Address(IPv6AddressSegment[] segments, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(segments, networkPrefixLength));
		if(segments.length != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv6.invalid.segment.count", segments.length);
		}
		this.zone = zone;
	}
	public IPv6Address(Inet6Address inet6Address) {
		this(inet6Address, inet6Address.getAddress(), null, getZone(inet6Address));
	}
	public IPv6Address(Inet6Address inet6Address, Integer networkPrefixLength) {
		this(inet6Address, inet6Address.getAddress(), networkPrefixLength, getZone(inet6Address));
	}
	private IPv6Address(Inet6Address inet6Address, byte[] bytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(bytes, 0, bytes.length, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
		getSection().setInetAddress(inet6Address);
	}
	@Deprecated
	public IPv6Address(byte[] bytes, CharSequence zone) throws AddressValueException {
		this(bytes, checkZone(zone));
	}
	public IPv6Address(byte[] bytes, IPv6Zone zone) throws AddressValueException {
		this(bytes, null, zone);
	}
	public IPv6Address(byte[] bytes) throws AddressValueException {
		this(bytes, null, null);
	}
	public IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, null, null);
	}
	public IPv6Address(byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, networkPrefixLength, null);
	}
	public IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, networkPrefixLength, null);
	}
	public IPv6Address(BigInteger val) throws AddressValueException {
		this(val, null, (IPv6Zone) null);
	}
	public IPv6Address(BigInteger val, Integer networkPrefixLength) throws AddressValueException {
		this(val, networkPrefixLength, (IPv6Zone) null);
	}
	@Deprecated
	public IPv6Address(BigInteger val, CharSequence zone) throws AddressValueException {
		this(val, checkZone(zone));
	}
	public IPv6Address(BigInteger val, IPv6Zone zone) throws AddressValueException {
		this(val, null, zone);
	}
	@Deprecated
	public IPv6Address(BigInteger val, Integer networkPrefixLength, CharSequence zone) throws AddressValueException {	
		this(val, networkPrefixLength, checkZone(zone));
	}
	public IPv6Address(BigInteger val, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {	
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSectionInternal(val.toByteArray(), IPv6Address.SEGMENT_COUNT, networkPrefixLength, false));
		this.zone = zone;
	}
	private IPv6Address(byte[] bytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		this(bytes, 0, bytes.length, networkPrefixLength, zone);
	}
	private IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(bytes, byteStartIndex, byteEndIndex, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
	}
	public IPv6Address(long highBytes, long lowBytes, IPv6Zone zone) throws AddressValueException {
		this(highBytes, lowBytes, null, zone);
	}
	public IPv6Address(long highBytes, long lowBytes) throws AddressValueException {
		this(highBytes, lowBytes, null, null);
	}
	public IPv6Address(long highBytes, long lowBytes, Integer networkPrefixLength) throws AddressValueException {
		this(highBytes, lowBytes, networkPrefixLength, null);
	}
	private IPv6Address(long highBytes, long lowBytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(highBytes, lowBytes, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
	}
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, networkPrefixLength, null);
	}
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, null, null);
	}
	public IPv6Address(SegmentValueProvider valueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, networkPrefixLength);
	}
	public IPv6Address(SegmentValueProvider valueProvider) {
		this(valueProvider, (Integer) null);
	}
	@Deprecated
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, CharSequence zone) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, checkZone(zone));
	}
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, IPv6Zone zone) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, null, zone);
	}
	private IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createFullSectionInternal(lowerValueProvider, upperValueProvider, networkPrefixLength));
		this.zone = zone;
	}
	public IPv6Address(IPv6Address prefix, MACAddress eui) throws IncompatibleAddressException {
		this(prefix.getSection(), eui.getSection());
	}
	public IPv6Address(IPv6AddressSection section, MACAddress eui) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui.getSection());
	}
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui, (IPv6Zone) null);
	}
	@Deprecated
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui, CharSequence zone) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui, checkZone(zone));
	}
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui, IPv6Zone zone) throws IncompatibleAddressException, AddressValueException  {
		super(thisAddress -> toFullEUI64Section(section, eui, ((IPv6Address) thisAddress).getDefaultCreator(), ((IPv6Address) thisAddress).getMACNetwork().getAddressCreator()));
		this.zone = zone;
	}
	static IPv6Zone checkZone(CharSequence zone) throws AddressValueException {
		if(zone == null) {
			return null;
		}
		String zoneStr = zone.toString().trim();
		if(zone.length() == 0) {
			return null;
		}
		int invalidIndex = Validator.validateZone(zoneStr);
		if(invalidIndex >= 0) {
			throw new AddressValueException("ipaddress.error.invalid.zone", invalidIndex);
		}
		return new IPv6Zone(zoneStr);
	}
	IPv6AddressCreator getDefaultCreator() {
		return getNetwork().getAddressCreator();
	}
	IPv6AddressCreator getCreator() {
		IPv6AddressCreator defaultCreator = getDefaultCreator();
		if(!hasZone()) {
			return defaultCreator;
		}
		IPv6AddressCreator creator = new IPv6AddressCreator(getNetwork(), defaultCreator.cache) {
			private static final long serialVersionUID = 4L;
			@Override
			protected IPv6Address createAddressInternal(IPv6AddressSegment segments[]) {
				IPv6AddressCreator creator = getDefaultCreator();
				return creator.createAddress(segments, zone); 
			}
			@Override
			public IPv6Address createAddress(IPv6AddressSection section) {
				IPv6AddressCreator creator = getDefaultCreator();
				return creator.createAddress(section, zone); 
			}
		};
		creator.useSegmentCache = defaultCreator.useSegmentCache;
		return creator;
	}
	private static IPv6Zone getZone(Inet6Address inet6Address) {
		NetworkInterface networkInterface = inet6Address.getScopedInterface();
		if(networkInterface != null) {
			return new IPv6Zone(networkInterface);
		}
		int scopeId = inet6Address.getScopeId();
		if(scopeId != 0) {
			return new IPv6Zone(scopeId);
		}
		return null;
	}
	private static IPv6AddressSection toFullEUI64Section(IPv6AddressSection section, MACAddressSection eui, IPv6AddressCreator creator, MACAddressCreator macCreator) throws AddressValueException, IncompatibleAddressException {
		boolean euiIsExtended = eui.isExtended();
		if(eui.addressSegmentIndex != 0) {
			throw new AddressPositionException(eui, eui.addressSegmentIndex);
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section, section.addressSegmentIndex);
		}
		if(section.getSegmentCount() < 4) {
			throw new AddressValueException(section, "ipaddress.mac.error.not.eui.convertible");
		}
		if(eui.getSegmentCount() != (euiIsExtended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT)) {
			throw new AddressValueException(eui, "ipaddress.mac.error.not.eui.convertible");
		}
		IPv6AddressSegment segments[] = creator.createSegmentArray(8);
		section.getSegments(0, 4, segments, 0);
		Integer prefLength = section.getNetworkPrefixLength();
		Integer prefixLength = prefLength != null && (prefLength <= 64) ? prefLength : null;
		toEUI64Segments(segments, 4, eui, 0, eui.isExtended(), creator, macCreator, prefixLength);
		return creator.createSectionInternal(segments);
	}
	static IPv6AddressSegment[] toEUI64Segments(
			IPv6AddressSegment segments[],
			int ipv6StartIndex,
			MACAddressSection eui,
			int euiStartIndex,
			boolean isExtended,
			IPv6AddressCreator creator,
			MACAddressCreator macCreator,
			Integer prefixLength) 
					throws IncompatibleAddressException {
		int euiSegmentIndex = 0;
		int euiSegmentCount = eui.getSegmentCount();
		MACAddressSegment seg0, seg1, seg2, seg3, seg4, seg5, seg6, seg7;
		seg0 = (euiStartIndex == 0 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg1 = (euiStartIndex <= 1 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg2 = (euiStartIndex <= 2 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg3 = (euiStartIndex <= 3 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg4 = (euiStartIndex <= 4 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg5 = (euiStartIndex <= 5 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg6 = (euiStartIndex <= 6 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg7 = (euiStartIndex <= 7 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex) : null;
		boolean isNotNull;
		MACAddressSegment zeroSegment = macCreator.createSegment(0);
		MACAddressSegment ffSegment = macCreator.createSegment(0xff);
		MACAddressSegment feSegment = macCreator.createSegment(0xfe);
		Integer currentPrefix = null;
		if(prefixLength != null) {
			currentPrefix = 0;
		}
		if((isNotNull = (seg0 != null)) || seg1 != null) {
			if(isNotNull) {
				if(seg1 == null) {
					seg1 = zeroSegment;
				}
			} else {
				seg0 = zeroSegment;
			}
			segments[ipv6StartIndex++] = join(creator, seg0, seg1, true , currentPrefix);
		}
		if(isExtended) {
			if((isNotNull = (seg2 != null)) || seg3 != null) {
				if(!isNotNull) {
					seg2 = zeroSegment;
					if(!seg3.matches(0xff)) {
						throw new IncompatibleAddressException(eui, "ipaddress.mac.error.not.eui.convertible");
					}
				}
				segments[ipv6StartIndex++] = join(creator, seg2, ffSegment, currentPrefix);
			}
			if((isNotNull = (seg4 != null)) || seg5 != null) {
				if(isNotNull) {
					if(!seg4.matches(0xfe)) {
						throw new IncompatibleAddressException(eui, "ipaddress.mac.error.not.eui.convertible");
					}
					if(seg5 == null) {
						seg5 = zeroSegment;
					}
				}
				segments[ipv6StartIndex++] = join(creator, feSegment, seg5, currentPrefix);
			}
		} else {
			if(seg2 != null) {
				segments[ipv6StartIndex++] = join(creator, seg2, ffSegment, currentPrefix);
			}
			if(seg3 != null) {
				segments[ipv6StartIndex++] = join(creator, feSegment, seg3, currentPrefix);
			}
			if((isNotNull = (seg4 != null)) || seg5 != null) {
				if(isNotNull) {
					if(seg5 == null) {
						seg5 = zeroSegment;
					}
				} else {
					seg4 = zeroSegment;
				}
				segments[ipv6StartIndex++] = join(creator, seg4, seg5, currentPrefix);
			}
		}
		if((isNotNull = (seg6 != null)) || seg7 != null) {
			if(isNotNull) {
				if(seg7 == null) {
					seg7 = zeroSegment;
				}
			} else {
				seg6 = zeroSegment;
			}
			segments[ipv6StartIndex] = join(creator, seg6, seg7, currentPrefix);
		}
		return segments;
	} 
	private static IPv6AddressSegment join(IPv6AddressCreator creator, MACAddressSegment macSegment0, MACAddressSegment macSegment1, Integer prefixLength) {
		return join(creator, macSegment0, macSegment1, false, prefixLength);
	}
	private static IPv6AddressSegment join(IPv6AddressCreator creator, MACAddressSegment macSegment0, MACAddressSegment macSegment1, boolean flip, Integer prefixLength) {
		if(macSegment0.isMultiple()) {
			if(!macSegment1.isFullRange()) {
				throw new IncompatibleAddressException(macSegment0, macSegment1, "ipaddress.error.invalidMACIPv6Range");
			}
		}
		int lower0 = macSegment0.getSegmentValue();
		int upper0 = macSegment0.getUpperSegmentValue();
		if(flip) {
			int mask2ndBit = 0x2;
			if(!macSegment0.matchesWithMask(mask2ndBit & lower0, mask2ndBit)) {
				throw new IncompatibleAddressException(macSegment0, "ipaddress.mac.error.not.eui.convertible");
			}
			lower0 ^= mask2ndBit;
			upper0 ^= mask2ndBit;
		}
		return creator.createSegment(
				(lower0 << 8) | macSegment1.getSegmentValue(), 
				(upper0 << 8) | macSegment1.getUpperSegmentValue(),
				prefixLength);
	}
	@Override
	public IPv6AddressNetwork getNetwork() {
		return defaultIpv6Network();
	}
	public MACAddressNetwork getMACNetwork() {
		return defaultMACNetwork();
	}
	public IPv4AddressNetwork getIPv4Network() {
		return defaultIpv4Network();
	}
	@Override
	public IPv6AddressSection getSection() {
		return (IPv6AddressSection) super.getSection();
	}
	@Override
	public IPv6AddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPv6AddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	@Override
	public IPv6AddressSegment getDivision(int index) {
		return getSegment(index);
	}
	@Override
	public IPv6AddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	@Override
	public IPv6AddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	public boolean isEUI64() {
		return getSection().isEUI64();
	}
	public MACAddress toEUI(boolean extended) {
		MACAddressSection section = getSection().toEUI(extended);
		if(section == null) {
			return null;
		}
		MACAddressCreator creator = getMACNetwork().getAddressCreator();
		return creator.createAddress(section);
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv6StringBuilderOptions.from(options));
	}
	public IPAddressStringDivisionSeries[] getParts(IPv6StringBuilderOptions options) {
		IPAddressStringDivisionSeries parts[] = getSection().getParts(options);
		IPv4Address ipv4Addr = getConverted(options);
		if(ipv4Addr != null) {
			IPAddressStringDivisionSeries ipv4Parts[] = ipv4Addr.getParts(options.ipv4ConverterOptions);
			IPAddressStringDivisionSeries tmp[] = parts;
			parts = new IPAddressStringDivisionSeries[tmp.length + ipv4Parts.length];
			System.arraycopy(tmp, 0, parts, 0, tmp.length);
			System.arraycopy(ipv4Parts,  0, parts, tmp.length, ipv4Parts.length);
		}
		return parts;
	}
	@Override
	public int getSegmentCount() {
		return SEGMENT_COUNT;
	}
	@Override
	public int getByteCount() {
		return BYTE_COUNT;
	}
	@Override
	public int getBitCount() {
		return BIT_COUNT;
	}
	void cache(IPv6Address lower, IPv6Address upper) {
		if((lower != null || upper != null) && getSection().getSingleLowestOrHighestSection() == null) {
			getSection().cache(lower != null ? lower.getSection() : null, upper != null ? upper.getSection() : null);
			IPv6AddressCache cache = addressCache;
			if(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null)) {
				synchronized(this) {
					cache = addressCache;
					boolean create = (cache == null);
					if(create) {
						addressCache = cache = new IPv6AddressCache();
						cache.lower = lower;
						cache.upper = upper;
					} else {
						if(cache.lower == null) {
							cache.lower = lower;
						}
						if(cache.upper == null) {
							cache.upper = upper;
						}
					}
				}
			}
		}
	}
	private IPv6Address getLowestOrHighest(boolean lowest, boolean excludeZeroHost) {
		IPv6AddressSection currentSection = getSection();
		IPv6AddressSection sectionResult = currentSection.getLowestOrHighestSection(lowest, excludeZeroHost);
		if(sectionResult == currentSection) {
			return this;
		} else if(sectionResult == null) {
			return null;
		}
		IPv6Address result = null;
		IPv6AddressCache cache = addressCache;
		if(cache == null || 
			(result = lowest ? (excludeZeroHost ? cache.lowerNonZeroHost : cache.lower) : cache.upper) == null) {
			synchronized(this) {
				cache = addressCache;
				boolean create = (cache == null);
				if(create) {
					addressCache = cache = new IPv6AddressCache();
				} else {
					if(lowest) {
						if(excludeZeroHost) {
							create = (result = cache.lowerNonZeroHost) == null;
						} else {
							create = (result = cache.lower) == null;
						}
					} else {
						create = (result = cache.upper) == null;
					}
				}
				if(create) {
					result = getCreator().createAddress(sectionResult);
					if(lowest) {
						if(excludeZeroHost) {
							 cache.lowerNonZeroHost = result;
						} else {
							cache.lower = result;
						}
					} else {
						cache.upper = result;
					}
				}
			}
		}
		return result;
	}
	@Override
	public IPv6Address getLowerNonZeroHost() {
		return getLowestOrHighest(true, true);
	}
	@Override
	public IPv6Address getLower() {
		return getLowestOrHighest(true, false);
	}
	@Override
	public IPv6Address getUpper() {
		return getLowestOrHighest(false, false);
	}
	public long[] longValues() {
		return getSection().longValues();
	}
	public long[] upperLongValues() {
		return getSection().upperLongValues();
	}
	IPv6TrieKeyData getTrieKeyCache() {
		IPv6TrieKeyData keyData = cachedTrieKeyData;
		if(keyData == null) {
			keyData = new IPv6TrieKeyData();
			Integer prefLen = getPrefixLength();
			keyData.prefixLength = prefLen;
			long vals[] = longValues();
			keyData.uint64HighVal = vals[0];
			keyData.uint64LowVal = vals[1];
			if(prefLen != null) {
				int bits = prefLen;
				IPv6Address mask = getNetwork().getNetworkMask(bits, false);
				vals = mask.longValues();
				keyData.mask64HighVal = vals[0];
				keyData.mask64LowVal = vals[1];
				if(bits > 63) {
					keyData.nextBitMask64Val = 0x8000000000000000L >>> (bits - 64);
				} else {
					keyData.nextBitMask64Val = 0x8000000000000000L >>> bits;
				}
			}
			cachedTrieKeyData = keyData;
		}
		return keyData;
	}
	public IPv6Address replace(int startIndex, int endIndex, IPv6Address replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	public IPv6Address replace(int startIndex, IPv6AddressSection replacement) {
		int replacementCount = Math.min(IPv6Address.SEGMENT_COUNT - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	@Override
	public IPv6Address reverseBits(boolean perByte) {
		return getCreator().createAddress(getSection().reverseBits(perByte));
	}
	@Override
	public IPv6Address reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	@Override
	public IPv6Address reverseBytesPerSegment() {
		return checkIdentity(getSection().reverseBytesPerSegment());
	}
	@Override
	public IPv6Address reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsNonZeroHostIterator() {
		return getSection().segmentsNonZeroHostIterator();
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	@Override
	public AddressComponentRangeSpliterator<IPv6Address, IPv6AddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getCreator());
	}
	@Override
	public Stream<IPv6AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixBlockIterator() {
		return getSection().prefixIterator(this, getCreator(), true);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getCreator(), true);
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixBlockIterator(int prefixLength) {
		return getSection().prefixIterator(this, getCreator(), true, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixBlockSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getCreator(), true, prefixLength);
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream(int prefixLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv6Address> prefixIterator() {
		return getSection().prefixIterator(this, getCreator(), false);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getCreator(), false);
	}
	@Override
	public Stream<IPv6Address> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixIterator(int prefixLength) {
		return getSection().prefixIterator(this, getCreator(), false, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getCreator(), false, prefixLength);
	}
	@Override
	public Stream<IPv6Address> prefixStream(int prefixLength) {
		return StreamSupport.stream(prefixSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv6Address> blockIterator(int segmentCount) {
		return getSection().blockIterator(this, getCreator(), segmentCount);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> blockSpliterator(int segmentCount) {
		return getSection().blockSpliterator(this, getCreator(), segmentCount);
	}
	@Override
	public Stream<IPv6Address> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6Address> sequentialBlockIterator() {
		return (Iterator<IPv6Address>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv6Address> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv6Address>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv6Address> sequentialBlockStream() {
		return (Stream<IPv6Address>) super.sequentialBlockStream();
	}
	@Override
	public Iterator<IPv6Address> iterator() {
		return getSection().iterator(this, getCreator(), null);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> spliterator() {
		return getSection().spliterator(this, getCreator(), false);
	}
	@Override
	public Stream<IPv6Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> nonZeroHostIterator() {
		Predicate<IPv6AddressSegment[]> excludeFunc = null;
		if(includesZeroHost()) {
			int prefLength = getNetworkPrefixLength();
			excludeFunc = segments -> getSection().isZeroHost(segments, prefLength);
		}
		return getSection().iterator(this, getCreator(), excludeFunc);
	}
	@Override
	public Iterable<IPv6Address> getIterable() {
		return this;
	}
	public IPv6Address increment(BigInteger increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv6Address increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv6Address incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	@Override
	public IPv4Address toIPv4() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.toIPv4(this);
	}
	@Override
	public IPv6Address toIPv6() {
		return this;
	}
	@Override
	public boolean isIPv6() {
		return true;
	}
	@Override
	public boolean isIPv4Convertible() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.isIPv4Convertible(this);
	}
	@Override
	public boolean isIPv6Convertible() {
		return true;
	}
	public IPv4AddressSection toMappedIPv4Segments() {
		if(isIPv4Mapped()) {
			return getSection().getEmbeddedIPv4AddressSection();
		}
		return null;
	}
	public IPv4Address get6To4IPv4Address() {
		return getEmbeddedIPv4Address(2);
	}
	public IPv4Address getEmbeddedIPv4Address() {
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		return creator.createAddress(getSection().getEmbeddedIPv4AddressSection()); 
	}
	public IPv4Address getEmbeddedIPv4Address(int byteIndex) {
		if(byteIndex == IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT * IPv6Address.BYTES_PER_SEGMENT) {
			return getEmbeddedIPv4Address();
		}
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		return creator.createAddress(getSection().getEmbeddedIPv4AddressSection(byteIndex, byteIndex + IPv4Address.BYTE_COUNT)); 
	}
	@Override
	public boolean isLocal() {
		if(isMulticast()) {
			IPv6AddressSegment firstSeg = getSegment(0);
			if(firstSeg.matchesWithMask(8, 0xf)) {
				return true;
			}
			if(firstSeg.getValueCount() <= 5 && 
					(firstSeg.getSegmentValue() & 0xf) >= 1 && (firstSeg.getUpperSegmentValue() & 0xf) <= 5) {
				return true;
			}
			if(firstSeg.matchesWithPrefixMask(0xff30, 12) && getSegment(6).matchesWithPrefixMask(0x8000, 1)) {
				return true;
			}
		}
		return isLinkLocal() || isSiteLocal() || isUniqueLocal() || isAnyLocal();
	}
	@Override
	public boolean isLinkLocal() {
		IPv6AddressSegment firstSeg = getSegment(0);
		return (isMulticast() && firstSeg.matchesWithMask(2, 0xf)) || 
				firstSeg.matchesWithPrefixMask(0xfe80, 10);
	}
	public boolean isSiteLocal() {
		IPv6AddressSegment firstSeg = getSegment(0);
		return (isMulticast() && firstSeg.matchesWithMask(5, 0xf)) ||  
				firstSeg.matchesWithPrefixMask(0xfec0, 10); 
	}
	public boolean isUniqueLocal() {
		return getSegment(0).matchesWithPrefixMask(0xfc00, 7);
	}
	public boolean isIPv4Mapped() {
		if(getSegment(5).matches(IPv6Address.MAX_VALUE_PER_SEGMENT)) {
			for(int i = 0; i < 5; i++) {
				if(!getSegment(i).isZero()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	public boolean isIPv4Compatible() {
		return getSegment(0).isZero() && getSegment(1).isZero() && getSegment(2).isZero() &&
				getSegment(3).isZero() && getSegment(4).isZero() && getSegment(5).isZero();
	}
	public boolean is6To4() {
		return getSegment(0).matches(0x2002);
	}
	public boolean is6Over4() {
		return getSegment(0).matches(0xfe80) && 
				getSegment(1).isZero() && getSegment(2).isZero() &&
				getSegment(3).isZero() && getSegment(4).isZero() &&
				getSegment(5).isZero();
	}
	public boolean isTeredo() {
		return getSegment(0).matches(0x2001) && getSegment(1).isZero();
	}
	public boolean isIsatap() {
		return getSegment(0).matches(0xfe80) &&
				getSegment(1).isZero() &&
				getSegment(2).isZero() &&
				getSegment(3).isZero() &&
				(getSegment(4).isZero() || getSegment(4).matches(0x200)) && 
				getSegment(5).matches(0x5efe);
	}
	public boolean isIPv4Translatable() { 
		return getSegment(4).matches(0xffff) && 
				getSegment(5).isZero() &&
				getSegment(0).isZero() &&
				getSegment(1).isZero() &&
				getSegment(2).isZero() &&
				getSegment(3).isZero();
	}
	public boolean isWellKnownIPv4Translatable() { 
		if(getSegment(0).matches(0x64) && getSegment(1).matches(0xff9b)) {
			for(int i=2; i<=5; i++) {
				if(!getSegment(i).isZero()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public boolean isMulticast() {
		return getSegment(0).matchesWithPrefixMask(0xff00, 8);
	}
	@Override
	public boolean isLoopback() {
		int i=0;
		for(; i < getSegmentCount() - 1; i++) {
			if(!getSegment(i).isZero()) {
				return false;
			}
		}
		return getSegment(i).matches(1);
	}
	@Override
	public IPv6Address intersect(IPAddress other) throws AddressConversionException {
		IPv6AddressSection thisSection = getSection();
		IPv6Address otherAddr = convertArg(other);
		IPv6AddressSection section = thisSection.intersect(otherAddr.getSection());
		if(section == null) {
			return null;
		}
		IPv6AddressCreator creator = isSameZone(otherAddr) ? getCreator() : getDefaultCreator();
		IPv6Address result = creator.createAddress(section);
		return result;
	}
	@Override
	public IPv6Address[] subtract(IPAddress other) throws AddressConversionException {
		IPv6AddressSection thisSection = getSection();
		IPv6AddressSection sections[] = thisSection.subtract(convertArg(other).getSection());
		if(sections == null) {
			return null;
		}
		IPv6Address result[] = new IPv6Address[sections.length];
		for(int i = 0; i < result.length; i++) {
			result[i] = getCreator().createAddress(sections[i]); 
		}
		return result;
	}
	private IPv6Address checkIdentity(IPv6AddressSection newSection) {
		if(newSection == getSection()) {
			return this;
		}
		return getCreator().createAddress(newSection);
	}
	@Override
	public IPv6Address adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	@Override
	public IPv6Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public IPv6Address adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	@Override
	public IPv6Address adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength) throws PrefixLenException {
		return setPrefixLength(prefixLength, true);
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength, boolean zeroed) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed, zeroHostIsBlock));
	}
	@Deprecated
	@Override
	public IPv6Address applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().applyPrefixLength(networkPrefixLength));
	}
	@Override @Deprecated
	public IPv6Address removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public IPv6Address withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override @Deprecated
	public IPv6Address removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	@Override
	protected IPv6Address convertArg(IPAddress arg) throws AddressConversionException {
		IPv6Address converted = arg.toIPv6();
		if(converted == null) {
			throw new AddressConversionException(this, arg);
		}
		return converted;
	}
	@Override
	public IPv6Address toZeroHost() {
		return toZeroHost(false);
	}
	@Override
	protected IPv6Address toZeroHost(boolean boundariesOnly) {
		if(!isPrefixed()) {
			IPv6AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv6Address addr = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				addr = addr.getLower();
			}
			return addr;
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();
		}
		return checkIdentity(getSection().createZeroHost(boundariesOnly));
	}
	@Override
	public IPv6Address toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		return checkIdentity(getSection().toZeroHost(prefixLength));
	}
	@Override
	public IPv6Address toZeroNetwork() {
		if(!isPrefixed()) {
			return getNetwork().getHostMask(getBitCount());
		}
		return checkIdentity(getSection().createZeroNetwork());
	}
	@Override
	public IPv6Address toMaxHost() {
		if(!isPrefixed()) {
			IPv6Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix;
			}
			return resultNoPrefix.setPrefixLength(0);
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();
		}
		return checkIdentity(getSection().createMaxHost());
	}
	@Override
	public IPv6Address toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		return checkIdentity(getSection().toMaxHost(prefixLength));
	}
	@Override
	public IPv6Address mask(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().mask(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv6Address mask(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return mask(mask, false);
	}
	@Override
	public IPv6Address maskNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().maskNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv6Address bitwiseOr(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOr(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv6Address bitwiseOr(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return bitwiseOr(mask, false);
	}
	@Override
	public IPv6Address bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOrNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv6Address getHostMask() {
		return (IPv6Address) super.getHostMask();
	}
	@Override
	public IPv6Address getNetworkMask() {
		return (IPv6Address) super.getNetworkMask();
	}
	@Override
	public IPv6AddressSection getNetworkSection() {
		return getSection().getNetworkSection();
	}
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength);
	}
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength, withPrefixLength);
	}
	@Override
	public IPv6AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getHostSection(networkPrefixLength);
	}
	@Override
	public IPv6AddressSection getHostSection() {
		return getSection().getHostSection();
	}
	@Override
	public IPv6Address toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv6Address toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().toPrefixBlock(networkPrefixLength));
	}
	@Override
	public IPv6Address assignPrefixForSingleBlock() {
		return (IPv6Address) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv6Address assignMinPrefixForBlock() {
		return (IPv6Address) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv6Address coverWithPrefixBlock() {
		return (IPv6Address) IPv6AddressSection.coverWithPrefixBlock(this, getLower(), getUpper());
	}
	@Override
	public IPv6Address coverWithPrefixBlock(IPAddress other) throws AddressConversionException {
		return IPv6AddressSection.coverWithPrefixBlock(
				this.removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	@Override
	public IPv6Address[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv6Address[] {removeZone()};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6Address> list = (ArrayList<IPv6Address>) removeZone().spanWithBlocks(true);
		return list.toArray(new IPv6Address[list.size()]);
	}
	@Override
	public IPv6Address[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningPrefixBlocks(
				removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6Address::assignPrefixForSingleBlock,
				IPv6Address::withoutPrefixLength,
				getCreator()::createAddressArray);
	}
	@Override
	public IPv6Address[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv6Address[] { withoutPrefixLength().removeZone() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6Address> list = (ArrayList<IPv6Address>) removeZone().spanWithBlocks(false);
		return list.toArray(new IPv6Address[list.size()]);
	}
	@Override
	public IPv6Address[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningSequentialBlocks(
				this.removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6Address::withoutPrefixLength,
				getDefaultCreator());
	}
	@Override
	public IPv6AddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException {
		return toSequentialRange(other);
	}
	@Override
	public IPv6Address[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSinglePrefixBlock()) {
				return new IPv6Address[] {removeZone()};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv6Address[blocks.size()]);
	}
	private IPAddress[] getConverted(IPAddress... addresses) {
		IPAddress converted[] = new IPAddress[addresses.length + 1];
		for(int i = 0, j = 1; i < addresses.length; i = j++) {
			converted[j] = convertArg(addresses[i]).removeZone();
		}
		converted[0] = removeZone();
		return converted;
	}
	@Override
	public IPv6Address[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSequential()) {
				return new IPv6Address[] {removeZone()};
			}
		}
		addresses = addresses.clone();
		for(int i = 0; i < addresses.length; i++) {
			addresses[i] = convertArg(addresses[i]).removeZone();
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getDefaultCreator());
		return blocks.toArray(new IPv6Address[blocks.size()]);
	}
	@Override
	protected SeriesCreator getSequentialSeriesCreator() {
		return getDefaultCreator()::createSequentialBlockAddress;
	}
	public boolean hasZone() {
		return zone != null;
	}
	public String getZone() {
		return getZoneString();
	}
	public IPv6Address setZone(IPv6Zone newZone) {
		if(newZone == null) {
			return removeZone();
		}
		return getDefaultCreator().createAddress(getSection(), newZone); 
	}
	public IPv6Zone getIPv6Zone() {
		return zone;
	}
	public IPv6Address removeZone() {
		if(hasZone()) {
			return getDefaultCreator().createAddress(getSection()); 
		}
		return this;
	}
	protected boolean hasNoValueCache() {
		if(addressCache == null) {
			synchronized(this) {
				if(addressCache == null) {
					addressCache = new IPv6AddressCache();
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public Inet6Address toInetAddress() {
		if(hasZone()) {
			Inet6Address result;
			if(hasNoValueCache() || (result = addressCache.inetAddress) == null) {
				addressCache.inetAddress = result = (Inet6Address) toInetAddressImpl();
			}
			return result;
		}
		return (Inet6Address) super.toInetAddress();
	}
	@Override
	public Inet6Address toUpperInetAddress() {
		return (Inet6Address) super.toUpperInetAddress();
	}
	@Override
	protected Inet6Address toInetAddressImpl() {
		Inet6Address result;
		byte bytes[] = getSection().getBytesInternal();
		try {
			if(hasZone()) {
				if(zone.referencesScopeId()) {
					result = Inet6Address.getByAddress(null, bytes, zone.getAssociatedScopeId());
				} else if(zone.referencesIntf() && zone.getAssociatedIntf() != null) {
					result = Inet6Address.getByAddress(null, bytes, zone.getAssociatedIntf());
				} else {
					IPv6Address adjusted = getLower().withoutPrefixLength();
					InetAddress resultIP = InetAddress.getByName(adjusted.toNormalizedString());
					if(resultIP instanceof Inet6Address) {
						result = (Inet6Address) resultIP;
					} else {
						result = Inet6Address.getByAddress(null, bytes, null);
					}
				}
			} else {
				result = Inet6Address.getByAddress(null, bytes, null);
			}
		} catch(UnknownHostException e) {
			result = null;
		}
		return result;
	}
	@Override
	@Deprecated
	public IPv6AddressSeqRange toSequentialRange(IPAddress other) {
		return new IPv6AddressSeqRange(this, convertArg(other));
	}
	@Override
	public IPv6AddressSeqRange toSequentialRange() {
		IPv6Address thiz = removeZone().withoutPrefixLength();
		return new IPv6AddressSeqRange(thiz.getLower(), thiz.getUpper(), true);
	}
	@Override
	public int hashCode() {
		int result = super.hashCode();
		if(hasZone()) {
			result *= zone.getName().hashCode();
		}
		return result;
	}
	@Override
	public boolean isSameAddress(Address other) {
		return other instanceof IPv6Address && super.isSameAddress(other) && isSameZone((IPv6Address) other);
	}
	private boolean isSameZone(IPv6Address otherIPv6Address) {
		return Objects.equals(zone, otherIPv6Address.zone);
	}
	@Override
	public boolean overlaps(Address other) {
		if(super.overlaps(other)) {
			if(other != this) {
				IPv6Address otherAddr = (IPv6Address) other;
				if(hasZone() || otherAddr.hasZone()) {
					return isSameZone(otherAddr);
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public boolean contains(Address other) {
		if(super.contains(other)) {
			if(other != this) {
				IPv6Address otherAddr = (IPv6Address) other;
				if(hasZone() || otherAddr.hasZone()) {
					return isSameZone(otherAddr);
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof IPv6Address) {
			return IPv6AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	public BigInteger enumerate(IPAddress other) {
		if(other.isIPv6()) {
			return IPv6AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	protected IPAddressStringParameters createFromStringParams() {
		return new IPAddressStringParameters.Builder().
				getIPv4AddressParametersBuilder().setNetwork(getIPv4Network()).getParentBuilder().
				getIPv6AddressParametersBuilder().setNetwork(getNetwork()).getParentBuilder().toParams();
	}
	private boolean hasNoStringCache() {
		if(stringCache == null) {
			synchronized(this) {
				if(stringCache == null) {
					if(hasZone()) {
						stringCache = new IPv6StringCache();
						return true;
					} else {
						IPv6AddressSection section = getSection();
						boolean result = section.hasNoStringCache();
						stringCache = section.getStringCache();
						return result;
					}
				}
			}
		}
		return false;
	}
	public String toMixedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.mixedString) == null) {
			if(hasZone()) {
				stringCache.mixedString = result = toNormalizedString(IPv6StringCache.mixedParams);
			} else {
				result = getSection().toMixedString();
			}
		}
		return result;
	}
	@Override
	public String toCanonicalString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalString) == null) {
			if(hasZone()) {
				stringCache.canonicalString = result = toNormalizedString(IPv6StringCache.canonicalParams);
			} else {
				result = getSection().toCanonicalString();
			}
		}
		return result;
	}
	@Override
	public String toFullString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.fullString) == null) {
			if(hasZone()) {
				stringCache.fullString = result = toNormalizedString(IPv6StringCache.fullParams);
			} else {
				result = getSection().toFullString();
			}
		}
		return result;
	}
	public static String toNormalizedString(IPv6AddressNetwork network, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
		return toNormalizedString(network.getPrefixConfiguration(), lowerValueProvider, upperValueProvider, prefixLength, SEGMENT_COUNT, BYTES_PER_SEGMENT, BITS_PER_SEGMENT, MAX_VALUE_PER_SEGMENT, SEGMENT_SEPARATOR, DEFAULT_TEXTUAL_RADIX, zone);
	}
	@Override
	public String toNormalizedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedString) == null) {
			if(hasZone()) {
				stringCache.normalizedString = result = toNormalizedString(IPv6StringCache.normalizedParams);
			} else {
				result = getSection().toNormalizedString();
			}
		}
		return result;
	}
	@Override
	public String toCompressedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.compressedString) == null) {
			if(hasZone()) {
				stringCache.compressedString = result = toNormalizedString(IPv6StringCache.compressedParams);
			} else {
				result = getSection().toCompressedString();
			}
		}
		return result;
	}
	@Override
	public String toSubnetString() {
		return toPrefixLengthString();
	}
	@Override
	public String toNormalizedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedWildcardString) == null) {
			if(hasZone()) {
				stringCache.normalizedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardNormalizedParams);
			} else {
				result = getSection().toNormalizedWildcardString();
			}
		}
		return result;
	}
	public String toBase85String() throws IncompatibleAddressException {
		IPAddressString originator = getAddressfromString();
		if(originator != null && (!isPrefixed() || getNetworkPrefixLength() == IPv6Address.BIT_COUNT) && 
				originator.isBase85IPv6()) {
			return originator.toString();
		}
		String result;
		if(hasNoStringCache() || (result = stringCache.base85String) == null) {
			if(hasZone()) {
				stringCache.base85String = result = getSection().toBase85String(getZone());
			} else {
				result = getSection().toBase85String();
			}
		}
		return result;
	}
	@Override
	public String toCanonicalWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalWildcardString) == null) {
			if(hasZone()) {
				stringCache.canonicalWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCanonicalParams);
			} else {
				result = getSection().toCanonicalWildcardString();
			}
		}
		return result;
	}
	@Override
	public String toCompressedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.compressedWildcardString) == null) {
			if(hasZone()) {
				stringCache.compressedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCompressedParams);
			} else {
				result = getSection().toCompressedWildcardString();
			}
		}
		return result;
	}
	@Override
	public String toSQLWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.sqlWildcardString) == null) {
			if(hasZone()) {
				stringCache.sqlWildcardString = result = toNormalizedString(IPv6StringCache.sqlWildcardParams);
			} else {
				result = getSection().toSQLWildcardString();
			}
		}
		return result;
	}
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = (with0xPrefix ? stringCache.hexStringPrefixed : stringCache.hexString)) == null) {
			if(hasZone()) {
				result = getSection().toHexString(with0xPrefix, zone.getName());
				if(with0xPrefix) {
					stringCache.hexStringPrefixed = result;
				} else {
					stringCache.hexString = result;
				}
			} else {
				result = getSection().toHexString(with0xPrefix);
			}
		}
		return result;
	}
	private String getZoneString() {
		return hasZone() ? zone.getName() : null;
	}
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = stringCache.binaryString) == null) {
			if(hasZone()) {
				result = getSection().toBinaryString(zone.getName());
				stringCache.binaryString = result;
			} else {
				result = getSection().toBinaryString();
			}
		}
		return result;
	}
	@Override
	public String toSegmentedBinaryString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.segmentedBinaryString) == null) {
			if(hasZone()) {
				result = getSection().toSegmentedBinaryString(zone.getName());
				stringCache.segmentedBinaryString = result;
			} else {
				result = getSection().toSegmentedBinaryString();
			}
		}
		return result;
	}
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = (with0Prefix ? stringCache.octalStringPrefixed : stringCache.octalString)) == null) {
			if(hasZone()) {
				result = getSection().toOctalString(with0Prefix, zone.getName());
				if(with0Prefix) {
					stringCache.octalStringPrefixed = result;
				} else {
					stringCache.octalString = result;
				}
			} else {
				result = getSection().toOctalString(with0Prefix);
			}
		}
		return result;
	}
	@Override
	public String toPrefixLengthString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.networkPrefixLengthString) == null) {
			if(hasZone()) {
				stringCache.networkPrefixLengthString = result = toNormalizedString(IPv6StringCache.networkPrefixLengthParams);
			} else {
				result = getSection().toPrefixLengthString();
			}
		}
		return result;
	}
	@Override
	public String toConvertedString() {
		if(isIPv4Convertible()) {
			return toMixedString();
		}
		return toNormalizedString();
	}
	@Override
	public String toNormalizedString(IPStringOptions params) {
		return getSection().toNormalizedString(params, getZoneString());
	}
	public String toNormalizedString(IPv6StringOptions params) {
		return getSection().toNormalizedString(params, getZoneString());
	}
	public String toNormalizedString(boolean keepMixed, IPv6StringOptions params) {
		if(keepMixed && fromString != null && getAddressfromString().isMixedIPv6() && !params.makeMixed()) {
			params = new IPv6StringOptions(
					params.base,
					params.expandSegments,
					params.wildcardOption,
					params.wildcards,
					params.segmentStrPrefix,
					true,
					params.ipv4Opts,
					params.compressOptions,
					params.separator,
					params.zoneSeparator,
					params.addrLabel,
					params.addrSuffix,
					params.reverse,
					params.splitDigits,
					params.uppercase);
		}
		return toNormalizedString(params);
	}
	@Override
	public String toUNCHostName() {
		String result;
		if(hasNoStringCache() || (result = stringCache.uncString) == null) {
			String newZone;
			if(hasZone()) {
				newZone = zone.getName().replace(IPv6Address.ZONE_SEPARATOR, IPv6Address.UNC_ZONE_SEPARATOR).replace(IPv6Address.SEGMENT_SEPARATOR, IPv6Address.UNC_SEGMENT_SEPARATOR);
			} else {
				newZone = null;
			}
			stringCache.uncString = result = getSection().toNormalizedString(IPv6StringCache.uncParams, newZone);
		}
		return result;
	}
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.ALL_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv6StringBuilderOptions.from(opts));
	}
	private IPv4Address getConverted(IPv6StringBuilderOptions opts) {
		if(!hasZone() && opts.includes(IPv6StringBuilderOptions.IPV4_CONVERSIONS)) {
			IPv4AddressConverter converter = opts.converter;
			return converter.toIPv4(this);
		}
		return null;
	}
	public IPAddressPartStringCollection toStringCollection(IPv6StringBuilderOptions opts) {
		IPv6StringCollection coll = getSection().toStringCollection(opts, getZoneString());
		IPv4Address ipv4Addr = getConverted(opts);
		if(ipv4Addr != null) {
			IPAddressPartStringCollection ipv4StringCollection = ipv4Addr.toStringCollection(opts.ipv4ConverterOptions);
			coll.addAll(ipv4StringCollection);
		}
		return coll;
	}
	public interface IPv6AddressConverter {
		IPv6Address toIPv6(IPAddress address);
	}
}
package inet.ipaddr.format.validate;
import inet.ipaddr.HostName;
import inet.ipaddr.HostNameException;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.AddressStringException;
import inet.ipaddr.MACAddressString;
import inet.ipaddr.ipv6.IPv6Address;
public interface HostIdentifierStringValidator {
	public static final int MAX_PREFIX = IPv6Address.BIT_COUNT;
	public static final int MAX_PREFIX_CHARS = Integer.toString(MAX_PREFIX).length();
	public static final String SMTP_IPV6_IDENTIFIER = "IPv6:";
	public static final char IPvFUTURE= 'v';
	ParsedHost validateHost(HostName fromHost) throws HostNameException;
	IPAddressProvider validateAddress(IPAddressString fromString) throws AddressStringException;
	MACAddressProvider validateAddress(MACAddressString fromString) throws AddressStringException;
	int validatePrefix(CharSequence fullAddr, IPVersion version) throws AddressStringException;
}
package inet.ipaddr;
import java.math.BigInteger;
import java.util.Comparator;
import java.util.Iterator;
import java.util.stream.Stream;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
public interface IPAddressSegmentSeries extends IPAddressDivisionSeries, AddressSegmentSeries {
	static Comparator<? super IPAddressSegmentSeries> getPrefixLenComparator() {
		return IPAddressSection.mergeListComparator;
	}
	IPVersion getIPVersion();
	IPAddressSegmentSeries assignMinPrefixForBlock();
	IPAddressSegmentSeries assignPrefixForSingleBlock();
	IPAddressSegmentSeries coverWithPrefixBlock();
	IPAddressSegmentSeries[] spanWithPrefixBlocks();
	IPAddressSegmentSeries[] spanWithSequentialBlocks();
	@Override
	IPAddressSegmentSeries toPrefixBlock();
	IPAddressSegmentSeries toPrefixBlock(int networkPrefixLength) throws PrefixLenException;
	IPAddressSegmentSeries getHostMask();
	IPAddressSegmentSeries getNetworkMask();
	IPAddressSection getHostSection();
	IPAddressSection getHostSection(int networkPrefixLength);
	IPAddressSection getNetworkSection();
	IPAddressSection getNetworkSection(int networkPrefixLength);
	IPAddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength);
	String toFullString();
	String toPrefixLengthString();
	String toSubnetString();
	String toNormalizedWildcardString();
	String toCanonicalWildcardString();
	String toCompressedWildcardString();
	String toSQLWildcardString();
	String toReverseDNSLookupString();
	String toBinaryString() throws IncompatibleAddressException;
	String toSegmentedBinaryString();
	String toOctalString(boolean with0Prefix) throws IncompatibleAddressException;
	IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions options);
	String toNormalizedString(IPStringOptions stringOptions);
	@Override
	IPAddressNetwork<?,?,?,?,?> getNetwork();
	@Override
	IPAddressSection getSection();
	@Override
	IPAddressSection getSection(int index);
	@Override
	IPAddressSection getSection(int index, int endIndex);
	@Override
	IPAddressSegment getSegment(int index);
	@Override
	IPAddressSegment[] getSegments();
	BigInteger getNonZeroHostCount();
	IPAddressSegmentSeries getLowerNonZeroHost();
	@Override
	IPAddressSegmentSeries getLower();
	@Override
	IPAddressSegmentSeries getUpper();
	@Override
	Iterable<? extends IPAddressSegmentSeries> getIterable();
	@Override
	Iterator<? extends IPAddressSegmentSeries> iterator();
	@Override
	AddressComponentSpliterator<? extends IPAddressSegmentSeries> spliterator();
	@Override
	Stream<? extends IPAddressSegmentSeries> stream();
	@Override
	Iterator<? extends IPAddressSegmentSeries> prefixIterator();
	@Override
	AddressComponentSpliterator<? extends IPAddressSegmentSeries> prefixSpliterator();
	@Override
	Stream<? extends IPAddressSegmentSeries> prefixStream();
	@Override
	Iterator<? extends IPAddressSegmentSeries> prefixBlockIterator();
	@Override
	AddressComponentSpliterator<? extends IPAddressSegmentSeries> prefixBlockSpliterator();
	@Override
	Stream<? extends IPAddressSegmentSeries> prefixBlockStream();
	Iterator<? extends IPAddressSegmentSeries> nonZeroHostIterator();
	Iterator<? extends IPAddressSegmentSeries> blockIterator(int segmentCount);
	AddressComponentSpliterator<? extends IPAddressSegmentSeries> blockSpliterator(int segmentCount);
	Stream<? extends IPAddressSegmentSeries> blockStream(int segmentCount);
	Iterator<? extends IPAddressSegmentSeries> sequentialBlockIterator();
	AddressComponentSpliterator<? extends IPAddressSegmentSeries> sequentialBlockSpliterator();
	Stream<? extends IPAddressSegmentSeries> sequentialBlockStream();
	BigInteger getSequentialBlockCount();
	@Override
	Iterator<? extends IPAddressSegment[]> segmentsIterator();
	@Override
	AddressComponentRangeSpliterator<? extends IPAddressSegmentSeries, ? extends IPAddressSegment[]> segmentsSpliterator();
	@Override
	Stream<? extends IPAddressSegment[]> segmentsStream();
	Iterator<? extends IPAddressSegment[]> segmentsNonZeroHostIterator();
	@Override
	IPAddressSegmentSeries increment(long increment);
	@Override
	IPAddressSegmentSeries incrementBoundary(long increment);
	IPAddressSegmentSeries toZeroHost();
	IPAddressSegmentSeries toZeroHost(int prefixLength);
	IPAddressSegmentSeries toZeroNetwork();
	boolean includesZeroHost();
	boolean includesZeroHost(int prefixLength);
	IPAddressSegmentSeries toMaxHost(int prefixLength);
	IPAddressSegmentSeries toMaxHost();
	boolean includesMaxHost();
	boolean includesMaxHost(int prefixLength);
	@Override
	IPAddressSegmentSeries reverseSegments();
	@Override
	IPAddressSegmentSeries reverseBits(boolean perByte);
	@Override
	IPAddressSegmentSeries reverseBytes();
	@Override
	IPAddressSegmentSeries reverseBytesPerSegment();
	@Override @Deprecated
	IPAddressSegmentSeries removePrefixLength();
	@Override
	IPAddressSegmentSeries withoutPrefixLength();
	@Override  @Deprecated
	IPAddressSegmentSeries removePrefixLength(boolean zeroed);
	@Override
	IPAddressSegmentSeries adjustPrefixBySegment(boolean nextSegment);
	@Override
	IPAddressSegmentSeries adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	@Override
	IPAddressSegmentSeries adjustPrefixLength(int adjustment);
	@Override
	IPAddressSegmentSeries adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	IPAddressSegmentSeries setPrefixLength(int prefixLength);
	@Override
	IPAddressSegmentSeries setPrefixLength(int prefixLength, boolean zeroed);
	@Override @Deprecated
	IPAddressSegmentSeries applyPrefixLength(int networkPrefixLength);
}
package inet.ipaddr.ipv4;
import java.io.Serializable;
import java.net.Inet4Address;
import java.util.function.BiFunction;
import java.util.function.Function;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.HostIdentifierString;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.ipv4.IPv4AddressSection.EmbeddedIPv4AddressSection;
public class IPv4AddressNetwork extends IPAddressNetwork<IPv4Address, IPv4AddressSection, IPv4AddressSection, IPv4AddressSegment, Inet4Address> {
	private static final long serialVersionUID = 4L;
	private static PrefixConfiguration defaultPrefixConfiguration = AddressNetwork.getDefaultPrefixConfiguration();
	private static boolean CACHE_SEGMENTS_BY_PREFIX = true;
	private static final IPv4AddressSegment EMPTY_SEGMENTS[] = {};
	private static final IPv4AddressSection EMPTY_SECTION[] = {};
	private static final IPv4Address EMPTY_ADDRESS[] = {};
	public static class IPv4AddressCreator extends IPAddressCreator<IPv4Address, IPv4AddressSection, IPv4AddressSection, IPv4AddressSegment, Inet4Address> {
		private static final long serialVersionUID = 4L;
		protected static class Cache implements Serializable {
			private static final long serialVersionUID = 1L;
			private transient IPv4AddressSegment ZERO_PREFIX_SEGMENT, ALL_RANGE_SEGMENT;
			private transient IPv4AddressSegment segmentCache[];
			private transient IPv4AddressSegment segmentPrefixCache[][]; 
			private transient IPv4AddressSegment allPrefixedCache[];
			void clear() {
				segmentCache = null;
				allPrefixedCache = null;
				segmentPrefixCache = null;
				ZERO_PREFIX_SEGMENT = null;
				ALL_RANGE_SEGMENT = null;
			}
		}
		Cache cache;
		boolean useSegmentCache = true;
		public IPv4AddressCreator(IPv4AddressNetwork network) {
			super(network);
			this.cache = new Cache();
		}
		protected IPv4AddressCreator(IPv4AddressNetwork network, Cache cache) {
			super(network);
			this.cache = cache;
		}
		@Override
		public void clearCaches() {
			super.clearCaches();
			cache.clear();
		}
		@Override
		public void setSegmentCaching(boolean enable) {
			useSegmentCache = enable;
		}
		@Override
		public IPv4AddressNetwork getNetwork() {
			return (IPv4AddressNetwork) super.getNetwork();
		}
		@Override
		public int getMaxValuePerSegment() {
			return IPv4Address.MAX_VALUE_PER_SEGMENT;
		}
		@Override
		protected int getAddressSegmentCount() {
			return IPv4Address.SEGMENT_COUNT;
		}
		@Override
		public IPv4AddressSegment[] createSegmentArray(int length) {
			if(length == 0) {
				return EMPTY_SEGMENTS;
			}
			return new IPv4AddressSegment[length];
		}
		@Override
		public IPv4AddressSegment createSegment(int value) {
			if(useSegmentCache && value >= 0 && value <= IPv4Address.MAX_VALUE_PER_SEGMENT) {
				IPv4AddressSegment result, cache[] = this.cache.segmentCache;
				if(cache == null) {
					this.cache.segmentCache = cache = new IPv4AddressSegment[IPv4Address.MAX_VALUE_PER_SEGMENT + 1];
					cache[value] = result = new IPv4AddressSegment(value);
				} else {
					result = cache[value];
					if(result == null) {
						cache[value] = result = new IPv4AddressSegment(value);
					}
				}
				return result;
			}
			return new IPv4AddressSegment(value);
		}
		@Override
		public IPv4AddressSegment createSegment(int value, Integer segmentPrefixLength) {
			if(segmentPrefixLength == null) {
				return createSegment(value);
			}
			if(useSegmentCache && value >= 0 && value <= IPv4Address.MAX_VALUE_PER_SEGMENT && segmentPrefixLength >= 0 && segmentPrefixLength <= IPv4Address.BIT_COUNT) {
				if(segmentPrefixLength == 0 && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
					IPv4AddressSegment result = cache.ZERO_PREFIX_SEGMENT;
					if(result == null) {
						cache.ZERO_PREFIX_SEGMENT = result = new IPv4AddressSegment(0, 0);
					}
					return result;
				}
				if(CACHE_SEGMENTS_BY_PREFIX) {
					int mask = getNetwork().getSegmentNetworkMask(segmentPrefixLength);
					int prefixIndex = segmentPrefixLength;
					int valueIndex;
					boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
					if(isAllSubnets) {
						value &= mask;
						valueIndex = value >>> (IPv4Address.BITS_PER_SEGMENT - segmentPrefixLength);
					} else {
						valueIndex = value;
					}
					IPv4AddressSegment result, block[], cache[][] = this.cache.segmentPrefixCache;
					if(cache == null) {
						this.cache.segmentPrefixCache = cache = new IPv4AddressSegment[IPv4Address.BITS_PER_SEGMENT + 1][];
						cache[prefixIndex] = block = new IPv4AddressSegment[isAllSubnets ? (1 << prefixIndex) : 256];
						block[valueIndex] = result = new IPv4AddressSegment(value, segmentPrefixLength);
					} else {
						block = cache[prefixIndex];
						if(block == null) {
							cache[prefixIndex] = block = new IPv4AddressSegment[isAllSubnets ? (1 << prefixIndex) : 256];
							block[valueIndex] = result = new IPv4AddressSegment(value, segmentPrefixLength);
						} else {
							result = block[valueIndex];
							if(result == null) {
								block[valueIndex] = result = new IPv4AddressSegment(value, segmentPrefixLength);
							}
						}
					}
					return result;
				}
			}
			IPv4AddressSegment result = new IPv4AddressSegment(value, segmentPrefixLength);
			return result;
		}
		@Override
		public IPv4AddressSegment createSegment(int lower, int upper, Integer segmentPrefixLength) {
			if(segmentPrefixLength == null) {
				if(lower == upper) {
					return createSegment(lower);
				}
				if(useSegmentCache && lower == 0 && upper == IPv4Address.MAX_VALUE_PER_SEGMENT) {
					IPv4AddressSegment result = cache.ALL_RANGE_SEGMENT;
					if(result == null) {
						cache.ALL_RANGE_SEGMENT = result = new IPv4AddressSegment(0, IPv4Address.MAX_VALUE_PER_SEGMENT, null);
					}
					return result;
				}
			} else {
				if(lower == upper) {
					return createSegment(lower, segmentPrefixLength);
				}
				if(useSegmentCache && lower >= 0 && lower <= IPv4Address.MAX_VALUE_PER_SEGMENT &&
						upper >= 0 && upper <= IPv4Address.MAX_VALUE_PER_SEGMENT &&
						segmentPrefixLength >= 0 && segmentPrefixLength <= IPv4Address.BIT_COUNT) {
					if(segmentPrefixLength == 0 && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
						return createSegment(0, cacheBits(0));
					}
					if(CACHE_SEGMENTS_BY_PREFIX) {
						int bitsPerSegment = IPv4Address.BITS_PER_SEGMENT;
						if(segmentPrefixLength > bitsPerSegment) {
							segmentPrefixLength = bitsPerSegment;
						}
						if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
							int mask = getNetwork().getSegmentNetworkMask(segmentPrefixLength);
							lower &= mask;
							if((upper & mask) == lower) {
								return createSegment(lower, segmentPrefixLength);
							}
							if(lower == 0 && upper >= mask) {
								int prefixIndex = segmentPrefixLength;
								IPv4AddressSegment result, cache[] = this.cache.allPrefixedCache;
								if(cache == null) {
									this.cache.allPrefixedCache = cache = new IPv4AddressSegment[IPv4Address.BITS_PER_SEGMENT + 1];
									cache[prefixIndex] = result = new IPv4AddressSegment(0, IPv4Address.MAX_VALUE_PER_SEGMENT, segmentPrefixLength);
								} else {
									result = cache[prefixIndex];
									if(result == null) {
										cache[prefixIndex] = result = new IPv4AddressSegment(0, IPv4Address.MAX_VALUE_PER_SEGMENT, segmentPrefixLength);
									}
								}
								return result;
							}
						} else {
							if(lower == 0 && upper == IPv4Address.MAX_VALUE_PER_SEGMENT) {
								int prefixIndex = segmentPrefixLength;
								IPv4AddressSegment result, cache[] = this.cache.allPrefixedCache;
								if(cache == null) {
									this.cache.allPrefixedCache = cache = new IPv4AddressSegment[IPv4Address.BITS_PER_SEGMENT + 1];
									cache[prefixIndex] = result = new IPv4AddressSegment(0, IPv4Address.MAX_VALUE_PER_SEGMENT, segmentPrefixLength);
								} else {
									result = cache[prefixIndex];
									if(result == null) {
										cache[prefixIndex] = result = new IPv4AddressSegment(0, IPv4Address.MAX_VALUE_PER_SEGMENT, segmentPrefixLength);
									}
								}
								return result;
							}
						}
					}
				}
			}
			IPv4AddressSegment result = new IPv4AddressSegment(lower, upper, segmentPrefixLength);
			return result;
		}
		@Override
		protected IPv4AddressSection[] createSectionArray(int length) {
			if(length == 0) {
				return EMPTY_SECTION;
			}
			return new IPv4AddressSection[length];
		}
		@Override
		protected IPv4AddressSection createSectionInternal(IPv4AddressSegment segments[]) {
			return new IPv4AddressSection(segments, false);
		}
		@Override
		protected IPv4AddressSection createPrefixedSectionInternal(IPv4AddressSegment segments[], Integer prefix, boolean singleOnly) {
			return new IPv4AddressSection(segments, false, prefix, singleOnly);
		}
		protected IPv4AddressSection createSectionInternal(int value) {
			return new IPv4AddressSection(value);
		}
		protected IPv4AddressSection createSectionInternal(int value, Integer prefix) {
			return new IPv4AddressSection(value, prefix);
		}
		@Override
		public IPv4AddressSection createFullSectionInternal(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix) {
			return new IPv4AddressSection(lowerValueProvider, upperValueProvider, IPv4Address.SEGMENT_COUNT, prefix);
		}
		@Override
		protected IPv4AddressSection createSectionInternal(byte[] bytes, int segmentCount, Integer prefix, boolean singleOnly) {
			return new IPv4AddressSection(bytes, segmentCount, prefix, false, singleOnly);
		}
		@Override
		protected IPv4AddressSection createSectionInternal(IPv4AddressSegment[] segments, int startIndex, boolean extended) {
			return new IPv4AddressSection(segments);
		}
		@Override
		public IPv4AddressSection createSection(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix) {
			return new IPv4AddressSection(bytes, byteStartIndex, byteEndIndex, -1, prefix, true, false);
		}
		@Override
		public IPv4AddressSection createSection(byte bytes[], Integer prefix) {
			return new IPv4AddressSection(bytes, prefix);
		}
		@Override
		protected IPv4AddressSection createSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer prefix) {
			return new IPv4AddressSection(bytes, byteStartIndex, byteEndIndex, segmentCount, prefix);
		}
		@Override
		public IPv4AddressSection createSection(IPv4AddressSegment segments[], Integer networkPrefixLength) {
			return new IPv4AddressSection(segments, networkPrefixLength);
		}
		@Override
		public IPv4AddressSection createSection(IPv4AddressSegment segments[]) {
			return new IPv4AddressSection(segments);
		}
		@Override
		protected IPv4AddressSection createEmbeddedSectionInternal(IPAddressSection encompassingSection, IPv4AddressSegment[] segments) {
			return new EmbeddedIPv4AddressSection(encompassingSection, segments);
		}
		@Override
		protected IPv4Address[] createAddressArray(int length) {
			if(length == 0) {
				return EMPTY_ADDRESS;
			}
			return new IPv4Address[length];
		}
		@Override
		protected IPv4Address createAddressInternal(IPv4AddressSegment segments[]) {
			return super.createAddressInternal(segments);
		}
		@Override
		protected IPv4Address createAddressInternal(IPv4AddressSection section, CharSequence zone, HostIdentifierString from, IPv4Address lower, IPv4Address upper) {
			IPv4Address result = createAddressInternal(section, from);
			result.cache(lower, upper);
			return result;
		}
		@Override
		protected IPv4Address createAddressInternal(IPv4AddressSection section, CharSequence zone) {
			return createAddress(section);
		}
		@Override
		public IPv4Address createAddress(IPv4AddressSection section) {
			return new IPv4Address(section);
		}
		@Override
		public IPv4Address createAddress(Inet4Address addr, Integer networkPrefixLength) {
			return new IPv4Address(addr, networkPrefixLength);
		}
		@Override
		public IPv4Address createAddress(Inet4Address addr) {
			return new IPv4Address(addr);
		}
	}
	public IPv4AddressNetwork() {
		super(IPv4Address.class);
	}
	@Override
	public PrefixConfiguration getPrefixConfiguration() {
		return defaultPrefixConfiguration;
	}
	public static void setDefaultPrefixConfiguration(PrefixConfiguration config) {
		defaultPrefixConfiguration = config;
	}
	public static PrefixConfiguration getDefaultPrefixConfiguration() {
		return defaultPrefixConfiguration;
	}
	protected boolean isCompatible(IPv4AddressNetwork other) {
		return super.isCompatible(other);
	}
	@Override
	protected BiFunction<IPv4Address, Integer, IPv4AddressSegment> getSegmentProducer() {
		return (address, index) -> address.getSegment(index);
	}
	@Override
	protected Function<IPv4Address, IPv4AddressSection> getSectionProducer() {
		return IPv4Address::getSection;
	}
	@Override
	protected IPv4AddressCreator createAddressCreator() {
		return new IPv4AddressCreator(this);
	}
	@Override
	protected IPv4Address createLoopback() {
		IPv4AddressCreator creator = getAddressCreator();
		IPv4AddressSegment zero = creator.createSegment(0);
		IPv4AddressSegment segs[] = creator.createSegmentArray(IPv4Address.SEGMENT_COUNT);
		segs[0] = creator.createSegment(127);
		segs[1] = segs[2] = zero;
		segs[3] = creator.createSegment(1);
		return creator.createAddressInternal(segs); 
	}
	@Override
	public IPv4AddressCreator getAddressCreator() {
		return (IPv4AddressCreator) super.getAddressCreator();
	}
	@Override
	public boolean isIPv4() {
		return true;
	}
	@Override
	public IPVersion getIPVersion() {
		return IPVersion.IPV4;
	}
}
package inet.ipaddr.format.validate;
import java.io.Serializable;
import inet.ipaddr.AddressStringException;
import inet.ipaddr.HostName;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.IncompatibleAddressException;
public class ParsedHost implements Serializable {
	private static final long serialVersionUID = 4L;
	private static final EmbeddedAddress NO_EMBEDDED_ADDRESS = new EmbeddedAddress();
	static final ParsedHostIdentifierStringQualifier NO_QUALIFIER = new ParsedHostIdentifierStringQualifier();
	private String normalizedLabels[];
	private int separatorIndices[];
	private boolean normalizedFlags[];
	private final ParsedHostIdentifierStringQualifier labelsQualifier;
	private String service;
	private EmbeddedAddress embeddedAddress;
	String host;
	private final String originalStr;
	public ParsedHost(String originalStr, IPAddressProvider valueProvider) {
		this(originalStr, null, null, NO_QUALIFIER, new EmbeddedAddress());
		embeddedAddress.addressProvider = valueProvider;
	}
	public ParsedHost(String originalStr, IPAddressProvider valueProvider, ParsedHostIdentifierStringQualifier portQualifier) {
		this(originalStr, null, null, portQualifier, new EmbeddedAddress());
		embeddedAddress.addressProvider = valueProvider;
	}
	ParsedHost(String originalStr, int separatorIndices[], boolean normalizedFlags[], ParsedHostIdentifierStringQualifier labelsQualifier) {
		this(originalStr, separatorIndices, normalizedFlags, labelsQualifier, null);
	}
	ParsedHost(String originalStr, int separatorIndices[], boolean normalizedFlags[], ParsedHostIdentifierStringQualifier labelsQualifier, EmbeddedAddress embeddedAddress) {
		this.labelsQualifier = labelsQualifier;
		this.normalizedFlags = normalizedFlags;
		this.separatorIndices = separatorIndices;
		this.originalStr = originalStr;
		this.embeddedAddress = embeddedAddress == null ? NO_EMBEDDED_ADDRESS : embeddedAddress;
	}
	static class EmbeddedAddress implements Serializable {
		private static final long serialVersionUID = 4L;
		boolean isUNCIPv6Literal;
		boolean isReverseDNS;
		AddressStringException addressStringException;
		IPAddressProvider addressProvider;
	}
	public boolean isIPv6Address() {
		return hasEmbeddedAddress() && getAddressProvider().isProvidingIPv6();
	}
	public Integer getPort() {
		return labelsQualifier.getPort();
	}
	public String getService() {
		String serv = service;
		if(serv == null) {	
			CharSequence sv = labelsQualifier.getService();
			if(sv != null) {
				service = serv = sv.toString();
			}
		}
		return serv;
	}
	public Integer getNetworkPrefixLength() {
		return labelsQualifier.getNetworkPrefixLength();
	}
	public Integer getEquivalentPrefixLength() {
		return labelsQualifier.getEquivalentPrefixLength();
	}
	public IPAddress getMask() {
		return labelsQualifier.getMaskLower();
	}
	public IPAddressProvider getAddressProvider() {
		return embeddedAddress.addressProvider;
	}
	private boolean hasEmbeddedAddress() {
		return embeddedAddress.addressProvider != null;
	}
	public boolean isAddressString() {
		return getAddressProvider() != null;
	}
	public IPAddress asAddress(IPVersion version) throws IncompatibleAddressException {
		if(hasEmbeddedAddress()) {
			return getAddressProvider().getProviderAddress(version);
		}
		return null;
	}
	public IPAddress asAddress() throws IncompatibleAddressException {
		if(hasEmbeddedAddress()) {
			return getAddressProvider().getProviderAddress();
		}
		return null;
	}
	private String mapString(IPAddressProvider addressProvider) {
		if(addressProvider.isProvidingAllAddresses()) {
			return IPAddress.SEGMENT_WILDCARD_STR;
		} else if(addressProvider.isProvidingPrefixOnly()) {
			return IPAddressNetwork.getPrefixString(addressProvider.getProviderNetworkPrefixLength());
		} else if(addressProvider.isProvidingEmpty()) {
			return "";
		}
		return originalStr;
	}
	public IPAddressString asGenericAddressString() {
		if(hasEmbeddedAddress()) {
			IPAddressProvider addressProvider = getAddressProvider();
			if(addressProvider.isProvidingAllAddresses()) {
				return new IPAddressString(IPAddress.SEGMENT_WILDCARD_STR, addressProvider.getParameters());
			} else if(addressProvider.isProvidingPrefixOnly()) {
				return new IPAddressString(IPAddressNetwork.getPrefixString(addressProvider.getProviderNetworkPrefixLength()), addressProvider.getParameters());
			} else if(addressProvider.isProvidingEmpty()) {
				return new IPAddressString("", addressProvider.getParameters());
			} else {
				try {
					IPAddress addr = addressProvider.getProviderAddress();
					return addr.toAddressString();
				} catch(IncompatibleAddressException e) {
					return new IPAddressString(originalStr, addressProvider.getParameters());
				}
			}
		}
		return null;
	}
	public String[] getNormalizedLabels() {
		String labels[] = normalizedLabels;
		if(labels == null) {
			synchronized(this) {
				labels = normalizedLabels;
				if(labels == null) {
					if(hasEmbeddedAddress()) {
						IPAddressProvider addressProvider = getAddressProvider();
						try {
							IPAddress addr = addressProvider.getProviderAddress();
							if(addr != null) {
								IPAddressSection section = addr.getSection();
								return normalizedLabels = section.getSegmentStrings();
							}
						} catch(IncompatibleAddressException e) {}
						if(addressProvider.isProvidingEmpty()) {
							labels = new String[0];
						} else {
							labels = new String[] {mapString(addressProvider)};
						}
					} else {
						labels = new String[separatorIndices.length];
						for(int i = 0, lastSep = -1; i < labels.length; i++) {
							int index = separatorIndices[i];
							if(normalizedFlags != null && !normalizedFlags[i]) {
								StringBuilder second = new StringBuilder((index - lastSep) - 1);
								for(int j = lastSep + 1; j < index; j++) {
									char c = originalStr.charAt(j);
									second.append((c >= 'A' && c <= 'Z') ? (char) (c + ('a' - 'A')) : c);
								}
								labels[i] = second.toString();
							} else {
								labels[i] = originalStr.substring(lastSep + 1, index);
							}
							lastSep = index;
						}
						separatorIndices = null;
						normalizedFlags = null;
					}
					normalizedLabels = labels;
				}
			}
		}
		return labels;
	}
	public String getHost() {
		String str = host;
		if(str == null) {
			if(originalStr.length() > 0) {
				synchronized(this) {
					str = host;
					if(str == null) {
						if(hasEmbeddedAddress()) {
							IPAddressProvider addressProvider = getAddressProvider();
							try {
								IPAddress addr = addressProvider.getProviderAddress();
								if(addr != null) {
									return host = addr.getSection().toCanonicalWildcardString();
								}
							} catch(IncompatibleAddressException e) {}
							return host = mapString(addressProvider);
						} else {
							StringBuilder builder = new StringBuilder(originalStr.length());
							String labels[] = getNormalizedLabels();
							builder.append(labels[0]);
							for(int i = 1; i < labels.length; i++) {
								builder.append(HostName.LABEL_SEPARATOR).append(labels[i]);
							}
							return host = builder.toString();
						}
					}
				}
			} else {
				str = host = originalStr;
			}
		}
		return str;
	}
	public AddressStringException getAddressStringException() {
		return embeddedAddress.addressStringException;
	}
	public boolean isUNCIPv6Literal() {
		return embeddedAddress.isUNCIPv6Literal;
	}
	public boolean isReverseDNS() {
		return embeddedAddress.isReverseDNS;
	}
}
package inet.ipaddr;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.math.BigInteger;
import java.net.InetAddress;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.TreeMap;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import inet.ipaddr.AddressComparator.ValueComparator;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.WildcardOptions.WildcardOption;
import inet.ipaddr.IPAddressSeqRange.IPAddressSeqRangeSplitterSink;
import inet.ipaddr.format.AddressComponentRange;
import inet.ipaddr.format.AddressDivisionSeries;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.standard.IPAddressBitsDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartConfiguredString;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.sql.IPAddressSQLTranslator;
import inet.ipaddr.format.util.sql.MySQLTranslator;
import inet.ipaddr.format.util.sql.SQLStringMatcher;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.format.validate.ParsedIPAddress.BitwiseOrer;
import inet.ipaddr.format.validate.ParsedIPAddress.Masker;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressSegment;
public abstract class IPAddressSection extends IPAddressDivisionGrouping implements IPAddressSegmentSeries, AddressSection {
	private static final long serialVersionUID = 4L;
	private static final IPAddressStringDivisionSeries EMPTY_PARTS[] = new IPAddressStringDivisionSeries[0];
	protected static class PrefixCache {
		private Integer networkMaskPrefixLen; 
		private Integer hostMaskPrefixLen; 
		private Integer cachedMinPrefix; 
		private Integer cachedEquivalentPrefix; 
		private Boolean cachedIsSinglePrefixBlock; 
	}
	private transient PrefixCache prefixCache;
	private transient BigInteger cachedNonzeroHostCount;
	protected IPAddressSection(IPAddressSegment segments[], boolean cloneSegments, boolean checkSegs) {
		super(cloneSegments ? segments.clone() : segments, false);
		if(checkSegs) {
			IPAddressNetwork<?, ?, ?, ?, ?> network = getNetwork();
			Integer previousSegmentPrefix = null;
			int bitsPerSegment = getBitsPerSegment();
			for(int i = 0; i < segments.length; i++) {
				IPAddressSegment segment = segments[i];
				if(!network.isCompatible(segment.getNetwork())) {
					throw new NetworkMismatchException(segment);
				}
				Integer segPrefix = segment.getSegmentPrefixLength();
				if(previousSegmentPrefix == null) {
					if(segPrefix != null) {
						cachedPrefixLength = cacheBits(getNetworkPrefixLength(bitsPerSegment, segPrefix, i));
					}
				} else if(segPrefix == null || segPrefix != 0) {
					throw new InconsistentPrefixException(segments[i - 1], segment, segPrefix);
				}
				previousSegmentPrefix = segPrefix;
			}
			if(previousSegmentPrefix == null) {
				cachedPrefixLength = NO_PREFIX_LENGTH;
			}
		}
	}
	protected void checkSegments(IPv6AddressSegment segs[]) {
		IPAddressNetwork<?, ?, ?, ?, ?> network = getNetwork();
		for(IPAddressSegment seg : segs) {
			if(!network.isCompatible(seg.getNetwork())) {
				throw new NetworkMismatchException(seg);
			}
		}
	}
	protected static String getMessage(String key) {
		return HostIdentifierException.getMessage(key);
	}
	protected void initCachedValues(
			Integer prefixLen,
			boolean network,
			Integer cachedNetworkPrefix,
			Integer cachedMinPrefix,
			Integer cachedEquivalentPrefix,
			BigInteger cachedCount,
			RangeList zeroSegments,
			RangeList zeroRanges) {
		if(prefixCache == null) {
			prefixCache = new PrefixCache();
		}
		if(network) {
			setNetworkMaskPrefix(prefixLen);
		} else {
			setHostMaskPrefix(prefixLen);
		}
		super.initCachedValues(cachedNetworkPrefix, cachedCount);
		prefixCache.cachedMinPrefix = cachedMinPrefix;
		prefixCache.cachedIsSinglePrefixBlock = Objects.equals(cachedEquivalentPrefix, cachedNetworkPrefix);
		prefixCache.cachedEquivalentPrefix = cachedEquivalentPrefix;
	}
	@Override
	public boolean isSinglePrefixBlock() {
		if(!hasNoPrefixCache() && prefixCache.cachedIsSinglePrefixBlock != null) {
			return prefixCache.cachedIsSinglePrefixBlock;
		}
		boolean result = super.isSinglePrefixBlock();
		prefixCache.cachedIsSinglePrefixBlock = result;
		if(result) {
			prefixCache.cachedEquivalentPrefix = getNetworkPrefixLength();
		}
		return result;
	}
	protected static RangeList getNoZerosRange() {
		return IPAddressDivisionGrouping.getNoZerosRange();
	}
	protected static RangeList getSingleRange(int index, int len) {
		return IPAddressDivisionGrouping.getSingleRange(index, len);
	}
	protected static boolean isCompatibleNetworks(AddressNetwork<?> one, AddressNetwork<?> two) {
		return AddressDivisionGrouping.isCompatibleNetworks(one, two);
	}
	@Override
	public int getBitCount() {
		return getSegmentCount() * getBitsPerSegment();
	}
	@Override
	public int getByteCount() {
		return getSegmentCount() * getBytesPerSegment();
	}
	@Override
	protected byte[] getBytesInternal() {
		return super.getBytesInternal();
	}
	public static int bitsPerSegment(IPVersion version) {
		return IPAddressSegment.getBitCount(version);
	}
	public static int bytesPerSegment(IPVersion version) {
		return IPAddressSegment.getBitCount(version);
	}
	protected long longCount(int segCount) {
		if(isMultiple()) {
			return longCount(this, segCount);
		}
		return 1L;
	}
	protected long longPrefixCount(int prefixLength) {
		if(isMultiple()) {
			return longPrefixCount(this, prefixLength);
		}
		return 1;
	}
	protected long longZeroHostCount(int prefixLength, int segCount) {
		if(includesZeroHost(prefixLength)) {
			if(isMultiple()) {
				int bitsPerSegment = getBitsPerSegment();
				int prefixedSegment = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), bitsPerSegment);
				long zeroHostCount = getLongCount(i -> {
					if(i == prefixedSegment) {
						IPAddressSegment seg = getSegment(i);
						int shift = seg.getBitCount() - getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
						int count = ((seg.getUpperSegmentValue() >>> shift) - (seg.getSegmentValue() >>> shift)) + 1;
						return count;
					}
					return getSegment(i).getValueCount();
				}, prefixedSegment + 1);
				return zeroHostCount;
			} else {
				return 1L;
			}
		}
		return 0L;
	}
	protected abstract BigInteger getZeroHostCountImpl(int prefixLength, int segCount);
	@Override
	public BigInteger getNonZeroHostCount() {
		if(isPrefixed() && getNetworkPrefixLength() < getBitCount()) {
			BigInteger cached = cachedNonzeroHostCount;
			if(cached == null) {
				cachedNonzeroHostCount = cached = getCount().subtract(getZeroHostCountImpl(getNetworkPrefixLength(), getSegmentCount()));
			}
			return cached;
		}
		return getCount();
	}
	protected abstract BigInteger getCountImpl(int segCount);
	@Override
	public BigInteger getCountImpl() {
		return getCountImpl(getSegmentCount());
	}
	@Override
	public BigInteger getBlockCount(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		int segCount = getSegmentCount();
		if(segmentCount > segCount) {
			segmentCount = segCount;
		}
		return getCountImpl(segmentCount);
	}
	public boolean isIPv4() {
		return false;
	}
	public boolean isIPv6() {
		return false;
	}
	@Override
	public int getMaxSegmentValue() {
		return IPAddressSegment.getMaxSegmentValue(getIPVersion());
	}
	protected static boolean isPrefixSubnetSegs(IPAddressSegment sectionSegments[], Integer networkPrefixLength, IPAddressNetwork<?, ?, ?, ?, ?> network, boolean fullRangeOnly) {
		int segmentCount = sectionSegments.length;
		if(segmentCount == 0) {
			return false;
		}
		IPAddressSegment seg = sectionSegments[0];
		return ParsedAddressGrouping.isPrefixSubnet(
				segmentIndex -> sectionSegments[segmentIndex].getSegmentValue(),
				segmentIndex -> sectionSegments[segmentIndex].getUpperSegmentValue(),
				segmentCount,
				seg.getByteCount(),
				seg.getBitCount(),
				seg.getMaxSegmentValue(),
				networkPrefixLength,
				network.getPrefixConfiguration(),
				fullRangeOnly);
	}
	protected boolean isNetworkSection(int networkPrefixLength, boolean withPrefixLength) {
		int segmentCount = getSegmentCount();
		if(segmentCount == 0) {
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int prefixedSegmentIndex = getNetworkSegmentIndex(networkPrefixLength, getBytesPerSegment(), bitsPerSegment);
		if(prefixedSegmentIndex + 1 < segmentCount) {
			return false; 
		}
		int segPrefLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, prefixedSegmentIndex);
		return !getSegment(segmentCount - 1).isNetworkChangedByPrefix(cacheBits(segPrefLength), withPrefixLength);
	}
	protected boolean isHostSection(int networkPrefixLength) {
		int segmentCount = getSegmentCount();
		if(segmentCount == 0) {
			return true;
		}
		if(networkPrefixLength >= getBitsPerSegment()) {
			return false;
		}
		return !getSegment(0).isHostChangedByPrefix(cacheBits(networkPrefixLength));
	}
	protected static int getNetworkSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getNetworkSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	protected static int getHostSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	private Integer checkForPrefixMask(boolean network) {
		int count = getSegmentCount();
		if(count == 0) {
			return null;
		}
		int front, back;
		int maxval = getSegment(0).getMaxSegmentValue();
		if(network) {
			front = maxval;
			back = 0;
		} else {
			back = maxval;
			front = 0;
		}
		int prefixLen = 0;
		for(int i=0; i < count; i++) {
			IPAddressSegment seg = getSegment(i);
			int value = seg.getSegmentValue();
			if(value != front) {
				Integer segmentPrefixLen = seg.getBlockMaskPrefixLength(network);
				if(segmentPrefixLen == null) {
					return null;
				}
				prefixLen += segmentPrefixLen;
				for(i++; i < count; i++) {
					value = getSegment(i).getSegmentValue();
					if(value != back) {
						return null;
					}
				}
			} else {
				prefixLen += seg.getBitCount();
			}
		}
		return cacheBits(prefixLen);
	}
	public Integer getBlockMaskPrefixLength(boolean network) {
		Integer prefixLen;
		if(network) {
			if(hasNoPrefixCache() || (prefixLen = prefixCache.networkMaskPrefixLen) == null) {
				prefixLen = setNetworkMaskPrefix(checkForPrefixMask(network));
			}
		} else {
			if(hasNoPrefixCache() || (prefixLen = prefixCache.hostMaskPrefixLen) == null) {
				prefixLen = setHostMaskPrefix(checkForPrefixMask(network));
			}
		}
		if(prefixLen < 0) {
			return null;
		}
		return prefixLen;
	}
	private Integer setHostMaskPrefix(Integer prefixLen) {
		if(prefixLen == null) {
			prefixLen = prefixCache.hostMaskPrefixLen = NO_PREFIX_LENGTH;
		} else {
			prefixCache.hostMaskPrefixLen = prefixLen;
			prefixCache.networkMaskPrefixLen = NO_PREFIX_LENGTH; 
		}
		return prefixLen;
	}
	private Integer setNetworkMaskPrefix(Integer prefixLen) {
		if(prefixLen == null) {
			prefixLen = prefixCache.networkMaskPrefixLen = NO_PREFIX_LENGTH;
		} else {
			prefixCache.networkMaskPrefixLen = prefixLen;
			prefixCache.hostMaskPrefixLen = NO_PREFIX_LENGTH; 
		}
		return prefixLen;
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment>
			R getNetworkSection(
					R original,
					int networkPrefixLength,
					boolean withPrefixLength,
					IPAddressCreator<T, R, ?, S, ?> creator,
					SegFunction<Integer, S> segProducer) {
		if(networkPrefixLength < 0 || networkPrefixLength > original.getBitCount()) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		if(original.isNetworkSection(networkPrefixLength, withPrefixLength)) {
			return original;
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int networkSegmentCount = original.getNetworkSegmentCount(networkPrefixLength);
		S result[] = creator.createSegmentArray(networkSegmentCount);
		for(int i = 0; i < networkSegmentCount; i++) {
			Integer prefix = getSegmentPrefixLength(bitsPerSegment, cacheBits(networkPrefixLength), i);
			result[i] = segProducer.apply(prefix, i);
		}
		return creator.createSectionInternal(result);
	}
	protected int getNetworkSegmentCount(int networkPrefixLength) {
		return getNetworkSegmentIndex(networkPrefixLength, getBytesPerSegment(), getBitsPerSegment()) + 1;
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> 
			R getHostSection(
					R original,
					int networkPrefixLength,
					int hostSegmentCount,
					IPAddressCreator<T, R, ?, S, ?> creator,
					SegFunction<Integer, S> segProducer) {
		if(networkPrefixLength < 0 || networkPrefixLength > original.getBitCount()) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		if(original.isHostSection(networkPrefixLength)) {
			return original;
		}
		int segmentCount = original.getSegmentCount();
		S result[] = creator.createSegmentArray(hostSegmentCount);
		if(hostSegmentCount > 0) {
			int bitsPerSegment = original.getBitsPerSegment();
			for(int i = hostSegmentCount - 1, j = segmentCount - 1; i >= 0; i--, j--) {
				Integer prefix = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, j);
				result[i] = segProducer.apply(prefix, j);
			}
		}
		return creator.createSectionInternal(result);
	}
	protected int getHostSegmentCount(int networkPrefixLength) {
		return getSegmentCount() - getHostSegmentIndex(networkPrefixLength, getBytesPerSegment(), getBitsPerSegment());
	}
	protected static Integer cacheBits(int i) {
		return AddressDivisionGrouping.cacheBits(i);
	}
	@FunctionalInterface
	public interface SegFunction<R, S> {
	    S apply(R addrItem, int value);
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R setPrefixLength(
			R original,
			IPAddressCreator<?, R, ?, S, ?> creator,
			int networkPrefixLength,
			boolean withZeros,
			boolean noShrink,
			boolean singleOnly,
			SegFunction<R, S> segProducer) throws IncompatibleAddressException {
		Integer existingPrefixLength = original.getNetworkPrefixLength();
		if(existingPrefixLength != null) {
			if(networkPrefixLength == existingPrefixLength.intValue()) {
				return original;
			} else if(noShrink && networkPrefixLength > existingPrefixLength.intValue()) {
				checkSubnet(original, networkPrefixLength);
				return original;
			}
		}
		checkSubnet(original, networkPrefixLength);
		IPAddressNetwork<?, R, ?, S, ?> network = creator.getNetwork();
		int maskBits;
		IntUnaryOperator segmentMaskProducer = null;
		if(network.getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			if(existingPrefixLength != null) {
				if(networkPrefixLength > existingPrefixLength.intValue()) {
					if(withZeros) {
						maskBits = existingPrefixLength;
					} else {
						maskBits = networkPrefixLength;
					}
				} else { 
					maskBits = networkPrefixLength;
				} 
			} else {
				maskBits = networkPrefixLength;
			}
		} else {
			if(existingPrefixLength != null) {
				if(withZeros) {
					R leftMask, rightMask;
					if(networkPrefixLength > existingPrefixLength.intValue()) {
						leftMask = network.getNetworkMaskSection(existingPrefixLength);
						rightMask = network.getHostMaskSection(networkPrefixLength);
					} else {
						leftMask = network.getNetworkMaskSection(networkPrefixLength);
						rightMask = network.getHostMaskSection(existingPrefixLength);
					}
					segmentMaskProducer = i -> {
						int val1 = segProducer.apply(leftMask, i).getSegmentValue();
						int val2 = segProducer.apply(rightMask, i).getSegmentValue();
						return val1 | val2;
					};
				}
			}
			maskBits = original.getBitCount();
		}
		if(segmentMaskProducer == null) {
			R mask = network.getNetworkMaskSection(maskBits);
			segmentMaskProducer = i -> segProducer.apply(mask, i).getSegmentValue();
		}
		return getSubnetSegments(
				original,
				cacheBits(networkPrefixLength),
				creator,
				true,
				i -> segProducer.apply(original, i),
				segmentMaskProducer,
				singleOnly);
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R getSubnetSegments(
			R original,
			Integer networkPrefixLength,
			IPAddressCreator<?, R, ?, S, ?> creator,
			boolean verifyMask,
			IntFunction<S> segProducer,
			IntUnaryOperator segmentMaskProducer,
			boolean singleOnly) {
		if(networkPrefixLength != null && (networkPrefixLength < 0 || networkPrefixLength > original.getBitCount())) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int count = original.getSegmentCount();
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && !singleOnly;
		for(int i = 0; i < count; i++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			S seg = segProducer.apply(i);
			int maskValue = segmentMaskProducer.applyAsInt(i);
			int value = seg.getSegmentValue(), upperValue = seg.getUpperSegmentValue();
			if(verifyMask) {
				if(isAllSubnets && segmentPrefixLength != null) {
					int hostMask = seg.getSegmentHostMask(segmentPrefixLength);
					maskValue |= hostMask;
				}
				Masker masker = IPAddressSegment.maskRange(value, upperValue, maskValue, seg.getMaxValue());
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
				}
				value = (int) masker.getMaskedLower(value, maskValue);
				upperValue = (int) masker.getMaskedUpper(upperValue, maskValue);
			} else {
				value &= maskValue;
				upperValue &= maskValue;
			}
			if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
				S newSegments[] = creator.createSegmentArray(original.getSegmentCount());
				original.getSegments(0, i, newSegments, 0);
				newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
				if(isAllSubnets && segmentPrefixLength != null) {
					if(++i < count) {
						S zeroSeg = creator.createSegment(0, cacheBits(0));
						Arrays.fill(newSegments, i, count, zeroSeg);
					}
				} else for(i++; i < count; i++) {
					segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
					seg  = segProducer.apply(i);
					maskValue = segmentMaskProducer.applyAsInt(i);
					value = seg.getSegmentValue();
					upperValue = seg.getUpperSegmentValue();
					if(verifyMask) {
						if(isAllSubnets && segmentPrefixLength != null) {
							int hostMask = seg.getSegmentHostMask(segmentPrefixLength);
							maskValue |= hostMask;
						}
						Masker masker = IPAddressSegment.maskRange(value, upperValue, maskValue, seg.getMaxValue());
						if(!masker.isSequential()) {
							throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
						}
						value = (int) masker.getMaskedLower(value, maskValue);
						upperValue = (int) masker.getMaskedUpper(upperValue, maskValue);
					} else {
						value &= maskValue;
						upperValue &= maskValue;
					}
					if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
						newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
					} else {
						newSegments[i] = seg;
					}
					if(isAllSubnets && segmentPrefixLength != null) {
						if(++i < count) {
							S zeroSeg = creator.createSegment(0, cacheBits(0));
							Arrays.fill(newSegments, i, count, zeroSeg);
						}
						break;
					}
				}
				return creator.createPrefixedSectionInternal(newSegments, networkPrefixLength, singleOnly);
			}
		}
		return original;
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R getOredSegments(
			R original,
			Integer networkPrefixLength,
			IPAddressCreator<?, R, ?, S, ?> creator,
			boolean verifyMask,
			IntFunction<S> segProducer,
			IntUnaryOperator segmentMaskProducer) {
		if(networkPrefixLength != null && (networkPrefixLength < 0 || networkPrefixLength > original.getBitCount())) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int count = original.getSegmentCount();
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		for(int i = 0; i < count; i++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			S seg = segProducer.apply(i);
			int maskValue = segmentMaskProducer.applyAsInt(i);
			int value = seg.getSegmentValue(), upperValue = seg.getUpperSegmentValue();
			if(verifyMask) {
				if(isAllSubnets && segmentPrefixLength != null) {
					int networkMask = seg.getSegmentNetworkMask(segmentPrefixLength);
					maskValue &= networkMask;
				}
				BitwiseOrer masker = IPAddressSegment.bitwiseOrRange(value, upperValue, maskValue, seg.getMaxValue());
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
				}
				value = (int) masker.getOredLower(value, maskValue);
				upperValue = (int) masker.getOredUpper(upperValue, maskValue);
			} else {
				value |= maskValue;
				upperValue |= maskValue;
			}
			if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
				S newSegments[] = creator.createSegmentArray(original.getSegmentCount());
				original.getSegments(0, i, newSegments, 0);
				newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
				if(isAllSubnets && segmentPrefixLength != null) {
					if(++i < count) {
						S zeroSeg = creator.createSegment(0, cacheBits(0));
						Arrays.fill(newSegments, i, count, zeroSeg);
					}
				} else for(i++; i < count; i++) {
					segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
					seg  = segProducer.apply(i);
					maskValue = segmentMaskProducer.applyAsInt(i);
					value = seg.getSegmentValue();
					upperValue = seg.getUpperSegmentValue();
					if(verifyMask) {
						if(isAllSubnets && segmentPrefixLength != null) {
							int networkMask = seg.getSegmentNetworkMask(segmentPrefixLength);
							maskValue &= networkMask;
						}
						BitwiseOrer masker = IPAddressSegment.bitwiseOrRange(value, upperValue, maskValue, seg.getMaxValue());
						if(!masker.isSequential()) {
							throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
						}
						value = (int) masker.getOredLower(value, maskValue);
						upperValue = (int) masker.getOredUpper(upperValue, maskValue);
					} else {
						value |= maskValue;
						upperValue |= maskValue;
					}
					if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
						newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
					} else {
						newSegments[i] = seg;
					}
					if(isAllSubnets && segmentPrefixLength != null) {
						if(++i < count) {
							S zeroSeg = creator.createSegment(0, cacheBits(0));
							Arrays.fill(newSegments, i, count, zeroSeg);
						}
						break;
					}
				}
				return creator.createPrefixedSectionInternal(newSegments, networkPrefixLength);
			}
		}
		return original;
	}
	protected static void checkSubnet(AddressDivisionSeries series, int prefixLength) throws PrefixLenException {
		AddressDivisionGrouping.checkSubnet(series, prefixLength);
	}
	protected static Integer getSegmentPrefixLength(int bitsPerSegment, Integer prefixLength, int segmentIndex) {
		return AddressDivisionGrouping.getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected static Integer getSegmentPrefixLength(int bitsPerSegment, int segmentPrefixedBits) {
		return AddressDivisionGrouping.getSegmentPrefixLength(bitsPerSegment, segmentPrefixedBits);
	}
	protected static Integer getPrefixedSegmentPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		return AddressDivisionGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R createLowestOrHighestSection(
			R section,
			IPAddressCreator<?, R, ?, S, ?> creator,
			Supplier<Iterator<S[]>> nonZeroHostIteratorSupplier,
			IntFunction<S> segProducer,
			boolean lowest,
			boolean excludeZeroHost) {
		boolean create = true;
		R result = null;
		S[] segs = null;
		if(lowest && excludeZeroHost && section.includesZeroHost()) {
			Iterator<S[]> it = nonZeroHostIteratorSupplier.get();
			if(!it.hasNext()) {
				create = false;
			} else {
				segs = it.next();
			}
		} else {
			segs = createSingle(section, creator, segProducer);
		}
		if(create) {
			Integer prefLength;
			result = section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() || (prefLength = section.getNetworkPrefixLength()) == null ? 
				creator.createSectionInternal(segs) :
				creator.createPrefixedSectionInternal(segs, prefLength, true);
		}
		return result;
	}
	@Override
	public int getSegmentCount() {
		return getDivisionCount();
	}
	@Override
	public IPAddressSegment getSegment(int index) {
		return getSegmentsInternal()[index];
	}
	@Override
	public IPAddressSegment getDivision(int index) {
		return getSegmentsInternal()[index];
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		checkSubnet(this, prefixLength);
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(isAllSubnets && isPrefixed() && getNetworkPrefixLength() <= prefixLength) {
			return true;
		}
		int divCount = getDivisionCount();
		int bitsPerSegment = getBitsPerSegment();
		int i = getHostSegmentIndex(prefixLength, getBytesPerSegment(), bitsPerSegment);
		if(i < divCount) {
			IPAddressSegment div = getDivision(i);
			int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
			if(!div.containsPrefixBlock(segmentPrefixLength)) {
				return false;
			}
			if(isAllSubnets && div.isPrefixed()) {
				return true;
			}
			for(++i; i < divCount; i++) {
				div = getDivision(i);
				if(!div.isFullRange()) {
					return false;
				}
				if(isAllSubnets && div.isPrefixed()) {
					return true;
				}
			}
		}
		return true;
	}
	static boolean containsPrefixBlock(int prefixLength, IPAddressSegmentSeries lower, IPAddressSegmentSeries upper) {
		checkSubnet(lower, prefixLength);
		int divCount = lower.getDivisionCount();
		int bitsPerSegment = lower.getBitsPerSegment();
		int i = getHostSegmentIndex(prefixLength, lower.getBytesPerSegment(), bitsPerSegment);
		if(i < divCount) {
			IPAddressSegment div = lower.getSegment(i);
			IPAddressSegment upperDiv = upper.getSegment(i);
			int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
			if(!div.containsPrefixBlock(div.getSegmentValue(), upperDiv.getSegmentValue(), segmentPrefixLength)) {
				return false;
			}
			for(++i; i < divCount; i++) {
				div = lower.getSegment(i);
				upperDiv = upper.getSegment(i);
				if(!div.includesZero() || !upperDiv.includesMax()) {
					return false;
				}
			}
		}
		return true;
	}
	static boolean containsSinglePrefixBlock(int prefixLength, IPAddressSegmentSeries lower, IPAddressSegmentSeries upper) {
		checkSubnet(lower, prefixLength);
		int prevBitCount = 0;
		int divCount = lower.getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressSegment div = lower.getSegment(i);
			IPAddressSegment upperDiv = upper.getSegment(i);
			int bitCount = div.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength >= totalBitCount) {
				if(!div.isSameValues(upperDiv)) {
					return false;
				}
			} else  {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!div.containsSinglePrefixBlock(div.getSegmentValue(), upperDiv.getSegmentValue(), divPrefixLen)) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = lower.getSegment(i);
					upperDiv = upper.getSegment(i);
					if(!div.includesZero() || !upperDiv.includesMax()) {
						return false;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	@Override
	public boolean contains(AddressSection other) {
		int count = getSegmentCount();
		if(count != other.getSegmentCount()) {
			return false;
		}
		boolean prefixIsSubnet = isPrefixed() && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		int endIndex = prefixIsSubnet ? 
				getNetworkSegmentIndex(getNetworkPrefixLength(), getBytesPerSegment(), getBitsPerSegment()) :
					count - 1;
		for(int i = endIndex; i >= 0; i--) {
			IPAddressSegment seg = getSegment(i);
			if(!seg.contains(other.getSegment(i))) {
				return false;
			}
		}
		return true;
	}
	public boolean containsNonZeroHosts(IPAddressSection other) {
		if(!other.isPrefixed()) {
			return contains(other);
		}
		int otherPrefixLength = other.getNetworkPrefixLength();
		if(otherPrefixLength  == other.getBitCount()) {
			return contains(other);
		}
		return containsNonZeroHostsImpl(other, otherPrefixLength);
	}
	protected abstract boolean containsNonZeroHostsImpl(IPAddressSection other, int otherPrefixLength);
	public abstract boolean prefixContains(IPAddressSection other);
	@Override
	public boolean isFullRange() {
		int divCount = getDivisionCount();
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			for(int i = 0; i < divCount; i++) {
				IPAddressSegment div = getSegment(i);
				if(!div.isFullRange()) {
					return false;
				}
				Integer prefix = div.getSegmentPrefixLength();
				if(prefix != null) {
					break;
				}
			}
		} else return super.isFullRange();
		return true;
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R intersect(
			R first,
			R other,
			IPAddressCreator<T, R, ?, S, ?> addrCreator,
			IntFunction<S> segProducer,
			IntFunction<S> otherSegProducer) {
		first.checkSegmentCount(other);
		Integer pref = first.getNetworkPrefixLength();
		Integer otherPref = other.getNetworkPrefixLength();
		if(pref != null) {
			if(otherPref != null) {
				if(otherPref > pref) {
					pref = otherPref;
				}
			} else {
				pref = null;
			}
		}
		if(other.contains(first)) {
			if(Objects.equals(pref, first.getNetworkPrefixLength())) {
				return first;
			}
		} else if(!first.isMultiple()) {
			return null;
		}
		if(first.contains(other)) {
			if(Objects.equals(pref, other.getNetworkPrefixLength())) {
				return other;
			}
		} else if(!other.isMultiple()) {
			return null;
		}
		int segCount = first.getSegmentCount();
		for(int i = 0; i < segCount; i++) {
			IPAddressSegment seg = first.getSegment(i);
			IPAddressSegment otherSeg = other.getSegment(i);
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			if(otherLower > higher || lower > otherHigher) {
				return null;
			}
		}
		S segs[] = addrCreator.createSegmentArray(segCount);
		for(int i = 0; i < segCount; i++) {
			S seg = segProducer.apply(i);
			S otherSeg = otherSegProducer.apply(i);
			Integer segPref = getSegmentPrefixLength(seg.getBitCount(), pref, i);
			if(seg.contains(otherSeg)) {
				if(!otherSeg.isChangedByPrefix(segPref, false)) {
					segs[i] = otherSeg;
					continue;
				}
			}
			if(otherSeg.contains(seg)) {
				if(!seg.isChangedByPrefix(segPref, false)) {
					segs[i] = seg;
					continue;
				}
			}
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			int newLower = Math.max(lower, otherLower);
			int newHigher = Math.min(higher, otherHigher);
			segs[i] = addrCreator.createSegment(newLower, newHigher, segPref);
		}
		R result = addrCreator.createSection(segs);
		return result;
	}
	@FunctionalInterface
	public interface TriFunction<R, S> {
	    S apply(R addrItem, R addrItem2, R addrItem3);
	}
	static <R extends IPAddressSegmentSeries, OperatorResult> OperatorResult applyOperatorToLowerUpper(
			R first,
			R other,
			UnaryOperator<R> getLower,
			UnaryOperator<R> getUpper,
			Comparator<R> comparator,
			Function<R, R> prefixRemover,
			TriFunction<R, OperatorResult> operatorFunctor) {
		R lower, upper;
		boolean isFirst, isOther;
		isFirst = isOther = true;
		if(first.equals(other)) {
			if(prefixRemover != null && first.isPrefixed()) {
				if(other.isPrefixed()) {
					lower = prefixRemover.apply(first);
					isOther = isFirst = false;
				} else {
					lower = other;
					isFirst = false;
				}
			} else {
				isOther = false;
				lower = first;
			}
			upper = getUpper.apply(lower);
			lower = getLower.apply(lower);
		} else {
			R firstLower = getLower.apply(first);
			R otherLower = getLower.apply(other);
			R firstUpper = getUpper.apply(first);
			R otherUpper = getUpper.apply(other);
			if(comparator.compare(firstLower, otherLower) > 0) {
				lower = otherLower;
				isFirst = false;
			} else {
				lower = firstLower;
				isOther = false;
			}
			if(comparator.compare(firstUpper, otherUpper) < 0) {
				upper = otherUpper;
				isFirst = false;
			} else {
				upper = firstUpper;
				isOther = false;
			}
			if(prefixRemover != null) {
				lower = prefixRemover.apply(lower);
				upper = prefixRemover.apply(upper);
			}
		}
		return operatorFunctor.apply(isFirst ? first : (isOther ? other : null), lower, upper);
	}
	@SuppressWarnings("unchecked")
	protected static <T extends IPAddressSegmentSeries> T coverWithPrefixBlock(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator) throws AddressConversionException {
		return (T)
				IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, null, 
						IPAddressSection::coverWithPrefixBlock);
	}
	protected static IPAddressSegmentSeries coverWithPrefixBlock(
			IPAddressSegmentSeries original,
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper) {
		int segCount = lower.getSegmentCount();
		int bitsPerSegment = lower.getBitsPerSegment();
		int currentSegment = 0, previousSegmentBits = 0;
		for(; currentSegment < segCount; currentSegment++) {
			IPAddressSegment lowerSeg = lower.getSegment(currentSegment);
			IPAddressSegment upperSeg = upper.getSegment(currentSegment);
			int lowerValue = lowerSeg.getSegmentValue();
			int upperValue = upperSeg.getSegmentValue();
			int differing = lowerValue ^ upperValue;
			if(differing != 0) {
				int highestDifferingBitInRange = Integer.numberOfLeadingZeros(differing) - (Integer.SIZE - bitsPerSegment);
				int differingBitPrefixLen = highestDifferingBitInRange + previousSegmentBits;
				return (original != null ? original : lower).toPrefixBlock(differingBitPrefixLen);
			}
			previousSegmentBits += bitsPerSegment;
		}
		return (original != null ? original : lower).toPrefixBlock(lower.getBitCount());
	}
	private static <R extends IPAddressSection> R[] checkSequentialBlockContainment(
			R first,
			R other,
			UnaryOperator<R> prefixRemover,
			IntFunction<R[]> arrayProducer) {
		if(first.contains(other)) {
			return IPAddress.checkSequentialBlockFormat(first, other, true, prefixRemover, arrayProducer);
		} else if(other.contains(first)) {
			return IPAddress.checkSequentialBlockFormat(other, first, false, prefixRemover, arrayProducer);
		}
		return null;
	}
	private static <R extends IPAddressSection> R checkPrefixBlockContainment(
			R first,
			R other,
			UnaryOperator<R> prefixAdder) {
		if(first.contains(other)) {
			return IPAddress.checkPrefixBlockFormat(first, other, true, prefixAdder);
		} else if(other.contains(first)) {
			return IPAddress.checkPrefixBlockFormat(other, first, false, prefixAdder);
		}
		return null;
	}
	protected static <R extends IPAddressSection> R[] getSpanningPrefixBlocks(
			R first,
			R other,
			UnaryOperator<R> getLower,
			UnaryOperator<R> getUpper,
			Comparator<R> comparator,
			UnaryOperator<R> prefixAdder,
			UnaryOperator<R> prefixRemover,
			IntFunction<R[]> arrayProducer) {
		first.checkSegmentCount(other);
		R result = checkPrefixBlockContainment(first, other, prefixAdder);
		if(result != null) {
			R resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		List<IPAddressSegmentSeries> blocks = applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, (orig, lower, upper) -> IPAddressSection.splitIntoPrefixBlocks(lower, upper));
		R resultArray[] = blocks.toArray(arrayProducer.apply(blocks.size()));
		return resultArray;
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R[] getSpanningSequentialBlocks(
			R first,
			R other,
			UnaryOperator<R> getLower,
			UnaryOperator<R> getUpper,
			Comparator<R> comparator,
			UnaryOperator<R> prefixRemover,
			IPAddressCreator<?, R, ?, S, ?> creator) {
		R[] result = checkSequentialBlockContainment(first, other, prefixRemover, creator::createSectionArray);
		if(result != null) {
			return result;
		}
		TriFunction<R, List<IPAddressSegmentSeries>> operatorFunctor = (orig, one, two) -> IPAddressSection.splitIntoSequentialBlocks(one, two, creator::createSequentialBlockSection);
		List<IPAddressSegmentSeries> blocks = applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, operatorFunctor);
		return blocks.toArray(creator.createSectionArray(blocks.size()));
	}
	@FunctionalInterface
	public interface SeriesCreator {
		IPAddressSegmentSeries apply(IPAddressSegmentSeries segmentSeries, int index, int lowerVal, int upperVal);
	}
	static List<IPAddressSegmentSeries> splitIntoSequentialBlocks(
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper,
			SeriesCreator seriesCreator) {
		ArrayList<IPAddressSegmentSeries> blocks = new ArrayList<>(IPv6Address.SEGMENT_COUNT);
		int segCount = lower.getSegmentCount();
		if(segCount == 0) {
			blocks.add(lower);
			return blocks;
		}
		int previousSegmentBits = 0, currentSegment = 0;
		int bitsPerSegment = lower.getBitsPerSegment();
		int segSegment;
		int lowerValue, upperValue;
		SeriesStack stack = null;
		Deque<IPAddressSegmentSeries> toAdd = null;
		while(true) {
			do {
				segSegment = currentSegment;
				IPAddressSegment lowerSeg = lower.getSegment(currentSegment);
				IPAddressSegment upperSeg = upper.getSegment(currentSegment++);
				lowerValue = lowerSeg.getSegmentValue();
				upperValue = upperSeg.getSegmentValue();
				previousSegmentBits += bitsPerSegment;
			} while(lowerValue == upperValue && currentSegment < segCount);
			if(lowerValue == upperValue) {
				blocks.add(lower);
			} else {	
				boolean lowerIsLowest = lower.includesZeroHost(previousSegmentBits);
				boolean higherIsHighest = upper.includesMaxHost(previousSegmentBits);
				if(lowerIsLowest) {
					if(higherIsHighest) {
						IPAddressSegmentSeries series = seriesCreator.apply(lower, segSegment, lowerValue, upperValue);
						blocks.add(series);
					} else {
						IPAddressSegmentSeries topLower = upper.toZeroHost(previousSegmentBits);
						IPAddressSegmentSeries middleUpper = topLower.increment(-1);
						IPAddressSegmentSeries series = seriesCreator.apply(lower, segSegment, lowerValue, middleUpper.getSegment(segSegment).getSegmentValue());
						blocks.add(series);
						lower = topLower;
						continue;
					}
				} else if(higherIsHighest) {
					IPAddressSegmentSeries bottomUpper = lower.toMaxHost(previousSegmentBits);
					IPAddressSegmentSeries topLower = bottomUpper.increment(1);
					IPAddressSegmentSeries series = seriesCreator.apply(topLower, segSegment, topLower.getSegment(segSegment).getSegmentValue(), upperValue);
					if(toAdd == null) {
						toAdd = new ArrayDeque<>(IPv6Address.SEGMENT_COUNT);
					}
					toAdd.addFirst(series);
					upper = bottomUpper;
					continue;
				} else {	
					IPAddressSegmentSeries topLower = upper.toZeroHost(previousSegmentBits);
					IPAddressSegmentSeries middleUpper = topLower.increment(-1);
					IPAddressSegmentSeries bottomUpper = lower.toMaxHost(previousSegmentBits);
					IPAddressSegmentSeries middleLower = bottomUpper.increment(1);
					if(middleLower.compareTo(middleUpper) <= 0) {
						IPAddressSegmentSeries series = seriesCreator.apply(middleLower, segSegment, middleLower.getSegment(segSegment).getSegmentValue(), middleUpper.getSegment(segSegment).getSegmentValue());
						if(toAdd == null) {
							toAdd = new ArrayDeque<>(IPv6Address.SEGMENT_COUNT);
						}
						toAdd.addFirst(series);
					}
					if(stack == null) {
						stack = new SeriesStack(IPv6Address.SEGMENT_COUNT);
					}
					stack.push(topLower, upper, previousSegmentBits, currentSegment); 
					upper = bottomUpper;
					continue;
				}
			}
			if(toAdd != null) {
				while(true) {
					IPAddressSegmentSeries saved = toAdd.pollFirst();
					if(saved == null) {
						break;
					}
					blocks.add(saved);
				}
			}
			if(stack == null || !stack.pop()) {
				return blocks;
			}
			lower = stack.lower;
			upper = stack.upper;
			previousSegmentBits = stack.previousSegmentBits;
			currentSegment = stack.currentSegment;
		}
	}
	static class SeriesStack {
		int stackSize;
		int top; 
		int capacity;
		IPAddressSegmentSeries seriesPairs[]; 
		int indexPairs[]; 
		IPAddressSegmentSeries lower, upper; 
		int previousSegmentBits, currentSegment; 
		SeriesStack(int initialCapacity) {
			this.capacity = 2 * initialCapacity;
		}
		void push(IPAddressSegmentSeries lower, IPAddressSegmentSeries upper, int previousSegmentBits, int currentSegment) {
			int top = this.top;
			if(top >= stackSize) {
				resize();
			}
			IPAddressSegmentSeries seriesPairs[] = this.seriesPairs;
			int indexPairs[] = this.indexPairs;
			seriesPairs[top] = lower;
			indexPairs[top++] = previousSegmentBits;
			seriesPairs[top] = upper;
			indexPairs[top++] = currentSegment;
			this.top = top;
		}
		boolean pop() {
			if(top <= 0) {
				return false;
			}
			IPAddressSegmentSeries seriesPairs[] = this.seriesPairs;
			int indexPairs[] = this.indexPairs;
			int top = this.top;
			currentSegment = indexPairs[--top];
			upper = seriesPairs[top];
			previousSegmentBits = indexPairs[--top];
			lower = seriesPairs[top];
			this.top = top;
			return true;
		}
		void resize() {
			int size = stackSize;
			if(size == 0) {
				size = capacity;
			} else {
				size <<= 1; 
			}
			IPAddressSegmentSeries newSeriesPairs[] = new IPAddressSegmentSeries[size];
			int newIndexPairs[] = new int[size];
			if(top > 0) {
				System.arraycopy(seriesPairs, 0, newSeriesPairs, 0, top);
				System.arraycopy(indexPairs, 0, newIndexPairs, 0, top);
			}
			seriesPairs = newSeriesPairs;
			indexPairs = newIndexPairs;
			stackSize = size;
		}
	}
	static List<IPAddressSegmentSeries> splitIntoPrefixBlocks(
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper) {
		ArrayList<IPAddressSegmentSeries> blocks = new ArrayList<>();
		int previousSegmentBits = 0, currentSegment = 0;
		SeriesStack stack = null;
		while(true) {
			int differing = 0;
			int segCount = lower.getSegmentCount();
			int bitsPerSegment = lower.getBitsPerSegment();
			for(; currentSegment < segCount; currentSegment++) {
				IPAddressSegment lowerSeg = lower.getSegment(currentSegment);
				IPAddressSegment upperSeg = upper.getSegment(currentSegment);
				int lowerValue = lowerSeg.getSegmentValue();
				int upperValue = upperSeg.getSegmentValue();
				differing = lowerValue ^ upperValue;
				if(differing != 0) {
					break;
				}
				previousSegmentBits += bitsPerSegment;
			}
			if(differing == 0) {
				blocks.add(lower.toPrefixBlock(lower.getBitCount()));
			} else {
				boolean differingIsLowestBit = (differing == 1);
				if(differingIsLowestBit && currentSegment + 1 == segCount) {
					blocks.add(lower.toPrefixBlock(lower.getBitCount() - 1));
				} else {
					int highestDifferingBitInRange = Integer.numberOfLeadingZeros(differing) - (Integer.SIZE - bitsPerSegment);
					int differingBitPrefixLen = highestDifferingBitInRange + previousSegmentBits;
					if(lower.includesZeroHost(differingBitPrefixLen) && upper.includesMaxHost(differingBitPrefixLen)) {
						blocks.add(lower.toPrefixBlock(differingBitPrefixLen));
					} else {
						IPAddressSegmentSeries lowerTop = upper.toZeroHost(differingBitPrefixLen + 1);
						IPAddressSegmentSeries upperBottom = lowerTop.increment(-1);
						if(differingIsLowestBit) {
							previousSegmentBits += bitsPerSegment;
							currentSegment++;
						}
						if(stack == null) {
							stack = new SeriesStack(IPv6Address.BIT_COUNT);
						}
						stack.push(lowerTop, upper, previousSegmentBits, currentSegment); 
						upper = upperBottom; 
						continue;
					}
				}
			}
			if(stack == null || !stack.pop()) {
				return blocks;
			}
			lower = stack.lower;
			upper = stack.upper;
			previousSegmentBits = stack.previousSegmentBits;
			currentSegment = stack.currentSegment;
		}
	}
	static final Comparator<? super IPAddressSegmentSeries> mergeListComparator = (one, two) ->  {
		Integer prefix1 = one.getPrefixLength();
		Integer prefix2 = two.getPrefixLength();
		int comparison = (prefix1 == prefix2) ? 0 : ((prefix1 == null) ? -1 : ((prefix2 == null) ? 1 : prefix2.compareTo(prefix1)));
		if(comparison != 0) {
			return comparison;
		}
		if(prefix1 == null || prefix1 != 0) {
			int networkSegIndex = (prefix1 == null) ? one.getSegmentCount() - 1 : getNetworkSegmentIndex(prefix1, one.getBytesPerSegment(), one.getBitsPerSegment());
			int hostSegIndex = (prefix1 == null) ? one.getSegmentCount() : getHostSegmentIndex(prefix1, one.getBytesPerSegment(), one.getBitsPerSegment());
			for(int i = 0; i < hostSegIndex; i++) {
				AddressSegment segOne = one.getSegment(i);
				AddressSegment segTwo = two.getSegment(i);
				int oneValue = segOne.getSegmentValue();
				int twoValue = segTwo.getSegmentValue();
				int oneUpperValue = segOne.getUpperSegmentValue();
				int twoUpperValue = segTwo.getUpperSegmentValue();
				comparison = (oneUpperValue - oneValue) - (twoUpperValue - twoValue);
				if(comparison != 0) {
					return comparison;
				}
			}
			for(int i = 0; i <= networkSegIndex; i++) {
				AddressSegment segOne = one.getSegment(i);
				AddressSegment segTwo = two.getSegment(i);
				int oneValue = segOne.getSegmentValue();
				int twoValue = segTwo.getSegmentValue();
				comparison = oneValue - twoValue;
				if(comparison != 0) {
					return comparison;
				}
			}
		}
		return comparison;
	};
	private static final ValueComparator REVERSE_LOW_COMPARATOR = new ValueComparator(true, false, true);
	private static final ValueComparator REVERSE_HIGH_COMPARATOR = new ValueComparator(true, true, true);
	protected static List<IPAddressSegmentSeries> getMergedSequentialBlocks(IPAddressSegmentSeries sections[], SeriesCreator seriesCreator) {
		ArrayList<IPAddressSegmentSeries> list = new ArrayList<>(sections.length << 1);
		boolean singleElement = organizeSequentialMerge(sections, list);
		if(singleElement) {
			list.set(0, list.get(0).withoutPrefixLength());
			return list;
		}
		ValueComparator reverseLowComparator = REVERSE_LOW_COMPARATOR;
		ValueComparator reverseHighComparator = REVERSE_HIGH_COMPARATOR;
		int removedCount = 0;
		int j = list.size() - 1, i = j - 1;
		int ithRangeSegmentIndex = -1, jthRangeSegmentIndex = -1;
		top:
		while(j > 0) {
			IPAddressSegmentSeries item = list.get(i);
			IPAddressSegmentSeries otherItem = list.get(j);
			int compare = reverseHighComparator.compare(item, otherItem);
			if(compare > 0) {
				removedCount++;
				int k = j + 1;
				while(k < list.size() && list.get(k) == null) {
					k++;
				}
				if(k < list.size()) {
					list.set(j, list.get(k));
					list.set(k, null);
					jthRangeSegmentIndex = -1;
				} else {
					list.set(j, null);
					j = i;
					i--;
					jthRangeSegmentIndex = ithRangeSegmentIndex;
					ithRangeSegmentIndex = -1;
				}
				continue;
			}
			int rcompare = reverseLowComparator.compare(item, otherItem);
			if(rcompare >= 0) {
				removedCount++;
				list.set(i, otherItem);
				list.set(j, null);
				j = i;
				i--;
				jthRangeSegmentIndex = ithRangeSegmentIndex;
				ithRangeSegmentIndex = -1;
				continue;
			}
			if(ithRangeSegmentIndex < 0) {
				ithRangeSegmentIndex = item.getSequentialBlockIndex();
			}
			if(jthRangeSegmentIndex < 0) {
				jthRangeSegmentIndex = otherItem.getSequentialBlockIndex();
			}
			if(ithRangeSegmentIndex != jthRangeSegmentIndex) {
				j = i;
				i--;
				jthRangeSegmentIndex = ithRangeSegmentIndex;
				ithRangeSegmentIndex = -1;
				continue;
			}
			IPAddressSegment rangeSegment = item.getSegment(ithRangeSegmentIndex);
			IPAddressSegment otherRangeSegment = otherItem.getSegment(ithRangeSegmentIndex);
			int otherRangeItemValue = otherRangeSegment.getSegmentValue();
			int rangeItemUpperValue = rangeSegment.getUpperSegmentValue();
			if(rangeItemUpperValue < otherRangeItemValue && rangeItemUpperValue + 1 != otherRangeItemValue) {
				j = i;
				i--;
				ithRangeSegmentIndex = -1;
				continue;
			}
			for(int k = ithRangeSegmentIndex - 1; k >= 0; k--) {
				IPAddressSegment itemSegment = item.getSegment(k);
				IPAddressSegment otherItemSegment = otherItem.getSegment(k);
				int val = itemSegment.getSegmentValue();
				int otherVal = otherItemSegment.getSegmentValue();
				if(val != otherVal) {
					j = i;
					i--;
					ithRangeSegmentIndex = -1;
					continue top;
				}
			}
			IPAddressSegmentSeries joinedItem = seriesCreator.apply(
					item,
					ithRangeSegmentIndex,
					rangeSegment.getSegmentValue(),
					Math.max(rangeItemUpperValue, otherRangeSegment.getUpperSegmentValue()));
			list.set(i, joinedItem);
			if(joinedItem.getSegment(ithRangeSegmentIndex).isFullRange()) {
				if(ithRangeSegmentIndex == 0) {
					list.clear();
					list.add(joinedItem);
					return list;
				}
				ithRangeSegmentIndex--;
			}
			removedCount++;
			int k = j + 1;
			while(k < list.size() && list.get(k) == null) {
				k++;
			}
			if(k < list.size()) {
				list.set(j, list.get(k));
				list.set(k, null);
				jthRangeSegmentIndex = -1;
			} else {
				list.set(j, null);
				j = i;
				i--;
				jthRangeSegmentIndex = ithRangeSegmentIndex;
				ithRangeSegmentIndex = -1;
			}
		}
		if(removedCount > 0) {
			int newSize = list.size() - removedCount;
			for(int k = 0, l = 0; k < newSize; k++, l++) {
				while(list.get(l) == null) {
					l++;
				}
				list.set(k, list.get(l).withoutPrefixLength());
			}
			int last = list.size();
			while(removedCount-- > 0) {
				list.remove(--last);
			}
		} else for(int n = 0; n < list.size(); n++) {
			list.set(n, list.get(n).withoutPrefixLength());
		}
		return list;
	}
	protected static List<IPAddressSegmentSeries> getMergedPrefixBlocks(IPAddressSegmentSeries sections[]) {
		ArrayList<IPAddressSegmentSeries> list = new ArrayList<>(sections.length << 3);
		boolean singleElement = organizeSequentially(sections, list);
		if(singleElement) {
			return list;
		}
		ValueComparator reverseLowComparator = REVERSE_LOW_COMPARATOR;
		ValueComparator reverseHighComparator = REVERSE_HIGH_COMPARATOR;
		IPAddressSegmentSeries first = sections[0];
		int bitCount = first.getBitCount();
		int bitsPerSegment = first.getBitsPerSegment();
		int bytesPerSegment = first.getBytesPerSegment();
		int removedCount = 0;
		int j = list.size() - 1, i = j - 1;
		top:
		while(j > 0) {
			IPAddressSegmentSeries item = list.get(i);
			IPAddressSegmentSeries otherItem = list.get(j);
			int compare = reverseHighComparator.compare(item, otherItem);
			if(compare > 0) {
				removedCount++;
				int k = j + 1;
				while(k < list.size() && list.get(k) == null) {
					k++;
				}
				if(k < list.size()) {
					list.set(j, list.get(k));
					list.set(k, null);
				} else {
					list.set(j, null);
					j = i;
					i--;
				}
				continue;
			}
			int rcompare = reverseLowComparator.compare(item, otherItem);
			if(rcompare >= 0) {
				removedCount++;
				list.set(i, otherItem);
				list.set(j, null);
				j = i;
				i--;
				continue;
			}
			Integer prefixLen = item.getPrefixLength();
			Integer otherPrefixLen = otherItem.getPrefixLength();
			if(!Objects.equals(prefixLen, otherPrefixLen)) {
				j = i;
				i--;
				continue;
			}
			int matchBitIndex = (prefixLen == null) ? bitCount - 1 : prefixLen - 1;
			int lastMatchSegmentIndex, lastBitSegmentIndex;
			if(matchBitIndex == 0) {
				lastMatchSegmentIndex = lastBitSegmentIndex = 0;
			} else {
				lastMatchSegmentIndex = getNetworkSegmentIndex(matchBitIndex, bytesPerSegment, bitsPerSegment);
				lastBitSegmentIndex = getHostSegmentIndex(matchBitIndex, bytesPerSegment, bitsPerSegment);
			}
			IPAddressSegment itemSegment = item.getSegment(lastMatchSegmentIndex);
			IPAddressSegment otherItemSegment = otherItem.getSegment(lastMatchSegmentIndex);
			int itemSegmentValue = itemSegment.getSegmentValue();
			int otherItemSegmentValue = otherItemSegment.getSegmentValue();
			int segmentLastBitIndex = bitsPerSegment - 1;
			if(lastBitSegmentIndex == lastMatchSegmentIndex) {
				int segmentBitToCheck = matchBitIndex % bitsPerSegment;
				int shift = segmentLastBitIndex - segmentBitToCheck;
				itemSegmentValue >>>= shift;
				otherItemSegmentValue >>>= shift;
			} else {
				int itemBitValue = item.getSegment(lastBitSegmentIndex).getSegmentValue();
				int otherItemBitalue = otherItem.getSegment(lastBitSegmentIndex).getSegmentValue();
				itemSegmentValue = (itemSegmentValue << 1) | (itemBitValue >>> segmentLastBitIndex);
				otherItemSegmentValue = (otherItemSegmentValue << 1) | (otherItemBitalue >>> segmentLastBitIndex);
			}
			if(itemSegmentValue != otherItemSegmentValue) {
				itemSegmentValue ^= 1;
				if(itemSegmentValue != otherItemSegmentValue) {
					j = i;
					i--;
					continue;
				} 
			}
			for(int k = lastMatchSegmentIndex - 1; k >= 0; k--) {
				itemSegment = item.getSegment(k);
				otherItemSegment = otherItem.getSegment(k);
				int val = itemSegment.getSegmentValue();
				int otherVal = otherItemSegment.getSegmentValue();
				if(val != otherVal) {
					j = i;
					i--;
					continue top;
				}
			}
			IPAddressSegmentSeries joinedItem = otherItem.toPrefixBlock(matchBitIndex);
			list.set(i, joinedItem);
			removedCount++;
			int k = j + 1;
			while(k < list.size() && list.get(k) == null) {
				k++;
			}
			if(k < list.size()) {
				list.set(j, list.get(k));
				list.set(k, null);
			} else {
				list.set(j, null);
				j = i;
				i--;
			}
		}
		if(removedCount > 0) {
			int newSize = list.size() - removedCount;
			for(int k = 0, l = 0; k < newSize; k++, l++) {
				while(list.get(l) == null) {
					l++;
				}
				if(k != l) {
					list.set(k, list.get(l));
				}
			}
			int last = list.size();
			while(removedCount-- > 0) { 
				list.remove(--last);
			}
		}
		return list;
	}
	private static boolean organizeSequentially(IPAddressSegmentSeries sections[], List<IPAddressSegmentSeries> list) {
		List<IPAddressSegmentSeries> sequentialList = null;
		for(int i = 0; i < sections.length; i++) {
			IPAddressSegmentSeries section = sections[i];
			if(section == null) {
				continue;
			}
			if(!section.isSequential()) {
				if(sequentialList == null) {
					sequentialList = new ArrayList<>(sections.length);
					for(int j = 0; j < i; j++) {
						IPAddressSegmentSeries series = sections[j];
						if(series != null) {
							sequentialList.add(series);
						}
					}
				}
				Iterator<? extends IPAddressSegmentSeries> iterator = section.sequentialBlockIterator();
				while(iterator.hasNext()) {
					sequentialList.add(iterator.next());
				}
			} else if(sequentialList != null) {
				sequentialList.add(section);
			}
		}
		if(sequentialList == null) {
			for(int i = 0; i < sections.length; i++) {
				IPAddressSegmentSeries series = sections[i];
				if(series != null) {
					if(series.isSinglePrefixBlock()) {
						list.add(series);
					} else {
						IPAddressSegmentSeries span[] = series.spanWithPrefixBlocks();
						for(int k = 0; k < span.length; k++) {
							list.add(span[k]);
						}
					}
				}
			}
		} else for(int j = 0; j < sequentialList.size(); j++) {
			IPAddressSegmentSeries series = sequentialList.get(j);
			if(series.isSinglePrefixBlock()) {
				list.add(series);
			} else {
				IPAddressSegmentSeries span[] = series.spanWithPrefixBlocks();
				for(int k = 0; k < span.length; k++) {
					list.add(span[k]);
				}
			}
		}
		if(list.size() == 1) {
			return true;
		}
		list.sort(Address.ADDRESS_LOW_VALUE_COMPARATOR);
		return false;
	}
	private static boolean organizeSequentialMerge(IPAddressSegmentSeries sections[], List<IPAddressSegmentSeries> list) {
		for(int i = 0; i < sections.length; i++) {
			IPAddressSegmentSeries section = sections[i];
			if(section == null) {
				continue;
			}
			if(section.isSequential()) {
				list.add(section);
			} else {
				Iterator<? extends IPAddressSegmentSeries> iterator = section.sequentialBlockIterator();
				while(iterator.hasNext()) {
					list.add(iterator.next());
				}
			}
		}
		if(list.size() == 1) {
			return true;
		}
		list.sort(Address.ADDRESS_LOW_VALUE_COMPARATOR);
		return false;
	}
	protected List<? extends IPAddressSegmentSeries> spanWithBlocks(boolean prefixBlocks) {
		return IPAddress.spanWithBlocks(this, prefixBlocks);
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R[] subtract(
			R first,
			R other,
			IPAddressCreator<T, R, ?, S, ?> addrCreator,
			IntFunction<S> segProducer,
			SegFunction<R, R> prefixApplier) {
		first.checkSegmentCount(other);
		if(!first.isMultiple()) {
			if(other.contains(first)) {
				return null;
			}
			R result[] = addrCreator.createSectionArray(1);
			result[0] = first;
			return result;
		}
		int segCount = first.getSegmentCount();
		for(int i = 0; i < segCount; i++) {
			IPAddressSegment seg = first.getSegment(i);
			IPAddressSegment otherSeg = other.getSegment(i);
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			if(otherLower > higher || lower > otherHigher) {
				R result[] = addrCreator.createSectionArray(1);
				result[0] = first;
				return result;
			}
		}
		S intersections[] = addrCreator.createSegmentArray(segCount);
		ArrayList<R> sections = new ArrayList<R>();
		for(int i = 0; i < segCount; i++) {
			S seg = segProducer.apply(i);
			IPAddressSegment otherSeg = other.getSegment(i);
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			if(lower >= otherLower) {
				if(higher <= otherHigher) {
					if(seg.isPrefixed()) {
						intersections[i] = addrCreator.createSegment(lower, higher, null);
					} else {
						intersections[i] = seg;
					}
					continue;
				}
				intersections[i] = addrCreator.createSegment(lower, otherHigher, null);
				R section = createDiffSection(first, otherHigher + 1, higher, i, addrCreator, segProducer, intersections);
				sections.add(section);
			} else {
				R section = createDiffSection(first, lower, otherLower - 1, i, addrCreator, segProducer, intersections);
				sections.add(section);
				if(higher <= otherHigher) {
					intersections[i] = addrCreator.createSegment(otherLower, higher, null);
				} else {
					intersections[i] = addrCreator.createSegment(otherLower, otherHigher, null);
					section = createDiffSection(first, otherHigher + 1, higher, i, addrCreator, segProducer, intersections);
					sections.add(section);
				}
			}
		}
		if(sections.size() == 0) {
			return null;
		}
		if(first.isPrefixed()) {
			int thisPrefix = first.getNetworkPrefixLength();
			for(int i = 0; i < sections.size(); i++) {
				R section = sections.get(i);
				int bitCount = section.getBitCount();
				int totalPrefix = bitCount;
				for(int j = first.getSegmentCount() - 1; j >= 0 ; j--) {
					IPAddressSegment seg = section.getSegment(j);
					int segBitCount = seg.getBitCount();
					int segPrefix = seg.getMinPrefixLengthForBlock();
					if(segPrefix == segBitCount) {
						break;
					} else {
						totalPrefix -= segBitCount;
						if(segPrefix != 0) {
							totalPrefix += segPrefix;
							break;
						}
					}
				}
				if(totalPrefix != bitCount) {
					if(totalPrefix < thisPrefix) {
						totalPrefix = thisPrefix;
					}
					section = prefixApplier.apply(section, totalPrefix);
					sections.set(i, section);
				}
			}
		}
		R result[] = addrCreator.createSectionArray(sections.size());
		sections.toArray(result);
		return result;
	}
	private static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R createDiffSection(
			R original,
			int lower,
			int upper,
			int diffIndex,
			IPAddressCreator<T, R, ?, S, ?> addrCreator,
			IntFunction<S> segProducer,
			S intersectingValues[]) {
		int segCount = original.getSegmentCount();
		S segments[] = addrCreator.createSegmentArray(segCount);
		for(int j = 0; j < diffIndex; j++) {
			segments[j] = intersectingValues[j];
		}
		S diff = addrCreator.createSegment(lower, upper, null);
		segments[diffIndex] = diff;
		for(int j = diffIndex + 1; j < segCount; j++) {
			segments[j] = segProducer.apply(j);
		}
		R section = addrCreator.createSectionInternal(segments);
		return section;
	}
	@Override
	public abstract IPAddressSection toZeroHost();
	@Override
	public abstract IPAddressSection toZeroHost(int prefixLength);
	@Override
	public abstract IPAddressSection toZeroNetwork();
	@Override
	public abstract IPAddressSection toMaxHost();
	@Override
	public abstract IPAddressSection toMaxHost(int prefixLength);
	@Deprecated
	@Override
	public abstract IPAddressSection applyPrefixLength(int networkPrefixLength) throws PrefixLenException;
	protected void checkMaskSegmentCount(IPAddressSection mask) throws SizeMismatchException {
		if(mask.getSegmentCount() < getSegmentCount()) {
			throw new SizeMismatchException(this, mask);
		}
	}
	@Override
	public abstract IPAddressSection coverWithPrefixBlock();
	@Override
	public abstract IPAddressSection toPrefixBlock();
	@Override
	public abstract IPAddressSection toPrefixBlock(int networkPrefixLength);
	@Override
	public IPAddressSection getHostMask() {
		Integer prefLen = getNetworkPrefixLength();
		return getNetwork().getHostMask(prefLen == null ? 0 : getNetworkPrefixLength()).getSection(0, getSegmentCount());
	}
	@Override
	public IPAddressSection getNetworkMask() {
		Integer prefLen = getNetworkPrefixLength();
		return getNetwork().getNetworkMask(prefLen == null ? getBitCount() : getNetworkPrefixLength()).getSection(0, getSegmentCount());
	}
	@Override
	public IPAddressSection assignPrefixForSingleBlock() {
		Integer newPrefix = getPrefixLengthForSingleBlock();
		if(newPrefix == null) {
			return null;
		}
		IPAddressSection result = setPrefixLength(newPrefix, false);
		if(result != this) { 
			result.hasNoPrefixCache();
			PrefixCache cache = result.prefixCache;
			cache.cachedIsSinglePrefixBlock = true;
			cache.cachedEquivalentPrefix = newPrefix;
			cache.cachedMinPrefix = newPrefix;
		}
		return result;
	}
	@Override
	public IPAddressSection assignMinPrefixForBlock() {
		return setPrefixLength(getMinPrefixLengthForBlock(), false);
	}
	@Override
	public boolean includesZeroHost() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return false;
		}
		return includesZeroHost(networkPrefixLength);
	}
	@Override
	public boolean includesZeroHost(int networkPrefixLength) {
		if(networkPrefixLength < 0 || networkPrefixLength > getBitCount()) {
			throw new PrefixLenException(this, networkPrefixLength);
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getNetworkPrefixLength() <= networkPrefixLength) { 
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int bytesPerSegment = getBytesPerSegment();
		int prefixedSegmentIndex = getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
		int divCount = getSegmentCount();
		for(int i = prefixedSegmentIndex; i < divCount; i++) {
			IPAddressSegment div = getSegment(i);
			Integer segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			if(segmentPrefixLength != null) {
				int mask = div.getSegmentHostMask(segmentPrefixLength);
				if((mask & div.getDivisionValue()) != 0) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = getSegment(i);
					if(!div.includesZero()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	@Override
	public boolean includesMaxHost() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return false;
		}
		return includesMaxHost(networkPrefixLength);
	}
	@Override
	public boolean includesMaxHost(int networkPrefixLength) {
		if(networkPrefixLength < 0 || networkPrefixLength > getBitCount()) {
			throw new PrefixLenException(this, networkPrefixLength);
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getNetworkPrefixLength() <= networkPrefixLength) { 
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int bytesPerSegment = getBytesPerSegment();
		int prefixedSegmentIndex = getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
		int divCount = getSegmentCount();
		for(int i = prefixedSegmentIndex; i < divCount; i++) {
			IPAddressSegment div = getSegment(i);
			Integer segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			if(segmentPrefixLength != null) {
				int mask = div.getSegmentHostMask(segmentPrefixLength);
				if((mask & div.getUpperSegmentValue()) != mask) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = getSegment(i);
					if(!div.includesMax()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	public boolean isSingleNetwork() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return !isMultiple();
		}
		int prefixedSegmentIndex = getNetworkSegmentIndex(networkPrefixLength, getBytesPerSegment(), getBitsPerSegment());
		if(prefixedSegmentIndex < 0) {
			return true;
		}
		for(int i = 0; i < prefixedSegmentIndex; i++) {
			IPAddressSegment div = getSegment(i);
			if(div.isMultiple()) {
				return false;
			}
		}
		IPAddressSegment div = getSegment(prefixedSegmentIndex);
		int differing = div.getSegmentValue() ^ div.getUpperSegmentValue();
		if(differing == 0) {
			return true;
		}
		int bitsPerSegment = div.getBitCount();
		int highestDifferingBitInRange = Integer.numberOfLeadingZeros(differing) - (Integer.SIZE - bitsPerSegment);
		return getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, prefixedSegmentIndex) <= highestDifferingBitInRange;
	}
	public boolean matchesWithMask(IPAddressSection other, IPAddressSection mask) {
		checkMaskSegmentCount(mask);
		checkSegmentCount(other);
		int divCount = getSegmentCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressSegment div = getSegment(i);
			IPAddressSegment maskSegment = mask.getSegment(i);
			IPAddressSegment otherSegment = other.getSegment(i);
			if(!div.matchesWithMask(
					otherSegment.getSegmentValue(), 
					otherSegment.getUpperSegmentValue(), 
					maskSegment.getSegmentValue())) {
				return false;
			}
		}
		return true;
	}
	@Override @Deprecated
	public abstract IPAddressSection removePrefixLength(boolean zeroed);
	@Override @Deprecated
	public abstract IPAddressSection removePrefixLength();
	@Override
	public abstract IPAddressSection withoutPrefixLength();
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment>
			R toPrefixBlock(
					R original,
					int networkPrefixLength,
					IPAddressCreator<T, R, ?, S, ?> creator,
					SegFunction<Integer, S> segProducer) {
		if(networkPrefixLength < 0 || networkPrefixLength > original.getBitCount()) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		if(original.isNetworkSubnet(networkPrefixLength)) {
			return original;
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int segmentCount = original.getSegmentCount();
		S result[] = creator.createSegmentArray(segmentCount);
		for(int i = 0; i < segmentCount; i++) {
			Integer prefix = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			result[i] = segProducer.apply(prefix, i);
		}
		return creator.createSectionInternal(result);
	}
	protected boolean isNetworkSubnet(int networkPrefixLength) {
		int segmentCount = getSegmentCount();
		if(segmentCount == 0) {
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int prefixedSegmentIndex = getHostSegmentIndex(networkPrefixLength, getBytesPerSegment(), bitsPerSegment);
		if(prefixedSegmentIndex >= segmentCount) {
			if(networkPrefixLength == getBitCount()) {
				IPAddressSegment last = getSegment(segmentCount - 1);
				return !last.isNetworkChangedByPrefixNonNull(last.getBitCount());
			}
			return true;
		}
		int segPrefLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, prefixedSegmentIndex);
		if(getSegment(prefixedSegmentIndex).isNetworkChangedByPrefixNonNull(segPrefLength)) {
			return false;
		}
		if(!getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			for(int i = prefixedSegmentIndex + 1; i < segmentCount; i++) {
				if(!getSegment(i).isFullRange()) {
					return false;
				}
			}
		}
		return true;
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R removePrefixLength(
			R original, boolean zeroed, IPAddressCreator<?, R, ?, S, ?> creator, SegFunction<R, S> segProducer) throws IncompatibleAddressException {
		if(!original.isPrefixed()) {
			return original;
		}
		IPAddressNetwork<?, R, ?, S, ?> network = creator.getNetwork();
		R mask = network.getNetworkMaskSection(zeroed ? original.getPrefixLength() : original.getBitCount());
		return getSubnetSegments(
				original,
				null,
				creator,
				zeroed,
				i -> segProducer.apply(original, i),
				i -> segProducer.apply(mask, i).getSegmentValue(),
				false);
	}
	@Override
	public IPAddressSection adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		int prefix = getAdjustedPrefix(nextSegment, getBitsPerSegment(), false);
		Integer existing = getNetworkPrefixLength();
		if(existing == null) {
			if(nextSegment ? prefix == getBitCount() : prefix == 0) {
				return this;
			}
		} else if(existing != null && existing == prefix && prefix != 0) {
			return removePrefixLength(zeroed);
		}
		return setPrefixLength(prefix, zeroed);
	}
	@Override
	public abstract IPAddressSection adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract IPAddressSection adjustPrefixLength(int adjustment);
	@Override
	public abstract IPAddressSection adjustPrefixLength(int adjustment, boolean zeroed);
	protected static <R extends IPAddressSection, S extends IPAddressSegment> IPAddressSection adjustPrefixLength(
			R original, int adjustment, boolean withZeros, IPAddressCreator<?, R, ?, S, ?> creator, SegFunction<R, S> segProducer) throws IncompatibleAddressException {
		if(adjustment == 0 && original.isPrefixed()) {
			return original;
		}
		int prefix = original.getAdjustedPrefix(adjustment, false, false);
		if(prefix > original.getBitCount()) {
			if(!original.isPrefixed()) {
				return original;
			}
			IPAddressNetwork<?, R, ?, S, ?> network = creator.getNetwork();
			R mask = network.getNetworkMaskSection(withZeros ? original.getPrefixLength() : original.getBitCount());
			return getSubnetSegments(
					original,
					null,
					creator,
					withZeros,
					i -> segProducer.apply(original, i),
					i -> segProducer.apply(mask, i).getSegmentValue(),
					false);
		}
		if(prefix < 0) {
			prefix = 0;
		}
		return original.setPrefixLength(prefix, withZeros);
	}
	@Override
	public abstract IPAddressSection setPrefixLength(int prefixLength);
	@Override
	public abstract IPAddressSection setPrefixLength(int prefixLength, boolean zeroed);
	public abstract IPAddressSection setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock);
	private boolean hasNoPrefixCache() {
		if(prefixCache == null) {
			synchronized(this) {
				if(prefixCache == null) {
					prefixCache = new PrefixCache();
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public int getMinPrefixLengthForBlock() {
		Integer result;
		if(hasNoPrefixCache() || (result = prefixCache.cachedMinPrefix) == null) {
			prefixCache.cachedMinPrefix = result = cacheBits(super.getMinPrefixLengthForBlock());
		}
		return result;
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		if(!hasNoPrefixCache()) {
			Integer result = prefixCache.cachedEquivalentPrefix;
			if(result != null) {
				if(result < 0) {
					return null;
				}
				return result;
			}
		}
		Integer res = super.getPrefixLengthForSingleBlock();
		if(res == null) {
			prefixCache.cachedEquivalentPrefix = NO_PREFIX_LENGTH;
			prefixCache.cachedIsSinglePrefixBlock = false;
			return null;
		}
		if(isPrefixed() && res.equals(getNetworkPrefixLength())) {
			prefixCache.cachedIsSinglePrefixBlock = true;
		}
		prefixCache.cachedEquivalentPrefix = res;
		return res;
	}
	@Override
	public abstract IPAddressSection getLowerNonZeroHost();
	@Override
	public abstract IPAddressSection getLower();
	@Override
	public abstract IPAddressSection getUpper();
	@Override
	public abstract IPAddressSection reverseSegments();
	@Override
	public abstract IPAddressSection reverseBits(boolean perByte);
	@Override
	public abstract IPAddressSection reverseBytes();
	@Override
	public abstract IPAddressSection reverseBytesPerSegment();
	protected IPAddressSegment[] getSegmentsInternal() {
		return (IPAddressSegment[]) getDivisionsInternal();
	}
	@Override
	public abstract IPAddressSection getSection(int index);
	@Override
	public abstract IPAddressSection getSection(int index, int endIndex);
	@Override
	public void getSegments(AddressSegment segs[]) {
		getSegments(0, getDivisionCount(), segs, 0);
	}
	@Override
	public void getSegments(int start, int end, AddressSegment segs[], int destIndex) {
		System.arraycopy(getDivisionsInternal(), start, segs, destIndex, end - start);
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R createEmbeddedSection(
			IPAddressCreator<T, R, ?, S, ?> creator, S segs[], IPAddressSection encompassingSection) {
		return creator.createEmbeddedSectionInternal(encompassingSection, segs);
	}
	@Override
	public abstract Iterable<? extends IPAddressSection> getIterable();
	@Override
	public abstract Iterator<? extends IPAddressSection> nonZeroHostIterator();
	@Override
	public abstract Iterator<? extends IPAddressSection> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> spliterator();
	@Override
	public abstract Stream<? extends IPAddressSection> stream();
	@Override
	public abstract Iterator<? extends IPAddressSection> prefixIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> prefixSpliterator();
	@Override
	public abstract Stream<? extends IPAddressSection> prefixStream();
	@Override
	public abstract Iterator<? extends IPAddressSection> prefixBlockIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends IPAddressSection> prefixBlockStream();
	@Override
	public abstract Iterator<? extends IPAddressSection> blockIterator(int segmentCount);
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> blockSpliterator(int segmentCount);
	@Override
	public abstract Stream<? extends IPAddressSection> blockStream(int segmentCount);
	@Override
	public Iterator<? extends IPAddressSection> sequentialBlockIterator() {
		return blockIterator(getSequentialBlockIndex());
	}
	@Override
	public AddressComponentSpliterator<? extends IPAddressSection> sequentialBlockSpliterator() {
		return blockSpliterator(getSequentialBlockIndex());
	}
	@Override
	public Stream<? extends IPAddressSection> sequentialBlockStream() {
		return blockStream(getSequentialBlockIndex());
	}
	@Override
	public BigInteger getSequentialBlockCount() {
		int sequentialSegCount = getSequentialBlockIndex();
		return getPrefixCount(sequentialSegCount * getBitsPerSegment());
	}
	static <S extends AddressSegment> Iterator<S[]> iterator(
			int divCount,
			AddressSegmentCreator<S> segmentCreator,
			IntFunction<Iterator<S>> segIteratorProducer,
			int networkSegmentIndex,
			int hostSegmentIndex,
			IntFunction<Iterator<S>> prefixedSegIteratorProducer) {
		return segmentsIterator(
				divCount, segmentCreator, null, segIteratorProducer, null,
				networkSegmentIndex,
				hostSegmentIndex,
				prefixedSegIteratorProducer);
	}
	static <T extends Address, S extends AddressSegment> Iterator<T> iterator(
			T original,
			AddressCreator<T, ?, ?, S> creator,
			Iterator<S[]> iterator) {
		return iterator(original != null, original, creator, iterator, null);
	}
	@FunctionalInterface
	static interface SeqRangeIteratorProvider<S, T> extends IteratorProvider<S,T>{}
	static class IPAddressSeqRangeSpliterator<S extends AddressComponentRange, T> extends AddressItemRangeSpliterator<S, T> implements IPAddressSeqRangeSplitterSink<S, T> {
		final Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter;
		IPAddressSeqRangeSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
				SeqRangeIteratorProvider<S, T> iteratorProvider,
				ToLongFunction<S> longSizer) {
			super(forIteration, null, iteratorProvider, null, null, longSizer);
			this.splitter = splitter;
		}
		IPAddressSeqRangeSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
				SeqRangeIteratorProvider<S, T> iteratorProvider,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, null, iteratorProvider, sizer, downSizer, longSizer);
			this.splitter = splitter;
		}
		IPAddressSeqRangeSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
				SeqRangeIteratorProvider<S, T> iteratorProvider,
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, null, iteratorProvider, isLowest, false, sizer, downSizer, longSizer);
			this.splitter = splitter;
		}
		@Override
		protected boolean split() {
			return splitter.test(this);
		}
		@Override
		protected IPAddressSeqRangeSpliterator<S, T> createSpliterator(
				S split, 
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			return new IPAddressSeqRangeSpliterator<S, T>(split, splitter, (SeqRangeIteratorProvider<S, T>) iteratorProvider, isLowest, sizer, downSizer, longSizer);
		}
	}
	static class IPAddressSeqRangePrefixSpliterator<S extends AddressComponentRange> 
		extends IPAddressSeqRangeSpliterator<S, S> implements AddressComponentSpliterator<S> {
		IPAddressSeqRangePrefixSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
				SeqRangeIteratorProvider<S, S> iteratorProvider,
				ToLongFunction<S> longSizer) {
			super(forIteration, splitter, iteratorProvider, longSizer);
		}
		IPAddressSeqRangePrefixSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
				SeqRangeIteratorProvider<S, S> iteratorProvider,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, splitter, iteratorProvider, sizer, downSizer, longSizer);
		}
		IPAddressSeqRangePrefixSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
				SeqRangeIteratorProvider<S, S> iteratorProvider,
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, splitter, iteratorProvider, isLowest, sizer, downSizer, longSizer);
		}
		@Override
		protected IPAddressSeqRangePrefixSpliterator<S> createSpliterator(
				S split, 
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			return new IPAddressSeqRangePrefixSpliterator<S>(split, splitter, (SeqRangeIteratorProvider<S, S>) iteratorProvider, isLowest, sizer, downSizer, longSizer);
		}
		@Override
		public IPAddressSeqRangePrefixSpliterator<S> trySplit() {
			return (IPAddressSeqRangePrefixSpliterator<S>) super.trySplit();
		}
	}
	@Override
	public abstract IPAddressSection increment(long increment);
	@Override
	public abstract IPAddressSection incrementBoundary(long increment);
	public boolean isEntireAddress() {
		return getSegmentCount() == IPAddress.getSegmentCount(getIPVersion());
	}
	protected boolean isMultiple(int segmentCount) {
		for(int i = 0; i < segmentCount; i++) {
			if(getSegment(i).isMultiple()) {
				return true;
			}
		}
		return false;
	}
	public boolean isZeroHost() {
		if(!isPrefixed()) {
			return false;
		}
		return isZeroHost(getNetworkPrefixLength());
	}
	public boolean isZeroHost(int prefixLength) {
		if(prefixLength < 0 || prefixLength > getBitCount()) {
			throw new PrefixLenException(this, prefixLength);
		}
		return isZeroHost(prefixLength, getSegments(), getBytesPerSegment(), getBitsPerSegment(), getBitCount());
	}
	protected <S extends IPAddressSegment> boolean isZeroHost(S segments[]) {
		if(!isPrefixed()) {
			return false;
		}
		return isZeroHost(getNetworkPrefixLength(), segments, getBytesPerSegment(), getBitsPerSegment(), getBitCount());
	}
	protected <S extends IPAddressSegment> boolean isZeroHost(S segments[], int prefixLength) {
		return isZeroHost(prefixLength, segments, getBytesPerSegment(), getBitsPerSegment(), getBitCount());
	}
	protected static <S extends IPAddressSegment> boolean isZeroHost(int prefLen, S segments[], int bytesPerSegment, int bitsPerSegment, int bitCount) {
		if(segments.length == 0 ) {
			return false;
		}
		if(prefLen >= bitCount) {
			return false;
		}
		int divCount = segments.length;
		int prefixedSegmentIndex = getHostSegmentIndex(prefLen, bytesPerSegment, bitsPerSegment);
		for(int i = prefixedSegmentIndex; i < divCount; i++) {
			Integer segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefLen, prefixedSegmentIndex);
			S div = segments[i];
			if(segmentPrefixLength != null) {
				int mask = div.getSegmentHostMask(segmentPrefixLength);
				if(div.isMultiple() || (mask & div.getSegmentValue()) != 0) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = segments[i];
					if(!div.isZero()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	InetAddress toInetAddress(IPAddress address) {
		InetAddress result;
		if(hasNoValueCache() || (result = valueCache.inetAddress) == null) {
			valueCache.inetAddress = result = address.toInetAddressImpl();
		}
		return result;
	}
	static void checkLengths(int length, StringBuilder builder) {
		IPAddressStringParams.checkLengths(length, builder);
	}
	@Override
	public String toString() {
		return toNormalizedString();
	}
	@Override
	public String[] getSegmentStrings() {
		return getDivisionStrings();
	}
	protected abstract void cacheNormalizedString(String str);
	protected abstract IPStringCache getStringCache();
	protected abstract boolean hasNoStringCache();
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = getStringCache().binaryString) == null) {
			IPStringCache stringCache = getStringCache();
			stringCache.binaryString = result = toBinaryString(null);
		}
		return result;
	}
	protected String toBinaryString(CharSequence zone) {
		if(isDualString()) {
			return toNormalizedStringRange(toIPParams(IPStringCache.binaryParams), getLower(), getUpper(), zone);
		}
		return toIPParams(IPStringCache.binaryParams).toString(this, zone);
	}
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {  
		String result;
		if(hasNoStringCache() || (result = (with0Prefix ? getStringCache().octalStringPrefixed : getStringCache().octalString)) == null) {
			IPStringCache stringCache = getStringCache();
			result = toOctalString(with0Prefix, null);
			if(with0Prefix) {
				stringCache.octalStringPrefixed = result;
			} else {
				stringCache.octalString = result;
			}
		}
		return result;
	}
	protected String toOctalString(boolean with0Prefix, CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			IPAddressSection lower = getLower();
			IPAddressSection upper = getUpper();
			IPAddressBitsDivision lowerDivs[] = lower.createNewDivisions(3, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
			IPAddressStringDivisionSeries lowerPart = new IPAddressDivisionGrouping(lowerDivs, getNetwork());
			IPAddressBitsDivision upperDivs[] = upper.createNewDivisions(3, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
			IPAddressStringDivisionSeries upperPart = new IPAddressDivisionGrouping(upperDivs, getNetwork());
			return toNormalizedStringRange(toIPParams(with0Prefix ? IPStringCache.octalPrefixedParams : IPStringCache.octalParams), lowerPart, upperPart, zone);
		}
		IPAddressBitsDivision divs[] = createNewPrefixedDivisions(3, null, null, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
		IPAddressStringDivisionSeries part = new IPAddressDivisionGrouping(divs, getNetwork());
		return toIPParams(with0Prefix ? IPStringCache.octalPrefixedParams : IPStringCache.octalParams).toString(part, zone);
	}
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {  
		String result;
		if(hasNoStringCache() || (result = (with0xPrefix ? getStringCache().hexStringPrefixed : getStringCache().hexString)) == null) {
			IPStringCache stringCache = getStringCache();
			result = toHexString(with0xPrefix, null);
			if(with0xPrefix) {
				stringCache.hexStringPrefixed = result;
			} else {
				stringCache.hexString = result;
			}
		}
		return result;
	}
	protected String toHexString(boolean with0xPrefix, CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			return toNormalizedStringRange(toIPParams(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams), getLower(), getUpper(), zone);
		}
		return toIPParams(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams).toString(this, zone);
	}
	@Override
	public String toNormalizedString(IPStringOptions stringOptions) {
		return toNormalizedString(stringOptions, this);
	}
	public static String toNormalizedString(IPStringOptions opts, IPAddressStringDivisionSeries section) {
		return toIPParams(opts).toString(section);
	}
	protected static IPAddressStringParams<IPAddressStringDivisionSeries> toIPParams(IPStringOptions opts) {
		@SuppressWarnings("unchecked")
		IPAddressStringParams<IPAddressStringDivisionSeries> result = (IPAddressStringParams<IPAddressStringDivisionSeries>) getCachedParams(opts);
		if(result == null) {
			result = new IPAddressStringParams<IPAddressStringDivisionSeries>(opts.base, opts.separator, opts.uppercase);
			result.expandSegments(opts.expandSegments);
			result.setWildcards(opts.wildcards);
			result.setWildcardOption(opts.wildcardOption);
			result.setSegmentStrPrefix(opts.segmentStrPrefix);
			result.setAddressSuffix(opts.addrSuffix);
			result.setAddressLabel(opts.addrLabel);
			result.setReverse(opts.reverse);
			result.setSplitDigits(opts.splitDigits);
			result.setZoneSeparator(opts.zoneSeparator);
			setCachedParams(opts, result);
		}
		return result;
	}
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(new IPStringBuilderOptions(IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS));
	}
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(new IPStringBuilderOptions(IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS));
	}
	public IPAddressPartStringCollection toDatabaseSearchStringCollection() {
		return toStringCollection(new IPStringBuilderOptions());
	}
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		if(options.includes(IPStringBuilderOptions.BASIC)) {
			return new IPAddressStringDivisionSeries[] { this };
		}
		return EMPTY_PARTS;
	}
	public void getStartsWithSQLClause(StringBuilder builder, String expression) {
		getStartsWithSQLClause(builder, expression, new MySQLTranslator());
	}
	public void getStartsWithSQLClause(StringBuilder builder, String expression, IPAddressSQLTranslator translator) {
		getStartsWithSQLClause(builder, expression, true, translator);
	}
	private void getStartsWithSQLClause(StringBuilder builder, String expression, boolean isFirstCall, IPAddressSQLTranslator translator) {
		if(isFirstCall && isMultiple()) {
			Iterator<? extends IPAddressSection> sectionIterator = iterator();
			builder.append('(');
			boolean isNotFirst = false;
			while(sectionIterator.hasNext()) {
				if(isNotFirst) {
					builder.append(" OR ");
				} else {
					isNotFirst = true;
				}
				IPAddressSection next = sectionIterator.next();
				next.getStartsWithSQLClause(builder, expression, false, translator);
			}
			builder.append(')');
		} else if(getSegmentCount() > 0) { 
			IPAddressPartStringCollection createdStringCollection = toDatabaseSearchStringCollection();
			boolean isNotFirst = false;
			if(createdStringCollection.size() > 1) {
				builder.append('(');
			}
			boolean isEntireAddress = isEntireAddress();
			for(IPAddressPartConfiguredString<?, ?> createdStr: createdStringCollection) {
				if(isNotFirst) {
					builder.append(" OR ");
				} else {
					isNotFirst = true;
				}
				SQLStringMatcher<?, ?, ?> matcher = createdStr.getNetworkStringMatcher(isEntireAddress, translator);
				matcher.getSQLCondition(builder.append('('), expression).append(')');
			}
			if(createdStringCollection.size() > 1) {
				builder.append(')');
			}
		}
	}
	protected static class IPStringCache extends StringCache {
		public static final IPStringOptions hexParams;
		public static final IPStringOptions hexPrefixedParams;
		public static final IPStringOptions octalParams;
		public static final IPStringOptions octalPrefixedParams;
		public static final IPStringOptions binaryParams;
		public static final IPStringOptions canonicalSegmentParams;
		static {
			WildcardOptions allWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL);
			hexParams = new IPStringOptions.Builder(16).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).toOptions();
			hexPrefixedParams = new IPStringOptions.Builder(16).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).setAddressLabel(IPAddress.HEX_PREFIX).toOptions();
			octalParams = new IPStringOptions.Builder(8).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).toOptions();
			octalPrefixedParams = new IPStringOptions.Builder(8).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).setAddressLabel(IPAddress.OCTAL_PREFIX).toOptions();
			binaryParams = new IPStringOptions.Builder(2).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).toOptions();
			canonicalSegmentParams = new IPStringOptions.Builder(10, ' ').toOptions();
		}
		public String normalizedWildcardString;
		public String fullString;
		public String sqlWildcardString;
		public String reverseDNSString;
		public String octalStringPrefixed;
		public String octalString;
		public String binaryString;
		public String segmentedBinaryString;
	}
	public static class WildcardOptions {
		public enum WildcardOption {
			NETWORK_ONLY, 
			ALL 
		}
		public final WildcardOption wildcardOption;
		public final Wildcards wildcards;
		public WildcardOptions() {
			this(WildcardOption.NETWORK_ONLY);
		}
		public WildcardOptions(WildcardOption wildcardOption) {
			this(wildcardOption, new Wildcards());
		}
		public WildcardOptions(WildcardOption wildcardOption, Wildcards wildcards) {
			this.wildcardOption = wildcardOption;
			this.wildcards = wildcards;
		}
	}
	public static class IPStringOptions extends StringOptions {
		public final String addrSuffix;
		public final WildcardOption wildcardOption;
		public final char zoneSeparator;
		protected IPStringOptions(
				int base,
				boolean expandSegments,
				WildcardOption wildcardOption,
				Wildcards wildcards,
				String segmentStrPrefix,
				Character separator,
				char zoneSeparator,
				String label,
				String suffix,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			super(base, expandSegments, wildcards, segmentStrPrefix, separator, label, reverse, splitDigits, uppercase);
			this.addrSuffix = suffix;
			this.wildcardOption = wildcardOption;
			this.zoneSeparator = zoneSeparator;
		}
		public static class Builder extends StringOptions.Builder {
			protected String addrSuffix = "";
			protected WildcardOption wildcardOption = WildcardOption.NETWORK_ONLY;
			protected char zoneSeparator = IPv6Address.ZONE_SEPARATOR;
			public Builder(int base) {
				this(base, ' ');
			}
			protected Builder(int base, char separator) {
				super(base, separator);
			}
			@Override
			public Builder setWildcards(Wildcards wildcards) {
				return (Builder) super.setWildcards(wildcards);
			}
			public Builder setAddressSuffix(String suffix) {
				this.addrSuffix = suffix;
				return this;
			}
			public Builder setWildcardOptions(WildcardOptions wildcardOptions) {
				setWildcardOption(wildcardOptions.wildcardOption);
				return setWildcards(wildcardOptions.wildcards);
			}
			public Builder setWildcardOption(WildcardOption wildcardOption) {
				this.wildcardOption = wildcardOption;
				return this;
			}
			@Override
			public Builder setReverse(boolean reverse) {
				return (Builder) super.setReverse(reverse);
			}
			@Override
			public Builder setUppercase(boolean uppercase) {
				return (Builder) super.setUppercase(uppercase);
			}
			@Override
			public Builder setSplitDigits(boolean splitDigits) {
				return (Builder) super.setSplitDigits(splitDigits);
			}
			@Override
			public Builder setExpandedSegments(boolean expandSegments) {
				return (Builder) super.setExpandedSegments(expandSegments);
			}
			@Override
			public Builder setRadix(int base) {
				return (Builder) super.setRadix(base);
			}
			@Override
			public Builder setSeparator(Character separator) {
				return (Builder) super.setSeparator(separator);
			}
			public Builder setZoneSeparator(char separator) {
				this.zoneSeparator = separator;
				return this;
			}
			@Override
			public Builder setAddressLabel(String label) {
				return (Builder) super.setAddressLabel(label);
			}
			@Override
			public Builder setSegmentStrPrefix(String prefix) {
				return (Builder) super.setSegmentStrPrefix(prefix);
			}
			@Override
			public IPStringOptions toOptions() {
				return new IPStringOptions(base,
						expandSegments, wildcardOption, wildcards, segmentStrPrefix, separator, zoneSeparator, addrLabel, addrSuffix, reverse, splitDigits, uppercase);
			}
		}
	}
	public static class IPStringBuilderOptions {
		public static final int BASIC = 0x1;
		public static final int LEADING_ZEROS_FULL_ALL_SEGMENTS = 0x10; 
		public static final int LEADING_ZEROS_FULL_SOME_SEGMENTS = 0x20 | LEADING_ZEROS_FULL_ALL_SEGMENTS; 
		public static final int LEADING_ZEROS_PARTIAL_SOME_SEGMENTS = 0x40 | LEADING_ZEROS_FULL_SOME_SEGMENTS; 
		public final int options;
		public IPStringBuilderOptions() {
			this(BASIC);
		}
		public IPStringBuilderOptions(int options) {
			this.options = options;
		}
		public boolean includes(int option) {
			return (option & options) == option;
		}
		public boolean includesAny(int option) {
			return (option & options) != 0;
		}
		@Override
		public String toString() {
			TreeMap<Integer, String> options = new TreeMap<>();
			Field fields[] = getClass().getFields();
			for(Field field: fields) {
				int modifiers = field.getModifiers();
				if(Modifier.isFinal(modifiers) && Modifier.isStatic(modifiers)) {
					try {
						int constant = field.getInt(null);
						String option = field.getName() + ": " + includes(constant) + System.lineSeparator();
						options.put(constant, option);
					} catch(IllegalAccessException e) {}
				}
			}
			Collection<String> values = options.values(); 
			StringBuilder builder = new StringBuilder();
			for(String val : values) {
				builder.append(val);
			}
			return builder.toString();
		}
	}
}
package inet.ipaddr;
import java.io.Serializable;
import java.util.Map;
import inet.ipaddr.Address.AddressValueProvider;
import inet.ipaddr.format.standard.AddressCreator;
public abstract class AddressNetwork<S extends AddressSegment> implements Serializable {
	private static final long serialVersionUID = 4L;
	public interface AddressSegmentCreator<S extends AddressSegment> {
		S[] createSegmentArray(int length);
		S createSegment(int value);
		S createSegment(int value, Integer segmentPrefixLength);
		S createSegment(int lower, int upper, Integer segmentPrefixLength);
	}
	public abstract AddressCreator<?, ?, ?, S> getAddressCreator();
	public void clearCaches() {
		getAddressCreator().clearCaches();
	}
	public void setSegmentCaching(boolean enable) {
		getAddressCreator().setSegmentCaching(enable);
	}
	public enum PrefixConfiguration {
		ALL_PREFIXED_ADDRESSES_ARE_SUBNETS,
		PREFIXED_ZERO_HOSTS_ARE_SUBNETS,
		EXPLICIT_SUBNETS;
		public boolean allPrefixedAddressesAreSubnets() {
			return this == ALL_PREFIXED_ADDRESSES_ARE_SUBNETS;
		}
		public boolean zeroHostsAreSubnets() {
			return this == PREFIXED_ZERO_HOSTS_ARE_SUBNETS;
		}
		public boolean prefixedSubnetsAreExplicit() {
			return this == EXPLICIT_SUBNETS;
		}
	}
	private static PrefixConfiguration defaultPrefixConfiguration = PrefixConfiguration.PREFIXED_ZERO_HOSTS_ARE_SUBNETS;
	public abstract PrefixConfiguration getPrefixConfiguration();
	public static PrefixConfiguration getDefaultPrefixConfiguration() {
		return defaultPrefixConfiguration;
	}
	protected boolean isCompatible(AddressNetwork<?> other) {
		return IPAddressSection.isCompatibleNetworks(this, other);
	}
	public static abstract class HostIdentifierStringGenerator<T extends HostIdentifierString> implements Serializable {
		private static final long serialVersionUID = 4L;
		protected final Map<String, T> backingMap;
		public HostIdentifierStringGenerator() {
			this(null);
		}
		public HostIdentifierStringGenerator(Map<String, T> backingMap) {
			this.backingMap = backingMap;
		}
		public Map<String, T> getBackingMap() {
			return backingMap;
		}
		protected void added(T added) {}
		public boolean contains(T value) {
			return backingMap.containsValue(value);
		}
		public T get(String key) {
			if(backingMap == null) {
				return create(key);
			}
			T result = backingMap.get(key);
			if(result == null) {
				result = create(key);
				String normalizedKey = result.toNormalizedString();
				result = create(normalizedKey);
				T existing = backingMap.putIfAbsent(normalizedKey, result);
				if(existing == null) {
					added(result);
				} else {
					result = existing;
				}
				if(!normalizedKey.equals(key)) {
					backingMap.put(key, result);
				}
			}
			return result;
		}
		public abstract T get(byte bytes[]);
		public abstract T get(AddressValueProvider addressProvider);
		protected abstract T create(String key);
	}
}
package inet.ipaddr.format.standard;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.BiFunction;
import java.util.function.BooleanSupplier;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.LongSupplier;
import java.util.function.Predicate;
import java.util.function.Supplier;
import inet.ipaddr.Address;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.AddressSegmentSeries;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.IPAddressSeqRange;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.NetworkMismatchException;
import inet.ipaddr.SizeMismatchException;
import inet.ipaddr.format.AddressDivisionBase;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.string.AddressStringDivisionSeries;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
public class AddressDivisionGrouping extends AddressDivisionGroupingBase {
	private static final long serialVersionUID = 4L;
	public static interface DivisionValueProvider {
		long getValue(int segmentIndex);
	}
	public static interface DivisionLengthProvider {
		int getLength(int segmentIndex);
	}
	protected static class SectionCache<R extends AddressSegmentSeries> {
		public R lower;
		public R lowerNonZeroHost;
		public R upper;
		public boolean lowerNonZeroHostIsNull;
		public SectionCache() {}
	}
	protected static class StringCache {
		public String canonicalString;
		public String hexString;
		public String hexStringPrefixed;
	}
	public AddressDivisionGrouping(AddressDivision divisions[]) {
		super(divisions);
	}
	public AddressDivisionGrouping(AddressDivision divisions[], boolean checkDivisions) {
		super(divisions, checkDivisions);
	}
	@Override
	public AddressDivision getDivision(int index) {
		return (AddressDivision) super.getDivision(index);
	}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		byte bytes[] = new byte[(getBitCount() + 7) >> 3];
		int byteCount = bytes.length;
		int divCount = getDivisionCount();
		for(int k = divCount - 1, byteIndex = byteCount - 1, bitIndex = 8; k >= 0; k--) {
			AddressDivision div = getDivision(k);
			long segmentValue = low ? div.getDivisionValue() : div.getUpperDivisionValue();
			int divBits = div.getBitCount();
			while(divBits > 0) {
				bytes[byteIndex] |= segmentValue << (8 - bitIndex);
				segmentValue >>>= bitIndex;
				if(divBits < bitIndex) {
					bitIndex -= divBits;
					break;
				} else {
					divBits -= bitIndex;
					bitIndex = 8;
					byteIndex--;
				}
			}
		}
		return bytes;
	}
	protected static Integer cacheBits(int i) {
		return ParsedAddressGrouping.cache(i);
	}
	protected static <R extends AddressSection, S extends AddressSegment> boolean overlaps(R original, R other) {
		int count = original.getSegmentCount();
		if(count != other.getSegmentCount()) {
			return false;
		}
		for(int i = count - 1; i >= 0; i--) {
			AddressSegment seg = original.getSegment(i);
			if(!seg.overlaps(other.getSegment(i))) {
				return false;
			}
		}
		return true;
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		checkSubnet(this, prefixLength);
		int divisionCount = getDivisionCount();
		int prevBitCount = 0;
		for(int i = 0; i < divisionCount; i++) {
			AddressDivision division = getDivision(i);
			int bitCount = division.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength < totalBitCount) {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!division.isPrefixBlock(division.getDivisionValue(), division.getUpperDivisionValue(), divPrefixLen)) {
					return false;
				}
				for(++i; i < divisionCount; i++) {
					division = getDivision(i);
					if(!division.isFullRange()) {
						return false;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		checkSubnet(this, prefixLength);
		int divisionCount = getDivisionCount();
		int prevBitCount = 0;
		for(int i = 0; i < divisionCount; i++) {
			AddressDivision division = getDivision(i);
			int bitCount = division.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength >= totalBitCount) {
				if(division.isMultiple()) {
					return false;
				}
			} else {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!division.isSinglePrefixBlock(division.getDivisionValue(), division.getUpperDivisionValue(), divPrefixLen)) {
					return false;
				}
				for(++i; i < divisionCount; i++) {
					division = getDivision(i);
					if(!division.isFullRange()) {
						return false;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	@Override
	public int hashCode() {
		int res = hashCode;
		if(res == 0) {
			res = 1;
			int count = getDivisionCount();
			for(int i = 0; i < count; i++) {
				AddressDivision combo = getDivision(i);
				res = adjustHashCode(res, combo.getDivisionValue(), combo.getUpperDivisionValue());
			}
			hashCode = res;
		}
		return res;
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof AddressDivisionGrouping && super.isSameGrouping(other);
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof AddressDivisionGrouping) {
			AddressDivisionGrouping other = (AddressDivisionGrouping) o;
			return other.isSameGrouping(this);
		}
		return false;
	}
	protected static long getLongCount(IntUnaryOperator countProvider, int segCount) {
		if(segCount == 0) {
			return 1;
		}
		long result = countProvider.applyAsInt(0);
		for(int i = 1; i < segCount; i++) {
			result *= countProvider.applyAsInt(i);
		}
		return result;
	}
	protected static <R extends AddressSection, S extends AddressSegment> long longPrefixCount(R section, int prefixLength) {
		int bitsPerSegment = section.getBitsPerSegment();
		int bytesPerSegment = section.getBytesPerSegment();
		int networkSegmentIndex = getNetworkSegmentIndex(prefixLength, bytesPerSegment, bitsPerSegment);
		int hostSegmentIndex = getHostSegmentIndex(prefixLength, bytesPerSegment, bitsPerSegment);
		boolean hasPrefixedSegment = (networkSegmentIndex == hostSegmentIndex);
		return getLongCount(i -> {
			if(hasPrefixedSegment && i == networkSegmentIndex) {
				int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
				return AddressDivision.getPrefixValueCount(section.getSegment(i), segmentPrefixLength);
			}
			AddressSegment segment = section.getSegment(i);
			int valueCount = (segment.getUpperSegmentValue() - segment.getSegmentValue()) + 1;
			return valueCount;
		}, networkSegmentIndex + 1);
	}
	protected static <R extends AddressSection, S extends AddressSegment> long longCount(R section, int segCount) {
		long result = getLongCount(i -> {
			AddressSegment segment = section.getSegment(i);
			int valueCount = (segment.getUpperSegmentValue() - segment.getSegmentValue()) + 1;
			return valueCount;
		}, segCount);
		return result;
	}
	protected static Integer getPrefixedSegmentPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		return ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected static int getNetworkSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getNetworkSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	protected static int getHostSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	protected static Integer getSegmentPrefixLength(int bitsPerSegment, Integer prefixLength, int segmentIndex) {
		return ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected static Integer getSegmentPrefixLength(int segmentBits, int segmentPrefixedBits) {
		return ParsedAddressGrouping.getDivisionPrefixLength(segmentBits, segmentPrefixedBits);
	}
	protected static int getNetworkPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		return ParsedAddressGrouping.getNetworkPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected int getAdjustedPrefix(boolean nextSegment, int bitsPerSegment, boolean skipBitCountPrefix) {
		Integer prefix = getPrefixLength();
		int bitCount = getBitCount();
		if(nextSegment) {
			if(prefix == null) {
				if(getMinPrefixLengthForBlock() == 0) {
					return 0;
				}
				return bitCount;
			}
			if(prefix == bitCount) {
				return bitCount;
			}
			int existingPrefixLength = prefix.intValue();
			int adjustment = existingPrefixLength % bitsPerSegment;
			return existingPrefixLength + bitsPerSegment - adjustment;
		} else {
			if(prefix == null) {
				if(getMinPrefixLengthForBlock() == 0) {
					return 0;
				}
				if(skipBitCountPrefix) {
					prefix = bitCount;
				} else {
					return bitCount;
				}
			} else if(prefix == 0) {
				return 0;
			}
			int existingPrefixLength = prefix.intValue();
			int adjustment = ((existingPrefixLength - 1) % bitsPerSegment) + 1;
			return existingPrefixLength - adjustment;
		}
	}
	protected int getAdjustedPrefix(int adjustment, boolean floor, boolean ceiling) {
		Integer prefix = getPrefixLength();
		if(prefix == null) {
			if(getMinPrefixLengthForBlock() == 0) {
				prefix = cacheBits(0);
			} else {
				prefix = cacheBits(getBitCount());
			}
		}
		int result = prefix + adjustment;
		if(ceiling) {
			result = Math.min(getBitCount(), result);
		}
		if(floor) {
			result = Math.max(0, result);
		}
		return result;
	}
	protected static <S extends IPAddressSegment> void normalizePrefixBoundary(
			int sectionPrefixBits,
			S segments[],
			int segmentBitCount,
			int segmentByteCount,
			Function<S, S> segProducer) {
		int networkSegmentIndex = getNetworkSegmentIndex(sectionPrefixBits, segmentByteCount, segmentBitCount);
		if(networkSegmentIndex >= 0) {
			S segment = segments[networkSegmentIndex];
			if(!segment.isPrefixed()) {
				segments[networkSegmentIndex] = segProducer.apply(segment);
			}
		}
	}
	protected static <S extends AddressSegment> S[] setPrefixedSegments(
			AddressNetwork<?> network,
			int sectionPrefixBits,
			S segments[],
			int segmentBitCount,
			int segmentByteCount,
			AddressSegmentCreator<S> segmentCreator,
			BiFunction<S, Integer, S> segProducer) {
		boolean allPrefsSubnet = network.getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		for(int i = (sectionPrefixBits == 0) ? 0 : getNetworkSegmentIndex(sectionPrefixBits, segmentByteCount, segmentBitCount); i < segments.length; i++) {
			Integer pref = getPrefixedSegmentPrefixLength(segmentBitCount, sectionPrefixBits, i);
			if(pref != null) {
				segments[i] = segProducer.apply(segments[i], pref);
				if(allPrefsSubnet) {
					if(++i < segments.length) {
						S allSeg = segmentCreator.createSegment(0, cacheBits(0));
						Arrays.fill(segments, i, segments.length, allSeg);
					}
				}
			}
		}
		return segments;
	}
	@FunctionalInterface
	protected interface SegPrefFunction<S> {
	    S apply(S s, Integer u, Integer v);
	}
	protected static <R extends AddressSection, S extends AddressSegment> S[] removePrefix(
			R original,
			S segments[],
			int segmentBitCount,
			SegPrefFunction<S> prefixSetter 
			) {
		Integer oldPrefix = original.getPrefixLength();
		if(oldPrefix != null) {
			segments = segments.clone();
			int networkSegIndex = 0;
			if(oldPrefix > 0) {
				networkSegIndex = getNetworkSegmentIndex(oldPrefix, original.getBytesPerSegment(), segmentBitCount);
			}
			for(int i = networkSegIndex; i < segments.length; i++) {
				Integer oldPref = getPrefixedSegmentPrefixLength(segmentBitCount, oldPrefix, i);
				segments[i] = prefixSetter.apply(segments[i], oldPref, null);
			}
		}
		return segments;
	}
	protected static boolean prefixEquals(AddressSection first, AddressSection other, int otherIndex) {
		if(otherIndex < 0) {
			return false;
		}
		Integer prefixLength = first.getPrefixLength();
		int prefixedSection;
		if(prefixLength == null) {
			prefixedSection = first.getSegmentCount();
			int oIndex = prefixedSection + otherIndex;
			if(oIndex > other.getSegmentCount()) {
				return false;
			}
		} else {
			prefixedSection = getNetworkSegmentIndex(prefixLength, first.getBytesPerSegment(), first.getBitsPerSegment());
			if(prefixedSection >= 0) {
				int oIndex = prefixedSection + otherIndex;
				if(oIndex >= other.getSegmentCount()) {
					return false;
				}
				AddressSegment one = first.getSegment(prefixedSection);
				AddressSegment two = other.getSegment(oIndex);
				int segPrefixLength = getPrefixedSegmentPrefixLength(one.getBitCount(), prefixLength, prefixedSection);
				if(!one.prefixEquals(two, segPrefixLength)) {
					return false;
				}
			}
		}
		while(--prefixedSection >= 0) {
			AddressSegment one = first.getSegment(prefixedSection);
			AddressSegment two = other.getSegment(prefixedSection + otherIndex);
			if(!one.equals(two)) {
				return false;
			}
		}
		return true;
	}
	protected static <S extends AddressSegment> S[] createSegments(
			S segments[],
			long highBytes,
			long lowBytes,
			int bitsPerSegment,
			AddressNetwork<S> network,
			Integer prefixLength) {
		AddressSegmentCreator<S> creator = network.getAddressCreator();
		int segmentMask = ~(~0 << bitsPerSegment);
		int lowIndex = Math.max(0, segments.length - (Long.SIZE / bitsPerSegment));
		int segmentIndex = segments.length - 1;
		long bytes = lowBytes;
		while(true) {
			while(true) {
				Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
				int value = segmentMask & (int) bytes;
				S seg = creator.createSegment(value, segmentPrefixLength);
				if(!isCompatibleNetworks(network, seg.getNetwork())) {
					throw new NetworkMismatchException(seg);
				}
				segments[segmentIndex] = seg;
				if(--segmentIndex < lowIndex) {
					break;
				}
				bytes >>>= bitsPerSegment;
			}
			if(lowIndex == 0) {
				break;
			}
			lowIndex = 0;
			bytes = highBytes;
		}
		return segments;
	}
	protected static boolean isCompatibleNetworks(AddressNetwork<?> one, AddressNetwork<?> two) {
		return one.getPrefixConfiguration().equals(two.getPrefixConfiguration());
	}
	protected static <S extends AddressSegment> S[] createSegments(
			S segments[],
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			int bytesPerSegment,
			int bitsPerSegment,
			AddressNetwork<S> network,
			Integer prefixLength) {
		AddressSegmentCreator<S> creator = network.getAddressCreator();
		int segmentCount = segments.length;
		for(int segmentIndex = 0; segmentIndex < segmentCount; segmentIndex++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
			if(segmentPrefixLength != null && segmentPrefixLength == 0 && network.getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				S allSeg = creator.createSegment(0, cacheBits(0));
				if(!isCompatibleNetworks(network, allSeg.getNetwork())) {
					throw new NetworkMismatchException(allSeg);
				}
				Arrays.fill(segments, segmentIndex, segmentCount, allSeg);
				break;
			}
			int value = 0, value2 = 0;
			if(lowerValueProvider == null) {
				value = upperValueProvider.getValue(segmentIndex);
			} else {
				value = lowerValueProvider.getValue(segmentIndex);
				if(upperValueProvider != null) {
					value2 = upperValueProvider.getValue(segmentIndex);
				}
			}
			S seg = (lowerValueProvider != null && upperValueProvider != null) ? 
					creator.createSegment(value, value2, segmentPrefixLength) : 
						creator.createSegment(value, segmentPrefixLength);
			if(!isCompatibleNetworks(network, seg.getNetwork())) {
				throw new NetworkMismatchException(seg);
			}
			segments[segmentIndex] = seg;
		}
		return segments;
	}
	protected static <S extends AddressSegment> S[] toSegments(
			S segments[],
			byte bytes[],
			int startIndex,
			int endIndex,
			int bytesPerSegment,
			int bitsPerSegment,
			AddressNetwork<S> network,
			Integer prefixLength) {
		if(endIndex < 0 || endIndex > bytes.length) {
			throw new AddressValueException(endIndex);
		}
		if(startIndex < 0 || startIndex > endIndex) {
			throw new AddressValueException(startIndex);
		}
		AddressSegmentCreator<S> creator = network.getAddressCreator();
		int segmentCount = segments.length;
		int expectedByteCount = segmentCount * bytesPerSegment;
		int missingBytes = expectedByteCount + startIndex - endIndex;
		if(missingBytes < 0) {
			int expectedStartIndex = endIndex - expectedByteCount;
			int higherStartIndex = expectedStartIndex - 1;
			byte expectedExtendedValue = bytes[higherStartIndex];
			if(expectedExtendedValue != 0) {
				int mostSignificantBit = bytes[expectedStartIndex] >>> 7;
				if(mostSignificantBit != 0) {
					if(expectedExtendedValue != -1) {
						throw new AddressValueException(expectedExtendedValue);
					}
				} else {
					throw new AddressValueException(expectedExtendedValue);
				}
			}
			while(startIndex < higherStartIndex) {
				if(bytes[--higherStartIndex] != expectedExtendedValue) {
					throw new AddressValueException(expectedExtendedValue);
				}
			}
			startIndex = expectedStartIndex;
			missingBytes = 0;
		}
		boolean allPrefixedAddressesAreSubnets = network.getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		for(int i = 0, segmentIndex = 0; i < expectedByteCount; segmentIndex++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
			if(allPrefixedAddressesAreSubnets && segmentPrefixLength != null && segmentPrefixLength == 0) {
				S allSeg = creator.createSegment(0, cacheBits(0));
				if(!isCompatibleNetworks(network, allSeg.getNetwork())) {
					throw new NetworkMismatchException(allSeg);
				}
				Arrays.fill(segments, segmentIndex, segmentCount, allSeg);
				break;
			}
			int value = 0;
			int k = bytesPerSegment + i;
			int j = i;
			if(j < missingBytes) {
				int mostSignificantBit = bytes[startIndex] >>> 7;
				if(mostSignificantBit == 0) {
					j = missingBytes;
				} else {
					int upper = Math.min(missingBytes, k);
					for(; j < upper; j++) {
						value <<= 8;
						value |= 0xff;
					}
				}
			}
			for(; j < k; j++) {
				int byteValue = 0xff & bytes[startIndex + j - missingBytes];
				value <<= 8;
				value |= byteValue;
			}
			i = k;
			S seg = creator.createSegment(value, segmentPrefixLength);
			if(!isCompatibleNetworks(network, seg.getNetwork())) {
				throw new NetworkMismatchException(seg);
			}
			segments[segmentIndex] = seg;
		}
		return segments;
	}
	protected static <R extends AddressSection, S extends AddressSegment> S[] createSingle(
			R original,
			AddressSegmentCreator<S> segmentCreator,
			IntFunction<S> segProducer) {
		int segmentCount = original.getSegmentCount();
		S segs[] = segmentCreator.createSegmentArray(segmentCount);
		for(int i = 0; i < segmentCount; i++) {
			segs[i] = segProducer.apply(i);
		}
		return segs;
	}
	protected static <R extends AddressSegmentSeries> R getSingleLowestOrHighestSection(R section) {
		if(!section.isMultiple() && !(section.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets())) {
			return section;
		}
		return null;
	}
	protected static <R extends AddressSection, S extends AddressSegment> R reverseSegments(R section, AddressCreator<?, R, ?, S> creator, IntFunction<S> segProducer, boolean removePrefix) {
		int count = section.getSegmentCount();
		S newSegs[] = creator.createSegmentArray(count);
		int halfCount = count >>> 1;
		int i = 0;
		boolean isSame = !removePrefix || !section.isPrefixed();
		for(int j = count - 1; i < halfCount; i++, j--) {
			newSegs[j] = segProducer.apply(i);
			newSegs[i] = segProducer.apply(j);
			if(isSame && !(newSegs[i].equals(section.getSegment(i)) && newSegs[j].equals(section.getSegment(j)))) {
				isSame = false;
			}
		}
		if((count & 1) == 1) {
			newSegs[i] = segProducer.apply(i);
			if(isSame && !newSegs[i].equals(section.getSegment(i))) {
				isSame = false;
			}
		}
		if(isSame) {
			return section;
		}
		return creator.createSectionInternal(newSegs);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R reverseBits(
			boolean perByte, R section, AddressCreator<?, R, ?, S> creator, IntFunction<S> segBitReverser, boolean removePrefix) {
		if(perByte) {
			boolean isSame = !removePrefix || !section.isPrefixed();
			int count = section.getSegmentCount();
			S newSegs[] = creator.createSegmentArray(count);
			for(int i = 0; i < count; i++) {
				newSegs[i] = segBitReverser.apply(i);
				if(isSame && !newSegs[i].equals(section.getSegment(i))) {
					isSame = false;
				}
			}
			if(isSame) {
				return section;
			}
			return creator.createSectionInternal(newSegs);
		}
		return reverseSegments(section, creator, segBitReverser, removePrefix);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R reverseBytes(
			boolean perSegment, R section, AddressCreator<?, R, ?, S> creator, IntFunction<S> segByteReverser, boolean removePrefix) {
		if(perSegment) {
			boolean isSame = !removePrefix || !section.isPrefixed();
			int count = section.getSegmentCount();
			S newSegs[] = creator.createSegmentArray(count);
			for(int i = 0; i < count; i++) {
				newSegs[i] = segByteReverser.apply(i);
				if(isSame && !newSegs[i].equals(section.getSegment(i))) {
					isSame = false;
				}
			}
			if(isSame) {
				return section;
			}
			return creator.createSectionInternal(newSegs);
		}
		return reverseSegments(section, creator, segByteReverser, removePrefix);
	}
	protected static interface GroupingCreator<S extends AddressDivisionBase> {
		S createDivision(long value, long upperValue, int bitCount, int radix);
	}
	protected <S extends AddressDivisionBase> S[] createNewDivisions(int bitsPerDigit, GroupingCreator<S> groupingCreator, IntFunction<S[]> groupingArrayCreator) {
		return createNewPrefixedDivisions(bitsPerDigit, null, null,
				(value, upperValue, bitCount, radix, network, prefixLength) -> groupingCreator.createDivision(value, upperValue, bitCount, radix),
				groupingArrayCreator);
	}
	protected static interface PrefixedGroupingCreator<S extends AddressDivisionBase> {
		S createDivision(long value, long upperValue, int bitCount, int radix, IPAddressNetwork<?, ?, ?, ?, ?> network, Integer prefixLength);
	}
	protected <S extends AddressDivisionBase> S[] createNewPrefixedDivisions(int bitsPerDigit, IPAddressNetwork<?, ?, ?, ?, ?> network, Integer networkPrefixLength, PrefixedGroupingCreator<S> groupingCreator, IntFunction<S[]> groupingArrayCreator) {
		if(bitsPerDigit >= Integer.SIZE) {
			throw new AddressValueException(bitsPerDigit);
		}
		int bitCount = getBitCount();
		List<Integer> bitDivs = new ArrayList<Integer>(bitsPerDigit);
		int largestBitCount = Long.SIZE - 1;
		largestBitCount -= largestBitCount % bitsPerDigit;
		do {
			if(bitCount <= largestBitCount) {
				int mod = bitCount % bitsPerDigit;
				int secondLast = bitCount - mod;
				if(secondLast > 0) {
					bitDivs.add(cacheBits(secondLast));
				}
				if(mod > 0) {
					bitDivs.add(cacheBits(mod));
				}
				break;
			} else {
				bitCount -= largestBitCount;
				bitDivs.add(cacheBits(largestBitCount));
			}
		} while(true);
		int bitDivSize = bitDivs.size();
		S divs[] = groupingArrayCreator.apply(bitDivSize);
		int currentSegmentIndex = 0;
		AddressDivision seg = getDivision(currentSegmentIndex);
		long segLowerVal = seg.getDivisionValue();
		long segUpperVal = seg.getUpperDivisionValue();
		int segBits = seg.getBitCount();
		int bitsSoFar = 0;
		int radix = AddressDivision.getRadixPower(BigInteger.valueOf(2), bitsPerDigit).intValue();
		for(int i = bitDivSize - 1; i >= 0; i--) {
			int originalDivBitSize, divBitSize;
			originalDivBitSize = divBitSize = bitDivs.get(i);
			long divLowerValue, divUpperValue;
			divLowerValue = divUpperValue = 0;
			while(true) {
				if(segBits >= divBitSize) {
					int diff = segBits - divBitSize;
					divLowerValue |= segLowerVal >>> diff;
					long shift = ~(~0L << diff);
					segLowerVal &= shift;
					divUpperValue |= segUpperVal >>> diff;
					segUpperVal &= shift;
					segBits = diff;
					Integer segPrefixBits = networkPrefixLength == null ? null : getSegmentPrefixLength(originalDivBitSize, networkPrefixLength - bitsSoFar);
					S div = groupingCreator.createDivision(divLowerValue, divUpperValue, originalDivBitSize, radix, network, segPrefixBits);
					divs[bitDivSize - i - 1] = div;
					if(segBits == 0 && i > 0) {
						seg = getDivision(++currentSegmentIndex);
						segLowerVal = seg.getDivisionValue();
						segUpperVal = seg.getUpperDivisionValue();
						segBits = seg.getBitCount();
					}
					break;
				} else {
					int diff = divBitSize - segBits;
					divLowerValue |= segLowerVal << diff;
					divUpperValue |= segUpperVal << diff;
					divBitSize = diff;
					seg = getDivision(++currentSegmentIndex);
					segLowerVal = seg.getDivisionValue();
					segUpperVal = seg.getUpperDivisionValue();
					segBits = seg.getBitCount();
				}
			}
			bitsSoFar += originalDivBitSize;
		}
		return divs;
	}
	protected static <I extends AddressSegmentSeries, S extends AddressSegment> boolean split(
			SplitterSink<I, ?> beingSplit,
			Function<S[], I> transformer,
			AddressSegmentCreator<S> segmentCreator,
			S originalSegments[],
			int networkSegmentIndex, 
			int hostSegmentIndex, 
			Integer prefixLength) {
		int i = 0;
		S lowerSeg, upperSeg;
		lowerSeg = upperSeg = null;
		boolean isSplit = false;
		for(; i < hostSegmentIndex; i++) {
			S seg = originalSegments[i];
			if(seg.isMultiple()) {
				isSplit = true;
				int lower = seg.getSegmentValue();
				int upper = seg.getUpperSegmentValue();
				int size = upper - lower;
				int mid = lower + (size >>> 1);
				Integer pref = getSegmentPrefixLength(seg.getBitCount(), prefixLength, i);
				lowerSeg = segmentCreator.createSegment(lower, mid, pref);
				upperSeg = segmentCreator.createSegment(mid + 1, upper, pref);
				break;
			}
		}
		if(i == networkSegmentIndex && !isSplit) {
			S seg = originalSegments[i];
			int segBitCount = seg.getBitCount();
			Integer pref = getSegmentPrefixLength(segBitCount, prefixLength, i);
			int shiftAdjustment = segBitCount - pref;
			int lower = seg.getSegmentValue();
			int upper = seg.getUpperSegmentValue();
			int originalLower = lower, originalUpper = upper;
			lower >>>= shiftAdjustment;
			upper >>>= shiftAdjustment;
			if(lower != upper) {
				isSplit = true;
				int size = upper - lower;
				int mid = lower + (size >>> 1);
				int next = mid + 1;
				mid = (mid << shiftAdjustment) | ~(~0 << shiftAdjustment);
				next <<= shiftAdjustment;
				lowerSeg = segmentCreator.createSegment(originalLower, mid, pref);
				upperSeg = segmentCreator.createSegment(next, originalUpper, pref);
			}
		}
		if(isSplit) {
			int len = originalSegments.length;
			S lowerSegs[] = segmentCreator.createSegmentArray(len);
			S upperSegs[] = segmentCreator.createSegmentArray(len);
			System.arraycopy(originalSegments, 0, lowerSegs, 0, i);
			System.arraycopy(originalSegments, 0, upperSegs, 0, i);
			int j = i + 1;
			lowerSegs[i] = lowerSeg;
			upperSegs[i] = upperSeg;
			System.arraycopy(originalSegments, j, lowerSegs, j, len - j);
			System.arraycopy(originalSegments, j, upperSegs, j, len - j);
			beingSplit.setSplitValues(transformer.apply(lowerSegs), transformer.apply(upperSegs));
		}
		return isSplit;
	}
	protected static <R extends AddressSection, S extends AddressSegment> Iterator<R> iterator(
			boolean useOriginal,
			R original,
			AddressCreator<?, R, ?, S> creator,
			Iterator<S[]> iterator,
			Integer prefixLength) {
		if(useOriginal) {
			return new Iterator<R>() {
				R orig = original;
				@Override
				public R next() {
					if(orig == null) {
			    		throw new NoSuchElementException();
			    	}
					R result = orig;
			    	orig = null;
				    return result;
			    }
				@Override
				public boolean hasNext() {
					return orig != null;
				}
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		return new Iterator<R>() {
			@Override
			public R next() {
				if(!iterator.hasNext()) {
		    		throw new NoSuchElementException();
		    	}
				S next[] = iterator.next();
				return createIteratedSection(next, creator, prefixLength);
			}
			@Override
			public boolean hasNext() {
				return iterator.hasNext();
			}
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	protected static <T extends Address, S extends AddressSegment> T createIteratedAddress(
			S next[],
			AddressCreator<T, ?, ?, S> creator,
			Integer prefixLength) {
		return creator.createAddressInternal(next, prefixLength, true);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R createIteratedSection(
			S next[],
			AddressCreator<?, R, ?, S> creator,
			Integer prefixLength) {
		return creator.createPrefixedSectionInternal(next, prefixLength, true);
	}
	protected static <S extends AddressSegment> Iterator<S[]> segmentsIterator(
			int divCount,
			AddressSegmentCreator<S> segmentCreator,
			Supplier<S[]> segSupplier,
			IntFunction<Iterator<S>> segIteratorProducer,
			Predicate<S[]> excludeFunc) {
		return segmentsIterator(divCount, segmentCreator, segSupplier, segIteratorProducer, excludeFunc, divCount - 1, divCount, null);
	}
	protected static <S extends AddressSegment> Iterator<S[]> segmentsIterator(
			int divCount,
			AddressSegmentCreator<S> segmentCreator,
			Supplier<S[]> segSupplier,
			IntFunction<Iterator<S>> segIteratorProducer,
			Predicate<S[]> excludeFunc,
			int networkSegmentIndex,
			int hostSegmentIndex,
			IntFunction<Iterator<S>> hostSegIteratorProducer) {
		if(segSupplier != null) {
			return new Iterator<S[]>() {
				S result[] = segSupplier.get(); {
					if(excludeFunc != null && excludeFunc.test(result)) {
						result = null;
					}
				}
				@Override
				public boolean hasNext() {
					return result != null;
				}
			    @Override
				public S[] next() {
			    	if(result == null) {
			    		throw new NoSuchElementException();
			    	}
			    	S res[] = result;
			    	result = null;
			    	return res;
			    }
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		return new Iterator<S[]>() {
			private boolean done;
			@SuppressWarnings("unchecked")
			private final Iterator<S> variations[] = new Iterator[divCount];
			private S nextSet[] = segmentCreator.createSegmentArray(divCount);  {
				updateVariations(0);
				for(int i = networkSegmentIndex + 1; i < divCount; i++) {
					variations[i] = hostSegIteratorProducer.apply(i);
					nextSet[i] = variations[i].next();
				}
				if(excludeFunc != null && excludeFunc.test(nextSet)) {
					increment();
				}
			}
			private void updateVariations(int start) {
				int i = start;
				for(; i < hostSegmentIndex; i++) {
					variations[i] = segIteratorProducer.apply(i);
					nextSet[i] = variations[i].next();
				}
				if(i == networkSegmentIndex) {
					variations[i] = hostSegIteratorProducer.apply(i);
					nextSet[i] = variations[i].next();
				}
			}
			@Override
			public boolean hasNext() {
				return !done;
			}
		    @Override
			public S[] next() {
		    	if(done) {
		    		throw new NoSuchElementException();
		    	}
		    	return increment();
		    }
		    private S[] increment() {
		    	S previousSegs[] = null;
		    	for(int j = networkSegmentIndex; j >= 0; j--) {
		    		while(variations[j].hasNext()) {
		    			if(previousSegs == null) {
		    				previousSegs = nextSet.clone();
		    			}
		    			nextSet[j] = variations[j].next();
		    			updateVariations(j + 1);
		    			if(excludeFunc != null && excludeFunc.test(nextSet)) {
		    				j = networkSegmentIndex;
						} else {
							return previousSegs;
						}
		    		}
		    	}
		    	done = true;
		    	return previousSegs == null ? nextSet : previousSegs;
		    }
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	protected static <T extends Address, S extends AddressSegment> Iterator<T> iterator(
			boolean useOriginal,
			T original,
			AddressCreator<T, ?, ?, S> creator,
			Iterator<S[]> iterator, 
			Integer prefixLength ) {
		if(useOriginal) {
			return new Iterator<T>() {
				T orig = original;
				@Override
				public boolean hasNext() {
					return orig != null;
				}
			    @Override
				public T next() {
			    	if(orig == null) {
			    		throw new NoSuchElementException();
			    	}
			    	T result = orig;
			    	orig = null;
			    	return result;
			    }
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		return new Iterator<T>() {
			@Override
			public boolean hasNext() {
				return iterator.hasNext();
			}
		    @Override
			public T next() {
		    	if(!hasNext()) {
		    		throw new NoSuchElementException();
		    	}
		    	S[] next = iterator.next();
		    	return createIteratedAddress(next, creator, prefixLength);
		    }
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	protected static void checkOverflow(
			long increment,
			LongSupplier lower,
			LongSupplier upper,
			LongSupplier counter,
			BooleanSupplier isSequential,
			LongSupplier maxValue) {
		if(increment < 0) {
			if(lower.getAsLong() < -increment) {
				throw new AddressValueException(increment);
			}
		} else if(isSequential.getAsBoolean()) {
			if(increment > maxValue.getAsLong() - lower.getAsLong()) {
				throw new AddressValueException(increment);
			}
		} else {
			long count = counter.getAsLong();
			if(increment >= count && increment - (count - 1) > maxValue.getAsLong() - upper.getAsLong()) {
				throw new AddressValueException(increment);
			}
		}
	}
	protected static void checkOverflow(
			long increment,
			BigInteger bigIncrement,
			Supplier<BigInteger> lower,
			Supplier<BigInteger> upper,
			Supplier<BigInteger> counter,
			BooleanSupplier isSequential,
			Supplier<BigInteger> maxValue) {
		checkOverflow(increment < 0, bigIncrement, lower, upper, counter, isSequential, maxValue);
	}
	protected static void checkOverflow(
			BigInteger bigIncrement,
			Supplier<BigInteger> lower,
			Supplier<BigInteger> upper,
			Supplier<BigInteger> counter,
			BooleanSupplier isSequential,
			Supplier<BigInteger> maxValue) {
		checkOverflow(bigIncrement.signum() < 0, bigIncrement, lower, upper, counter, isSequential, maxValue);
	}
	private static void checkOverflow(
			boolean incrementIsNegative,
			BigInteger bigIncrement,
			Supplier<BigInteger> lower,
			Supplier<BigInteger> upper,
			Supplier<BigInteger> counter,
			BooleanSupplier isSequential,
			Supplier<BigInteger> maxValue) {
		if(incrementIsNegative) {
			if(lower.get().compareTo(bigIncrement.negate()) < 0) {
				throw new AddressValueException(bigIncrement);
			}
		} else if(isSequential.getAsBoolean()) {
			if(bigIncrement.compareTo(maxValue.get().subtract(lower.get())) > 0) {
				throw new AddressValueException(bigIncrement);
			}
		} else {
			BigInteger count = counter.get();
			if(bigIncrement.compareTo(count) >= 0 && bigIncrement.subtract(count.subtract(BigInteger.ONE)).compareTo(maxValue.get().subtract(upper.get())) > 0) {
				throw new AddressValueException(bigIncrement);
			}
		}
	}
	protected static <R extends AddressSection, S extends AddressSegment> R fastIncrement(
			R section,
			long increment,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(increment >= 0) {
			BigInteger count = section.getCount();
			if(count.compareTo(LONG_MAX) <= 0) {
				long longCount = count.longValue();
				if(longCount > increment) {
					if(longCount == increment + 1) {
						return upperProducer.get();
					}
					return incrementRange(section, increment, addrCreator, lowerProducer, prefixLength);
				}
				BigInteger upperValue = section.getUpperValue();
				if(upperValue.compareTo(LONG_MAX) <= 0) {
					return increment(
							section,
							increment,
							addrCreator,
							count::longValue,
							() -> section.getValue().longValue(),
							upperValue::longValue,
							lowerProducer,
							upperProducer,
							prefixLength);
				}
			}
		} else {
			BigInteger value = section.getValue();
			if(value.compareTo(LONG_MAX) <= 0) {
				return add(lowerProducer.get(), value.longValue(), increment, addrCreator, prefixLength);
			}
		}
		return null;
	}
	protected static <R extends AddressSection, S extends AddressSegment> R increment(
			R section,
			long increment,
			AddressCreator<?, R, ?, S> addrCreator, 
			LongSupplier counter,
			LongSupplier lower,
			LongSupplier upper,
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(!section.isMultiple()) {
			return add(section, lower.getAsLong(), increment, addrCreator, prefixLength);
		}
		boolean isDecrement = increment <= 0;
		if(isDecrement) {
			return add(lowerProducer.get(), lower.getAsLong(), increment, addrCreator, prefixLength);
		} 
		long count = counter.getAsLong();
		if(count > increment) {
			if(count == increment + 1) {
				return upperProducer.get();
			}
			return incrementRange(section, increment, addrCreator, lowerProducer, prefixLength);
		}
		long upperValue = upper.getAsLong();
		if(increment <= Long.MAX_VALUE - upperValue) {
			return add(upperProducer.get(), upperValue, increment - (count - 1), addrCreator, prefixLength);
		}
		return add(upperProducer.get(), BigInteger.valueOf(increment - (count - 1)), addrCreator, prefixLength);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R increment(
			R section,
			long increment,
			BigInteger bigIncrement,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(!section.isMultiple()) {
			return add(section, bigIncrement, addrCreator, prefixLength);
		}
		boolean isDecrement = increment <= 0;
		if(isDecrement) {
			return add(lowerProducer.get(), bigIncrement, addrCreator, prefixLength);
		}
		BigInteger count = section.getCount();
		BigInteger incrementPlus1 = bigIncrement.add(BigInteger.ONE);
		int countCompare = count.compareTo(incrementPlus1);
		if(countCompare <= 0) {
			if(countCompare == 0) {
				return upperProducer.get();
			}
			return add(upperProducer.get(), incrementPlus1.subtract(count), addrCreator, prefixLength);
		}
		return incrementRange(section, increment, addrCreator, lowerProducer, prefixLength);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R increment(
			R section,
			BigInteger bigIncrement,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(!section.isMultiple()) {
			return add(section, bigIncrement, addrCreator, prefixLength);
		}
		boolean isDecrement = bigIncrement.signum() <= 0;
		if(isDecrement) {
			return add(lowerProducer.get(), bigIncrement, addrCreator, prefixLength);
		}
		BigInteger count = section.getCount();
		BigInteger incrementPlus1 = bigIncrement.add(BigInteger.ONE);
		int countCompare = count.compareTo(incrementPlus1);
		if(countCompare <= 0) {
			if(countCompare == 0) {
				return upperProducer.get();
			}
			return add(upperProducer.get(), incrementPlus1.subtract(count), addrCreator, prefixLength);
		}
		return incrementRange(section, bigIncrement, addrCreator, lowerProducer, prefixLength);
	}
	@SuppressWarnings("unchecked")
	protected static <R extends AddressSection, S extends AddressSegment> R incrementRange(
			R section,
			long increment,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Integer prefixLength) {
		if(increment == 0) {
			return lowerProducer.get();
		}
		int segCount = section.getSegmentCount();
		S newSegments[];
		if(segCount > 0) {
			int i = segCount - 1;
			AddressSegment seg = section.getSegment(i);
			int bitCount = seg.getBitCount();
			newSegments = addrCreator.createSegmentArray(segCount);
			while(true) {
				int segValue = seg.getSegmentValue();
				long revolutions;
				int remainder;
				S newSegment;
				long segRange = seg.getValueCount();
				if(bitCount == IPv6Address.BITS_PER_SEGMENT && segRange == IPv6Address.MAX_VALUE_PER_SEGMENT + 1) {
					revolutions = increment >>> IPv6Address.BITS_PER_SEGMENT;
					remainder = (int) (increment & IPv6Address.MAX_VALUE_PER_SEGMENT);
					newSegment = addrCreator.createSegment(remainder);
				} else if(bitCount == IPv4Address.BITS_PER_SEGMENT && segRange == IPv4Address.MAX_VALUE_PER_SEGMENT + 1) {
					revolutions = increment >>> IPv4Address.BITS_PER_SEGMENT;
					remainder = (int) (increment & IPv4Address.MAX_VALUE_PER_SEGMENT);
					newSegment = addrCreator.createSegment(remainder);
				} else if(segRange == 1) {
					revolutions = increment;
					newSegment = addrCreator.createSegment(segValue);
				} else {
					revolutions = increment / segRange;
					remainder = (int) (increment % segRange);
					newSegment = addrCreator.createSegment(segValue + remainder);
				}
				newSegments[i] = newSegment;
				if(revolutions == 0) {
					for(i--; i >= 0; i--) {
						AddressSegment original = section.getSegment(i);
						newSegments[i] = addrCreator.createSegment(original.getSegmentValue());
					}
					break;
				}
				if(--i < 0) {
					break;
				}
				increment = revolutions;
				seg = section.getSegment(i);
			}
		} else {
			newSegments = (S[]) section.getSegments();
		}
		return createIteratedSection(newSegments, addrCreator, prefixLength);
	}
	private static <R extends AddressSection, S extends AddressSegment> R incrementRange(
			R section,
			BigInteger bigIncrement,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Integer prefixLength) {
		if(bigIncrement.signum() == 0) {
			return lowerProducer.get();
		}
		int segCount = section.getSegmentCount();
		S newSegments[] = addrCreator.createSegmentArray(segCount);
		for(int i = segCount - 1; i >= 0; i--) {
			AddressSegment seg = section.getSegment(i);
			int segValue = seg.getSegmentValue();
			long segRange = (seg.getUpperSegmentValue() - segValue) + 1L;
			BigInteger divs[] = bigIncrement.divideAndRemainder(BigInteger.valueOf(segRange)); 
			BigInteger revolutions = divs[0];
			int remainder = divs[1].intValue();
			S newSegment = addrCreator.createSegment(segValue + remainder);
			newSegments[i] = newSegment;
			if(revolutions.signum() == 0) {
				for(i--; i >= 0; i--) {
					AddressSegment original = section.getSegment(i);
					newSegments[i] = addrCreator.createSegment(original.getSegmentValue());
				}
				break;
			} else {
				bigIncrement = revolutions;
			}
		}
		return createIteratedSection(newSegments, addrCreator, prefixLength);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R add(
			R section, BigInteger increment, AddressCreator<?, R, ?, S> addrCreator, Integer prefixLength) {
		if(section.isMultiple()) {
			throw new IllegalArgumentException();
		}
		int segCount = section.getSegmentCount();
		BigInteger fullValue = section.getValue();
		fullValue = fullValue.add(increment);
		byte bytes[] = fullValue.toByteArray();
		return addrCreator.createSectionInternal(bytes, segCount, prefixLength, true);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R add(
			R section, long fullValue, long increment, AddressCreator<?, R, ?, S> addrCreator, Integer prefixLength) {
		if(section.isMultiple()) {
			throw new IllegalArgumentException();
		}
		int segCount = section.getSegmentCount();
		S newSegs[] = addrCreator.createSegmentArray(segCount);
		createSegments(
					newSegs,
					0,
					fullValue + increment,
					section.getBitsPerSegment(),
					addrCreator.getNetwork(),
					prefixLength);
		return createIteratedSection(newSegs, addrCreator, prefixLength);
	}
	protected static Long enumerateSmall(AddressSegmentSeries series, AddressSegmentSeries otherSeries) {
		if(otherSeries.isMultiple()) {
			return null;
		} else if(otherSeries == series) { 
			return 0L;
		}
		return enumerateSmallImpl(series, otherSeries);
	}
	protected static Long enumerateSmallImpl(AddressSegmentSeries series, AddressSegmentSeries otherSeries) {
		if(series.isMultiple()) {
			if(!series.isSequential()) {
				if(series.getUpper().compareTo(otherSeries) < 0) {
					return (otherSeries.getValue().longValue() - series.getUpperValue().longValue()) + (series.getCount().longValue() - 1L);
				} else if(series.getLower().compareTo(otherSeries) <= 0) {
					long total = 0;
					long cumulativeSize = 1;
					for(int i = series.getSegmentCount() - 1; ; i--) {
						AddressSegment segment = series.getSegment(i), otherSegment = otherSeries.getSegment(i);
						int otherValue = otherSegment.getSegmentValue();
						int segValue = segment.getSegmentValue();
						if(otherValue < segValue || otherValue > segment.getUpperSegmentValue()) {
							return null;
						}
						total += cumulativeSize * (otherValue - segValue);
						if(i == 0) {
							return total;
						}
						cumulativeSize *= segment.getValueCount();
					}
				}
			}
		}
		return otherSeries.getValue().longValue() - series.getValue().longValue();
	}
	protected static BigInteger enumerateBig(AddressSegmentSeries series, AddressSegmentSeries otherSeries) {
		int segmentCount = series.getSegmentCount();
		if(segmentCount != otherSeries.getSegmentCount()) {
			throw new SizeMismatchException(series, otherSeries);
		} else if(otherSeries.isMultiple()) {
			return null;
		} else if(otherSeries == series) { 
			return BigInteger.ZERO;
		}
		boolean initialSegsMatch = true;
		int bitsPerSegment = series.getBitsPerSegment();
		int totalBits = ParsedAddressGrouping.getTotalBits(segmentCount, series.getBytesPerSegment(), bitsPerSegment);
		int i = 0;
		while(totalBits > Long.SIZE) {
			AddressSegment seg = series.getSegment(i);
			AddressSegment otherSeg = otherSeries.getSegment(i);
			if(!seg.matches(otherSeg.getSegmentValue())) {
				initialSegsMatch = false;
				break;
			}
			totalBits -= bitsPerSegment;
			i++;
		}
		if(initialSegsMatch) {
			if(totalBits == Long.SIZE) {
				AddressSegment seg = series.getSegment(i);
				AddressSegment otherSeg = otherSeries.getSegment(i);
				int mask = (1 << bitsPerSegment) >>> 1;
				if(seg.matchesWithMask(otherSeg.getSegmentValue() & mask, mask)) {
					Long result = enumerateSmallImpl(series, otherSeries);
					if(result == null) {
						return null;
					}
					return BigInteger.valueOf(result);
				}
			} else {
				Long result = enumerateSmallImpl(series, otherSeries);
				if(result == null) {
					return null;
				}
				return BigInteger.valueOf(result);
			}
		}
		if(series.isMultiple()) {
			if(!series.isSequential()) {
				if(series.getUpper().compareTo(otherSeries) < 0) {
					return otherSeries.getValue().subtract(series.getUpperValue()).add(series.getCount().subtract(BigInteger.ONE));
				} else if(series.getLower().compareTo(otherSeries) <= 0) {
					BigInteger total = BigInteger.ZERO;
					BigInteger cumulativeSize = BigInteger.ONE;
					for(int j = series.getSegmentCount() - 1; ; j--) {
						AddressSegment segment = series.getSegment(j), otherSegment = otherSeries.getSegment(j);
						int otherValue = otherSegment.getSegmentValue();
						int segValue = segment.getSegmentValue();
						if(otherValue < segValue || otherValue > segment.getUpperSegmentValue()) {
							return null;
						}
						total = total.add(cumulativeSize.multiply(BigInteger.valueOf(otherValue - segValue)));
						if(j == 0) {
							return total;
						}
						cumulativeSize = cumulativeSize.multiply(segment.getCount());
					}
				}
			}
		}
		return otherSeries.getValue().subtract(series.getValue());
	}
	protected static BigInteger count(IntUnaryOperator segmentValueCountProvider, int segCount, int safeMultiplies, long safeLimit) {
		int i = 0;
		BigInteger result = BigInteger.ONE;
		if(segCount == 0) {
			return result;
		}
		while(true) {
			long curResult = segmentValueCountProvider.applyAsInt(i++);
			if(i == segCount) {
				return mult(result, curResult);
			}
			int limit = i + safeMultiplies;
			if(segCount <= limit) {
				while(i < segCount) {
					curResult *= segmentValueCountProvider.applyAsInt(i++);
				}
				return mult(result, curResult);
			}
			while(i < limit) {
				curResult *= segmentValueCountProvider.applyAsInt(i++);
			}
			while(curResult <= safeLimit) {
				curResult *= segmentValueCountProvider.applyAsInt(i++);
				if(i == segCount) {
					return mult(result, curResult);
				}
			}
			result = mult(result, curResult);
		}
	}
	private static BigInteger mult(BigInteger currentResult, long newResult) {
		if(newResult == 1) {
			return currentResult;
		}
		BigInteger newBig = BigInteger.valueOf(newResult);
		if(currentResult == BigInteger.ONE) {
			return newBig;
		}
		return currentResult.multiply(newBig);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R getSection(
			int index,
			int endIndex,
			R section,
			AddressCreator<?, R, ?, S> creator) {
		if(index == 0 && endIndex == section.getSegmentCount()) {
			return section;
		}
		int segmentCount = endIndex - index;
		if(segmentCount < 0) {
			throw new IndexOutOfBoundsException();
		}
		S segs[] = creator.createSegmentArray(segmentCount);
		section.getSegments(index, endIndex, segs, 0);
		return creator.createSectionInternal(segs);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R append(
			R section,
			R other,
			AddressCreator<?, R, ?, S> creator) {
		int otherSegmentCount = other.getSegmentCount();
		int segmentCount = section.getSegmentCount();
		int totalSegmentCount = segmentCount + otherSegmentCount;
		S segs[] = creator.createSegmentArray(totalSegmentCount);
		section.getSegments(0, segmentCount, segs, 0);
		if(section.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			S allSegment = creator.createSegment(0, cacheBits(0));
			Arrays.fill(segs, segmentCount, totalSegmentCount, allSegment);
		} else {
			other.getSegments(0, otherSegmentCount, segs, segmentCount);
		}
		return creator.createSectionInternal(segs);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R replace(
			R section,
			int index,
			int endIndex,
			R replacement,
			int replacementStartIndex,
			int replacementEndIndex,
			AddressCreator<?, R, ?, S> creator,
			boolean appendNetwork,
			boolean isMac) {
		int otherSegmentCount = replacementEndIndex  - replacementStartIndex;
		int segmentCount = section.getSegmentCount();
		int totalSegmentCount = segmentCount + otherSegmentCount - (endIndex - index);
		S segs[] = creator.createSegmentArray(totalSegmentCount);
		section.getSegments(0, index, segs, 0);
		if(index < totalSegmentCount) {
			if(section.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() &&
					(appendNetwork ?
							(getHostSegmentIndex(section.getPrefixLength(), section.getBytesPerSegment(), section.getBitsPerSegment()) < index) :
							(getNetworkSegmentIndex(section.getPrefixLength(), section.getBytesPerSegment(), section.getBitsPerSegment()) < index)) && 
					(isMac || index > 0)) { 
				S allSegment = creator.createSegment(0, cacheBits(0));
				Arrays.fill(segs, index, totalSegmentCount, allSegment);
				return creator.createSectionInternal(segs);
			}
			replacement.getSegments(replacementStartIndex, replacementEndIndex, segs, index);
			if(index + otherSegmentCount < totalSegmentCount) {
				if(replacement.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && 
						getNetworkSegmentIndex(replacement.getPrefixLength(), replacement.getBytesPerSegment(), replacement.getBitsPerSegment()) < replacementEndIndex && 
						(isMac || otherSegmentCount > 0)) {
					S allSegment = creator.createSegment(0, cacheBits(0));
					Arrays.fill(segs, index + otherSegmentCount, totalSegmentCount, allSegment);
				} else {
					section.getSegments(endIndex, segmentCount, segs, index + otherSegmentCount);
				}
			}
		}
		return creator.createSectionInternal(segs);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R createSectionInternal(AddressCreator<?, R, ?, S> creator, S[] segments, int startIndex, boolean extended) {
		return creator.createSectionInternal(segments, startIndex, extended);
	}
	protected boolean isDualString() throws IncompatibleAddressException {
		int count = getDivisionCount();
		for(int i = 0; i < count; i++) {
			AddressDivision division = getDivision(i);
			if(division.isMultiple()) {
				boolean isLastFull = true;
				AddressDivision lastDivision = null;
				for(int j = count - 1; j >= 0; j--) {
					division = getDivision(j);
					if(division.isMultiple()) {
						if(!isLastFull) {
							throw new IncompatibleAddressException(division, i, lastDivision, i + 1, "ipaddress.error.segmentMismatch");
						}
						isLastFull = division.isFullRange();
					} else {
						isLastFull = false;
					}
					lastDivision = division;
				}
				return true;
			}
		}
		return false;
	}
	protected static <T extends AddressStringDivisionSeries, E extends AddressStringDivisionSeries> String 
			toNormalizedStringRange(AddressStringParams<T> params, T lower, T upper, CharSequence zone) {
		int length = params.getStringLength(lower, null) + params.getStringLength(upper, zone);
		StringBuilder builder;
		String separator = params.getWildcards().rangeSeparator;
		if(separator != null) {
			length += separator.length();
			builder = new StringBuilder(length);
			params.append(params.append(builder, lower, null).append(separator), upper, zone);
		} else {
			builder = new StringBuilder(length);
			params.append(params.append(builder, lower, null), upper, zone);
		}
		AddressStringParams.checkLengths(length, builder);
		return builder.toString();
	}
	protected void checkSegmentCount(AddressSection sec) throws SizeMismatchException {
		if(sec.getDivisionCount() != getDivisionCount()) {
			throw new SizeMismatchException(this, sec);
		}
	}
	public static class StringOptions extends StringOptionsBase {
		public static class Wildcards {
			public final String rangeSeparator;
			public final String wildcard;
			public final String singleWildcard;
			public Wildcards() {
				this(Address.RANGE_SEPARATOR_STR, Address.SEGMENT_WILDCARD_STR, null);
			}
			public Wildcards(String wildcard, String singleWildcard) {
				this(Address.RANGE_SEPARATOR_STR, wildcard, singleWildcard);
			}
			public Wildcards(String rangeSeparator) {
				this(rangeSeparator, null, null);
			}
			public Wildcards(String rangeSeparator, String wildcard, String singleWildcard) {
				if(rangeSeparator == null) {
					rangeSeparator = Address.RANGE_SEPARATOR_STR;
				}
				this.rangeSeparator = rangeSeparator;
				this.wildcard = wildcard;
				this.singleWildcard = singleWildcard;
			}
			@Override
			public String toString() {
				return "range separator: " + rangeSeparator + "\nwildcard: " + wildcard + "\nsingle wildcard: " + singleWildcard;
			}
		}
		public final Wildcards wildcards;
		public final boolean expandSegments;
		public final int base;
		public final String segmentStrPrefix;
		public final Character separator;
		public final String addrLabel;
		public final boolean reverse;
		public final boolean splitDigits;
		public final boolean uppercase;
		protected StringOptions(
				int base,
				boolean expandSegments,
				Wildcards wildcards,
				String segmentStrPrefix,
				Character separator,
				String label,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			this.expandSegments = expandSegments;
			this.wildcards = wildcards;
			this.base = base;
			if(segmentStrPrefix == null) {
				throw new NullPointerException("segment str");
			}
			this.segmentStrPrefix = segmentStrPrefix;
			this.separator = separator;
			if(label == null) {
				throw new NullPointerException("label");
			}
			this.addrLabel = label;
			this.reverse = reverse;
			this.splitDigits = splitDigits;
			this.uppercase = uppercase;
		}
		public static class Builder {
			public static final Wildcards DEFAULT_WILDCARDS = new Wildcards();
			protected Wildcards wildcards = DEFAULT_WILDCARDS;
			protected boolean expandSegments;
			protected int base;
			protected String segmentStrPrefix = "";
			protected Character separator;
			protected String addrLabel = "";
			protected boolean reverse;
			protected boolean splitDigits;
			protected boolean uppercase;
			public Builder(int base) {
				this.base = base;
				this.separator = ' ';
			}
			public Builder(int base, char separator) {
				this.base = base;
				this.separator = separator;
			}
			public Builder setWildcards(Wildcards wildcards) {
				this.wildcards = wildcards;
				return this;
			}
			public Builder setReverse(boolean reverse) {
				this.reverse = reverse;
				return this;
			}
			public Builder setUppercase(boolean uppercase) {
				this.uppercase = uppercase;
				return this;
			}
			public Builder setSplitDigits(boolean splitDigits) {
				this.splitDigits = splitDigits;
				return this;
			}
			public Builder setExpandedSegments(boolean expandSegments) {
				this.expandSegments = expandSegments;
				return this;
			}
			public Builder setRadix(int base) {
				this.base = base;
				return this;
			}
			public Builder setSeparator(Character separator) {
				this.separator = separator;
				return this;
			}
			public Builder setAddressLabel(String label) {
				this.addrLabel = label;
				return this;
			}
			public Builder setSegmentStrPrefix(String prefix) {
				this.segmentStrPrefix = prefix;
				return this;
			}
			public StringOptions toOptions() {
				return new StringOptions(base, expandSegments, wildcards, segmentStrPrefix, separator, addrLabel, reverse, splitDigits, uppercase);
			}
		}
	}
}
package inet.ipaddr.format.large;
import java.math.BigInteger;
import java.util.Arrays;
import inet.ipaddr.Address;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.AddressDivisionBase;
import inet.ipaddr.format.IPAddressGenericDivision;
import inet.ipaddr.format.standard.AddressDivision;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.standard.IPAddressDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.format.util.AddressSegmentParams;
public class IPAddressLargeDivision extends AddressDivisionBase implements IPAddressGenericDivision {
	private static final BigInteger LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);
	public static final char EXTENDED_DIGITS_RANGE_SEPARATOR = Address.ALTERNATIVE_RANGE_SEPARATOR;
	public static final String EXTENDED_DIGITS_RANGE_SEPARATOR_STR = String.valueOf(EXTENDED_DIGITS_RANGE_SEPARATOR);
	private static final long serialVersionUID = 4L;
	private final BigInteger value, upperValue, maxValue, upperValueMasked;
	private final BigInteger defaultRadix; 
	private final int bitCount;
	private final Integer networkPrefixLength;
	private final boolean isSinglePrefixBlock, isPrefixBlock;
	protected transient String cachedString;
	public IPAddressLargeDivision(byte bytes[], int bitCount, int defaultRadix) throws AddressValueException {
		if(defaultRadix < MIN_RADIX || defaultRadix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		maxValue = getMaxValue(bitCount);
		this.bitCount = bitCount;
		this.defaultRadix = BigInteger.valueOf(defaultRadix);
		isPrefixBlock = isSinglePrefixBlock = false;
		upperValueMasked = upperValue = value = new BigInteger(1, bytes);
		networkPrefixLength = null;
		if(upperValue.compareTo(maxValue) > 0) {
			throw new AddressValueException(upperValue);
		}
	}
	public IPAddressLargeDivision(byte bytes[], int bitCount, int defaultRadix, IPAddressNetwork<?, ?, ?, ?, ?> network, Integer prefixLength) throws AddressValueException {
		if(prefixLength != null && prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		} else if(defaultRadix < MIN_RADIX || defaultRadix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		maxValue = getMaxValue(bitCount);
		this.bitCount = bitCount;
		this.defaultRadix = BigInteger.valueOf(defaultRadix);
		if(prefixLength == null || prefixLength >= bitCount) {
			if(prefixLength != null && prefixLength > bitCount) {
				prefixLength = bitCount;
			}
			isPrefixBlock = isSinglePrefixBlock = prefixLength != null;
			upperValueMasked = upperValue = value = new BigInteger(1, bytes);
		} else {
			bytes = extend(bytes, bitCount);
			byte upperBytes[] = bytes.clone();
			int shift = bitCount - prefixLength;
			int byteShift = (shift + 7) >>> 3;
			int byteIndex = bytes.length - byteShift;
			int mask = 0xff & (~0 << (((shift - 1) % 8) + 1));
			if(network.getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				bytes[byteIndex] &= mask;
				Arrays.fill(bytes, byteIndex + 1, bytes.length, (byte) 0);
				upperValueMasked = value = new BigInteger(1, bytes);
				upperBytes[byteIndex] |= ~mask;
				Arrays.fill(upperBytes, byteIndex + 1, bytes.length, (byte) 0xff);
				upperValue = new BigInteger(1, upperBytes);
				isPrefixBlock = isSinglePrefixBlock = true;
			} else {
				byte maskedUpperBytes[] = upperBytes.clone();
				maskedUpperBytes[byteIndex] &= mask;
				Arrays.fill(maskedUpperBytes, byteIndex + 1, bytes.length, (byte) 0);
				upperValueMasked = new BigInteger(1, maskedUpperBytes);
				upperValue = value = new BigInteger(1, bytes);
				isPrefixBlock = isSinglePrefixBlock = false;
			}
		}
		if(upperValue.compareTo(maxValue) > 0) {
			throw new AddressValueException(upperValue);
		}
		networkPrefixLength = prefixLength;
	}
	public IPAddressLargeDivision(
			byte bytes[], byte upperBytes[], int bitCount, int defaultRadix, IPAddressNetwork<?, ?, ?, ?, ?> network, Integer prefixLength) throws AddressValueException {
		if(prefixLength != null && prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		} else if(defaultRadix < MIN_RADIX || defaultRadix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		bytes = extend(bytes, bitCount);
		upperBytes = extend(upperBytes, bitCount);
		maxValue = getMaxValue(bitCount);
		this.bitCount = bitCount;
		this.defaultRadix = BigInteger.valueOf(defaultRadix);
		if(prefixLength == null || prefixLength >= bitCount) {
			if(prefixLength != null && prefixLength > bitCount) {
				prefixLength = bitCount;
			}
			BigInteger low, high;
			if(Arrays.equals(bytes, upperBytes)) {
				low = high = new BigInteger(1, bytes);
				isSinglePrefixBlock = prefixLength != null;
			} else {
				low = new BigInteger(1, bytes);
				high = new BigInteger(1, upperBytes);
				if(low.compareTo(high) > 0) {
					BigInteger tmp = high;
					high = low;
					low = tmp;
				}
				isSinglePrefixBlock = false;
			}
			isPrefixBlock = prefixLength != null;
			value = low;
			upperValueMasked = upperValue = high;
		} else {
			int shift = bitCount - prefixLength;
			int byteShift = (shift + 7) >>> 3;
			int byteIndex = bytes.length - byteShift;
			int mask = 0xff & (~0 << (((shift - 1) % 8) + 1));
			int upperByteIndex = upperBytes.length - byteShift;
			if(network.getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				BigInteger low, high, highMasked;
				while(true) {
					bytes[byteIndex] &= mask;
					Arrays.fill(bytes, byteIndex + 1, bytes.length, (byte) 0);
					low = new BigInteger(1, bytes);
					upperBytes[upperByteIndex] |= ~mask;
					Arrays.fill(upperBytes, upperByteIndex + 1, upperBytes.length, (byte) 0xff);
					high = new BigInteger(1, upperBytes);
					byte maskedUpperBytes[] = upperBytes.clone();
					maskedUpperBytes[upperByteIndex] &= mask;
					Arrays.fill(maskedUpperBytes, upperByteIndex + 1, upperBytes.length, (byte) 0);
					highMasked = new BigInteger(1, maskedUpperBytes);
					if(low.compareTo(high) > 0) {
						byte tmp[] = upperBytes;
						upperBytes = bytes;
						bytes = tmp;
						continue;
					}
					break;
				}
				value = low;
				upperValue = high;
				upperValueMasked = highMasked;
				isPrefixBlock = true;
				isSinglePrefixBlock = isPrefixSubnetBlock(bytes, upperBytes, bitCount, prefixLength, true, false);
			} else {
				BigInteger low, high;
				if(Arrays.equals(bytes, upperBytes)) {
					low = high = new BigInteger(1, bytes);
					isPrefixBlock = isSinglePrefixBlock = false;
				} else {
					low = new BigInteger(1, bytes);
					high = new BigInteger(1, upperBytes);
					boolean backIsPrefixed = isPrefixSubnetBlock(bytes, upperBytes, bitCount, prefixLength, false, true);
					if(backIsPrefixed) {
						isPrefixBlock = true;
						isSinglePrefixBlock = isPrefixSubnetBlock(bytes, upperBytes, bitCount, prefixLength, true, false);
					} else {
						isPrefixBlock = isSinglePrefixBlock = false;
					}
					if(low.compareTo(high) > 0) {
						BigInteger tmp = high;
						high = low;
						low = tmp;
					}
				}
				value = low;
				upperValue = high;
				byte maskedUpperBytes[] = upperBytes.clone();
				maskedUpperBytes[byteIndex] &= mask;
				Arrays.fill(maskedUpperBytes, byteIndex + 1, bytes.length, (byte) 0);
				upperValueMasked = new BigInteger(1, maskedUpperBytes);
			}
		}
		if(upperValue.compareTo(maxValue) > 0) {
			throw new AddressValueException(upperValue);
		}
		networkPrefixLength = prefixLength;
	}
	@Override
	public BigInteger getValue() {
		return value;
	}
	@Override
	public BigInteger getUpperValue() {
		return upperValue;
	}
	private static boolean isPrefixSubnetBlock(byte bytes[], byte upperBytes[], int bitCount, Integer prefix, boolean front, boolean back) {
		if(prefix == null) {
			return false;
		}
		int shift = bitCount - prefix;
		int byteShift = (shift + 7) >>> 3;
		int byteIndex = bytes.length - byteShift;
		int mask = 0xff & (~0 << (((shift - 1) % 8) + 1));
		byte lowerByte = bytes[byteIndex];
		byte upperByte = upperBytes[byteIndex];
		if(front) {
			int lower = lowerByte & mask;
			int upper = upperByte & mask;
			if(lower != upper) {
				return false;
			}
			for(int i = byteIndex - 1; i >= 0; i--) {
				if(bytes[i] != upperBytes[i]) {
					return false;
				}
			}
		}
		if(back) {
			int hostMask = 0xff & ~mask;
			int lower = lowerByte & hostMask;
			int upper = upperByte & hostMask;
			if(lower != 0 || upper != hostMask) {
				return false;
			}
			for(int i = byteIndex + 1; i < bytes.length; i++) {
				if(bytes[i] != 0 || upperBytes[i] != (byte) 0xff) {
					return false;
				}
			}
		}
		return true;
	}
	private static byte[] extend(byte bytes[], int bitCount) {
		return convert(bytes, (bitCount + 7) >>> 3, "");
	}
	private static byte[] convert(byte bytes[], int requiredByteCount, String key) {
		int len = bytes.length;
		if(len < requiredByteCount) {
			byte oldBytes[] = bytes;
			bytes = new byte[requiredByteCount];
			int diff = bytes.length - oldBytes.length;
			int mostSignificantBit = 0x80 & oldBytes[0];
			if(mostSignificantBit != 0) {
				Arrays.fill(bytes, 0, diff, (byte) 0xff);
			}
			System.arraycopy(oldBytes, 0, bytes, diff, oldBytes.length);
		} else {
			if(len > requiredByteCount) {
				int i = 0;
				do {
					if(bytes[i++] != 0) {
						throw new AddressValueException(key, len);
					}
				} while(--len > requiredByteCount);
				bytes = Arrays.copyOfRange(bytes, i, bytes.length);
			}
		}
		return bytes;
	}
	@Override
	public boolean isBoundedBy(int val) {
		BigInteger bigVal = BigInteger.valueOf(val);
		return getUpperValue().compareTo(bigVal) < 0;
	}
	@Override
	public int getDigitCount(int radix) {
		if(!isMultiple() && radix == getDefaultTextualRadix()) {
			return getString().length();
		}
		return getDigitCountStatic(getUpperValue(), radix);
	}
	@Override
	public int getBitCount() {
		return bitCount;
	}
	@Override
	public boolean isMultiple() {
		return !getValue().equals(getUpperValue());
	}
	@Override
	public boolean includesZero() {
		return getValue().signum() == 0;
	}
	@Override
	public boolean includesMax() {
		return getUpperValue().equals(maxValue);
	}
	@Override
	public boolean isMax() {
		return includesMax() && !isMultiple();
	}
	@Override
	public boolean isZero() {
		return includesZero() && !isMultiple();
	}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		return convert(low ? getValue().toByteArray() : getUpperValue().toByteArray(), (bitCount + 7) >>> 3, "");
	}
	@Override
	public int getDefaultTextualRadix() {
		return defaultRadix.intValue();
	}
	@Override
	public int getMaxDigitCount() {
		return getMaxDigitCount(defaultRadix.intValue(), bitCount, maxValue);
	}
	@Override
	public int getMaxDigitCount(int radix) {
		return getMaxDigitCount(radix, bitCount, maxValue);
	}
	@Override
	protected int adjustLowerLeadingZeroCount(int leadingZeroCount, int radix) {
		return adjustLeadingZeroCount(leadingZeroCount, getValue(), radix);
	}
	@Override
	protected int adjustUpperLeadingZeroCount(int leadingZeroCount, int radix) {
		return adjustLeadingZeroCount(leadingZeroCount, getUpperValue(), radix);
	}
	private int adjustLeadingZeroCount(int leadingZeroCount, BigInteger value, int radix) {
		if(leadingZeroCount < 0) {
			int width = getDigitCount(value, radix);
			return Math.max(0, getMaxDigitCount(radix) - width);
		}
		return leadingZeroCount;
	}
	private int getDigitCount(BigInteger val, int radix) {
		BigInteger bigRadix = defaultRadix.intValue() == radix ? defaultRadix : BigInteger.valueOf(radix);
		return getDigitCount(val, bigRadix);
	}
	private static int getDigitCountStatic(BigInteger val, int radix) {
		return getDigitCount(val, BigInteger.valueOf(radix));
	}
	private String toDefaultString(BigInteger val, int radix, boolean uppercase, int choppedDigits) {
		BigInteger bigRadix = defaultRadix.intValue() == radix ? defaultRadix : BigInteger.valueOf(radix);
		return toDefaultString(val, bigRadix, uppercase, choppedDigits, getMaxDigitCount(radix, bitCount, null));
	}
	private static void toDefaultStringRecursive(BigInteger val, BigInteger radix, boolean uppercase, int choppedDigits, int digitCount, char dig[], boolean highest, StringBuilder builder) {
		if(val.compareTo(LONG_MAX) <= 0) {
			long longVal = val.longValue();
			int intRadix = radix.intValue();
			if(!highest) {
				getLeadingZeros(digitCount - toUnsignedStringLength(longVal, intRadix), builder);
			}
			toUnsignedStringCased(longVal, intRadix, choppedDigits, uppercase, builder);
		} else {
			if(digitCount > choppedDigits) {
				int halfCount = digitCount >>> 1;
				BigInteger radixPower = getRadixPower(radix, halfCount);
				BigInteger highLow[] = val.divideAndRemainder(radixPower);
				BigInteger high = highLow[0];
				BigInteger low = highLow[1];
				if(highest && high.signum() == 0) {
					toDefaultStringRecursive(low, radix, uppercase, choppedDigits, halfCount, dig, true, builder);
				} else {
					toDefaultStringRecursive(high, radix, uppercase, Math.max(0,  choppedDigits - halfCount), digitCount - halfCount, dig, highest, builder);
					toDefaultStringRecursive(low, radix, uppercase, choppedDigits, halfCount, dig, false, builder);
				}
			}
		}
	}
	private boolean isExtendedDigits() {
		return isExtendedDigits(defaultRadix.intValue());
	}
	private static boolean isExtendedDigits(int radix) {
		return radix > 36;
	}
	private static char[] getDigits(int radix, boolean uppercase) {
		if(isExtendedDigits(radix)) {
			return EXTENDED_DIGITS;
		}
		return uppercase ? UPPERCASE_DIGITS : DIGITS;
	}
	@Override
	protected void appendUppercase(CharSequence str, int radix, StringBuilder appendable) {
		if(radix > 10 && !isExtendedDigits()) {
			for(int i = 0; i < str.length(); i++) {
				char c = str.charAt(i);
				if(c >= 'a' && c <= 'z') {
					c += 'A' - 'a';
				}
				appendable.append(c);
			}
		} else {
			appendable.append(str);
		}
	}
	private static String toDefaultString(BigInteger val, BigInteger radix, boolean uppercase, int choppedDigits, int maxDigits) {
		if(radix.compareTo(BIG_MIN_RADIX) < 0 || radix.compareTo(BIG_MAX_RADIX) > 0) {
			throw new IllegalArgumentException();
		} else if(val.equals(BigInteger.ZERO)) {
			return "0";
		} else if(val.equals(BigInteger.ONE)) {
			return "1";
		}
		char dig[] = getDigits(radix.intValue(), uppercase);
		StringBuilder builder;
		if(maxDigits > 0) {
			if(maxDigits <= choppedDigits) {
				return "";
			}
			builder = new StringBuilder();
			toDefaultStringRecursive(val, radix, uppercase, choppedDigits, maxDigits, dig, true, builder);
		} else {
			builder = null;
			do {
				BigInteger divisorRemainder[] = val.divideAndRemainder(radix);
				BigInteger quotient = divisorRemainder[0];
				BigInteger remainder = divisorRemainder[1];
				if(choppedDigits > 0) {
					--choppedDigits;
					continue;
				}
				if(builder == null) {
					builder = new StringBuilder();
				}
				builder.append(dig[remainder.intValue()]);
				val = quotient;
			} while(val.signum() != 0);
			if(builder == null) {
				return "";
			}
			builder.reverse();
		}
		return builder.toString();
	}
	@Override
	public String getString() {
		String result = cachedString;
		if(result == null) {
			synchronized(this) {
				result = cachedString;
				if(result == null) {
					if(isSinglePrefixBlock() || !isMultiple()) { 
						result = getDefaultLowerString();
					} else if(!isFullRange() || (result = getDefaultSegmentWildcardString()) == null) {
						if(isPrefixBlock()) {
							result = getDefaultMaskedRangeString();
						} else {
							result = getDefaultRangeString();
						}
					}
					cachedString = result;
				}
			}
		}
		return result;
	}
	@Override
	protected String getCachedDefaultLowerString() {
		String result = cachedString;
		if(result == null) {
			synchronized(this) {
				result = cachedString;
				if(result == null) {
					cachedString = result = getDefaultLowerString();
				}
			}
		}
		return result;
	}
	@Override
	public String getWildcardString() {
		String result = cachedWildcardString;
		if(result == null) {
			synchronized(this) {
				result = cachedWildcardString;
				if(result == null) {
					if(!isPrefixed() || !isMultiple()) {
						result = getString();
					} else if(!isFullRange() || (result = getDefaultSegmentWildcardString()) == null) {
						result = getDefaultRangeString();
					}
					cachedWildcardString = result;
				}
			}
		}
		return result;
	}
	@Override
	protected String getDefaultLowerString() {
		return toDefaultString(getValue(), defaultRadix, false, 0, getMaxDigitCount());
	}
	@Override
	protected String getDefaultRangeString() {
		int maxDigitCount = getMaxDigitCount();
		return toDefaultString(getValue(), defaultRadix, false, 0, maxDigitCount) + 
				getDefaultRangeSeparatorString() + 
				toDefaultString(getUpperValue(), defaultRadix, false, 0, maxDigitCount);
	}
	protected String getDefaultMaskedRangeString() {
		int maxDigitCount = getMaxDigitCount();
		return toDefaultString(getValue(), defaultRadix, false, 0, maxDigitCount) + 
				getDefaultRangeSeparatorString() + 
				toDefaultString(upperValueMasked, defaultRadix, false, 0, maxDigitCount);
	}
	@Override
	protected String getDefaultRangeSeparatorString() {
		return isExtendedDigits()  ? EXTENDED_DIGITS_RANGE_SEPARATOR_STR : Address.RANGE_SEPARATOR_STR;
	}
	@Override
	protected int getLowerStringLength(int radix) {
		return getDigitCount(getValue(), radix);
	}
	@Override
	protected int getUpperStringLength(int radix) {
		return getDigitCount(getUpperValue(), radix);
	}
	@Override
	protected void getLowerString(int radix, boolean uppercase, StringBuilder appendable) {
		appendable.append(toDefaultString(getValue(), radix, uppercase, 0));
	}
	@Override
	protected void getLowerString(int radix, int choppedDigits, boolean uppercase, StringBuilder appendable) {
		appendable.append(toDefaultString(getValue(), radix, uppercase, choppedDigits));
	}
	@Override
	protected void getUpperString(int radix, boolean uppercase, StringBuilder appendable) {
		appendable.append(toDefaultString(getUpperValue(), radix, uppercase, 0));
	}
	@Override
	protected void getUpperStringMasked(int radix, boolean uppercase, StringBuilder appendable) {
		appendable.append(toDefaultString(upperValueMasked, radix, uppercase, 0));
	}
	@Override
	protected void getSplitLowerString(int radix, int choppedDigits, boolean uppercase,
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix, StringBuilder appendable) {
		StringBuilder builder = new StringBuilder();
		getLowerString(radix, choppedDigits, uppercase, builder);
		int prefLen = stringPrefix.length();
		for(int i = 0; i < builder.length(); i++) {
			if(i > 0) {
				appendable.append(splitDigitSeparator);
			}
			if(prefLen > 0) {
				appendable.append(stringPrefix);
			}
			appendable.append(builder.charAt(reverseSplitDigits ? (builder.length() - i - 1) : i));
		}
	}
	@Override
	protected void getSplitRangeString(String rangeSeparator, String wildcard, int radix, boolean uppercase,
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix, StringBuilder appendable) {
		StringBuilder lowerBuilder = new StringBuilder();
		StringBuilder upperBuilder = new StringBuilder();
		getLowerString(radix, uppercase, lowerBuilder);
		getUpperString(radix, uppercase, upperBuilder);
		int diff = upperBuilder.length() - lowerBuilder.length();
		if(diff > 0) {
			StringBuilder newLowerBuilder = new StringBuilder();
			while(diff-- > 0) {
				newLowerBuilder.append('0');
			}
			newLowerBuilder.append(lowerBuilder);
			lowerBuilder = newLowerBuilder;
		}
		boolean previousWasFull = true;
		boolean nextMustBeFull = false;
		char dig[] = getDigits(radix, uppercase);
		char zeroDigit = dig[0];
		char highestDigit = dig[radix - 1];
		int len = lowerBuilder.length();
		int prefLen = stringPrefix.length();
		for(int i = 0; i < len; i++) {
			int index = reverseSplitDigits ? (len - i - 1) : i;
			char lower = lowerBuilder.charAt(index);
			char upper = upperBuilder.charAt(index);
			if(i > 0) {
				appendable.append(splitDigitSeparator);
			}
			if(lower == upper) {
				if(nextMustBeFull) {
					throw new IncompatibleAddressException(lower, upper, "ipaddress.error.splitMismatch");
				}
				if(prefLen > 0) {
					appendable.append(stringPrefix);
				}
				appendable.append(lower);
			} else {
				boolean isFullRange = (lower == zeroDigit) && (upper == highestDigit);
				if(isFullRange) {
					appendable.append(wildcard);
				} else {
					if(nextMustBeFull) {
						throw new IncompatibleAddressException(lower, upper, "ipaddress.error.splitMismatch");
					}
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					appendable.append(lower);
					appendable.append(rangeSeparator);
					appendable.append(upper);
				}
				if(reverseSplitDigits) {
					if(!previousWasFull) {
						throw new IncompatibleAddressException(lower, upper, "ipaddress.error.splitMismatch");
					}
					previousWasFull = isFullRange;
				} else {
					nextMustBeFull = true;
				}
			}
		}
	}
	@Override
	protected int getSplitRangeStringLength(String rangeSeparator, String wildcard, int leadingZeroCount,
			int radix, boolean uppercase, char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix) {
		int digitsLength = -1;
		int stringPrefixLength = stringPrefix.length();
		StringBuilder lowerBuilder = new StringBuilder();
		StringBuilder upperBuilder = new StringBuilder();
		getLowerString(radix, uppercase, lowerBuilder);
		getUpperString(radix, uppercase, upperBuilder);
		char dig[] = getDigits(radix, uppercase);
		char zeroDigit = dig[0];
		char highestDigit = dig[radix - 1];
		int remainingAfterLoop = leadingZeroCount;
		for(int i = 1; i <= upperBuilder.length(); i++) {
			char lower = (i <= lowerBuilder.length()) ? lowerBuilder.charAt(lowerBuilder.length() - i) : 0;
			int upperIndex = upperBuilder.length() - i;
			char upper = upperBuilder.charAt(upperIndex);
			boolean isFullRange = (lower == zeroDigit) && (upper == highestDigit);
			if(isFullRange) {
				digitsLength += wildcard.length() + 1;
			} else if (lower != upper ){
				digitsLength += (stringPrefixLength << 1) + 4 ; 
			} else {
				remainingAfterLoop += upperIndex + 1;
				break;
			}
		}
		if(remainingAfterLoop > 0) {
			digitsLength += remainingAfterLoop * (stringPrefixLength + 2);
		}
		return digitsLength;
	}
	@Override
	protected int getRangeDigitCount(int radix) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		} else if(!isMultiple()) {
			return 0;
		}
		BigInteger val = getValue(), upperVal = getUpperValue();
		int count = 1;
		BigInteger bigRadix = BigInteger.valueOf(radix);
		BigInteger bigUpper = BigInteger.valueOf(radix - 1);
		while(true) {
			BigInteger highLow[] = val.divideAndRemainder(bigRadix);
			BigInteger quotient = highLow[0];
			BigInteger remainder = highLow[1];
			if(remainder.signum() == 0) {
				highLow = upperVal.divideAndRemainder(bigRadix);
				BigInteger upperQuotient = highLow[0];
				remainder = highLow[1];
				if(remainder.equals(bigUpper)) {
					val = quotient;
					upperVal = upperQuotient;
					if(val.equals(upperVal)) {
						return count;
					} else {
						count++;
						continue;
					}
				}
			}
			return 0;
		}
	}
	@Override
	public int getPrefixAdjustedRangeString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		return super.getPrefixAdjustedRangeString(segmentIndex, params, appendable);
	}
	@Override
	public boolean isPrefixBlock() {
		return isPrefixBlock;
	}
	@Override
	public boolean isSinglePrefixBlock() {
		return isSinglePrefixBlock;
	}
	@Override
	public Integer getDivisionPrefixLength() {
		return networkPrefixLength;
	}
	@Override
	public boolean isPrefixed() {
		return networkPrefixLength != null;
	}
	@Override
	protected boolean isSameValues(AddressDivisionBase otherSegment) {
		return otherSegment instanceof IPAddressLargeDivision && super.isSameValues(otherSegment);
	}
	@Override
	public boolean equals(Object other) {
		if(other == this) {
			return true;
		}
		if(other instanceof IPAddressLargeDivision) {
			IPAddressLargeDivision otherSegments = (IPAddressLargeDivision) other;
			return getBitCount() == otherSegments.getBitCount() && otherSegments.isSameValues(this);
		}
		return false;
	}
}
package inet.ipaddr.format.standard;
import java.util.Arrays;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.InconsistentPrefixException;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.AddressDivisionSeries;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.ipv6.IPv6Address;
public class IPAddressDivisionGrouping extends AddressDivisionGrouping implements IPAddressDivisionSeries {
	private static final long serialVersionUID = 4L;
	private final IPAddressNetwork<?, ?, ?, ?, ?> network;
	protected static final RangeCache ZEROS_CACHE = new RangeCache();
	static {
		if(RangeCache.PRELOAD_CACHE) {
			ZEROS_CACHE.preloadCache(-1);
		}
	}
	public IPAddressDivisionGrouping(IPAddressDivision divisions[], IPAddressNetwork<?, ?, ?, ?, ?> network) throws AddressValueException {
		super(divisions);
		if(network == null) {
			throw new NullPointerException(getMessage("ipaddress.error.nullNetwork"));
		}
		this.network = network;
		int totalPrefixBits = 0;
		for(int i = 0; i < divisions.length; i++) {
			IPAddressDivision division = divisions[i];
			Integer divPrefix = division.getDivisionPrefixLength();
			if(divPrefix != null) {
				cachedPrefixLength = cacheBits(totalPrefixBits + divPrefix);
				for(++i; i < divisions.length; i++) {
					division = divisions[i];
					divPrefix = division.getDivisionPrefixLength();
					if(divPrefix == null || divPrefix != 0) {
						throw new InconsistentPrefixException(divisions[i - 1], division, divPrefix);
					}
				}
				return;
			}
			totalPrefixBits += division.getBitCount();
		}
		cachedPrefixLength = NO_PREFIX_LENGTH;
	}
	protected IPAddressDivisionGrouping(IPAddressDivision divisions[], boolean checkSegs) {
		super(divisions, checkSegs);
		network = getNetwork();
		if(network == null) {
			throw new NullPointerException(getMessage("ipaddress.error.nullNetwork"));
		}
	}
	@Override
	public IPAddressNetwork<?, ?, ?, ?, ?> getNetwork() {
		return network;
	}
	@Override
	public IPAddressDivision getDivision(int index) {
		return (IPAddressDivision) super.getDivision(index);
	}
	@Override
	public int isMore(AddressDivisionSeries other) {
		if(!isMultiple()) {
			return other.isMultiple() ? -1 : 0;
		}
		if(!other.isMultiple()) {
			return 1;
		}
		if(isSinglePrefixBlock() && other.isSinglePrefixBlock()) {
			int bits = getBitCount() - getPrefixLength();
			int otherBits = other.getBitCount() - other.getPrefixLength();
			return bits - otherBits;
		}
		return getCount().compareTo(other.getCount());
	}
	@Override
	public Integer getPrefixLength() {
		return getNetworkPrefixLength();
	}
	@Override
	public Integer getNetworkPrefixLength() {
		Integer ret = cachedPrefixLength;
		if(ret == null) {
			Integer result = calculatePrefix(this);
			if(result != null) {
				return cachedPrefixLength = result;
			}
			cachedPrefixLength = NO_PREFIX_LENGTH;
			return null;
		}
		if(ret.intValue() == NO_PREFIX_LENGTH.intValue()) {
			return null;
		}
		return ret;
	}
	public int getTrailingBitCount(boolean network) {
		int count = getDivisionCount();
		if(count == 0) {
			return 0;
		}
		long back = network ? 0 : getDivision(0).getMaxValue();
		int bitLen = 0;
		for(int i = count - 1; i >= 0; i--) {
			IPAddressDivision seg = getDivision(i);
			long value = seg.getDivisionValue();
			if(value != back) {
				return bitLen + seg.getTrailingBitCount(network);
			}
			bitLen += seg.getBitCount();
		}
		return bitLen;
	}
	public int getLeadingBitCount(boolean network) {
		int count = getDivisionCount();
		if(count == 0) {
			return 0;
		}
		long front = network ? getDivision(0).getMaxValue() : 0;
		int prefixLen = 0;
		for(int i = 0; i < count; i++) {
			IPAddressDivision seg = getDivision(i);
			long value = seg.getDivisionValue();
			if(value != front) {
				return prefixLen + seg.getLeadingBitCount(network);
			}
			prefixLen += seg.getBitCount();
		}
		return prefixLen;
	}
	@Override
	public boolean isPrefixBlock() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null) {
			return false;
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return true;
		}
		return containsPrefixBlock(networkPrefixLength);
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		return containsPrefixBlock(this, prefixLength);
	}
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		return containsSinglePrefixBlock(this, prefixLength);
	}
	@Override
	public boolean isSinglePrefixBlock() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null) {
			return false;
		}
		return containsSinglePrefixBlock(networkPrefixLength);
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		return getPrefixLengthForSingleBlock(this);
	}
	public boolean includesZeroHost() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return false;
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return true;
		}
		int divCount = getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressDivision div = getDivision(i);
			Integer segmentPrefixLength = div.getDivisionPrefixLength();
			if(segmentPrefixLength != null) {
				long mask = ~(~0L << (div.getBitCount() - segmentPrefixLength));
				if((mask & div.getDivisionValue()) != 0) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = getDivision(i);
					if(!div.includesZero()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof IPAddressDivisionGrouping && super.isSameGrouping(other);
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof IPAddressDivisionGrouping) {
			IPAddressDivisionGrouping other = (IPAddressDivisionGrouping) o;
			return other.isSameGrouping(this); 
		}
		return false;
	}
	protected static boolean prefixContains(IPAddressSection first, IPAddressSection other, int otherIndex) {
		if(otherIndex < 0) {
			return false;
		}
		Integer prefixLength = first.getPrefixLength();
		int prefixedSection;
		if(prefixLength == null) {
			prefixedSection = first.getSegmentCount();
			int oIndex = prefixedSection + otherIndex;
			if(oIndex > other.getSegmentCount()) {
				return false;
			}
		} else {
			prefixedSection = getNetworkSegmentIndex(prefixLength, first.getBytesPerSegment(), first.getBitsPerSegment());
			if(prefixedSection >= 0) {
				int oIndex = prefixedSection + otherIndex;
				if(oIndex >= other.getSegmentCount()) {
					return false;
				}
				IPAddressSegment one = first.getSegment(prefixedSection);
				IPAddressSegment two = other.getSegment(oIndex);
				int segPrefixLength = getPrefixedSegmentPrefixLength(one.getBitCount(), prefixLength, prefixedSection);
				if(!one.prefixContains(two, segPrefixLength)) {
					return false;
				}
			}
		}
		while(--prefixedSection >= 0) {
			IPAddressSegment one = first.getSegment(prefixedSection);
			IPAddressSegment two = other.getSegment(prefixedSection + otherIndex);
			if(!one.contains(two)) {
				return false;
			}
		}
		return true;
	}
	public RangeList getZeroSegments() {
		return getZeroSegments(false);
	}
	public RangeList getZeroRangeSegments() {
		if(isPrefixed()) {
			return getZeroSegments(true);
		}
		return getZeroSegments();
	}
	protected static RangeList getNoZerosRange() {
		return RangeCache.NO_ZEROS;
	}
	protected static RangeList getSingleRange(int index, int len) {
		RangeCache cache = ZEROS_CACHE.addRange(index, -1, len);
		return cache.get();
	}
	protected RangeList getZeroSegments(boolean includeRanges) {
		RangeCache cache = ZEROS_CACHE;
		int divisionCount = getDivisionCount();
		boolean isFullRangeHost = !getNetwork().getPrefixConfiguration().prefixedSubnetsAreExplicit() && isPrefixBlock();
		includeRanges &= isFullRangeHost;
		int currentIndex = -1, lastIndex = -1, currentCount = 0;
		for(int i = 0; i < divisionCount; i++) {
			IPAddressDivision division = getDivision(i);
			boolean isCompressible = division.isZero() || 
					(includeRanges && division.isPrefixed() && division.isSinglePrefixBlock(0, division.getDivisionPrefixLength()));
			if(isCompressible) {
				if(++currentCount == 1) {
					currentIndex = i;
				}
				if(i == divisionCount - 1) {
					cache = cache.addRange(currentIndex, lastIndex, currentCount);
					lastIndex = currentIndex + currentCount;
				}
			} else if(currentCount > 0) {
				cache = cache.addRange(currentIndex, lastIndex, currentCount);
				lastIndex = currentIndex + currentCount;
				currentCount = 0;
			}
		}
		return cache.get();
	}
	public static class Range {
		public final int index;
		public final int length;
		Range(int index, int length) {
			this.index = index;
			this.length = length;
		}
		@Override
		public String toString() {
			return "[" + index + ',' + (index + length) + ']';
		}
	}
	public static class RangeList {
		final Range ranges[];
		RangeList(Range ranges[]) {
			if(ranges == null) {
				throw new NullPointerException();
			}
			this.ranges = ranges;
		}
		public int size() {
			return ranges.length;
		}
		public Range getRange(int index) {
			return ranges[index];
		}
		@Override
		public String toString() {
			return Arrays.asList(ranges).toString();
		}
	}
	private static class RangeCache {
		static boolean PRELOAD_CACHE;
		static final int MAX_DIVISION_COUNT = IPv6Address.SEGMENT_COUNT;
		static final RangeList NO_ZEROS = new RangeList(new Range[0]);
		RangeCache nextRange[][];
		RangeCache parent;
		RangeList zeroRanges;
		Range range;
		RangeCache() {
			this(null, MAX_DIVISION_COUNT, null);
			zeroRanges = NO_ZEROS;
		}
		private RangeCache(RangeCache parent, int potentialZeroOffsets, Range range) {
			if(potentialZeroOffsets > 0) {
				nextRange = new RangeCache[potentialZeroOffsets][];
				for(int i = 0; i < potentialZeroOffsets; i++) {
					nextRange[i] = new RangeCache[potentialZeroOffsets - i];
				}
			}
			this.parent = parent;
			this.range = range;
		}
		private void get(Range ranges[], int rangesIndex) {
			ranges[--rangesIndex] = range;
			if(rangesIndex > 0) {
				parent.get(ranges, rangesIndex);
			}
		}
		public RangeList get() {
			RangeList result = zeroRanges;
			if(result == null) {
				int depth = 0;
				RangeCache up = parent;
				while(up != null) {
					depth++;
					up = up.parent;
				}
				Range ranges[] = new Range[depth];
				if(depth > 0) {
					ranges[--depth] = range;
					if(depth > 0) {
						parent.get(ranges, depth);
					}
				}
				zeroRanges = result = new RangeList(ranges);
			}
			return result;
		}
		void preloadCache(int lastIndex) {
			if(nextRange != null) {
				for(int i = 0; i < nextRange.length; i++) {
					RangeCache next[] = nextRange[i];
					for(int j = 0; j < next.length; j++) {
						Range newRange;
						if(lastIndex == -1) {
							newRange = new Range(i + lastIndex + 1, j + 1);
						} else {
							newRange = ZEROS_CACHE.nextRange[i + lastIndex + 1][j].range;
						}
						int nextPotentialZeroIndex = i + lastIndex + j + 3;
						int remainingPotentialZeroOffsets = RangeCache.MAX_DIVISION_COUNT - nextPotentialZeroIndex;
						RangeCache newRangeCache = new RangeCache(this, remainingPotentialZeroOffsets, newRange);
						newRangeCache.get();
						next[j] = newRangeCache;
					}
				}
				for(int i = 0; i < nextRange.length; i++) {
					RangeCache next[] = nextRange[i];
					for(int j = 0; j < next.length; j++) {
						RangeCache nextCache = next[j];
						Range nextRange = nextCache.range;
						nextCache.preloadCache(nextRange.index + nextRange.length);
					}
				}
			}
		}
		public RangeCache addRange(int currentIndex, int lastIndex, int currentCount) {
			int offset = currentIndex - lastIndex;
			int cacheOffset = offset - 1;
			int cacheCount = currentCount - 1;
			RangeCache next = nextRange[cacheOffset][cacheCount];
			if(next == null) {
				synchronized(this) {
					next = nextRange[cacheOffset][cacheCount];
					if(next == null) {
						int nextPotentialZeroIndex = lastIndex + 1;
						int remainingPotentialZeroOffsets = RangeCache.MAX_DIVISION_COUNT - nextPotentialZeroIndex;
						Range newRange;
						if(this == ZEROS_CACHE) {
							newRange = new Range(currentIndex, currentCount);
						} else {
							RangeCache rootNext = ZEROS_CACHE.nextRange[currentIndex][currentCount - 1];
							if(rootNext == null) {
								ZEROS_CACHE.nextRange[currentIndex][currentCount - 1] = new RangeCache(ZEROS_CACHE, RangeCache.MAX_DIVISION_COUNT, newRange = new Range(currentIndex, currentCount));
							} else {
								newRange = rootNext.range;
							}
						}
						nextRange[cacheOffset][cacheCount] = next = new RangeCache(this, remainingPotentialZeroOffsets, newRange);
					}
				}
			}
			return next;
		}
	}
}
package inet.ipaddr.format.large;
import java.math.BigInteger;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.InconsistentPrefixException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.IPAddressDivisionSeries;
public class IPAddressLargeDivisionGrouping extends AddressDivisionGroupingBase implements IPAddressDivisionSeries {
	private static final long serialVersionUID = 1L;
	private IPAddressNetwork<?, ?, ?, ?, ?> network;
	public IPAddressLargeDivisionGrouping(IPAddressLargeDivision divisions[], IPAddressNetwork<?, ?, ?, ?, ?> network) {
		super(divisions);
		this.network = network;
		int totalPrefixBits = 0;
		for(int i = 0; i < divisions.length; i++) {
			IPAddressLargeDivision division = divisions[i];
			Integer divPrefix = division.getDivisionPrefixLength();
			if(divPrefix != null) {
				cachedPrefixLength = cacheBits(totalPrefixBits + divPrefix);
				for(++i; i < divisions.length; i++) {
					division = divisions[i];
					divPrefix = division.getDivisionPrefixLength();
					if(divPrefix == null || divPrefix != 0) {
						throw new InconsistentPrefixException(divisions[i - 1], division, divPrefix);
					}
				}
				return;
			}
			totalPrefixBits += division.getBitCount();
		}
		cachedPrefixLength = NO_PREFIX_LENGTH;
	}
	@Override
	public IPAddressNetwork<?, ?, ?, ?, ?> getNetwork() {
		return network;
	}
	@Override
	public IPAddressLargeDivision getDivision(int index) {
		return (IPAddressLargeDivision) super.getDivision(index);
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		return containsPrefixBlock(this, prefixLength);
	}
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) throws PrefixLenException {
		return containsSinglePrefixBlock(this, prefixLength);
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		return getPrefixLengthForSingleBlock(this);
	}
	@Override
	public Integer getPrefixLength() {
		return getNetworkPrefixLength();
	}
	@Override
	public Integer getNetworkPrefixLength() {
		Integer ret = cachedPrefixLength;
		if(ret == null) {
			Integer result = calculatePrefix(this);
			if(result != null) {
				return cachedPrefixLength = result;
			}
			cachedPrefixLength = NO_PREFIX_LENGTH;
			return null;
		}
		if(ret.intValue() == NO_PREFIX_LENGTH.intValue()) {
			return null;
		}
		return ret;
	}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		byte bytes[] = new byte[(getBitCount() + 7) >> 3];
		int byteCount = bytes.length;
		int divCount = getDivisionCount();
		for(int k = divCount - 1, byteIndex = byteCount - 1, bitIndex = 8; k >= 0; k--) {
			IPAddressLargeDivision div = getDivision(k);
			BigInteger divValue = low ? div.getValue() : div.getUpperValue();
			int divBits = div.getBitCount();
			while(divBits > 0) {
				BigInteger bits = divValue.shiftLeft(8 - bitIndex);
				bytes[byteIndex] |= bits.byteValue();
				divValue = divValue.shiftRight(bitIndex);
				if(divBits < bitIndex) {
					bitIndex -= divBits;
					break;
				} else {
					divBits -= bitIndex;
					bitIndex = 8;
					byteIndex--;
				}
			}
		}
		return bytes;
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof IPAddressLargeDivisionGrouping && super.isSameGrouping(other);
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof IPAddressLargeDivisionGrouping) {
			IPAddressLargeDivisionGrouping other = (IPAddressLargeDivisionGrouping) o;
			return other.isSameGrouping(this);
		}
		return false;
	}
}
package inet.ipaddr.format.standard;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.format.AddressDivisionBase;
public class IPAddressBitsDivision extends IPAddressDivision {
	private static final long serialVersionUID = 4L;
	private final int bitCount, defaultRadix, maxDigitCount;
	private final long value, upperValue;
	private final long bitsMask;
	public IPAddressBitsDivision(long value, long upperValue, int bitCount, int defaultRadix) {
		this(value, upperValue, bitCount, defaultRadix, null, null);
	}
	public IPAddressBitsDivision(long value, long upperValue, int bitCount, int defaultRadix, Integer networkPrefixLength) {
		this(value, upperValue, bitCount, defaultRadix, null, networkPrefixLength);
	}
	public IPAddressBitsDivision(long value, long upperValue, int bitCount, int defaultRadix, IPAddressNetwork<?, ?, ?, ?, ?> network, Integer networkPrefixLength) {
		super(networkPrefixLength == null ? null : 
			((bitCount < networkPrefixLength) ? AddressDivisionGrouping.cacheBits(bitCount) : networkPrefixLength));
		this.bitCount = bitCount;
		if(value > upperValue) {
			long tmp = value;
			value = upperValue;
			upperValue = tmp;
		}
		if(value < 0) {
			throw new AddressValueException(value);
		}
		long fullMask = ~0L << bitCount; 
		long max = ~fullMask;
		if(upperValue > max) {
			throw new AddressValueException(upperValue);
		}
		networkPrefixLength = getDivisionPrefixLength();
		if(networkPrefixLength != null && networkPrefixLength < bitCount && network.getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			long mask = ~0L << (bitCount - networkPrefixLength);
			this.value = value & mask;
			this.upperValue = upperValue | ~mask;
		} else {
			this.value = value;
			this.upperValue = upperValue;
		}
		this.defaultRadix = defaultRadix;
		bitsMask = max;
		maxDigitCount = getMaxDigitCount(defaultRadix, bitCount, max); 
	}
	@Override
	public int getBitCount() {
		return bitCount;
	}
	@Override
	protected long getDivisionNetworkMask(int bits) {
		int bitShift = bitCount - bits;
		return bitsMask & (~0L << bitShift);
	}
	@Override
	protected long getDivisionHostMask(int bits) {
		int bitShift = bitCount - bits;
		return ~(~0L << bitShift);
	}
	@Override
	public long getDivisionValue() {
		return value;
	}
	@Override
	public long getUpperDivisionValue() {
		return upperValue;
	}
	@Override
	protected boolean isSameValues(AddressDivisionBase other) {
		if(other instanceof IPAddressBitsDivision) {
			return isSameValues((IPAddressBitsDivision) other);
		}
		return false;
	}
	protected boolean isSameValues(IPAddressBitsDivision otherSegment) {
		return  value == otherSegment.value && upperValue == otherSegment.upperValue;
	}
	@Override
	public boolean equals(Object other) {
		if(other == this) {
			return true;
		}
		if(other instanceof IPAddressBitsDivision) {
			IPAddressBitsDivision otherSegments = (IPAddressBitsDivision) other;
			return getBitCount() == otherSegments.getBitCount() && otherSegments.isSameValues(this);
		}
		return false;
	}
	@Override
	public int getDefaultTextualRadix() {
		return defaultRadix;
	}
	@Override
	public int getMaxDigitCount() {
		return maxDigitCount;
	}
}
package inet.ipaddr.format.standard;
import inet.ipaddr.Address;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.format.validate.ParsedAddressCreator;
public abstract class AddressCreator<T extends Address, R extends AddressSection, E extends AddressSection, S extends AddressSegment> extends ParsedAddressCreator<T, R, E, S>  implements AddressSegmentCreator<S> {
	private static final long serialVersionUID = 4L;
	public abstract AddressNetwork<S> getNetwork();
	protected abstract T createAddressInternal(S segments[]);
	protected abstract T createAddressInternal(S segments[], Integer prefix);
	protected abstract T createAddressInternal(S segments[], Integer prefix, boolean singleOnly);
	protected abstract R createSectionInternal(byte bytes[], int segmentCount, Integer prefix, boolean singleOnly);
	@Override
	protected abstract R createSectionInternal(S segments[]);
	@Override
	protected abstract R createPrefixedSectionInternal(S segments[], Integer prefix, boolean singleOnly);
	protected abstract R createSectionInternal(S segments[], int startIndex, boolean extended);
	public abstract T createAddress(R section);
}