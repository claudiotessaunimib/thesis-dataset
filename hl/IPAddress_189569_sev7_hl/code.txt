/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv4;
import java.math.BigInteger;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.function.Predicate;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressSection.WildcardOptions.WildcardOption;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.SizeMismatchException;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.standard.IPAddressDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.format.string.AddressStringDivision;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartConfiguredString;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.IPAddressPartStringSubCollection;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringCollection.IPv4AddressSectionStringCollection;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringCollection.IPv4StringBuilder;
import inet.ipaddr.ipv6.IPv6Address.IPv6AddressConverter;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringBuilderOptions;
/**
 * A section of an IPv4Address. 
 * 
 * It is a series of 0 to 4 individual IPv4 address segments.
 * 
 * @author sfoley
 *
 */
public class IPv4AddressSection extends IPAddressSection implements Iterable<IPv4AddressSection> {
	private static final long serialVersionUID = 4L;
	
	private static final long MAX_VALUES[] = new long[] {0, IPv4Address.MAX_VALUE_PER_SEGMENT, 0xffff, 0xffffff, 0xffffffffL};
	static class IPv4StringCache extends IPStringCache {
		// a set of pre-defined string types
		static final IPStringOptions fullParams;
		static final IPStringOptions normalizedWildcardParams;
		static final IPStringOptions sqlWildcardParams;
		static final IPStringOptions inetAtonOctalParams;
		static final IPStringOptions inetAtonHexParams;
		static final IPStringOptions canonicalParams;
		static final IPStringOptions reverseDNSParams;
		
		static final IPStringOptions segmentedBinaryParams;
		
		static {
			WildcardOptions allWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL);
			WildcardOptions allSQLWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL, new Wildcards(IPAddress.SEGMENT_SQL_WILDCARD_STR, IPAddress.SEGMENT_SQL_SINGLE_WILDCARD_STR));
			WildcardOptions wildcardsRangeOnlyNetworkOnly = new WildcardOptions(WildcardOptions.WildcardOption.NETWORK_ONLY, new Wildcards(IPAddress.RANGE_SEPARATOR_STR));
			fullParams = new IPv4StringOptions.Builder().setExpandedSegments(true).setWildcardOptions(wildcardsRangeOnlyNetworkOnly).toOptions();
			normalizedWildcardParams = new IPv4StringOptions.Builder().setWildcardOptions(allWildcards).toOptions();
			sqlWildcardParams = new IPv4StringOptions.Builder().setWildcardOptions(allSQLWildcards).toOptions();
			inetAtonOctalParams = new IPv4StringOptions.Builder().setRadix(IPv4Address.inet_aton_radix.OCTAL.getRadix()).setSegmentStrPrefix(IPv4Address.inet_aton_radix.OCTAL.getSegmentStrPrefix()).toOptions();
			inetAtonHexParams = new IPv4StringOptions.Builder().setRadix(IPv4Address.inet_aton_radix.HEX.getRadix()).setSegmentStrPrefix(IPv4Address.inet_aton_radix.HEX.getSegmentStrPrefix()).toOptions();
			canonicalParams = new IPv4StringOptions.Builder().toOptions();
			reverseDNSParams = new IPv4StringOptions.Builder().setWildcardOptions(allWildcards).setReverse(true).setAddressSuffix(IPv4Address.REVERSE_DNS_SUFFIX).toOptions();
			segmentedBinaryParams = new IPStringOptions.Builder(2).setSeparator(IPv4Address.SEGMENT_SEPARATOR).setSegmentStrPrefix(IPAddress.BINARY_STR_PREFIX).toOptions();
		}
		
		public String octalString;
		public String hexString;
	}
	
	static class IPv4AddressCache extends SectionCache<IPv4Address> {}
	
	transient IPv4StringCache stringCache;
	
	private transient SectionCache<IPv4AddressSection> sectionCache;
	private transient Integer cachedLowerVal, cachedUpperVal;
	/**
	 * Constructs a single segment section.
	 * 
	 * @param segment
	 */
	public IPv4AddressSection(IPv4AddressSegment segment) {
		this(new IPv4AddressSegment[] {segment}, false);
	}
	
	public IPv4AddressSection(IPv4AddressSegment segments[]) throws AddressValueException {
		this(segments, true);
	}
	
	/**
	 * @param segments an array containing the segments.  Segments that are entirely part of the host section need not be provided, although the array must be the correct length.
	 * @param networkPrefixLength
	 */
	public IPv4AddressSection(IPv4AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		this(segments, true, networkPrefixLength, false);
	}
	
	protected IPv4AddressSection(IPv4AddressSegment[] segments, boolean cloneSegments, Integer networkPrefixLength, boolean singleOnly) throws AddressValueException {
		this(segments, cloneSegments, networkPrefixLength == null /* only need to check segment prefixes if not applying a prefix */);
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0) {
				throw new PrefixLenException(networkPrefixLength);
			}
			int max = segments.length << 3;
			if(networkPrefixLength > max) {
				if(networkPrefixLength > IPv4Address.BIT_COUNT) {
					throw new PrefixLenException(networkPrefixLength);
				}
				networkPrefixLength = max;
			}
			if(segments.length > 0) {
				if(cachedPrefixLength != NO_PREFIX_LENGTH && cachedPrefixLength < networkPrefixLength) {
					networkPrefixLength = cachedPrefixLength;
				}
				IPv4AddressNetwork network = getNetwork();
				setPrefixedSegments(
						network,
						networkPrefixLength,
						getSegmentsInternal(),
						getBitsPerSegment(),
						getBytesPerSegment(),
						network.getAddressCreator(), 
						!singleOnly && isPrefixSubnetSegs(segments, networkPrefixLength, network, false) ? IPv4AddressSegment::toNetworkSegment : IPv4AddressSegment::toPrefixedSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} 
	}
	
	protected IPv4AddressSection(IPv4AddressSegment segments[], boolean cloneSegments) throws AddressValueException {
		this(segments, cloneSegments, true);
	}
	
	IPv4AddressSection(IPv4AddressSegment segments[], boolean cloneSegments, boolean normalizeSegments) throws AddressValueException {
		//super(segments, cloneSegments, normalizeSegments);
		super(segments, cloneSegments, true);
		if(normalizeSegments && isPrefixed()) {
			normalizePrefixBoundary(getNetworkPrefixLength(), getSegmentsInternal(), IPv4Address.BITS_PER_SEGMENT, IPv4Address.BYTES_PER_SEGMENT, IPv4AddressSegment::toPrefixNormalizedSeg);
		}
		if(segments.length > IPv4Address.SEGMENT_COUNT) {
			throw new AddressValueException(segments.length);
		}
	}
	
	public IPv4AddressSection(SegmentValueProvider valueProvider, int segmentCount, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, segmentCount, networkPrefixLength);
	}
	
	public IPv4AddressSection(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, int segmentCount, Integer networkPrefixLength) throws AddressValueException {
		super(new IPv4AddressSegment[segmentCount], false, false);
		IPv4AddressSegment segs[] = getSegmentsInternal();
		IPv4AddressNetwork network = getNetwork();
		createSegments(
				segs,
				lowerValueProvider,
				upperValueProvider,
				getBytesPerSegment(),
				getBitsPerSegment(),
				network,
				networkPrefixLength);
		if(networkPrefixLength != null) {
			if(networkPrefixLength > IPv4Address.BIT_COUNT) {
				throw new PrefixLenException(networkPrefixLength);
			}
			if(network.getPrefixConfiguration().zeroHostsAreSubnets() && isPrefixSubnetSegs(segs, networkPrefixLength, network, false)) {
				setPrefixedSegments(
						network,
						networkPrefixLength,
						getSegmentsInternal(),
						getBitsPerSegment(),
						getBytesPerSegment(),
						network.getAddressCreator(),
						IPv4AddressSegment::toNetworkSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
		}
	}
	
	public IPv4AddressSection(SegmentValueProvider valueProvider, int segmentCount) throws AddressValueException {
		this(valueProvider, valueProvider, segmentCount);
	}
	
	public IPv4AddressSection(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, int segmentCount) {
		this(lowerValueProvider, upperValueProvider, segmentCount, null);
	}
	protected IPv4AddressSection(byte bytes[], int segmentCount, Integer networkPrefixLength, boolean cloneBytes, boolean singleOnly) throws AddressValueException {
		this(bytes, 0, bytes.length, segmentCount, networkPrefixLength, cloneBytes, singleOnly);
	}
	protected IPv4AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer networkPrefixLength, boolean cloneBytes, boolean singleOnly) throws AddressValueException {
		super(new IPv4AddressSegment[segmentCount >= 0 ? segmentCount : Math.max(0, byteEndIndex - byteStartIndex)], false, false);
		IPv4AddressSegment segs[] = getSegmentsInternal();
		IPv4AddressNetwork network = getNetwork();
		toSegments(
			segs,
			bytes,
			byteStartIndex,
			byteEndIndex,
			getBytesPerSegment(),
			getBitsPerSegment(),
			network,
			networkPrefixLength);
		boolean byteLengthIsExact = bytes.length == segs.length;
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0) {
				throw new PrefixLenException(networkPrefixLength);
			}
			int max = segs.length << 3;
			if(networkPrefixLength > max) {
				if(networkPrefixLength > IPv4Address.BIT_COUNT) {
					throw new PrefixLenException(networkPrefixLength);
				}
				networkPrefixLength = max;
			}
			if(segs.length > 0) {
				PrefixConfiguration prefConf = network.getPrefixConfiguration();
				if(prefConf.zeroHostsAreSubnets()) {
					if(isPrefixSubnetSegs(segs, networkPrefixLength, network, false) && !singleOnly) {
						setPrefixedSegments(
								network,
								networkPrefixLength,
								segs,
								getBitsPerSegment(),
								getBytesPerSegment(),
								network.getAddressCreator(),
								IPv4AddressSegment::toNetworkSegment);
					} else if(byteLengthIsExact && networkPrefixLength >= getBitCount()) {
						setBytes(cloneBytes ? bytes.clone() : bytes);
					}
				} else if(byteLengthIsExact && (prefConf.prefixedSubnetsAreExplicit() || networkPrefixLength >= getBitCount())) {
					setBytes(cloneBytes ? bytes.clone() : bytes);
				}
			} else if(byteLengthIsExact) {
				setBytes(bytes); // no need to clone if zero-length
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
			if(byteLengthIsExact) {
				setBytes(cloneBytes ? bytes.clone() : bytes);
			}
		}
	}
	
	protected IPv4AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer prefix) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, segmentCount, prefix, true, false);
	}
	
	public IPv4AddressSection(byte bytes[], Integer prefix) throws AddressValueException {
		this(bytes, bytes.length, prefix, true, false);
	}
	
	public IPv4AddressSection(byte bytes[]) throws AddressValueException {
		this(bytes, bytes.length, null, true, false);
	}
	
	public IPv4AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, -1, prefix, true, false);
	}
	
	public IPv4AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, -1, null, true, false);
	}
	
	public IPv4AddressSection(int value, Integer networkPrefixLength) throws AddressValueException {
		super(new IPv4AddressSegment[IPv4Address.SEGMENT_COUNT], false, false);
		IPv4AddressSegment segs[] = getSegmentsInternal();
		IPv4AddressNetwork network = getNetwork();
		createSegments(
				segs,
				0,
				value,
				getBitsPerSegment(),
				network,
				networkPrefixLength);
		if(networkPrefixLength != null) {
			if(networkPrefixLength > IPv4Address.BIT_COUNT) {
				throw new PrefixLenException(networkPrefixLength);
			}
			if(network.getPrefixConfiguration().zeroHostsAreSubnets() && isPrefixSubnetSegs(segs, networkPrefixLength, network, false)) {
				setPrefixedSegments(
						network,
						networkPrefixLength,
						getSegmentsInternal(),
						getBitsPerSegment(),
						getBytesPerSegment(),
						network.getAddressCreator(),
						IPv4AddressSegment::toNetworkSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
		}
	}
	
	public IPv4AddressSection(int value) {
		this(value, null);
	}
	
	@Override
	public IPv4AddressSegment[] getSegments() {
		return (IPv4AddressSegment[]) getDivisionsInternal().clone();
	}
	@Override
	public IPv4AddressSection getSection() {
		return this;
	}
	
	@Override
	public IPv4AddressSection getSection(int index) {
		return getSection(index, getSegmentCount());
	}
	@Override
	public IPv4AddressSection getSection(int index, int endIndex) {
		return getSection(index, endIndex, this, getAddressCreator());
	}
	
	@Override
	protected void setInetAddress(InetAddress addr) {
		super.setInetAddress(addr);
	}
	
	void cache(IPv4Address thisAddr, IPv4Address lower, IPv4Address upper) {
		if((lower != null || upper != null) && getSingleLowestOrHighestSection(this) == null) {
			getSection().cache(lower != null ? lower.getSection() : null, upper != null ? upper.getSection() : null);
			IPv4AddressCache cache = thisAddr.addressCache;
			if(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null)) {
				synchronized(this) {
					cache = thisAddr.addressCache;
					boolean create = (cache == null);
					if(create) {
						thisAddr.addressCache = cache = new IPv4AddressCache();
						cache.lower = lower;
						cache.upper = upper;
					} else {
						if(cache.lower == null) {
							cache.lower = lower;
						}
						if(cache.upper == null) {
							cache.upper = upper;
						}
					}
				}
			}
		}
	}
	
	void cache(IPv4AddressSection lower, IPv4AddressSection upper) {
		SectionCache<IPv4AddressSection> cache = sectionCache;
		if((lower != null || upper != null) && 
				(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null))) {
			synchronized(this) {
				cache = sectionCache;
				boolean create = (cache == null);
				if(create) {
					sectionCache = cache = new SectionCache<IPv4AddressSection>();
					cache.lower = lower;
					cache.upper = upper;
				} else {
					if(cache.lower == null) {
						cache.lower = lower;
					}
					if(cache.upper == null) {
						cache.upper = upper;
					}
				}
			}
		}
	}
	private IPv4AddressSection getLowestOrHighestSection(boolean lowest, boolean excludeZeroHost) {
		IPv4AddressSection result = getSingleLowestOrHighestSection(this);
		if(result == null) {
			SectionCache<IPv4AddressSection> cache = sectionCache;
			if(cache == null || (lowest ? (excludeZeroHost ? ((result = cache.lowerNonZeroHost) == null && !cache.lowerNonZeroHostIsNull) : (result = cache.lower) == null) : (result = cache.upper) == null)) {
				synchronized(this) {
					cache = sectionCache;
					boolean create = (cache == null);
					if(create) {
						sectionCache = cache = new SectionCache<IPv4AddressSection>();
					} else {
						if(lowest) {
							if(excludeZeroHost) {
								create = (result = cache.lowerNonZeroHost) == null && !cache.lowerNonZeroHostIsNull;
							} else {
								create = (result = cache.lower) == null;
							}
						} else {
							create = (result = cache.upper) == null;
						}
					}
					if(create) {
						result = createLowestOrHighestSection(
								this,
								getAddressCreator(), 
								this::segmentsNonZeroHostIterator,
								i -> lowest ? getSegment(i).getLower() : getSegment(i).getUpper(),
								lowest,
								excludeZeroHost);
						if(result == null) {
							cache.lowerNonZeroHostIsNull = true;
						} else if(lowest) {
							if(excludeZeroHost) {
								 cache.lowerNonZeroHost = result;
							} else {
								cache.lower = result;
							}
						} else {
							cache.upper = result;
						}
					}
				}
			}
		} else if(excludeZeroHost && includesZeroHost()) {
			return null;
		}
		return result;
	}
	
	IPv4Address getLowestOrHighest(IPv4Address addr, boolean lowest, boolean excludeZeroHost) {
		IPv4AddressSection sectionResult = getLowestOrHighestSection(lowest, excludeZeroHost);
		if(sectionResult == this) {
			return addr;
		} else if(sectionResult == null) {
			return null;
		}
		IPv4Address result = null;
		IPv4AddressCache cache = addr.addressCache;
		if(cache == null || 
				(result = lowest ? (excludeZeroHost ? cache.lowerNonZeroHost : cache.lower) : cache.upper) == null) {
			synchronized(this) {
				cache = addr.addressCache;
				boolean create = (cache == null);
				if(create) {
					cache = addr.addressCache = new IPv4AddressCache();
				} else {
					if(lowest) {
						if(excludeZeroHost) {
							create = (result = cache.lowerNonZeroHost) == null;
						} else {
							create = (result = cache.lower) == null;
						}
					} else {
						create = (result = cache.upper) == null;
					}
				}
				if(create) {
					result = getAddressCreator().createAddress(sectionResult);
					if(lowest) {
						if(excludeZeroHost) {
							 cache.lowerNonZeroHost = result;
						} else {
							cache.lower = result;
						}
					} else {
						cache.upper = result;
					}
				}
			}
		}
		return result;
	}
	
	@Override
	public IPv4AddressSection getLowerNonZeroHost() {
		return getLowestOrHighestSection(true, true);
	}
	
	@Override
	public IPv4AddressSection getLower() {
		return getLowestOrHighestSection(true, false);
	}
	
	@Override
	public IPv4AddressSection getUpper() {
		return getLowestOrHighestSection(false, false);
	}
	
	public int intValue() {
		return getIntValue(true);
	}
	
	public int upperIntValue() {
		return getIntValue(false);
	}
	
	public long longValue() {
		return intValue() & 0xffffffffL;
	}
	
	public long upperLongValue() {
		return upperIntValue() & 0xffffffffL;
	}
	
	private int calcValue(boolean lower) {
		int segCount = getSegmentCount();
		int result = 0;
		if(segCount != 0) {
			IPv4AddressSegment first = getSegment(0);
			result = lower ? first.getSegmentValue() : first.getUpperSegmentValue();
			if(segCount != 1) {
				int bitsPerSegment = getBitsPerSegment();
				for(int i = 1; i < segCount; i++) {
					IPv4AddressSegment seg = getSegment(i);
					result = (result << bitsPerSegment) | 
							(lower ? seg.getSegmentValue() : seg.getUpperSegmentValue());
				}
			}
		}
		return result;
	}
	
	private int getIntValue(boolean lower) {
		int result = 0;
		if(lower || !isMultiple()) {
			Integer cachedInt = this.cachedLowerVal;
			if(cachedInt == null) {
				result = calcValue(true);
				this.cachedLowerVal = result;
			} else {
				result = cachedInt;
			}
		} else {
			Integer cachedInt = this.cachedUpperVal;
			if(cachedInt == null) {
				result = calcValue(false);
				this.cachedUpperVal = result;
			} else {
				result = cachedInt;
			}
		}
		return result;
	}
	
	@Override
	public IPv4AddressSection reverseBits(boolean perByte) {
		return reverseBits(perByte, this, getAddressCreator(), i -> getSegment(i).reverseBits(perByte), true);
	}
	
	@Override
	public IPv4AddressSection reverseBytes() {
		return reverseSegments();
	}
	
	@Override
	public IPv4AddressSection reverseBytesPerSegment() {
		if(!isPrefixed()) {
			return this;
		}
		return withoutPrefixLength();
	}
	
	@Override
	public IPv4AddressSection reverseSegments() {
		if(getSegmentCount() <= 1) {
			if(isPrefixed()) {
				return withoutPrefixLength();
			}
			return this;
		}
		return reverseSegments(this, getAddressCreator(), (i) -> getSegment(i).withoutPrefixLength(), true);
	}
	
	@Override
	protected IPv4AddressSegment[] getSegmentsInternal() {
		return (IPv4AddressSegment[])  super.getDivisionsInternal();
	}
	@Override
	public Iterable<IPv4AddressSection> getIterable() {
		return this;
	}
	private Iterator<IPv4AddressSection> iterator(Predicate<IPv4AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = !isMultiple() && (!isAllSubnets || !isPrefixed());
		IPv4AddressSection original;
		if(!useOriginal || (excludeFunc != null && excludeFunc.test(getSegmentsInternal()))) {
			original = null;
		} else {
			original = this;
		}
		return iterator(
				useOriginal,
				original,
				getAddressCreator(),
				useOriginal ? null : segmentsIterator(excludeFunc),
				isAllSubnets ? null : getPrefixLength());
	}
	AddressComponentSpliterator<IPv4AddressSection> spliterator(boolean excludeZeroHosts) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		IPv4AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv4AddressSection forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = this;
		}
		//Function<IPv4AddressSection, Iterator<IPv4AddressSection>> iteratorProvider;
		IteratorProvider<IPv4AddressSection, IPv4AddressSection> iteratorProvider;
		ToLongFunction<IPv4AddressSection> longSizer;
		if(excludeZeroHosts && includesZeroHost()) {
			longSizer = section -> longCount(section, segmentCount) - section.longZeroHostCount(prefixLength, segmentCount);
			iteratorProvider = (isLowest, isHighest, section) -> section.iterator(segs -> isZeroHost(segs, prefixLength));
		} else {
			longSizer = section -> longCount(section, segmentCount);
			iteratorProvider = (isLowest, isHighest, section) -> section.iterator();
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				iteratorProvider,
				null,
				null,
				longSizer);
	}
	Iterator<IPv4Address> iterator(IPv4Address original,
			AddressCreator<IPv4Address, ?, ?, IPv4AddressSegment> creator,
			Predicate<IPv4AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = !isMultiple() && (!isAllSubnets || !isPrefixed());
		if(useOriginal && excludeFunc != null && excludeFunc.test(original.getSection().getSegmentsInternal())) {
			original = null;
		}
		return iterator(
				useOriginal,
				original, 
				creator, // using a lambda for this one results in a big performance hit
				useOriginal ? null : 
					segmentsIterator(
							getSegmentCount(),
							creator,
							isMultiple() ? null : () -> getLower().getSegmentsInternal(),
							index -> getSegment(index).iterator(!isAllSubnets),
							excludeFunc),
				isAllSubnets ? null : getPrefixLength());
	}
	AddressComponentSpliterator<IPv4Address> spliterator(
			IPv4Address original,
			IPv4AddressCreator creator,
			boolean excludeZeroHosts) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv4Address forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = original.withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = original;
		}
		IteratorProvider<IPv4Address, IPv4Address> iteratorProvider;
		ToLongFunction<IPv4Address> longSizer;
		if(excludeZeroHosts && includesZeroHost()) {
			longSizer = addr -> longCount(addr.getSection(), segmentCount) - addr.getSection().longZeroHostCount(prefixLength, segmentCount);
			iteratorProvider = (isLowest, isHighest, addr) -> addr.getSection().iterator(addr, addr.getAddressCreator(), s -> isZeroHost(s, prefixLength));
		} else {
			longSizer = addr -> longCount(addr.getSection(), segmentCount);
			iteratorProvider = (isLowest, isHighest, addr) -> addr.iterator();
			//iteratorProvider = IPv4Address::iterator;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				iteratorProvider,
				null,
				null,
				longSizer);
	}
	@Override
	public Iterator<IPv4AddressSection> nonZeroHostIterator() {
		return iterator(excludeNonZeroHosts());
	}
	
	@Override
	public Iterator<IPv4AddressSection> iterator() {
		return iterator(null);
	}
	@Override
	public AddressComponentSpliterator<IPv4AddressSection> spliterator() {
		return spliterator(false);
	}
	@Override
	public Stream<IPv4AddressSection> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv4AddressSection> prefixIterator() {
		return prefixIterator(false);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4AddressSection> prefixSpliterator() {
		return prefixSpliterator(false);
	}
	@Override
	public Stream<IPv4AddressSection> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv4AddressSection> prefixBlockIterator() {
		return prefixIterator(true);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4AddressSection> prefixBlockSpliterator() {
		return prefixSpliterator(true);
	}
	@Override
	public Stream<IPv4AddressSection> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	private Iterator<IPv4AddressSection> prefixIterator(boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return iterator();
		}
		IPv4AddressCreator creator = getAddressCreator();
		boolean useOriginal = isBlockIterator ? isSinglePrefixBlock() : longPrefixCount(prefLength) == 1;
		int networkSegIndex = getNetworkSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				this,
				creator,
				useOriginal ?
						null :
						segmentsIterator(
								segCount,
							creator,
							null, //when no prefix we defer to other iterator, when there is one we use the whole original section in the encompassing iterator and not just the original segments
							index -> getSegment(index).iterator(),
							null, 
							networkSegIndex, 
							hostSegIndex, 
							isBlockIterator ? index -> getSegment(index).prefixBlockIterator() : index -> getSegment(index).prefixIterator()),
				prefLength);
	}
	private AddressComponentSpliterator<IPv4AddressSection> prefixSpliterator(boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return spliterator(false);
		}
		return prefixSpliterator(isBlockIterator, prefLength);
	}
	
	private AddressComponentSpliterator<IPv4AddressSection> prefixSpliterator(boolean isBlockIterator, int prefixLength) {
		if(prefixLength > getBitCount() || prefixLength < 0) {
			throw new PrefixLenException(this, prefixLength);
		}
		Integer prefLength = cacheBits(prefixLength);
		IPv4AddressCreator creator = getAddressCreator();
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		return createSeriesSpliterator(
				setPrefixLength(prefixLength, false),
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, prefLength),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefLength),
				isBlockIterator ? 
						(isLowest, isHighest, section) -> section.prefixBlockIterator() : 
							(!isSequential() ?  (isLowest, isHighest, section) -> section.prefixIterator() : 
							((isLowest, isHighest, section) -> (isLowest || isHighest) ? section.prefixIterator() : section.prefixBlockIterator())), 
				null,
				null,
				section -> longPrefixCount(section, prefixLength));
	}
	@Override
	public Iterator<IPv4AddressSection> blockIterator(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return iterator();
		}
		IPv4AddressCreator creator = getAddressCreator();
		boolean useOriginal = !isMultiple(segmentCount);
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		return iterator(
				useOriginal,
				this,
				creator,
				useOriginal ?
						null :
						segmentsIterator(
							getSegmentCount(),
							creator,
							null, //when no prefix we defer to other iterator, when there is one we use the whole original section in the encompassing iterator and not just the original segments
							index -> getSegment(index).iterator(!isAllSubnets),
							null, 
							segmentCount - 1, 
							segmentCount, 
							index -> getSegment(index).identityIterator()),
				isAllSubnets ? null : getPrefixLength());
	}
	@Override
	public AddressComponentSpliterator<IPv4AddressSection> blockSpliterator(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return spliterator();
		}
		IPv4AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer prefLength = isAllSubnets ? null : getPrefixLength();
		IPv4AddressSection forIteration;
		Integer iterationsPrefix;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefLength;
			forIteration = this;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, section) -> section.blockIterator(segmentCount), 
				null,
				null,
				section -> longCount(section, segmentCount));
	}
	@Override
	public Stream<IPv4AddressSection> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AddressSection> sequentialBlockIterator() {
		return (Iterator<IPv4AddressSection>) super.sequentialBlockIterator();
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv4AddressSection> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv4AddressSection>) super.sequentialBlockSpliterator();
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv4AddressSection> sequentialBlockStream() {
		return (Stream<IPv4AddressSection>) super.sequentialBlockStream();
	}
	private Iterator<IPv4AddressSegment[]> segmentsIterator(Predicate<IPv4AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		return segmentsIterator(
				getSegmentCount(),
				getSegmentCreator(),
				isMultiple() ? null : () -> getLower().getSegments(),
				index -> getSegment(index).iterator(!isAllSubnets),
				excludeFunc);
	}
	private Predicate<IPv4AddressSegment[]> excludeNonZeroHosts() {
		if(isPrefixed()) {
			int prefLength = getNetworkPrefixLength();
			return segments -> isZeroHost(segments, prefLength);
		}
		return null;
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsNonZeroHostIterator() {
		return segmentsIterator(excludeNonZeroHosts());
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsIterator() {
		return segmentsIterator(null);
	}
	@Override
	public AddressComponentRangeSpliterator<IPv4AddressSection, IPv4AddressSegment[]> segmentsSpliterator() {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		IPv4AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv4AddressSection forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = this;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createItemSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, section) -> section.segmentsIterator(),
				null,
				null,
				section -> longCount(section, segmentCount));
	}
	@Override
	public Stream<IPv4AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	AddressComponentRangeSpliterator<IPv4Address, IPv4AddressSegment[]> segmentsSpliterator(IPv4Address address, IPv4AddressCreator creator) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv4Address forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = address.withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = address;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createItemSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, addr) -> addr.segmentsIterator(),
				null,
				null,
				addr -> longCount(addr.getSection(), segmentCount));
	}
	Iterator<IPv4Address> prefixIterator(
			IPv4Address original,
			AddressCreator<IPv4Address, ?, ?, IPv4AddressSegment> creator,
			boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return iterator(original, creator, null);
		}
		return prefixIterator(original, creator, isBlockIterator, prefLength);
	}
	
	AddressComponentSpliterator<IPv4Address> prefixSpliterator(
			IPv4Address original,
			IPv4AddressCreator creator,
			boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return spliterator(original, creator, false);
		}
		return prefixSpliterator(original, creator, isBlockIterator, prefLength);
	}
	
	AddressComponentSpliterator<IPv4Address> prefixSpliterator(
			IPv4Address original,
			IPv4AddressCreator creator,
			boolean isBlockIterator,
			int prefixLength) {
		if(prefixLength > getBitCount() || prefixLength < 0) {
			throw new PrefixLenException(original, prefixLength);
		}
		Integer prefLength = cacheBits(prefixLength);
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		return createSeriesSpliterator(
				original.setPrefixLength(prefixLength, false),
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, prefLength),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefLength),
				isBlockIterator ? 
						(isLowest, isHighest, addr) -> addr.prefixBlockIterator() : 
							(!isSequential() ? (isLowest, isHighest, addr) -> addr.prefixIterator() : 
							((isLowest, isHighest, addr) -> (isLowest || isHighest) ? addr.prefixIterator() : addr.prefixBlockIterator())),
				null,
				null,
				addr -> longPrefixCount(addr.getSection(), prefixLength));
	}
	Iterator<IPv4Address> prefixIterator(IPv4Address original, AddressCreator<IPv4Address, ?, ?, IPv4AddressSegment> creator, boolean isBlockIterator, int prefLength) {
		if(prefLength > getBitCount() || prefLength < 0) {
			throw new PrefixLenException(original, prefLength);
		}
		boolean useOriginal = isBlockIterator ? containsSinglePrefixBlock(prefLength) : longPrefixCount(prefLength) == 1;
		if(useOriginal) {
			original = original.setPrefixLength(prefLength, false);
		}
		int networkSegIndex = getNetworkSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				original, 
				creator, // using a lambda for this one resulted in a big performance hit
				useOriginal ? null :
					segmentsIterator(
							segCount,
							creator,
							null, // when no prefix we defer to other iterator, when there is one we use the whole original address in the encompassing iterator and not just the original segments
							index -> getSegment(index).iterator(),
							null,
							networkSegIndex, 
							hostSegIndex, 
							isBlockIterator ? index -> getSegment(index).prefixBlockIterator() : index -> getSegment(index).prefixIterator()),
				cacheBits(prefLength));
	}
	
	Iterator<IPv4Address> blockIterator(IPv4Address original, AddressCreator<IPv4Address, ?, ?, IPv4AddressSegment> creator, int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount > getSegmentCount()) {
			return iterator(original, creator, null);
		}
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = !isMultiple(segmentCount);
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				original, 
				creator,// using a lambda for this one results in a big performance hit
				useOriginal ? null :
					segmentsIterator(
							segCount,
							creator,
							null, // when no prefix we defer to other iterator, when there is one we use the whole original address in the encompassing iterator and not just the original segments
							index -> getSegment(index).iterator(!isAllSubnets),
							null,
							networkSegIndex,
							hostSegIndex,
							index -> getSegment(index).identityIterator()),
				isAllSubnets ? null : getPrefixLength());
	}
	AddressComponentSpliterator<IPv4Address> blockSpliterator(IPv4Address original, IPv4AddressCreator creator, int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return spliterator(original, creator, false);
		}
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer prefLength = isAllSubnets ? null : getPrefixLength();
		Integer iterationsPrefix;
		IPv4Address forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = original.withoutPrefixLength();
		} else {
			iterationsPrefix = prefLength;
			forIteration = original;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, addr) -> addr.blockIterator(segmentCount), 
				null,
				null,
				addr -> longCount(addr.getSection(), segmentCount));
	}
	protected boolean isZeroHost(IPv4AddressSegment segments[], int prefixLength) {
		return super.isZeroHost(segments, prefixLength);
	}
	private static long getMaxValue(int segmentCount) {
		return MAX_VALUES[segmentCount];
	}
	
	@Override
	public IPv4AddressSection incrementBoundary(long increment) {
		if(increment <= 0) {
			if(increment == 0) {
				return this;
			}
			return getLower().increment(increment);
		}
		return getUpper().increment(increment);
	}
	@Override
	public IPv4AddressSection increment(long increment) {
		if(increment == 0 && !isMultiple()) {
			return this;
		}
		checkOverflow(increment, this::longValue, this::upperLongValue, () -> getCount().longValue(), this::isSequential, () -> getMaxValue(getSegmentCount()));
		return increment(
				this,
				increment,
				getAddressCreator(),
				() -> getCount().longValue(),
				this::longValue,
				this::upperLongValue,
				this::getLower,
				this::getUpper,
				getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength());
	}
	public long getIPv4Count(boolean excludeZeroHosts) {
		return excludeZeroHosts && includesZeroHost() ? 
				longZeroHostCount(getNetworkPrefixLength(), getSegmentCount()) : 
					longCount(getSegmentCount());
	}
	
	@Override
	protected BigInteger getCountImpl(int segCount) {
		if(!isMultiple()) {
			return BigInteger.ONE;
		}
		return BigInteger.valueOf(longCount(this, segCount));
	}
	
	@Override
	protected BigInteger getZeroHostCountImpl(int prefixLength, int segCount) {
		if(includesZeroHost(prefixLength)) {
			if(isMultiple()) {
				return BigInteger.valueOf(longZeroHostCount(prefixLength, segCount));
				
			} else {
				return BigInteger.ONE;
			}
		}
		return BigInteger.ZERO;
	}
	//This was added so count available as a long and not as BigInteger
	public long getIPv4PrefixCount(int prefixLength) {
		checkSubnet(this, prefixLength);
		return longPrefixCount(prefixLength);
	}
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		return BigInteger.valueOf(getIPv4PrefixCount(prefixLength));
	}
		
	public long getIPv4PrefixCount() {
		Integer prefixLength = getPrefixLength();
		if(prefixLength == null || prefixLength >= getBitCount()) {
			return getIPv4Count(false);
		}
		return getIPv4PrefixCount(prefixLength);
	}
	@Override
	protected BigInteger getPrefixCountImpl() {
		return BigInteger.valueOf(getIPv4PrefixCount());
	}
	
	private IPv4AddressCreator getSegmentCreator() {
		return getIPv4SegmentCreator();
	}
	private IPv4AddressCreator getAddressCreator() {
		return getIPv4SegmentCreator();
	}
	
	private IPv4AddressCreator getIPv4SegmentCreator() {
		return getNetwork().getAddressCreator();
	}
	
	@Override
	public IPv4AddressSegment getDivision(int index) {
		return (IPv4AddressSegment) super.getDivision(index);
	}
	
	@Override
	public IPv4AddressSegment getSegment(int index) {
		return (IPv4AddressSegment) super.getSegment(index);
	}
	public void getSegments(Collection<? super IPv4AddressSegment> segs) {
		getSegments(0, getSegmentCount(), segs);
	}
	public void getSegments(int start, int end, Collection<? super IPv4AddressSegment> segs) {
		for(int i = start; i < end; i++) {
			segs.add(getSegment(i));
		}
	}
	@Override
	public int getBitsPerSegment() {
		return IPv4Address.BITS_PER_SEGMENT;
	}
	
	@Override
	public int getBytesPerSegment() {
		return IPv4Address.BYTES_PER_SEGMENT;
	}
	
	@Override
	public int getBitCount() {
		return getSegmentCount() << 3;
	}
	
	@Override
	public int getByteCount() {
		return getSegmentCount();
	}
	
	@Override
	protected byte[] getBytesImpl(boolean low) {
		int segmentCount = getSegmentCount();
		byte bytes[] = new byte[segmentCount];
		for(int i = 0; i < segmentCount; i++) {
			IPv4AddressSegment seg = getSegment(i);
			int val = low ? seg.getSegmentValue() : seg.getUpperSegmentValue();
			bytes[i] = (byte) val;
		}
		return bytes;
	}
	@Override
	public boolean isIPv4() {
		return true;
	}
	
	@Override
	public IPVersion getIPVersion() {
		return IPVersion.IPV4;
	}
	
	@Override
	public boolean matchesWithMask(IPAddressSection other, IPAddressSection mask) {
		return other instanceof IPv4AddressSection && mask instanceof IPv4AddressSection && super.matchesWithMask(other, mask);
	}
	
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof IPv4AddressSection && super.isSameGrouping(other);
	}
	
	@Override
	public boolean equals(Object o) {
		return o == this || (o instanceof IPv4AddressSection && ((IPv4AddressSection) o).isSameGrouping(this));
	}
	@Override
	public boolean overlaps(AddressSection other) {
		return other instanceof IPv4AddressSection && overlaps(this, other);
	}
	@Override
	public boolean contains(AddressSection other) {
		return other instanceof IPv4AddressSection && super.contains(other);
	}
	
	/**
	 * Returns whether this address contains the non-zero host addresses in other.
	 * @param other
	 * @return
	 */
	@Override
	protected boolean containsNonZeroHostsImpl(IPAddressSection other, int otherPrefixLength) {
		if(other instanceof IPv4AddressSection) {
			IPv4AddressSection remaining[] = ((IPv4AddressSection) other).subtract(this);
			if(remaining != null) {
				for(int i = 0; i < remaining.length; i++) {
					if(!remaining[i].isZeroHost(otherPrefixLength)) {
						return false;
					}
				}
			}
			return true;
		}
		return false;
	}
	static BigInteger enumerate(IPv4AddressSection addr, AddressSection other) {
		Long result = enumerateSmall(addr, other);
		if(result != null) {
			return BigInteger.valueOf(result);
		}
		return null;
	}
	
	/**
	 * Indicates where an address section sits relative to the ordering of individual address sections within this section.
	 * <p>
	 * Equivalent to {@link #enumerate(AddressSection)} but returns a Long rather than a BigInteger.
	 */
	public Long enumerateIPv4(IPv4AddressSection other){
		checkSegmentCount(other);
		return enumerateSmall(this, other);
	}
	
	// called by addresses
	static Long enumerateIPv4(IPv4AddressSection addr, AddressSection other) {
		 return enumerateSmall(addr, other);
	}
	
	@Override
	public BigInteger enumerate(AddressSection other) {
		if(other instanceof IPv4AddressSection) {
			checkSegmentCount(other);
			Long result = enumerateSmall(this, other);
			if(result != null) {
				return BigInteger.valueOf(result);
			}
		}
		return null;
	}
	@Override
	public boolean prefixEquals(AddressSection other) {
		return other == this || (other instanceof IPv4AddressSection && prefixEquals(this, other, 0));
	}
	
	@Override
	public boolean prefixContains(IPAddressSection other) {
		return other == this || (other instanceof IPv4AddressSection && prefixContains(this, other, 0));
	}
	public IPv4AddressSection append(IPv4AddressSection other) {
		int count = getSegmentCount();
		return replace(count, count, other, 0, other.getSegmentCount());
	}
	public IPv4AddressSection insert(int index, IPv4AddressSection other) {
		return replace(index, index, other, 0, other.getSegmentCount());
	}
	/**
	 * Replace the segments of this section starting at the given index with the given replacement segments
	 * 
	 * @param index
	 * @param other
	 * @return
	 */
	public IPv4AddressSection replace(int index, IPv4AddressSection other) {
		return replace(index, index + other.getSegmentCount(), other, 0, other.getSegmentCount());
	}
	public IPv4AddressSection appendToNetwork(IPv4AddressSection other) {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null) {
			return append(other);
		}
		IPv4AddressSection thizz = this;
		int bitsPerSegment = getBitsPerSegment();
		int adjustment = prefixLength % bitsPerSegment;
		if(adjustment != 0) {
			prefixLength += bitsPerSegment - adjustment;
			thizz = setPrefixLength(prefixLength, false);
		}
		int index = prefixLength >>> 3;
		if(other.isPrefixed() && other.getPrefixLength() == 0) {
			//replacement is all host, cannot make it part of network
			return insert(index, other);
		}
		return thizz.replace(index, index, other, 0, other.getSegmentCount(), true);
	}
	
	/**
	 * Replaces segments starting from startIndex and ending before endIndex with the segments starting at replacementStartIndex and 
	 * ending before replacementEndIndex from the replacement section
	 * @param startIndex
	 * @param endIndex
	 * @param replacement
	 * @param replacementStartIndex
	 * @param replacementEndIndex
	 * @throws IndexOutOfBoundsException
	 * @throws IncompatibleAddressException if the resulting section would exceed the maximum segment count for this address type and version
	 * @return
	 */
	public IPv4AddressSection replace(int startIndex, int endIndex, IPv4AddressSection replacement, int replacementStartIndex, int replacementEndIndex) {
		return replace(startIndex, endIndex, replacement, replacementStartIndex, replacementEndIndex, false);
	}
	
	private IPv4AddressSection replace(int startIndex, int endIndex, IPv4AddressSection replacement, int replacementStartIndex, int replacementEndIndex, boolean appendNetwork) {
		int segmentCount = getSegmentCount();
		int replacedCount = endIndex - startIndex;
		int replacementCount = replacementEndIndex - replacementStartIndex;
		if(replacedCount < 0 || replacementCount < 0 || startIndex < 0 || replacementStartIndex < 0 || replacementEndIndex > replacement.getSegmentCount() || endIndex > segmentCount) {
			throw new IndexOutOfBoundsException();
		}
		IPv4AddressSection thizz = this;
		if(segmentCount + replacementCount - replacedCount > IPv4Address.SEGMENT_COUNT) {
			throw new AddressValueException(this, replacement, segmentCount + replacementCount - replacedCount);
		} else if(replacementCount == 0 && replacedCount == 0) {//keep in mind for ipvx, empty sections cannot have prefix lengths
			return this;
		} else if(segmentCount == replacedCount) {//keep in mind for ipvx, empty sections cannot have prefix lengths
			return replacement;
		} else if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			if(appendNetwork) {
				thizz = withoutPrefixLength();
				int replacementEndBits = replacementEndIndex << 3;
				if(!replacement.isPrefixed() || replacement.getNetworkPrefixLength() > replacementEndBits) {
					replacement = replacement.setPrefixLength(replacementEndBits, false);
				}
			}
		} else {
			Integer prefixLength = getPrefixLength();
			if(appendNetwork) {
				int additionalSegs = segmentCount - endIndex;
				if(additionalSegs > 0) {
					//we move the non-replaced host segments from the end of this to the end of the replacement segments
					//and we also remove the prefix length from this
					thizz = getSection(0, startIndex).withoutPrefixLength();
					replacement = replacement.insert(replacementEndIndex, getSection(endIndex));
					replacementEndIndex += additionalSegs;
					endIndex = startIndex;
				} else {
					thizz = withoutPrefixLength();
					int replacementEndBits = replacementEndIndex << 3;
					if(!replacement.isPrefixed() || replacement.getNetworkPrefixLength() > replacementEndBits) {
						replacement = replacement.setPrefixLength(replacementEndBits, false);
					}
				}
			} else if(prefixLength != null && !appendNetwork && prefixLength <= startIndex << 3) {
				replacement = replacement.setPrefixLength(0, false);
			} else if(endIndex < segmentCount) {
				int replacementEndBits = replacementEndIndex << 3;
				if(replacement.isPrefixed() && replacement.getNetworkPrefixLength() <= replacementEndBits) {
					int thisNextIndexBits = endIndex << 3;
					if(prefixLength == null || prefixLength > thisNextIndexBits) {
						if(replacedCount > 0 || replacement.getPrefixLength() == 0) {
							thizz = setPrefixLength(thisNextIndexBits, false);
						} else {
							//we move the non-replaced host segments from the end of this to the end of the replacement segments
							//and we also remove the prefix length from this
							int additionalSegs = segmentCount - endIndex;
							thizz = getSection(0, startIndex);
							replacement = replacement.insert(replacementEndIndex, getSection(endIndex));
							replacementEndIndex += additionalSegs;
						}
					}
				}
			}
		}
		return replace(thizz, startIndex, endIndex, replacement, replacementStartIndex, replacementEndIndex, getAddressCreator(), appendNetwork, false);
	}
	
	/**
	 * Produces the subnet sections whose individual sections are found in both this and the given argument.
	 * <p>
	 * This is also known as the conjunction of the two sets of address sections.
	 * <p>
	 * @param other
	 * @return the section containing the sections found in both this and the given subnet sections
	 */
	public IPv4AddressSection intersect(IPv4AddressSection other) throws SizeMismatchException {
		return intersect(this, other, getAddressCreator(), this::getSegment, other::getSegment);
	}
	
	/**
	 * Subtract the given subnet from this subnet, returning an array of sections for the result (the subnets will not be contiguous so an array is required).
	 * <p>
	 * Computes the subnet difference, the set of addresses in this address section but not in the provided section.  This is also known as the relative complement of the given argument in this subnet.
	 * <p>
	 * Keep in mind this is set subtraction, not subtraction of segment values.  We have a subnet of addresses and we are removing some of those addresses.
	 * 
	 * @param other
	 * @throws SizeMismatchException if the two sections are different sizes
	 * @return the difference, or null if there are no remaining sections
	 */
	public IPv4AddressSection[] subtract(IPv4AddressSection other) throws SizeMismatchException {
		return subtract(this, other, getAddressCreator(), this::getSegment, (section, prefix) -> section.setPrefixLength(prefix, false, true));
	}
	@Override
	public IPv4AddressNetwork getNetwork() {
		return Address.defaultIpv4Network();
	}
	@Override
	public IPv4AddressSection adjustPrefixBySegment(boolean nextSegment) {
		return adjustPrefixBySegment(nextSegment, true);
	}
	
	@Override
	public IPv4AddressSection adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return (IPv4AddressSection) super.adjustPrefixBySegment(nextSegment, zeroed);
	}
	
	@Override
	public IPv4AddressSection adjustPrefixLength(int adjustment) {
		return adjustPrefixLength(adjustment, true);
	}
	@Override
	public IPv4AddressSection adjustPrefixLength(int adjustment, boolean zeroed) {
		return (IPv4AddressSection) adjustPrefixLength(this, adjustment, zeroed, getAddressCreator(), (section, i) -> section.getSegment(i));
	}
	
	@Deprecated
	@Override
	public IPv4AddressSection applyPrefixLength(int networkPrefixLength) {
		return setPrefixLength(networkPrefixLength, true, true, true);
	}
	
	@Override
	public IPv4AddressSection setPrefixLength(int networkPrefixLength) {
		return setPrefixLength(networkPrefixLength, true, false, true);
	}
	
	@Override
	public IPv4AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros) {
		return setPrefixLength(networkPrefixLength, withZeros, false, true);
	}
	
	@Override
	public IPv4AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros, boolean zeroHostIsBlock) throws PrefixLenException {
		return setPrefixLength(networkPrefixLength, withZeros, false, zeroHostIsBlock);
	}
	private IPv4AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros, boolean noShrink, boolean zeroHostIsBlock) {
		return setPrefixLength(
				this,
				getAddressCreator(),
				networkPrefixLength,
				withZeros,
				noShrink,
				!zeroHostIsBlock,
				(section, i) -> section.getSegment(i));
	}
	@Override
	@Deprecated
	public IPv4AddressSection removePrefixLength() {
		return removePrefixLength(true);
	}
	
	@Override
	public IPv4AddressSection withoutPrefixLength() {
		return removePrefixLength(false);
	}
	
	@Override @Deprecated
	public IPv4AddressSection removePrefixLength(boolean zeroed) {
		return removePrefixLength(this, zeroed, getAddressCreator(), IPv4AddressSection::getSegment);
	}
	@Override
	public IPv4AddressSection toZeroHost() throws IncompatibleAddressException {
		if(!isPrefixed()) {
			IPv4AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv4Address networkMask = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				networkMask = networkMask.getLower();
			}
			return networkMask.getSection(0, getSegmentCount());
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();//cached
		}
		return createZeroHost(false);
	}
	IPv4AddressSection createZeroHost(boolean boundariesOnly) {
		int prefixLength = getNetworkPrefixLength();//we know it is prefixed here so no NullPointerException
		IPv4AddressNetwork network = getNetwork();
		IPv4Address mask = network.getNetworkMask(prefixLength);
		return getSubnetSegments(
				this,
				network.getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : cacheBits(prefixLength),
				getAddressCreator(),
				!boundariesOnly,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	
	@Override
	public IPv4AddressSection toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		IPv4Address mask = getNetwork().getNetworkMask(prefixLength);
		return getSubnetSegments(
				this,
				null,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	
	@Override
	public IPv4AddressSection toZeroNetwork() {
		if(!isPrefixed()) {
			IPv4Address hostMask = getNetwork().getHostMask(getBitCount());
			return hostMask.getSection(0, getSegmentCount());
		}
		return createZeroNetwork();
	}
	
	IPv4AddressSection createZeroNetwork() {
		Integer prefixLength = getNetworkPrefixLength();
		IPv4Address mask = getNetwork().getHostMask(prefixLength);
		return getSubnetSegments(
				this,
				prefixLength,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	@Override
	public IPv4AddressSection toMaxHost() throws IncompatibleAddressException {
		if(!isPrefixed()) {
			IPv4Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix.getSection(0, getSegmentCount());
			}
			return resultNoPrefix.setPrefixLength(0).getSection(0, getSegmentCount());
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper(); // cached
		}
		return createMaxHost();
	}
	public IPv4AddressSection createMaxHost() {
		Integer prefixLength = getNetworkPrefixLength();//we know it is prefixed here so no NullPointerException
		IPv4Address mask = getNetwork().getHostMask(prefixLength);
		return getOredSegments(
				this,
				getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : prefixLength,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	@Override
	public IPv4AddressSection toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		IPv4Address mask = getNetwork().getHostMask(prefixLength);
		return getOredSegments(
				this,
				null,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	/**
	 * Does the bitwise conjunction with this address.  Useful when subnetting.
	 * 
	 * @param mask
	 * @param retainPrefix whether to drop the prefix
	 * @return
	 * @throws IncompatibleAddressException
	 */
	public IPv4AddressSection mask(IPv4AddressSection mask, boolean retainPrefix) throws IncompatibleAddressException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		return getSubnetSegments(
				this,
				retainPrefix ? getPrefixLength() : null,
				getAddressCreator(),
				true,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				false);
	}
	/**
	 * Equivalent to {@link #mask(IPv4AddressSection, boolean)} with the second argument as false.
	 */
	public IPv4AddressSection mask(IPv4AddressSection mask) throws IncompatibleAddressException, SizeMismatchException {
		return mask(mask, false);
	}
	
	/**
	 * Produces the bitwise conjunction of the given mask with the network section of the address as indicated by the given prefix length.
	 * Useful for subnetting.  Once you have zeroed a section of the network you can insert bits 
	 * using {@link #bitwiseOr(IPv4AddressSection)} or {@link #replace(int, IPv4AddressSection)}
	 * 
	 * @param mask
	 * @param networkPrefixLength
	 * @return
	 * @throws IncompatibleAddressException
	 */
	public IPv4AddressSection maskNetwork(IPv4AddressSection mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		IPv4AddressSection hostMask = getNetwork().getHostMaskSection(networkPrefixLength);
		return getSubnetSegments(
				this,
				cacheBits(networkPrefixLength),
				getAddressCreator(),
				true, 
				this::getSegment, 
				i -> {
					int val1 = mask.getSegment(i).getSegmentValue();
					int val2 = hostMask.getSegment(i).getSegmentValue();
					return val1 | val2;
				},
				false);
	}
	protected static Integer cacheBits(int i) {
		return IPAddressSection.cacheBits(i);
	}
	
	/**
	 * Equivalent to {@link #bitwiseOr(IPv4AddressSection, boolean)} with the second argument as false.
	 */
	public IPv4AddressSection bitwiseOr(IPv4AddressSection mask) throws IncompatibleAddressException {
		return bitwiseOr(mask, false);
	}
	
	/**
	 * Does the bitwise disjunction with this address section.  Useful when subnetting.  Similar to {@link #mask(IPv4AddressSection)} which does the bitwise conjunction.
	 * 
	 * @param retainPrefix whether the result will retain the same prefix length as this.
	 * @return
	 * @throws IncompatibleAddressException
	 */
	public IPv4AddressSection bitwiseOr(IPv4AddressSection mask, boolean retainPrefix) throws IncompatibleAddressException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		return getOredSegments(
				this,
				retainPrefix ? getPrefixLength() : null,
				getAddressCreator(),
				true,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	/**
	 * Does the bitwise disjunction with this address section.  Useful when subnetting.  Similar to {@link #maskNetwork(IPv4AddressSection, int)} which does the bitwise conjunction.
	 * <p>
	 * Any existing prefix length is dropped for the new prefix length and the disjunction is applied up to the end the new prefix length.
	 * 
	 * @param mask
	 * @return
	 * @throws IncompatibleAddressException
	 */
	public IPv4AddressSection bitwiseOrNetwork(IPv4AddressSection mask, int networkPrefixLength) throws IncompatibleAddressException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		IPv4AddressSection networkMask = getNetwork().getNetworkMaskSection(networkPrefixLength);
		return getOredSegments(
				this,
				cacheBits(networkPrefixLength),
				getAddressCreator(),
				true,
				this::getSegment, 
				i -> {
					int val1 = mask.getSegment(i).getSegmentValue();
					int val2 = networkMask.getSegment(i).getSegmentValue();
					return val1 & val2;
				}
		);
	}
	@Override
	public IPv4AddressSection getHostMask() {
		return (IPv4AddressSection) super.getHostMask();
	}
	@Override
	public IPv4AddressSection getNetworkMask() {
		return (IPv4AddressSection) super.getNetworkMask();
	}
	@Override
	public IPv4AddressSection getNetworkSection() {
		if(isPrefixed()) {
			return getNetworkSection(getNetworkPrefixLength());
		}
		return getNetworkSection(getBitCount());
	}
	
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getNetworkSection(networkPrefixLength, true);
	}
	
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getNetworkSection(this, networkPrefixLength, withPrefixLength, getAddressCreator(), (prefix, i) -> getSegment(i).toNetworkSegment(prefix, withPrefixLength));
	}
	
	@Override
	public IPv4AddressSection getHostSection() {
		if(isPrefixed()) {
			return getHostSection(getNetworkPrefixLength());
		}
		return getHostSection(0);
	}
	
	@Override
	public IPv4AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		int hostSegmentCount = getHostSegmentCount(networkPrefixLength);
		return getHostSection(this, networkPrefixLength, hostSegmentCount, getAddressCreator(), (prefix, i) -> getSegment(i).toHostSegment(prefix));
	}
	
	@Override
	public IPv4AddressSection toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	
	@Override
	public IPv4AddressSection toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return toPrefixBlock(this, networkPrefixLength, getAddressCreator(), (prefix, i) -> getSegment(i).toNetworkSegment(prefix, true));
	}
	
	@Override
	public IPv4AddressSection assignPrefixForSingleBlock() {
		return (IPv4AddressSection) super.assignPrefixForSingleBlock();
	}
	
	@Override
	public IPv4AddressSection assignMinPrefixForBlock() {
		return (IPv4AddressSection) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv4AddressSection coverWithPrefixBlock() {
		return (IPv4AddressSection) coverWithPrefixBlock(this, getLower(), getUpper());
	}
	public IPv4AddressSection coverWithPrefixBlock(IPv4AddressSection other) throws AddressConversionException {
		checkSegmentCount(other);
		return coverWithPrefixBlock(
				this,
				other,
				IPv4AddressSection::getLower,
				IPv4AddressSection::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	protected static <T extends IPAddressSegmentSeries> T coverWithPrefixBlock(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator) throws AddressConversionException {
		return IPAddressSection.coverWithPrefixBlock(first, other, getLower, getUpper, comparator);
	}
	protected static IPAddressSegmentSeries coverWithPrefixBlock(
			IPAddressSegmentSeries orig,
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper) {
		return IPAddressSection.coverWithPrefixBlock(orig, lower, upper);
	}
	/**
	 * Produces an array of prefix blocks that spans the same set of values.
	 * <p>
	 * Unlike {@link #spanWithPrefixBlocks(IPv4AddressSection)} this method only includes blocks that are a part of this section.
	 */
	@Override
	public IPv4AddressSection[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv4AddressSection[] {this};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4AddressSection> list = (ArrayList<IPv4AddressSection>) spanWithBlocks(true);
		return list.toArray(new IPv4AddressSection[list.size()]);
	}
	/**
	 * Produces the list of prefix block subnets that span from this series to the given series.
	 * 
	 * @param other
	 * @return
	 */
	public IPv4AddressSection[] spanWithPrefixBlocks(IPv4AddressSection other) {
		return getSpanningPrefixBlocks(
				this,
				other,
				IPv4AddressSection::getLower,
				IPv4AddressSection::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4AddressSection::assignPrefixForSingleBlock,
				IPv4AddressSection::withoutPrefixLength,
				getAddressCreator()::createSectionArray);
	}
	
	/**
	 * 
	 * @param other
	 * @deprecated use {@link #spanWithSequentialBlocks(IPv4AddressSection)}
	 * @return
	 */
	@Deprecated
	public IPv4AddressSection[] spanWithRangedSegments(IPv4AddressSection other) {
		return spanWithSequentialBlocks(other);
	}
	/**
	 * Produces an array of blocks that are sequential that cover the same set of sections as this.
	 * <p>
	 * This array can be shorter than that produced by {@link #spanWithPrefixBlocks()} and is never longer.
	 * <p>
	 * Unlike {@link #spanWithSequentialBlocks(IPv4AddressSection)} this method only includes values that are a part of this section.
	 */
	@Override
	public IPv4AddressSection[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv4AddressSection[] { withoutPrefixLength() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4AddressSection> list = (ArrayList<IPv4AddressSection>) spanWithBlocks(false);
		return list.toArray(new IPv4AddressSection[list.size()]);
	}
	
	/**
	 * Produces a list of range subnets that span from this series to the given series.
	 * 
	 * @param other
	 * @return
	 */
	public IPv4AddressSection[] spanWithSequentialBlocks(IPv4AddressSection other) {
		return getSpanningSequentialBlocks(
				this,
				other,
				IPv4AddressSection::getLower,
				IPv4AddressSection::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4AddressSection::withoutPrefixLength,
				getAddressCreator());
	}
	
	/**
	 * 
	 * @param sections
	 * @deprecated use {@link #mergeToPrefixBlocks(IPv4AddressSection...)}
	 * @return
	 * @throws SizeMismatchException
	 */
	@Deprecated
	public IPv4AddressSection[] mergePrefixBlocks(IPv4AddressSection ...sections) throws SizeMismatchException {
		return mergeToPrefixBlocks(sections);
	}
	/**
	 * Merges this with the list of sections to produce the smallest array of prefix blocks.
	 * <p>
	 * The resulting array is sorted from lowest address value to highest, regardless of the size of each prefix block.
	 * <p>
	 * In version 5.3.1 and earlier, the result was sorted from single address to smallest blocks to largest blocks.
	 * For that ordering, sort with {@link IPAddressSegmentSeries#getPrefixLenComparator()}:<br>
	 * <code>Arrays.sort(result, IPAddressSegmentSeries.getPrefixLenComparator());</code>
	 * 
	 * @param sections the sections to merge with this
	 * @return
	 */
	public IPv4AddressSection[] mergeToPrefixBlocks(IPv4AddressSection ...sections) throws SizeMismatchException {
		checkSectionsMergeable(sections);
		IPv4AddressSection converted[] = getCloned(sections);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv4AddressSection[blocks.size()]);
	}
	
	private IPv4AddressSection[] getCloned(IPv4AddressSection... sections) {
		IPv4AddressSection converted[] = new IPv4AddressSection[sections.length + 1];
		System.arraycopy(sections, 0, converted, 1, sections.length);
		converted[0] = this;
		return converted;
	}
	
	private void checkSectionsMergeable(IPv4AddressSection sections[]) {
		for(int i = 0; i < sections.length; i++) {
			IPv4AddressSection section = sections[i];
			if(section == null) {
				continue;
			}
			if(section.getSegmentCount() != getSegmentCount()) {
				throw new SizeMismatchException(this, section);
			}
		}
	}
	/**
	 * Merges this with the list of sections to produce the smallest array of sequential block subnets.
	 * <p>
	 * The resulting array is sorted by lower address, regardless of the size of each prefix block.
	 * <p>
	 * In version 5.3.1 and earlier, the result was sorted from single address to smallest blocks to largest blocks.
	 * For that ordering, sort with {@link IPAddressSegmentSeries#getPrefixLenComparator()}:<br>
	 * <code>Arrays.sort(result, IPAddressSegmentSeries.getPrefixLenComparator());</code>
	 * 
	 * @param sections the sections to merge with this
	 * @return
	 */
	public IPv4AddressSection[] mergeToSequentialBlocks(IPv4AddressSection ...sections) throws SizeMismatchException {
		checkSectionsMergeable(sections);
		IPv4AddressSection converted[] = getCloned(sections);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getAddressCreator()::createSequentialBlockSection);
		return blocks.toArray(new IPv4AddressSection[blocks.size()]);
	}
	@Override
	protected boolean hasNoStringCache() {
		if(stringCache == null) {
			synchronized(this) {
				if(stringCache == null) {
					stringCache = new IPv4StringCache();
					return true;
				}
			}
		}
		return false;
	}
	
	@Override
	protected IPv4StringCache getStringCache() {
		return stringCache;
	}
	
	/**
	 * This produces a canonical string.
	 * 
	 * If this has a prefix length, that will be included in the string.
	 */
	@Override
	public String toCanonicalString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalString) == null) {
			stringCache.canonicalString = result = toNormalizedString(IPv4StringCache.canonicalParams);
		}
		return result;
	}
	/**
	 * This produces a string with no compressed segments and all segments of full length,
	 * which is 3 characters for IPv4 segments.
	 */
	@Override
	public String toFullString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.fullString) == null) {
			stringCache.fullString = result = toNormalizedString(IPv4StringCache.fullParams);
		}
		return result;
	}
	
	/**
	 * The shortest string for IPv4 addresses is the same as the canonical string.
	 */
	@Override
	public String toCompressedString() {
		return toCanonicalString();
	}
	/**
	 * The normalized string returned by this method is consistent with java.net.Inet4Address,
	 * and is the same as {@link #toCanonicalString()}.
	 */
	@Override
	public String toNormalizedString() {
		return toCanonicalString();
	}
	@Override
	protected void cacheNormalizedString(String str) {
		if(hasNoStringCache() || stringCache.canonicalString == null) {
			stringCache.canonicalString = str;
		}
	}
	@Override
	public String toCompressedWildcardString() {
		return toNormalizedWildcardString();
	}
	
	@Override
	public String toSubnetString() {
		return toNormalizedWildcardString();
	}
	
	@Override
	public String toPrefixLengthString() {
		return toCanonicalString();
	}
	
	public String toInetAtonString(IPv4Address.inet_aton_radix radix) {
		String result;
		if(radix == IPv4Address.inet_aton_radix.OCTAL) {
			if(hasNoStringCache() || (result = stringCache.octalString) == null) {
				stringCache.octalString = result = toNormalizedString(IPv4StringCache.inetAtonOctalParams);
			}
		} else if(radix == IPv4Address.inet_aton_radix.HEX) {
			if(hasNoStringCache() || (result = stringCache.hexString) == null) {
				stringCache.hexString = result = toNormalizedString(IPv4StringCache.inetAtonHexParams);
			}
		} else {
			result = toCanonicalString();
		}
		return result;
	}
	public String toInetAtonString(IPv4Address.inet_aton_radix radix, int joinedCount) throws IncompatibleAddressException {
		if(joinedCount <= 0) {
			return toInetAtonString(radix);
		}
		IPStringOptions stringParams;
		if(radix == IPv4Address.inet_aton_radix.OCTAL) {
			stringParams = IPv4StringCache.inetAtonOctalParams;
		} else if(radix == IPv4Address.inet_aton_radix.HEX) {
			stringParams = IPv4StringCache.inetAtonHexParams;
		} else {
			stringParams = IPv4StringCache.canonicalParams;
		}
		return toNormalizedString(stringParams, joinedCount);
	}
	@Override
	public String toNormalizedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedWildcardString) == null) {
			stringCache.normalizedWildcardString = result = toNormalizedString(IPv4StringCache.normalizedWildcardParams);
		}
		return result;
	}
	@Override
	public String toCanonicalWildcardString() {
		return toNormalizedWildcardString();
	}
	@Override
	public String toSQLWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.sqlWildcardString) == null) {
			stringCache.sqlWildcardString = result = toNormalizedString(IPv4StringCache.sqlWildcardParams);
		}
		return result;
	}
	
	@Override
	public String toReverseDNSLookupString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.reverseDNSString) == null) {
			stringCache.reverseDNSString = result = toNormalizedString(IPv4StringCache.reverseDNSParams);
		}
		return result;
	}
	@Override
	public String toSegmentedBinaryString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.segmentedBinaryString) == null) {
			stringCache.segmentedBinaryString = result = toNormalizedString(IPv4StringCache.segmentedBinaryParams);
		}
		return result;
	}
	
	public String toNormalizedString(IPStringOptions stringParams, int joinCount) throws IncompatibleAddressException {
		if(joinCount <= 0) {
			return toNormalizedString(stringParams);
		}
		int thisCount = getSegmentCount();
		if(thisCount <= 1) {
			return toNormalizedString(stringParams);
		}
		IPAddressStringDivisionSeries equivalentPart = toJoinedSegments(joinCount);
		return toNormalizedString(stringParams, equivalentPart);
	}
	
	public IPAddressDivisionGrouping toJoinedSegments(int joinCount) {
		int thisCount = getSegmentCount();
		if(joinCount <= 0 || thisCount <=1) {
			return this;
		}
		int totalCount;
		if(joinCount >= thisCount) {
			joinCount = thisCount - 1;
			totalCount = 1;
		} else {
			totalCount = thisCount - joinCount;
		}
		int notJoinedCount = totalCount - 1;
		IPAddressDivision segs[] = new IPAddressDivision[totalCount];
		int i = 0;
		for(; i < notJoinedCount; i++) {
			segs[i] = getDivision(i);
		}
		IPv4JoinedSegments joinedSegment = joinSegments(joinCount);
		segs[notJoinedCount] = joinedSegment;
		IPAddressDivisionGrouping equivalentPart = new IPAddressDivisionGrouping(segs, getNetwork());
		return equivalentPart;
	}
	private IPv4JoinedSegments joinSegments(int joinCount) {
		long lower = 0, upper = 0;
		int networkPrefixLength = 0;
		Integer prefix = null;
		int firstSegIndex = 0;
		IPv4AddressSegment firstRange = null;
		int firstJoinedIndex = getSegmentCount() - 1 - joinCount;
		for(int j = 0; j <= joinCount; j++) {
			IPv4AddressSegment thisSeg = getSegment(firstJoinedIndex + j);
			if(firstRange != null) {
				if(!thisSeg.isFullRange()) {
					throw new IncompatibleAddressException(firstRange, firstSegIndex, thisSeg, firstJoinedIndex + j, "ipaddress.error.segmentMismatch");
				}
			} else if(thisSeg.isMultiple()) {
				firstSegIndex = firstJoinedIndex + j;
				firstRange = thisSeg;
			}
			lower = lower << getBitsPerSegment() | thisSeg.getSegmentValue();
			upper = upper << getBitsPerSegment() | thisSeg.getUpperSegmentValue();
			if(prefix == null) {
				Integer thisSegPrefix = thisSeg.getSegmentPrefixLength();
				if(thisSegPrefix != null) {
					prefix = cacheBits(networkPrefixLength + thisSegPrefix);
				} else {
					networkPrefixLength += thisSeg.getBitCount();
				}
			}
		}
		IPv4JoinedSegments joinedSegment = new IPv4JoinedSegments(joinCount, lower, upper, prefix);
		return joinedSegment;
	}
	
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.ALL_OPTS);
	}
	
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.STANDARD_OPTS);
	}
	
	@Override
	public IPAddressPartStringCollection toDatabaseSearchStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.DATABASE_SEARCH_OPTS);
	}
	
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv4StringBuilderOptions.from(opts));
	}
	public IPAddressPartStringCollection toStringCollection(IPv4StringBuilderOptions opts) {
		IPv4SectionStringCollection collection = new IPv4SectionStringCollection();
		IPAddressStringDivisionSeries parts[] = getParts(opts);
		for(IPAddressStringDivisionSeries part : parts) {
			IPv4StringBuilder builder = new IPv4StringBuilder(part, opts, new IPv4AddressSectionStringCollection(part));
			IPv4AddressSectionStringCollection subCollection = builder.getVariations();
			collection.add(subCollection);
		}
		return collection;
	}
	
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv4StringBuilderOptions.from(options));
	}
	
	public IPAddressStringDivisionSeries[] getParts(IPv4StringBuilderOptions options) {
		if(!options.includesAny(IPv4StringBuilderOptions.ALL_JOINS)) {
			return super.getParts(options);
		}
		ArrayList<IPAddressStringDivisionSeries> parts = new ArrayList<>(IPv4Address.SEGMENT_COUNT);
		if(options.includes(IPStringBuilderOptions.BASIC)) {
			parts.add(this);
		}
		boolean joined[] = new boolean[IPv4Address.SEGMENT_COUNT];
		int segmentCount = getSegmentCount();
		joined[Math.max(3, segmentCount - 1)] = options.includes(IPv4StringBuilderOptions.JOIN_ALL);
		joined[Math.max(2, Math.min(2, segmentCount - 1))] |= options.includes(IPv4StringBuilderOptions.JOIN_TWO);
		joined[Math.max(1, Math.min(1, segmentCount - 1))] |= options.includes(IPv4StringBuilderOptions.JOIN_ONE);
		for(int i = 1; i < joined.length; i++) {
			if(joined[i]) {
				parts.add(toJoinedSegments(i));
			}
		}
		return parts.toArray(new IPAddressStringDivisionSeries[parts.size()]);
	}
	
	static class EmbeddedIPv4AddressSection extends IPv4AddressSection {
		private static final long serialVersionUID = 4L;
		
		private final IPAddressSection encompassingSection;
		EmbeddedIPv4AddressSection(IPAddressSection encompassingSection, IPv4AddressSegment subSegments[]) {
			super(subSegments, false);
			this.encompassingSection = encompassingSection;
		}
		@Override
		public boolean isPrefixBlock() {
			return encompassingSection.isPrefixBlock();
		}
	}
	static class IPv4SectionStringCollection extends IPAddressPartStringCollection {
	
		@Override
		protected void add(IPAddressPartStringSubCollection<?, ?, ? extends IPAddressPartConfiguredString<?, ?>> collection) {
			super.add(collection);
		}
		
		@Override
		protected void addAll(IPAddressPartStringCollection collections) {
			super.addAll(collections);
		}
	}
	
	public static class IPv4StringBuilderOptions extends IPStringBuilderOptions {
		public static final int JOIN_ALL = 0x2;
		public static final int JOIN_TWO = 0x4;
		public static final int JOIN_ONE = 0x8;
		public static final int ALL_JOINS = JOIN_ALL | JOIN_TWO | JOIN_ONE;
		
		public static final int IPV6_CONVERSIONS = 0x10000;
		
		//right now we do not do mixing of octal and/or hex and/or decimal which could create another 81 = 3^4 combos with 4 segments
		public static final int OCTAL = 0x100;
		public static final int HEX = 0x200;
		
		public final IPv6StringBuilderOptions ipv6ConverterOptions;
		public final IPv6AddressConverter converter;
		public static final IPv4StringBuilderOptions STANDARD_OPTS = new IPv4StringBuilderOptions(IPStringBuilderOptions.BASIC | IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS);
		
		public static final IPv4StringBuilderOptions DATABASE_SEARCH_OPTS = new IPv4StringBuilderOptions();
		
		public static final IPv4StringBuilderOptions ALL_OPTS = new IPv4StringBuilderOptions(
				IPStringBuilderOptions.BASIC | 
					IPv4StringBuilderOptions.JOIN_ALL | 
					IPv4StringBuilderOptions.JOIN_TWO | 
					IPv4StringBuilderOptions.JOIN_ONE |
					IPv4StringBuilderOptions.HEX |
					IPv4StringBuilderOptions.OCTAL |
					IPv4StringBuilderOptions.IPV6_CONVERSIONS |
					IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS,
				null,
				new IPv6StringBuilderOptions(
						IPStringBuilderOptions.BASIC | 
							IPv6StringBuilderOptions.MIXED |
							IPv6StringBuilderOptions.UPPERCASE | 
							IPv6StringBuilderOptions.COMPRESSION_ALL_FULL |
							IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS));
		public IPv4StringBuilderOptions() {
			this.ipv6ConverterOptions = null;
			this.converter = null;
		}
		
		public IPv4StringBuilderOptions(int options) {
			this(options, null, null);
		}
		
		public IPv4StringBuilderOptions(int options, IPv6AddressConverter ipv6AddressConverter, IPv6StringBuilderOptions ipv6ConverterOptions) {
			super(options | (ipv6ConverterOptions == null ? 0 : IPV6_CONVERSIONS));
			if(includes(IPV6_CONVERSIONS)) {
				if(ipv6ConverterOptions == null) {
					ipv6ConverterOptions = new IPv6StringBuilderOptions(
							IPStringBuilderOptions.BASIC | 
							IPv6StringBuilderOptions.UPPERCASE | 
							IPv6StringBuilderOptions.COMPRESSION_ALL_FULL | 
							IPv6StringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS | 
							IPv6StringBuilderOptions.MIXED);
				}
				if(ipv6AddressConverter == null) {
					ipv6AddressConverter = IPAddress.DEFAULT_ADDRESS_CONVERTER;
				}
			}
			this.ipv6ConverterOptions = ipv6ConverterOptions;
			this.converter = ipv6AddressConverter;
		}
		
		public static IPv4StringBuilderOptions from(IPStringBuilderOptions opts) {
			if(opts instanceof IPv4StringBuilderOptions) {
				return (IPv4StringBuilderOptions) opts;
			}
			return new IPv4StringBuilderOptions(opts.options & ~(ALL_JOINS | IPV6_CONVERSIONS | OCTAL | HEX));
		}
	}
	
	/**
	 * Represents a clear way to create a specific type of string.
	 * 
	 * @author sfoley
	 */
	public static class IPv4StringOptions extends IPStringOptions {
		
		protected IPv4StringOptions(
				int base,
				boolean expandSegments,
				WildcardOption wildcardOption,
				Wildcards wildcards,
				String segmentStrPrefix,
				Character separator,
				String label,
				String suffix,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			super(base, expandSegments, wildcardOption, wildcards, segmentStrPrefix, separator, ' ', label, suffix, reverse, splitDigits, uppercase);
		}
		
		public static class Builder extends IPStringOptions.Builder {
			
			public Builder() {
				this(IPv4Address.DEFAULT_TEXTUAL_RADIX, IPv4Address.SEGMENT_SEPARATOR);
			}
			
			protected Builder(int base, char separator) {
				super(base, separator);
			}
			
			@Override
			public IPv4StringOptions toOptions() {
				return new IPv4StringOptions(base, expandSegments, wildcardOption, wildcards, segmentStrPrefix, separator, addrLabel, addrSuffix, reverse, splitDigits, uppercase);
			}
		}
	}
	/**
	 * Each IPv4StringParams instance has settings to write exactly one IPv4 address section string.
	 * Using this class allows us to avoid referencing StringParams<IPAddressPart> everywhere,
	 * but in reality this class has no functionality of its own.
	 * 
	 * @author sfoley
	 *
	 */
	private static class IPv4StringParams extends IPAddressStringParams<IPAddressStringDivisionSeries> {
		
		IPv4StringParams(int radix) {
			super(radix, IPv4Address.SEGMENT_SEPARATOR, false);
		}
		
		@Override
		public IPv4StringParams clone() {
			return (IPv4StringParams) super.clone();
		}
	}
	static class IPv4StringCollection extends IPAddressPartStringCollection {
		
		@Override
		protected void addAll(IPAddressPartStringCollection collections) {
			super.addAll(collections);
		}
		
		static class IPv4AddressSectionStringCollection extends IPAddressPartStringSubCollection<IPAddressStringDivisionSeries, IPv4StringParams, IPAddressPartConfiguredString<IPAddressStringDivisionSeries, IPv4StringParams>> {
			IPv4AddressSectionStringCollection(IPAddressStringDivisionSeries addr) {
				super(addr);
			}
			
			@Override
			public Iterator<IPAddressPartConfiguredString<IPAddressStringDivisionSeries, IPv4StringParams>> iterator() {
				return new IPAddressConfigurableStringIterator() {
					@Override
					public IPAddressPartConfiguredString<IPAddressStringDivisionSeries, IPv4StringParams> next() {
						return new IPAddressPartConfiguredString<IPAddressStringDivisionSeries, IPv4StringParams>(part, iterator.next()); 
					}
				};
			}
		}
		/**
		 * Capable of building any and all possible representations of IPv4 addresses.
		 * Not all such representations are necessarily something you might consider valid.
		 * For example: 001.02.3.04
		 * This string has the number '2' and '4' expanded partially to 02 (a partial expansion), rather than left as is, or expanded to the full 3 chars 002.
		 * The number '1' is fully expanded to 3 characters.
		 * 
		 * With the default settings of this class, a single address can have 16 variations.  If partial expansions are allowed, there are many more.
		 * 
		 * @author sfoley
		 */
		static class IPv4StringBuilder
			extends AddressPartStringBuilder<IPAddressStringDivisionSeries, IPv4StringParams, IPAddressPartConfiguredString<IPAddressStringDivisionSeries, IPv4StringParams>, IPv4AddressSectionStringCollection, IPv4StringBuilderOptions> {
			
			private IPv4StringBuilder(IPAddressStringDivisionSeries address, IPv4StringBuilderOptions options, IPv4AddressSectionStringCollection collection) {
				super(address, options, collection);
			}
			
			/**
			 * 
			 * @return whether this section in decimal appears the same as this segment in octal.
			 * 	This is true if all the values lies between 0 and 8 (so the octal and decimal values are the same)
			 */
			public static boolean isDecimalSameAsOctal(IPAddressStringDivisionSeries part) {
				int count = part.getDivisionCount();
				for(int i = 0; i < count; i++) {
					AddressStringDivision seg = part.getDivision(i);
					//we return true in cases where all segments are between 0 and 7, in which case the octal and decimal digits are the same.
					if(!seg.isBoundedBy(8)) {
						return false;
					}
				}
				return true;	
			}
			
			@Override
			public void addAllVariations() {
				ArrayList<IPv4StringParams> allParams = new ArrayList<IPv4StringParams>();
				ArrayList<Integer> radices = new ArrayList<Integer>();
				radices.add(cacheBits(IPv4Address.DEFAULT_TEXTUAL_RADIX));
				if(options.includes(IPv4StringBuilderOptions.HEX)) {
					radices.add(cacheBits(16));
				}
				boolean hasDecimalOctalDups = false;
				if(options.includes(IPv4StringBuilderOptions.OCTAL)) {
					radices.add(cacheBits(8));
					//We need to consider when octal intersects with a leading zero config. 01 as octal vs 01 as a decimal with leading zero
					//Or 001 as octal with a single leading zero and 001 as decimal with two leading zeros.
					//However, keep in mind this is only true when the segment value is <= 8, otherwise the segment value is different in octal.
					//So if the segment value is <=8 (or both values of a range are <=8) and we are doing both decimal and octal and we are doing partial expansions,
					//then we cannot have repeats. In such cases, each octal expansion of size x is same as decimal expansion of size x + 1 (where x = 0 or 1)
					//But the full string is only a repeat if the whole thing is same in decimal as octal.  Only then will we see dups.
					//So, we skip if we are (a) doing both octal and decimal and (b) all segments are <=8 and 
					//case 1: for the octal:  (c) Every segment is either no expansion or expansion of size 1
					//case 2: for the decimal: (c) Every segment is an expansion of size 1 or 2 (ie 2 is full) 
					//Here we are checking for cases (a) and (b).  (c) we check below.
					hasDecimalOctalDups = options.includes(IPStringBuilderOptions.LEADING_ZEROS_PARTIAL_SOME_SEGMENTS) && IPv4Address.inet_aton_radix.OCTAL.getSegmentStrPrefix().equals("0") && isDecimalSameAsOctal(addressSection);
				}
				for(int radix : radices) {
					ArrayList<IPv4StringParams> radixParams = new ArrayList<>();
					IPv4StringParams stringParams = new IPv4StringParams(radix);
					radixParams.add(stringParams);
					switch(radix) {
						case 8:
							stringParams.setSegmentStrPrefix(IPv4Address.inet_aton_radix.OCTAL.getSegmentStrPrefix());
							break;
						case 16:
							stringParams.setSegmentStrPrefix(IPv4Address.inet_aton_radix.HEX.getSegmentStrPrefix());
							break;
					}
					if(options.includes(IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS)) {
						int expandables[] = getExpandableSegments(radix);
						int count = addressSection.getDivisionCount();
						for(int i = 0; i < count; i++) {
							int expansionLength = expandables[i];
							int len = radixParams.size();
							while(expansionLength > 0) {
								for(int j = 0; j < len; j++) {
									IPv4StringParams clone = radixParams.get(j);
									if(hasDecimalOctalDups && radix == 10) {
										//See above for explanation.
										//we know already expansionLength == 1 || expansionLength == 2 for the current segment
										//Here we check the others
										boolean isDup = true;
										for(int k = 0; k < count; k++) {
											if(k != i) {
												int length = clone.getExpandedSegmentLength(k);
												if(length == 0) {//length is not either 1 or 2
													isDup = false;
													break;
												}
											}
										}
										if(isDup) {
											//this decimal string is a duplicate of an octal string, so we skip it
											continue;
										}
									}
									clone = clone.clone();
									clone.expandSegment(i, expansionLength, addressSection.getDivisionCount());
									radixParams.add(clone);
								}
								if(!options.includes(IPStringBuilderOptions.LEADING_ZEROS_PARTIAL_SOME_SEGMENTS)) {
									break;
								}
								expansionLength--;
							}
						}
					} else if(options.includes(IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS)) {
						boolean allExpandable = isExpandable(radix);
						if(allExpandable) {
							IPv4StringParams expandParams = new IPv4StringParams(IPv4Address.DEFAULT_TEXTUAL_RADIX);
							expandParams.expandSegments(true);
							radixParams.add(expandParams);
						}
					}
					allParams.addAll(radixParams);
				}
				for(int i=0; i<allParams.size(); i++) {
					IPv4StringParams param = allParams.get(i);
					addStringParam(param);
				}
			}
			
			@Override
			protected void addStringParam(IPv4StringParams stringParams) {
				super.addStringParam(stringParams);
			}
		} //end IPv4StringBuilder
	} //end IPv4StringCollection
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv4;
import java.math.BigInteger;
import java.net.Inet4Address;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressConverter;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4AddressCache;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringBuilderOptions;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringCollection;
import inet.ipaddr.ipv4.IPv4AddressTrie.IPv4TrieNode.IPv4TrieKeyData;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6Address.IPv6AddressConverter;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.ipv6.IPv6AddressSegment;
/**
 * An IPv4 address, or a subnet of multiple IPv4 addresses.  Each segment can represent a single value or a range of values.
 * <p>
 * You can construct an IPv4 address from a byte array, from an int, from a {@link inet.ipaddr.Address.SegmentValueProvider}, 
 * from Inet4Address, from an {@link IPv4AddressSection} of 4 segments, or from an array of 4 {@link IPv4AddressSegment} objects.
 * <p>
 * To construct one from a {@link java.lang.String} use 
 * {@link inet.ipaddr.IPAddressString#toAddress()} or  {@link inet.ipaddr.IPAddressString#getAddress()}, {@link inet.ipaddr.IPAddressString#toHostAddress()} or {@link inet.ipaddr.IPAddressString#getHostAddress()}
 * 
 * 
 * @custom.core
 * @author sfoley
 *
 */
public class IPv4Address extends IPAddress implements Iterable<IPv4Address> {
	private static final long serialVersionUID = 4L;
	
	public static final char SEGMENT_SEPARATOR = '.';
	public static final int BITS_PER_SEGMENT = 8;
	public static final int BYTES_PER_SEGMENT = 1;
	public static final int SEGMENT_COUNT = 4;
	public static final int BYTE_COUNT = 4;
	public static final int BIT_COUNT = 32;
	public static final int DEFAULT_TEXTUAL_RADIX = 10;
	public static final int MAX_VALUE_PER_SEGMENT = 0xff;
	public static final int MAX_VALUE = 0xffffffff;
	public static final String REVERSE_DNS_SUFFIX = ".in-addr.arpa";
	
	transient IPv4AddressCache addressCache;
	private transient IPv4TrieKeyData cachedTrieKeyData;
	/**
	 * Constructs an IPv4 address or subnet.
	 * @param segments the address segments
	 * @throws AddressValueException if segments is not length 4
	 */
	public IPv4Address(IPv4AddressSegment[] segments) throws AddressValueException {
		this(segments, null);
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * @param segments the address segments
	 * @param networkPrefixLength
	 * @throws AddressValueException if segments is not length 4
	 */
	public IPv4Address(IPv4AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(segments, networkPrefixLength));
		if(getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv4.invalid.segment.count", getSegmentCount());
		}
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * @param section the address segments
	 * @throws AddressValueException if section does not have 4 segments
	 */
	public IPv4Address(IPv4AddressSection section) throws AddressValueException {
		super(section);
		if(section.getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv4.invalid.segment.count", section.getSegmentCount());
		}
	}
	
	/**
	 * Constructs an IPv4 address.
	 * 
	 * @param address the 4 byte IPv4 address
	 */
	public IPv4Address(int address) {
		this(address, null);
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param address the 4 byte IPv4 address
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 */
	public IPv4Address(int address, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSectionInternal(address, networkPrefixLength));
	}
	
	/**
	 * Constructs an IPv4 address.
	 *
	 * @param inet4Address the java.net address object
	 */
	public IPv4Address(Inet4Address inet4Address, Integer networkPrefixLength) {
		this(inet4Address, inet4Address.getAddress(), networkPrefixLength);
	}
	
	/**
	 * Constructs an IPv4 address.
	 *
	 * @param inet4Address the java.net address object
	 */
	public IPv4Address(Inet4Address inet4Address) {
		this(inet4Address, inet4Address.getAddress(), null);
	}
	
	private IPv4Address(Inet4Address inet4Address, byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(bytes, 0, bytes.length, IPv4Address.SEGMENT_COUNT, networkPrefixLength));
		getSection().setInetAddress(inet4Address);
	}
	
	/**
	 * Constructs an IPv4 address.
	 * 
	 * @param bytes the 4 byte IPv4 address in network byte order - if longer than 4 bytes the additional bytes must be zero, if shorter than 4 bytes then then the bytes are sign-extended to 4 bytes.
	 * @throws AddressValueException if bytes not equivalent to a 4 byte address
	 */
	public IPv4Address(byte[] bytes) throws AddressValueException {
		this(bytes, null);
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * Similar to {@link #IPv4Address(byte[])} except that you can specify the start and end of the address in the given byte array.
	 * 
	 * @param bytes
	 * @throws AddressValueException
	 */
	public IPv4Address(byte[] bytes, int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, null);
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param bytes the 4 byte IPv4 address in network byte order - if longer than 4 bytes the additional bytes must be zero, if shorter than 4 bytes then the bytes are sign-extended to 4 bytes.
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 * @throws AddressValueException if bytes not equivalent to a 4 byte address
	 */
	public IPv4Address(byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, 0, bytes.length, networkPrefixLength);
	}
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * Similar to {@link #IPv4Address(byte[],Integer)} except that you can specify the start and end of the address in the given byte array.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param bytes the 4 byte IPv4 address - if longer than 4 bytes the additional bytes must be zero, if shorter than 4 bytes then the bytes are sign-extended to 4 bytes.
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 * @throws AddressValueException if bytes not equivalent to a 4 byte address
	 */
	public IPv4Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(bytes, byteStartIndex, byteEndIndex, IPv4Address.SEGMENT_COUNT, networkPrefixLength));
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param lowerValueProvider supplies the 1 byte lower values for each segment
	 * @param upperValueProvider supplies the 1 byte upper values for each segment
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 */
	public IPv4Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createFullSectionInternal(lowerValueProvider, upperValueProvider, networkPrefixLength));
	}
	
	/**
	 * Constructs an IPv4 address or subnet.
	 * 
	 * @param lowerValueProvider supplies the 1 byte lower values for each segment
	 * @param upperValueProvider supplies the 1 byte upper values for each segment
	 */
	public IPv4Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, null);
	}
	
	/**
	 * Constructs an IPv4 address.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param valueProvider supplies the 1 byte value for each segment
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 */
	public IPv4Address(SegmentValueProvider valueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, networkPrefixLength);
	}
	
	/**
	 * Constructs an IPv4 address.
	 * 
	 * @param valueProvider supplies the 1 byte value for each segment
	 */
	public IPv4Address(SegmentValueProvider valueProvider) {
		this(valueProvider, (Integer) null);
	}
	@Override
	public IPv4AddressSection getSection() {
		return (IPv4AddressSection) super.getSection();
	}
	@Override
	public IPv4AddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPv4AddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	
	@Override
	public IPv4AddressSegment getDivision(int index) {
		return getSegment(index);
	}
	
	@Override
	public IPv4AddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	
	@Override
	public IPv4AddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv4StringBuilderOptions.from(options));
	}
	
	public IPAddressStringDivisionSeries[] getParts(IPv4StringBuilderOptions options) {
		IPAddressStringDivisionSeries parts[] = getSection().getParts(options);
		IPv6Address ipv6Addr = getConverted(options);
		if(ipv6Addr != null) {
			IPAddressStringDivisionSeries ipv6Parts[] = ipv6Addr.getParts(options.ipv6ConverterOptions);
			IPAddressStringDivisionSeries tmp[] = parts;
			parts = new IPAddressStringDivisionSeries[tmp.length + ipv6Parts.length];
			System.arraycopy(tmp, 0, parts, 0, tmp.length);
			System.arraycopy(ipv6Parts,  0, parts, tmp.length, ipv6Parts.length);
		}
		return parts;
	}
	
	@Override
	public int getSegmentCount() {
		return SEGMENT_COUNT;
	}
	
	@Override
	public int getByteCount() {
		return BYTE_COUNT;
	}
	
	@Override
	public int getBitCount() {
		return BIT_COUNT;
	}
	
	@Override
	public boolean isIPv4() {
		return true;
	}
	
	@Override
	public IPv4Address toIPv4() {
		return this;
	}
	
	@Override
	public boolean isIPv4Convertible() {
		return true;
	}
	
	/**
	 * Create an IPv6 mixed address using the given ipv6 segments and using this address for the embedded IPv4 segments
	 * 
	 * @param segs
	 * @return
	 */
	public IPv6Address getIPv6Address(IPv6AddressSegment segs[]) {
		IPv6AddressCreator creator = getIPv6Network().getAddressCreator();
		return creator.createAddress(IPv6AddressSection.createSection(creator, segs, this)); /* address creation */
	}
	
	public IPv6Address getIPv4MappedAddress() {
		IPv6AddressCreator creator = getIPv6Network().getAddressCreator();
		IPv6AddressSegment zero = creator.createSegment(0);
		IPv6AddressSegment segs[] = creator.createSegmentArray(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT);
		segs[0] = segs[1] = segs[2] = segs[3] = segs[4] = zero;
		segs[5] = creator.createSegment(IPv6Address.MAX_VALUE_PER_SEGMENT);
		return getIPv6Address(segs);
	}
	
	/**
	 * Override this method to convert in your own way.
	 * The default behaviour uses IPv4-mapped conversion.
	 * 
	 * You should also override {@link #toIPv6()} to match the conversion.
	 * 
	 * @see IPv4Address#toIPv6()
	 */
	@Override
	public boolean isIPv6Convertible() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.isIPv6Convertible(this);
	}
	
	/**
	 * Returns this address converted to IPv6.
	 * <p>
	 * You can also use {@link #isIPv6Convertible()} to determine convertibility.  Both use an instance of {@link IPAddressConverter.DefaultAddressConverter} which uses IPv4-mapped address mappings from rfc 4038.
	 * <p>
	 * Override this method and {@link IPv6Address#isIPv6Convertible()} if you wish to map IPv4 to IPv6 according to the mappings defined by
	 * in {@link IPv6Address#isIPv4Compatible()}, {@link IPv6Address#isIPv4Mapped()}, {@link IPv6Address#is6To4()} or some other mapping.
	 * <p>
	 * If you override this method, you should also override the {@link IPv4Address#isIPv6Convertible()} method to match this behaviour, 
	 * and potentially also override the reverse conversion {@link IPv6Address#toIPv4()} in your {@link IPv6Address} subclass.
	 */
	@Override
	public IPv6Address toIPv6() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.toIPv6(this);
	}
	/**
	 * The broadcast address has the same prefix but a host that is all 1 bits.
	 * If this address or subnet is not prefixed, this returns the address of all 1 bits, the "max" address.
	 * 
	 * @return
	 */
	public IPv4Address toBroadcastAddress() {
		return toMaxHost();
	}
	
	/**
	 * The network address has the same prefix but a zero host.
	 * If this address or subnet is not prefixed, this returns the zero "any" address.
	 * 
	 * @return
	 */
	public IPv4Address toNetworkAddress() {
		return toZeroHost();
	}
	
	void cache(IPv4Address lower, IPv4Address upper) {
		getSection().cache(this, lower, upper);
	}
	
	@Override
	public IPv4Address getLowerNonZeroHost() {
		return getSection().getLowestOrHighest(this, true, true);
	}
	
	@Override
	public IPv4Address getLower() {
		return getSection().getLowestOrHighest(this, true, false);
	}
	
	@Override
	public IPv4Address getUpper() {
		return getSection().getLowestOrHighest(this, false, false);
	}
	
	/**
	 * Returns the address (or lowest value of the address if a subnet) as a signed integer
	 * @return the signed integer lower address value
	 */
	public int intValue() {
		return getSection().intValue();
	}
	
	/**
	 * Returns the address (or highest value of the address if a subnet) as a signed integer
	 * @return the signed integer upper address value
	 */
	public int upperIntValue() {
		return getSection().upperIntValue();
	}
	
	/**
	 * Returns the address (or lowest value of the address if a subnet) as a positive integer
	 * @return the positive integer lower address value
	 */
	public long longValue() {
		return getSection().longValue();
	}
	
	/**
	 * Returns the address (or highest value of the address if a subnet) as a positive integer
	 * @return the positive integer upper address value
	 */
	public long upperLongValue() {
		return getSection().upperLongValue();
	}
	
	IPv4TrieKeyData getTrieKeyCache() {
		IPv4TrieKeyData keyData = cachedTrieKeyData;
		if(keyData == null) {
			keyData = new IPv4TrieKeyData();
			Integer prefLen = getPrefixLength();
			keyData.prefixLength = prefLen;
			keyData.uint32Val = intValue();
			if(prefLen != null) {
				int bits = prefLen;
				keyData.nextBitMask32Val = 0x80000000 >>> bits;
				keyData.mask32Val = getNetwork().getNetworkMask(bits, false).intValue();
			}
			cachedTrieKeyData = keyData;
		}
		return keyData;
	}
	/**
	 * Replaces segments starting from startIndex and ending before endIndex with the same number of segments starting at replacementStartIndex from the replacement section
	 * 
	 * @param startIndex
	 * @param endIndex
	 * @param replacement
	 * @param replacementIndex
	 * @throws IndexOutOfBoundsException
	 * @return
	 */
	public IPv4Address replace(int startIndex, int endIndex, IPv4Address replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	
	/**
	 * Replaces segments starting from startIndex with as many segments as possible from the replacement section
	 * 
	 * @param startIndex
	 * @param replacement
	 * @throws IndexOutOfBoundsException
	 * @return
	 */
	public IPv4Address replace(int startIndex, IPv4AddressSection replacement) {
		int replacementCount = Math.min(IPv4Address.SEGMENT_COUNT - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	@Override
	public IPv4Address reverseBits(boolean perByte) {
		return checkIdentity(getSection().reverseBits(perByte));
	}
	
	@Override
	public IPv4Address reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	
	@Override
	public IPv4Address reverseBytesPerSegment() {
		return this;
	}
	
	@Override
	public IPv4Address reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	
	private IPv4Address checkIdentity(IPv4AddressSection newSection) {
		IPv4AddressSection section = getSection();
		if(newSection == section) {
			return this;
		}
		return getAddressCreator().createAddress(newSection);
	}
	
	@Override
	public IPv4Address adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	
	@Override
	public IPv4Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public IPv4Address adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	
	@Override
	public IPv4Address adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength) {
		return setPrefixLength(prefixLength, true);
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength, boolean zeroed) {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	
	@Override
	public IPv4Address setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed, zeroHostIsBlock));
	}
	@Deprecated
	@Override
	public IPv4Address applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().applyPrefixLength(networkPrefixLength));
	}
	@Override @Deprecated
	public IPv4Address removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	
	@Override
	public IPv4Address withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override
	@Deprecated
	public IPv4Address removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsNonZeroHostIterator() {
		return getSection().segmentsNonZeroHostIterator();
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	
	@Override
	public AddressComponentRangeSpliterator<IPv4Address, IPv4AddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getAddressCreator());
	}
	@Override
	public Stream<IPv4AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> iterator() {
		return getSection().iterator(this, getAddressCreator(), null);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4Address> spliterator() {
		return getSection().spliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<IPv4Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> nonZeroHostIterator() {
		Predicate<IPv4AddressSegment[]> excludeFunc = null;
		if(includesZeroHost()) {
			int prefLength = getNetworkPrefixLength();
			excludeFunc = s -> getSection().isZeroHost(s, prefLength);
		}
		return getSection().iterator(this, getAddressCreator(), excludeFunc);
	}
	
	@Override
	public Iterator<IPv4Address> prefixBlockIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), true);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), true);
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixBlockIterator(int prefixLength) {
		return getSection().prefixIterator(this, getAddressCreator(), true, prefixLength);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixBlockSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getAddressCreator(), true, prefixLength);
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream(int prefixLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv4Address> prefixIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), false);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<IPv4Address> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixIterator(int prefixLength) {
		return getSection().prefixIterator(this, getAddressCreator(), false, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getAddressCreator(), false, prefixLength);
	}
	@Override
	public Stream<IPv4Address> prefixStream(int prefixLength) {
		return StreamSupport.stream(prefixSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv4Address> blockIterator(int segmentCount) {
		return getSection().blockIterator(this, getAddressCreator(), segmentCount);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4Address> blockSpliterator(int segmentCount) {
		return getSection().blockSpliterator(this, getAddressCreator(), segmentCount);
	}
	
	@Override
	public Stream<IPv4Address> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4Address> sequentialBlockIterator() {
		return (Iterator<IPv4Address>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv4Address> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv4Address>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv4Address> sequentialBlockStream() {
		return (Stream<IPv4Address>) super.sequentialBlockStream();
	}
	@Override
	public Iterable<IPv4Address> getIterable() {
		return this;
	}
	@Override
	public IPv4Address increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	
	@Override
	public IPv4Address incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	/**
	 * Indicates where an address sits relative to the subnet ordering.
	 * <p>
	 * Equivalent to {@link #enumerate(IPAddress)} but returns a Long rather than a BigInteger.
	 */
	public Long enumerateIPv4(IPv4Address other){
		return IPv4AddressSection.enumerateIPv4(getSection(), other.getSection());
	}
	
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof IPv4Address) {
			return IPv4AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	public BigInteger enumerate(IPAddress other) {
		if(other.isIPv4()) {
			return IPv4AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	IPv4AddressCreator getAddressCreator() {
		return getNetwork().getAddressCreator();
	}
	@Override
	public IPv4AddressNetwork getNetwork() {
		return defaultIpv4Network();
	}
	
	/**
	 * Returns the IPv6 network used by {@link #getIPv4MappedAddress()} and {@link #getIPv6Address(IPv6AddressSegment[])}
	 * 
	 * @return
	 */
	public IPv6AddressNetwork getIPv6Network() {
		return defaultIpv6Network();
	}
	@Override
	protected IPv4Address convertArg(IPAddress arg) throws AddressConversionException {
		IPv4Address converted = arg.toIPv4();
		if(converted == null) {
			throw new AddressConversionException(this, arg);
		}
		return converted;
	}
	@Override
	public IPv4Address intersect(IPAddress other) throws AddressConversionException {
		IPv4AddressSection thisSection = getSection();
		IPv4AddressSection section = thisSection.intersect(convertArg(other).getSection());
		if(section == null) {
			return null;
		}
		IPv4AddressCreator creator = getAddressCreator();
		IPv4Address result = creator.createAddress(section); /* address creation */
		return result;
	}
	
	@Override
	public IPv4Address[] subtract(IPAddress other)  throws AddressConversionException {
		IPv4AddressSection thisSection = getSection();
		IPv4AddressSection sections[] = thisSection.subtract(convertArg(other).getSection());
		if(sections == null) {
			return null;
		}
		IPv4AddressCreator creator = getAddressCreator();
		IPv4Address result[] = new IPv4Address[sections.length];
		for(int i = 0; i < result.length; i++) {
			result[i] = creator.createAddress(sections[i]); /* address creation */
		}
		return result;
	}
	
	@Override
	public IPv4Address toZeroHost() {
		return toZeroHost(false);
	}
	
	@Override
	protected IPv4Address toZeroHost(boolean boundariesOnly) {
		if(!isPrefixed()) {
			IPv4AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv4Address addr = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				addr = addr.getLower();
			}
			return addr;
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();//cached
		}
		return checkIdentity(getSection().createZeroHost(boundariesOnly));
	}
	@Override
	public IPv4Address toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		return checkIdentity(getSection().toZeroHost(prefixLength));
	}
	@Override
	public IPv4Address toZeroNetwork() {
		if(!isPrefixed()) {
			return getNetwork().getHostMask(getBitCount());
		}
		return checkIdentity(getSection().createZeroNetwork());
	}
	@Override
	public IPv4Address toMaxHost() {
		if(!isPrefixed()) {
			IPv4Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix;
			}
			return resultNoPrefix.setPrefixLength(0);
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();//cached
		}
		return checkIdentity(getSection().createMaxHost());
	}
	
	@Override
	public IPv4Address toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		return checkIdentity(getSection().toMaxHost(prefixLength));
	}
	@Override
	public IPv4Address mask(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().mask(convertArg(mask).getSection(), retainPrefix));
	}
	
	@Override
	public IPv4Address mask(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return mask(mask, false);
	}
	
	@Override
	public IPv4Address maskNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().maskNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv4Address bitwiseOr(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOr(convertArg(mask).getSection(), retainPrefix));
	}
	
	@Override
	public IPv4Address bitwiseOr(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return bitwiseOr(mask, false);
	}
	
	@Override
	public IPv4Address bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOrNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv4Address getHostMask() {
		return (IPv4Address) super.getHostMask();
	}
	@Override
	public IPv4Address getNetworkMask() {
		return (IPv4Address) super.getNetworkMask();
	}
	@Override
	public IPv4AddressSection getNetworkSection() {
		return getSection().getNetworkSection();
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength);
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength, withPrefixLength);
	}
	@Override
	public IPv4AddressSection getHostSection() {
		return getSection().getHostSection();
	}
	@Override
	public IPv4AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getHostSection(networkPrefixLength);
	}
	@Override
	public IPv4Address toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv4Address toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().toPrefixBlock(networkPrefixLength));
	}
	@Override
	public IPv4Address assignPrefixForSingleBlock() {
		return (IPv4Address) super.assignPrefixForSingleBlock();
	}
	
	@Override
	public IPv4Address assignMinPrefixForBlock() {
		return (IPv4Address) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv4Address coverWithPrefixBlock() {
		return (IPv4Address) IPv4AddressSection.coverWithPrefixBlock(this, getLower(), getUpper());
	}
	@Override
	public IPv4Address coverWithPrefixBlock(IPAddress other) throws AddressConversionException {
		return IPv4AddressSection.coverWithPrefixBlock(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	/**
	 * Produces an array of prefix blocks that cover the same set of addresses as this.
	 * <p>
	 * Unlike {@link #spanWithPrefixBlocks(IPAddress)} this method only includes addresses that are a part of this subnet.
	 */
	@Override
	public IPv4Address[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv4Address[] {this};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4Address> list = (ArrayList<IPv4Address>) spanWithBlocks(true);
		return list.toArray(new IPv4Address[list.size()]);
	}
	
	@Override
	public IPv4Address[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningPrefixBlocks(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4Address::assignPrefixForSingleBlock,
				IPv4Address::withoutPrefixLength,
				getAddressCreator()::createAddressArray);
	}
	
	/**
	 * Produces an array of blocks that are sequential that cover the same set of addresses as this.
	 * <p>
	 * This array can be shorter than that produced by {@link #spanWithPrefixBlocks()} and is never longer.
	 * <p>
	 * Unlike {@link #spanWithSequentialBlocks(IPAddress)} this method only includes addresses that are a part of this subnet.
	 */
	@Override
	public IPv4Address[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv4Address[] { withoutPrefixLength() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4Address> list = (ArrayList<IPv4Address>) spanWithBlocks(false);
		return list.toArray(new IPv4Address[list.size()]);
	}
	
	@Override
	public IPv4Address[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningSequentialBlocks(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4Address::withoutPrefixLength,
				getAddressCreator());
	}
	
	@Override
	public IPv4AddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException {
		return toSequentialRange(other);
	}
	@Override
	public IPv4Address[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSinglePrefixBlock()) {
				return new IPv4Address[] {this};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv4Address[blocks.size()]);
	}
	
	private IPAddress[] getConverted(IPAddress... addresses) {
		IPAddress converted[] = new IPAddress[addresses.length + 1];
		for(int i = 0, j = 1; i < addresses.length; i = j++) {
			converted[j] = convertArg(addresses[i]);
		}
		converted[0] = this;
		return converted;
	}
	
	@Override
	public IPv4Address[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSequential()) {
				return new IPv4Address[] {this};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getAddressCreator());
		return blocks.toArray(new IPv4Address[blocks.size()]);
	}
	@Override
	protected SeriesCreator getSequentialSeriesCreator() {
		return getAddressCreator()::createSequentialBlockAddress;
	}
	@Override
	public Inet4Address toUpperInetAddress() {
		return (Inet4Address) super.toUpperInetAddress();
	}
	
	@Override
	public Inet4Address toInetAddress() {
		return (Inet4Address) super.toInetAddress();
	}
	
	@Override
	@Deprecated
	public IPv4AddressSeqRange toSequentialRange(IPAddress other) {
		return new IPv4AddressSeqRange(this, convertArg(other));
	}
	
	@Override
	public IPv4AddressSeqRange toSequentialRange() {
		IPv4Address thiz = withoutPrefixLength();
		return new IPv4AddressSeqRange(thiz.getLower(), thiz.getUpper(), true);
	}
	@Override
	public boolean isLocal() {
		if(isMulticast()) {
			//1110...
			IPv4AddressSegment seg0 = getSegment(0);
			//http://www.tcpipguide.com/free/t_IPMulticastAddressing.htm
			//rfc4607 and https://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml
			
			//239.0.0.0-239.255.255.255 organization local
			if(seg0.matches(239)) {
				return true;
			}
			IPv4AddressSegment seg1 = getSegment(1), seg2 = getSegment(2);
			
			return 
					// 224.0.0.0 to 224.0.0.255 local 
					// includes link local multicast name resolution https://tools.ietf.org/html/rfc4795 224.0.0.252
					(seg0.matches(224) && seg1.isZero() && seg2.isZero())
					
					//232.0.0.1 - 232.0.0.255	Reserved for IANA allocation	[RFC4607]			
					//232.0.1.0 - 232.255.255.255	Reserved for local host allocation	[RFC4607]
									
					|| (seg0.matches(232) && !(seg1.isZero() && seg2.isZero()));
		}
		return isLinkLocal() || isPrivate() || isAnyLocal();
	}
	
	/**
	 * @see java.net.InetAddress#isLinkLocalAddress()
	 */
	@Override
	public boolean isLinkLocal() {
		if(isMulticast()) {
			//224.0.0.252	Link-local Multicast Name Resolution	[RFC4795]
			return getSegment(0).matches(224) && getSegment(1).isZero() && getSegment(2).isZero() &&  getSegment(3).matches(252);
		}
		return getSegment(0).matches(169) && getSegment(1).matches(254);
	}
	/**
	 * Unicast addresses allocated for private use
	 * 
	 * @see java.net.InetAddress#isSiteLocalAddress()
	 */
	public boolean isPrivate() {
		// refer to RFC 1918
        // 10/8 prefix
        // 172.16/12 prefix (172.16.0.0 – 172.31.255.255)
        // 192.168/16 prefix
		IPv4AddressSegment seg0 = getSegment(0);
		IPv4AddressSegment seg1 = getSegment(1);
		return seg0.matches(10)
			|| (seg0.matches(172) && seg1.matchesWithPrefixMask(16, 4))
			|| (seg0.matches(192) && seg1.matches(168));
	}
	
	@Override
	public boolean isMulticast() {
		// 1110...
		//224.0.0.0/4
		return getSegment(0).matchesWithPrefixMask(0xe0, 4);
	}
	
	/**
	 * @see java.net.InetAddress#isLoopbackAddress()
	 */
	@Override
	public boolean isLoopback() {
		return getSegment(0).matches(127);
	}
	
	/**
	 * @custom.core
	 * @author sfoley
	 *
	 */
	public interface IPv4AddressConverter {
		/**
		 * If the given address is IPv4, or can be converted to IPv4, returns that {@link IPv4Address}.  Otherwise, returns null.
		 */
		IPv4Address toIPv4(IPAddress address);
	}
	
	////////////////string creation below ///////////////////////////////////////////////////////////////////////////////////////////
	@Override
	protected IPAddressStringParameters createFromStringParams() {
		return new IPAddressStringParameters.Builder().
				getIPv4AddressParametersBuilder().setNetwork(getNetwork()).getParentBuilder().
				getIPv6AddressParametersBuilder().setNetwork(getIPv6Network()).getParentBuilder().toParams();
	}
	
	/**
	 * Creates the normalized string for an address without having to create the address objects first.
	 * 
	 * @param lowerValueProvider
	 * @param upperValueProvider
	 * @param prefixLength
	 * @param network use {@link #defaultIpv4Network()} if there is no custom network in use
	 * @return
	 */
	public static String toNormalizedString(IPv4AddressNetwork network, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
		return toNormalizedString(network.getPrefixConfiguration(), lowerValueProvider, upperValueProvider, prefixLength, SEGMENT_COUNT, BYTES_PER_SEGMENT, BITS_PER_SEGMENT, MAX_VALUE_PER_SEGMENT, SEGMENT_SEPARATOR, DEFAULT_TEXTUAL_RADIX, null);
	}
	/**
	 * @author sfoley
	 *
	 */
	public static enum inet_aton_radix {
		OCTAL, HEX, DECIMAL;
		
		int getRadix() {
			if(this == OCTAL) {
				return 8;
			} else if(this == HEX) {
				return 16;
			}
			return 10;
		}
		
		String getSegmentStrPrefix() {
			if(this == OCTAL) {
				return "0";
			} else if(this == HEX) {
				return "0x";
			}
			return null;
		}
		
		@Override
		public String toString() {
			if(this == OCTAL) {
				return "octal";
			} else if(this == HEX) {
				return "hexadecimal";
			}
			return "decimal";
		}
	}
	/**
	 * Returns a string like the inet_aton style string
	 * @return
	 */
	public String toInetAtonString(IPv4Address.inet_aton_radix radix) {
		return getSection().toInetAtonString(radix);
	}
	
	public String toInetAtonString(IPv4Address.inet_aton_radix radix, int joinedCount) throws IncompatibleAddressException {
		return getSection().toInetAtonString(radix, joinedCount);
	}
	
	@Override
	public String toSegmentedBinaryString() {
		return getSection().toSegmentedBinaryString();
	}
	
	@Override
	public String toUNCHostName() {
		return super.toCanonicalString();
	}
	
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.ALL_OPTS);
	}
	
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv4StringBuilderOptions.from(opts));
	}
	
	private IPv6Address getConverted(IPv4StringBuilderOptions opts) {
		if(opts.includes(IPv4StringBuilderOptions.IPV6_CONVERSIONS)) {
			IPv6AddressConverter converter = opts.converter;
			return converter.toIPv6(this);
		}
		return null;
	}
	
	public IPAddressPartStringCollection toStringCollection(IPv4StringBuilderOptions opts) {
		IPv4StringCollection coll = new IPv4StringCollection();
		IPAddressPartStringCollection sectionColl = getSection().toStringCollection(opts);
		coll.addAll(sectionColl);
		IPv6Address ipv6Addr = getConverted(opts);
		if(ipv6Addr != null) {
			IPAddressPartStringCollection ipv6StringCollection = ipv6Addr.toStringCollection(opts.ipv6ConverterOptions);
			coll.addAll(ipv6StringCollection);
		}
		return coll;
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.math.BigInteger;
import java.net.InetAddress;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.TreeMap;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import inet.ipaddr.AddressComparator.ValueComparator;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.WildcardOptions.WildcardOption;
import inet.ipaddr.IPAddressSeqRange.IPAddressSeqRangeSplitterSink;
import inet.ipaddr.format.AddressComponentRange;
import inet.ipaddr.format.AddressDivisionSeries;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.standard.IPAddressBitsDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartConfiguredString;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.sql.IPAddressSQLTranslator;
import inet.ipaddr.format.util.sql.MySQLTranslator;
import inet.ipaddr.format.util.sql.SQLStringMatcher;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.format.validate.ParsedIPAddress.BitwiseOrer;
import inet.ipaddr.format.validate.ParsedIPAddress.Masker;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressSegment;
/**
 * A section of an IPAddress. 
 * 
 * It is a series of individual address segments.
 * <p>
 * IPAddressSection objects are immutable.  Some of the derived state is created upon demand and cached.
 * 
 * This also makes them thread-safe.
 * 
 * Almost all operations that can be performed on IPAddress objects can also be performed on IPAddressSection objects and vice-versa.
 * 
 */
public abstract class IPAddressSection extends IPAddressDivisionGrouping implements IPAddressSegmentSeries, AddressSection {
	
	private static final long serialVersionUID = 4L;
	private static final IPAddressStringDivisionSeries EMPTY_PARTS[] = new IPAddressStringDivisionSeries[0];
	
	/* caches objects to avoid recomputing them */
	protected static class PrefixCache {
		/* for caching */
		private Integer networkMaskPrefixLen; //null indicates this field not initialized, -1 indicates the prefix len is null
		private Integer hostMaskPrefixLen; //null indicates this field not initialized, -1 indicates the prefix len is null
		
		/* also for caching */
		private Integer cachedMinPrefix; //null indicates this field not initialized
		private Integer cachedEquivalentPrefix; //null indicates this field not initialized, -1 indicates the prefix len is null
		private Boolean cachedIsSinglePrefixBlock; //null indicates this field not initialized
	}
	
	private transient PrefixCache prefixCache;
	private transient BigInteger cachedNonzeroHostCount;
	
	protected IPAddressSection(IPAddressSegment segments[], boolean cloneSegments, boolean checkSegs) {
		super(cloneSegments ? segments.clone() : segments, false);
		if(checkSegs) {// the segment array is populated, so we need to check the prefixes within to get the prefix length
			// we also must check the network does not change across segments
			IPAddressNetwork<?, ?, ?, ?, ?> network = getNetwork();
			Integer previousSegmentPrefix = null;
			int bitsPerSegment = getBitsPerSegment();
			for(int i = 0; i < segments.length; i++) {
				IPAddressSegment segment = segments[i];
				if(!network.isCompatible(segment.getNetwork())) {
					throw new NetworkMismatchException(segment);
				}
				/**
				 * Across an address prefixes are:
				 * IPv6: (null):...:(null):(1 to 16):(0):...:(0)
				 * or IPv4: ...(null).(1 to 8).(0)...
				 */
				Integer segPrefix = segment.getSegmentPrefixLength();
				if(previousSegmentPrefix == null) {
					if(segPrefix != null) {
						cachedPrefixLength = cacheBits(getNetworkPrefixLength(bitsPerSegment, segPrefix, i));
					}
				} else if(segPrefix == null || segPrefix != 0) {
					throw new InconsistentPrefixException(segments[i - 1], segment, segPrefix);
				}
				previousSegmentPrefix = segPrefix;
			}
			if(previousSegmentPrefix == null) {
				cachedPrefixLength = NO_PREFIX_LENGTH;
			}
		}
	}
	
	protected void checkSegments(IPv6AddressSegment segs[]) {
		IPAddressNetwork<?, ?, ?, ?, ?> network = getNetwork();
		for(IPAddressSegment seg : segs) {
			if(!network.isCompatible(seg.getNetwork())) {
				throw new NetworkMismatchException(seg);
			}
		}
	}
	protected static String getMessage(String key) {
		return HostIdentifierException.getMessage(key);
	}
	
	protected void initCachedValues(
			Integer prefixLen,
			boolean network,
			Integer cachedNetworkPrefix,
			Integer cachedMinPrefix,
			Integer cachedEquivalentPrefix,
			BigInteger cachedCount,
			RangeList zeroSegments,
			RangeList zeroRanges) {
		if(prefixCache == null) {
			prefixCache = new PrefixCache();
		}
		if(network) {
			setNetworkMaskPrefix(prefixLen);
		} else {
			setHostMaskPrefix(prefixLen);
		}
		super.initCachedValues(cachedNetworkPrefix, cachedCount);
		prefixCache.cachedMinPrefix = cachedMinPrefix;
		prefixCache.cachedIsSinglePrefixBlock = Objects.equals(cachedEquivalentPrefix, cachedNetworkPrefix);
		prefixCache.cachedEquivalentPrefix = cachedEquivalentPrefix;
	}
	
	@Override
	public boolean isSinglePrefixBlock() {
		if(!hasNoPrefixCache() && prefixCache.cachedIsSinglePrefixBlock != null) {
			return prefixCache.cachedIsSinglePrefixBlock;
		}
		boolean result = super.isSinglePrefixBlock();
		prefixCache.cachedIsSinglePrefixBlock = result;
		if(result) {
			prefixCache.cachedEquivalentPrefix = getNetworkPrefixLength();
		}
		return result;
	}
	
	protected static RangeList getNoZerosRange() {
		return IPAddressDivisionGrouping.getNoZerosRange();
	}
	
	protected static RangeList getSingleRange(int index, int len) {
		return IPAddressDivisionGrouping.getSingleRange(index, len);
	}
	
	protected static boolean isCompatibleNetworks(AddressNetwork<?> one, AddressNetwork<?> two) {
		return AddressDivisionGrouping.isCompatibleNetworks(one, two);
	}
	@Override
	public int getBitCount() {
		return getSegmentCount() * getBitsPerSegment();
	}
	@Override
	public int getByteCount() {
		return getSegmentCount() * getBytesPerSegment();
	}
	@Override
	protected byte[] getBytesInternal() {
		return super.getBytesInternal();
	}
	public static int bitsPerSegment(IPVersion version) {
		return IPAddressSegment.getBitCount(version);
	}
	public static int bytesPerSegment(IPVersion version) {
		return IPAddressSegment.getBitCount(version);
	}
	protected long longCount(int segCount) {
		if(isMultiple()) {
			return longCount(this, segCount);
		}
		return 1L;
	}
	protected long longPrefixCount(int prefixLength) {
		if(isMultiple()) {
			return longPrefixCount(this, prefixLength);
		}
		return 1;
	}
	protected long longZeroHostCount(int prefixLength, int segCount) {
		if(includesZeroHost(prefixLength)) {
			if(isMultiple()) {
				int bitsPerSegment = getBitsPerSegment();
				int prefixedSegment = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), bitsPerSegment);
				long zeroHostCount = getLongCount(i -> {
					if(i == prefixedSegment) {
						IPAddressSegment seg = getSegment(i);
						int shift = seg.getBitCount() - getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
						int count = ((seg.getUpperSegmentValue() >>> shift) - (seg.getSegmentValue() >>> shift)) + 1;
						return count;
					}
					return getSegment(i).getValueCount();
				}, prefixedSegment + 1);
				return zeroHostCount;
			} else {
				return 1L;
			}
		}
		return 0L;
	}
	protected abstract BigInteger getZeroHostCountImpl(int prefixLength, int segCount);
	@Override
	public BigInteger getNonZeroHostCount() {
		if(isPrefixed() && getNetworkPrefixLength() < getBitCount()) {
			BigInteger cached = cachedNonzeroHostCount;
			if(cached == null) {
				cachedNonzeroHostCount = cached = getCount().subtract(getZeroHostCountImpl(getNetworkPrefixLength(), getSegmentCount()));
			}
			return cached;
		}
		return getCount();
	}
	protected abstract BigInteger getCountImpl(int segCount);
	@Override
	public BigInteger getCountImpl() {
		return getCountImpl(getSegmentCount());
	}
	@Override
	public BigInteger getBlockCount(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		int segCount = getSegmentCount();
		if(segmentCount > segCount) {
			segmentCount = segCount;
		}
		return getCountImpl(segmentCount);
	}
	public boolean isIPv4() {
		return false;
	}
	
	public boolean isIPv6() {
		return false;
	}
	
	@Override
	public int getMaxSegmentValue() {
		return IPAddressSegment.getMaxSegmentValue(getIPVersion());
	}
	/*
	 * Starting from the first host bit according to the prefix, if the section is a sequence of zeros in both low and high values, 
	 * followed by a sequence where low values are zero and high values are 1, then the section is a subnet prefix.
	 * 
	 * Note that this includes sections where hosts are all zeros, or sections where hosts are full range of values, 
	 * so the sequence of zeros can be empty and the sequence of where low values are zero and high values are 1 can be empty as well.
	 * However, if they are both empty, then this returns false, there must be at least one bit in the sequence.
	 */
	//For explicit prefix config this always returns false.  For all prefix subnets config this always returns true if the prefix length does not extend beyond the address end
	protected static boolean isPrefixSubnetSegs(IPAddressSegment sectionSegments[], Integer networkPrefixLength, IPAddressNetwork<?, ?, ?, ?, ?> network, boolean fullRangeOnly) {
		int segmentCount = sectionSegments.length;
		if(segmentCount == 0) {
			return false;
		}
		IPAddressSegment seg = sectionSegments[0];
		return ParsedAddressGrouping.isPrefixSubnet(
				segmentIndex -> sectionSegments[segmentIndex].getSegmentValue(),
				segmentIndex -> sectionSegments[segmentIndex].getUpperSegmentValue(),
				segmentCount,
				seg.getByteCount(),
				seg.getBitCount(),
				seg.getMaxSegmentValue(),
				networkPrefixLength,
				network.getPrefixConfiguration(),
				fullRangeOnly);
	}
	
	//this method is basically checking whether we can return "this" for getNetworkSection
	protected boolean isNetworkSection(int networkPrefixLength, boolean withPrefixLength) {
		int segmentCount = getSegmentCount();
		if(segmentCount == 0) {
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int prefixedSegmentIndex = getNetworkSegmentIndex(networkPrefixLength, getBytesPerSegment(), bitsPerSegment);
		if(prefixedSegmentIndex + 1 < segmentCount) {
			return false; //not the right number of segments
		}
		//the segment count matches, now compare the prefixed segment
		int segPrefLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, prefixedSegmentIndex);// prefixedSegmentIndex of -1 already handled
		return !getSegment(segmentCount - 1).isNetworkChangedByPrefix(cacheBits(segPrefLength), withPrefixLength);
	}
	
	protected boolean isHostSection(int networkPrefixLength) {
		int segmentCount = getSegmentCount();
		if(segmentCount == 0) {
			return true;
		}
		if(networkPrefixLength >= getBitsPerSegment()) {
			return false;
		}
		return !getSegment(0).isHostChangedByPrefix(cacheBits(networkPrefixLength));
	}
	
	protected static int getNetworkSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getNetworkSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	
	protected static int getHostSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	
	private Integer checkForPrefixMask(boolean network) {
		int count = getSegmentCount();
		if(count == 0) {
			return null;
		}
		int front, back;
		int maxval = getSegment(0).getMaxSegmentValue();
		if(network) {
			front = maxval;
			back = 0;
		} else {
			back = maxval;
			front = 0;
		}
		int prefixLen = 0;
		for(int i=0; i < count; i++) {
			IPAddressSegment seg = getSegment(i);
			int value = seg.getSegmentValue();
			if(value != front) {
				Integer segmentPrefixLen = seg.getBlockMaskPrefixLength(network);
				if(segmentPrefixLen == null) {
					return null;
				}
				prefixLen += segmentPrefixLen;
				for(i++; i < count; i++) {
					value = getSegment(i).getSegmentValue();
					if(value != back) {
						return null;
					}
				}
			} else {
				prefixLen += seg.getBitCount();
			}
		}
		//note that when segments.length == 0, we return 0 as well, since both the host mask and prefix mask are empty (length of 0 bits)
		return cacheBits(prefixLen);
	}
	
	/**
	 * If this address section is equivalent to the mask for a CIDR prefix block, it returns that prefix length.
	 * Otherwise, it returns null.
	 * A CIDR network mask is an address with all 1s in the network section and then all 0s in the host section.
	 * A CIDR host mask is an address with all 0s in the network section and then all 1s in the host section.
	 * The prefix length is the length of the network section.
	 * 
	 * Also, keep in mind that the prefix length returned by this method is not equivalent to the prefix length used to construct this object.
	 * The prefix length used to construct indicates the network and host section of this address.  
	 * The prefix length returned here indicates the whether the value of this address can be used as a mask for the network and host
	 * section of any other address.  Therefore the two values can be different values, or one can be null while the other is not.
	 * 
	 * This method applies only to the lower value of the range if this section represents multiple values.
	 * 
	 * @param network whether to check for a network mask or a host mask
	 * @return the prefix length corresponding to this mask, or null if there is no such prefix length
	 */
	public Integer getBlockMaskPrefixLength(boolean network) {
		Integer prefixLen;
		if(network) {
			if(hasNoPrefixCache() || (prefixLen = prefixCache.networkMaskPrefixLen) == null) {
				prefixLen = setNetworkMaskPrefix(checkForPrefixMask(network));
			}
		} else {
			if(hasNoPrefixCache() || (prefixLen = prefixCache.hostMaskPrefixLen) == null) {
				prefixLen = setHostMaskPrefix(checkForPrefixMask(network));
			}
		}
		if(prefixLen < 0) {
			return null;
		}
		return prefixLen;
	}
	
	private Integer setHostMaskPrefix(Integer prefixLen) {
		if(prefixLen == null) {
			prefixLen = prefixCache.hostMaskPrefixLen = NO_PREFIX_LENGTH;
		} else {
			prefixCache.hostMaskPrefixLen = prefixLen;
			prefixCache.networkMaskPrefixLen = NO_PREFIX_LENGTH; //cannot be both network and host mask
		}
		return prefixLen;
	}
	
	private Integer setNetworkMaskPrefix(Integer prefixLen) {
		if(prefixLen == null) {
			prefixLen = prefixCache.networkMaskPrefixLen = NO_PREFIX_LENGTH;
		} else {
			prefixCache.networkMaskPrefixLen = prefixLen;
			prefixCache.hostMaskPrefixLen = NO_PREFIX_LENGTH; //cannot be both network and host mask
		}
		return prefixLen;
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment>
			R getNetworkSection(
					R original,
					int networkPrefixLength,
					boolean withPrefixLength,
					IPAddressCreator<T, R, ?, S, ?> creator,
					SegFunction<Integer, S> segProducer) {
		if(networkPrefixLength < 0 || networkPrefixLength > original.getBitCount()) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		if(original.isNetworkSection(networkPrefixLength, withPrefixLength)) {
			return original;
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int networkSegmentCount = original.getNetworkSegmentCount(networkPrefixLength);
		S result[] = creator.createSegmentArray(networkSegmentCount);
		for(int i = 0; i < networkSegmentCount; i++) {
			Integer prefix = getSegmentPrefixLength(bitsPerSegment, cacheBits(networkPrefixLength), i);
			result[i] = segProducer.apply(prefix, i);
		}
		return creator.createSectionInternal(result);
	}
	protected int getNetworkSegmentCount(int networkPrefixLength) {
		return getNetworkSegmentIndex(networkPrefixLength, getBytesPerSegment(), getBitsPerSegment()) + 1;
	}
	
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> 
			R getHostSection(
					R original,
					int networkPrefixLength,
					int hostSegmentCount,
					IPAddressCreator<T, R, ?, S, ?> creator,
					SegFunction<Integer, S> segProducer) {
		if(networkPrefixLength < 0 || networkPrefixLength > original.getBitCount()) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		if(original.isHostSection(networkPrefixLength)) {
			return original;
		}
		int segmentCount = original.getSegmentCount();
		S result[] = creator.createSegmentArray(hostSegmentCount);
		if(hostSegmentCount > 0) {
			int bitsPerSegment = original.getBitsPerSegment();
			for(int i = hostSegmentCount - 1, j = segmentCount - 1; i >= 0; i--, j--) {
				Integer prefix = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, j);
				result[i] = segProducer.apply(prefix, j);
			}
		}
		return creator.createSectionInternal(result);
	}
	
	protected int getHostSegmentCount(int networkPrefixLength) {
		return getSegmentCount() - getHostSegmentIndex(networkPrefixLength, getBytesPerSegment(), getBitsPerSegment());
	}
	
	protected static Integer cacheBits(int i) {
		return AddressDivisionGrouping.cacheBits(i);
	}
	@FunctionalInterface
	public interface SegFunction<R, S> {
	    S apply(R addrItem, int value);
	}
	
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R setPrefixLength(
			R original,
			IPAddressCreator<?, R, ?, S, ?> creator,
			int networkPrefixLength,
			boolean withZeros,
			boolean noShrink,
			boolean singleOnly,
			SegFunction<R, S> segProducer) throws IncompatibleAddressException {
		Integer existingPrefixLength = original.getNetworkPrefixLength();
		if(existingPrefixLength != null) {
			if(networkPrefixLength == existingPrefixLength.intValue()) {
				return original;
			} else if(noShrink && networkPrefixLength > existingPrefixLength.intValue()) {
				checkSubnet(original, networkPrefixLength);
				return original;
			}
		}
		checkSubnet(original, networkPrefixLength);
		IPAddressNetwork<?, R, ?, S, ?> network = creator.getNetwork();
		int maskBits;
		IntUnaryOperator segmentMaskProducer = null;
		if(network.getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			if(existingPrefixLength != null) {
				if(networkPrefixLength > existingPrefixLength.intValue()) {
					if(withZeros) {
						maskBits = existingPrefixLength;
					} else {
						maskBits = networkPrefixLength;
					}
				} else { // networkPrefixLength < existingPrefixLength.intValue()
					maskBits = networkPrefixLength;
				} 
			} else {
				maskBits = networkPrefixLength;
			}
		} else {
			if(existingPrefixLength != null) {
				if(withZeros) {
					R leftMask, rightMask;
					if(networkPrefixLength > existingPrefixLength.intValue()) {
						leftMask = network.getNetworkMaskSection(existingPrefixLength);
						rightMask = network.getHostMaskSection(networkPrefixLength);
					} else {
						leftMask = network.getNetworkMaskSection(networkPrefixLength);
						rightMask = network.getHostMaskSection(existingPrefixLength);
					}
					segmentMaskProducer = i -> {
						int val1 = segProducer.apply(leftMask, i).getSegmentValue();
						int val2 = segProducer.apply(rightMask, i).getSegmentValue();
						return val1 | val2;
					};
				}
			}
			maskBits = original.getBitCount();
		}
		if(segmentMaskProducer == null) {
			R mask = network.getNetworkMaskSection(maskBits);
			segmentMaskProducer = i -> segProducer.apply(mask, i).getSegmentValue();
		}
		return getSubnetSegments(
				original,
				cacheBits(networkPrefixLength),
				creator,
				true,
				i -> segProducer.apply(original, i),
				segmentMaskProducer,
				singleOnly);
	}
	
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R getSubnetSegments(
			R original,
			Integer networkPrefixLength,
			IPAddressCreator<?, R, ?, S, ?> creator,
			boolean verifyMask,
			IntFunction<S> segProducer,
			IntUnaryOperator segmentMaskProducer,
			boolean singleOnly) {
		if(networkPrefixLength != null && (networkPrefixLength < 0 || networkPrefixLength > original.getBitCount())) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int count = original.getSegmentCount();
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && !singleOnly;
		for(int i = 0; i < count; i++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			S seg = segProducer.apply(i);
			//note that the mask can represent a range (for example a CIDR mask), 
			//but we use the lowest value (maskSegment.value) in the range when masking (ie we discard the range)
			int maskValue = segmentMaskProducer.applyAsInt(i);
			
			int value = seg.getSegmentValue(), upperValue = seg.getUpperSegmentValue();
			if(verifyMask) {
				if(isAllSubnets && segmentPrefixLength != null) {
					int hostMask = seg.getSegmentHostMask(segmentPrefixLength);
					maskValue |= hostMask;
				}
				Masker masker = IPAddressSegment.maskRange(value, upperValue, maskValue, seg.getMaxValue());
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
				}
				value = (int) masker.getMaskedLower(value, maskValue);
				upperValue = (int) masker.getMaskedUpper(upperValue, maskValue);
			} else {
				value &= maskValue;
				upperValue &= maskValue;
			}
			
			if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
				S newSegments[] = creator.createSegmentArray(original.getSegmentCount());
				original.getSegments(0, i, newSegments, 0);
				newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
				if(isAllSubnets && segmentPrefixLength != null) {
					if(++i < count) {
						S zeroSeg = creator.createSegment(0, cacheBits(0));
						Arrays.fill(newSegments, i, count, zeroSeg);
					}
				} else for(i++; i < count; i++) {
					segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
					seg  = segProducer.apply(i);
					maskValue = segmentMaskProducer.applyAsInt(i);
					value = seg.getSegmentValue();
					upperValue = seg.getUpperSegmentValue();
					if(verifyMask) {
						if(isAllSubnets && segmentPrefixLength != null) {
							int hostMask = seg.getSegmentHostMask(segmentPrefixLength);
							maskValue |= hostMask;
						}
						Masker masker = IPAddressSegment.maskRange(value, upperValue, maskValue, seg.getMaxValue());
						if(!masker.isSequential()) {
							throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
						}
						value = (int) masker.getMaskedLower(value, maskValue);
						upperValue = (int) masker.getMaskedUpper(upperValue, maskValue);
					} else {
						value &= maskValue;
						upperValue &= maskValue;
					}
					if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
						newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
					} else {
						newSegments[i] = seg;
					}
					if(isAllSubnets && segmentPrefixLength != null) {
						if(++i < count) {
							S zeroSeg = creator.createSegment(0, cacheBits(0));
							Arrays.fill(newSegments, i, count, zeroSeg);
						}
						break;
					}
				}
				return creator.createPrefixedSectionInternal(newSegments, networkPrefixLength, singleOnly);
			}
		}
		return original;
	}
	
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R getOredSegments(
			R original,
			Integer networkPrefixLength,
			IPAddressCreator<?, R, ?, S, ?> creator,
			boolean verifyMask,
			IntFunction<S> segProducer,
			IntUnaryOperator segmentMaskProducer) {
		if(networkPrefixLength != null && (networkPrefixLength < 0 || networkPrefixLength > original.getBitCount())) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int count = original.getSegmentCount();
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		for(int i = 0; i < count; i++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			S seg = segProducer.apply(i);
			int maskValue = segmentMaskProducer.applyAsInt(i);
			int value = seg.getSegmentValue(), upperValue = seg.getUpperSegmentValue();
			if(verifyMask) {
				if(isAllSubnets && segmentPrefixLength != null) {
					int networkMask = seg.getSegmentNetworkMask(segmentPrefixLength);
					maskValue &= networkMask;
				}
				BitwiseOrer masker = IPAddressSegment.bitwiseOrRange(value, upperValue, maskValue, seg.getMaxValue());
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
				}
				value = (int) masker.getOredLower(value, maskValue);
				upperValue = (int) masker.getOredUpper(upperValue, maskValue);
			} else {
				value |= maskValue;
				upperValue |= maskValue;
			}
			if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
				S newSegments[] = creator.createSegmentArray(original.getSegmentCount());
				original.getSegments(0, i, newSegments, 0);
				newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
				if(isAllSubnets && segmentPrefixLength != null) {
					if(++i < count) {
						S zeroSeg = creator.createSegment(0, cacheBits(0));
						Arrays.fill(newSegments, i, count, zeroSeg);
					}
				} else for(i++; i < count; i++) {
					segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
					seg  = segProducer.apply(i);
					maskValue = segmentMaskProducer.applyAsInt(i);
					value = seg.getSegmentValue();
					upperValue = seg.getUpperSegmentValue();
					if(verifyMask) {
						if(isAllSubnets && segmentPrefixLength != null) {
							int networkMask = seg.getSegmentNetworkMask(segmentPrefixLength);
							maskValue &= networkMask;
						}
						BitwiseOrer masker = IPAddressSegment.bitwiseOrRange(value, upperValue, maskValue, seg.getMaxValue());
						if(!masker.isSequential()) {
							throw new IncompatibleAddressException(seg, "ipaddress.error.maskMismatch");
						}
						value = (int) masker.getOredLower(value, maskValue);
						upperValue = (int) masker.getOredUpper(upperValue, maskValue);
					} else {
						value |= maskValue;
						upperValue |= maskValue;
					}
					if(seg.isChangedBy(value, upperValue, segmentPrefixLength)) {
						newSegments[i] = creator.createSegment(value, upperValue, segmentPrefixLength);
					} else {
						newSegments[i] = seg;
					}
					if(isAllSubnets && segmentPrefixLength != null) {
						if(++i < count) {
							S zeroSeg = creator.createSegment(0, cacheBits(0));
							Arrays.fill(newSegments, i, count, zeroSeg);
						}
						break;
					}
				}
				return creator.createPrefixedSectionInternal(newSegments, networkPrefixLength);
			}
		}
		return original;
	}
	protected static void checkSubnet(AddressDivisionSeries series, int prefixLength) throws PrefixLenException {
		AddressDivisionGrouping.checkSubnet(series, prefixLength);
	}
	
	protected static Integer getSegmentPrefixLength(int bitsPerSegment, Integer prefixLength, int segmentIndex) {
		return AddressDivisionGrouping.getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected static Integer getSegmentPrefixLength(int bitsPerSegment, int segmentPrefixedBits) {
		return AddressDivisionGrouping.getSegmentPrefixLength(bitsPerSegment, segmentPrefixedBits);
	}
	
	protected static Integer getPrefixedSegmentPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		return AddressDivisionGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R createLowestOrHighestSection(
			R section,
			IPAddressCreator<?, R, ?, S, ?> creator,
			Supplier<Iterator<S[]>> nonZeroHostIteratorSupplier,
			IntFunction<S> segProducer,
			boolean lowest,
			boolean excludeZeroHost) {
		boolean create = true;
		R result = null;
		S[] segs = null;
		if(lowest && excludeZeroHost && section.includesZeroHost()) {
			Iterator<S[]> it = nonZeroHostIteratorSupplier.get();
			if(!it.hasNext()) {
				create = false;
			} else {
				segs = it.next();
			}
		} else {
			segs = createSingle(section, creator, segProducer);
		}
		if(create) {
			Integer prefLength;
			result = section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() || (prefLength = section.getNetworkPrefixLength()) == null ? 
				creator.createSectionInternal(segs) :
				creator.createPrefixedSectionInternal(segs, prefLength, true);
		}
		return result;
	}
	@Override
	public int getSegmentCount() {
		return getDivisionCount();
	}
	@Override
	public IPAddressSegment getSegment(int index) {
		return getSegmentsInternal()[index];
	}
	@Override
	public IPAddressSegment getDivision(int index) {
		return getSegmentsInternal()[index];
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		checkSubnet(this, prefixLength);
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(isAllSubnets && isPrefixed() && getNetworkPrefixLength() <= prefixLength) {
			return true;
		}
		int divCount = getDivisionCount();
		int bitsPerSegment = getBitsPerSegment();
		int i = getHostSegmentIndex(prefixLength, getBytesPerSegment(), bitsPerSegment);
		if(i < divCount) {
			IPAddressSegment div = getDivision(i);
			int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
			if(!div.containsPrefixBlock(segmentPrefixLength)) {
				return false;
			}
			if(isAllSubnets && div.isPrefixed()) {
				return true;
			}
			for(++i; i < divCount; i++) {
				div = getDivision(i);
				if(!div.isFullRange()) {
					return false;
				}
				if(isAllSubnets && div.isPrefixed()) {
					return true;
				}
			}
		}
		return true;
	}
	static boolean containsPrefixBlock(int prefixLength, IPAddressSegmentSeries lower, IPAddressSegmentSeries upper) {
		checkSubnet(lower, prefixLength);
		int divCount = lower.getDivisionCount();
		int bitsPerSegment = lower.getBitsPerSegment();
		int i = getHostSegmentIndex(prefixLength, lower.getBytesPerSegment(), bitsPerSegment);
		if(i < divCount) {
			IPAddressSegment div = lower.getSegment(i);
			IPAddressSegment upperDiv = upper.getSegment(i);
			int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
			if(!div.containsPrefixBlock(div.getSegmentValue(), upperDiv.getSegmentValue(), segmentPrefixLength)) {
				return false;
			}
			for(++i; i < divCount; i++) {
				div = lower.getSegment(i);
				upperDiv = upper.getSegment(i);
				//is full range?
				if(!div.includesZero() || !upperDiv.includesMax()) {
					return false;
				}
			}
		}
		return true;
	}
	
	static boolean containsSinglePrefixBlock(int prefixLength, IPAddressSegmentSeries lower, IPAddressSegmentSeries upper) {
		checkSubnet(lower, prefixLength);
		int prevBitCount = 0;
		int divCount = lower.getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressSegment div = lower.getSegment(i);
			IPAddressSegment upperDiv = upper.getSegment(i);
			int bitCount = div.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength >= totalBitCount) {
				if(!div.isSameValues(upperDiv)) {
					return false;
				}
			} else  {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!div.containsSinglePrefixBlock(div.getSegmentValue(), upperDiv.getSegmentValue(), divPrefixLen)) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = lower.getSegment(i);
					upperDiv = upper.getSegment(i);
					if(!div.includesZero() || !upperDiv.includesMax()) {
						return false;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	/**
	 * @param other
	 * @return whether this subnet contains the given address section
	 */
	@Override
	public boolean contains(AddressSection other) {
		//check if they are comparable first
		int count = getSegmentCount();
		if(count != other.getSegmentCount()) {
			return false;
		}
		boolean prefixIsSubnet = isPrefixed() && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		int endIndex = prefixIsSubnet ? 
				getNetworkSegmentIndex(getNetworkPrefixLength(), getBytesPerSegment(), getBitsPerSegment()) :
					count - 1;
		for(int i = endIndex; i >= 0; i--) {
			IPAddressSegment seg = getSegment(i);
			if(!seg.contains(other.getSegment(i))) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * Returns whether this address contains the non-zero host addresses in other.
	 * @param other
	 * @return
	 */
	public boolean containsNonZeroHosts(IPAddressSection other) {
		if(!other.isPrefixed()) {
			return contains(other);
		}
		int otherPrefixLength = other.getNetworkPrefixLength();
		if(otherPrefixLength  == other.getBitCount()) {
			return contains(other);
		}
		return containsNonZeroHostsImpl(other, otherPrefixLength);
	}
	
	protected abstract boolean containsNonZeroHostsImpl(IPAddressSection other, int otherPrefixLength);
	/**
	 * Returns whether the prefix of this address contains all values of the same bits in the given address or subnet
	 * 
	 * @param other
	 * @return
	 */
	public abstract boolean prefixContains(IPAddressSection other);
	@Override
	public boolean isFullRange() {
		int divCount = getDivisionCount();
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			for(int i = 0; i < divCount; i++) {
				IPAddressSegment div = getSegment(i);
				if(!div.isFullRange()) {
					return false;
				}
				Integer prefix = div.getSegmentPrefixLength();
				if(prefix != null) {
					//any segment that follows is full range
					break;
				}
			}
		} else return super.isFullRange();
		return true;
	}
	
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R intersect(
			R first,
			R other,
			IPAddressCreator<T, R, ?, S, ?> addrCreator,
			IntFunction<S> segProducer,
			IntFunction<S> otherSegProducer) {
		//check if they are comparable first.  We only check segment count, we do not care about start index.
		first.checkSegmentCount(other);
		
		//larger prefix length should prevail?    hmmmmm... I would say that is true, choose the larger prefix
		Integer pref = first.getNetworkPrefixLength();
		Integer otherPref = other.getNetworkPrefixLength();
		if(pref != null) {
			if(otherPref != null) {
				if(otherPref > pref) {
					pref = otherPref;
				}
			} else {
				pref = null;
			}
		}
				
		if(other.contains(first)) {
			if(Objects.equals(pref, first.getNetworkPrefixLength())) {
				return first;
			}
		} else if(!first.isMultiple()) {
			return null;
		}
		if(first.contains(other)) {
			if(Objects.equals(pref, other.getNetworkPrefixLength())) {
				return other;
			}
		} else if(!other.isMultiple()) {
			return null;
		}
		
		int segCount = first.getSegmentCount();
		for(int i = 0; i < segCount; i++) {
			IPAddressSegment seg = first.getSegment(i);
			IPAddressSegment otherSeg = other.getSegment(i);
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			if(otherLower > higher || lower > otherHigher) {
				//no overlap in this segment means no overlap at all
				return null;
			}
		}
		
		S segs[] = addrCreator.createSegmentArray(segCount);
		for(int i = 0; i < segCount; i++) {
			S seg = segProducer.apply(i);
			S otherSeg = otherSegProducer.apply(i);
			Integer segPref = getSegmentPrefixLength(seg.getBitCount(), pref, i);
			if(seg.contains(otherSeg)) {
				if(!otherSeg.isChangedByPrefix(segPref, false)) {
					segs[i] = otherSeg;
					continue;
				}
			}
			if(otherSeg.contains(seg)) {
				if(!seg.isChangedByPrefix(segPref, false)) {
					segs[i] = seg;
					continue;
				}
			}
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			int newLower = Math.max(lower, otherLower);
			int newHigher = Math.min(higher, otherHigher);
			segs[i] = addrCreator.createSegment(newLower, newHigher, segPref);
		}
		R result = addrCreator.createSection(segs);
		return result;
	}
	@FunctionalInterface
	public interface TriFunction<R, S> {
	    S apply(R addrItem, R addrItem2, R addrItem3);
	}
	
	static <R extends IPAddressSegmentSeries, OperatorResult> OperatorResult applyOperatorToLowerUpper(
			R first,
			R other,
			UnaryOperator<R> getLower,
			UnaryOperator<R> getUpper,
			Comparator<R> comparator,
			Function<R, R> prefixRemover,
			TriFunction<R, OperatorResult> operatorFunctor) {
		R lower, upper;
		boolean isFirst, isOther;
		isFirst = isOther = true;
		if(first.equals(other)) {
			if(prefixRemover != null && first.isPrefixed()) {
				if(other.isPrefixed()) {
					lower = prefixRemover.apply(first);
					isOther = isFirst = false;
				} else {
					lower = other;
					isFirst = false;
				}
			} else {
				isOther = false;
				lower = first;
			}
			upper = getUpper.apply(lower);
			lower = getLower.apply(lower);
		} else {
			R firstLower = getLower.apply(first);
			R otherLower = getLower.apply(other);
			R firstUpper = getUpper.apply(first);
			R otherUpper = getUpper.apply(other);
			if(comparator.compare(firstLower, otherLower) > 0) {
				lower = otherLower;
				isFirst = false;
			} else {
				lower = firstLower;
				isOther = false;
			}
			if(comparator.compare(firstUpper, otherUpper) < 0) {
				upper = otherUpper;
				isFirst = false;
			} else {
				upper = firstUpper;
				isOther = false;
			}
			if(prefixRemover != null) {
				lower = prefixRemover.apply(lower);
				upper = prefixRemover.apply(upper);
			}
		}
		return operatorFunctor.apply(isFirst ? first : (isOther ? other : null), lower, upper);
	}
	@SuppressWarnings("unchecked")
	protected static <T extends IPAddressSegmentSeries> T coverWithPrefixBlock(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator) throws AddressConversionException {
		return (T)
				IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, null, 
						IPAddressSection::coverWithPrefixBlock);
	}
	protected static IPAddressSegmentSeries coverWithPrefixBlock(
			IPAddressSegmentSeries original,
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper) {
		int segCount = lower.getSegmentCount();
		int bitsPerSegment = lower.getBitsPerSegment();
		int currentSegment = 0, previousSegmentBits = 0;
		for(; currentSegment < segCount; currentSegment++) {
			IPAddressSegment lowerSeg = lower.getSegment(currentSegment);
			IPAddressSegment upperSeg = upper.getSegment(currentSegment);
			int lowerValue = lowerSeg.getSegmentValue();//these are single addresses, so lower or upper value no different here
			int upperValue = upperSeg.getSegmentValue();
			int differing = lowerValue ^ upperValue;
			if(differing != 0) {
				int highestDifferingBitInRange = Integer.numberOfLeadingZeros(differing) - (Integer.SIZE - bitsPerSegment);
				int differingBitPrefixLen = highestDifferingBitInRange + previousSegmentBits;
				return (original != null ? original : lower).toPrefixBlock(differingBitPrefixLen);
			}
			previousSegmentBits += bitsPerSegment;
		}
		//all bits match, it's just a single address
		return (original != null ? original : lower).toPrefixBlock(lower.getBitCount());
	}
	private static <R extends IPAddressSection> R[] checkSequentialBlockContainment(
			R first,
			R other,
			UnaryOperator<R> prefixRemover,
			IntFunction<R[]> arrayProducer) {
		if(first.contains(other)) {
			return IPAddress.checkSequentialBlockFormat(first, other, true, prefixRemover, arrayProducer);
		} else if(other.contains(first)) {
			return IPAddress.checkSequentialBlockFormat(other, first, false, prefixRemover, arrayProducer);
		}
		return null;
	}
	private static <R extends IPAddressSection> R checkPrefixBlockContainment(
			R first,
			R other,
			UnaryOperator<R> prefixAdder) {
		if(first.contains(other)) {
			return IPAddress.checkPrefixBlockFormat(first, other, true, prefixAdder);
		} else if(other.contains(first)) {
			return IPAddress.checkPrefixBlockFormat(other, first, false, prefixAdder);
		}
		return null;
	}
	/**
	 * Returns the smallest set of prefix blocks that spans both this and the supplied address or subnet.
	 * @param other
	 * @return
	 */
	protected static <R extends IPAddressSection> R[] getSpanningPrefixBlocks(
			R first,
			R other,
			UnaryOperator<R> getLower,
			UnaryOperator<R> getUpper,
			Comparator<R> comparator,
			UnaryOperator<R> prefixAdder,
			UnaryOperator<R> prefixRemover,
			IntFunction<R[]> arrayProducer) {
		first.checkSegmentCount(other);
		R result = checkPrefixBlockContainment(first, other, prefixAdder);
		if(result != null) {
			R resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		List<IPAddressSegmentSeries> blocks = applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, (orig, lower, upper) -> IPAddressSection.splitIntoPrefixBlocks(lower, upper));
		R resultArray[] = blocks.toArray(arrayProducer.apply(blocks.size()));
		return resultArray;
	}
	
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R[] getSpanningSequentialBlocks(
			R first,
			R other,
			UnaryOperator<R> getLower,
			UnaryOperator<R> getUpper,
			Comparator<R> comparator,
			UnaryOperator<R> prefixRemover,
			IPAddressCreator<?, R, ?, S, ?> creator) {
		R[] result = checkSequentialBlockContainment(first, other, prefixRemover, creator::createSectionArray);
		if(result != null) {
			return result;
		}
		TriFunction<R, List<IPAddressSegmentSeries>> operatorFunctor = (orig, one, two) -> IPAddressSection.splitIntoSequentialBlocks(one, two, creator::createSequentialBlockSection);
		List<IPAddressSegmentSeries> blocks = applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, operatorFunctor);
		return blocks.toArray(creator.createSectionArray(blocks.size()));
	}
	
	@FunctionalInterface
	public interface SeriesCreator {
		IPAddressSegmentSeries apply(IPAddressSegmentSeries segmentSeries, int index, int lowerVal, int upperVal);
	}
	
	static List<IPAddressSegmentSeries> splitIntoSequentialBlocks(
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper,
			SeriesCreator seriesCreator) {
		ArrayList<IPAddressSegmentSeries> blocks = new ArrayList<>(IPv6Address.SEGMENT_COUNT);
		int segCount = lower.getSegmentCount();
		if(segCount == 0) {
			//all segments match, it's just a single address
			blocks.add(lower);
			return blocks;
		}
		int previousSegmentBits = 0, currentSegment = 0;
		int bitsPerSegment = lower.getBitsPerSegment();
		int segSegment;
		int lowerValue, upperValue;
		SeriesStack stack = null;
		Deque<IPAddressSegmentSeries> toAdd = null;
		while(true) {
			do {
				segSegment = currentSegment;
				IPAddressSegment lowerSeg = lower.getSegment(currentSegment);
				IPAddressSegment upperSeg = upper.getSegment(currentSegment++);
				lowerValue = lowerSeg.getSegmentValue();//these are single addresses, so lower or upper value no different here
				upperValue = upperSeg.getSegmentValue();
				previousSegmentBits += bitsPerSegment;
			} while(lowerValue == upperValue && currentSegment < segCount);
			
			if(lowerValue == upperValue) {
				blocks.add(lower);
			} else {	
				boolean lowerIsLowest = lower.includesZeroHost(previousSegmentBits);
				boolean higherIsHighest = upper.includesMaxHost(previousSegmentBits);
				if(lowerIsLowest) {
					if(higherIsHighest) {
						// full range
						IPAddressSegmentSeries series = seriesCreator.apply(lower, segSegment, lowerValue, upperValue);
						blocks.add(series);
					} else {
						IPAddressSegmentSeries topLower = upper.toZeroHost(previousSegmentBits);
						IPAddressSegmentSeries middleUpper = topLower.increment(-1);
						IPAddressSegmentSeries series = seriesCreator.apply(lower, segSegment, lowerValue, middleUpper.getSegment(segSegment).getSegmentValue());
						blocks.add(series);
						lower = topLower;
						continue;
					}
				} else if(higherIsHighest) {
					IPAddressSegmentSeries bottomUpper = lower.toMaxHost(previousSegmentBits);
					IPAddressSegmentSeries topLower = bottomUpper.increment(1);
					IPAddressSegmentSeries series = seriesCreator.apply(topLower, segSegment, topLower.getSegment(segSegment).getSegmentValue(), upperValue);
					if(toAdd == null) {
						toAdd = new ArrayDeque<>(IPv6Address.SEGMENT_COUNT);
					}
					toAdd.addFirst(series);
					upper = bottomUpper;
					continue;
				} else {	//lower 2:3:ffff:5:: to upper 2:4:1:5::      2:3:ffff:5:: to 2:3:ffff:ffff:ffff:ffff:ffff:ffff and 2:4:: to 2:3:ffff:ffff:ffff:ffff:ffff:ffff and 2:4:: to 2:4:1:5::
					//from top to bottom we have: top - topLower - middleUpper - middleLower - bottomUpper - lower
					IPAddressSegmentSeries topLower = upper.toZeroHost(previousSegmentBits);//2:4::
					IPAddressSegmentSeries middleUpper = topLower.increment(-1);//2:3:ffff:ffff:ffff:ffff:ffff:ffff
					IPAddressSegmentSeries bottomUpper = lower.toMaxHost(previousSegmentBits);//2:3:ffff:ffff:ffff:ffff:ffff:ffff
					IPAddressSegmentSeries middleLower = bottomUpper.increment(1);//2:4::
					if(middleLower.compareTo(middleUpper) <= 0) {
						IPAddressSegmentSeries series = seriesCreator.apply(middleLower, segSegment, middleLower.getSegment(segSegment).getSegmentValue(), middleUpper.getSegment(segSegment).getSegmentValue());
						if(toAdd == null) {
							toAdd = new ArrayDeque<>(IPv6Address.SEGMENT_COUNT);
						}
						toAdd.addFirst(series);
					}
					if(stack == null) {
						stack = new SeriesStack(IPv6Address.SEGMENT_COUNT);
					}
					stack.push(topLower, upper, previousSegmentBits, currentSegment); // do this one later
					upper = bottomUpper;
					continue;
				}
			}
			if(toAdd != null) {
				while(true) {
					IPAddressSegmentSeries saved = toAdd.pollFirst();
					if(saved == null) {
						break;
					}
					blocks.add(saved);
				}
			}
			if(stack == null || !stack.pop()) {
				return blocks;
			}
			lower = stack.lower;
			upper = stack.upper;
			previousSegmentBits = stack.previousSegmentBits;
			currentSegment = stack.currentSegment;
		}
	}
	
	static class SeriesStack {
		int stackSize;
		int top; // top of stack
		int capacity;
		
		IPAddressSegmentSeries seriesPairs[]; // stack items
		int indexPairs[]; // stack items
		
		IPAddressSegmentSeries lower, upper; // last popped items
		int previousSegmentBits, currentSegment; // last popped items
		
		SeriesStack(int initialCapacity) {
			this.capacity = 2 * initialCapacity;
		}
		
		void push(IPAddressSegmentSeries lower, IPAddressSegmentSeries upper, int previousSegmentBits, int currentSegment) {
			int top = this.top;
			if(top >= stackSize) {
				resize();
			}
			IPAddressSegmentSeries seriesPairs[] = this.seriesPairs;
			int indexPairs[] = this.indexPairs;
			seriesPairs[top] = lower;
			indexPairs[top++] = previousSegmentBits;
			seriesPairs[top] = upper;
			indexPairs[top++] = currentSegment;
			this.top = top;
		}
		
		boolean pop() {
			if(top <= 0) {
				return false;
			}
			IPAddressSegmentSeries seriesPairs[] = this.seriesPairs;
			int indexPairs[] = this.indexPairs;
			int top = this.top;
			currentSegment = indexPairs[--top];
			upper = seriesPairs[top];
			previousSegmentBits = indexPairs[--top];
			lower = seriesPairs[top];
			this.top = top;
			return true;
		}
		
		void resize() {
			int size = stackSize;
			if(size == 0) {
				// splits are limited by bit count, and each recursion here pushes a pair onto each stack
				size = capacity;
			} else {
				size <<= 1; // double the stack size
			}
			IPAddressSegmentSeries newSeriesPairs[] = new IPAddressSegmentSeries[size];
			int newIndexPairs[] = new int[size];
			if(top > 0) {
				System.arraycopy(seriesPairs, 0, newSeriesPairs, 0, top);
				System.arraycopy(indexPairs, 0, newIndexPairs, 0, top);
			}
			seriesPairs = newSeriesPairs;
			indexPairs = newIndexPairs;
			stackSize = size;
		}
	}
	
	static List<IPAddressSegmentSeries> splitIntoPrefixBlocks(
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper) {
		ArrayList<IPAddressSegmentSeries> blocks = new ArrayList<>();
		int previousSegmentBits = 0, currentSegment = 0;
		SeriesStack stack = null;
		
		while(true) {
			//Find first non-matching bit.  
			int differing = 0;
			int segCount = lower.getSegmentCount();
			int bitsPerSegment = lower.getBitsPerSegment();
			for(; currentSegment < segCount; currentSegment++) {
				IPAddressSegment lowerSeg = lower.getSegment(currentSegment);
				IPAddressSegment upperSeg = upper.getSegment(currentSegment);
				int lowerValue = lowerSeg.getSegmentValue();//these are single addresses, so lower or upper value no different here
				int upperValue = upperSeg.getSegmentValue();
				differing = lowerValue ^ upperValue;
				if(differing != 0) {
					break;
				}
				previousSegmentBits += bitsPerSegment;
			}
			if(differing == 0) {
				//all bits match, it's just a single address
				blocks.add(lower.toPrefixBlock(lower.getBitCount()));
			} else {
				boolean differingIsLowestBit = (differing == 1);
				if(differingIsLowestBit && currentSegment + 1 == segCount) {
					//only the very last bit differs, so we have a prefix block right there
					blocks.add(lower.toPrefixBlock(lower.getBitCount() - 1));
				} else {
					int highestDifferingBitInRange = Integer.numberOfLeadingZeros(differing) - (Integer.SIZE - bitsPerSegment);
					int differingBitPrefixLen = highestDifferingBitInRange + previousSegmentBits;
					if(lower.includesZeroHost(differingBitPrefixLen) && upper.includesMaxHost(differingBitPrefixLen)) {
						//full range at the differing bit, we have a single prefix block
						blocks.add(lower.toPrefixBlock(differingBitPrefixLen));
					} else {
						//neither a prefix block nor a single address
						//we split into two new ranges to continue  
						//starting from the differing bit,
						//lower top becomes 1000000...
						//upper bottom becomes 01111111...
						//so in each new range, the differing bit is at least one further to the right (or more)
						IPAddressSegmentSeries lowerTop = upper.toZeroHost(differingBitPrefixLen + 1);
						IPAddressSegmentSeries upperBottom = lowerTop.increment(-1);
						if(differingIsLowestBit) {
							previousSegmentBits += bitsPerSegment;
							currentSegment++;
						}
						if(stack == null) {
							stack = new SeriesStack(IPv6Address.BIT_COUNT);
						}
						stack.push(lowerTop, upper, previousSegmentBits, currentSegment); // do upper one later
						upper = upperBottom; // do lower one now
						continue;
					}
				}
			}
			if(stack == null || !stack.pop()) {
				return blocks;
			}
			lower = stack.lower;
			upper = stack.upper;
			previousSegmentBits = stack.previousSegmentBits;
			currentSegment = stack.currentSegment;
		}
	}
	
	//sort by prefix length, smallest blocks coming first
	//so this means null prefixes come first, then largest prefix length to smallest
	static final Comparator<? super IPAddressSegmentSeries> mergeListComparator = (one, two) ->  {
		Integer prefix1 = one.getPrefixLength();
		Integer prefix2 = two.getPrefixLength();
		int comparison = (prefix1 == prefix2) ? 0 : ((prefix1 == null) ? -1 : ((prefix2 == null) ? 1 : prefix2.compareTo(prefix1)));
		if(comparison != 0) {
			return comparison;
		}
		if(prefix1 == null || prefix1 != 0) {// this does not actually need to handle prefix len 0, but we handle anyway
			int networkSegIndex = (prefix1 == null) ? one.getSegmentCount() - 1 : getNetworkSegmentIndex(prefix1, one.getBytesPerSegment(), one.getBitsPerSegment());
			int hostSegIndex = (prefix1 == null) ? one.getSegmentCount() : getHostSegmentIndex(prefix1, one.getBytesPerSegment(), one.getBitsPerSegment());
			for(int i = 0; i < hostSegIndex; i++) {
				AddressSegment segOne = one.getSegment(i);
				AddressSegment segTwo = two.getSegment(i);
				int oneValue = segOne.getSegmentValue();
				int twoValue = segTwo.getSegmentValue();
				int oneUpperValue = segOne.getUpperSegmentValue();
				int twoUpperValue = segTwo.getUpperSegmentValue();
				comparison = (oneUpperValue - oneValue) - (twoUpperValue - twoValue);
				if(comparison != 0) {
					return comparison;
				}
			}
			for(int i = 0; i <= networkSegIndex; i++) {
				AddressSegment segOne = one.getSegment(i);
				AddressSegment segTwo = two.getSegment(i);
				int oneValue = segOne.getSegmentValue();
				int twoValue = segTwo.getSegmentValue();
				comparison = oneValue - twoValue;
				if(comparison != 0) {
					return comparison;
				}
			}
		}
		return comparison;
	};
	private static final ValueComparator REVERSE_LOW_COMPARATOR = new ValueComparator(true, false, true);
	private static final ValueComparator REVERSE_HIGH_COMPARATOR = new ValueComparator(true, true, true);
	protected static List<IPAddressSegmentSeries> getMergedSequentialBlocks(IPAddressSegmentSeries sections[], SeriesCreator seriesCreator) {
		ArrayList<IPAddressSegmentSeries> list = new ArrayList<>(sections.length << 1);
		boolean singleElement = organizeSequentialMerge(sections, list);
		if(singleElement) {
			list.set(0, list.get(0).withoutPrefixLength());
			return list;
		}
		ValueComparator reverseLowComparator = REVERSE_LOW_COMPARATOR;
		ValueComparator reverseHighComparator = REVERSE_HIGH_COMPARATOR;
		int removedCount = 0;
		int j = list.size() - 1, i = j - 1;
		int ithRangeSegmentIndex = -1, jthRangeSegmentIndex = -1;
		top:
		while(j > 0) {
			IPAddressSegmentSeries item = list.get(i);
			IPAddressSegmentSeries otherItem = list.get(j);
			int compare = reverseHighComparator.compare(item, otherItem);
			// check for strict containment, case 1:
			// w   z
			//  x y
			if(compare > 0) {
				removedCount++;
				int k = j + 1;
				while(k < list.size() && list.get(k) == null) {
					k++;
				}
				if(k < list.size()) {
					list.set(j, list.get(k));
					list.set(k, null);
					jthRangeSegmentIndex = -1;
				} else {
					list.set(j, null);
					j = i;
					i--;
					jthRangeSegmentIndex = ithRangeSegmentIndex;
					ithRangeSegmentIndex = -1;
				}
				continue;
			}
			// non-strict containment, case 2:
			// w   z
			// w   z
			//
			// reverse containment, case 3:
			// w  y
			// w   z
			int rcompare = reverseLowComparator.compare(item, otherItem);
			if(rcompare >= 0) {
				removedCount++;
				list.set(i, otherItem);
				list.set(j, null);
				j = i;
				i--;
				jthRangeSegmentIndex = ithRangeSegmentIndex;
				ithRangeSegmentIndex = -1;
				continue;
			}
			//check for overlap
			
			if(ithRangeSegmentIndex < 0) {
				ithRangeSegmentIndex = item.getSequentialBlockIndex();
			}
			if(jthRangeSegmentIndex < 0) {
				jthRangeSegmentIndex = otherItem.getSequentialBlockIndex();
			}
			// check for overlap in the non-full range segment,
			// which must be the same segment in both, otherwise it cannot be overlap,
			// it can only be containment.
			// The one with the earlier range segment can only contain the other, there cannot be overlap.
			// eg 1.a-b.*.* and 1.2.3.* overlap in range segment 2 must have a <= 2 <= b and that means 1.a-b.*.* contains 1.2.3.*
			if(ithRangeSegmentIndex != jthRangeSegmentIndex) {
			//if(rangeSegmentIndex != otherRangeSegmentIndex) {
				j = i;
				i--;
				jthRangeSegmentIndex = ithRangeSegmentIndex;
				ithRangeSegmentIndex = -1;
				continue;
			}
			
			IPAddressSegment rangeSegment = item.getSegment(ithRangeSegmentIndex);
			IPAddressSegment otherRangeSegment = otherItem.getSegment(ithRangeSegmentIndex);
			int otherRangeItemValue = otherRangeSegment.getSegmentValue();
			int rangeItemUpperValue = rangeSegment.getUpperSegmentValue();
			
			//check for overlapping range in the range segment
			if(rangeItemUpperValue < otherRangeItemValue && rangeItemUpperValue + 1 != otherRangeItemValue) {
				j = i;
				i--;
				//jthRangeSegmentIndex = ithRangeSegmentIndex;
				ithRangeSegmentIndex = -1;
				continue;
			}
			
			// now check all previous segments match
			for(int k = ithRangeSegmentIndex - 1; k >= 0; k--) {
				IPAddressSegment itemSegment = item.getSegment(k);
				IPAddressSegment otherItemSegment = otherItem.getSegment(k);
				int val = itemSegment.getSegmentValue();
				int otherVal = otherItemSegment.getSegmentValue();
				if(val != otherVal) {
					j = i;
					i--;
					ithRangeSegmentIndex = -1;
					continue top;
				}
			}
			IPAddressSegmentSeries joinedItem = seriesCreator.apply(
					item,
					ithRangeSegmentIndex,
					rangeSegment.getSegmentValue(),
					Math.max(rangeItemUpperValue, otherRangeSegment.getUpperSegmentValue()));
			list.set(i, joinedItem);
			if(joinedItem.getSegment(ithRangeSegmentIndex).isFullRange()) {
				if(ithRangeSegmentIndex == 0) {
					list.clear();
					list.add(joinedItem);
					return list;
				}
				ithRangeSegmentIndex--;
			}
			removedCount++;
			int k = j + 1;
			while(k < list.size() && list.get(k) == null) {
				k++;
			}
			if(k < list.size()) {
				list.set(j, list.get(k));
				list.set(k, null);
				jthRangeSegmentIndex = -1;
			} else {
				list.set(j, null);
				j = i;
				i--;
				jthRangeSegmentIndex = ithRangeSegmentIndex;
				ithRangeSegmentIndex = -1;
			}
		}
		if(removedCount > 0) {
			int newSize = list.size() - removedCount;
			for(int k = 0, l = 0; k < newSize; k++, l++) {
				while(list.get(l) == null) {
					l++;
				}
				list.set(k, list.get(l).withoutPrefixLength());
			}
			int last = list.size();
			while(removedCount-- > 0) {
				list.remove(--last);
			}
		} else for(int n = 0; n < list.size(); n++) {
			list.set(n, list.get(n).withoutPrefixLength());
		}
		return list;
	}
	
	protected static List<IPAddressSegmentSeries> getMergedPrefixBlocks(IPAddressSegmentSeries sections[]) {
		ArrayList<IPAddressSegmentSeries> list = new ArrayList<>(sections.length << 3);
		boolean singleElement = organizeSequentially(sections, list);
		if(singleElement) {
			return list;
		}
		ValueComparator reverseLowComparator = REVERSE_LOW_COMPARATOR;
		ValueComparator reverseHighComparator = REVERSE_HIGH_COMPARATOR;
		IPAddressSegmentSeries first = sections[0];
		int bitCount = first.getBitCount();
		int bitsPerSegment = first.getBitsPerSegment();
		int bytesPerSegment = first.getBytesPerSegment();
		//Now we see if we can match blocks or join them into larger blocks
		int removedCount = 0;
		int j = list.size() - 1, i = j - 1;
		top:
		while(j > 0) {
			IPAddressSegmentSeries item = list.get(i);
			IPAddressSegmentSeries otherItem = list.get(j);
			int compare = reverseHighComparator.compare(item, otherItem);
			// check for strict containment, case 1:
			// w   z
			//  x y
			if(compare > 0) {
				removedCount++;
				int k = j + 1;
				while(k < list.size() && list.get(k) == null) {
					k++;
				}
				if(k < list.size()) {
					list.set(j, list.get(k));
					list.set(k, null);
				} else {
					list.set(j, null);
					j = i;
					i--;
				}
				continue;
			}
			// non-strict containment, case 2:
			// w   z
			// w   z
			//
			// reverse containment, case 3:
			// w  y
			// w   z
			int rcompare = reverseLowComparator.compare(item, otherItem);
			if(rcompare >= 0) {
				removedCount++;
				list.set(i, otherItem);
				list.set(j, null);
				j = i;
				i--;
				continue;
			}
			// check for merge, case 4:
			// w   x
			//      y   z
			// where x and y adjacent, becoming:
			// w        z
			//
			Integer prefixLen = item.getPrefixLength();
			Integer otherPrefixLen = otherItem.getPrefixLength();
			if(!Objects.equals(prefixLen, otherPrefixLen)) {
				j = i;
				i--;
				continue;
			}
			int matchBitIndex = (prefixLen == null) ? bitCount - 1 : prefixLen - 1;
			int lastMatchSegmentIndex, lastBitSegmentIndex;
			if(matchBitIndex == 0) {
				lastMatchSegmentIndex = lastBitSegmentIndex = 0;
			} else {
				lastMatchSegmentIndex = getNetworkSegmentIndex(matchBitIndex, bytesPerSegment, bitsPerSegment);
				lastBitSegmentIndex = getHostSegmentIndex(matchBitIndex, bytesPerSegment, bitsPerSegment);
			}
			IPAddressSegment itemSegment = item.getSegment(lastMatchSegmentIndex);
			IPAddressSegment otherItemSegment = otherItem.getSegment(lastMatchSegmentIndex);
			int itemSegmentValue = itemSegment.getSegmentValue();
			int otherItemSegmentValue = otherItemSegment.getSegmentValue();
			int segmentLastBitIndex = bitsPerSegment - 1;
			if(lastBitSegmentIndex == lastMatchSegmentIndex) {
				int segmentBitToCheck = matchBitIndex % bitsPerSegment;
				int shift = segmentLastBitIndex - segmentBitToCheck;
				itemSegmentValue >>>= shift;
				otherItemSegmentValue >>>= shift;
			} else {
				int itemBitValue = item.getSegment(lastBitSegmentIndex).getSegmentValue();
				int otherItemBitalue = otherItem.getSegment(lastBitSegmentIndex).getSegmentValue();
				//we will make space for the last bit so we can do a single comparison
				itemSegmentValue = (itemSegmentValue << 1) | (itemBitValue >>> segmentLastBitIndex);
				otherItemSegmentValue = (otherItemSegmentValue << 1) | (otherItemBitalue >>> segmentLastBitIndex);
			}
			if(itemSegmentValue != otherItemSegmentValue) {
				itemSegmentValue ^= 1;//the ^ 1 flips the first bit
				if(itemSegmentValue != otherItemSegmentValue) {
					//neither an exact match nor a match when flipping the bit, so move on
					j = i;
					i--;
					continue;
				} //else we will merge these two into a single prefix block, presuming the initial segments match
			}
			//check initial segments
			for(int k = lastMatchSegmentIndex - 1; k >= 0; k--) {
				itemSegment = item.getSegment(k);
				otherItemSegment = otherItem.getSegment(k);
				int val = itemSegment.getSegmentValue();
				int otherVal = otherItemSegment.getSegmentValue();
				if(val != otherVal) {
					j = i;
					i--;
					continue top;
				}
			}
			IPAddressSegmentSeries joinedItem = otherItem.toPrefixBlock(matchBitIndex);
			list.set(i, joinedItem);
			removedCount++;
			int k = j + 1;
			while(k < list.size() && list.get(k) == null) {
				k++;
			}
			if(k < list.size()) {
				list.set(j, list.get(k));
				list.set(k, null);
			} else {
				list.set(j, null);
				j = i;
				i--;
			}
		}
		if(removedCount > 0) {
			int newSize = list.size() - removedCount;
			for(int k = 0, l = 0; k < newSize; k++, l++) {
				while(list.get(l) == null) {
					l++;
				}
				if(k != l) {
					list.set(k, list.get(l));
				}
			}
			int last = list.size();
			while(removedCount-- > 0) { // could use subList here 
				list.remove(--last);
			}
		}
		return list;
	}
	
	private static boolean organizeSequentially(IPAddressSegmentSeries sections[], List<IPAddressSegmentSeries> list) {
		List<IPAddressSegmentSeries> sequentialList = null;
		for(int i = 0; i < sections.length; i++) {
			IPAddressSegmentSeries section = sections[i];
			if(section == null) {
				continue;
			}
			if(!section.isSequential()) {
				if(sequentialList == null) {
					sequentialList = new ArrayList<>(sections.length);
					for(int j = 0; j < i; j++) {
						IPAddressSegmentSeries series = sections[j];
						if(series != null) {
							sequentialList.add(series);
						}
					}
				}
				Iterator<? extends IPAddressSegmentSeries> iterator = section.sequentialBlockIterator();
				while(iterator.hasNext()) {
					sequentialList.add(iterator.next());
				}
			} else if(sequentialList != null) {
				sequentialList.add(section);
			}
		}
		if(sequentialList == null) {
			for(int i = 0; i < sections.length; i++) {
				IPAddressSegmentSeries series = sections[i];
				if(series != null) {
					if(series.isSinglePrefixBlock()) {
						list.add(series);
					} else {
						IPAddressSegmentSeries span[] = series.spanWithPrefixBlocks();
						for(int k = 0; k < span.length; k++) {
							list.add(span[k]);
						}
					}
				}
			}
		} else for(int j = 0; j < sequentialList.size(); j++) {
			IPAddressSegmentSeries series = sequentialList.get(j);
			if(series.isSinglePrefixBlock()) {
				list.add(series);
			} else {
				IPAddressSegmentSeries span[] = series.spanWithPrefixBlocks();
				for(int k = 0; k < span.length; k++) {
					list.add(span[k]);
				}
			}
		}
		if(list.size() == 1) {
			return true;
		}
		list.sort(Address.ADDRESS_LOW_VALUE_COMPARATOR);
		return false;
	}
	
	private static boolean organizeSequentialMerge(IPAddressSegmentSeries sections[], List<IPAddressSegmentSeries> list) {
		for(int i = 0; i < sections.length; i++) {
			IPAddressSegmentSeries section = sections[i];
			if(section == null) {
				continue;
			}
			if(section.isSequential()) {
				list.add(section);
			} else {
				Iterator<? extends IPAddressSegmentSeries> iterator = section.sequentialBlockIterator();
				while(iterator.hasNext()) {
					list.add(iterator.next());
				}
			}
		}
		if(list.size() == 1) {
			return true;
		}
		list.sort(Address.ADDRESS_LOW_VALUE_COMPARATOR);
		return false;
	}
	protected List<? extends IPAddressSegmentSeries> spanWithBlocks(boolean prefixBlocks) {
		return IPAddress.spanWithBlocks(this, prefixBlocks);
	}
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R[] subtract(
			R first,
			R other,
			IPAddressCreator<T, R, ?, S, ?> addrCreator,
			IntFunction<S> segProducer,
			SegFunction<R, R> prefixApplier) {
		//check if they are comparable first
		first.checkSegmentCount(other);
		if(!first.isMultiple()) {
			if(other.contains(first)) {
				return null;
			}
			R result[] = addrCreator.createSectionArray(1);
			result[0] = first;
			return result;
		}
		//getDifference: same as removing the intersection
		//   first you confirm there is an intersection in each segment.  
		// Then you remove each intersection, one at a time, leaving the other segments the same, since only one segment needs to differ.
		// To prevent adding the same section twice, use only the intersection (ie the relative complement of the diff) 
		// of segments already handled and not the whole segment.
		
		// For example: 0-3.0-3.2.4 subtracting 1-4.1-3.2.4, the intersection is 1-3.1-3.2.4
		// The diff of the first segment is just 0, giving 0.0-3.2.4 (subtract the first segment, leave the others the same)
		// The diff of the second segment is also 0, but for the first segment we use the intersection since we handled the first already, giving 1-3.0.2.4
		// 	(take the intersection of the first segment, subtract the second segment, leave remaining segments the same)
		int segCount = first.getSegmentCount();
		for(int i = 0; i < segCount; i++) {
			IPAddressSegment seg = first.getSegment(i);
			IPAddressSegment otherSeg = other.getSegment(i);
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			if(otherLower > higher || lower > otherHigher) {
				//no overlap in this segment means no overlap at all
				R result[] = addrCreator.createSectionArray(1);
				result[0] = first;
				return result;
			}
		}
		
		S intersections[] = addrCreator.createSegmentArray(segCount);
		ArrayList<R> sections = new ArrayList<R>();
		for(int i = 0; i < segCount; i++) {
			S seg = segProducer.apply(i);
			IPAddressSegment otherSeg = other.getSegment(i);
			int lower = seg.getSegmentValue();
			int higher = seg.getUpperSegmentValue();
			int otherLower = otherSeg.getSegmentValue();
			int otherHigher = otherSeg.getUpperSegmentValue();
			if(lower >= otherLower) {
				if(higher <= otherHigher) {
					//this segment is contained in the other
					if(seg.isPrefixed()) {
						intersections[i] = addrCreator.createSegment(lower, higher, null);
					} else {
						intersections[i] = seg;
					}
					continue;
				}
				//otherLower <= lower <= otherHigher < higher
				intersections[i] = addrCreator.createSegment(lower, otherHigher, null);
				R section = createDiffSection(first, otherHigher + 1, higher, i, addrCreator, segProducer, intersections);
				sections.add(section);
			} else {
				//lower < otherLower <= otherHigher
				R section = createDiffSection(first, lower, otherLower - 1, i, addrCreator, segProducer, intersections);
				sections.add(section);
				if(higher <= otherHigher) {
					intersections[i] = addrCreator.createSegment(otherLower, higher, null);
				} else {
					//lower < otherLower <= otherHigher < higher
					intersections[i] = addrCreator.createSegment(otherLower, otherHigher, null);
					section = createDiffSection(first, otherHigher + 1, higher, i, addrCreator, segProducer, intersections);
					sections.add(section);
				}
			}
		}
		if(sections.size() == 0) {
			return null;
		}
		
		//apply the prefix to the sections
		//for each section, we figure out what each prefix length should be
		if(first.isPrefixed()) {
			int thisPrefix = first.getNetworkPrefixLength();
			for(int i = 0; i < sections.size(); i++) {
				R section = sections.get(i);
				int bitCount = section.getBitCount();
				int totalPrefix = bitCount;
				for(int j = first.getSegmentCount() - 1; j >= 0 ; j--) {
					IPAddressSegment seg = section.getSegment(j);
					int segBitCount = seg.getBitCount();
					int segPrefix = seg.getMinPrefixLengthForBlock();
					if(segPrefix == segBitCount) {
						break;
					} else {
						totalPrefix -= segBitCount;
						if(segPrefix != 0) {
							totalPrefix += segPrefix;
							break;
						}
					}
				}
				if(totalPrefix != bitCount) {
					if(totalPrefix < thisPrefix) {
						totalPrefix = thisPrefix;
					}
					section = prefixApplier.apply(section, totalPrefix);
					sections.set(i, section);
				}
			}
		}
		
		R result[] = addrCreator.createSectionArray(sections.size());
		sections.toArray(result);
		return result;
	}
	
	private static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R createDiffSection(
			R original,
			int lower,
			int upper,
			int diffIndex,
			IPAddressCreator<T, R, ?, S, ?> addrCreator,
			IntFunction<S> segProducer,
			S intersectingValues[]) {
		int segCount = original.getSegmentCount();
		S segments[] = addrCreator.createSegmentArray(segCount);
		for(int j = 0; j < diffIndex; j++) {
			segments[j] = intersectingValues[j];
		}
		S diff = addrCreator.createSegment(lower, upper, null);
		segments[diffIndex] = diff;
		for(int j = diffIndex + 1; j < segCount; j++) {
			segments[j] = segProducer.apply(j);
		}
		R section = addrCreator.createSectionInternal(segments);
		return section;
	}
	@Override
	public abstract IPAddressSection toZeroHost();
	@Override
	public abstract IPAddressSection toZeroHost(int prefixLength);
	
	@Override
	public abstract IPAddressSection toZeroNetwork();
	
	@Override
	public abstract IPAddressSection toMaxHost();
	@Override
	public abstract IPAddressSection toMaxHost(int prefixLength);
	
	@Deprecated
	@Override
	public abstract IPAddressSection applyPrefixLength(int networkPrefixLength) throws PrefixLenException;
	
	protected void checkMaskSegmentCount(IPAddressSection mask) throws SizeMismatchException {
		if(mask.getSegmentCount() < getSegmentCount()) {
			throw new SizeMismatchException(this, mask);
		}
	}
	
	@Override
	public abstract IPAddressSection coverWithPrefixBlock();
		
	@Override
	public abstract IPAddressSection toPrefixBlock();
	@Override
	public abstract IPAddressSection toPrefixBlock(int networkPrefixLength);
	@Override
	public IPAddressSection getHostMask() {
		Integer prefLen = getNetworkPrefixLength();
		return getNetwork().getHostMask(prefLen == null ? 0 : getNetworkPrefixLength()).getSection(0, getSegmentCount());
	}
	@Override
	public IPAddressSection getNetworkMask() {
		Integer prefLen = getNetworkPrefixLength();
		return getNetwork().getNetworkMask(prefLen == null ? getBitCount() : getNetworkPrefixLength()).getSection(0, getSegmentCount());
	}
	/**
	 * Returns the equivalent CIDR address section with a prefix length for which the subnet block for that prefix matches the range of values in this section.
	 * <p>
	 * If no such prefix length exists, returns null.
	 * <p>
	 * If this address represents just a single address, "this" is returned.
	 * 
	 * @return
	 */
	@Override
	public IPAddressSection assignPrefixForSingleBlock() {
		Integer newPrefix = getPrefixLengthForSingleBlock();
		if(newPrefix == null) {
			return null;
		}
		IPAddressSection result = setPrefixLength(newPrefix, false);
		if(result != this) { // otherwise these are already set
			result.hasNoPrefixCache();
			PrefixCache cache = result.prefixCache;
			cache.cachedIsSinglePrefixBlock = true;
			cache.cachedEquivalentPrefix = newPrefix;
			cache.cachedMinPrefix = newPrefix;
		}
		return result;
	}
	
	/**
	 * Constructs an equivalent address section with the smallest CIDR prefix possible (largest network),
	 * such that the range of values are a set of subnet blocks for that prefix.
	 * 
	 * @return
	 */
	@Override
	public IPAddressSection assignMinPrefixForBlock() {
		return setPrefixLength(getMinPrefixLengthForBlock(), false);
	}
	@Override
	public boolean includesZeroHost() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return false;
		}
		return includesZeroHost(networkPrefixLength);
	}
	
	@Override
	public boolean includesZeroHost(int networkPrefixLength) {
		if(networkPrefixLength < 0 || networkPrefixLength > getBitCount()) {
			throw new PrefixLenException(this, networkPrefixLength);
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getNetworkPrefixLength() <= networkPrefixLength) { 
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int bytesPerSegment = getBytesPerSegment();
		int prefixedSegmentIndex = getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
		int divCount = getSegmentCount();
		for(int i = prefixedSegmentIndex; i < divCount; i++) {
			IPAddressSegment div = getSegment(i);
			Integer segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			if(segmentPrefixLength != null) {
				int mask = div.getSegmentHostMask(segmentPrefixLength);
				if((mask & div.getDivisionValue()) != 0) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = getSegment(i);
					if(!div.includesZero()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	@Override
	public boolean includesMaxHost() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return false;
		}
		return includesMaxHost(networkPrefixLength);
	}
	
	@Override
	public boolean includesMaxHost(int networkPrefixLength) {
		if(networkPrefixLength < 0 || networkPrefixLength > getBitCount()) {
			throw new PrefixLenException(this, networkPrefixLength);
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getNetworkPrefixLength() <= networkPrefixLength) { 
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int bytesPerSegment = getBytesPerSegment();
		int prefixedSegmentIndex = getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
		int divCount = getSegmentCount();
		for(int i = prefixedSegmentIndex; i < divCount; i++) {
			IPAddressSegment div = getSegment(i);
			Integer segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			if(segmentPrefixLength != null) {
				int mask = div.getSegmentHostMask(segmentPrefixLength);
				if((mask & div.getUpperSegmentValue()) != mask) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = getSegment(i);
					if(!div.includesMax()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	
	/**
	 * 
	 * @return whether the network section of the address, the prefix, consists of a single value
	 */
	public boolean isSingleNetwork() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return !isMultiple();
		}
		int prefixedSegmentIndex = getNetworkSegmentIndex(networkPrefixLength, getBytesPerSegment(), getBitsPerSegment());
		if(prefixedSegmentIndex < 0) {
			return true;
		}
		for(int i = 0; i < prefixedSegmentIndex; i++) {
			IPAddressSegment div = getSegment(i);
			if(div.isMultiple()) {
				return false;
			}
		}
		IPAddressSegment div = getSegment(prefixedSegmentIndex);
		int differing = div.getSegmentValue() ^ div.getUpperSegmentValue();
		if(differing == 0) {
			return true;
		}
		int bitsPerSegment = div.getBitCount();
		int highestDifferingBitInRange = Integer.numberOfLeadingZeros(differing) - (Integer.SIZE - bitsPerSegment);
		return getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, prefixedSegmentIndex) <= highestDifferingBitInRange;
	}
	
	/**
	 * Applies the mask to this address section and then compares values with the given address section
	 * 
	 * @param mask
	 * @param other
	 * @return
	 */
	public boolean matchesWithMask(IPAddressSection other, IPAddressSection mask) {
		checkMaskSegmentCount(mask);
		checkSegmentCount(other);
		int divCount = getSegmentCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressSegment div = getSegment(i);
			IPAddressSegment maskSegment = mask.getSegment(i);
			IPAddressSegment otherSegment = other.getSegment(i);
			if(!div.matchesWithMask(
					otherSegment.getSegmentValue(), 
					otherSegment.getUpperSegmentValue(), 
					maskSegment.getSegmentValue())) {
				return false;
			}
		}
		return true;
	}
	
	@Override @Deprecated
	public abstract IPAddressSection removePrefixLength(boolean zeroed);
	@Override @Deprecated
	public abstract IPAddressSection removePrefixLength();
	
	@Override
	public abstract IPAddressSection withoutPrefixLength();
	
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment>
			R toPrefixBlock(
					R original,
					int networkPrefixLength,
					IPAddressCreator<T, R, ?, S, ?> creator,
					SegFunction<Integer, S> segProducer) {
		if(networkPrefixLength < 0 || networkPrefixLength > original.getBitCount()) {
			throw new PrefixLenException(original, networkPrefixLength);
		}
		if(original.isNetworkSubnet(networkPrefixLength)) {
			return original;
		}
		int bitsPerSegment = original.getBitsPerSegment();
		int segmentCount = original.getSegmentCount();
		S result[] = creator.createSegmentArray(segmentCount);
		for(int i = 0; i < segmentCount; i++) {
			Integer prefix = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			result[i] = segProducer.apply(prefix, i);
		}
		return creator.createSectionInternal(result);
	}
	
	protected boolean isNetworkSubnet(int networkPrefixLength) {
		int segmentCount = getSegmentCount();
		if(segmentCount == 0) {
			return true;
		}
		int bitsPerSegment = getBitsPerSegment();
		int prefixedSegmentIndex = getHostSegmentIndex(networkPrefixLength, getBytesPerSegment(), bitsPerSegment);
		if(prefixedSegmentIndex >= segmentCount) {
			if(networkPrefixLength == getBitCount()) {
				IPAddressSegment last = getSegment(segmentCount - 1);
				return !last.isNetworkChangedByPrefixNonNull(last.getBitCount());
			}
			return true;
		}
		int segPrefLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, prefixedSegmentIndex);
		if(getSegment(prefixedSegmentIndex).isNetworkChangedByPrefixNonNull(segPrefLength)) {
			return false;
		}
		if(!getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			for(int i = prefixedSegmentIndex + 1; i < segmentCount; i++) {
				if(!getSegment(i).isFullRange()) {
					return false;
				}
			}
		}
		return true;
	}
	protected static <R extends IPAddressSection, S extends IPAddressSegment> R removePrefixLength(
			R original, boolean zeroed, IPAddressCreator<?, R, ?, S, ?> creator, SegFunction<R, S> segProducer) throws IncompatibleAddressException {
		if(!original.isPrefixed()) {
			return original;
		}
		IPAddressNetwork<?, R, ?, S, ?> network = creator.getNetwork();
		R mask = network.getNetworkMaskSection(zeroed ? original.getPrefixLength() : original.getBitCount());
		return getSubnetSegments(
				original,
				null,
				creator,
				zeroed,
				i -> segProducer.apply(original, i),
				i -> segProducer.apply(mask, i).getSegmentValue(),
				false);
	}
	@Override
	public IPAddressSection adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		int prefix = getAdjustedPrefix(nextSegment, getBitsPerSegment(), false);
		Integer existing = getNetworkPrefixLength();
		if(existing == null) {
			if(nextSegment ? prefix == getBitCount() : prefix == 0) {
				return this;
			}
		} else if(existing != null && existing == prefix && prefix != 0) {
			//remove the prefix from the end
			return removePrefixLength(zeroed);
		}
		return setPrefixLength(prefix, zeroed);
	}
	
	@Override
	public abstract IPAddressSection adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract IPAddressSection adjustPrefixLength(int adjustment);
	
	@Override
	public abstract IPAddressSection adjustPrefixLength(int adjustment, boolean zeroed);
	
	protected static <R extends IPAddressSection, S extends IPAddressSegment> IPAddressSection adjustPrefixLength(
			R original, int adjustment, boolean withZeros, IPAddressCreator<?, R, ?, S, ?> creator, SegFunction<R, S> segProducer) throws IncompatibleAddressException {
		if(adjustment == 0 && original.isPrefixed()) {
			return original;
		}
		int prefix = original.getAdjustedPrefix(adjustment, false, false);
		if(prefix > original.getBitCount()) {
			if(!original.isPrefixed()) {
				return original;
			}
			IPAddressNetwork<?, R, ?, S, ?> network = creator.getNetwork();
			R mask = network.getNetworkMaskSection(withZeros ? original.getPrefixLength() : original.getBitCount());
			return getSubnetSegments(
					original,
					null,
					creator,
					withZeros,
					i -> segProducer.apply(original, i),
					i -> segProducer.apply(mask, i).getSegmentValue(),
					false);
		}
		if(prefix < 0) {
			prefix = 0;
		}
		return original.setPrefixLength(prefix, withZeros);
	}
	@Override
	public abstract IPAddressSection setPrefixLength(int prefixLength);
	@Override
	public abstract IPAddressSection setPrefixLength(int prefixLength, boolean zeroed);
	
	/**
	 * Sets the prefix length while allowing the caller to control whether bits moved in or out of the prefix become zero, 
	 * and whether a zero host for the new prefix bits can be translated into a prefix block.  
	 * The latter behaviour only applies to the default prefix handling configuration,
	 * PREFIXED_ZERO_HOSTS_ARE_SUBNETS.  The methods  {@link #setPrefixLength(int, boolean)} and {@link #setPrefixLength(int)}
	 * use a value of true for zeroed and for zeroHostIsBlock.
	 * <p>
	 * For example, when zeroHostIsBlock is true, applying to 1.2.0.0 the prefix length 16 results in 1.2.*.*&#x2f;16 
	 * <p>
	 * Or if you start with 1.2.0.0&#x2f;24, setting the prefix length to 16 results in 
	 * a zero host followed by the existing prefix block, which is then converted to a full prefix block, 1.2.*.*&#x2f;16
	 * <p>
	 * When both zeroed and zeroHostIsBlock are true, applying the prefix length of 16 to 1.2.4.0&#x2f;24 also results in 
	 * a zero host followed by the existing prefix block, which is then converted to a full prefix block, 1.2.*.*&#x2f;16.
	 * <p>
	 * When both zeroed and zeroHostIsBlock are false, the resulting address always encompasses the same set of addresses as the original,
	 * albeit with a different prefix length.
	 * 
	 * @param prefixLength
	 * @param zeroed
	 * @param zeroHostIsBlock
	 * @return
	 */
	public abstract IPAddressSection setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock);
	private boolean hasNoPrefixCache() {
		if(prefixCache == null) {
			synchronized(this) {
				if(prefixCache == null) {
					prefixCache = new PrefixCache();
					return true;
				}
			}
		}
		return false;
	}
	
	/**
	 * Returns the smallest CIDR prefix length possible (largest network) for which this includes the block of address sections for that prefix.
	 *
	 * @see inet.ipaddr.format.standard.IPAddressDivision#getBlockMaskPrefixLength(boolean)
	 * 
	 * @return
	 */
	@Override
	public int getMinPrefixLengthForBlock() {
		Integer result;
		if(hasNoPrefixCache() || (result = prefixCache.cachedMinPrefix) == null) {
			prefixCache.cachedMinPrefix = result = cacheBits(super.getMinPrefixLengthForBlock());
		}
		return result;
	}
	
	/**
	 * Returns a prefix length for which the range of this address section matches the block of addresses for that prefix.
	 * <p>
	 * If no such prefix exists, returns null
	 * <p>
	 * If this address section represents a single value, returns the bit length
	 * <p>
	 * @return the prefix length or null
	 */
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		if(!hasNoPrefixCache()) {
			Integer result = prefixCache.cachedEquivalentPrefix;
			if(result != null) {
				if(result < 0) {
					return null;
				}
				return result;
			}
		}
		Integer res = super.getPrefixLengthForSingleBlock();
		if(res == null) {
			prefixCache.cachedEquivalentPrefix = NO_PREFIX_LENGTH;
			prefixCache.cachedIsSinglePrefixBlock = false;
			return null;
		}
		if(isPrefixed() && res.equals(getNetworkPrefixLength())) {
			prefixCache.cachedIsSinglePrefixBlock = true;
		}
		prefixCache.cachedEquivalentPrefix = res;
		return res;
	}
	@Override
	public abstract IPAddressSection getLowerNonZeroHost();
	
	@Override
	public abstract IPAddressSection getLower();
	
	@Override
	public abstract IPAddressSection getUpper();
	
	@Override
	public abstract IPAddressSection reverseSegments();
	
	@Override
	public abstract IPAddressSection reverseBits(boolean perByte);
	
	@Override
	public abstract IPAddressSection reverseBytes();
	
	@Override
	public abstract IPAddressSection reverseBytesPerSegment();
	protected IPAddressSegment[] getSegmentsInternal() {
		return (IPAddressSegment[]) getDivisionsInternal();
	}
	@Override
	public abstract IPAddressSection getSection(int index);
	@Override
	public abstract IPAddressSection getSection(int index, int endIndex);
	@Override
	public void getSegments(AddressSegment segs[]) {
		getSegments(0, getDivisionCount(), segs, 0);
	}
	
	@Override
	public void getSegments(int start, int end, AddressSegment segs[], int destIndex) {
		System.arraycopy(getDivisionsInternal(), start, segs, destIndex, end - start);
	}
	
	protected static <T extends IPAddress, R extends IPAddressSection, S extends IPAddressSegment> R createEmbeddedSection(
			IPAddressCreator<T, R, ?, S, ?> creator, S segs[], IPAddressSection encompassingSection) {
		return creator.createEmbeddedSectionInternal(encompassingSection, segs);
	}
	
	@Override
	public abstract Iterable<? extends IPAddressSection> getIterable();
	
	@Override
	public abstract Iterator<? extends IPAddressSection> nonZeroHostIterator();
	@Override
	public abstract Iterator<? extends IPAddressSection> iterator();
	
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> spliterator();
	
	@Override
	public abstract Stream<? extends IPAddressSection> stream();
	@Override
	public abstract Iterator<? extends IPAddressSection> prefixIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> prefixSpliterator();
	@Override
	public abstract Stream<? extends IPAddressSection> prefixStream();
		
	@Override
	public abstract Iterator<? extends IPAddressSection> prefixBlockIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends IPAddressSection> prefixBlockStream();
		
	@Override
	public abstract Iterator<? extends IPAddressSection> blockIterator(int segmentCount);
	
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSection> blockSpliterator(int segmentCount);
	@Override
	public abstract Stream<? extends IPAddressSection> blockStream(int segmentCount);
		
	@Override
	public Iterator<? extends IPAddressSection> sequentialBlockIterator() {
		return blockIterator(getSequentialBlockIndex());
	}
	@Override
	public AddressComponentSpliterator<? extends IPAddressSection> sequentialBlockSpliterator() {
		return blockSpliterator(getSequentialBlockIndex());
	}
	@Override
	public Stream<? extends IPAddressSection> sequentialBlockStream() {
		return blockStream(getSequentialBlockIndex());
	}
		
	@Override
	public BigInteger getSequentialBlockCount() {
		int sequentialSegCount = getSequentialBlockIndex();
		return getPrefixCount(sequentialSegCount * getBitsPerSegment());
	}
	// this iterator function used by sequential ranges
	static <S extends AddressSegment> Iterator<S[]> iterator(
			int divCount,
			AddressSegmentCreator<S> segmentCreator,
			IntFunction<Iterator<S>> segIteratorProducer,
			int networkSegmentIndex,
			int hostSegmentIndex,
			IntFunction<Iterator<S>> prefixedSegIteratorProducer) {
		return segmentsIterator(
				divCount, segmentCreator, null, segIteratorProducer, null,
				networkSegmentIndex,
				hostSegmentIndex,
				prefixedSegIteratorProducer);
	}
	
	// this one is used by the sequential ranges
	static <T extends Address, S extends AddressSegment> Iterator<T> iterator(
			T original,
			AddressCreator<T, ?, ?, S> creator,
			Iterator<S[]> iterator) {
		return iterator(original != null, original, creator, iterator, null);
	}
	
	@FunctionalInterface
	static interface SeqRangeIteratorProvider<S, T> extends IteratorProvider<S,T>{}
	static class IPAddressSeqRangeSpliterator<S extends AddressComponentRange, T> extends AddressItemRangeSpliterator<S, T> implements IPAddressSeqRangeSplitterSink<S, T> {
		
		final Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter;
		
		IPAddressSeqRangeSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
				SeqRangeIteratorProvider<S, T> iteratorProvider,
				ToLongFunction<S> longSizer) {
			super(forIteration, null, iteratorProvider, null, null, longSizer);
			this.splitter = splitter;
		}
		
		IPAddressSeqRangeSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
				SeqRangeIteratorProvider<S, T> iteratorProvider,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, null, iteratorProvider, sizer, downSizer, longSizer);
			this.splitter = splitter;
		}
		
		IPAddressSeqRangeSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
				SeqRangeIteratorProvider<S, T> iteratorProvider,
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, null, iteratorProvider, isLowest, false, sizer, downSizer, longSizer);
			this.splitter = splitter;
		}
		
		@Override
		protected boolean split() {
			return splitter.test(this);
		}
		
		@Override
		protected IPAddressSeqRangeSpliterator<S, T> createSpliterator(
				S split, 
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			return new IPAddressSeqRangeSpliterator<S, T>(split, splitter, (SeqRangeIteratorProvider<S, T>) iteratorProvider, isLowest, sizer, downSizer, longSizer);
		}
	}
	
	static class IPAddressSeqRangePrefixSpliterator<S extends AddressComponentRange> 
		extends IPAddressSeqRangeSpliterator<S, S> implements AddressComponentSpliterator<S> {
		
		IPAddressSeqRangePrefixSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
				SeqRangeIteratorProvider<S, S> iteratorProvider,
				ToLongFunction<S> longSizer) {
			super(forIteration, splitter, iteratorProvider, longSizer);
		}
		
		IPAddressSeqRangePrefixSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
				SeqRangeIteratorProvider<S, S> iteratorProvider,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, splitter, iteratorProvider, sizer, downSizer, longSizer);
		}
		
		IPAddressSeqRangePrefixSpliterator(
				S forIteration,
				Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
				SeqRangeIteratorProvider<S, S> iteratorProvider,
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			super(forIteration, splitter, iteratorProvider, isLowest, sizer, downSizer, longSizer);
		}
		
		@Override
		protected IPAddressSeqRangePrefixSpliterator<S> createSpliterator(
				S split, 
				boolean isLowest,
				Function<S, BigInteger> sizer,
				Predicate<S> downSizer,
				ToLongFunction<S> longSizer) {
			return new IPAddressSeqRangePrefixSpliterator<S>(split, splitter, (SeqRangeIteratorProvider<S, S>) iteratorProvider, isLowest, sizer, downSizer, longSizer);
		}
		
		@Override
		public IPAddressSeqRangePrefixSpliterator<S> trySplit() {
			return (IPAddressSeqRangePrefixSpliterator<S>) super.trySplit();
		}
	}
	
	@Override
	public abstract IPAddressSection increment(long increment);
	
	@Override
	public abstract IPAddressSection incrementBoundary(long increment);
	
	public boolean isEntireAddress() {
		return getSegmentCount() == IPAddress.getSegmentCount(getIPVersion());
	}
	
	protected boolean isMultiple(int segmentCount) {
		for(int i = 0; i < segmentCount; i++) {
			if(getSegment(i).isMultiple()) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Returns whether this section has a prefix length and if so, 
	 * whether the host section is zero for this section or all sections in this set of address sections.
	 * If the host section is zero length (there are no host bits at all), returns false.
	 * 
	 * @return
	 */
	public boolean isZeroHost() {
		if(!isPrefixed()) {
			return false;
		}
		return isZeroHost(getNetworkPrefixLength());
	}
	
	/**
	 * Returns whether the host is zero for the given prefix length for this section or all sections in this set of address sections.
	 * If this section already has a prefix length, then that prefix length is ignored.
	 * If the host section is zero length (there are no host bits at all), returns false.
	 * 
	 * @return
	 */
	public boolean isZeroHost(int prefixLength) {
		if(prefixLength < 0 || prefixLength > getBitCount()) {
			throw new PrefixLenException(this, prefixLength);
		}
		return isZeroHost(prefixLength, getSegments(), getBytesPerSegment(), getBitsPerSegment(), getBitCount());
	}
	
	protected <S extends IPAddressSegment> boolean isZeroHost(S segments[]) {
		if(!isPrefixed()) {
			return false;
		}
		return isZeroHost(getNetworkPrefixLength(), segments, getBytesPerSegment(), getBitsPerSegment(), getBitCount());
	}
	
	protected <S extends IPAddressSegment> boolean isZeroHost(S segments[], int prefixLength) {
		return isZeroHost(prefixLength, segments, getBytesPerSegment(), getBitsPerSegment(), getBitCount());
	}
	
	protected static <S extends IPAddressSegment> boolean isZeroHost(int prefLen, S segments[], int bytesPerSegment, int bitsPerSegment, int bitCount) {
		if(segments.length == 0 ) {
			return false;
		}
		if(prefLen >= bitCount) {
			return false;
		}
		int divCount = segments.length;
		int prefixedSegmentIndex = getHostSegmentIndex(prefLen, bytesPerSegment, bitsPerSegment);
		for(int i = prefixedSegmentIndex; i < divCount; i++) {
			Integer segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefLen, prefixedSegmentIndex);
			S div = segments[i];
			if(segmentPrefixLength != null) {
				int mask = div.getSegmentHostMask(segmentPrefixLength);
				if(div.isMultiple() || (mask & div.getSegmentValue()) != 0) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = segments[i];
					if(!div.isZero()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	InetAddress toInetAddress(IPAddress address) {
		InetAddress result;
		if(hasNoValueCache() || (result = valueCache.inetAddress) == null) {
			valueCache.inetAddress = result = address.toInetAddressImpl();
		}
		return result;
	}
	
	////////////////string creation below ///////////////////////////////////////////////////////////////////////////////////////////
	static void checkLengths(int length, StringBuilder builder) {
		IPAddressStringParams.checkLengths(length, builder);
	}
	
	@Override
	public String toString() {
		return toNormalizedString();//for ipv6, the canonical string can be the same for two different sections
	}
	@Override
	public String[] getSegmentStrings() {
		return getDivisionStrings();
	}
	
	protected abstract void cacheNormalizedString(String str);
	
	protected abstract IPStringCache getStringCache();
	
	protected abstract boolean hasNoStringCache();
	
	/*
	 * There are two approaches when going beyond the usual segment by segment approach to producing strings for IPv6 and IPv4.
	 * We can use the inet_aton approach, creating new segments as desired (one, two or three segments instead of the usual 4).
	 * Then each such segment must simply know it's own sizes, whether bits, bytes, or characters, as IPAddressJoinedSegments and its subclasses show.
	 * The limitations to this are the fact that arithmetic is done with Java longs, limiting the possible sizes.  Also, we must define new classes to accommodate the new segments.
	 * A disadvantage to this approach is that the new segments may be short lived, so any caching is not helpful.
	 * 
	 * The second approach is to print with no separator chars (no '.' or ':') and with leading zeros, but otherwise print in the same manner.
	 * So 1:2 would become 00010002.  
	 * This works in cases where the string character boundaries line up with the segment boundaries.
	 * This works for hexadecimal, where each segment is exactly two characters for IPv4, and each segment is exactly 4 characters for IPv6.
	 * For other radices, this is not so simple.
	 * 
	 * A hybrid approach would use both approaches.  For instance, for octal we could simply divide into segments where each segment has 6 bits,
	 * corresponding to exactly two octal characters, or any combination where each segment has some multiple of 3 bits.  It helps if the segment bit length
	 * divides the total bit length, so the first segment does not end up with too many leading zeros.  
	 * In the cases where the above approaches do not work, this approach works.
	 */
	
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = getStringCache().binaryString) == null) {
			IPStringCache stringCache = getStringCache();
			stringCache.binaryString = result = toBinaryString(null);
		}
		return result;
	}
	
	protected String toBinaryString(CharSequence zone) {
		if(isDualString()) {
			return toNormalizedStringRange(toIPParams(IPStringCache.binaryParams), getLower(), getUpper(), zone);
		}
		return toIPParams(IPStringCache.binaryParams).toString(this, zone);
	}
	
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {  
		String result;
		if(hasNoStringCache() || (result = (with0Prefix ? getStringCache().octalStringPrefixed : getStringCache().octalString)) == null) {
			IPStringCache stringCache = getStringCache();
			result = toOctalString(with0Prefix, null);
			if(with0Prefix) {
				stringCache.octalStringPrefixed = result;
			} else {
				stringCache.octalString = result;
			}
		}
		return result;
	}
	
	protected String toOctalString(boolean with0Prefix, CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			IPAddressSection lower = getLower();
			IPAddressSection upper = getUpper();
			IPAddressBitsDivision lowerDivs[] = lower.createNewDivisions(3, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
			IPAddressStringDivisionSeries lowerPart = new IPAddressDivisionGrouping(lowerDivs, getNetwork());
			IPAddressBitsDivision upperDivs[] = upper.createNewDivisions(3, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
			IPAddressStringDivisionSeries upperPart = new IPAddressDivisionGrouping(upperDivs, getNetwork());
			return toNormalizedStringRange(toIPParams(with0Prefix ? IPStringCache.octalPrefixedParams : IPStringCache.octalParams), lowerPart, upperPart, zone);
		}
		IPAddressBitsDivision divs[] = createNewPrefixedDivisions(3, null, null, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
		IPAddressStringDivisionSeries part = new IPAddressDivisionGrouping(divs, getNetwork());
		return toIPParams(with0Prefix ? IPStringCache.octalPrefixedParams : IPStringCache.octalParams).toString(part, zone);
	}
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {  
		String result;
		if(hasNoStringCache() || (result = (with0xPrefix ? getStringCache().hexStringPrefixed : getStringCache().hexString)) == null) {
			IPStringCache stringCache = getStringCache();
			result = toHexString(with0xPrefix, null);
			if(with0xPrefix) {
				stringCache.hexStringPrefixed = result;
			} else {
				stringCache.hexString = result;
			}
		}
		return result;
	}
	
	//overridden in ipv6 to handle zone
	protected String toHexString(boolean with0xPrefix, CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			return toNormalizedStringRange(toIPParams(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams), getLower(), getUpper(), zone);
		}
		return toIPParams(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams).toString(this, zone);
	}
	
	@Override
	public String toNormalizedString(IPStringOptions stringOptions) {
		return toNormalizedString(stringOptions, this);
	}
	public static String toNormalizedString(IPStringOptions opts, IPAddressStringDivisionSeries section) {
		return toIPParams(opts).toString(section);
	}
	protected static IPAddressStringParams<IPAddressStringDivisionSeries> toIPParams(IPStringOptions opts) {
		//since the params here are not dependent on the section, we could cache the params in the options 
		//this is not true on the IPv6 side where compression settings change based on the section
		
		@SuppressWarnings("unchecked")
		IPAddressStringParams<IPAddressStringDivisionSeries> result = (IPAddressStringParams<IPAddressStringDivisionSeries>) getCachedParams(opts);
			
		if(result == null) {
			result = new IPAddressStringParams<IPAddressStringDivisionSeries>(opts.base, opts.separator, opts.uppercase);
			result.expandSegments(opts.expandSegments);
			result.setWildcards(opts.wildcards);
			result.setWildcardOption(opts.wildcardOption);
			result.setSegmentStrPrefix(opts.segmentStrPrefix);
			result.setAddressSuffix(opts.addrSuffix);
			result.setAddressLabel(opts.addrLabel);
			result.setReverse(opts.reverse);
			result.setSplitDigits(opts.splitDigits);
			result.setZoneSeparator(opts.zoneSeparator);
			setCachedParams(opts, result);
		}
		return result;
	}
		
	/**
	 * Returns at most a couple dozen string representations:
	 * 
	 * -mixed (1:2:3:4:5:6:1.2.3.4)
	 * -upper and lower case
	 * -full compressions or no compression (a:0:0:c:d:0:e:f or a::c:d:0:e:f or a:0:b:c:d::e:f)
	 * -full leading zeros (000a:0000:000b:000c:000d:0000:000e:000f)
	 * -combinations thereof
	 * 
	 * @return
	 */
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(new IPStringBuilderOptions(IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS));
	}
	/**
	 * Use this method with care...  a single IPv6 address can have thousands of string representations.
	 * 
	 * Examples: 
	 * "::" has 1297 such variations, but only 9 are considered standard
	 * "a:b:c:0:d:e:f:1" has 1920 variations, but only 12 are standard
	 * 
	 * Variations included in this method:
	 * -all standard variations
	 * -choosing specific segments for full leading zeros (::a:b can be ::000a:b, ::a:000b, or ::000a:000b)
	 * -choosing which zero-segments to compress (0:0:a:: can be ::a:0:0:0:0:0 or 0:0:a::)
	 * -mixed representation (1:2:3:4:5:6:1.2.3.4)
	 * -all combinations of such variations
	 * 
	 * Variations omitted from this method: 
	 * -mixed case of a-f, which you can easily handle yourself with String.equalsIgnoreCase
	 * -adding a variable number of leading zeros (::a can be ::0a, ::00a, ::000a)
	 * -choosing any number of zero-segments anywhere to compress (:: can be 0:0:0::0:0)
	 * 
	 * @return
	 */
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(new IPStringBuilderOptions(IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS));
	}
	
	/**
	 * Returns a set of strings for search the standard string representations in a database
	 * 
	 * -compress the largest compressible segments or no compression (a:0:0:c:d:0:e:f or a::c:d:0:e:f)
	 * -upper/lowercase is not considered because many databases are case-insensitive
	 * 
	 * @return
	 */
	public IPAddressPartStringCollection toDatabaseSearchStringCollection() {
		return toStringCollection(new IPStringBuilderOptions());
	}
	
	/**
	 * Get all representations of this address including this IPAddressSection.  
	 * This includes:
	 * <ul>
	 * <li>alternative segment groupings expressed as {@link IPAddressDivisionGrouping}</li>
	 * <li>conversions to IPv6, and alternative representations of those IPv6 addresses</li>
	 * </ul>
	 * 
	 * @param options
	 * @return
	 */
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		if(options.includes(IPStringBuilderOptions.BASIC)) {
			return new IPAddressStringDivisionSeries[] { this };
		}
		return EMPTY_PARTS;
	}
	
	/**
	 * This method gives you an SQL clause that allows you to search the database for the front part of an address or 
	 * addresses in a given network.
	 * 
	 * This is not as simple as it sounds, because the same address can be written in different ways (especially for IPv6)
	 * and in addition, addresses in the same network can have different beginnings (eg 1.0.0.0/7 are all addresses from 0.0.0.0 to 1.255.255.255),
	 * so you can see they start with both 1 and 0.  You can reduce the number of possible beginnings by choosing a segment
	 * boundary for the network prefix.
	 * 
	 * The SQL produced works for MySQL.  For a different database type, 
	 * use {@link #getStartsWithSQLClause(StringBuilder, String, IPAddressSQLTranslator)}
	 * 
	 * @param builder
	 * @param expression the expression that must match the condition, whether a column name or other
	 */
	public void getStartsWithSQLClause(StringBuilder builder, String expression) {
		getStartsWithSQLClause(builder, expression, new MySQLTranslator());
	}
	
	public void getStartsWithSQLClause(StringBuilder builder, String expression, IPAddressSQLTranslator translator) {
		getStartsWithSQLClause(builder, expression, true, translator);
	}
	
	private void getStartsWithSQLClause(StringBuilder builder, String expression, boolean isFirstCall, IPAddressSQLTranslator translator) {
		if(isFirstCall && isMultiple()) {
			Iterator<? extends IPAddressSection> sectionIterator = iterator();
			builder.append('(');
			boolean isNotFirst = false;
			while(sectionIterator.hasNext()) {
				if(isNotFirst) {
					builder.append(" OR ");
				} else {
					isNotFirst = true;
				}
				IPAddressSection next = sectionIterator.next();
				next.getStartsWithSQLClause(builder, expression, false, translator);
			}
			builder.append(')');
		} else if(getSegmentCount() > 0) { //there is something to match and we are searching for an exact network prefix	
			IPAddressPartStringCollection createdStringCollection = toDatabaseSearchStringCollection();
			boolean isNotFirst = false;
			if(createdStringCollection.size() > 1) {
				builder.append('(');
			}
			boolean isEntireAddress = isEntireAddress();
			//for every string representation of our address section in the collection, we get an SQL clause that will match it
			for(IPAddressPartConfiguredString<?, ?> createdStr: createdStringCollection) {
				if(isNotFirst) {
					builder.append(" OR ");
				} else {
					isNotFirst = true;
				}
				SQLStringMatcher<?, ?, ?> matcher = createdStr.getNetworkStringMatcher(isEntireAddress, translator);
				matcher.getSQLCondition(builder.append('('), expression).append(')');
			}
			if(createdStringCollection.size() > 1) {
				builder.append(')');
			}
		}
	}
	/* the various string representations - these fields are for caching */
	protected static class IPStringCache extends StringCache {
		public static final IPStringOptions hexParams;
		public static final IPStringOptions hexPrefixedParams;
		public static final IPStringOptions octalParams;
		public static final IPStringOptions octalPrefixedParams;
		public static final IPStringOptions binaryParams;
		public static final IPStringOptions canonicalSegmentParams;
		static {
			WildcardOptions allWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL);
			hexParams = new IPStringOptions.Builder(16).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).toOptions();
			hexPrefixedParams = new IPStringOptions.Builder(16).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).setAddressLabel(IPAddress.HEX_PREFIX).toOptions();
			octalParams = new IPStringOptions.Builder(8).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).toOptions();
			octalPrefixedParams = new IPStringOptions.Builder(8).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).setAddressLabel(IPAddress.OCTAL_PREFIX).toOptions();
			binaryParams = new IPStringOptions.Builder(2).setSeparator(null).setExpandedSegments(true).setWildcardOptions(allWildcards).toOptions();
			canonicalSegmentParams = new IPStringOptions.Builder(10, ' ').toOptions();
		}
		
		public String normalizedWildcardString;
		public String fullString;
		public String sqlWildcardString;
		public String reverseDNSString;
		
		public String octalStringPrefixed;
		public String octalString;
		public String binaryString;
		
		public String segmentedBinaryString;
	}
	
	public static class WildcardOptions {
		public enum WildcardOption {
			NETWORK_ONLY, //only print wildcards that are part of the network portion (only possible with subnet address notation, otherwise this option is ignored)
			ALL //print wildcards for any visible (non-compressed) segments
		}
		
		public final WildcardOption wildcardOption;
		public final Wildcards wildcards;
		
		public WildcardOptions() {
			this(WildcardOption.NETWORK_ONLY);
		}
		
		public WildcardOptions(WildcardOption wildcardOption) {
			this(wildcardOption, new Wildcards());
		}
		
		public WildcardOptions(WildcardOption wildcardOption, Wildcards wildcards) {
			this.wildcardOption = wildcardOption;
			this.wildcards = wildcards;
		}
	}
	/**
	 * Represents a clear way to create a specific type of string.
	 * 
	 * @author sfoley
	 */
	public static class IPStringOptions extends StringOptions {
		
		public final String addrSuffix;
		public final WildcardOption wildcardOption;
		public final char zoneSeparator;
		
		protected IPStringOptions(
				int base,
				boolean expandSegments,
				WildcardOption wildcardOption,
				Wildcards wildcards,
				String segmentStrPrefix,
				Character separator,
				char zoneSeparator,
				String label,
				String suffix,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			super(base, expandSegments, wildcards, segmentStrPrefix, separator, label, reverse, splitDigits, uppercase);
			this.addrSuffix = suffix;
			this.wildcardOption = wildcardOption;
			this.zoneSeparator = zoneSeparator;
		}
		
		public static class Builder extends StringOptions.Builder {
			protected String addrSuffix = "";
			protected WildcardOption wildcardOption = WildcardOption.NETWORK_ONLY;
			protected char zoneSeparator = IPv6Address.ZONE_SEPARATOR;
			
			public Builder(int base) {
				this(base, ' ');
			}
			
			protected Builder(int base, char separator) {
				super(base, separator);
			}
			
			@Override
			public Builder setWildcards(Wildcards wildcards) {
				return (Builder) super.setWildcards(wildcards);
			}
			
			/*
			 * .in-addr.arpa, .ip6.arpa, .ipv6-literal.net are examples of suffixes tacked onto the end of address strings
			 */
			public Builder setAddressSuffix(String suffix) {
				this.addrSuffix = suffix;
				return this;
			}
			
			public Builder setWildcardOptions(WildcardOptions wildcardOptions) {
				setWildcardOption(wildcardOptions.wildcardOption);
				return setWildcards(wildcardOptions.wildcards);
			}
			
			public Builder setWildcardOption(WildcardOption wildcardOption) {
				this.wildcardOption = wildcardOption;
				return this;
			}
			
			@Override
			public Builder setReverse(boolean reverse) {
				return (Builder) super.setReverse(reverse);
			}
			
			@Override
			public Builder setUppercase(boolean uppercase) {
				return (Builder) super.setUppercase(uppercase);
			}
			
			@Override
			public Builder setSplitDigits(boolean splitDigits) {
				return (Builder) super.setSplitDigits(splitDigits);
			}
			
			@Override
			public Builder setExpandedSegments(boolean expandSegments) {
				return (Builder) super.setExpandedSegments(expandSegments);
			}
			
			@Override
			public Builder setRadix(int base) {
				return (Builder) super.setRadix(base);
			}
			
			/*
			 * separates the divisions of the address, typically ':' or '.', but also can be null for no separator
			 */
			@Override
			public Builder setSeparator(Character separator) {
				return (Builder) super.setSeparator(separator);
			}
			
			public Builder setZoneSeparator(char separator) {
				this.zoneSeparator = separator;
				return this;
			}
			
			@Override
			public Builder setAddressLabel(String label) {
				return (Builder) super.setAddressLabel(label);
			}
			
			@Override
			public Builder setSegmentStrPrefix(String prefix) {
				return (Builder) super.setSegmentStrPrefix(prefix);
			}
			
			@Override
			public IPStringOptions toOptions() {
				return new IPStringOptions(base,
						expandSegments, wildcardOption, wildcards, segmentStrPrefix, separator, zoneSeparator, addrLabel, addrSuffix, reverse, splitDigits, uppercase);
			}
		}
	}
	
	/**
	 * This user-facing class is designed to be a clear way to create a collection of strings.
	 * 
	 * @author sfoley
	 *
	 */
	public static class IPStringBuilderOptions {
		public static final int BASIC = 0x1;//no compressions, lowercase only, no leading zeros, no mixed, no nothing
		
		public static final int LEADING_ZEROS_FULL_ALL_SEGMENTS = 0x10; //0001:0002:00ab:0abc::
		public static final int LEADING_ZEROS_FULL_SOME_SEGMENTS = 0x20 | LEADING_ZEROS_FULL_ALL_SEGMENTS; //1:0002:00ab:0abc::, 0001:2:00ab:0abc::, ...
		public static final int LEADING_ZEROS_PARTIAL_SOME_SEGMENTS = 0x40 | LEADING_ZEROS_FULL_SOME_SEGMENTS; //1:02:00ab:0abc::, 01:2:00ab:0abc::, ...
		public final int options;
		
		public IPStringBuilderOptions() {
			this(BASIC);
		}
		
		public IPStringBuilderOptions(int options) {
			this.options = options;
		}
		
		public boolean includes(int option) {
			return (option & options) == option;
		}
		
		public boolean includesAny(int option) {
			return (option & options) != 0;
		}
		
		@Override
		public String toString() {
			TreeMap<Integer, String> options = new TreeMap<>();
			Field fields[] = getClass().getFields();
			for(Field field: fields) {
				int modifiers = field.getModifiers();
				if(Modifier.isFinal(modifiers) && Modifier.isStatic(modifiers)) {
					try {
						int constant = field.getInt(null);
						String option = field.getName() + ": " + includes(constant) + System.lineSeparator();
						options.put(constant, option);
					} catch(IllegalAccessException e) {}
				}
			}
			Collection<String> values = options.values(); //the iterator for this Collection is sorted since we use a SortedMap
			StringBuilder builder = new StringBuilder();
			for(String val : values) {
				builder.append(val);
			}
			return builder.toString();
		}
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.math.BigInteger;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Stream;
import inet.ipaddr.AddressComparator.CountComparator;
import inet.ipaddr.AddressComparator.ValueComparator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
/**
 * An address, or a collection of multiple addresses.  Each segment can represent a single value or a range of values.
 * <p>
 * To construct one from a {@link java.lang.String} use 
 * {@link inet.ipaddr.IPAddressString} or  {@link inet.ipaddr.MACAddressString}
 * 
 * @custom.core
 * @author sfoley
 *
 */
public abstract class Address implements AddressSegmentSeries {
	private static final long serialVersionUID = 4L;
	/**
	 * @custom.core
	 * @author sfoley
	 *
	 */
	public static interface AddressValueProvider {
		
		int getSegmentCount();
		SegmentValueProvider getValues();
		
		default SegmentValueProvider getUpperValues() {
			return getValues();
		}
	}
	/**
	 * @custom.core
	 * @author sfoley
	 *
	 */
	@FunctionalInterface
	public static interface SegmentValueProvider {
		int getValue(int segmentIndex);
	}
	public static final String HEX_PREFIX = "0x";
	public static final String OCTAL_PREFIX = "0";
	public static final char RANGE_SEPARATOR = '-';
	public static final String RANGE_SEPARATOR_STR = String.valueOf(RANGE_SEPARATOR);
	public static final char ALTERNATIVE_RANGE_SEPARATOR = '\u00bb'; //'»'; javadoc whines about this char
	public static final String ALTERNATIVE_RANGE_SEPARATOR_STR = String.valueOf(ALTERNATIVE_RANGE_SEPARATOR);
	public static final char SEGMENT_WILDCARD = '*';
	public static final String SEGMENT_WILDCARD_STR = String.valueOf(SEGMENT_WILDCARD);
	public static final String ALTERNATIVE_SEGMENT_WILDCARD_STR = "¿";
	public static final char SEGMENT_SQL_WILDCARD = '%';
	public static final String SEGMENT_SQL_WILDCARD_STR = String.valueOf(SEGMENT_SQL_WILDCARD);
	public static final char SEGMENT_SQL_SINGLE_WILDCARD = '_';
	public static final String SEGMENT_SQL_SINGLE_WILDCARD_STR = String.valueOf(SEGMENT_SQL_SINGLE_WILDCARD);
	public static final AddressComparator DEFAULT_ADDRESS_COMPARATOR = new CountComparator(true);
	public static final AddressComparator ADDRESS_LOW_VALUE_COMPARATOR = new ValueComparator(true, false);
	public static final AddressComparator ADDRESS_HIGH_VALUE_COMPARATOR = new ValueComparator(true, true);
	private static MACAddressNetwork macNetwork;
	private static IPv6AddressNetwork ipv6Network;
	private static IPv4AddressNetwork ipv4Network;
	/* the segments.  For IPv4, each element is actually just 1 byte and the array has 4 elements, 
	 * while for IPv6, each element is 2 bytes and the array has 8 elements. */
	final AddressSection addressSection;
	/* an object encapsulating a string representing the address, which is the one used to construct the address if the address was constructed from a string */
	protected HostIdentifierString fromString;
	/**
	 * Constructs an address.
	 * @param section the address segments
	 */
	protected Address(AddressSection section) {
		addressSection = section;
		if(!getNetwork().isCompatible(addressSection.getNetwork())) {
			throw new NetworkMismatchException(addressSection);
		}
	}
	protected Address(Function<Address, AddressSection> supplier) {
		addressSection = supplier.apply(this);
		if(!getNetwork().isCompatible(addressSection.getNetwork())) {
			throw new NetworkMismatchException(addressSection);
		}
	}
	public static IPv6AddressNetwork defaultIpv6Network() {
		if(ipv6Network == null) {
			synchronized(Address.class) {
				if(ipv6Network == null) {
					ipv6Network = new IPv6AddressNetwork();
				}
			}
		}
		return ipv6Network;
	}
	public static IPv4AddressNetwork defaultIpv4Network() {
		if(ipv4Network == null) {
			synchronized(Address.class) {
				if(ipv4Network == null) {
					ipv4Network = new IPv4AddressNetwork();
				}
			}
		}
		return ipv4Network;
	}
	
	public static MACAddressNetwork defaultMACNetwork() {
		if(macNetwork == null) {
			synchronized(Address.class) {
				if(macNetwork == null) {
					macNetwork = new MACAddressNetwork();
				}
			}
		}
		return macNetwork;
	}
	protected static String getMessage(String key) {
		return HostIdentifierException.getMessage(key);
	}
	@Override
	public int getSegmentCount() {
		return getSection().getSegmentCount();
	}
	
	@Override
	public int getDivisionCount() {
		return getSection().getDivisionCount();
	}
	
	@Override
	public int getBitCount() {
		return getSection().getBitCount();
	}
	@Override
	public int getByteCount() {
		return getSection().getByteCount();
	}
	@Override
	public AddressSection getSection() {
		return addressSection;
	}
	@Override
	public void getSegments(AddressSegment segs[]) {
		getSection().getSegments(segs);
	}
	@Override
	public void getSegments(int start, int end, AddressSegment segs[], int index) {
		getSection().getSegments(start, end, segs, index);
	}
	@Override
	public abstract Iterable<? extends Address> getIterable();
	@Override
	public abstract Iterator<? extends Address> iterator();
	
	@Override
	public abstract AddressComponentSpliterator<? extends Address> spliterator();
	@Override
	public abstract Stream<? extends Address> stream();
	@Override
	public abstract Iterator<? extends Address> prefixIterator();
	
	@Override
	public abstract AddressComponentSpliterator<? extends Address> prefixSpliterator();
	@Override
	public abstract Stream<? extends Address> prefixStream();
	@Override
	public abstract Iterator<? extends Address> prefixBlockIterator();
	
	@Override
	public abstract AddressComponentSpliterator<? extends Address> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends Address> prefixBlockStream();
	@Override
	public abstract Address increment(long increment) throws AddressValueException;
	
	@Override
	public abstract Address incrementBoundary(long increment) throws AddressValueException;
	
	@Override
	public abstract Address getLower();
	
	@Override
	public abstract Address getUpper();
	/**
	 * Returns whether this address represents more than a single individual address, whether it is a subnet.
	 * 
	 * Such addresses include CIDR/IP addresses (eg 1.2.3.0/25) or wildcard addresses (eg 1.2.*.4) or range addresses (eg 1.2.3-4.5)
	 * 
	 * @return whether this address represents more than one address.
	 */
	@Override
	public boolean isMultiple() {
		return getSection().isMultiple();
	}
	/**
	 * Returns whether this address has an associated prefix length
	 * 
	 * @return whether this address has an associated prefix length
	 */
	@Override
	public boolean isPrefixed() {
		return getSection().isPrefixed();
	}
	/**
	 * Returns whether this address is an IP address
	 * 
	 * @return whether this address is an IP address
	 */
	public boolean isIPAddress() {
		return false;
	}
	/**
	 * Returns whether this address is a MAC address
	 * 
	 * @return whether this address is a MAC address
	 */
	public boolean isMACAddress() {
		return false;
	}
	/**
	 * If this address is an IP address, returns that {@link IPAddress}.  Otherwise, returns null.
	 * 
	 * @return the IP address
	 */
	public IPAddress toIPAddress() {
		return null;
	}
	/**
	 * If this address is a MAC address, returns that {@link MACAddress}.  Otherwise, returns null.
	 * 
	 * @return the MAC address
	 */
	public MACAddress toMACAddress() {
		return null;
	}
	/**
	 * the largest number of high bits for which this address represents all addresses with the same set of high bits
	 */
	@Override
	public Integer getPrefixLength() {
		return getSection().getPrefixLength();
	}
	/**
	 * Returns the smallest prefix length possible such that this includes the block of addresses for that prefix.
	 * <p>
	 * If the entire range can be dictated this way, then this method returns the same value as {@link #getPrefixLengthForSingleBlock()}.  
	 * Otherwise, this method will return the minimal possible prefix that can be paired with this address, while {@link #getPrefixLengthForSingleBlock()} will return null.
	 *<p>
	 * In cases where the final bit in this address division series is constant, this returns the bit length of this address division series.
	 *
	 * @return the prefix length
	 */
	@Override
	public int getMinPrefixLengthForBlock() {
		return getSection().getMinPrefixLengthForBlock();
	}
	/**
	 * Returns a prefix length for which the range of this address subnet matches the block of addresses for that prefix.
	 * <p>
	 * If the range can be dictated this way, then this method returns the same value as {@link #getMinPrefixLengthForBlock()}.
	 * <p>
	 * If no such prefix exists, returns null.
	 * <p>
	 * If this segment grouping represents a single value, returns the bit length of this address division series.
	 * <p>
	 * IP address examples:
	 * 1.2.3.4 returns 32
	 * 1.2.*.* returns 16
	 * 1.2.*.0/24 returns 16 in the case of PrefixConfiguration == ALL_PREFIXES_ARE_SUBNETS, 32 otherwise
	 * 1.2.*.4 returns null
	 * 1.2.252-255.* returns 22
	 * 1.2.3.4/x returns x in the case of PrefixConfiguration == ALL_PREFIXES_ARE_SUBNETS, 32 otherwise
	 * 1.2.0.0/16 returns 16 in the case of PrefixConfiguration == ALL_PREFIXES_ARE_SUBNETS or PREFIXED_ZERO_HOSTS_ARE_SUBNETS, 32 otherwise
	 * 
	 * @return the prefix length or null if it does not exist
	 */
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		return getSection().getPrefixLengthForSingleBlock();
	}
	
	/**
	 * Whether the MAC address or IP address or other form of address is multicast.
	 * 
	 * @see java.net.InetAddress#isMulticastAddress()
	 */
	public abstract boolean isMulticast();
	
	/**
	 * Gets the count of addresses that this address may represent.
	 * 
	 * If this address is not a subnet block of multiple addresses or has no range of values, then there is only one such address.
	 * 
	 * @return
	 */
	@Override
	public BigInteger getCount() {
		return getSection().getCount();
	}
	
	/**
	 * Gets the count of prefixes in this address for the given prefix length.
	 * 
	 * If this address is not a subnet block of multiple addresses or has no range of values, then there is only one.
	 * 
	 * @return
	 */
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		return getSection().getPrefixCount(prefixLength);
	}
	/**
	 * If this has a prefix length, the count of the range of values in the prefix.
	 * 
	 * If this has no prefix, returns the same value as {@link #getCount()}
	 * 
	 * @return
	 */
	@Override
	public BigInteger getPrefixCount() {
		return getSection().getPrefixCount();
	}
	@Override
	public BigInteger getBlockCount(int segmentCount) {
		return getSection().getBlockCount(segmentCount);
	}
	@Override
	public byte[] getBytes() {
		return getSection().getBytes();
	}
	@Override
	public byte[] getBytes(byte bytes[]) {
		return getSection().getBytes(bytes);
	}
	@Override
	public byte[] getBytes(byte bytes[], int index) {
		return getSection().getBytes(bytes, index);
	}
	/**
	 * Gets the bytes for the highest address in the range of addresses represented by this address instance.
	 * 
	 * @return
	 */
	@Override
	public byte[] getUpperBytes() {
		return getSection().getUpperBytes();
	}
	@Override
	public byte[] getUpperBytes(byte bytes[]) {
		return getSection().getUpperBytes(bytes);
	}
	@Override
	public byte[] getUpperBytes(byte bytes[], int index) {
		return getSection().getUpperBytes(bytes, index);
	}
	@Override
	public BigInteger getValue() {
		return getSection().getValue();
	}
	
	@Override
	public BigInteger getUpperValue() {
		return getSection().getUpperValue();
	}
	@Override
	public boolean isZero() {
		return getSection().isZero();
	}
	
	@Override
	public boolean includesZero() {
		return getSection().includesZero();
	}
	
	@Override
	public boolean isMax() {
		return getSection().isMax();
	}
	
	@Override
	public boolean includesMax() {
		return getSection().includesMax();
	}
	
	@Override
	public boolean isFullRange() {
		return getSection().isFullRange();
	}
	
	/**
	 * Whether the address can be considered a local address (as opposed to a global one)
	 * @return
	 */
	public abstract boolean isLocal();
	
	@Override
	public int hashCode() {
		return getSection().hashCode();
	}
	protected abstract boolean isFromSameString(HostIdentifierString otherString);
	
	public boolean isSameAddress(Address other) {
		return other == this || getSection().equals(other.getSection());
	}
	/**
	 * Two Address objects are equal if they represent the same set of addresses.
	 */
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof Address) {
			Address other = (Address) o;
			if(isFromSameString(other.fromString)) {
				return true;
			}
			return isSameAddress(other);
		}
		return false;
	}
	public boolean prefixEquals(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().prefixEquals(other.getSection());
	}
	/**
	 * Returns whether this is same type and version of the given address and whether it overlaps with the individual addresses in the given address or subnet,
	 * containing at least one individual address common to both.
	 * 
	 * 
	 * @param other
	 * @return
	 */
	public boolean overlaps(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().overlaps(other.getSection());
	}
	/**
	 * Returns whether this is same type and version of the given address and whether it contains all individual addresses in the given address or subnet
	 * 
	 * @param other
	 * @return
	 */
	public boolean contains(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().contains(other.getSection());
	}
	/**
	 * Indicates where an address sits relative to the subnet ordering.
	 * <p>
	 * Determines how many address elements of a subnet precede the given address element, if the address is in the subnet.
	 * If above the subnet range, it is the distance to the upper boundary added to the subnet address count less one, and if below the subnet range, the distance to the lower boundary.
	 * <p>
	 * In other words, if the given address is not in the subnet but above it, returns the number of addresses preceding the address from the upper subnet boundary, 
	 * added to one less than the total number of subnet addresses.  If the given address is not in the subnet but below it, returns the number of addresses following the address to the lower subnet boundary.
	 * <p>
	 * enumerate returns null when the argument is a multi-valued subnet. The argument must be an individual address.
	 * <p>
	 * When this address is also single-valued, the returned value is the distance (difference) between this address and the argument address.
	 * <p>
	 * enumerate is the inverse of the increment method:
	 * <ul><li>subnet.enumerate(subnet.increment(inc)) = inc</li>
	 * <li>subnet.increment(subnet.enumerate(newAddr)) = newAddr</li></ul>
	 * <p>
	 * If the given address does not have the same version or type as this subnet or address, then null is returned.
	 */
	public abstract BigInteger enumerate(Address other);
	@Override
	public boolean isSequential() {
		return getSection().isSequential();
	}
	/**
	 * Returns a host identifier string representation for this address,
	 * which will be already validated.
	 * 
	 * @return
	 */
	public HostIdentifierString toAddressString() {
		return fromString;
	}
	/**
	 * Writes this address as a single hexadecimal value with always the exact same number of characters, with or without a preceding 0x prefix.
	 * 
	 * If this section represents a range of values outside of the network prefix length, then this is printed as a range of two hex values.
	 */
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {
		return getSection().toHexString(with0xPrefix);
	}
	/**
	 * The normalized string returned by this method is a common and consistent representation of the address.
	 * <p>
	 * The string returned by this method is unique for each address.
	 */
	@Override
	public String toNormalizedString() {
		return getSection().toNormalizedString();
	}
	
	/**
	 * This produces a canonical string.
	 * <p>
	 * RFC 5952 describes canonical representations for Ipv6
	 * http://en.wikipedia.org/wiki/IPv6_address#Recommended_representation_as_text
	 * http://tools.ietf.org/html/rfc5952
	 * <p>
	 * Each address has a unique canonical string, not counting the prefix.  The prefix can cause two equal addresses to have different strings.
	 */
	@Override
	public String toCanonicalString() {
		return getSection().toCanonicalString();
	}
	
	/**
	 * Produce short strings for the address in the usual address format.
	 * 
	 * Each address has a unique compressed string.
	 * 
	 */
	@Override
	public String toCompressedString() {
		return getSection().toCompressedString();
	}
	
	@Override
	public String toString() {
		return toCanonicalString();
	}
	
	@Override
	public String[] getDivisionStrings() {
		return getSection().getDivisionStrings();
	}
	
	@Override
	public String[] getSegmentStrings() {
		return getSection().getSegmentStrings();
	}
	
	@Override
	public abstract Address reverseSegments();
	
	@Override
	public abstract Address reverseBits(boolean perByte);
	
	@Override
	public abstract Address reverseBytes();
	
	@Override
	public abstract Address reverseBytesPerSegment();
	
	/**
	 * Returns whether the address range has a prefix length and includes the block of values for its prefix length.
	 */
	@Override
	public boolean isPrefixBlock() {
		return getSection().isPrefixBlock();
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		return getSection().containsPrefixBlock(prefixLength);
	}
	
	/**
	 * Returns whether the address range the block of values for a single prefix identified by its prefix length.
	 * This is similar to {@link #isPrefixBlock()} except that it returns false when
	 * the subnet has multiple prefixes.
	 * 
	 * For instance, 1.*.*.* /16 return false for this method and returns true for {@link #isPrefixBlock()}
	 */
	@Override
	public boolean isSinglePrefixBlock() {
		return getSection().isSinglePrefixBlock();
	}
	
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		return getSection().containsSinglePrefixBlock(prefixLength);
	}
	@Override
	public abstract Address toPrefixBlock();
	
	@Override @Deprecated
	public abstract Address removePrefixLength();
	
	@Override
	public abstract Address withoutPrefixLength();
	
	@Override @Deprecated
	public abstract Address removePrefixLength(boolean zeroed);
	
	@Override
	public abstract Address adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	@Override
	public abstract Address adjustPrefixLength(int adjustment);
	@Override
	public abstract Address adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	public abstract Address setPrefixLength(int prefixLength);
	
	@Override
	public abstract Address setPrefixLength(int prefixLength, boolean zeroed);
	
	@Deprecated
	@Override
	public abstract Address applyPrefixLength(int networkPrefixLength);
	
	/** 
	 * Checks if the two arrays share the same list of addresses, subnets, or address collections, in any order, using address equality.
	 * The function can handle duplicates, ignoring them.
	 * @param addrs1
	 * @param addrs2
	 * @return
	 */
	public static boolean matchUnordered(Address addrs1[], Address addrs2[]) {
		int len1 = addrs1 == null ? 0 : addrs1.length;
		int len2 = addrs2 == null ? 0 : addrs2.length;
		boolean sameLen = len1 == len2;
		boolean result;
		if(len1 == 0 || len2 == 0) {
			result = sameLen;
		} else if(len1 == 1 && sameLen) {
			result = addrs1[0].equals(addrs2[0]);
		} else if(len1 == 2 && sameLen) {
			if(addrs1[0].equals(addrs2[0])) {
				result = addrs1[1].equals(addrs2[1]);
			} else if(result = addrs1[0].equals(addrs2[1])) {
				result = addrs1[1].equals(addrs2[0]);
			}
		} else {
			result = Objects.equals(asSet(addrs1), asSet(addrs2));
		}
		return result;
	}
	
	private static HashSet<Address> asSet(Address addrs[])  {
		int addrLen = addrs.length;
		if(addrLen > 0) {
			HashSet<Address> result = new HashSet<>();
			for(int i = 0; i < addrs.length; i++) {
				Address addr = addrs[i];
				result.add(addr);
			}
			return result;
		}
		return null;
	}
	
	/**
	 * Checks if the two arrays share the same ordered list of addresses, subnets, or address collections, using address equality.
	 * Duplicates are allowed, but must match their counterpart in the other array with each occurrence.
	 * @param addrs1
	 * @param addrs2
	 * @return
	 */
	public static boolean matchOrdered(Address addrs1[], Address addrs2[]) {
		int len1 = addrs1 == null ? 0 : addrs1.length;
		int len2 = addrs2 == null ? 0 : addrs2.length;
		if(len1 != len2) {
			return false;
		}
		for(int i = 0; i < len1; i++) {
			if(!addrs1[i].equals(addrs2[i])) {
				return false;
			}
		}
		return true;
	}
}
/*
 * Copyright 2016-2018 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.format.AddressItem;
public class PrefixLenException extends AddressValueException {
	private static final long serialVersionUID = 1L;
	
	static String getMessage(String key) {
		return AddressStringException.getMessage(key);
	}
	public PrefixLenException(int prefixLength) {
		super(errorMessage + " " + getMessage("ipaddress.error.prefixSize"));
	}
	
	public PrefixLenException(AddressItem one, int prefixLength) {
		super(one + ", " + errorMessage + " " + getMessage("ipaddress.error.prefixSize"));
	}
	
	public PrefixLenException(int prefixLength, IPVersion version) {
		super(version + " /" + prefixLength + ", " + errorMessage + " " + getMessage("ipaddress.error.prefixSize"));
	}
	
	public PrefixLenException(CharSequence prefixLength, IPVersion version, Throwable cause) {
		super(version + " /" + prefixLength + ", " + errorMessage + " " + getMessage("ipaddress.error.invalidCIDRPrefix"), cause);
	}
}
/*
 * Copyright 2016-2019 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.io.Serializable;
import java.util.Map;
import inet.ipaddr.Address.AddressValueProvider;
import inet.ipaddr.format.standard.AddressCreator;
/**
 * An object representing a collection of addresses.
 * <p>
 * It also encapsulates settings for handling all addresses in the network like the prefix configuration that determines certain properties of the addresses in the network.
 * <p>
 * If your use of the IPAddress library has non-default configuration settings in this AddressNetwork class, and within the same JVM the IPAddress library 
 * is being used elsewhere with different configuration settings, then you have two options available to you:
 * <p>
 * 1. Use classloaders to load the two uses of IPAddress in different classloaders, a common Java architecture that is part of the language itself to address just this issue
 * <p>
 * 2. Use your own network classes, and within them overide the configuration methods to return the values you desire.  
 * <p>
 * All access to the network classes is through public virtual accessor methods getNetwork or getXNetwork in the classes XAddress, XAddressSection, XAddressSegment
 * where X is one of MAC, IPv6, or IPv4.  So you need to subclass those classes, and then override those getNetwork and getXNetwork methods to return your own network instances.
 * There are a couple of other places to consider to ensure only your own network instances are used.  
 * XAddressString objects obtain their network object from the validation parameters supplied to the constructor, so you would customize those validation parameters as well.
 * The same is true for the HostName class, which uses an embedded address validation instance inside the host name parameters instance.  
 * Finally, the address generator/cache classes (that are nested classes that in the network) use validation parameters as well that would be customized to your own network instances.
 * <p>
 * Generally you would use the same network object for any given address type (ie one for IPv6, one for IPv4, one for MAC), although this is not necessary.  
 * However, it is necessary that the configuration is the same for any given address type.
 * <p>
 * Now suppose you wish to ensure any and all methods in this library create instances of your own subclasses of the XAddress, XAddressSection, XAddressSegment classes.
 * 
 * All internally created address components are created by the address creator instance owned by the network object.
 * So you override the getAddressCreator() in your new network classes to provide your own address creator object.
 * 
 * 
 * @author sfoley
 *
 */
public abstract class AddressNetwork<S extends AddressSegment> implements Serializable {
	private static final long serialVersionUID = 4L;
	public interface AddressSegmentCreator<S extends AddressSegment> {
		
		S[] createSegmentArray(int length);
		
		S createSegment(int value);
		
		S createSegment(int value, Integer segmentPrefixLength);
		
		S createSegment(int lower, int upper, Integer segmentPrefixLength);
	}
	public abstract AddressCreator<?, ?, ?, S> getAddressCreator();
	
	public void clearCaches() {
		getAddressCreator().clearCaches();
	}
	public void setSegmentCaching(boolean enable) {
		getAddressCreator().setSegmentCaching(enable);
	}
	//// Configuration
	
	/*
	 * a few sources about the network address - 
	 * https://superuser.com/questions/379451/why-can-a-network-address-not-be-a-valid-host-address
	 * https://serverfault.com/questions/451238/why-cant-all-zeros-in-the-host-portion-of-ip-address-be-used-for-a-host
	 * //// Configuration
	 * Maybe use a bit from https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing, see the phrase "In common usage"
	 * https://github.com/ipaddress-gem/ipaddress
	 */
	/**
	 * Prefix Handling Configuration
	 * 
	 * The library is designed to treat prefixes three different ways:
	 * <p>1. All prefixes are subnets.  This was the legacy behaviour for version earlier than version 4.
	 * All prefixed addresses are converted to the block of addresses that share the same prefix.
	 * For addresses in which prefixes are derived from the address ranges, such as MAC, prefix lengths are implicitly calculated from the range,
	 * so 1:2:3:*:*:* implicitly has the prefix length of 24.  This is also the case for any address derived from the original.
	 * <p>
	 * 2. Addresses with zero-values hosts are treated as subnets.  More precisely, addresses whose hosts are entirely zero, 
	 * or addresses whose hosts start with zeros and end with the full range of values are treated as subnets.  
	 * So, for example, 1.2.0.0/16 is converted to 1.2.*.* which is the block of addresses with with prefix 1.2.
	 * Also, 1.2.0.* /16 or 1.2.*.* /16 are also equivalent to the block of 65535 addresses 1.2.*.* associated with prefix length 16.
	 * Addresses with non-zero hosts, such as 1.2.0.1/16 are treated differently. 1.2.0.1/16 is equivalent to the single address 1.2.0.1 and is not a treated as a subnet block of multiple addresses.
	 * The new behaviour is akin to the typical convention used by network administrators in which the address with a host of zero is known as the network address.
	 * The all-zero address 0.0.0.0 is conventionally known as INADDR_ANY (any address on the local machine), and when paired with prefix zero it is known as the default route (the route for all addresses).
	 * <p>
	 * The same is true on the IPv6 side, where 1:2:3:4::/64 is treated as the subnet of all addresses with prefix 1:2:3:4.  
	 * With IPv6 it is a common convention to depict a prefixed network as a:b:c:d::/64, with the host shown as all zeros.
	 * This is also known as the subnet router anycast address in IPv6.  The all-zero address '::' is the value of IN6ADDR_ANY_INIT, the analog to the IPv4 INADDR_ANY.
	 * <p>
	 * In summary:<br>
	 * <ul><li>A prefixed address whose host bits are all 0 is not a single host address, instead it represents a subnet, the block of all addresses with that prefix.
	 * </li><li>A prefixed address whose host is non-zero is treated as a single address with the given prefix length.
	 * </li></ul>
	 * <p>
	 * So for example, 1.2.0.0/16 will give you the subnet block 1.2.*.* /16, and once you have it, if you want just the single address 1.2.0.0/16, you can get it using {@link IPAddress#getLower()}.
	 * <p>
	 * This option has less meaning for other address types in which ranges are explicit, such as MAC addresses.  However, this option does allow you, using the appropriate constructor, to assign a prefix length to any address.
	 * So there is no automatic fixed mapping between the range of the address values and the associated prefix length.
	 * <p>
	 * Additionally, when starting with an address whose prefix was calculated from its range, you can derive additionally addresses from the original, and those addresses will have the same prefix.
	 * For instance, 1:2:3:*:*:* implicitly has the prefix length of 24 regardless of the prefix configuration.  But with this prefix configuration, 
	 * you can then construct a derived address with the same prefix, for example with new MACAddressString("1:2:3:*:*:*").getAddress().replace(MACAddressString("1:2:3:4:5:6").getSection(2));
	 * <p>
	 * 3. The third option is the setting for which prefixes are never automatically converted to subnets.  Any subnet must be explicitly defined,
	 * such as 1.2.*.* /16
	 * <p>
	 * For addresses in which ranges are explicit, such as MAC addresses, this option is no different than the second option.
	 * 
	 * <p>
	 * In summary:<ul>
	 * <li>When PrefixConfiguration == ALL_PREFIXES_ARE_SUBNETS all prefixed addresses have hosts that span all possible host values.</li>
	 * <li>When PrefixConfiguration == PREFIXED_ZERO_HOSTS_ARE_SUBNETS addresses constructed with zero host will have hosts that span all possible values, such as 1.2.0.0/16 which is equivalent to 1.2.*.* /16</li>
	 * <li>When PrefixConfiguration == EXPLICIT_SUBNETS hosts that span all values are explicit, such as 1.2.*.* /16, while 1.2.0.0/16 is just a single address with a single host value of zero.</li>
	 * </ul>
	 * <p>
	 * Note that when setting a non-default prefix configuration, indeterminate behaviour can result from the same addresses using different prefix configuration settings at different times, so this method must be used carefully.
	 * <p>
	 * Should you wish to use two different prefix configurations in the same app, it can be done safely using classloaders,
	 * and it can also be done using different network instances.  To used different networks, you can override the virtual methods
	 * for getting network instances in your address component classes.
	 */
	public enum PrefixConfiguration {
		ALL_PREFIXED_ADDRESSES_ARE_SUBNETS,//legacy behaviour
		PREFIXED_ZERO_HOSTS_ARE_SUBNETS,//default
		EXPLICIT_SUBNETS;
		
		/**
		 * @return whether this is ALL_PREFIXED_ADDRESSES_ARE_SUBNETS
		 */
		public boolean allPrefixedAddressesAreSubnets() {
			return this == ALL_PREFIXED_ADDRESSES_ARE_SUBNETS;
		}
		/**
		 * @return whether this is PREFIXED_ZERO_HOSTS_ARE_SUBNETS
		 */
		public boolean zeroHostsAreSubnets() {
			return this == PREFIXED_ZERO_HOSTS_ARE_SUBNETS;
		}
		
		/**
		 * @return whether this is EXPLICIT_SUBNETS
		 */
		public boolean prefixedSubnetsAreExplicit() {
			return this == EXPLICIT_SUBNETS;
		}
	}
	private static PrefixConfiguration defaultPrefixConfiguration = PrefixConfiguration.PREFIXED_ZERO_HOSTS_ARE_SUBNETS;
	//public static PrefixConfiguration prefixConfiguration = PrefixConfiguration.ALL_PREFIXES_ARE_SUBNETS; //old behaviour (version 3 and under)
	
	/**
	 * This method determines the prefix configuration in use by this network.
	 * <p>
	 * The prefix configuration determines whether a prefixed address like 1.2.0.0/16 results in a subnet block (ie 1.2.*.*) or just a single address (1.2.0.0) with a prefix length.
	 * <p>
	 * If you wish to change the default behaviour, you can either call {@link inet.ipaddr.ipv4.IPv4AddressNetwork#setDefaultPrefixConfiguration(PrefixConfiguration)},
	 * or {@link inet.ipaddr.ipv6.IPv6AddressNetwork#setDefaultPrefixConfiguration(PrefixConfiguration)} or you can override this method in your own network and use your own network for your addresses.
	 * 
	 * @see PrefixConfiguration
	 */
	public abstract PrefixConfiguration getPrefixConfiguration();
	
	public static PrefixConfiguration getDefaultPrefixConfiguration() {
		return defaultPrefixConfiguration;
	}
	
	protected boolean isCompatible(AddressNetwork<?> other) {
		return IPAddressSection.isCompatibleNetworks(this, other);
	}
	
	/**
	 * Generates and caches HostIdentifierString instances.  Choose a map of your choice to implement a cache of address string identifiers.
	 * <p>
	 * You choose the map of your choice to be the backing map for the cache.
	 * For example, for thread-safe access to the cache, ConcurrentHashMap is a good choice.
	 * For maps of bounded size, LinkedHashMap provides the removeEldestEntry method to override to implement LRU or other eviction mechanisms.
	 * <p>
	 * @author sfoley
	 *
	 * @param <T> the type to be cached, typically either IPAddressString or HostName
	 */
	public static abstract class HostIdentifierStringGenerator<T extends HostIdentifierString> implements Serializable {
		private static final long serialVersionUID = 4L;
		
		protected final Map<String, T> backingMap;
		
		public HostIdentifierStringGenerator() {
			this(null);
		}
		
		public HostIdentifierStringGenerator(Map<String, T> backingMap) {
			this.backingMap = backingMap;
		}
		
		public Map<String, T> getBackingMap() {
			return backingMap;
		}
		
		/*
		 * If you wish to maintain a count of added addresses, or a log, then override this method
		 */
		protected void added(T added) {}
		/**
		 * Returns whether the given instance is in the cache.
		 * @param value
		 * @return whether the given instance of T is in the cache
		 */
		public boolean contains(T value) {
			return backingMap.containsValue(value);
		}
		/**
		 * Gets the object for the given key.  If the object does not exist yet then it is created and added to the cache.
		 * @param key
		 * @return the object for the given key
		 */
		public T get(String key) {
			if(backingMap == null) {
				return create(key);
			}
			T result = backingMap.get(key);
			if(result == null) {
				result = create(key);
				
				String normalizedKey = result.toNormalizedString();
				
				//we want to use only the IPAddressString or HostName that was created from the normalized string.
				//This helps things like getHostAddress to have predictable behaviour
				result = create(normalizedKey);
				
				T existing = backingMap.putIfAbsent(normalizedKey, result);
				if(existing == null) {
					added(result);
				} else {
					result = existing;
				}
				if(!normalizedKey.equals(key)) {
					backingMap.put(key, result);
				}
			}
			return result;
		}
		
		public abstract T get(byte bytes[]);
		
		public abstract T get(AddressValueProvider addressProvider);
		
		protected abstract T create(String key);
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.standard;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.IPAddressGenericDivision;
import inet.ipaddr.format.util.AddressSegmentParams;
/**
 * A division of an IP address.
 * <p>
 * May be associated with a prefix length, in which case that number of bits 
 * in the upper-most portion of the object represent a prefix.
 * 
 * @author sfoley
 *
 */
public abstract class IPAddressDivision extends AddressDivision implements IPAddressGenericDivision {
	private static final long serialVersionUID = 4L;
	private final Integer divisionNetworkPrefix;//the prefix length for this division, or null if there is none
	
	protected transient String cachedString;
	private transient Boolean isSinglePrefixBlock;
	
	protected IPAddressDivision() {
		this(null);
	}
	
	protected IPAddressDivision(Integer networkPrefixLength) {
		if(networkPrefixLength != null && networkPrefixLength < 0) {
			throw new PrefixLenException(networkPrefixLength);
		}
		this.divisionNetworkPrefix = networkPrefixLength;
	}
	@Override
	public boolean isPrefixed() {
		return divisionNetworkPrefix != null;
	}
	
	/**
	 * Returns the network prefix for the division.
	 * 
	 * The network prefix is 16 for an address like 1.2.0.0/16.
	 * 
	 * When it comes to each address division or segment, the prefix for the division is the
	 * prefix obtained when applying the address or section prefix.
	 * 
	 * For instance, with the address 1.2.0.0/20, 
	 * segment 1 has no prefix because the address prefix 20 extends beyond the 8 bits in the first segment, it does not even apply to the segment, 
	 * segment 2 has no prefix because the address prefix extends beyond bits 9 to 16 which lie in the second segment, it does not apply to that segment either,
	 * segment 3 has the prefix 4 because the address prefix 20 corresponds to the first 4 bits in the 3rd segment,
	 * which means that the first 4 bits are part of the network section of the address or segment,
	 * and segment 4 has the prefix 0 because not a single bit is in the network section of the address or segment
	 * 
	 * The prefix applied across the address is null ... null ... (1 to segment bit length) ... 0 ... 0
	 * 
	 * If the segment has no prefix then null is returned.
	 * 
	 * @return
	 */
	@Override
	public Integer getDivisionPrefixLength() {
		return divisionNetworkPrefix;
	}
	public boolean matchesWithPrefixMask(long value, Integer divisionPrefixLen) {
		if(divisionPrefixLen == null) {
			return matches(value);
		}
		long mask = getDivisionNetworkMask(divisionPrefixLen);
		long matchingValue = value & mask;
		return matchingValue == (getDivisionValue() & mask) && matchingValue == (getUpperDivisionValue() & mask);
	}
	
	protected abstract long getDivisionNetworkMask(int bits);
	
	protected abstract long getDivisionHostMask(int bits);
	
	/**
	 * If this is equivalent to the mask for a CIDR prefix length block or subnet class, it returns the prefix length.
	 * Otherwise, it returns null.
	 * A CIDR network mask is an address with all 1s in the network section (the upper bits) and then all 0s in the host section.
	 * A CIDR host mask is an address with all 0s in the network section (the lower bits) and then all 1s in the host section.
	 * The prefix length is the length of the network section.
	 * <p>
	 * Also, keep in mind that the prefix length returned by this method is not equivalent to the prefix length used to construct this object.
	 * The prefix length used to construct indicates the network and host portion of this address.  
	 * The prefix length returned here indicates the whether the value of this address can be used as a mask for the network and host of an address with that prefix length.
	 * Therefore the two values can be different values, or one can be null while the other is not.
	 * <p>
	 * This method applies only to the lower value of the range if this segment represents multiple values.
	 * 
	 * @see IPAddressSection#getPrefixLengthForSingleBlock()
	 * 
	 * @param network whether to check for a network mask or a host mask
	 * @return the prefix length corresponding to this mask, or null if there is no such prefix length
	 */
	public Integer getBlockMaskPrefixLength(boolean network) {
		int hostLength = getTrailingBitCount(network);
		long shifted;
		if(network) {
			shifted = (~getDivisionValue() & getMaxValue()) >>> hostLength;
		} else {
			shifted = getDivisionValue() >>> hostLength;
		}
		return shifted == 0 ? AddressDivisionGrouping.cacheBits(getBitCount() - hostLength) : null;
	}
	/**
	 * Returns the number of consecutive trailing one or zero bits.
	 * If network is true, returns the number of consecutive trailing zero bits.
	 * Otherwise, returns the number of consecutive trailing one bits.
	 * <p>
	 * This method applies only to the lower value of the range if this segment represents multiple values.
	 *
	 * @param network
	 * @return
	 */
	public int getTrailingBitCount(boolean network) {
		if(network) {
			//trailing zeros
			return Long.numberOfTrailingZeros(getDivisionValue() | (~0L << getBitCount()));
		}
		// trailing ones
		return Long.numberOfTrailingZeros(~getDivisionValue());  
	}
	
	/**
	 * Returns the number of consecutive leading one or zero bits.
	 * If network is true, returns the number of consecutive leading one bits.
	 * Otherwise, returns the number of consecutive leading zero bits.
	 * <p>
	 * This method applies only to the lower value of the range if this segment represents multiple values.
	 * @param network
	 * @return
	 */
	public int getLeadingBitCount(boolean network) {
		int extraLeading = Long.SIZE - getBitCount();
		if(network) {
			//leading ones
			return Long.numberOfLeadingZeros(~getDivisionValue() & getMaxValue()) - extraLeading;
		}
		// leading zeros
		return Long.numberOfLeadingZeros(getDivisionValue()) - extraLeading;
	}
	@Override
	protected boolean isPrefixBlock(long segmentValue, long upperValue, int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			//is full range?
			return segmentValue == 0 && upperValue == getMaxValue();
		}
		return testRange(segmentValue,
				upperValue,
				upperValue,
				getDivisionNetworkMask(divisionPrefixLen),
				getDivisionHostMask(divisionPrefixLen));
	}
	@Override
	protected boolean isSinglePrefixBlock(long segmentValue, long upperValue, int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			//is full range?
			return segmentValue == 0 && upperValue == getMaxValue();
		}
		return testRange(segmentValue,
				segmentValue,
				upperValue,
				getDivisionNetworkMask(divisionPrefixLen),
				getDivisionHostMask(divisionPrefixLen));
	}
	
	/**
	 * Whether the range of this division matches the range for a single prefix with the given value and the given prefix length.
	 * 
	 * @param divisionPrefixLen
	 * @return whether the range of this segment matches the block of address divisions for that prefix.
	 */
	boolean isSinglePrefixBlock(long segmentValue, int divisionPrefixLen) {
		return isSinglePrefixBlock(segmentValue, getUpperDivisionValue(), divisionPrefixLen);
	}
	
	/**
	 * @return whether the division range includes the block of values for the given prefix length
	 */
	@Override
	public boolean containsPrefixBlock(int divisionPrefixLen) {
		return isPrefixBlock(getDivisionValue(), getUpperDivisionValue(), divisionPrefixLen);
	}
	/**
	 * @return whether the division range includes the block of values for the division prefix length,
	 *  or false if the division has no prefix length
	 */
	@Override
	public boolean isPrefixBlock() {
		return isPrefixed() && containsPrefixBlock(getDivisionPrefixLength());
	}
	/**
	 * Returns whether the division range matches exactly the block of values for the given prefix length.
	 * 
	 * @return whether the range of this division matches the range for a single prefix with a single value and the given prefix length.
	 * 
	 * @param divisionPrefixLen
	 * @return whether the range of this segment matches the block of address divisions for that prefix.
	 */
	@Override
	public boolean containsSinglePrefixBlock(int divisionPrefixLen) {
		return isSinglePrefixBlock(getDivisionValue(), getUpperDivisionValue(), divisionPrefixLen);
	}
	/**
	 * @return whether the division range matches exactly the block of values for its prefix length.
	 */
	@Override
	public boolean isSinglePrefixBlock() {//since this one is commonly used for string production, it is cached
		if(isSinglePrefixBlock == null) {
			isSinglePrefixBlock = isPrefixed() && containsSinglePrefixBlock(getDivisionPrefixLength());
		}
		return isSinglePrefixBlock;
	}
	/**
	 * Produces a normalized string to represent the segment.
	 * If the segment CIDR prefix length covers the range, then it is assumed to be a CIDR, and the string has only the lower value of the CIDR range.
	 * Otherwise, the explicit range will be printed.
	 * @return
	 */
	@Override
	public String getString() {
		String result = cachedString;
		if(result == null) {
			synchronized(this) {
				result = cachedString;
				if(result == null) {
					if(isSinglePrefixBlock() || !isMultiple()) { //covers the case of !isMultiple, ie single addresses, when there is no prefix or the prefix is the bit count
						result = getDefaultLowerString();
					} else if(!isFullRange() || (result = getDefaultSegmentWildcardString()) == null) {
						long upperValue = getUpperDivisionValue();
						if(isPrefixBlock()) {
							upperValue &= getDivisionNetworkMask(getDivisionPrefixLength());
						}
						result = getDefaultRangeString(getDivisionValue(), upperValue, getDefaultTextualRadix());
					}
					cachedString = result;
				}
			}
		}
		return result;
	}
	/**
	 * Produces a string to represent the segment, favouring wildcards and range characters over the network prefix to represent subnets.
	 * If it exists, the segment CIDR prefix is ignored and the explicit range is printed.
	 * @return
	 */
	@Override
	public String getWildcardString() {
		String result = cachedWildcardString;
		if(result == null) {
			synchronized(this) {
				result = cachedWildcardString;
				if(result == null) {
					if(!isPrefixed() || !isMultiple()) {
						result = getString();
					} else if(!isFullRange() || (result = getDefaultSegmentWildcardString()) == null) {
						result = getDefaultRangeString();
					}
					cachedWildcardString = result;
				}
			}
		}
		return result;
	}
	
	@Override
	protected String getCachedDefaultLowerString() {
		String result = cachedString;
		if(result == null) {
			synchronized(this) {
				result = cachedString;
				if(result == null) {
					cachedString = result = getDefaultLowerString();
				}
			}
		}
		return result;
	}
	@Override
	protected void getUpperStringMasked(int radix, boolean uppercase, StringBuilder appendable) {
		long upperValue = getUpperDivisionValue();
		long mask = getDivisionNetworkMask(getDivisionPrefixLength());
		upperValue &= mask;
		toUnsignedStringCased(upperValue, radix, 0, uppercase, appendable);
	}
	
	@Override
	public int getPrefixAdjustedRangeString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		return super.getPrefixAdjustedRangeString(segmentIndex, params, appendable);
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv6;
import java.math.BigInteger;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import java.util.function.IntUnaryOperator;
import java.util.function.Predicate;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressPositionException;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressSection.WildcardOptions.WildcardOption;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.InconsistentPrefixException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.SizeMismatchException;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.large.IPAddressLargeDivision;
import inet.ipaddr.format.large.IPAddressLargeDivisionGrouping;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.standard.IPAddressBitsDivision;
import inet.ipaddr.format.standard.IPAddressDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.format.string.AddressStringDivision;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartConfiguredString;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.IPAddressPartStringSubCollection;
import inet.ipaddr.format.util.IPAddressStringWriter;
import inet.ipaddr.format.util.sql.IPAddressSQLTranslator;
import inet.ipaddr.format.util.sql.SQLStringMatcher;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4Address.IPv4AddressConverter;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringBuilderOptions;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringOptions;
import inet.ipaddr.ipv4.IPv4AddressSegment;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection.CompressOptions.CompressionChoiceOptions;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCollection.IPv6StringBuilder;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCollection.IPv6v4MixedStringBuilder;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
import inet.ipaddr.mac.MACAddressNetwork.MACAddressCreator;
import inet.ipaddr.mac.MACAddressSection;
import inet.ipaddr.mac.MACAddressSegment;
/**
 * A section of an IPv6Address. 
 * 
 * It is a series of 0 to 8 individual IPv6 address segments 
 * that is aware of the segment index from within the address from which the section begins.
 * 
 * @author sfoley
 *
 */
public class IPv6AddressSection extends IPAddressSection implements Iterable<IPv6AddressSection> {
	private static final long serialVersionUID = 4L;
	
	static class IPv6StringCache extends IPStringCache {
		//a set of pre-defined string types
		static final IPv6StringOptions mixedParams;
		static final IPv6StringOptions fullParams;
		static final IPv6StringOptions normalizedParams;
		static final IPv6StringOptions canonicalParams;
		static final IPv6StringOptions uncParams;
		static final IPv6StringOptions compressedParams;
		
		static final IPv6StringOptions wildcardNormalizedParams;
		static final IPv6StringOptions wildcardCanonicalParams;
		static final IPv6StringOptions sqlWildcardParams;
		static final IPv6StringOptions wildcardCompressedParams;
		static final IPv6StringOptions networkPrefixLengthParams;
		static final IPv6StringOptions reverseDNSParams;
		
		static final IPStringOptions base85Params;
		
		static final IPStringOptions segmentedBinaryParams;
		
		static {
			CompressOptions 
				compressAll = new CompressOptions(true, CompressOptions.CompressionChoiceOptions.ZEROS_OR_HOST),
				compressMixed = new CompressOptions(true, CompressOptions.CompressionChoiceOptions.MIXED_PREFERRED),
				compressAllNoSingles = new CompressOptions(false, CompressOptions.CompressionChoiceOptions.ZEROS_OR_HOST), 
				compressHostPreferred = new CompressOptions(true, CompressOptions.CompressionChoiceOptions.HOST_PREFERRED),
				compressZeros = new CompressOptions(true, CompressOptions.CompressionChoiceOptions.ZEROS),
				compressZerosNoSingles = new CompressOptions(false, CompressOptions.CompressionChoiceOptions.ZEROS);
			mixedParams = new IPv6StringOptions.Builder().setMakeMixed(true).setCompressOptions(compressMixed).toOptions();
			fullParams = new IPv6StringOptions.Builder().setExpandedSegments(true).setWildcardOptions(new WildcardOptions(WildcardOptions.WildcardOption.NETWORK_ONLY, new Wildcards(IPAddress.RANGE_SEPARATOR_STR))).toOptions();
			canonicalParams = new IPv6StringOptions.Builder().setCompressOptions(compressAllNoSingles).toOptions();
			uncParams = new IPv6StringOptions.Builder().setSeparator(IPv6Address.UNC_SEGMENT_SEPARATOR).setZoneSeparator(IPv6Address.UNC_ZONE_SEPARATOR).
					setAddressSuffix(IPv6Address.UNC_SUFFIX).
					setWildcardOptions(new WildcardOptions(WildcardOptions.WildcardOption.NETWORK_ONLY, new Wildcards(IPv6Address.UNC_RANGE_SEPARATOR_STR, IPAddress.SEGMENT_WILDCARD_STR, null))).toOptions();
			compressedParams = new IPv6StringOptions.Builder().setCompressOptions(compressAll).toOptions();
			normalizedParams = new IPv6StringOptions.Builder().toOptions();
			WildcardOptions 
				allWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL),
				allSQLWildcards = new WildcardOptions(WildcardOptions.WildcardOption.ALL, new Wildcards(IPAddress.SEGMENT_SQL_WILDCARD_STR, IPAddress.SEGMENT_SQL_SINGLE_WILDCARD_STR));
			wildcardCanonicalParams = new IPv6StringOptions.Builder().setWildcardOptions(allWildcards).setCompressOptions(compressZerosNoSingles).toOptions();
			wildcardNormalizedParams = new IPv6StringOptions.Builder().setWildcardOptions(allWildcards).toOptions(); //no compression
			sqlWildcardParams = new IPv6StringOptions.Builder().setWildcardOptions(allSQLWildcards).toOptions(); //no compression
			wildcardCompressedParams = new IPv6StringOptions.Builder().setWildcardOptions(allWildcards).setCompressOptions(compressZeros).toOptions();
			networkPrefixLengthParams = new IPv6StringOptions.Builder().setCompressOptions(compressHostPreferred).toOptions();
			reverseDNSParams = new IPv6StringOptions.Builder().setReverse(true).setAddressSuffix(IPv6Address.REVERSE_DNS_SUFFIX).setSplitDigits(true).setExpandedSegments(true).setSeparator('.').toOptions();
			base85Params = new IPStringOptions.Builder(85).setExpandedSegments(true).setWildcards(new Wildcards(Address.ALTERNATIVE_RANGE_SEPARATOR_STR)).setZoneSeparator(IPv6Address.ALTERNATIVE_ZONE_SEPARATOR).toOptions();
			segmentedBinaryParams = new IPStringOptions.Builder(2).setSeparator(IPv6Address.SEGMENT_SEPARATOR).setSegmentStrPrefix(IPAddress.BINARY_STR_PREFIX).setExpandedSegments(true).toOptions();
		}
		
		public String normalizedString;
		public String compressedString;
		public String mixedString;
		public String compressedWildcardString;									
		public String canonicalWildcardString;
		public String networkPrefixLengthString;
		public String base85String;
		
		//we piggy-back on the section cache for strings that are full address only
		public String uncString;
	}
	static class IPv6AddressCache extends SectionCache<IPv6Address> {
		public Inet6Address inetAddress;
	}
	
	private static IPv6AddressCreator creators[] = new IPv6AddressCreator[IPv6Address.SEGMENT_COUNT];
	private transient IPv6StringCache stringCache;
	private transient SectionCache<IPv6AddressSection> sectionCache;
	private transient long[] cachedLowerVals;
	transient IPv4AddressSection embeddedIPv4Section;//the lowest 4 bytes as IPv4
	transient IPv6v4MixedAddressSection defaultMixedAddressSection;
	/*
	 * Indicates the index of the first segment where this section would be located in a full IPv6 address.  0 for network sections or full addresses
	 */
	public final int addressSegmentIndex;
	/* also for caching: index of segments that are zero, and the number of consecutive zeros for each. */
	private transient RangeList zeroSegments;
	/* also for caching: index of segments that are zero or any value due to CIDR prefix, and the number of consecutive segments for each. */
	private transient RangeList zeroRanges;
	/**
	 * Constructs a single segment section, the segment being the leading segment.
	 * 
	 * @param segment
	 */
	public IPv6AddressSection(IPv6AddressSegment segment) {
		this(new IPv6AddressSegment[] {segment}, 0, false);
	}
	/**
	 * Constructs a single segment section with the segment at the given index in the address.
	 * 
	 * @param segment
	 */
	public IPv6AddressSection(IPv6AddressSegment segment, int startIndex) throws AddressValueException {
		this(new IPv6AddressSegment[] {segment}, startIndex, false);
	}
	/**
	 * Use this constructor for any address section that includes the leading segment of an IPv6 address
	 */
	public IPv6AddressSection(IPv6AddressSegment segments[]) throws AddressValueException {
		this(segments, 0, true);
	}
	/**
	 * Use this constructor for any address section that includes the leading segment of an IPv6 address
	 * @param segments an array containing the segments.  Segments that are entirely part of the host section need not be provided, although the array must be the correct length.
	 * @param networkPrefixLength
	 */
	public IPv6AddressSection(IPv6AddressSegment segments[], Integer networkPrefixLength) throws AddressValueException {
		this(segments, 0, networkPrefixLength);
	}
	
	/**
	 * @param startIndex the index of the first segment where this section would be located in a full address, 0 for network sections or full addresses
	 * @param segments an array containing the segments.  Segments that are entirely part of the host section need not be provided, although the array must be the correct length.
	 * @param networkPrefixLength
	 */
	public IPv6AddressSection(IPv6AddressSegment[] segments, int startIndex, Integer networkPrefixLength) throws AddressValueException {
		this(segments, startIndex, true, networkPrefixLength, false);
	}
	protected IPv6AddressSection(IPv6AddressSegment[] segments, int startIndex, boolean cloneSegments, Integer networkPrefixLength, boolean singleOnly) throws AddressValueException {
		this(segments, startIndex, cloneSegments, networkPrefixLength == null /* only need to check segment prefixes if not applying a prefix */);
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0) {
				throw new PrefixLenException(networkPrefixLength);
			}
			int max = segments.length << 4;
			if(networkPrefixLength > max) {
				if(networkPrefixLength > IPv6Address.BIT_COUNT) {
					throw new PrefixLenException(networkPrefixLength);
				}
				networkPrefixLength = max;
			}
			if(segments.length > 0) {
				if(cachedPrefixLength != NO_PREFIX_LENGTH && cachedPrefixLength < networkPrefixLength) {//if the segments have a shorter prefix length, then use that
					networkPrefixLength = cachedPrefixLength;
				}
				IPv6AddressNetwork network = getNetwork();
				setPrefixedSegments(
						network,
						networkPrefixLength,
						getSegmentsInternal(),
						getBitsPerSegment(),
						getBytesPerSegment(),
						network.getAddressCreator(), 
						!singleOnly && isPrefixSubnetSegs(segments, networkPrefixLength, network, false) ? IPv6AddressSegment::toNetworkSegment : IPv6AddressSegment::toPrefixedSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} //else the cached prefix has already been set to the proper value
	}
	
	protected IPv6AddressSection(IPv6AddressSegment[] segments, int startIndex, boolean cloneSegments) throws AddressValueException {
		this(segments, startIndex, cloneSegments, true);
	}
	
	IPv6AddressSection(IPv6AddressSegment[] segments, int startIndex, boolean cloneSegments, boolean normalizeSegments) throws AddressValueException {
		super(segments, cloneSegments, true);
		if(normalizeSegments && isPrefixed()) {
			normalizePrefixBoundary(getNetworkPrefixLength(), getSegmentsInternal(), IPv6Address.BITS_PER_SEGMENT, IPv6Address.BYTES_PER_SEGMENT, IPv6AddressSegment::toPrefixNormalizedSeg);
		}
		this.addressSegmentIndex = startIndex;
		if(startIndex < 0) {
			throw new AddressPositionException(startIndex);
		} else if(startIndex + segments.length > IPv6Address.SEGMENT_COUNT) {
			//we throw address value exception because too many segments
			throw new AddressValueException(startIndex + segments.length);
		}
	}
	
	public IPv6AddressSection(SegmentValueProvider valueProvider, int segmentCount, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, segmentCount, networkPrefixLength);
	}
	public IPv6AddressSection(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, int segmentCount, Integer networkPrefixLength) throws AddressValueException {
		super(new IPv6AddressSegment[segmentCount], false, false);
		IPv6AddressSegment segs[] = getSegmentsInternal();
		IPv6AddressNetwork network = getNetwork();
		createSegments(
				segs,
				lowerValueProvider,
				upperValueProvider,
				getBytesPerSegment(),
				getBitsPerSegment(),
				network,
				networkPrefixLength);
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0 || networkPrefixLength > IPv6Address.BIT_COUNT) {
				throw new PrefixLenException(networkPrefixLength);
			}
			if(network.getPrefixConfiguration().zeroHostsAreSubnets() && isPrefixSubnetSegs(segs, networkPrefixLength, network, false)) {
				setPrefixedSegments(
					network,
					networkPrefixLength,
					getSegmentsInternal(),
					getBitsPerSegment(),
					getBytesPerSegment(),
					network.getAddressCreator(),
					IPv6AddressSegment::toNetworkSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
		}
		this.addressSegmentIndex = 0;
	}
	
	public IPv6AddressSection(SegmentValueProvider valueProvider, int segmentCount) throws AddressValueException {
		this(valueProvider, valueProvider, segmentCount);
	}
	
	public IPv6AddressSection(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, int segmentCount) {
		this(lowerValueProvider, upperValueProvider, segmentCount, null);
	}
	
	protected IPv6AddressSection(byte bytes[], int segmentCount, Integer networkPrefixLength, boolean cloneBytes, boolean singleOnly) throws AddressValueException {
		this(bytes, 0, bytes.length, segmentCount, networkPrefixLength, cloneBytes, singleOnly);
	}
	protected IPv6AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer networkPrefixLength, boolean cloneBytes, boolean singleOnly) throws AddressValueException {
		super(new IPv6AddressSegment[segmentCount >= 0 ? segmentCount : (Math.max(0, byteEndIndex - byteStartIndex) + IPv6Address.BYTES_PER_SEGMENT - 1) >> 1], false, false);
		IPv6AddressSegment segs[] = getSegmentsInternal();
		IPv6AddressNetwork network = getNetwork();
		toSegments(
				segs,
				bytes,
				byteStartIndex,
				byteEndIndex,
				getBytesPerSegment(),
				getBitsPerSegment(),
				network,
				networkPrefixLength);
		boolean byteLengthIsExact = bytes.length == (segs.length << 1);
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0) {
				throw new PrefixLenException(networkPrefixLength);
			}
			int max = segs.length << 4;
			if(networkPrefixLength > max) {
				if(networkPrefixLength > IPv6Address.BIT_COUNT) {
					throw new PrefixLenException(networkPrefixLength);
				}
				networkPrefixLength = max;
			}
			if(segs.length > 0) {
				if(network.getPrefixConfiguration().zeroHostsAreSubnets() && !singleOnly) {
					if(isPrefixSubnetSegs(segs, networkPrefixLength, network, false)) {
						setPrefixedSegments(
							network,
							networkPrefixLength,
							segs,
							getBitsPerSegment(),
							getBytesPerSegment(),
							network.getAddressCreator(),
							IPv6AddressSegment::toNetworkSegment);
					} else if(byteLengthIsExact && networkPrefixLength >= getBitCount()) {
						setBytes(cloneBytes ? bytes.clone() : bytes);
					}
				} else if(byteLengthIsExact && network.getPrefixConfiguration().prefixedSubnetsAreExplicit() || networkPrefixLength >= getBitCount()) {
					setBytes(cloneBytes ? bytes.clone() : bytes);
				}
			} else if(byteLengthIsExact) {
				setBytes(bytes);
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
			if(byteLengthIsExact) {
				setBytes(cloneBytes ? bytes.clone() : bytes);
			}
		}
		this.addressSegmentIndex = 0;
	}
	protected IPv6AddressSection(byte bytes[], int segmentCount, Integer prefix, boolean cloneBytes) throws AddressValueException {
		this(bytes, 0, bytes.length, segmentCount, prefix, cloneBytes, false);
	}
	
	/*
	 * Use this constructor for any address section that includes the leading segment of an IPv6 address
	 */
	public IPv6AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, -1, prefix, true, false);
	}
	
	/*
	 * Use this constructor for any address section that includes the leading segment of an IPv6 address
	 */
	public IPv6AddressSection(byte bytes[], int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, -1, null, true, false);
	}
	
	/*
	 * Use this constructor for any address section that includes the leading segment of an IPv6 address
	 */
	public IPv6AddressSection(byte bytes[], Integer prefix) throws AddressValueException {
		this(bytes, 0, bytes.length, -1, prefix, true, false);
	}
	
	/*
	 * Use this constructor for any address section that includes the leading segment of an IPv6 address
	 */
	public IPv6AddressSection(byte bytes[]) throws AddressValueException {
		this(bytes, 0, bytes.length, -1, null, true, false);
	}
	/*
	 * Use this constructor for any address section that includes the leading segment of an IPv6 address
	 */
	public IPv6AddressSection(BigInteger val, int segmentCount, Integer networkPrefixLength) throws AddressValueException {
		this(val.toByteArray(), segmentCount, networkPrefixLength, false);
	}
	
	/*
	 * Use this constructor for any address section that includes the leading segment of an IPv6 address
	 */
	public IPv6AddressSection(BigInteger val, int segmentCount) throws AddressValueException {
		this(val, segmentCount, null);
	}
	/*
	 * Use this constructor for any address section that includes the leading segment of an IPv6 address
	 */
	public IPv6AddressSection(long highBytes, long lowBytes, int segmentCount, Integer networkPrefixLength) throws PrefixLenException {
		super(new IPv6AddressSegment[segmentCount], false, false);
		IPv6AddressSegment segs[] = getSegmentsInternal();
		IPv6AddressNetwork network = getNetwork();
		createSegments(
				segs,
				highBytes,
				lowBytes,
				getBitsPerSegment(),
				network,
				networkPrefixLength);
		if(networkPrefixLength != null) {
			if(networkPrefixLength < 0 || networkPrefixLength > IPv6Address.BIT_COUNT) {
				throw new PrefixLenException(networkPrefixLength);
			}
			if(network.getPrefixConfiguration().zeroHostsAreSubnets() && isPrefixSubnetSegs(segs, networkPrefixLength, network, false)) {
				setPrefixedSegments(
					network,
					networkPrefixLength,
					getSegmentsInternal(),
					getBitsPerSegment(),
					getBytesPerSegment(),
					network.getAddressCreator(),
					IPv6AddressSegment::toNetworkSegment);
			}
			cachedPrefixLength = networkPrefixLength;
		} else {
			cachedPrefixLength = NO_PREFIX_LENGTH;
		}
		this.addressSegmentIndex = 0;
	}
	
	/*
	 * Use this constructor for any address section that includes the leading segment of an IPv6 address
	 */
	public IPv6AddressSection(long highBytes, long lowBytes, int segmentCount) {
		this(highBytes, lowBytes, segmentCount, null);
	}
	
	/**
	 * Constructs the corresponding IPv6 address section from a modified EUI-64 (Extended Unique Identifier) address.
	 * <p>
	 * If the supplied address is an 8 byte EUI-64, then it must match the required EUI-64 format of xx-xx-ff-fe-xx-xx
	 * with the ff-fe section in the middle.
	 * 
	 * If the supplied address is a 6 byte MAC-48 or EUI-48, then the ff-fe pattern will be inserted.
	 * <p>
	 * The constructor will toggle the MAC U/L (universal/local) bit as required with EUI-64.
	 * <p>
	 * Any prefix length in the MAC address is ignored.
	 * 
	 * @throws IncompatibleAddressException when the MAC address is an EUI-64 that cannot be converted to an IPv6 address (ff-fe section in middle)
	 * 
	 * @param eui
	 */
	public IPv6AddressSection(MACAddress eui) {
		this(eui.getSection(), 4, 4);
	}
	
	/**
	 * Constructs the corresponding IPv6 address section from a modified EUI-64 (Extended Unique Identifier) address section.
	 * <p>
	 * If the supplied address section comes from an 8 byte EUI-64, then it must match the required EUI-64 format of xx-xx-ff-fe-xx-xx
	 * with the ff-fe section in the middle.
	 * 
	 * If the supplied address section comes from a 6 byte MAC-48 or EUI-48, then the ff-fe pattern will be inserted.
	 * <p>
	 * The constructor will toggle the MAC U/L (universal/local) bit as required with EUI-64.
	 * <p>
	 * Any prefix length in the MAC address section is ignored.
	 * @throws IncompatibleAddressException when the MAC address section is an EUI-64 that cannot be converted to an IPv6 address (ff-fe section in middle)
	 * 
	 * @param eui
	 */
	public IPv6AddressSection(MACAddressSection eui) {
		this(eui, getIPv6StartIndex(eui), getIPv6SegmentCount(eui));
	}
	
	private IPv6AddressSection(MACAddressSection eui, int ipv6StartIndex, int ipv6SegmentCount) throws IncompatibleAddressException {
		super(ipv6SegmentCount <= 0 ? IPv6AddressNetwork.EMPTY_SEGMENTS : new IPv6AddressSegment[ipv6SegmentCount], false, false);
		cachedPrefixLength = NO_PREFIX_LENGTH;
		this.addressSegmentIndex = ipv6StartIndex;
		IPv6AddressSegment segs[] = getSegmentsInternal();
		IPv6Address.toEUI64Segments(segs, 0, eui, eui.addressSegmentIndex, eui.isExtended(), getNetwork().getAddressCreator(), getMACNetwork().getAddressCreator(), null);
		checkSegments(segs);
	}
	
	private static int getIPv6SegmentCount(MACAddressSection eui) {
		int euiStartIndex = eui.addressSegmentIndex;
		int euiEndIndex = euiStartIndex + eui.getSegmentCount();
		//we must round up both sides of the subtraction
		int result = (euiEndIndex + 1) >> 1;
		result -= euiStartIndex >> 1;
		if(!eui.isExtended() && euiStartIndex <= 2 && euiEndIndex >= 4) {
			//if we have a segment 2 but no segment 3, then we just add ff to the end of already counted segment
			//if we have a segment 3 but no segment 2, the same is true
			//so we only add an extra segment if we have both, in which case segment 3 will be shifted to fit an extra segment
			result++;
		}
		return result;
	}
	
	private static int getIPv6StartIndex(MACAddressSection eui) {
		int euiStartIndex = eui.addressSegmentIndex;
		int result =  4 + (euiStartIndex >> 1);
		if(!eui.isExtended() && euiStartIndex >= 3) {
			result++;
		}
		return result;
	}
	
	@Override
	protected void initCachedValues(
			Integer prefixLen,
			boolean network,
			Integer cachedNetworkPrefix,
			Integer cachedMinPrefix,
			Integer cachedEquivalentPrefix,
			BigInteger cachedCount,
			RangeList zeroSegments,
			RangeList zeroRanges) {
		super.initCachedValues(prefixLen, network, cachedNetworkPrefix, cachedMinPrefix, cachedEquivalentPrefix, cachedCount, zeroSegments, zeroRanges);
		this.zeroSegments = zeroSegments;
		this.zeroRanges = zeroRanges;
	}
	
	@Override
	protected void setInetAddress(InetAddress addr) {
		super.setInetAddress(addr);
	}
	@Override
	public IPv6AddressSection getSection() {
		return this;
	}
	@Override
	public IPv6AddressSection getSection(int index) {
		return getSection(index, getSegmentCount());
	}
	@Override
	public IPv6AddressSection getSection(int index, int endIndex) {
		return getSection(index, endIndex, this, getAddressCreator(addressSegmentIndex + index));
	}
	@Override
	public IPv6AddressSegment[] getSegments() {
		return (IPv6AddressSegment[]) getDivisionsInternal().clone();
	}
	void cache(IPv6AddressSection lower, IPv6AddressSection upper) {
		SectionCache<IPv6AddressSection> cache = sectionCache;
		if((lower != null || upper != null) && 
				(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null))) {
			synchronized(this) {
				cache = sectionCache;
				boolean create = (cache == null);
				if(create) {
					sectionCache = cache = new SectionCache<IPv6AddressSection>();
					cache.lower = lower;
					cache.upper = upper;
				} else {
					if(cache.lower == null) {
						cache.lower = lower;
					}
					if(cache.upper == null) {
						cache.upper = upper;
					}
				}
			}
		}
	}
	protected IPv6AddressSection getSingleLowestOrHighestSection() {
		return getSingleLowestOrHighestSection(this);
	}
	IPv6AddressSection getLowestOrHighestSection(boolean lowest, boolean excludeZeroHost) {
		IPv6AddressSection result = getSingleLowestOrHighestSection();
		if(result == null) {
			SectionCache<IPv6AddressSection> cache = sectionCache;
			if(cache == null || 
					(lowest ? (excludeZeroHost ? ((result = cache.lowerNonZeroHost) == null && !cache.lowerNonZeroHostIsNull) : (result = cache.lower) == null) : (result = cache.upper) == null)) {
				synchronized(this) {
					cache = sectionCache;
					boolean create = (cache == null);
					if(create) {
						sectionCache = cache = new SectionCache<IPv6AddressSection>();
					} else {
						if(lowest) {
							if(excludeZeroHost) {
								create = (result = cache.lowerNonZeroHost) == null && !cache.lowerNonZeroHostIsNull;
							} else {
								create = (result = cache.lower) == null;
							}
						} else {
							create = (result = cache.upper) == null;
						}
					}
					if(create) {
						result = createLowestOrHighestSection(
								this,
								getAddressCreator(), 
								this::segmentsNonZeroHostIterator, 
								i -> lowest ? getSegment(i).getLower() : getSegment(i).getUpper(),
								lowest,
								excludeZeroHost);
						if(result == null) {
							cache.lowerNonZeroHostIsNull = true;
						} else if(lowest) {
							if(excludeZeroHost) {
								 cache.lowerNonZeroHost = result;
							} else {
								cache.lower = result;
							}
						} else {
							cache.upper = result;
						}
					}
				}
			}
		} else if(excludeZeroHost && includesZeroHost()) {
			return null;
		}
		return result;
	}
	@Override
	public IPv6AddressSection getLowerNonZeroHost() {
		return getLowestOrHighestSection(true, true);
	}
	@Override
	public IPv6AddressSection getLower() {
		return getLowestOrHighestSection(true, false);
	}
	@Override
	public IPv6AddressSection getUpper() {
		return getLowestOrHighestSection(false, false);
	}
	public long[] longValues() {
		long result[] = cachedLowerVals;
		if(result == null) {
			cachedLowerVals = result = calcLongValues(true);
		}
		return result;
	}
	public long[] upperLongValues() {
		if(!isMultiple()) {
			return longValues();
		}
		return calcLongValues(false);
	}
	private long[] calcLongValues(boolean lower) {
		int segCount = getSegmentCount();
		if(segCount != 0) {
			int bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
			long low, high;
			if(segCount <= IPv6Address.SEGMENT_COUNT >> 1) {
				high = 0;
				low = getSegment(0).getDivisionValue();
				for(int i = 1; i < segCount; i++) {
					IPv6AddressSegment seg = getSegment(i);
					low = (low << bitsPerSegment) | (lower ? seg.getDivisionValue() : seg.getUpperDivisionValue());
				}
			} else {
				high = getSegment(0).getDivisionValue();
				int highCount = segCount - 4;
				int i = 1;
				for(; i < highCount; i++) {
					IPv6AddressSegment seg = getSegment(i);
					high = (high << bitsPerSegment) | (lower ? seg.getDivisionValue() : seg.getUpperDivisionValue());
				}
				low = getSegment(i).getDivisionValue();
				for(i++; i < segCount; i++) {
					IPv6AddressSegment seg = getSegment(i);
					low = (low << bitsPerSegment) | (lower ? seg.getDivisionValue() : seg.getUpperDivisionValue());
				}
			}
			return new long[]{high, low};
		}
		return new long[2];
	}
	@Override
	public IPv6AddressSection reverseBits(boolean perByte) {
		return reverseBits(perByte, this, getAddressCreator(), i -> getSegment(i).reverseBits(perByte), true);
	}
	@Override
	public IPv6AddressSection reverseBytes() {
		return reverseBytes(false);
	}
	@Override
	public IPv6AddressSection reverseBytesPerSegment() {
		return reverseBytes(true);
	}
	private IPv6AddressSection reverseBytes(boolean perSegment) {
		return reverseBytes(perSegment, this, getAddressCreator(), i -> getSegment(i).reverseBytes(), true);
	}
	@Override
	public IPv6AddressSection reverseSegments() {
		if(getSegmentCount() <= 1) {
			return this;
		}
		return reverseSegments(this, getAddressCreator(), i -> getSegment(i).withoutPrefixLength(), true);
	}
	@Override
	public Iterable<IPv6AddressSection> getIterable() {
		return this;
	}
	private Iterator<IPv6AddressSection> iterator(Predicate<IPv6AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = !isMultiple() && (!isAllSubnets || !isPrefixed());
		IPv6AddressSection original;
		if(!useOriginal || (excludeFunc != null && excludeFunc.test(getSegmentsInternal()))) {
			original = null;
		} else {
			original = this;
		}
		return iterator(
				useOriginal,
				original,
				getAddressCreator(),
				useOriginal ? null : segmentsIterator(excludeFunc),
				isAllSubnets ? null : getPrefixLength());
	}
	private AddressComponentSpliterator<IPv6AddressSection> prefixSpliterator(boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return spliterator(false);
		}
		return prefixSpliterator(isBlockIterator, prefLength);
	}
	private AddressComponentSpliterator<IPv6AddressSection> prefixSpliterator(boolean isBlockIterator, int prefixLength) {
		if(prefixLength > getBitCount() || prefixLength < 0) {
			throw new PrefixLenException(this, prefixLength);
		}
		Integer prefLength = cacheBits(prefixLength);
		IPv6AddressCreator creator = getAddressCreator();
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		return createSeriesSpliterator(
				setPrefixLength(prefixLength, false),
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, prefLength),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefLength),
				isBlockIterator ? 
						(isLowest, isHighest, section) -> section.prefixBlockIterator() : 
							(!isSequential() ?  (isLowest, isHighest, section) -> section.prefixIterator() : 
							((isLowest, isHighest, section) -> (isLowest || isHighest) ? section.prefixIterator() : section.prefixBlockIterator())), 
				IPv6AddressSection::getPrefixCount,
				section -> section.getPrefixCount().compareTo(LONG_MAX) <= 0,
				section -> longPrefixCount(section, prefixLength));
	}
	@Override
	public Iterator<IPv6AddressSection> nonZeroHostIterator() {
		return iterator(excludeNonZeroHosts());
	}
	@Override
	public Iterator<IPv6AddressSection> iterator() {
		return iterator(null);
	}
	@Override
	public AddressComponentSpliterator<IPv6AddressSection> spliterator() {
		return spliterator(false);
	}
	@Override
	public Stream<IPv6AddressSection> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv6AddressSection> prefixIterator() {
		return prefixIterator(false);
	}
	@Override
	public AddressComponentSpliterator<IPv6AddressSection> prefixSpliterator() {
		return prefixSpliterator(false);
	}
	@Override
	public Stream<IPv6AddressSection> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv6AddressSection> prefixBlockIterator() {
		return prefixIterator(true);
	}
	@Override
	public AddressComponentSpliterator<IPv6AddressSection> prefixBlockSpliterator() {
		return prefixSpliterator(true);
	}
	@Override
	public Stream<IPv6AddressSection> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	private Iterator<IPv6AddressSection> prefixIterator(boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return iterator();
		}
		IPv6AddressCreator creator = getAddressCreator();
		boolean useOriginal = isBlockIterator ? isSinglePrefixBlock() : getPrefixCount().equals(BigInteger.ONE);
		int networkSegIndex = getNetworkSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				this,
				creator,
				useOriginal ?
						null :
						segmentsIterator(
							segCount,
							creator,
							null, //when no prefix we defer to other iterator, when there is one we use the whole original address in the encompassing iterator and not just the original segments
							index -> getSegment(index).iterator(),
							null, 
							networkSegIndex, 
							hostSegIndex, 
							isBlockIterator ? index -> getSegment(index).prefixBlockIterator() : index -> getSegment(index).prefixIterator()),
				prefLength);
	}
	@Override
	public Iterator<IPv6AddressSection> blockIterator(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return iterator();
		}
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		IPv6AddressCreator creator = getAddressCreator();
		boolean useOriginal = true;
		for(int i = 0; i <= segmentCount - 1; i++) {
			if(getSegment(i).isMultiple()) {
				useOriginal = false;
				break;
			}
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				this,
				creator,
				useOriginal ?
						null :
						segmentsIterator(
								segCount,
							creator,
							null, //when no prefix we defer to other iterator, when there is one we use the whole original section in the encompassing iterator and not just the original segments
							index -> getSegment(index).iterator(!isAllSubnets),
							null, 
							networkSegIndex, 
							hostSegIndex, 
							index -> getSegment(index).identityIterator()),
				isAllSubnets ? null : getPrefixLength());
	}
	@Override
	public AddressComponentSpliterator<IPv6AddressSection> blockSpliterator(int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return spliterator();
		}
		IPv6AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer prefLength = isAllSubnets ? null : getPrefixLength();
		IPv6AddressSection forIteration;
		Integer iterationsPrefix;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefLength;
			forIteration = this;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, section) -> section.blockIterator(segmentCount), 
				section -> section.getBlockCount(segmentCount),
				section -> section.getBlockCount(segmentCount).compareTo(LONG_MAX) <= 0,
				section -> longCount(section, segmentCount));
	}
	@Override
	public Stream<IPv6AddressSection> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AddressSection> sequentialBlockIterator() {
		return (Iterator<IPv6AddressSection>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv6AddressSection> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv6AddressSection>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv6AddressSection> sequentialBlockStream() {
		return (Stream<IPv6AddressSection>) super.sequentialBlockStream();
	}
	private Iterator<IPv6AddressSegment[]> segmentsIterator(Predicate<IPv6AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		return super.segmentsIterator(
				getSegmentCount(),
				getSegmentCreator(),
				isMultiple() ? null : () -> getLower().getSegments(),
				index -> getSegment(index).iterator(!isAllSubnets),
				excludeFunc);
	}
	private Predicate<IPv6AddressSegment[]> excludeNonZeroHosts() {
		if(isPrefixed()) {
			int prefLength = getNetworkPrefixLength();
			return segments -> isZeroHost(segments, prefLength);
		}
		return null;
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsNonZeroHostIterator() {
		return segmentsIterator(excludeNonZeroHosts());
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsIterator() {
		return segmentsIterator(null);
	}
	@Override
	public AddressComponentRangeSpliterator<IPv6AddressSection, IPv6AddressSegment[]> segmentsSpliterator() {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		IPv6AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv6AddressSection forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = this;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createItemSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, section) -> section.segmentsIterator(),
				IPv6AddressSection::getCount,
				section -> section.getCount().compareTo(LONG_MAX) <= 0,
				section -> longCount(section, segmentCount));
	}
	AddressComponentRangeSpliterator<IPv6Address, IPv6AddressSegment[]> segmentsSpliterator(IPv6Address address, IPv6AddressCreator creator) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv6Address forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = address.withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = address;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createItemSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, addr) -> addr.segmentsIterator(),
				IPv6Address::getCount,
				addr -> addr.getCount().compareTo(LONG_MAX) <= 0,
				addr -> longCount(addr.getSection(), segmentCount));
	}
	@Override
	public Stream<IPv6AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	protected IPv6AddressSegment[] getSegmentsInternal() {
		return (IPv6AddressSegment[])  super.getDivisionsInternal();
	}
	protected AddressComponentSpliterator<IPv6AddressSection> spliterator(boolean excludeZeroHosts) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		IPv6AddressCreator creator = getAddressCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv6AddressSection forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = this;
		}
		IteratorProvider<IPv6AddressSection, IPv6AddressSection> iteratorProvider;
		Function<IPv6AddressSection, BigInteger> sizer;
		ToLongFunction<IPv6AddressSection> longSizer;
		if(excludeZeroHosts && includesZeroHost()) {
			int prefLength = prefixLength;
			iteratorProvider = (isLowest, isHighest, section) -> section.iterator(segs -> isZeroHost(segs, prefLength));
			longSizer = section -> longCount(section, segmentCount) - section.longZeroHostCount(prefLength, segmentCount);
			sizer = section -> section.getCount().subtract(section.getZeroHostCountImpl(prefLength, segmentCount));
		} else {
			iteratorProvider = (isLowest, isHighest, section) -> section.iterator();
			longSizer = section -> longCount(section, segmentCount);
			sizer = IPv6AddressSection::getCount;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedSection(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				iteratorProvider,
				sizer,
				section -> section.getCount().compareTo(LONG_MAX) <= 0,
				longSizer);
	}
	protected Iterator<IPv6Address> iterator(
			IPv6Address original,
			AddressCreator<IPv6Address, ?, ?, IPv6AddressSegment> creator,
			Predicate<IPv6AddressSegment[]> excludeFunc) {
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = !isMultiple() && (!isAllSubnets || !isPrefixed());
		if(!useOriginal || (excludeFunc != null && excludeFunc.test(getSegmentsInternal()))) {
			original = null;
		}
		return iterator(
				useOriginal,
				original, 
				creator,//using a lambda for this one results in a big performance hit
				useOriginal ? null : segmentsIterator(
										getSegmentCount(),
										creator,
										isMultiple() ? null : () -> (IPv6AddressSegment[]) getLower().getSegmentsInternal(),
										index -> getSegment(index).iterator(!isAllSubnets),
										excludeFunc),//For whatever reason the IBM JVM is blowing up here, getting this mixed up with ipv4 side, but only when running multi-threaded
				isAllSubnets ? null : getPrefixLength());
	}
	protected AddressComponentSpliterator<IPv6Address> spliterator(
			IPv6Address original,
			IPv6AddressCreator creator,
			boolean excludeZeroHosts) {
		int segmentCount = getSegmentCount();
		Integer prefixLength = getNetworkPrefixLength();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer iterationsPrefix;
		IPv6Address forIteration;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = original.withoutPrefixLength();
		} else {
			iterationsPrefix = prefixLength;
			forIteration = original;
		}
		IteratorProvider<IPv6Address, IPv6Address> iteratorProvider;
		Function<IPv6Address, BigInteger> sizer;
		ToLongFunction<IPv6Address> longSizer;
		if(excludeZeroHosts && includesZeroHost()) {
			int prefLength = prefixLength;
			iteratorProvider = (isLowest, isHighest, addr) -> addr.getSection().iterator(addr, addr.getCreator(), s -> isZeroHost(s, prefLength));
			longSizer = addr -> longCount(addr.getSection(), segmentCount) - addr.getSection().longZeroHostCount(prefLength, segmentCount);
			sizer = addr -> addr.getSection().getCount().subtract(addr.getSection().getZeroHostCountImpl(prefLength, segmentCount));
		} else {
			iteratorProvider = (isLowest, isHighest, addr) -> addr.iterator();
			longSizer = addr -> longCount(addr.getSection(), segmentCount);
			sizer = IPv6Address::getCount;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				iteratorProvider,
				sizer,
				addr -> addr.getCount().compareTo(LONG_MAX) <= 0,
				longSizer);
	}
	Iterator<IPv6Address> prefixIterator(IPv6Address original, AddressCreator<IPv6Address, ?, ?, IPv6AddressSegment> creator, boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return iterator(original, creator, null);
		}
		return prefixIterator(original, creator, isBlockIterator, prefLength);
	}
	Iterator<IPv6Address> prefixIterator(IPv6Address original, AddressCreator<IPv6Address, ?, ?, IPv6AddressSegment> creator, boolean isBlockIterator, int prefLength) {
		if(prefLength > getBitCount() || prefLength < 0) {
			throw new PrefixLenException(original, prefLength);
		}
		boolean useOriginal = isBlockIterator ? containsSinglePrefixBlock(prefLength) : getPrefixCount(prefLength).equals(BigInteger.ONE);
		if(useOriginal) {
			original = original.setPrefixLength(prefLength, false);
		}
		int networkSegIndex = getNetworkSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefLength, getBytesPerSegment(), getBitsPerSegment());
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				original,
				creator,
				useOriginal ? null :
					segmentsIterator(
							segCount,
							creator,
							null, //when no prefix we defer to other iterator, when there is one we use the whole original section in the encompassing iterator and not just the original segments
							index -> getSegment(index).iterator(),
							null, 
							networkSegIndex, 
							hostSegIndex, 
							isBlockIterator ? index -> getSegment(index).prefixBlockIterator() : index -> getSegment(index).prefixIterator()),
				cacheBits(prefLength));
	}
	
	AddressComponentSpliterator<IPv6Address> prefixSpliterator(
			IPv6Address original,
			IPv6AddressCreator creator,
			boolean isBlockIterator) {
		Integer prefLength = getPrefixLength();
		if(prefLength == null || prefLength > getBitCount()) {
			return spliterator(original, creator, false);
		}
		return prefixSpliterator(original, creator, isBlockIterator, prefLength);
	}
	AddressComponentSpliterator<IPv6Address> prefixSpliterator(
			IPv6Address original,
			IPv6AddressCreator creator,
			boolean isBlockIterator,
			int prefixLength) {
		if(prefixLength > getBitCount() || prefixLength < 0) {
			throw new PrefixLenException(original, prefixLength);
		}
		Integer prefLength = cacheBits(prefixLength);
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		int hostSegIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
		return createSeriesSpliterator(
				original.setPrefixLength(prefixLength, false),
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, prefLength),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefLength),
				isBlockIterator ? 
						(isLowest, isHighest, addr) -> addr.prefixBlockIterator() : 
							(!isSequential() ?  (isLowest, isHighest, addr) -> addr.prefixIterator() : 
							((isLowest, isHighest, addr) -> (isLowest || isHighest) ? addr.prefixIterator() : addr.prefixBlockIterator())),
				IPv6Address::getPrefixCount,
				addr -> addr.getPrefixCount().compareTo(LONG_MAX) <= 0,
				addr -> longPrefixCount(addr.getSection(), prefixLength));
	}
	Iterator<IPv6Address> blockIterator(IPv6Address original, AddressCreator<IPv6Address, ?, ?, IPv6AddressSegment> creator, int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount > getSegmentCount()) {
			return iterator(original, creator, null);
		}
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		boolean useOriginal = true;
		for(int i = 0; i < segmentCount; i++) {
			if(getSegment(i).isMultiple()) {
				useOriginal = false;
				break;
			}
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		int segCount = getSegmentCount();
		return iterator(
				useOriginal,
				original, 
				creator,// using a lambda for this one results in a big performance hit
				useOriginal ? null :
					segmentsIterator(
							segCount,
							creator,
							null, // when no prefix we defer to other iterator, when there is one we use the whole original address in the encompassing iterator and not just the original segments
							index -> getSegment(index).iterator(!isAllSubnets),
							null,
							networkSegIndex,
							hostSegIndex,
							index -> getSegment(index).identityIterator()),
				isAllSubnets ? null : getPrefixLength());
	}
	AddressComponentSpliterator<IPv6Address> blockSpliterator(IPv6Address original, IPv6AddressCreator creator, int segmentCount) {
		if(segmentCount < 0) {
			throw new IllegalArgumentException();
		}
		if(segmentCount >= getSegmentCount()) {
			return spliterator(original, creator, false);
		}
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer prefLength = isAllSubnets ? null : getPrefixLength();
		IPv6Address forIteration;
		Integer iterationsPrefix;
		if(isAllSubnets) {
			iterationsPrefix = null;
			forIteration = original.withoutPrefixLength();
		} else {
			iterationsPrefix = prefLength;
			forIteration = original;
		}
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSeriesSpliterator(
				forIteration,
				spliterator -> split(
						spliterator,
						segs -> createIteratedAddress(segs, creator, iterationsPrefix),
						creator,
						spliterator.getAddressItem().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						iterationsPrefix),
				(isLowest, isHighest, addr) -> addr.blockIterator(segmentCount),
				addr -> addr.getBlockCount(segmentCount),
				addr -> addr.getBlockCount(segmentCount).compareTo(LONG_MAX) <= 0,
				addr -> longCount(addr.getSection(), segmentCount));
	}	
	protected boolean isZeroHost(IPv6AddressSegment segments[], int prefixLength) {
		return super.isZeroHost(segments, prefixLength);
	}
	private static final BigInteger MAX_VALUES_BY_SEGMENT[] = {
			BigInteger.ZERO,
			BigInteger.valueOf(IPv6Address.MAX_VALUE_PER_SEGMENT),
			BigInteger.valueOf(0xffffffffL),
			BigInteger.valueOf(0xffffffffffffL),
			BigInteger.valueOf(1).shiftLeft(16 * 4).subtract(BigInteger.ONE),
			BigInteger.valueOf(1).shiftLeft(16 * 5).subtract(BigInteger.ONE),
			BigInteger.valueOf(1).shiftLeft(16 * 6).subtract(BigInteger.ONE),
			BigInteger.valueOf(1).shiftLeft(16 * 7).subtract(BigInteger.ONE),
			BigInteger.valueOf(1).shiftLeft(16 * 8).subtract(BigInteger.ONE),
	};
	public static BigInteger getMaxValue(int segmentCount) {
		return MAX_VALUES_BY_SEGMENT[segmentCount];
	}
	@Override
	public IPv6AddressSection incrementBoundary(long increment) {
		if(increment <= 0) {
			if(increment == 0) {
				return this;
			}
			return getLower().increment(increment);
		}
		return getUpper().increment(increment);
	}
	public IPv6AddressSection increment(BigInteger bigIncrement) {
		if(bigIncrement.signum() == 0 && !isMultiple()) {
			return this;
		}
		checkOverflow(bigIncrement, this::getValue, this::getUpperValue, this::getCount, this::isSequential, () -> getMaxValue(getSegmentCount()));
		Integer prefixLength = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength();
		return increment(
				this,
				bigIncrement,
				getAddressCreator(), 
				this::getLower,
				this::getUpper,
				prefixLength);
	};
	@Override
	public IPv6AddressSection increment(long increment) {
		if(increment == 0 && !isMultiple()) {
			return this;
		}
		BigInteger bigIncrement = BigInteger.valueOf(increment);
		checkOverflow(increment, bigIncrement, this::getValue, this::getUpperValue, this::getCount, this::isSequential, () -> getMaxValue(getSegmentCount()));
		Integer prefixLength = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : getPrefixLength();
		IPv6AddressSection result = fastIncrement(
				this,
				increment,
				getAddressCreator(),
				this::getLower,
				this::getUpper,
				prefixLength);
		if(result != null) {
			return result;
		}
		return increment(
				this,
				increment,
				bigIncrement,
				getAddressCreator(), 
				this::getLower,
				this::getUpper,
				prefixLength);
	}
	@Override
	protected BigInteger getCountImpl(int segCount) {
		if(!isMultiple()) {
			return BigInteger.ONE;
		}
		BigInteger result = getCountIPv6(i -> getSegment(i).getValueCount(), segCount);
		return result;
	}
	private static BigInteger getCountIPv6(IntUnaryOperator segmentValueCountProvider, int segCount) {
		if(segCount < 0) {
			throw new IllegalArgumentException();
		}
		return count(segmentValueCountProvider, segCount, 2, 0x7fffffffffffL);
	}
	@Override
	protected BigInteger getZeroHostCountImpl(int prefixLength, int segCount) {
		if(includesZeroHost(prefixLength)) {
			if(isMultiple()) {
				int prefixedSegment = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
				BigInteger zeroHostCount = getCountIPv6(i -> {
					if(i == prefixedSegment) {
						IPAddressSegment seg = getSegment(i);
						int shift = seg.getBitCount() - getPrefixedSegmentPrefixLength(getBitsPerSegment(), prefixLength, i);
						int count = ((seg.getUpperSegmentValue() >>> shift) - (seg.getSegmentValue() >>> shift)) + 1;
						return count;
					}
					return getSegment(i).getValueCount();
				}, prefixedSegment + 1);
				return zeroHostCount;
			} else {
				return BigInteger.ONE;
			}
		}
		return BigInteger.ZERO;
	}
	@Override
	protected BigInteger getPrefixCountImpl() {
		Integer prefixLength = getPrefixLength();
		if(prefixLength == null || prefixLength >= getBitCount()) {
			return getCount();
		}
		return getPrefixCount(prefixLength);
	}
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		checkSubnet(this, prefixLength);
		if(isMultiple()) {
			int networkSegmentIndex = getNetworkSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
			int hostSegmentIndex = getHostSegmentIndex(prefixLength, getBytesPerSegment(), getBitsPerSegment());
			boolean hasPrefixedSegment = (networkSegmentIndex == hostSegmentIndex);
			return getCountIPv6(i -> {
				if(hasPrefixedSegment && i == networkSegmentIndex) {
					return getSegment(i).getPrefixValueCount();
				}
				return getSegment(i).getValueCount();
			}, networkSegmentIndex + 1);
		}
		return BigInteger.ONE;
	}
	private AddressSegmentCreator<IPv6AddressSegment> getSegmentCreator() {
		return getNetwork().getAddressCreator();
	}
	private IPv6AddressCreator getAddressCreator() {
		return getAddressCreator(addressSegmentIndex);
	}
	protected IPv6AddressCreator getAddressCreator(int startIndex) {
		IPv6AddressCreator creator = null, defaultCreator = getNetwork().getAddressCreator();
		boolean useCached = startIndex < IPv6Address.SEGMENT_COUNT;
		if(useCached) {
			creator = creators[startIndex];
		}
		if(creator != null) {
			useCached |= creator.getNetwork().equals(getNetwork());
			if(useCached) {
				return creator;
			}
		}
		creator = new IPv6AddressCreator(getNetwork(), defaultCreator.cache) {
			private static final long serialVersionUID = 4L;
			@Override
			protected IPv6AddressSection createSectionInternal(IPv6AddressSegment segments[]) {
				return getNetwork().getAddressCreator().createSectionInternal(segments, startIndex); /* address creation */
			}
			
			@Override
			protected IPv6AddressSection createPrefixedSectionInternal(IPv6AddressSegment segments[], Integer prefix, boolean singleOnly) {
				return new IPv6AddressSection(segments, startIndex, false, prefix, singleOnly);
			}
		};
		creator.useSegmentCache = defaultCreator.useSegmentCache;
		if(useCached) {
			creators[startIndex] = creator;
		}
		return creator;
	}
	@Override
	public IPv6AddressSegment getDivision(int index) {
		return (IPv6AddressSegment) super.getDivision(index);
	}
	@Override
	public IPv6AddressSegment getSegment(int index) {
		return (IPv6AddressSegment) super.getSegment(index);
	}
	public void getSegments(Collection<? super IPv6AddressSegment> segs) {
		getSegments(0, getSegmentCount(), segs);
	}
	public void getSegments(int start, int end, Collection<? super IPv6AddressSegment> segs) {
		for(int i = start; i < end; i++) {
			segs.add(getSegment(i));
		}
	}
	/**
	 * Equivalent to isEUI64(false)
	 * 
	 * @return
	 */
	public boolean isEUI64() {
		return isEUI64(false);
	}
	/**
	 * Whether this section is consistent with an EUI64 section,
	 * which means it came from an extended 8 byte address,
	 * and the corresponding segments in the middle match 0xff and 0xfe
	 * 
	 * @param partial whether missing segments are considered a match
	 * @return
	 */
	public boolean isEUI64(boolean partial) {
		int segmentCount = getSegmentCount();
		int endIndex = addressSegmentIndex + segmentCount;
		if(addressSegmentIndex <= 5) {
			if(endIndex > 6) {
				int index3 = 5 - addressSegmentIndex;
				IPv6AddressSegment seg3 = getSegment(index3);
				IPv6AddressSegment seg4 = getSegment(index3 + 1);
				return seg4.matchesWithMask(0xfe00, 0xff00) && seg3.matchesWithMask(0xff, 0xff);
			} else if(partial && endIndex == 6) {
				IPv6AddressSegment seg3 = getSegment(5 - addressSegmentIndex);
				return seg3.matchesWithMask(0xff, 0xff);
			}
		} else if(partial && addressSegmentIndex == 6 && endIndex > 6) {
			IPv6AddressSegment seg4 = getSegment(6 - addressSegmentIndex);
			return seg4.matchesWithMask(0xfe00, 0xff00);
		}
		return partial;
	}
	/**
	 * Returns the corresponding mac section, or null if this address section does not correspond to a mac section.
	 * If this address section has a prefix length it is ignored.
	 * 
	 * @param extended
	 * @return
	 */
	public MACAddressSection toEUI(boolean extended) {
		MACAddressSegment[] segs = toEUISegments(extended);
		if(segs == null) {
			return null;
		}
		MACAddressCreator creator = getMACNetwork().getAddressCreator();
		return createSectionInternal(creator, segs, Math.max(0, addressSegmentIndex - 4) << 1, extended);
	}
	protected static MACAddressSection createSectionInternal(MACAddressCreator creator, MACAddressSegment[] segments, int startIndex, boolean extended) {
		return AddressDivisionGrouping.createSectionInternal(creator, segments, startIndex, extended);
	}
	//prefix length in this section is ignored when converting to MAC
	MACAddressSegment[] toEUISegments(boolean extended) {
		IPv6AddressSegment seg0, seg1, seg2, seg3;
		int start = addressSegmentIndex;
		int segmentCount = getSegmentCount();
		int segmentIndex;
		if(start < 4) {
			start = 0;
			segmentIndex = 4 - start;
		} else {
			start -= 4;
			segmentIndex = 0;
		}
		int originalSegmentIndex = segmentIndex;
		seg0 = (start == 0 && segmentIndex < segmentCount) ? getSegment(segmentIndex++) : null;
		seg1 = (start <= 1 && segmentIndex < segmentCount) ? getSegment(segmentIndex++) : null;
		seg2 = (start <= 2 && segmentIndex < segmentCount) ? getSegment(segmentIndex++) : null;
		seg3 = (start <= 3 && segmentIndex < segmentCount) ? getSegment(segmentIndex++) : null;
		int macSegCount = (segmentIndex - originalSegmentIndex) << 1;
		if(!extended) {
			macSegCount -= 2;
		}
		if((seg1 != null && !seg1.matchesWithMask(0xff, 0xff)) || (seg2 != null && !seg2.matchesWithMask(0xfe00, 0xff00)) || macSegCount == 0) {
			return null;
		}
		MACAddressCreator creator = getMACNetwork().getAddressCreator();
		MACAddressSegment ZERO_SEGMENT = creator.createSegment(0);
		MACAddressSegment newSegs[] = creator.createSegmentArray(macSegCount);
		int macStartIndex = 0;
		if(seg0 != null) {
			seg0.getSplitSegments(newSegs, macStartIndex, creator);
			//toggle the u/l bit
			MACAddressSegment macSegment0 = newSegs[0];
			int lower0 = macSegment0.getSegmentValue();
			int upper0 = macSegment0.getUpperSegmentValue();
			int mask2ndBit = 0x2;
			if(!macSegment0.matchesWithMask(mask2ndBit & lower0, mask2ndBit)) {
				return null;
			}
			//you can use matches with mask
			lower0 ^= mask2ndBit;//flip the universal/local bit
			upper0 ^= mask2ndBit;
			newSegs[0] = creator.createSegment(lower0, upper0, null);
			macStartIndex += 2;
		}
		if(seg1 != null) {
			seg1.getSplitSegments(newSegs, macStartIndex, creator);  //a ff fe b
			if(!extended) {
				newSegs[macStartIndex + 1] = ZERO_SEGMENT;
			}
			macStartIndex += 2;
		}
		if(seg2 != null) {
			if(!extended) {
				if(seg1 != null) {
					macStartIndex -= 2;
					MACAddressSegment first = newSegs[macStartIndex];
					seg2.getSplitSegments(newSegs, macStartIndex, creator);
					newSegs[macStartIndex] = first;
				} else {
					seg2.getSplitSegments(newSegs, macStartIndex, creator);
					newSegs[macStartIndex] = ZERO_SEGMENT;
				}
			} else {
				seg2.getSplitSegments(newSegs, macStartIndex, creator);
			}
			macStartIndex += 2;
		}
		if(seg3 != null) {
			seg3.getSplitSegments(newSegs, macStartIndex, creator);
		}
		return newSegs;
	}
	/**
	 * Produces an IPv4 address section from any sequence of bytes in this IPv6 address section
	 * 
	 * @param startIndex the byte index in this section to start from
	 * @param endIndex the byte index in this section to end at
	 * @throws IndexOutOfBoundsException
	 * @return
	 * 
	 * @see #getEmbeddedIPv4AddressSection()
	 * @see #getMixedAddressSection()
	 */
	public IPv4AddressSection getEmbeddedIPv4AddressSection(int startIndex, int endIndex) {
		if(startIndex == ((IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - this.addressSegmentIndex) << 1) && endIndex == (getSegmentCount() << 1)) {
			return getEmbeddedIPv4AddressSection();
		}
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		IPv4AddressSegment[] segments = creator.createSegmentArray(endIndex - startIndex);
		int i = startIndex, j = 0;
		int bytesPerSegment = getBytesPerSegment();
		if(i % bytesPerSegment == 1) {
			IPv6AddressSegment ipv6Segment = getSegment(i >> 1);
			i++;
			ipv6Segment.getSplitSegments(segments, j - 1, creator);
			j++;
		}
		for(; i < endIndex; i += bytesPerSegment, j += bytesPerSegment) {
			IPv6AddressSegment ipv6Segment = getSegment(i >> 1);
			ipv6Segment.getSplitSegments(segments, j, creator);
		}
		return createEmbeddedSection(creator, segments, this);
	}
	/**
	 * Gets the IPv4 section corresponding to the lowest (least-significant) 4 bytes in the original address,
	 * which will correspond to between 0 and 4 bytes in this address.  Many IPv4 to IPv6 mapping schemes (but not all) use these 4 bytes for a mapped IPv4 address.
	 * 
	 * @see #getEmbeddedIPv4AddressSection(int, int)
	 * @see #getMixedAddressSection()
	 * @return the embedded IPv4 section or null
	 */
	public IPv4AddressSection getEmbeddedIPv4AddressSection() {
		if(embeddedIPv4Section == null) {
			synchronized(this) {
				if(embeddedIPv4Section == null) {
					int mixedCount = getSegmentCount() - Math.max(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSegmentIndex, 0);
					int lastIndex = getSegmentCount() - 1;
					IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
					IPv4AddressSegment[] mixed;
					if(mixedCount == 0) {
						mixed = creator.createSegmentArray(0);
					} else {
						if(mixedCount == 1) {
							mixed = creator.createSegmentArray(getBytesPerSegment());
							IPv6AddressSegment last = getSegment(lastIndex);
							last.getSplitSegments(mixed, 0, creator);
						} else {
							mixed = creator.createSegmentArray(getBytesPerSegment() << 1);
							IPv6AddressSegment low = getSegment(lastIndex);
							IPv6AddressSegment high = getSegment(lastIndex - 1);
							high.getSplitSegments(mixed, 0, creator);
							low.getSplitSegments(mixed, getBytesPerSegment(), creator);
						}
					}
					embeddedIPv4Section = createEmbeddedSection(creator, mixed, this);
				}
			}
		}
		return embeddedIPv4Section;
	}
	public IPv6AddressSection createNonMixedSection() {
		int mixedCount = getSegmentCount() - Math.max(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSegmentIndex, 0);
		if(mixedCount <= 0) {
			return this;
		}
		int nonMixedCount = Math.max(0, getSegmentCount() - mixedCount);
		IPv6AddressCreator creator = getNetwork().getAddressCreator();
		IPv6AddressSegment[] nonMixed = creator.createSegmentArray(nonMixedCount);
		getSegments(0, nonMixedCount, nonMixed, 0);
		return creator.createEmbeddedSectionInternal(this, nonMixed, addressSegmentIndex);
	}
	public IPv6v4MixedAddressSection getMixedAddressSection() {
		if(defaultMixedAddressSection == null) {
			synchronized(this) {
				if(defaultMixedAddressSection == null) {
					defaultMixedAddressSection = new IPv6v4MixedAddressSection(
							createNonMixedSection(),
							getEmbeddedIPv4AddressSection());
				}
			}
		}
		return defaultMixedAddressSection;
	}
	public static IPv6AddressSection createSection(IPv6AddressCreator creator, IPv6AddressSegment nonMixedSection[], IPv4Address mixedSection) throws IncompatibleAddressException {
		IPv4AddressSection ipv4Section = mixedSection.getSection();
		IPv6AddressSegment newSegs[] = creator.createSegmentArray(nonMixedSection.length + IPv6Address.MIXED_REPLACED_SEGMENT_COUNT);
		newSegs[0] = nonMixedSection[0];
		newSegs[1] = nonMixedSection[1];
		newSegs[2] = nonMixedSection[2];
		newSegs[3] = nonMixedSection[3];
		newSegs[4] = nonMixedSection[4];
		newSegs[5] = nonMixedSection[5];
		newSegs[6] = ipv4Section.getSegment(0).join(creator, ipv4Section.getSegment(1));
		newSegs[7] = ipv4Section.getSegment(2).join(creator, ipv4Section.getSegment(3));
		IPv6AddressSection result = creator.createSectionInternal(newSegs);
		result.embeddedIPv4Section = ipv4Section;
		return result;
	}
	/**
	 * Create an IPv6 mixed address using the given address for the embedded IPv4 segments
	 * 
	 * @param mixedSection the IPv4 address used to construct the terminating segments of the returned address
	 * @return
	 */
	public IPv6Address getIPv6Address(IPv4Address mixedSection) {
		return mixedSection.getIPv6Address(getSegmentsInternal());
	}
	@Override
	public int getBitsPerSegment() {
		return IPv6Address.BITS_PER_SEGMENT;
	}
	@Override
	public int getBytesPerSegment() {
		return IPv6Address.BYTES_PER_SEGMENT;
	}
	@Override
	public int getBitCount() {
		return getSegmentCount() << 4;
	}
	@Override
	public int getByteCount() {
		return getSegmentCount() << 1;
	}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		byte bytes[] = new byte[getByteCount()];
		int segmentCount = getSegmentCount();
		for(int i = 0; i < segmentCount; i++) {
			IPv6AddressSegment seg = getSegment(i);
			int byteIndex = i << 1;
			int val = low ? seg.getSegmentValue() : seg.getUpperSegmentValue();
			bytes[byteIndex] = (byte) (val >>> 8);
			bytes[byteIndex + 1] = (byte) val;
		}
		return bytes;
	}
	@Override
	protected byte[] getBytesInternal() {
		return super.getBytesInternal();
	}
	/**
	 * Returns whether this subnet or address has alphabetic digits when printed.
	 * 
	 * Note that this method does not indicate whether any address contained within this subnet has alphabetic digits,
	 * only whether the subnet itself when printed has alphabetic digits.
	 * 
	 * @return whether the section has alphabetic digits when printed.
	 */
	public boolean hasUppercaseVariations(int base, boolean lowerOnly) {
		if(base > 10) {
			int count = getSegmentCount();
			for(int i = 0; i < count; i++) {
				IPv6AddressSegment seg = getSegment(i);
				if(seg.hasUppercaseVariations(base, lowerOnly)) {
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public boolean isIPv6() {
		return true;
	}
	@Override
	public IPVersion getIPVersion() {
		return IPVersion.IPV6;
	}
	public IPv6AddressSection append(IPv6AddressSection other) {
		int count = getSegmentCount();
		return replace(count, count, other, 0, other.getSegmentCount());
	}
	public IPv6AddressSection appendToNetwork(IPv6AddressSection other) {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null) {
			return append(other);
		}
		IPv6AddressSection thizz = this;
		int bitsPerSegment = getBitsPerSegment();
		int adjustment = prefixLength % bitsPerSegment;
		if(adjustment != 0) {
			prefixLength += bitsPerSegment - adjustment;
			thizz = setPrefixLength(prefixLength, false);
		}
		int index = prefixLength >>> 4;
		if(other.isPrefixed() && other.getPrefixLength() == 0) {
			//replacement is all host, cannot make it part of network
			return insert(index, other); //return append(other);
		}
		return thizz.replace(index, index, other, 0, other.getSegmentCount(), true);
	}
	public IPv6AddressSection insert(int index, IPv6AddressSection other) {
		return replace(index, index, other, 0, other.getSegmentCount());
	}
	/**
	 * Replace the segments of this section starting at the given index with the given replacement segments
	 * 
	 * @param index
	 * @param replacement
	 * @return
	 */
	public IPv6AddressSection replace(int index, IPv6AddressSection replacement) {
		return replace(index, index + replacement.getSegmentCount(), replacement, 0, replacement.getSegmentCount());
	}
	/**
	 * Replaces segments starting from startIndex and ending before endIndex with the segments starting at replacementStartIndex and 
	 * ending before replacementEndIndex from the replacement section
	 * @param startIndex
	 * @param endIndex
	 * @param replacement
	 * @param replacementStartIndex
	 * @param replacementEndIndex
	 * @throws IndexOutOfBoundsException
	 * @throws AddressValueException if the resulting section would exceed the maximum segment count for this address type and version
	 * @return
	 */
	public IPv6AddressSection replace(int startIndex, int endIndex, IPv6AddressSection replacement, int replacementStartIndex, int replacementEndIndex) {
		return replace(startIndex, endIndex, replacement, replacementStartIndex, replacementEndIndex, false);
	}
	public IPv6AddressSection replace(int startIndex, int endIndex, IPv6AddressSection replacement, int replacementStartIndex, int replacementEndIndex, boolean appendNetwork) {
		int segmentCount = getSegmentCount();
		int replacedCount = endIndex - startIndex;
		int replacementCount = replacementEndIndex - replacementStartIndex;
		if(replacedCount < 0 || replacementCount < 0 || startIndex < 0 || replacementStartIndex < 0 || replacementEndIndex > replacement.getSegmentCount() || endIndex > segmentCount) {
			throw new IndexOutOfBoundsException();
		}
		IPv6AddressSection thizz = this;
		if(addressSegmentIndex + segmentCount + replacementCount - replacedCount > IPv6Address.SEGMENT_COUNT) {
			throw new AddressValueException(this, replacement);
		} else if(replacementCount == 0 && replacedCount == 0) {//keep in mind for ipvx, empty sections cannot have prefix lengths
			return this;
		} else if(addressSegmentIndex == replacement.addressSegmentIndex && segmentCount == replacedCount) {//keep in mind for ipvx, empty sections cannot have prefix lengths
			return replacement;
		} else if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			if(appendNetwork) {
				thizz = withoutPrefixLength();
				int replacementEndBits = replacementEndIndex << 4;
				if(!replacement.isPrefixed() || replacement.getNetworkPrefixLength() > replacementEndBits) {
					replacement = replacement.setPrefixLength(replacementEndBits, false);
				}
			}
		} else {
			Integer prefixLength = getPrefixLength();
			if(appendNetwork) { 
				int additionalSegs = segmentCount - endIndex;
				if(additionalSegs > 0) {
					//we move the non-replaced host segments from the end of this to the end of the replacement segments
					//and we also remove the prefix length from this
					thizz = getSection(0, startIndex).withoutPrefixLength();
					replacement = replacement.insert(replacementEndIndex, getSection(endIndex));
					replacementEndIndex += additionalSegs;
					endIndex = startIndex;
				} else {
					thizz = withoutPrefixLength();
					int replacementEndBits = replacementEndIndex << 4;
					if(!replacement.isPrefixed() || replacement.getNetworkPrefixLength() > replacementEndBits) {
						replacement = replacement.setPrefixLength(replacementEndBits, false);
					}
				}
			} else if(prefixLength != null && prefixLength <= startIndex << 4) {
				replacement = replacement.setPrefixLength(0, false);
			} else if(endIndex < segmentCount) {
				int replacementEndBits = replacementEndIndex << 4;
				if(replacement.isPrefixed() && replacement.getNetworkPrefixLength() <= replacementEndBits) {
					int thisNextIndexBits = endIndex << 4;
					if(prefixLength == null || prefixLength > thisNextIndexBits) {
						if(replacedCount > 0 || replacement.getPrefixLength() == 0) {
							thizz = setPrefixLength(thisNextIndexBits, false);
						} else {
							//we move the non-replaced host segments from the end of this to the end of the replacement segments
							//and we also remove the prefix length from this
							int additionalSegs = segmentCount - endIndex;
							thizz = getSection(0, startIndex);
							replacement = replacement.insert(replacementEndIndex, getSection(endIndex));
							replacementEndIndex += additionalSegs;
						}
					}
				}
			}
		}
		return replace(thizz, startIndex, endIndex, replacement, replacementStartIndex, replacementEndIndex, getAddressCreator(), appendNetwork, false);
	}
	@Override
	public boolean overlaps(AddressSection other) {
		return other instanceof IPv6AddressSection &&
				addressSegmentIndex == ((IPv6AddressSection) other).addressSegmentIndex && 
				overlaps(this, other);
	}
	@Override
	public boolean contains(AddressSection other) {
		return other instanceof IPv6AddressSection &&
				addressSegmentIndex == ((IPv6AddressSection) other).addressSegmentIndex && 
				super.contains(other);
	}
	@Override
	protected boolean containsNonZeroHostsImpl(IPAddressSection other, int otherPrefixLength) {
		if(other instanceof IPv6AddressSection) {
			IPv6AddressSection remaining[] = ((IPv6AddressSection) other).subtract(this);
			if(remaining != null) {
				for(int i = 0; i < remaining.length; i++) {
					if(!remaining[i].isZeroHost(otherPrefixLength)) {
						return false;
					}
				}
			}
			return true;
		}
		return false;
	}
	// called by addresses
	static BigInteger enumerate(IPv6AddressSection addr, AddressSection other) {
		return enumerateBig(addr, other);
	}
	@Override
	public BigInteger enumerate(AddressSection other) {
		if(other instanceof IPv6AddressSection) {
			IPv6AddressSection otherSec = (IPv6AddressSection) other;
			checkSegmentCount(other);
			if(addressSegmentIndex != otherSec.addressSegmentIndex) {
				throw new AddressPositionException(this, addressSegmentIndex, otherSec.addressSegmentIndex);
			} else if(getSegmentCount() < 4) {
				Long result = enumerateSmall(this, other);
				if(result == null) {
					return null;
				}
				return BigInteger.valueOf(result);
			}
			return enumerateBig(this, other);
		}
		return null;
	}
	@Override
	public boolean prefixEquals(AddressSection o) {
		if(o == this) {
			return true;
		} else if(o instanceof IPv6AddressSection) {
			IPv6AddressSection other = (IPv6AddressSection) o;
			if(addressSegmentIndex >= other.addressSegmentIndex) {
				return prefixEquals(this, other, addressSegmentIndex - other.addressSegmentIndex);
			}
		}
		return false;
	}
	@Override
	public boolean prefixContains(IPAddressSection o) {
		if(o == this) {
			return true;
		} else if(o instanceof IPv6AddressSection) {
			IPv6AddressSection other = (IPv6AddressSection) o;
			if(addressSegmentIndex >= other.addressSegmentIndex) {
				return prefixContains(this, other, addressSegmentIndex - other.addressSegmentIndex);
			}
		}
		return false;
	}
	@Override
	public boolean matchesWithMask(IPAddressSection other, IPAddressSection mask) {
		return other instanceof IPv6AddressSection && mask instanceof IPv6AddressSection && super.matchesWithMask(other, mask);
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof IPv6AddressSection &&
				super.isSameGrouping(other);
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof IPv6AddressSection) {
			IPv6AddressSection other = (IPv6AddressSection) o;
			return addressSegmentIndex == other.addressSegmentIndex && other.isSameGrouping(this);
		}
		return false;
	}
	/**
	 * Produces the subnet sections whose addresses are found in both this and the given argument.
	 * <p>
	 * This is also known as the conjunction of the two sets of address sections.
	 * <p>
	 * @param other
	 * @return the section containing the sections found in both this and the given subnet sections
	 */
	public IPv6AddressSection intersect(IPv6AddressSection other) throws SizeMismatchException {
		return intersect(this, other, getAddressCreator(), this::getSegment, other::getSegment);
	}
	/**
	 * Subtract the give subnet from this subnet, returning an array of sections for the result (the subnets will not be contiguous so an array is required).
	 * <p>
	 * Computes the subnet difference, the set of addresses in this address section but not in the provided section.  This is also known as the relative complement of the given argument in this subnet.
	 * <p>
	 * Keep in mind this is set subtraction, not subtraction of segment values.  We have a subnet of addresses and we are removing some of those addresses.
	 * 
	 * @param other
	 * @throws SizeMismatchException if the two sections have different sizes
	 * @return the difference
	 */
	public IPv6AddressSection[] subtract(IPv6AddressSection other) throws SizeMismatchException {
		return subtract(this, other, getAddressCreator(), this::getSegment, (section, prefix) -> section.setPrefixLength(prefix, false, true));
	}
	@Override
	public IPv6AddressNetwork getNetwork() {
		return Address.defaultIpv6Network();
	}
	public IPv4AddressNetwork getIPv4Network() {
		return Address.defaultIpv4Network();
	}
	public MACAddressNetwork getMACNetwork() {
		return Address.defaultMACNetwork();
	}
	@Override
	public IPv6AddressSection adjustPrefixBySegment(boolean nextSegment) {
		return adjustPrefixBySegment(nextSegment, true);
	}
	@Override
	public IPv6AddressSection adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return (IPv6AddressSection) super.adjustPrefixBySegment(nextSegment, zeroed);
	}
	@Override
	public IPv6AddressSection adjustPrefixLength(int adjustment) {
		return adjustPrefixLength(adjustment, true);
	}
	@Override
	public IPv6AddressSection adjustPrefixLength(int adjustment, boolean zeroed) {
		return (IPv6AddressSection) adjustPrefixLength(this, adjustment, zeroed, getAddressCreator(), (section, i) -> section.getSegment(i));
	}
	@Deprecated
	@Override
	public IPv6AddressSection applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return setPrefixLength(networkPrefixLength, true, true, true);
	}
	@Override
	public IPv6AddressSection setPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return setPrefixLength(networkPrefixLength, true, false, true);
	}
	@Override
	public IPv6AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros) throws PrefixLenException {
		return setPrefixLength(networkPrefixLength, withZeros, false, true);
	}
	@Override
	public IPv6AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros, boolean zeroHostIsBlock) throws PrefixLenException {
		return setPrefixLength(networkPrefixLength, withZeros, false, zeroHostIsBlock);
	}
	private IPv6AddressSection setPrefixLength(int networkPrefixLength, boolean withZeros, boolean noShrink, boolean zeroHostIsBlock) {
		return setPrefixLength(
				this,
				getAddressCreator(),
				networkPrefixLength,
				withZeros,
				noShrink,
				!zeroHostIsBlock,
				(section, i) -> section.getSegment(i));
	}
	@Override @Deprecated
	public IPv6AddressSection removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public IPv6AddressSection withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override @Deprecated
	public IPv6AddressSection removePrefixLength(boolean zeroed) {
		return removePrefixLength(this, zeroed, getAddressCreator(), IPv6AddressSection::getSegment);
	}
	/**
	 * Does the bitwise disjunction with this address.  Useful when subnetting.  Similar to {@link #maskNetwork(IPv6AddressSection, int)} which does the bitwise conjunction.
	 * <p>
	 * Any existing prefix length is dropped for the new prefix length and the mask is applied up to the end the new prefix length.
	 * 
	 * @param mask
	 * @return
	 * @throws IncompatibleAddressException
	 */
	public IPv6AddressSection bitwiseOrNetwork(IPv6AddressSection mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		IPv6AddressSection networkMask = getNetwork().getNetworkMaskSection(networkPrefixLength);
		return getOredSegments(
				this,
				cacheBits(networkPrefixLength),
				getAddressCreator(), 
				true,
				this::getSegment, 
				i -> {
					int val1 = mask.getSegment(i).getSegmentValue();
					int val2 = networkMask.getSegment(i).getSegmentValue();
					return val1 & val2;
				}
		);
	}
	/**
	 * Equivalent to {@link #bitwiseOr(IPv6AddressSection, boolean)} with the second argument as false.
	 */
	public IPv6AddressSection bitwiseOr(IPv6AddressSection mask) throws IncompatibleAddressException {
		return bitwiseOr(mask, false);
	}
	/**
	 * Does the bitwise disjunction with this address.  Useful when subnetting.  Similar to {@link #mask(IPv6AddressSection)} which does the bitwise conjunction.
	 * 
	 * @param mask
	 * @param retainPrefix whether to drop the prefix
	 * @return
	 * @throws IncompatibleAddressException
	 */
	public IPv6AddressSection bitwiseOr(IPv6AddressSection mask, boolean retainPrefix) throws IncompatibleAddressException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		return getOredSegments(
				this,
				retainPrefix ? getPrefixLength() : null,
				getAddressCreator(),
				true,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	@Override
	public IPv6AddressSection toZeroHost() throws IncompatibleAddressException {
		if(!isPrefixed()) {
			IPv6AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv6Address networkMask = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				networkMask = networkMask.getLower();
			}
			return networkMask.getSection(0, getSegmentCount());
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();//cached
		}
		return createZeroHost(false);
	}
	IPv6AddressSection createZeroHost(boolean boundariesOnly) {
		int prefixLength = getNetworkPrefixLength();
		IPv6AddressNetwork network = getNetwork();
		IPv6Address mask = network.getNetworkMask(prefixLength);
		return getSubnetSegments(
				this,
				network.getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : cacheBits(prefixLength),
				getAddressCreator(),
				!boundariesOnly,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	@Override
	public IPv6AddressSection toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		IPv6Address mask = getNetwork().getNetworkMask(prefixLength);
		return getSubnetSegments(
				this,
				null,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	@Override
	public IPv6AddressSection toZeroNetwork() {
		if(!isPrefixed()) {
			IPv6Address hostMask = getNetwork().getHostMask(getBitCount());
			return hostMask.getSection(0, getSegmentCount());
		}
		return createZeroNetwork();
	}
	IPv6AddressSection createZeroNetwork() {
		Integer prefixLength = getNetworkPrefixLength();
		IPv6Address mask = getNetwork().getHostMask(prefixLength);
		return getSubnetSegments(
				this,
				prefixLength,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				true);
	}
	@Override
	public IPv6AddressSection toMaxHost() throws IncompatibleAddressException {
		if(!isPrefixed()) {
			IPv6Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix.getSection(0, getSegmentCount());
			}
			return resultNoPrefix.setPrefixLength(0).getSection(0, getSegmentCount());
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();//cached
		}
		return createMaxHost();
	}
	public IPv6AddressSection createMaxHost() {
		Integer prefixLength = getNetworkPrefixLength();//we know it is prefixed here so no NullPointerException
		IPv6Address mask = getNetwork().getHostMask(prefixLength);
		return getOredSegments(
				this,
				getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() ? null : prefixLength,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	@Override
	public IPv6AddressSection toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == this.getNetworkPrefixLength()) {
			return toMaxHost();
		}
		IPv6Address mask = getNetwork().getHostMask(prefixLength);
		return getOredSegments(
				this,
				null,
				getAddressCreator(),
				false,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue());
	}
	/**
	 * Does the bitwise conjuction with this address.  Useful when subnetting.
	 * 
	 * @param mask
	 * @param retainPrefix whether to drop the prefix
	 * @return
	 * @throws IncompatibleAddressException
	 */
	public IPv6AddressSection mask(IPv6AddressSection mask, boolean retainPrefix) throws IncompatibleAddressException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		return getSubnetSegments(
				this,
				retainPrefix ? getPrefixLength() : null,
				getAddressCreator(),
				true,
				this::getSegment,
				i -> mask.getSegment(i).getSegmentValue(),
				false);
	}
	/**
	 * Equivalent to {@link #mask(IPv6AddressSection, boolean)} with the second argument as false.
	 */
	public IPv6AddressSection mask(IPv6AddressSection mask) throws IncompatibleAddressException, SizeMismatchException {
		return mask(mask, false);
	}
	/**
	 * Applies the given mask to the network section of the address as indicated by the given prefix length.
	 * Useful for subnetting.  Once you have zeroed a section of the network you can insert bits 
	 * using {@link #bitwiseOr(IPv6AddressSection)} or {@link #replace(int, IPv6AddressSection)}
	 * 
	 * @param mask
	 * @param networkPrefixLength
	 * @return
	 * @throws IncompatibleAddressException
	 */
	public IPv6AddressSection maskNetwork(IPv6AddressSection mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, SizeMismatchException {
		checkMaskSegmentCount(mask);
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return getSubnetSegments(
					this,
					cacheBits(networkPrefixLength),
					getAddressCreator(),
					true,
					this::getSegment,
					i -> mask.getSegment(i).getSegmentValue(),
					false);
		}
		IPv6AddressSection hostMask = getNetwork().getHostMaskSection(networkPrefixLength);
		return getSubnetSegments(
				this,
				cacheBits(networkPrefixLength),
				getAddressCreator(),
				true, 
				this::getSegment, 
				i -> {
					int val1 = mask.getSegment(i).getSegmentValue();
					int val2 = hostMask.getSegment(i).getSegmentValue();
					return val1 | val2;
				},
				false
		);
	}
	protected static Integer cacheBits(int i) {
		return IPAddressSection.cacheBits(i);
	}
	@Override
	public IPv6AddressSection getHostMask() {
		return (IPv6AddressSection) super.getHostMask();
	}
	@Override
	public IPv6AddressSection getNetworkMask() {
		return (IPv6AddressSection) super.getNetworkMask();
	}
	@Override
	public IPv6AddressSection getNetworkSection() {
		if(isPrefixed()) {
			return getNetworkSection(getNetworkPrefixLength());
		}
		return getNetworkSection(getBitCount());
	}
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getNetworkSection(networkPrefixLength, true);
	}
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getNetworkSection(this, networkPrefixLength, withPrefixLength, getAddressCreator(), (prefix, i) -> getSegment(i).toNetworkSegment(prefix, withPrefixLength));
	}
	@Override
	public IPv6AddressSection getHostSection() {
		if(isPrefixed()) {
			return getHostSection(getNetworkPrefixLength());
		}
		return getHostSection(0);
	}
	@Override
	public IPv6AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		int hostSegmentCount = getHostSegmentCount(networkPrefixLength);
		IPv6AddressCreator creator = getAddressCreator(addressSegmentIndex + (getSegmentCount() - hostSegmentCount));
		return getHostSection(this, networkPrefixLength, hostSegmentCount, creator, (prefix, i) -> getSegment(i).toHostSegment(prefix));
	}
	@Override
	public IPv6AddressSection toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv6AddressSection assignPrefixForSingleBlock() {
		return (IPv6AddressSection) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv6AddressSection assignMinPrefixForBlock() {
		return (IPv6AddressSection) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv6AddressSection toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return toPrefixBlock(this, networkPrefixLength, getAddressCreator(), (prefix, i) -> getSegment(i).toNetworkSegment(prefix, true));
	}
	@Override
	public IPv6AddressSection coverWithPrefixBlock() {
		return (IPv6AddressSection) coverWithPrefixBlock(this, getLower(), getUpper());
	}
	public IPv6AddressSection coverWithPrefixBlock(IPv6AddressSection other) throws AddressConversionException {
		checkSegmentCount(other);
		return coverWithPrefixBlock(
				this,
				other,
				IPv6AddressSection::getLower,
				IPv6AddressSection::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	protected static <T extends IPAddressSegmentSeries> T coverWithPrefixBlock(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator) throws AddressConversionException {
		return IPAddressSection.coverWithPrefixBlock(first, other, getLower, getUpper, comparator);
	}
	protected static IPAddressSegmentSeries coverWithPrefixBlock(
			IPAddressSegmentSeries original,
			IPAddressSegmentSeries lower,
			IPAddressSegmentSeries upper) {
		return IPAddressSection.coverWithPrefixBlock(original, lower, upper);
	}
	/**
	 * Produces an array of prefix blocks that spans the same set of values.
	 * <p>
	 * Unlike {@link #spanWithPrefixBlocks(IPv6AddressSection)} this method only includes blocks that are a part of this section.
	 */
	@Override
	public IPv6AddressSection[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv6AddressSection[] {this};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6AddressSection> list = (ArrayList<IPv6AddressSection>) spanWithBlocks(true);
		return list.toArray(new IPv6AddressSection[list.size()]);
	}
	/**
	 * Produces the list of prefix block subnets that span from this series to the given series.
	 * 
	 * @param other
	 * @return
	 */
	public IPv6AddressSection[] spanWithPrefixBlocks(IPv6AddressSection other) throws AddressPositionException {
		if(other.addressSegmentIndex != addressSegmentIndex) {
			throw new AddressPositionException(other, other.addressSegmentIndex, addressSegmentIndex);
		}
		return getSpanningPrefixBlocks(
				this,
				other,
				IPv6AddressSection::getLower,
				IPv6AddressSection::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6AddressSection::assignPrefixForSingleBlock,
				IPv6AddressSection::withoutPrefixLength,
				getAddressCreator()::createSectionArray);
	}
	/**
	 * 
	 * @param other
	 * @deprecated use {@link #spanWithSequentialBlocks(IPv6AddressSection)}
	 * @return
	 */
	@Deprecated
	public IPv6AddressSection[] spanWithRangedSegments(IPv6AddressSection other) {
		return spanWithSequentialBlocks(other);
	}
	/**
	 * Produces an array of blocks that are sequential that cover the same set of sections as this.
	 * <p>
	 * This array can be shorter than that produced by {@link #spanWithPrefixBlocks()} and is never longer.
	 * <p>
	 * Unlike {@link #spanWithSequentialBlocks(IPv6AddressSection)} this method only includes values that are a part of this section.
	 */
	@Override
	public IPv6AddressSection[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv6AddressSection[] { withoutPrefixLength() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6AddressSection> list = (ArrayList<IPv6AddressSection>) spanWithBlocks(false);
		return list.toArray(new IPv6AddressSection[list.size()]);
	}
	/**
	 * Produces a list of range subnets that span from this series to the given series.
	 * 
	 * @param other
	 * @return
	 */
	public IPv6AddressSection[] spanWithSequentialBlocks(IPv6AddressSection other) throws AddressPositionException {
		if(other.addressSegmentIndex != addressSegmentIndex) {
			throw new AddressPositionException(other, other.addressSegmentIndex, addressSegmentIndex);
		}
		return getSpanningSequentialBlocks(
				this,
				other,
				IPv6AddressSection::getLower,
				IPv6AddressSection::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6AddressSection::withoutPrefixLength,
				getAddressCreator());
	}
	/**
	 * 
	 * @param sections
	 * @deprecated use {@link #mergeToPrefixBlocks(IPv6AddressSection...)}
	 * @return
	 * @throws SizeMismatchException
	 */
	@Deprecated
	public IPv6AddressSection[] mergePrefixBlocks(IPv6AddressSection ...sections) throws SizeMismatchException {
		return mergeToPrefixBlocks(sections);
	}
	/**
	 * Merges this with the list of sections to produce the smallest array of prefix blocks.
	 * <p>
	 * The resulting array is sorted from lowest address value to highest, regardless of the size of each prefix block.
	 * <p>
	 * In version 5.3.1 and earlier, the result was sorted from single address to smallest blocks to largest blocks.
	 * For that ordering, sort with {@link IPAddressSegmentSeries#getPrefixLenComparator()}:<br>
	 * <code>Arrays.sort(result, IPAddressSegmentSeries.getPrefixLenComparator());</code>
	 * 
	 * @param sections the sections to merge with this
	 * @return
	 */
	public IPv6AddressSection[] mergeToPrefixBlocks(IPv6AddressSection ...sections) throws SizeMismatchException, AddressPositionException {
		checkSectionsMergeable(sections);
		IPv6AddressSection[] converted = getCloned(sections);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv6AddressSection[blocks.size()]);
	}
	private IPv6AddressSection[] getCloned(IPv6AddressSection... sections) {
		IPv6AddressSection converted[] = new IPv6AddressSection[sections.length + 1];
		System.arraycopy(sections, 0, converted, 1, sections.length);
		converted[0] = this;
		return converted;
	}
	private void checkSectionsMergeable(IPv6AddressSection sections[]) {
		for(int i = 0; i < sections.length; i++) {
			IPv6AddressSection section = sections[i];
			if(section == null) {
				continue;
			}
			if(section.addressSegmentIndex != addressSegmentIndex) {
				throw new AddressPositionException(section, section.addressSegmentIndex, addressSegmentIndex);
			}
			if(section.getSegmentCount() != getSegmentCount()) {
				throw new SizeMismatchException(this, section);
			}
		}
	}
	/**
	 * Merges this with the list of sections to produce the smallest array of sequential block subnets, going from smallest to largest
	 * <p>
	 * The resulting array is sorted by lower address, regardless of the size of each prefix block.
	 * <p>
	 * In version 5.3.1 and earlier, the result was sorted from single address to smallest blocks to largest blocks.
	 * For that ordering, sort with {@link IPAddressSegmentSeries#getPrefixLenComparator()}:<br>
	 * <code>Arrays.sort(result, IPAddressSegmentSeries.getPrefixLenComparator());</code>
	 * 
	 * @param sections the sections to merge with this
	 * @return
	 */
	public IPv6AddressSection[] mergeToSequentialBlocks(IPv6AddressSection ...sections) throws SizeMismatchException {
		checkSectionsMergeable(sections);
		IPv6AddressSection[] converted = getCloned(sections);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getAddressCreator()::createSequentialBlockSection);
		return blocks.toArray(new IPv6AddressSection[blocks.size()]);
	}
	////////////////string creation below ///////////////////////////////////////////////////////////////////////////////////////////
	@Override
	protected boolean hasNoStringCache() {
		if(stringCache == null) {
			synchronized(this) {
				if(stringCache == null) {
					stringCache = new IPv6StringCache();
					return true;
				}
			}
		}
		return false;
	}
	@Override
	protected IPv6StringCache getStringCache() {
		return stringCache;
	}
	/**
	 * This produces the shortest valid string for the address.
	 */
	@Override
	public String toCompressedString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().compressedString) == null) {
			getStringCache().compressedString = result = toNormalizedString(IPv6StringCache.compressedParams);
		}
		return result;
	}
	/**
	 * This produces a canonical string.
	 * 
	 * RFC 5952 describes canonical representations.
	 * http://en.wikipedia.org/wiki/IPv6_address#Recommended_representation_as_text
	 * http://tools.ietf.org/html/rfc5952
	 */
	@Override
	public String toCanonicalString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalString) == null) {
			stringCache.canonicalString = result = toNormalizedString(IPv6StringCache.canonicalParams);
		}
		return result;
	}
	/**
	 * This produces the mixed IPv6/IPv4 string.  It is the shortest such string (ie fully compressed).
	 */
	public String toMixedString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().mixedString) == null) {
			getStringCache().mixedString = result = toNormalizedString(IPv6StringCache.mixedParams);
		}
		return result;
	}
	/**
	 * This produces a string with no compressed segments and all segments of full length,
	 * which is 4 characters for IPv6 segments and 3 characters for IPv4 segments.
	 */
	@Override
	public String toFullString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().fullString) == null) {
			getStringCache().fullString = result = toNormalizedString(IPv6StringCache.fullParams);
		}
		return result;
	}
	@Override
	public String toCompressedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().compressedWildcardString) == null) {
			getStringCache().compressedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCompressedParams);
		}
		return result;
	}
	@Override
	public String toPrefixLengthString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().networkPrefixLengthString) == null) {
			getStringCache().networkPrefixLengthString = result = toNormalizedString(IPv6StringCache.networkPrefixLengthParams);
		}
		return result;
	}
	@Override
	public String toSubnetString() {
		return toPrefixLengthString();
	}
	@Override
	public String toCanonicalWildcardString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().canonicalWildcardString) == null) {
			getStringCache().canonicalWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCanonicalParams);
		}
		return result;
	}
	@Override
	public String toNormalizedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().normalizedWildcardString) == null) {
			getStringCache().normalizedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardNormalizedParams);
		}
		return result;
	}
	@Override
	public String toSQLWildcardString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().sqlWildcardString) == null) {
			getStringCache().sqlWildcardString = result = toNormalizedString(IPv6StringCache.sqlWildcardParams);
		}
		return result;
	}
	/**
	 * The normalized string returned by this method is consistent with java.net.Inet6address.
	 * IPs are not compressed nor mixed in this representation.
	 */
	@Override
	public String toNormalizedString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().normalizedString) == null) {
			getStringCache().normalizedString = result = toNormalizedString(IPv6StringCache.normalizedParams);
		}
		return result;
	}
	/**
	 * The base 85 string is described by RFC 1924
	 * @return
	 */
	public String toBase85String() throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = getStringCache().base85String) == null) {
			getStringCache().base85String = result = toBase85String(null);
		}
		return result;
	}
	String toBase85String(String zone) {
		Integer prefixLength = getNetworkPrefixLength();
		IPAddressLargeDivision largeDiv;
		if(isDualString()) {
			largeDiv = new IPAddressLargeDivision(getBytesInternal(), getUpperBytesInternal(), getBitCount(), 85, getNetwork(), prefixLength);
		} else {
			largeDiv = new IPAddressLargeDivision(getBytesInternal(), getBitCount(), 85, getNetwork(), prefixLength);
		}
		IPAddressStringDivisionSeries part = new IPAddressLargeDivisionGrouping(new IPAddressLargeDivision[] { largeDiv }, getNetwork());
		return toNormalizedString(IPv6StringCache.base85Params, zone, part);
	}
	@Override
	protected void cacheNormalizedString(String str) {
		if(hasNoStringCache() || getStringCache().normalizedString == null) {
			getStringCache().normalizedString = str;
		}
	}
	@Override
	public String toReverseDNSLookupString() {
		String result;
		if(hasNoStringCache() || (result = getStringCache().reverseDNSString) == null) {
			IPStringCache stringCache = getStringCache();
			stringCache.reverseDNSString = result = toNormalizedString(IPv6StringCache.reverseDNSParams, "");
		}
		return result;
	}
	@Override
	public String toSegmentedBinaryString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.segmentedBinaryString) == null) {
			getStringCache().segmentedBinaryString = result = toSegmentedBinaryString(null);
		}
		return result;
	}
	protected String toSegmentedBinaryString(CharSequence zone) {
		return toNormalizedString(IPv6StringCache.segmentedBinaryParams, zone);
	}
	@Override
	protected String toBinaryString(CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			IPAddressStringParams<IPAddressStringDivisionSeries> params = toIPParams(IPStringCache.binaryParams);
			return toNormalizedStringRange(params, getLower(), getUpper(), zone);
		}
		return toNormalizedString(IPStringCache.binaryParams, zone);
	}
	@Override
	protected String toHexString(boolean with0xPrefix, CharSequence zone) throws IncompatibleAddressException {
		if(isDualString()) {
			IPAddressStringParams<IPAddressStringDivisionSeries> params = toIPParams(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams);
			return toNormalizedStringRange(params, getLower(), getUpper(), zone);
		}
		return toNormalizedString(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams, zone);
	}
	@Override
	protected String toOctalString(boolean with0Prefix, CharSequence zone) throws IncompatibleAddressException {
		if(zone == null) {
			return super.toOctalString(with0Prefix, null);
		}
		IPAddressStringParams<IPAddressStringDivisionSeries> params = toIPParams(with0Prefix ? IPStringCache.octalPrefixedParams : IPStringCache.octalParams);
		if(isDualString()) {
			IPv6AddressSection lower = getLower();
			IPv6AddressSection upper = getUpper();
			IPAddressBitsDivision lowerDivs[] = lower.createNewDivisions(3, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
			IPAddressStringDivisionSeries lowerPart = new IPAddressDivisionGrouping(lowerDivs, getNetwork());
			IPAddressBitsDivision upperDivs[] = upper.createNewDivisions(3, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
			IPAddressStringDivisionSeries upperPart = new IPAddressDivisionGrouping(upperDivs, getNetwork());
			return toNormalizedStringRange(params, lowerPart, upperPart, zone);
		}
		IPAddressBitsDivision divs[] = createNewPrefixedDivisions(3, null, null, IPAddressBitsDivision::new, IPAddressBitsDivision[]::new);
		IPAddressStringDivisionSeries part = new IPAddressDivisionGrouping(divs, getNetwork());
		return params.toString(part, zone);
	}
	@Override
	public String toNormalizedString(IPStringOptions options) {
		if(options instanceof IPv6StringOptions) {
			return toNormalizedString((IPv6StringOptions) options);
		}
		return super.toNormalizedString(options);
	}
	public String toNormalizedString(IPv6StringOptions options) {
		return toNormalizedString(options, (String) null);
	}
	private String toNormalizedMixedString(IPv6v4MixedParams mixedParams, CharSequence zone) {
		IPv6v4MixedAddressSection mixed = getMixedAddressSection();
		String result = mixedParams.toString(mixed, zone);
		return result;
	}
	String toNormalizedString(IPStringOptions options, CharSequence zone) {
		if(zone == null) {
			return toNormalizedString(options);
		}
		if(options instanceof IPv6StringOptions) {
			return toNormalizedString((IPv6StringOptions) options, zone);
		}
		IPAddressStringParams<IPAddressStringDivisionSeries> params = toIPParams(options);
		return params.toString(this, zone);
	}
	public String toNormalizedString(IPv6StringOptions options, CharSequence zone) {
		IPv6StringParams stringParams;
		if(options.isCacheable()) {
			IPAddressStringWriter<?> cachedParams = (IPAddressStringWriter<?>) getCachedParams(options);
			if(cachedParams == null) {
				stringParams = options.from(this);
				if(options.makeMixed()) {
					IPv6v4MixedParams mixedParams = new IPv6v4MixedParams(stringParams, options.ipv4Opts);
					setCachedParams(options, mixedParams);
					return toNormalizedMixedString(mixedParams, zone);
				} else {
					setCachedParams(options, stringParams);
				}
			} else {
				if(cachedParams instanceof IPv6v4MixedParams) {
					return toNormalizedMixedString((IPv6v4MixedParams) cachedParams, zone);
				}
				stringParams = (IPv6StringParams) cachedParams;
			}
		} else {
			//no caching is possible due to the compress options
			stringParams = options.from(this);
			if(options.makeMixed() && stringParams.nextUncompressedIndex <= IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSegmentIndex) {//the mixed section is not compressed
				return toNormalizedMixedString(new IPv6v4MixedParams(stringParams, options.ipv4Opts), zone);
			}
		}
		return stringParams.toString(this, zone);
	}
	public static String toNormalizedString(IPStringOptions options, CharSequence zone, IPAddressStringDivisionSeries part) {
		AddressStringParams<IPAddressStringDivisionSeries> params = toIPParams(options);
		String result = params.toString(part, zone);
		return result;
	}
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.ALL_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toDatabaseSearchStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.DATABASE_SEARCH_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions options) {
		return toStringCollection(IPv6StringBuilderOptions.from(options));
	}
	public IPAddressPartStringCollection toStringCollection(IPv6StringBuilderOptions opts) {
		return toStringCollection(opts, null);
	}
	IPv6StringCollection toStringCollection(IPv6StringBuilderOptions opts, CharSequence zone) {
		IPv6StringCollection collection = new IPv6StringCollection();
		int mixedCount = getSegmentCount() - Math.max(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSegmentIndex, 0);
		if(mixedCount > 0 && opts.includes(IPv6StringBuilderOptions.MIXED)) {
			IPv6v4MixedAddressSection mixed = getMixedAddressSection();
			IPv6v4MixedStringBuilder mixedBuilder = new IPv6v4MixedStringBuilder(mixed, opts, zone);
			IPv6v4MixedStringCollection mixedCollection = mixedBuilder.getVariations();
			collection.add(mixedCollection);
		}
		if(opts.includes(IPStringBuilderOptions.BASIC)) {
			IPv6StringBuilder ipv6Builder = new IPv6StringBuilder(this, opts, zone);
			IPv6AddressSectionStringCollection ipv6Collection = ipv6Builder.getVariations();
			collection.add(ipv6Collection);
		}
		return collection;
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions opts) {
		return getParts(IPv6StringBuilderOptions.from(opts));
	}
	public IPAddressStringDivisionSeries[] getParts(IPv6StringBuilderOptions opts) {
		if(opts.includes(IPv6StringBuilderOptions.MIXED)) {
			if(opts.includes(IPStringBuilderOptions.BASIC)) {
				return new IPAddressStringDivisionSeries[] { this, getMixedAddressSection() };
			}
			return new IPAddressStringDivisionSeries[] { getMixedAddressSection() };
		}
		return super.getParts(opts);
	}
	private static class IPv6StringMatcher extends SQLStringMatcher<IPv6AddressSection, IPv6StringParams, IPv6AddressSectionString> {
		IPv6StringMatcher(
				IPv6AddressSectionString networkString,
				IPAddressSQLTranslator translator) {
			super(networkString, networkString.addr.isEntireAddress(), translator);
		}
	
		@Override
		public StringBuilder getSQLCondition(StringBuilder builder, String columnName) {
			if(networkString.addr.isEntireAddress()) {
				matchString(builder, columnName, networkString.getString());
			} else if(networkString.endIsCompressed()) { //'::' is at end of networkString
				char sep = networkString.getTrailingSegmentSeparator();
				String searchStr = networkString.getString().substring(0, networkString.getString().length() - 1);
				builder.append('(');
				matchSubString(builder, columnName, sep, networkString.getTrailingSeparatorCount(), searchStr);
				
				//We count the separators to ensure they are below a max count.
				//The :: is expected to match a certain number of segments in the network and possibly more in the host.
				//If the network has y segments then there can be anywhere between 0 and 7 - y additional separators for the host. 
				//eg 1:: matching 7 segments in network means full string has at most an additional 7 - 7 = 0 host separators, so it is either 1:: or 1::x.  It cannot be 1::x:x.
				//eg 1:: matching 6 segments means full string has at most an additional 7 - 6 = 1 separators, so it is either 1::, 1::x or 1::x:x.  It cannot be 1::x:x:x.
				int extraSeparatorCountMax = (IPv6Address.SEGMENT_COUNT - 1) - networkString.addr.getSegmentCount();
				builder.append(") AND (");
				boundSeparatorCount(builder, columnName, sep, extraSeparatorCountMax + networkString.getTrailingSeparatorCount());
				builder.append(')');
			} else if(networkString.isCompressed()) { //'::' is in networkString but not at end of networkString
				char sep = networkString.getTrailingSegmentSeparator();
				builder.append('(');
				matchSubString(builder, columnName, sep, networkString.getTrailingSeparatorCount() + 1, networkString.getString());
				
				//we count the separators to ensure they are an exact count.
				//The :: is expected to match a certain number of segments in the network and there is no compression in the host.
				//If the network has y segments then there is 8 - y additional separators for the host. 
				//eg ::1 matching 7 segments in network means full string has additional 8 - 7 = 1 host separators, so it is ::1:x
				//eg ::1 matching 6 segments means full string has additional 8 - 6 = 2 separators, so it is ::1:x:x
				int extraSeparatorCount = IPv6Address.SEGMENT_COUNT - networkString.addr.getSegmentCount();
				builder.append(") AND (");
				matchSeparatorCount(builder, columnName, sep, extraSeparatorCount + networkString.getTrailingSeparatorCount());
				builder.append(')');
			} else {
				matchSubString(builder, columnName, networkString.getTrailingSegmentSeparator(), networkString.getTrailingSeparatorCount() + 1, networkString.getString());
			}
			return builder;
		}
	}
	public static class CompressOptions {
		public enum CompressionChoiceOptions {
			HOST_PREFERRED, //if there is a host section, compress the host along with any adjoining zero segments, otherwise compress a range of zero segments
			MIXED_PREFERRED, //if there is a mixed section that is compressible according to the MixedCompressionOptions, compress the mixed section along with any adjoining zero segments, otherwise compress a range of zero segments
			ZEROS_OR_HOST, //compress the largest range of zero or host segments
			ZEROS; //compress the largest range of zero segments
			
			boolean compressHost() {
				return this != ZEROS;
			}
		}
		public enum MixedCompressionOptions {
			NO, //do not allow compression of a mixed section
			NO_HOST, //allow compression of a mixed section when there is no host section
			COVERED_BY_HOST, //allow compression of a mixed section when there is no host section or the host section covers the mixed section
			YES; //allow compression of a mixed section
			
			boolean compressMixed(IPv6AddressSection addressSection) {
				switch(this) {
					default:
					case YES:
						return true;
					case NO:
						return false;
					case NO_HOST:
						return !addressSection.isPrefixed();
					case COVERED_BY_HOST:
						if(addressSection.isPrefixed()) {
							int mixedDistance = IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSection.addressSegmentIndex;
							int mixedCount = addressSection.getSegmentCount() - Math.max(mixedDistance, 0);
							if(mixedCount > 0) {
								return (mixedDistance * addressSection.getBitsPerSegment()) >= addressSection.getNetworkPrefixLength();
							}
						}
						return true;
				}
			}
		}
		public final boolean compressSingle;
		public final CompressionChoiceOptions rangeSelection;
		//options for addresses with an ipv4 section
		public final MixedCompressionOptions compressMixedOptions;
		public CompressOptions(boolean compressSingle, CompressionChoiceOptions rangeSelection) {
			this(compressSingle, rangeSelection, MixedCompressionOptions.YES);
		}
		public CompressOptions(boolean compressSingle, CompressionChoiceOptions rangeSelection, MixedCompressionOptions compressMixedOptions) {
			this.compressSingle = compressSingle;
			this.rangeSelection = rangeSelection;
			this.compressMixedOptions = compressMixedOptions == null ? MixedCompressionOptions.YES : compressMixedOptions;
		}
	}
	/**
	 * Provides a clear way to create a specific type of string.
	 * 
	 * @author sfoley
	 *
	 */
	public static class IPv6StringOptions extends IPStringOptions {
		public final IPStringOptions ipv4Opts;
		//can be null, which means no compression
		public final CompressOptions compressOptions;
		IPv6StringOptions(
				int base,
				boolean expandSegments,
				WildcardOption wildcardOption,
				Wildcards wildcards,
				String segmentStrPrefix,
				boolean makeMixed,
				IPStringOptions ipv4Opts,
				CompressOptions compressOptions,
				Character separator,
				char zoneSeparator,
				String addressPrefix,
				String addressSuffix,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			super(base, expandSegments, wildcardOption, wildcards, segmentStrPrefix, separator, zoneSeparator, addressPrefix, addressSuffix, reverse, splitDigits, uppercase);
			this.compressOptions = compressOptions;
			if(makeMixed) {
				if(ipv4Opts == null) {
					ipv4Opts = new IPv4StringOptions.Builder().
							setExpandedSegments(expandSegments).setWildcardOption(wildcardOption).setWildcards(wildcards).toOptions();
				}
				this.ipv4Opts = ipv4Opts;
			} else {
				this.ipv4Opts = null;
			}
		}
		boolean isCacheable() {
			return compressOptions == null;
		}
		boolean makeMixed() {
			return ipv4Opts != null;
		}
		private IPv6StringParams from(IPv6AddressSection addr) {
			IPv6StringParams result = new IPv6StringParams();
			if(compressOptions != null) {
				boolean makeMixed = makeMixed();
				int vals[] = addr.getCompressIndexAndCount(compressOptions, makeMixed);
				if(vals != null) {
					int maxIndex = vals[0];
					int maxCount = vals[1];
					result.firstCompressedSegmentIndex = maxIndex;
					result.nextUncompressedIndex = maxIndex + maxCount;
					result.hostCompressed = compressOptions.rangeSelection.compressHost() &&
							addr.isPrefixed() &&
							(result.nextUncompressedIndex > 
								getHostSegmentIndex(addr.getNetworkPrefixLength(), IPv6Address.BYTES_PER_SEGMENT, IPv6Address.BITS_PER_SEGMENT));
				}
			}
			result.expandSegments(expandSegments);
			result.setWildcardOption(wildcardOption);
			result.setWildcards(wildcards);
			result.setSeparator(separator);
			result.setAddressSuffix(addrSuffix);
			result.setAddressLabel(addrLabel);
			result.setReverse(reverse);
			result.setSplitDigits(splitDigits);
			result.setZoneSeparator(zoneSeparator);
			result.setUppercase(uppercase);
			result.setRadix(base);
			result.setSegmentStrPrefix(segmentStrPrefix);
			return result;
		}
		public static IPv6StringOptions from(IPStringOptions opts) {
			if(opts instanceof IPv6StringOptions) {
				return (IPv6StringOptions) opts;
			}
			return new IPv6StringOptions(
					opts.base,
					opts.expandSegments,
					opts.wildcardOption,
					opts.wildcards,
					opts.segmentStrPrefix,
					false,
					null,
					null,
					opts.separator,
					IPv6Address.ZONE_SEPARATOR,
					opts.addrLabel,
					opts.addrSuffix,
					opts.reverse,
					opts.splitDigits,
					opts.uppercase);
		}
		public static class Builder extends IPStringOptions.Builder {
			private boolean makeMixed;
			private IPStringOptions ipv4Options;
			//default is null, which means no compression
			private CompressOptions compressOptions;
			public Builder() {
				super(IPv6Address.DEFAULT_TEXTUAL_RADIX, IPv6Address.SEGMENT_SEPARATOR);
			}
			public Builder setCompressOptions(CompressOptions compressOptions) {
				this.compressOptions = compressOptions;
				return this;
			}
			public Builder setMakeMixed(boolean makeMixed) {
				this.makeMixed = makeMixed;
				return this;
			}
			public Builder setMakeMixed(IPStringOptions ipv4Options) {
				this.makeMixed = true;
				this.ipv4Options = ipv4Options;
				return this;
			}
			@Override
			public Builder setWildcardOptions(WildcardOptions wildcardOptions) {
				return (Builder) super.setWildcardOptions(wildcardOptions);
			}
			@Override
			public Builder setExpandedSegments(boolean expandSegments) {
				return (Builder) super.setExpandedSegments(expandSegments);
			}
			@Override
			public Builder setRadix(int base) {
				return (Builder) super.setRadix(base);
			}
			@Override
			public Builder setSeparator(Character separator) {
				return (Builder) super.setSeparator(separator);
			}
			@Override
			public Builder setZoneSeparator(char separator) {
				return (Builder) super.setZoneSeparator(separator);
			}
			@Override
			public Builder setAddressSuffix(String suffix) {
				return (Builder) super.setAddressSuffix(suffix);
			}
			@Override
			public Builder setSegmentStrPrefix(String prefix) {
				return (Builder) super.setSegmentStrPrefix(prefix);
			}
			@Override
			public Builder setReverse(boolean reverse) {
				return (Builder) super.setReverse(reverse);
			}
			@Override
			public Builder setUppercase(boolean upper) {
				return (Builder) super.setUppercase(upper);
			}
			@Override
			public Builder setSplitDigits(boolean splitDigits) {
				return (Builder) super.setSplitDigits(splitDigits);
			}
			@Override
			public IPv6StringOptions toOptions() {
				return new IPv6StringOptions(base, expandSegments, wildcardOption, wildcards, segmentStrPrefix, makeMixed, ipv4Options, compressOptions, separator, zoneSeparator, addrLabel, addrSuffix, reverse, splitDigits, uppercase);
			}
		}
	}
	@Override
	public RangeList getZeroSegments() {
		if(zeroSegments == null) {
			zeroSegments = super.getZeroSegments();
		}
		return zeroSegments;
	}
	@Override
	public RangeList getZeroRangeSegments() {
		if(zeroRanges == null) {
			zeroRanges = super.getZeroRangeSegments();
		}
		return zeroRanges;
	}
	@Override
	public boolean isZero() {
		RangeList ranges = getZeroSegments();
		return ranges.size() == 1 && ranges.getRange(0).length == getSegmentCount();
	}
	private int[] getCompressIndexAndCount(CompressOptions options) {
		return getCompressIndexAndCount(options, false);
	}
	/**
	 * Chooses a single segment to be compressed, or null if no segment could be chosen.
	 * @param options
	 * @param createMixed
	 * @return
	 */
	private int[] getCompressIndexAndCount(CompressOptions options, boolean createMixed) {
		if(options != null) {
			CompressionChoiceOptions rangeSelection = options.rangeSelection;
			RangeList compressibleSegs = rangeSelection.compressHost() ? getZeroRangeSegments() : getZeroSegments();
			int maxIndex = -1, maxCount = 0;
			int segmentCount = getSegmentCount();
			
			boolean compressMixed = createMixed && options.compressMixedOptions.compressMixed(this);
			boolean preferHost = (rangeSelection == CompressOptions.CompressionChoiceOptions.HOST_PREFERRED);
			boolean preferMixed = createMixed && (rangeSelection == CompressOptions.CompressionChoiceOptions.MIXED_PREFERRED);
			for(int i = compressibleSegs.size() - 1; i >= 0 ; i--) {
				Range range = compressibleSegs.getRange(i);
				int index = range.index;
				int count = range.length;
				if(createMixed) {
					//so here we shorten the range to exclude the mixed part if necessary
					int mixedIndex = IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT - addressSegmentIndex;
					if(!compressMixed ||
							index > mixedIndex || index + count < segmentCount) { //range does not include entire mixed part.  We never compress only part of a mixed part.
						//the compressible range must stop at the mixed part
						count = Math.min(count, mixedIndex - index);
					}
				}
				//select this range if is the longest
				if(count > 0 && count >= maxCount && (options.compressSingle || count > 1)) {
					maxIndex = index;
					maxCount = count;
				}
				if(preferHost && isPrefixed() &&
						((index + count) * getBitsPerSegment()) > getNetworkPrefixLength()) { //this range contains the host
					//Since we are going backwards, this means we select as the maximum any zero segment that includes the host
					break;
				}
				if(preferMixed && index + count >= segmentCount) { //this range contains the mixed section
					//Since we are going backwards, this means we select to compress the mixed segment
					break;
				}
			}
			if(maxIndex >= 0) {
				return new int[] {maxIndex, maxCount};
			}
		}
		return null;
	}
	/**
	 * Each IPv6StringParams has settings to write exactly one IPv6 address section string
	 * 
	 * @author sfoley
	 *
	 */
	static class IPv6StringParams extends IPAddressStringParams<IPv6AddressSection> {
		int firstCompressedSegmentIndex, nextUncompressedIndex; //the start and end of any compressed section
		boolean hostCompressed; //whether the host was compressed, which with some prefix configurations means we must print the network prefix to indicate that the host is full range
		IPv6StringParams() {
			this(-1, 0);
		}
		IPv6StringParams(int firstCompressedSegmentIndex, int compressedCount) {
			this(false, firstCompressedSegmentIndex, compressedCount, false, IPv6Address.SEGMENT_SEPARATOR, IPv6Address.ZONE_SEPARATOR);
		}
		private IPv6StringParams(
				boolean expandSegments,
				int firstCompressedSegmentIndex,
				int compressedCount,
				boolean uppercase, 
				char separator,
				char zoneSeparator) {
			super(IPv6Address.DEFAULT_TEXTUAL_RADIX, separator, uppercase, zoneSeparator);
			this.expandSegments(expandSegments);
			this.firstCompressedSegmentIndex = firstCompressedSegmentIndex;
			this.nextUncompressedIndex = firstCompressedSegmentIndex + compressedCount;
		}
		public boolean endIsCompressed(IPAddressStringDivisionSeries addr) {
			return nextUncompressedIndex >= addr.getDivisionCount();
		}
		public boolean isCompressed(IPAddressStringDivisionSeries addr) {
			return firstCompressedSegmentIndex >= 0;
		}
		@Override
		public int getTrailingSeparatorCount(IPv6AddressSection addr) {
			return getTrailingSepCount(addr);
		}
		public int getTrailingSepCount(IPAddressStringDivisionSeries addr) {
			int divisionCount = addr.getDivisionCount();
			if(divisionCount == 0) {
				return 0;
			}
			int count = divisionCount - 1;//separators with no compression
			if(isCompressed(addr)) {
				count -= (nextUncompressedIndex - firstCompressedSegmentIndex) - 1; //missing seps
				if(firstCompressedSegmentIndex == 0 /* additional separator at front */ || 
						nextUncompressedIndex >= divisionCount /* additional separator at end */) {
					count++;
				}
			}
			return count;
		}
		@Override
		public int getStringLength(IPv6AddressSection addr) {
			int count = getSegmentsStringLength(addr);
			if(!isReverse() && (!preferWildcards() || hostCompressed)) {
				count += getPrefixIndicatorStringLength(addr);
			}
			count += getAddressSuffixLength();
			count += getAddressLabelLength();
			return count;
		}
		@Override
		public StringBuilder append(StringBuilder builder, IPv6AddressSection addr, CharSequence zone) {
			/* 
			 * Our order is label, then segments, then zone, then suffix, then prefix length.
			 */
			appendSuffix(appendZone(appendSegments(appendLabel(builder), addr), zone));
			if(!isReverse() && (!preferWildcards() || hostCompressed)) {
				appendPrefixIndicator(builder, addr);
			}
			return builder;
		}
		 /**
		 * @see inet.ipaddr.format.util.IPAddressPartStringCollection.IPAddressStringParams#appendSegments(java.lang.StringBuilder, inet.ipaddr.format.string.IPAddressStringDivisionSeries)
		 */
		@Override
		public StringBuilder appendSegments(StringBuilder builder, IPv6AddressSection addr) {
			int divisionCount = addr.getDivisionCount();
			if(divisionCount <= 0) {
				return builder;
			}
			int lastIndex = divisionCount - 1;
			Character separator = getSeparator();
			boolean reverse = isReverse();
			int i = 0;
			while(true) {
				int segIndex = reverse ? lastIndex - i : i;
				if(segIndex < firstCompressedSegmentIndex || segIndex >= nextUncompressedIndex) {
					appendSegment(segIndex, builder, addr);
					if(++i > lastIndex) {
						break;
					}
					if(separator != null) {
						builder.append(separator);
					}
				} else {
					if(segIndex == (reverse ? nextUncompressedIndex - 1 :  firstCompressedSegmentIndex) && separator != null) { //the segment is compressed
						builder.append(separator);
						if(i == 0) {//when compressing the front we use two separators
							builder.append(separator);
						}
					} //else we are in the middle of a compressed set of segments, so nothing to write
					if(++i > lastIndex) {
						break;
					}
				}
			}
			return builder;
		}
		@Override
		public int getSegmentsStringLength(IPv6AddressSection part) {
			int count = 0;
			int divCount = part.getDivisionCount();
			if(divCount != 0) {
				Character separator = getSeparator();
				int i = 0;
				while(true) {
					if(i < firstCompressedSegmentIndex || i >= nextUncompressedIndex) {
						count += appendSegment(i, null, part);
						if(++i >= divCount) {
							break;
						}
						if(separator != null) {
							count++;
						}
					} else {
						if(i == firstCompressedSegmentIndex && separator != null) { //the segment is compressed
							count++;
							if(i == 0) {//when compressing the front we use two separators
								count++;
							}
						} //else we are in the middle of a compressed set of segments, so nothing to write
						if(++i >= divCount) {
							break;
						}
					}
				}
			}
			return count;
		}
		@Override
		public IPv6StringParams clone() {
			return (IPv6StringParams) super.clone();
		}
	}
	static class EmbeddedIPv6AddressSection extends IPv6AddressSection {
		private static final long serialVersionUID = 4L;
		private final IPAddressSection encompassingSection;
		EmbeddedIPv6AddressSection(IPAddressSection encompassingSection, IPv6AddressSegment subSegments[], int startIndex) {
			super(subSegments, startIndex, false);
			this.encompassingSection = encompassingSection;
		}
		@Override
		public boolean isPrefixBlock() {
			return encompassingSection.isPrefixBlock();
		}
	}
	public static class IPv6v4MixedAddressSection extends IPAddressDivisionGrouping {
		private static final long serialVersionUID = 4L;
		private final IPv6AddressSection ipv6Section;
		private final IPv4AddressSection ipv4Section;
		private String string;
		private IPv6v4MixedAddressSection(
				IPv6AddressSection ipv6Section,
				IPv4AddressSection ipv4Section) {
			super(createSegments(ipv6Section, ipv4Section), ipv6Section.getNetwork());
			if(ipv6Section.isPrefixed()) {
				if(!ipv4Section.isPrefixed() || ipv4Section.getNetworkPrefixLength() != 0) {
					throw new InconsistentPrefixException(ipv6Section, ipv4Section, ipv4Section.getNetworkPrefixLength());
				}
				cachedPrefixLength = ipv6Section.getNetworkPrefixLength();
			} else if(ipv4Section.isPrefixed()) {
				cachedPrefixLength = cacheBits(ipv4Section.getNetworkPrefixLength() + ipv6Section.getBitCount());
			} else {
				cachedPrefixLength = NO_PREFIX_LENGTH;
			}
			this.ipv4Section = ipv4Section;
			this.ipv6Section = ipv6Section;
		}
		private static IPAddressDivision[] createSegments(IPv6AddressSection ipv6Section, IPv4AddressSection ipv4Section) {
			int ipv6Len = ipv6Section.getSegmentCount();
			int ipv4Len = ipv4Section.getSegmentCount();
			if(ipv6Len + ((ipv4Len + 1) >> 1) + ipv6Section.addressSegmentIndex > IPv6Address.SEGMENT_COUNT) {
				throw new AddressValueException(ipv6Section, ipv4Section);
			}
			IPAddressSegment allSegs[] = new IPAddressSegment[ipv6Len + ipv4Len];
			ipv6Section.getSegments(0, ipv6Len, allSegs, 0);
			ipv4Section.getSegments(0, ipv4Len, allSegs, ipv6Len);
			return allSegs;
		}
		@Override
		public int getByteCount() {
			return ipv6Section.getByteCount() + ipv4Section.getByteCount();
		}
		@Override
		public int getBitCount() {
			return ipv6Section.getBitCount() + ipv4Section.getBitCount();
		}
		@Override
		public boolean isPrefixBlock() {
			Integer networkPrefixLength = getNetworkPrefixLength();
			if(networkPrefixLength == null) {
				return false;
			}
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return true;
			}
			if(ipv6Section.isPrefixed()) {
				return ipv6Section.isPrefixBlock() && ipv4Section.isFullRange();
			}
			return ipv4Section.isPrefixBlock();
		}
		@Override
		public String toString() {
			if(string == null) {
				IPv6StringOptions mixedParams = IPv6StringCache.mixedParams;
				IPv6StringParams ipv6Params = mixedParams.from(ipv6Section);
				IPStringOptions ipv4Opts = mixedParams.ipv4Opts;
				IPv6v4MixedParams parms = new IPv6v4MixedParams(ipv6Params, ipv4Opts);
				string = parms.toString(this);
			}
			return string;
		}
		@Override
		protected boolean isSameGrouping(AddressDivisionGroupingBase o) {
			if(o instanceof IPv6v4MixedAddressSection) {
				IPv6v4MixedAddressSection other = (IPv6v4MixedAddressSection) o;
				return ipv6Section.equals(other.ipv6Section) && ipv4Section.equals(other.ipv4Section);
			}
			return false;
		}
		@Override
		public boolean equals(Object o) {
			if(o == this) {
				return true;
			}
			if(o instanceof IPv6v4MixedAddressSection) {
				IPv6v4MixedAddressSection other = (IPv6v4MixedAddressSection) o;
				return ipv6Section.equals(other.ipv6Section) && ipv4Section.equals(other.ipv4Section);
			}
			return false;
		}
	}
	static class IPv6v4MixedParams implements IPAddressStringWriter<IPv6v4MixedAddressSection>, Cloneable {
		private IPAddressStringParams<IPAddressStringDivisionSeries> ipv4Params; //params for the IPv4 part of a mixed IPv6/IPv4 address a:b:c:d:e:f:1.2.3.4
		private IPv6StringParams ipv6Params;
		@SuppressWarnings("unchecked")
		IPv6v4MixedParams(IPv6AddressSectionString ipv6Variation, IPAddressPartConfiguredString<?, ?> ipv4Variation) {
			this.ipv4Params = (IPAddressStringParams<IPAddressStringDivisionSeries>) ipv4Variation.stringParams;
			this.ipv6Params = ipv6Variation.stringParams;
		}
		IPv6v4MixedParams(IPv6StringParams ipv6Params, IPStringOptions ipv4Opts) {
			this.ipv4Params = IPAddressSection.toIPParams(ipv4Opts);
			this.ipv6Params = ipv6Params;
		}
		@Override
		public char getTrailingSegmentSeparator() {
			return ipv4Params.getTrailingSegmentSeparator();
		}
		@Override
		public int getTrailingSeparatorCount(IPv6v4MixedAddressSection addr) {
			return ipv4Params.getTrailingSeparatorCount(addr.ipv4Section);
		}
		public int getStringLength(IPv6v4MixedAddressSection addr, CharSequence zone) {
			int ipv6length = ipv6Params.getSegmentsStringLength(addr.ipv6Section);
			int ipv4length = ipv4Params.getSegmentsStringLength(addr.ipv4Section);
			int length = ipv6length + ipv4length;
			if(ipv6Params.nextUncompressedIndex < addr.ipv6Section.getSegmentCount()) {
				length++;
			}
			length += getPrefixStringLength(addr);
			length += ipv6Params.getZoneLength(zone);
			length += ipv6Params.getAddressSuffixLength();
			length += ipv6Params.getAddressLabelLength();
			return length;
		}
		@Override
		public String toString(IPv6v4MixedAddressSection addr) {
			return toString(addr, null);
		}
		@Override
		public String toString(IPv6v4MixedAddressSection addr, CharSequence zone) {
			int length = getStringLength(addr, zone);
			StringBuilder builder = new StringBuilder(length);
			append(builder, addr, zone);
			AddressStringParams.checkLengths(length, builder);
			return builder.toString();
		}
		@Override
		public int getDivisionStringLength(AddressStringDivision seg) {
			return ipv6Params.getDivisionStringLength(seg);
		}
		@Override
		public StringBuilder appendDivision(StringBuilder builder, AddressStringDivision seg) {
			return ipv6Params.appendDivision(builder, seg);
		}
		public StringBuilder append(StringBuilder builder, IPv6v4MixedAddressSection addr, CharSequence zone) {
			ipv6Params.appendLabel(builder);
			ipv6Params.appendSegments(builder, addr.ipv6Section);
			if(ipv6Params.nextUncompressedIndex < addr.ipv6Section.getSegmentCount()) {
				builder.append(ipv6Params.getTrailingSegmentSeparator());
			}
			ipv4Params.appendSegments(builder, addr.ipv4Section);
			/* 
			 * rfc 4038: for bracketed addresses, zone is inside and prefix outside, putting prefix after zone. 
			 * 
			 * Suffixes are things like .in-addr.arpa, .ip6.arpa, .ipv6-literal.net
			 * which generally convert an address string to a host
			 * As with our HostName, we support host/prefix in which case the prefix is applied
			 * to the resolved address.
			 * 
			 * So in summary, our order is zone, then suffix, then prefix length.
			 */
			ipv6Params.appendZone(builder, zone);
			ipv6Params.appendSuffix(builder);
			appendPrefixIndicator(builder, addr);
			return builder;
		}
		protected int getPrefixStringLength(IPv6v4MixedAddressSection addr) {
			if(requiresPrefixIndicator(addr.ipv6Section) || requiresPrefixIndicator(addr.ipv4Section)) {
				return IPAddressStringParams.getPrefixIndicatorStringLength(addr);
			}
			return 0;
		}
		public void appendPrefixIndicator(StringBuilder builder, IPv6v4MixedAddressSection addr) {
			if(requiresPrefixIndicator(addr.ipv6Section) || requiresPrefixIndicator(addr.ipv4Section)) {
				ipv6Params.appendPrefixIndicator(builder, addr);
			}
		}
		protected boolean requiresPrefixIndicator(IPv4AddressSection ipv4Section)    {
			return ipv4Section.isPrefixed() && !ipv4Params.preferWildcards();
		}
		protected boolean requiresPrefixIndicator(IPv6AddressSection ipv6Section)    {
			return ipv6Section.isPrefixed() && (!ipv6Params.preferWildcards() || ipv6Params.hostCompressed);
		}
		@Override
		public IPv6v4MixedParams clone() {
			try {
				IPv6v4MixedParams params = (IPv6v4MixedParams) super.clone();
				params.ipv6Params = ipv6Params.clone();
				params.ipv4Params = ipv4Params.clone();
				return params;
			} catch(CloneNotSupportedException e) {
				 return null;
			}
		}
	}
	static class IPv6AddressSectionStringCollection extends IPAddressPartStringSubCollection<IPv6AddressSection, IPv6StringParams, IPv6AddressSectionString> {
		private final CharSequence zone;
		IPv6AddressSectionStringCollection(IPv6AddressSection addr, CharSequence zone) {
			super(addr);
			this.zone = zone;
		}
		@Override
		public Iterator<IPv6AddressSectionString> iterator() {
			return new IPAddressConfigurableStringIterator() {
				@Override
				public IPv6AddressSectionString next() {
					return new IPv6AddressSectionString(part, iterator.next(), zone); 
				}
			};
		}
	}
	static class IPv6v4MixedStringCollection
		extends IPAddressPartStringSubCollection<IPv6v4MixedAddressSection, IPv6v4MixedParams, IPAddressPartConfiguredString<IPv6v4MixedAddressSection, IPv6v4MixedParams>> {
		private final CharSequence zone;
		public IPv6v4MixedStringCollection(IPv6v4MixedAddressSection part, CharSequence zone) {
			super(part);
			this.zone = zone;
		}
		@Override
		public Iterator<IPAddressPartConfiguredString<IPv6v4MixedAddressSection, IPv6v4MixedParams>> iterator() {
			return new IPAddressConfigurableStringIterator() {
				@Override
				public IPAddressPartConfiguredString<IPv6v4MixedAddressSection, IPv6v4MixedParams> next() {
					return new IPAddressPartConfiguredString<IPv6v4MixedAddressSection, IPv6v4MixedParams>(part, iterator.next()) {
						
						@Override
						public String getString() {
							if(string == null) {
								string = stringParams.toString(addr, zone);
							}
							return string;
						}
					};
				}
			};
		}
	}
	static class IPv6StringCollection extends IPAddressPartStringCollection {
		@Override
		protected void add(IPAddressPartStringSubCollection<?, ?, ?> collection) {
			super.add(collection);
		}
		@Override
		protected void addAll(IPAddressPartStringCollection collections) {
			super.addAll(collections);
		}
		/**
		 * Capable of building any and all possible representations of IPv6 addresses.
		 * Not all such representations are necessarily something you might consider valid.
		 * For example: a:0::b:0c:d:1:2
		 * This string has a single zero segment compressed rather than two consecutive (a partial compression),
		 * it has the number 'c' expanded partially to 0c (a partial expansion), rather than left as is, or expanded to the full 4 chars 000c.
		 * 
		 * Mixed representation strings are produced by the IPv6 mixed builder.
		 * The one other type of variation not produced by this class are mixed case, containing both upper and lower case characters: A-F vs a-f.
		 * That would result in gazillions of possible representations.  
		 * But such variations are easy to work with for comparison purposes because you can easily convert strings to lowercase,
		 * so in general there is no need to cover such variations.
		 * However, this does provide the option to have either all uppercase or all lowercase strings.
		 * 
		 * A single address can have hundreds of thousands, even millions, of possible variations.
		 * The default settings for this class will produce at most a couple thousand possible variations.
		 * 
		 * @author sfoley
		 */
		static class IPv6StringBuilder
				extends AddressPartStringBuilder<IPv6AddressSection, IPv6StringParams, IPv6AddressSectionString, IPv6AddressSectionStringCollection, IPv6StringBuilderOptions> {
			IPv6StringBuilder(IPv6AddressSection address, IPv6StringBuilderOptions opts, CharSequence zone) {
				super(address,  opts, new IPv6AddressSectionStringCollection(address, zone));
			}
			private void addUppercaseVariations(ArrayList<IPv6StringParams> allParams, int base) {
				boolean lowerOnly = true; //by default we use NETWORK_ONLY wildcards (we use prefix notation otherwise) so here we check lower values only for alphabetic
				if(options.includes(IPv6StringBuilderOptions.UPPERCASE) && addressSection.hasUppercaseVariations(base, lowerOnly)) {
					int len = allParams.size();
					for(int j=0; j<len; j++) {
						IPv6StringParams clone = allParams.get(j);
						clone = clone.clone();
						clone.setUppercase(true);
						allParams.add(clone);
					}
				}
			}
			private void addAllExpansions(int firstCompressedIndex, int count, int segmentCount) {
				IPv6StringParams stringParams = new IPv6StringParams(firstCompressedIndex, count);
				int base = stringParams.getRadix();
				final ArrayList<IPv6StringParams> allParams = new ArrayList<>();
				allParams.add(stringParams);
				
				int radix = IPv6Address.DEFAULT_TEXTUAL_RADIX;
				if(options.includes(IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS)) {
					int expandables[] = getExpandableSegments(radix);
					int nextUncompressedIndex = firstCompressedIndex + count;
					int ipv6SegmentEnd = addressSection.getSegmentCount();
					for(int i=0; i < ipv6SegmentEnd; i++) {
						if(i < firstCompressedIndex || i >= nextUncompressedIndex) {
							int expansionLength = expandables[i];
							int len = allParams.size();
							while(expansionLength > 0) {		
								for(int j=0; j<len; j++) {
									IPv6StringParams clone = allParams.get(j);
									clone = clone.clone();
									clone.expandSegment(i, expansionLength, addressSection.getSegmentCount());
									allParams.add(clone);
								}
								if(!options.includes(IPStringBuilderOptions.LEADING_ZEROS_PARTIAL_SOME_SEGMENTS)) {
									break;
								}
								expansionLength--;
							}
						}
					}
				} else if(options.includes(IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS)) {
					boolean isExpandable = isExpandableOutsideRange(radix, firstCompressedIndex, count);
					if(isExpandable) {
						int len = allParams.size();
						for(int j=0; j<len; j++) {
							IPv6StringParams clone = allParams.get(j);
							clone = clone.clone();
							clone.expandSegments(true);
							allParams.add(clone);
						}
					}
				}
				addUppercaseVariations(allParams, base);
				for(int i=0; i<allParams.size(); i++) {
					IPv6StringParams param = allParams.get(i);
					addStringParam(param);
				}	
			}
			private void addAllCompressedStrings(int zeroStartIndex, int count, boolean partial, int segmentCount) {
				int end = zeroStartIndex + count;
				if(partial) {
					for(int i = zeroStartIndex; i < end; i++) {
						for(int j = i + 1; j <= end; j++) {
							addAllExpansions(i, j - i, segmentCount);
						}	
					}
				} else {
					int len = end - zeroStartIndex;
					if(len > 0) {
						addAllExpansions(zeroStartIndex, len, segmentCount);
					}
				}
			}
			/*
			Here is how we get all potential strings:
					//for each zero-segment we choose, including the one case of choosing no zero segment
						//for each sub-segment of that zero-segment compressed (this loop is skipped for the no-zero segment case)
							//for each potential expansion of a non-compressed segment
								//we write the string
			 */
			@Override
			protected void addAllVariations() {
				int segmentCount = addressSection.getSegmentCount();
				//start with the case of compressing nothing
				addAllExpansions(-1, 0, segmentCount);
				//now do the compressed strings
				if(options.includes(IPv6StringBuilderOptions.COMPRESSION_ALL_FULL)) {
					RangeList zeroSegs  = addressSection.getZeroSegments();
					for(int i = 0; i < zeroSegs.size(); i++) {
						Range range = zeroSegs.getRange(i);
						addAllCompressedStrings(range.index, range.length, options.includes(IPv6StringBuilderOptions.COMPRESSION_ALL_PARTIAL), segmentCount);
					}
				} else if(options.includes(IPv6StringBuilderOptions.COMPRESSION_CANONICAL)) {
					CompressOptions opts = new CompressOptions(options.includes(IPv6StringBuilderOptions.COMPRESSION_SINGLE), CompressOptions.CompressionChoiceOptions.ZEROS);
					int indexes[] = addressSection.getCompressIndexAndCount(opts);
					if(indexes != null) {
						if(options.includes(IPv6StringBuilderOptions.COMPRESSION_LARGEST)) {
							//we compress any section with length that matches the max
							int maxCount = indexes[1];
							RangeList zeroSegs  = addressSection.getZeroSegments();
							for(int i = 0; i < zeroSegs.size(); i++) {
								Range range = zeroSegs.getRange(i);
								int count = range.length;
								if(count == maxCount) {
									addAllCompressedStrings(range.index, count, options.includes(IPv6StringBuilderOptions.COMPRESSION_ALL_PARTIAL), segmentCount);
								}
							}
						} else {
							int maxIndex = indexes[0];
							int maxCount = indexes[1];
							addAllCompressedStrings(maxIndex, maxCount, false, segmentCount);
						}
					} // else nothing to compress, and this case already handled
				}
			}
		}
		static class IPv6v4MixedStringBuilder
				extends AddressPartStringBuilder<
					IPv6v4MixedAddressSection,
					IPv6v4MixedParams,
					IPAddressPartConfiguredString<IPv6v4MixedAddressSection, IPv6v4MixedParams>,
					IPv6v4MixedStringCollection,
					IPv6StringBuilderOptions> {
			private final CharSequence zone;
			IPv6v4MixedStringBuilder(IPv6v4MixedAddressSection address, IPv6StringBuilderOptions opts, CharSequence zone) {
				super(address, opts, new IPv6v4MixedStringCollection(address, zone));
				this.zone = zone;
			}
			@Override
			protected void addAllVariations() {
				IPv6StringBuilder ipv6Builder = new IPv6StringBuilder(addressSection.ipv6Section, options, zone);
				IPv6AddressSectionStringCollection ipv6Variations = ipv6Builder.getVariations();
				IPAddressPartStringCollection ipv4Collection = 
						addressSection.ipv4Section.toStringCollection(options.mixedOptions);
				for(IPv6AddressSectionString ipv6Variation : ipv6Variations) {
					for(IPAddressPartConfiguredString<?, ?> ipv4Variation : ipv4Collection) {
						IPv6v4MixedParams mixed = new IPv6v4MixedParams(ipv6Variation, ipv4Variation);
						addStringParam(mixed);
					}
				}
			}
		}
	}
	private static class IPv6AddressSectionString extends IPAddressPartConfiguredString<IPv6AddressSection, IPv6StringParams> {
		private final CharSequence zone;
		IPv6AddressSectionString(IPv6AddressSection addr, IPv6StringParams stringParams, CharSequence zone) {
			super(addr, stringParams);
			this.zone = zone;
		}
		@SuppressWarnings("unchecked")
		@Override
		public IPv6StringMatcher getNetworkStringMatcher(boolean isEntireAddress, IPAddressSQLTranslator translator) {
			return new IPv6StringMatcher(this, translator);
		}
		public boolean endIsCompressed() {
			return stringParams.endIsCompressed(addr);
		}
		public boolean isCompressed() {
			return stringParams.isCompressed(addr);
		}
		@Override
		public String getString() {
			if(string == null) {
				string = stringParams.toString(addr, zone);
			}
			return string;
		}
	}
	public static class IPv6StringBuilderOptions extends IPStringBuilderOptions {
		public static final int MIXED = 0x2;
		public static final int UPPERCASE = 0x4;
		public static final int COMPRESSION_CANONICAL = 0x100; //use the compression that is part of the canonical string format
		public static final int COMPRESSION_SINGLE = COMPRESSION_CANONICAL | 0x200; //compress a single segment.  If more than one is compressible, choose the largest, and if multiple are largest, choose the most leftward.
		public static final int COMPRESSION_LARGEST = COMPRESSION_SINGLE | 0x400; //compress fully any section that is largest 
		public static final int COMPRESSION_ALL_FULL = COMPRESSION_LARGEST | 0x800; //compress fully any section that can be compressed
		public static final int COMPRESSION_ALL_PARTIAL = COMPRESSION_ALL_FULL | 0x1000;
		public static final int IPV4_CONVERSIONS = 0x10000;
		public final IPv4StringBuilderOptions mixedOptions;
		public final IPv4StringBuilderOptions ipv4ConverterOptions;
		public final IPv4AddressConverter converter;
		public static final IPv6StringBuilderOptions STANDARD_OPTS = new IPv6StringBuilderOptions(
				IPStringBuilderOptions.BASIC |
					IPv6StringBuilderOptions.UPPERCASE |
					IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS |
					IPv6StringBuilderOptions.COMPRESSION_ALL_FULL, 
			new IPv4StringBuilderOptions(IPStringBuilderOptions.BASIC | IPStringBuilderOptions.LEADING_ZEROS_FULL_ALL_SEGMENTS));
		public static final IPv6StringBuilderOptions ALL_OPTS =  
				new IPv6StringBuilderOptions(
						IPStringBuilderOptions.BASIC | 
							IPv6StringBuilderOptions.MIXED | 
							IPv6StringBuilderOptions.UPPERCASE | 
							IPv6StringBuilderOptions.COMPRESSION_ALL_FULL |
							IPv6StringBuilderOptions.IPV4_CONVERSIONS |
							IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS, 
						new IPv4StringBuilderOptions(IPStringBuilderOptions.BASIC | IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS),//mixed
						null,
						new IPv4StringBuilderOptions(
							IPStringBuilderOptions.BASIC | 
								IPv4StringBuilderOptions.JOIN_ALL | 
								IPv4StringBuilderOptions.JOIN_TWO | 
								IPv4StringBuilderOptions.JOIN_ONE |
								IPv4StringBuilderOptions.HEX |
								IPv4StringBuilderOptions.OCTAL |IPStringBuilderOptions.LEADING_ZEROS_FULL_SOME_SEGMENTS));
		public static final IPv6StringBuilderOptions DATABASE_SEARCH_OPTS =
				new IPv6StringBuilderOptions(IPStringBuilderOptions.BASIC | IPv6StringBuilderOptions.COMPRESSION_LARGEST);
		public IPv6StringBuilderOptions(int options) {
			this(options, null, null, null);
		}
		public IPv6StringBuilderOptions(int options, IPv4StringBuilderOptions mixedOptions) {
			this(options, mixedOptions, null, null);
		}
		public IPv6StringBuilderOptions(int options, IPv4StringBuilderOptions mixedOptions, IPv4AddressConverter ipv4AddressConverter, IPv4StringBuilderOptions ipv4ConverterOptions) {
			super(options | (mixedOptions == null ? 0 : MIXED) | (ipv4ConverterOptions == null ? 0 : IPV4_CONVERSIONS));
			if(includes(MIXED) && mixedOptions == null) {
				mixedOptions = new IPv4StringBuilderOptions();
			}
			this.mixedOptions = mixedOptions;
			if(includes(IPV4_CONVERSIONS)) {
				if(ipv4ConverterOptions == null) {
					ipv4ConverterOptions = new IPv4StringBuilderOptions();
				}
				if(ipv4AddressConverter == null) {
					ipv4AddressConverter = IPAddress.DEFAULT_ADDRESS_CONVERTER;
				}
			}
			this.ipv4ConverterOptions = ipv4ConverterOptions;
			this.converter = ipv4AddressConverter;
		}
		public static IPv6StringBuilderOptions from(IPStringBuilderOptions opts) {
			if(opts instanceof IPv6StringBuilderOptions) {
				return (IPv6StringBuilderOptions) opts;
			}
			return new IPv6StringBuilderOptions(opts.options & ~(MIXED | UPPERCASE | COMPRESSION_ALL_PARTIAL | IPV4_CONVERSIONS));
		}
	}
}
/*
 * Copyright 2019 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import inet.ipaddr.format.AddressComponentRange;
/**
 * AddressComponentSpliterator is an AddressComponentRangeSpliterator for address components where 
 * the type of the item producing the spliterator matches the type of the item traversed.
 * 
 * @author seancfoley
 *
 * @param <T>
 */
public interface AddressComponentSpliterator<T extends AddressComponentRange> extends AddressComponentRangeSpliterator<T, T> {
	
	@Override
	AddressComponentSpliterator<T> trySplit();
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format;
import java.io.Serializable;
import java.math.BigInteger;
import inet.ipaddr.Address;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.string.AddressStringDivisionSeries;
/**
 * Represents any part of an address, whether divided into the standard arrangement of AddressComponent objects, or whether an alternative arrangement using AddressDivision objects.
 * <p>
 * The basic difference between the AddressComponent hierarchy and the AddressDivision hierarchy is that <br>
 * AddressComponent hierarchy uses<br>
 * <ul><li>standardized/typical arrangement (ie for ipv4, 4 equal segments of 1 byte each, for ipv6, 8 equal segments of 2 bytes each, for mac, 6 or 8 equal segments of 1 byte each)</li>
 * <li>equal size segments</li>
 * <li>segments divided along byte boundaries</li></ul>
 * <p>
 * AddressDivision allows alternative arrangements, such as inet_aton style of presenting ipv4 in fewer divisions, 
 * or base 85 for ipv6 which does not even use a base that is a power of 2 (and hence so subdivisions possibly using bit boundaries), 
 * or the aaa-bbb-ccc-ddd mac format with which segments are not divided along byte boundaries
 * <p>
 * Parsing creates objects in the AddressComponent hierarchy, which can then be used to create alternative arrangements using {@link AddressDivisionGrouping} or {@link AddressStringDivisionSeries}
 * <p>
 * @author sfoley
 *
 */
public interface AddressItem extends Comparable<AddressItem>, Serializable {
	/**
	 * Uses {@link Address#DEFAULT_ADDRESS_COMPARATOR}, an instance of {@link inet.ipaddr.AddressComparator.CountComparator}, to compare any two address items.
	 */
	@Override
	default int compareTo(AddressItem other) {
		return Address.DEFAULT_ADDRESS_COMPARATOR.compare(this, other);
	}
	/**
	 * The count of possible distinct values for this AddressComponent.  If not multiple, this is 1.
	 * Note that an AddressDivisionSeries with no divisions or AddressSection with no segments has a single value of 0.
	 * 
	 * For instance, if this is the ip address series subnet 0::/64, then the count is 2 to the power of 64.
	 * 
	 * If this is a the segment 3-7, then the count is 5.
	 * 
	 * @return
	 */
	default BigInteger getCount() {
		return getUpperValue().subtract(getValue()).add(BigInteger.ONE);
	}
	/**
	 * The count of the number of distinct values within the prefix part of the address item, the bits that appear within the prefix length.
	 * 
	 * @param prefixLength
	 * @return
	 */
	default BigInteger getPrefixCount(int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(this, prefixLength);
		}
		int bitCount = getBitCount();
		if(bitCount <= prefixLength) {
			return getCount();
		}
		int shiftAdjustment = bitCount - prefixLength;
		BigInteger lower = getValue(), upper = getUpperValue();
		return upper.shiftRight(shiftAdjustment).subtract(lower.shiftRight(shiftAdjustment)).add(BigInteger.ONE);
	}
	
	/**
	 * Provides the number of bits comprising this address item
	 * 
	 * @return the number of bits
	 */
	int getBitCount();
	
	/**
	 * Provides the number of bytes required for this address item, rounding up if the bit count is not a multiple of 8
	 * 
	 * @return the number of bytes
	 */
	default int getByteCount() {
		return (getBitCount() + (Byte.SIZE - 1)) >>> 3;
	}
	
	/**
	 * Whether this represents multiple potential values (eg a prefixed address or a segment representing a range of values)
	 */
	default boolean isMultiple() {
		return !getUpperValue().equals(getValue());
	}
	
	/**
	 * 
	 * @return the bytes of the lowest address item represented by this address item
	 */
	byte[] getBytes();
	
	/**
	 * Copies the bytes of the lowest address item represented by this address item into the supplied array,
	 * and returns that array.
	 * 
	 * If the supplied array is null or of insufficient size, a new array is created and returned.
	 * 
	 * @return the bytes of the lowest address represented by this address item.
	 */
	byte[] getBytes(byte bytes[]);
	
	/**
	 * Copies the bytes of the lowest address item represented by this address item into the supplied array starting at the given index,
	 * and returns that array.
	 * 
	 * If the supplied array is null or of insufficient size, a new array is created and returned, with the rest of the array contents the same as the original.
	 * 
	 * @return the bytes of the lowest address represented by this address item.
	 */
	byte[] getBytes(byte bytes[], int index);
	
	/**
	 * 
	 * @return the bytes of the largest address item represented by this address item
	 */
	byte[] getUpperBytes();
	
	/**
	 * Copies the bytes of the largest address item represented by this address item into the supplied array,
	 * and returns that array.
	 * 
	 * If the supplied array is null or of insufficient size, a new array is created and returned, with the rest of the array contents the same as the original.
	 * 
	 * @return the bytes of the largest address represented by this address item.
	 */
	byte[] getUpperBytes(byte bytes[]);
	
	/**
	 * Copies the bytes of the largest address item represented by this address item into the supplied array at the given index,
	 * and returns that array.
	 * 
	 * If the supplied array is null or of insufficient size, a new array is created and returned.
	 * 
	 * @return the bytes of the largest address represented by this address item.
	 */
	byte[] getUpperBytes(byte bytes[], int index);
	
	/**
	 * Returns the lowest value represented by this address item, the lowest value included in the range of values
	 * 
	 * @return the lowest value represented by this address item
	 */
	BigInteger getValue();
	
	/**
	 * Returns the highest value represented by this address item, the highest value included in the range of values
	 * 
	 * @return the highest value represented by this address item
	 */
	BigInteger getUpperValue();
		
	/**
	 * Returns whether this item matches the value of zero
	 * 
	 * @return whether this item matches the value of zero
	 */
	boolean isZero();
	
	/**
	 * Returns whether this item includes the value of zero within its range
	 * 
	 * @return whether this item includes the value of zero within its range
	 */
	boolean includesZero();
	
	/**
	 * Returns whether this item matches the maximum possible value for the address type or version
	 * 
	 * @return whether this item matches the maximum possible value
	 */
	boolean isMax();
	
	/**
	 * Returns whether this item includes the maximum possible value for the address type or version within its range
	 * 
	 * @return whether this item includes the maximum possible value within its range
	 */
	boolean includesMax();
	
	/**
	 * whether this address item represents all possible values attainable by an address item of this type
	 * 
	 * @return whether this address item represents all possible values attainable by an address item of this type,
	 * or in other words, both includesZero() and includesMax() return true
	 */
	default boolean isFullRange() {
		return includesZero() && includesMax();
	}
	/**
	 * Returns whether the values of this series contains the prefix block for the given prefix length.
	 * <p>
	 * Use {@link #getMinPrefixLengthForBlock()} to determine the smallest prefix length for which this method returns true.
	 * 
	 * @param divisionPrefixLen
	 * @throws PrefixLenException if prefixLength exceeds the bit count or is negative
	 * @return
	 */
	default boolean containsPrefixBlock(int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return isFullRange();
		}
		BigInteger upper = getUpperValue();
		return AddressDivisionBase.testRange(getValue(), upper, upper, getBitCount(), divisionPrefixLen);
	}
	
	/**
	 * Returns whether the values of this series contains a single prefix block for the given prefix length.
	 * <p>
	 * Use {@link #getPrefixLengthForSingleBlock()} to determine whether there is a prefix length for which this method returns true.
	 * 
	 * @param divisionPrefixLen
	 * @throws PrefixLenException if prefixLength exceeds the bit count or is negative
	 * @return
	 */
	default boolean containsSinglePrefixBlock(int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return isFullRange();
		}
		BigInteger lower = getValue(), upper = getUpperValue();
		return AddressDivisionBase.testRange(lower, lower, upper, getBitCount(), divisionPrefixLen);
	}
	
	/**
	 * Returns the smallest prefix length possible such that this item includes the block of all values for that prefix length.
	 * <p>
	 * If the entire range can be dictated this way, then this method returns the same value as {@link #getPrefixLengthForSingleBlock()}.  
	 * Otherwise, this method will return the minimal possible prefix that can be paired with this address, while {@link #getPrefixLengthForSingleBlock()} will return null.
	 * <p>
	 * In cases where the final bit is constant so there is no such block, this returns the bit count.
	 *
	 * @return the prefix length
	 */
	default int getMinPrefixLengthForBlock() {
		int result = getBitCount();
		BigInteger lower = getValue(), upper = getUpperValue();
		if(!lower.equals(upper)) {
			int longBits = Long.SIZE;
			do {
				long low = lower.longValue();
				int lowerZeros = Long.numberOfTrailingZeros(low);
				if(lowerZeros == 0) {
					break;
				}
				long up = upper.longValue();
				int upperOnes = Long.numberOfTrailingZeros(~up);
				if(upperOnes == 0) {
					break;
				}
				int prefixedBitCount = Math.min(lowerZeros, upperOnes);
				result -= prefixedBitCount;
				if(prefixedBitCount < longBits) {
					break;
				}
				lower = lower.shiftRight(longBits);
				upper = upper.shiftRight(longBits);
			} while(upper.signum() != 0);
		}
		return result;
	}
	
	/**
	 * Returns a prefix length for which the range of this item matches the block of all values for that prefix length.
	 * <p>
	 * If the range can be dictated this way, then this method returns the same value as {@link #getMinPrefixLengthForBlock()}.
	 * <p>
	 * If no such prefix length exists, returns null.
	 * <p>
	 * If this item represents a single value, this returns the bit count.
	 * 
	 * @return the prefix length or null
	 */
	default Integer getPrefixLengthForSingleBlock() {
		int divPrefix = getMinPrefixLengthForBlock();
		BigInteger lower = getValue(), upper = getUpperValue();
		int bitCount = getBitCount();
		if(divPrefix == bitCount) {
			if(lower.equals(upper)) {
				return AddressDivisionGroupingBase.cacheBits(divPrefix);
			}
		} else {
			int shift = bitCount - divPrefix;
			if(lower.shiftRight(shift).equals(upper.shiftRight(shift))) {
				return AddressDivisionGroupingBase.cacheBits(divPrefix);
			}
		}
		return null;
	}
	/**
	 * Returns the total number of values when ranging across the given number of host bits. 
	 * This is the reverse of {@link #getBitsForCount(long)}.
	 * 
	 * A bitCount of zero or less returns zero.
	 * 
	 * @param bitCount
	 */
	public static BigInteger getBlockSize(int bitCount) {
		return BigInteger.ONE.shiftLeft(bitCount);
	}
	
	/**
	 * BitsForCount returns the number of bits required outside the prefix length 
	 * for a single prefix block to span at least as many addresses as the given count. 
	 * Mathematically, it is the ceiling of the base 2 logarithm of the given count. 
	 * A count of zero or less than zero returns null.
	 * 
	 * See {@link #getBlockSize(int)} for the reverse direction.
	 * 
	 * @param count
	 */
	public static Integer getBitsForCount(long count) {
		if(count <= 0) {
			return null;
		}
		int logBase2 = (Long.SIZE - 1) - Long.numberOfLeadingZeros(count);
		if((~(-1L << logBase2) & count) != 0) {
			logBase2++;
		}
		return logBase2;
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.TreeMap;
import java.util.function.Supplier;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.format.AddressDivisionGroupingBase.AddressStringParams;
import inet.ipaddr.format.AddressDivisionGroupingBase.IPAddressStringParams;
import inet.ipaddr.format.large.IPAddressLargeDivision;
import inet.ipaddr.format.standard.AddressDivisionGrouping.StringOptions.Wildcards;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.AddressSegmentParams;
/**
 * Base class for address divisions.
 * 
 * @author sfoley
 *
 */
public abstract class AddressDivisionBase implements AddressGenericDivision {
	private static final long serialVersionUID = 4L;
	// a set of pre-defined string types		
	private static final IPStringOptions OCTAL_PARAMS, HEX_PARAMS, DECIMAL_PARAMS;
	static {
		Wildcards rangeWildcard = new Wildcards(IPAddress.RANGE_SEPARATOR_STR);
		OCTAL_PARAMS = new IPStringOptions.Builder(8).setSegmentStrPrefix("0").setWildcards(rangeWildcard).toOptions();
		HEX_PARAMS = new IPStringOptions.Builder(16).setSegmentStrPrefix("0x").setWildcards(rangeWildcard).toOptions();
		DECIMAL_PARAMS = new IPStringOptions.Builder(10).setWildcards(rangeWildcard).toOptions();
	}
	private static final String zeros[];
	static {
		int zerosLength = 20;
		zeros = new String[zerosLength];
		zeros[0] = "";
		for(int i = 1; i < zerosLength; i++) {
			zeros[i] = zeros[i - 1] + '0';
		}
	}
	protected static final char[] DIGITS = {
		'0', '1', '2', '3', '4', '5',
		'6', '7', '8', '9', 'a', 'b',
		'c', 'd', 'e', 'f', 'g', 'h',
		'i', 'j', 'k', 'l', 'm', 'n',
		'o', 'p', 'q', 'r', 's', 't',
		'u', 'v', 'w', 'x', 'y', 'z',
    };
	public static final char[] EXTENDED_DIGITS = {
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 
		'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 
		'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 
		'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 
		'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 
		'y', 'z', '!', '#', '$', '%', '&', '(', ')', '*', '+', '-', 
		';', '<', '=', '>', '?', '@', '^', '_', '`', '{', '|', '}', 
		'~' };
	protected static final int MIN_RADIX = 2, MAX_RADIX = 85;
	protected static final BigInteger BIG_MIN_RADIX = BigInteger.valueOf(MIN_RADIX),
			BIG_MAX_RADIX = BigInteger.valueOf(MAX_RADIX);
	protected static final char[] UPPERCASE_DIGITS = IPAddressLargeDivision.EXTENDED_DIGITS; 
	protected static final char[] DOUBLE_DIGITS_DEC = {
		'0', '0', '0', '1', '0', '2', '0', '3', '0', '4',
		'0', '5', '0', '6', '0', '7', '0', '8', '0', '9',
		'1', '0', '1', '1', '1', '2', '1', '3', '1', '4',
		'1', '5', '1', '6', '1', '7', '1', '8', '1', '9',
		'2', '0', '2', '1', '2', '2', '2', '3', '2', '4',
		'2', '5', '2', '6', '2', '7', '2', '8', '2', '9',
		'3', '0', '3', '1', '3', '2', '3', '3', '3', '4',
		'3', '5', '3', '6', '3', '7', '3', '8', '3', '9',
		'4', '0', '4', '1', '4', '2', '4', '3', '4', '4',
		'4', '5', '4', '6', '4', '7', '4', '8', '4', '9',
		'5', '0', '5', '1', '5', '2', '5', '3', '5', '4',
		'5', '5', '5', '6', '5', '7', '5', '8', '5', '9',
		'6', '0', '6', '1', '6', '2', '6', '3', '6', '4',
		'6', '5', '6', '6', '6', '7', '6', '8', '6', '9',
		'7', '0', '7', '1', '7', '2', '7', '3', '7', '4',
		'7', '5', '7', '6', '7', '7', '7', '8', '7', '9',
		'8', '0', '8', '1', '8', '2', '8', '3', '8', '4',
		'8', '5', '8', '6', '8', '7', '8', '8', '8', '9',
		'9', '0', '9', '1', '9', '2', '9', '3', '9', '4',
		'9', '5', '9', '6', '9', '7', '9', '8', '9', '9',
	};
	private static TreeMap<Long, Integer> maxDigitMap = new TreeMap<Long, Integer>();
	private static TreeMap<Long, BigInteger> radixPowerMap = new TreeMap<Long, BigInteger>();
	//cached for performance reasons - especially valuable since segments can be shared amongst different addresses as we do with the masks
	protected transient String cachedWildcardString;
	
	/* the cached address bytes */
	private transient byte[] lowerBytes, upperBytes;
	
	protected transient int hashCode;
	
	protected AddressDivisionBase() {}
	
	protected boolean isSameValues(AddressDivisionBase other) {
		return getValue().equals(other.getValue()) && getUpperValue().equals(other.getUpperValue());
	}
	/**
	 * Two divisions are equal if they:
	 * - they match type/version (ipv4, ipv6, mac, or a specific division class)
	 * - match bit counts
	 * - match values
	 * Prefix lengths, for those divisions that have them, are ignored.
	 */
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof AddressDivisionBase) {
			// we call isSameValues on the other object to defer to subclasses overriding that method in object o.
			// For instance, if we are a grouping class like AddressDivision, 
			// and if the other is IPv4/6/MAC/AddressSection, then we call the overridden isSameGrouping in the other class,
			// which matches type.
			// Also, those other classes override equals to ensure flip doesn't go the other way
			AddressDivisionBase other = (AddressDivisionBase) o;
			return getBitCount() == other.getBitCount() && other.isSameValues(this);
		}
		return false;
	}
	
	protected static int createHashCode(long value, long upperValue) {
		return adjustHashCode(1, value, upperValue);
	}
		
	static int adjustHashCode(int currentHash, long value, long upperValue) {
		long shifted = value >>> 32;
		int adjusted = (int) ((shifted == 0) ? value : (value ^ shifted));
		currentHash = 31 * currentHash + adjusted;
		if(upperValue != value) {
			shifted = upperValue >>> 32;
			adjusted = (int) ((shifted == 0) ? upperValue : (upperValue ^ shifted));
			currentHash = 31 * currentHash + adjusted;
		}
		return currentHash;
	}
	
	@Override
	public int hashCode() {
		int res = hashCode;
		if(res == 0) {
			res = 1;
			BigInteger lower = getValue(), upper = getUpperValue();
			int longBits = Long.SIZE;
			do {
				long low = lower.longValue();
				long up = upper.longValue();
				lower = lower.shiftRight(longBits);
				upper = upper.shiftRight(longBits);
				res = adjustHashCode(res, low, up);
			} while(upper.signum() != 0);
			hashCode = res;
		}
		return res;
	}
	
	/**
	 * Gets the bytes for the lowest address in the range represented by this address division.
	 * <p>
	 * Since bytes are signed values while addresses are unsigned, values greater than 127 are
	 * represented as the (negative) two's complement value of the actual value.
	 * You can get the unsigned integer value i from byte b using i = 0xff &amp; b.
	 * 
	 * @return
	 */
	@Override
	public byte[] getBytes() {
		byte cached[] = lowerBytes;
		if(cached == null) {
			lowerBytes = cached = getBytesImpl(true);
		}
		return cached.clone();
	}
	
	/**
	 * Gets the value for the lowest address in the range represented by this address division.
	 * <p>
	 * If the value fits in the specified array at the specified index, the same array is returned with the value copied at the specified index.  
	 * Otherwise, a new array is allocated and returned with the value copied at the specified index, and the rest of the array contents the same as the original.
	 * <p>
	 * You can use {@link #getBitCount()} to determine the required array length for the bytes.
	 * <p>
	 * Since bytes are signed values while addresses are unsigned, values greater than 127 are
	 * represented as the (negative) two's complement value of the actual value.
	 * You can get the unsigned integer value i from byte b using i = 0xff &amp; b.
	 * 
	 * @return
	 */
	@Override
	public byte[] getBytes(byte bytes[], int index) {
		byte cached[] = lowerBytes;
		if(cached == null) {
			lowerBytes = cached = getBytesImpl(true);
		}
		return getBytes(bytes, index, cached);
	}
	/**
	 * Equivalent to {@link #getBytes(byte[], int)} with index of 0.
	 */
	@Override
	public byte[] getBytes(byte bytes[]) {
		return getBytes(bytes, 0);
	}
	private byte[] getBytes(byte[] provided, int startIndex, byte[] cached) {
		int byteCount = (getBitCount() + 7) >> 3;
		if(provided == null || provided.length < byteCount + startIndex) {
			if(startIndex > 0) {
				byte bytes2[] = new byte[byteCount + startIndex];
				if(provided != null) {
					System.arraycopy(provided, 0, bytes2, 0, Math.min(startIndex, provided.length));
				}
				System.arraycopy(cached, 0, bytes2, startIndex, cached.length);
				return bytes2;
			}
			return cached.clone();
		} 
		System.arraycopy(cached, 0, provided, startIndex, byteCount);
		return provided;
	}
	
	@Override
	public byte[] getUpperBytes() {
		if(!isMultiple()) {
			return getBytes();
		}
		byte cached[] = upperBytes;
		if(cached == null) {
			upperBytes = cached = getBytesImpl(false);
		}
		return cached.clone();
	}
	
	@Override
	public byte[] getUpperBytes(byte bytes[], int index) {
		if(!isMultiple()) {
			return getBytes(bytes, index);
		}
		byte cached[] = upperBytes;
		if(cached == null) {
			upperBytes = cached = getBytesImpl(false);
		}
		return getBytes(bytes, index, cached);
	}
	
	@Override
	public byte[] getUpperBytes(byte bytes[]) {
		return getUpperBytes(bytes, 0);
	}
	
	protected abstract byte[] getBytesImpl(boolean low);
	
	/**
	 * @return the default radix for textual representations of addresses (10 for IPv4, 16 for IPv6)
	 */
	protected abstract int getDefaultTextualRadix();
	
	/**
	 * @return the number of digits for the maximum possible value of the division when using the default radix
	 */
	protected abstract int getMaxDigitCount();
	// Returns the maximum number of digits required for the given bit-count and radix.
	// The supplied maximum value can be null, in which case it will be calculated if needed, 
	// otherwise it must correspond to the largest unsigned integer corresponding to the given bit-count.
	// So this means you should call this method for bit-counts 63 bits and larger, for which maxValue cannot be stored in a long.
	// The bit-count and radix are validated.
	// Callers must ensure maxValue is either null, or it is non-negative and corresponds to the given bit-count, otherwise the result will be incorrect.
	protected static int getMaxDigitCount(int radix, int bitCount, BigInteger maxValue) {
		int result = getDigitCount(radix, bitCount); // validates both radix and bitCount
		if(result > 0) {
			return result;
		}
		long key = (((long) radix) << 32) | bitCount;
		Integer digs = maxDigitMap.get(key);
		if(digs == null) {
			if(maxValue == null) {
				maxValue = getMaxValue(bitCount);
			}
			digs = getDigitCount(maxValue, BigInteger.valueOf(radix));
			@SuppressWarnings("unchecked")
			TreeMap<Long, Integer> newMaxDigitMap = (TreeMap<Long, Integer>) maxDigitMap.clone();
			newMaxDigitMap.put(key, digs);
			maxDigitMap = newMaxDigitMap;
		}
		return digs;
	}
	
	protected static BigInteger getMaxValue(int bitCount) {
		if(bitCount < 0) {
			throw new IllegalArgumentException();
		}
		int maxBytes = (bitCount + 7) >>> 3;
		byte max[] = new byte[maxBytes];
		if(maxBytes > 0) {
			int topBits = bitCount % 8;
			if(topBits == 0) {
				topBits = 8;
			}
			max[0] = (byte) ~(~0 << topBits);
			for(int i = 1; i < max.length; i++) {
				max[i] = ~0;
			}
		}
		return new BigInteger(1, max);
	}
	
	public static int getDigitCount(BigInteger val, BigInteger radix) {
		if(radix.compareTo(BIG_MIN_RADIX) < 0 || radix.compareTo(BIG_MAX_RADIX) > 0) {
			throw new IllegalArgumentException();
		} else if(val.signum() == 0 || val.equals(BigInteger.ONE)) {
			return 1;
		}
		if(val.signum() > 0) {
			int smallRadix = radix.intValue();
			if(smallRadix == 16) {
				return getDigitCount(16, val.bitLength());
			} else if(smallRadix == 8) {
				// could have used getDigitCount like hex, but chose to avoid the division
				int result = 1;
				while(true) {
					val = val.shiftRight(3);
					if(val.signum() == 0) {
						break;
					}
					result++;
				}
				return result;
			} else if(smallRadix == 4) {
				return getDigitCount(4, val.bitLength());
			} else if(smallRadix == 2) {
				return val.bitLength();
			}
		}
		int result = 1;
		while(true) {
			val = val.divide(radix);
			if(val.signum() == 0) {
				break;
			}
			result++;
		}
		return result;
	}
	// Returns the maximum number of digits required for the given bit-count and radix.
	// The supplied maximum value must correspond to the largest unsigned integer corresponding to the given bit-count.
	// So this means you should avoid calling this method for bit-counts larger than 63.
	// The bit-count and radix are validated.
	// Callers must ensure maxValue is non-negative and corresponds to the given bit-count, otherwise the result will be incorrect.
	protected static int getMaxDigitCount(int radix, int bitCount, long maxValue) {
		int result = getDigitCount(radix, bitCount); // validates both radix and bitCount
		if(result > 0) {
			return result;
		}
		if(radix == 10) {
			if(maxValue < 10) {
				return 1;
			} else if(maxValue < 100) {
				return 2;
			} else if(maxValue < 1000) {
				return 3;
			} else if(maxValue < 10000) {
				return 4;
			} else if(maxValue < 100000) {
				return 5;
			} else if(maxValue < 1000000) {
				return 6;
			} else if(maxValue < 10000000) {
				return 7;
			} else if(maxValue < 100000000) {
				return 8;
			} else if(maxValue < 1000000000) {
				return 9;
			} else if(maxValue < 10000000000L) {
				return 10;
			} else if(maxValue < 100000000000L) {
				return 11;
			} else if(maxValue < 1000000000000L) {
				return 12;
			} else if(maxValue < 10000000000000L) {
				return 13;
			} else if(maxValue < 100000000000000L) {
				return 14;
			} else if(maxValue < 1000000000000000L) {
				return 15;
			} else if(maxValue < 10000000000000000L) {
				return 16;
			} else if(maxValue < 100000000000000000L) {
				return 17;
			} else if(maxValue < 1000000000000000000L) {
				return 18;
			}
			return 19;
		} else {
			long key = (((long) radix) << 32) | bitCount;
			Integer digs = maxDigitMap.get(key);
			if(digs == null) {
				result = 1;
				while(true) {
					maxValue /= radix;
					if(maxValue == 0) {
						break;
					}
					result++;
				}
				@SuppressWarnings("unchecked")
				TreeMap<Long, Integer> newMaxDigitMap = (TreeMap<Long, Integer>) maxDigitMap.clone();
				newMaxDigitMap.put(key, result);
				maxDigitMap = newMaxDigitMap;
			} else {
				result = digs;
			}
			return result;
		}
	}
	private static int getDigitCount(int radix, int bitCount) {
		if(bitCount <= 0) {
			if(bitCount == 0 && radix >= MIN_RADIX && radix <= MAX_RADIX) {
				return 1;
			}
			throw new IllegalArgumentException();
		}
		switch(radix) {
		case 16:
			return (bitCount + 3) >> 2; //every 4 bits is another digit
		case 8:
			return (bitCount + 2) / 3; //every 3 bits is another digit
		case 4:
			return (bitCount + 1) >> 1; //every 2 bits is another digit
		case 2:
			return bitCount; //every bit is another digit
		case 10:
			break;
		default:
			if(radix < MIN_RADIX || radix > MAX_RADIX) {
				throw new IllegalArgumentException();
			}
		}
		return -1;
	}
	
	public static int getDigitCount(long value, int radix) {
		int result = 1;
		if(radix == 16 && value >= 0) {
			return getDigitCount(16, Long.SIZE - Long.numberOfLeadingZeros(value));
		} else if(radix == 10 && value > -10) {
			if(value < 10) {
				return 1;
			} else if(value < 100) {
				return 2;
			} else if(value < 1000) {
				return 3;
			}
			value /= 1000;
			result = 3; //we start with 3 in the loop below
		} else if(radix == 8 && value >= 0) {
			// could have used getDigitCount like hex, but chose to avoid the division
			while(true) {
				value >>>= 3;
				if(value == 0) {
					break;
				}
				result++;
			}
			return result;
		} else if(radix == 4 && value >= 0) {
			return getDigitCount(4, Long.SIZE - Long.numberOfLeadingZeros(value));
		} else if(radix == 2 && value > 0) {
			return Long.SIZE - Long.numberOfLeadingZeros(value);
		} else if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		while(true) {
			value /= radix;
			if(value == 0) {
				break;
			}
			result++;
		}
		return result;
	}
	
	/**
	 * Caches the results of radix to the given power.
	 * 
	 * @param radix
	 * @param power
	 * @return
	 */
	protected static BigInteger getRadixPower(BigInteger radix, int power) {
		long key = (((long) radix.intValue()) << 32) | power;
		BigInteger result = radixPowerMap.get(key);
		if(result == null) {
			if(radix.compareTo(BIG_MIN_RADIX) < 0 || radix.compareTo(BIG_MAX_RADIX) > 0) {
				throw new IllegalArgumentException();
			} else if(power == 1) {
				result = radix;
			} else if((power & 1) == 0) {
				BigInteger halfPower = getRadixPower(radix, power >> 1);
				result = halfPower.multiply(halfPower);
			} else {
				BigInteger halfPower = getRadixPower(radix, (power - 1) >> 1);
				result = halfPower.multiply(halfPower).multiply(radix);
			}
			@SuppressWarnings("unchecked")
			TreeMap<Long, BigInteger> newRadixPowerMap = (TreeMap<Long, BigInteger>) radixPowerMap.clone();
			newRadixPowerMap.put(key, result);
			radixPowerMap = newRadixPowerMap;
		}
		return result;
	}
	
	protected abstract int adjustLowerLeadingZeroCount(int leadingZeroCount, int radix);
	
	protected abstract int adjustUpperLeadingZeroCount(int leadingZeroCount, int radix);
	private static void getSplitChar(int count, char splitDigitSeparator, String characters, String stringPrefix, StringBuilder builder) {
		while(count-- > 0) {
			if(stringPrefix.length() > 0) {
				builder.append(stringPrefix);
			}
			builder.append(characters);
			builder.append(splitDigitSeparator);
		}
		builder.setLength(builder.length() - 1);
	}
	
	private static void getSplitChar(int count, char splitDigitSeparator, char character, String stringPrefix, StringBuilder builder) {
		int prefLen = stringPrefix.length();
		while(count-- > 0) {
			if(prefLen > 0) {
				builder.append(stringPrefix);
			}
			builder.append(character);
			builder.append(splitDigitSeparator);
		}
		builder.setLength(builder.length() - 1);
	}
	private static void getSplitLeadingZeros(int leadingZeroCount, char splitDigitSeparator, String stringPrefix, StringBuilder builder) {
		getSplitChar(leadingZeroCount, splitDigitSeparator, '0', stringPrefix, builder);
	}
	protected static void getLeadingZeros(int leadingZeroCount, StringBuilder builder) {
		if(leadingZeroCount > 0) {
			String stringArray[] = zeros;
			if(leadingZeroCount >= stringArray.length) {
				int increment = stringArray.length - 1;
				String incrementStr = stringArray[increment];
				while(leadingZeroCount >= increment) {
					builder.append(incrementStr);
					leadingZeroCount -= increment;
				}
				builder.append(stringArray[leadingZeroCount]);
				return;
			}
			builder.append(stringArray[leadingZeroCount]);
		}
	}
	
	@Override
	public String toString() {
		int radix = getDefaultTextualRadix();
		IPStringOptions opts;
		switch(radix) {
		case 8:
			opts = OCTAL_PARAMS;
			break;
		case 16:
			opts = HEX_PARAMS;
			break;
		case 10:
			opts = DECIMAL_PARAMS;
			break;
		default:
			opts = new IPStringOptions.Builder(radix).setWildcards(new Wildcards(IPAddress.RANGE_SEPARATOR_STR)).toOptions();
			break;
		}
		StringBuilder builder = new StringBuilder(34);
		toParams(opts).appendSingleDivision(this, builder);
		return builder.toString();
	}
	
	protected static AddressStringParams<IPAddressStringDivisionSeries> toParams(IPStringOptions opts) {
		//since the params here are not dependent on the section, we could cache the params in the options 
		//this is not true on the IPv6 side where compression settings change based on the section
		
		@SuppressWarnings("unchecked")
		AddressStringParams<IPAddressStringDivisionSeries> result = (AddressStringParams<IPAddressStringDivisionSeries>) AddressDivisionGroupingBase.getCachedParams(opts);
		if(result == null) {
			result = new IPAddressStringParams<IPAddressStringDivisionSeries>(opts.base, opts.separator, opts.uppercase);
			result.expandSegments(opts.expandSegments);
			result.setWildcards(opts.wildcards);
			result.setSegmentStrPrefix(opts.segmentStrPrefix);
			result.setAddressLabel(opts.addrLabel);
			result.setReverse(opts.reverse);
			result.setSplitDigits(opts.splitDigits);
			result.setRadix(opts.base);
			result.setUppercase(opts.uppercase);
			result.setSeparator(opts.separator);
			result.setZoneSeparator(opts.zoneSeparator);
			AddressDivisionGroupingBase.setCachedParams(opts, result);
		}
		return result;
	}
	/**
	 * A simple string using just the lower value and the default radix.
	 * 
	 * @return
	 */
	protected abstract String getDefaultLowerString();
	/**
	 * A simple string using just the lower and upper values and the default radix, separated by the default range character.
	 * 
	 * @return
	 */
	protected abstract String getDefaultRangeString();
	/**
	 * This is the wildcard string to be used when producing the default strings with getString() or getWildcardString()
	 * 
	 * Since no parameters for the string are provided, default settings are used, but they must be consistent with the address.
	 * 
	 * For instance, generally the '*' is used as a wildcard to denote all possible values for a given segment,
	 * but in some cases that character is used for a segment separator.
	 * 
	 * Note that this only applies to "default" settings, there are additional string methods that allow you to specify these separator characters.
	 * Those methods must be aware of the defaults as well, to know when they can defer to the defaults and when they cannot.
	 * 
	 * @return
	 */
	protected String getDefaultSegmentWildcardString() {
		return null;
	}
	
	/**
	 * This is the wildcard string to be used when producing the default strings with getString() or getWildcardString()
	 * 
	 * Since no parameters for the string are provided, default settings are used, but they must be consistent with the address.
	 * 
	 * For instance, generally the '-' is used as a range separator, but in some cases that character is used for a segment separator.
	 * 
	 * Note that this only applies to "default" settings, there are additional string methods that allow you to specify these separator characters.
	 * Those methods must be aware of the defaults as well, to know when they can defer to the defaults and when they cannot.
	 * 
	 * @return
	 */
	protected abstract String getDefaultRangeSeparatorString();
	/**
	 * Produces a normalized string to represent the segment.
	 * If the segment CIDR prefix length covers the range, then it is assumed to be a CIDR, and the string has only the lower value of the CIDR range.
	 * Otherwise, the explicit range will be printed.
	 * @return
	 */
	protected String getString() {
		String result = cachedWildcardString;
		if(result == null) {
			synchronized(this) {
				result = cachedWildcardString;
				if(result == null) {
					if(!isMultiple()) {
						result = getDefaultLowerString();
					} else if(!isFullRange() || (result = getDefaultSegmentWildcardString()) == null) {
						result = getDefaultRangeString();
					}
					cachedWildcardString = result;
				}
			}
		}
		return result;
	}
	// this is like a shortcut to getDefaultString() when you already know !isMultiple() or you know isSinglePrefixBlock()
	protected String getCachedDefaultLowerString() {
		String result = cachedWildcardString;
		if(result == null) {
			synchronized(this) {
				result = cachedWildcardString;
				if(result == null) {
					cachedWildcardString = result = getDefaultLowerString();
				}
			}
		}
		return result;
	}
	
	protected String getWildcardString() {
		return getString();
	}
	
	protected void setDefaultAsFullRangeWildcardString() {
		if(cachedWildcardString == null) {
			String result = getDefaultSegmentWildcardString(); 
			if(result != null) {
				synchronized(this) {
					cachedWildcardString = result;
				}
			}
		}
	}
	protected abstract int getLowerStringLength(int radix);
	
	protected abstract int getUpperStringLength(int radix);
	
	protected abstract void getLowerString(int radix, boolean uppercase, StringBuilder appendable);
	
	protected abstract void getLowerString(int radix, int choppedDigits, boolean uppercase, StringBuilder appendable);
	
	protected abstract void getUpperString(int radix, boolean uppercase, StringBuilder appendable);
	
	protected abstract void getUpperStringMasked(int radix, boolean uppercase, StringBuilder appendable);
	
	protected abstract void getSplitLowerString(int radix, int choppedDigits, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix, StringBuilder appendable);
	
	protected abstract void getSplitRangeString(String rangeSeparator, String wildcard, int radix, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix, StringBuilder appendable);
	
	protected abstract int getSplitRangeStringLength(String rangeSeparator, String wildcard, int leadingZeroCount, int radix, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix);
	protected abstract int getRangeDigitCount(int radix);
	
	protected static int toUnsignedStringLength(long value, int radix) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		int result;
		if(value > 0xffff || (result = toUnsignedStringLengthFast((int) value, radix)) < 0) {
			result = toUnsignedStringLengthSlow(value, radix);
		}
		return result;
	}
	
	private static int toUnsignedStringLengthSlow(long value, int radix) {
		int count = 1;
		boolean useInts = value <= Integer.MAX_VALUE;
		int intValue = useInts ? (int) value : radix;
		while(intValue >= radix) {
			if(useInts) {
				intValue /= radix;
			} else {
				value /= radix;
				if(value <= Integer.MAX_VALUE) {
					useInts = true;
					intValue = (int) value;
				}
			}
			++count;
		}
		return count;
	}
	
	private static int toUnsignedStringLengthFast(int value, int radix) {
		if(value <= 1) {//for values larger than 1, result can be different with different radix (radix is 2 and up)
			return 1;
		}
		if(radix == 10) {
			//this needs value <= 0xffff (ie 16 bits or less) which is a prereq to calling this method
			if(value < 10) {
				return 1;
			} else if(value < 100) {
				return 2;
			} else if(value < 1000) {
				return 3;
			} else if(value < 10000) {
				return 4;
			}
			return 5;
	    }
		if(radix == 16) {
			//this needs value <= 0xffff (ie 16 bits or less)
			if(value < 0x10) {
				return 1;
			} else if(value < 0x100) {
				return 2;
			} else if(value < 0x1000) {
				return 3;
			}
			return 4;
		}
		if(radix == 8) {
			//this needs value <= 0xffff (ie 16 bits or less)
			if(value < 010) {
				return 1;
			} else if(value < 0100) {
				return 2;
			} else if(value < 01000) {
				return 3;
			} else if(value < 010000) {
				return 4;
			} else if(value < 0100000) {
				return 5;
			}
			return 6;
		}
		if(radix == 2) {
			//count the number of digits
			//note that we already know value != 0 and that value <= 0xffff
			//and we use both of those facts
			int digitCount = 15;
			int val = value;
			if (val >>> 8 == 0) { 
				digitCount -=  8;
			} else {
				val >>>= 8;
			}
			if (val >>> 4 == 0) {
				digitCount -=  4;
			} else {
				val >>>= 4;
			}
			if (val >>> 2 == 0) {
				digitCount -= 2;
			} else {
				val >>>= 2;
			}
			//at this point, if (val & 2) != 0 we have undercounted the digit count by 1
			if((val & 2) != 0) {
				++digitCount;
			}
			return digitCount;
		}
		return -1;
	}
	
	protected static StringBuilder toUnsignedStringCased(long value, int radix, int choppedDigits, boolean uppercase, StringBuilder appendable) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		} else if(value > 0xffff || !toUnsignedStringFastChopped((int) value, radix, choppedDigits, uppercase, appendable)) {
			toUnsignedStringSlow(value, radix, choppedDigits, uppercase, appendable);
		}
		return appendable;
	}
	
	// callers ensure value <= 0xffff
	private static boolean toUnsignedStringFastChopped(int value, int radix, int choppedDigits, boolean uppercase, StringBuilder appendable) {
		if(toUnsignedStringFast(value, radix, uppercase, appendable)) {
			if(choppedDigits > 0) {
				appendable.setLength(appendable.length() - choppedDigits);
			}
			return true;
		}
		return false;
	}
	private static char[] getDigits(boolean uppercase, int radix) {
		if(uppercase || radix > 36) {
			return UPPERCASE_DIGITS;
		}
		return DIGITS;
	}
	
	// callers ensure value <= 0xffff
	private static boolean toUnsignedStringFast(int value, int radix, boolean uppercase, StringBuilder appendable) {
		if(value <= 1) {//for values larger than 1, result can be different with different radix (radix is 2 and up)
			appendable.append(value == 0 ? '0' : '1');
			return true;
		}
		int quotient, remainder; //we iterate on //value == quotient * radix + remainder
		if(radix == 10) {
			// we know value <= 0xffff (ie 16 bits or less)
			if(value < 10) {
				char dig[] = getDigits(uppercase, radix);
				appendable.append(dig[value]);
				return true;
			} else if(value < 100) {
				char dig[] = DOUBLE_DIGITS_DEC;
				int digIndex = value << 1;
				appendable.append(dig[digIndex]);
				appendable.append(dig[digIndex + 1]);
				return true;
			} else if(value < 200) {
				int index = appendable.length();
				appendable.append("127");
				if(value != 127) {
					char dig[] = DOUBLE_DIGITS_DEC;
					index++;
					int digIndex = (value - 100) << 1;
					appendable.setCharAt(index, dig[digIndex]);
					appendable.setCharAt(index + 1, dig[digIndex + 1]);
				}
				return true;
			} else if(value < 300) {
				int index = appendable.length();
				appendable.append("255");
				if(value != 255) {
					char dig[] = DOUBLE_DIGITS_DEC;
					index++;
					int digIndex = (value - 200) << 1;
					appendable.setCharAt(index, dig[digIndex]);
					appendable.setCharAt(index + 1, dig[digIndex + 1]);
				}
				return true;
			} else if(value < 1000) {
				appendable.append("   ");
			} else if(value < 10000) {
				appendable.append("    ");
			} else {
				appendable.append("     ");
			}
			char dig[] = DIGITS;
			int index = appendable.length();
			do { //value == quotient * 10 + remainder
				quotient = (value * 0xcccd) >>> 19; //floor of n/10 is same as floor of ((0xcccd * n / 2^16) / 2^3)
				remainder = value - ((quotient << 3) + (quotient << 1)); //multiplication by 2 added to multiplication by 2 ^ 3 is multiplication by 2 + 8 = 10
				appendable.setCharAt(--index, dig[remainder]);
				value = quotient;
	        } while(value != 0);
			return true;
	    } else if(radix == 16) {
			if(value < 0x10) {
				char dig[] = getDigits(uppercase, radix);
				appendable.append(dig[value]);
				return true;
			} else if(value < 0x100) {
				appendable.append("  ");
			} else if(value < 0x1000) {
				appendable.append("   ");
			} else {
				if(value == 0xffff) {
					appendable.append(uppercase ? "FFFF" : "ffff");
					return true;
				}
				appendable.append("    ");
			}
			char dig[] = getDigits(uppercase, radix);
			int index = appendable.length();
			do {//value2 == quotient * 16 + remainder
				remainder = value & 15;
				value >>>= 4;
				appendable.setCharAt(--index, dig[remainder]);
			} while(value != 0);
			return true;
		} else if(radix == 8) {
			char dig[] = DIGITS;
			if(value < 010) {
				appendable.append(dig[value]);
				return true;
			} else if(value < 0100) {
				appendable.append("  ");
			} else if(value < 01000) {
				appendable.append("   ");
			} else if(value < 010000) {
				appendable.append("    ");
			} else if(value < 0100000) { 
				appendable.append("     ");
			} else {
				appendable.append("      ");
			}
			int index = appendable.length();
			do {//value2 == quotient * 8 + remainder
				remainder = value & 7;
				value >>>= 3;
				appendable.setCharAt(--index, dig[remainder]);
			} while(value != 0);
			return true;
		} else if(radix == 2) {
			//note that we already know value != 0 and that value <= 0xffff
			int digitIndex;
			if (value >>> 8 == 0) {
				if(value == 0xff) {
					appendable.append("11111111");
					return true;
				} else if (value >>> 4 == 0) {
					digitIndex = 4;
				} else {
					digitIndex = 8;
				}
			} else {
				if(value == 0xffff) {
					appendable.append("1111111111111111");
					return true;
				} else if (value >>> 4 == 0) {
					digitIndex = 12;
				} else {
					digitIndex = 16;
				}
			}
			while(--digitIndex > 0) {
				int digit = (value >>> digitIndex) & 1;
				if(digit == 1) {
					appendable.append('1');
					while(--digitIndex > 0) {
						digit = (value >>> digitIndex) & 1;
						appendable.append(digit == 0 ? '0' : '1');
					}
					break;
				}
			}
			appendable.append((value & 1) == 0 ? '0' : '1');
			return true;
		}
		return false;
	}
	
	private static void toUnsignedStringSlow(
			long value,
			int radix,
			int choppedDigits,
			boolean uppercase,
			StringBuilder appendable) {
		int front = appendable.length();
		appendDigits(value, radix, choppedDigits, uppercase, appendable);
		int back = appendable.length() - 1;
		while(front < back) {
			char frontChar = appendable.charAt(front);
			appendable.setCharAt(front++, appendable.charAt(back));
			appendable.setCharAt(back--, frontChar);
		}
	}
	
	private static void appendDigits(
			long value,
			int radix,
			int choppedDigits,
			boolean uppercase,
			StringBuilder appendable) {
		boolean useInts = value <= Integer.MAX_VALUE;
		int value2 = useInts ? (int) value : radix;
		int index;
		char dig[] = getDigits(uppercase, radix);
		while(value2 >= radix) {
			if(useInts) {
				int val2 = value2;
				value2 /= radix;
				if(choppedDigits > 0) {
					choppedDigits--;
					continue;
				}
				index = val2 % radix;
			} else {
				long val = value;
				value /= radix;
				if(value <= Integer.MAX_VALUE) {
					useInts = true;
					value2 = (int) value;
				}
				if(choppedDigits > 0) {
					choppedDigits--;
					continue;
				}
				index = (int) (val % radix);
			}
			appendable.append(dig[index]);
		}
		if(choppedDigits == 0) {
			appendable.append(dig[value2]);
		}
	}
	
	protected void appendUppercase(CharSequence str, int radix, StringBuilder appendable) {
		if(radix > 10) {
			for(int i = 0; i < str.length(); i++) {
				char c = str.charAt(i);
				if(c >= 'a' && c <= 'z') {
					c += 'A' - 'a';
				}
				appendable.append(c);
			}
		} else {
			appendable.append(str);
		}
	}
	
	private static int getFullRangeString(String wildcard, StringBuilder appendable) {
		if(appendable == null) {
			return wildcard.length();
		}
		appendable.append(wildcard);
		return 0;
	}
	
	protected int getPrefixAdjustedRangeString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		int leadingZeroCount = params.getLeadingZeros(segmentIndex);
		int radix = params.getRadix();
		int lowerLeadingZeroCount = adjustLowerLeadingZeroCount(leadingZeroCount, radix);
		int upperLeadingZeroCount = adjustUpperLeadingZeroCount(leadingZeroCount, radix);
		//if the wildcards match those in use by getString(), and there is no character prefix, let's defer to getString() so that it is cached
		Wildcards wildcards = params.getWildcards();
		String rangeSeparator = wildcards.rangeSeparator;
		int rangeDigitCount = wildcards.singleWildcard == null ? 0 : getRangeDigitCount(radix);
		
		//If we can, we reuse the standard string to construct this string (must have the same radix and no chopped digits)
		//We can insert leading zeros, string prefix, and a different separator string if necessary
		//Also, we cannot in the case of full range (in which case we are only here because we do not want '*')
		if(rangeDigitCount == 0 && radix == getDefaultTextualRadix() && !isFullRange()) {
			//we call getString() to cache the result, and we call getString instead of getWildcardString() because it will also mask with the segment prefix length
			String str = getString();
			String rangeSep = getDefaultRangeSeparatorString();
			String stringPrefix = params.getSegmentStrPrefix();
			int prefLen = stringPrefix.length();
			if(lowerLeadingZeroCount == 0 && upperLeadingZeroCount == 0 && rangeSep.equals(rangeSeparator) && prefLen == 0) {
				if(appendable == null) {
					return str.length();
				} else {
					if(params.isUppercase()) {
						appendUppercase(str, radix, appendable);
					} else {
						appendable.append(str);
					}
					return 0;
				}
			} else {
				if(appendable == null) {
					int count = str.length() + (rangeSeparator.length() - rangeSep.length()) +
							lowerLeadingZeroCount + upperLeadingZeroCount;
					if(prefLen > 0) {
						count += prefLen << 1;
					}
					return count;
				} else {
					int firstEnd = str.indexOf(rangeSep);
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					if(lowerLeadingZeroCount > 0) {
						getLeadingZeros(lowerLeadingZeroCount, appendable);
					}
					appendable.append(str.substring(0, firstEnd));
					appendable.append(rangeSeparator);
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					if(upperLeadingZeroCount > 0) {
						getLeadingZeros(upperLeadingZeroCount, appendable);
					}
					appendable.append(str.substring(firstEnd + rangeSep.length()));
					return 0;
				}
			}
		}
		rangeDigitCount = adjustRangeDigits(rangeDigitCount);
		if(leadingZeroCount < 0 && appendable == null) {
			int charLength = getMaxDigitCount(radix);
			String stringPrefix = params.getSegmentStrPrefix();
			int prefLen = stringPrefix.length();
			if(rangeDigitCount != 0) {
				int count = charLength;
				if(prefLen > 0) {
					count += prefLen;
				}
				return count;
			}
			int count = charLength << 1;
			if(prefLen > 0) {
				count += prefLen << 1;
			}
			count += rangeSeparator.length();
			return count;
		}
		if(rangeDigitCount != 0) {
			return getRangeDigitString(segmentIndex, params, appendable);
		}
		return getRangeString(segmentIndex, params, lowerLeadingZeroCount, upperLeadingZeroCount, true, appendable);
	}
	
	@Override
	public int getLowerStandardString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		int count = 0;
		String stringPrefix = params.getSegmentStrPrefix();
		int prefLen = stringPrefix.length();
		if(prefLen > 0) {
			if(appendable == null) {
				count += prefLen;
			} else {
				appendable.append(stringPrefix);
			}
		}
		int radix = params.getRadix();
		int leadingZeroCount = params.getLeadingZeros(segmentIndex);
		if(leadingZeroCount != 0) {
			if(appendable == null) {
				if(leadingZeroCount < 0) {
					return count + getMaxDigitCount(radix);
				} else {
					count += leadingZeroCount;
				}
			} else {
				leadingZeroCount = adjustLowerLeadingZeroCount(leadingZeroCount, radix);
				getLeadingZeros(leadingZeroCount, appendable);
			}
		}
		boolean uppercase = params.isUppercase();
		if(radix == getDefaultTextualRadix()) {
			String str = getCachedDefaultLowerString();
			if(appendable == null) {
				return count + str.length();
			} else if(uppercase) {
				appendUppercase(str, radix, appendable);
			} else {
				appendable.append(str);
			}
		} else {
			if(appendable == null) {
				return count + getLowerStringLength(radix);
			} else {
				getLowerString(radix, uppercase, appendable);
			}
		}
		return 0;
	}
	/**
	 * Produces a string to represent the segment, using wildcards and range characters.
	 * Use this instead of getWildcardString() if you have a customized wildcard or range separator or you have a non-zero leadingZeroCount,
	 * or you have a non-standard radix (for IPv4 standard radix is 10, for IPv6 it is 16)
	 * 
	 */
	@Override
	public int getStandardString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		if(!isMultiple()) {
			boolean splitDigits = params.isSplitDigits();
			if(splitDigits) {
				int radix = params.getRadix();
				int leadingZeroCount = params.getLeadingZeros(segmentIndex);
				leadingZeroCount = adjustLowerLeadingZeroCount(leadingZeroCount, radix);
				String stringPrefix = params.getSegmentStrPrefix();
				int prefLen = stringPrefix.length();
				if(appendable == null) {
					int len;
					if(leadingZeroCount != 0) {
						if(leadingZeroCount < 0) {
							len = getMaxDigitCount(radix);
						} else {
							len = getLowerStringLength(radix) + leadingZeroCount;
						}
					} else {
						len = getLowerStringLength(radix);
					}
					int count = (len << 1) - 1;
					if(prefLen > 0) {
						count += len * prefLen;
					}
					return count;
				} else {
					char splitDigitSeparator = params.getSplitDigitSeparator() == null ? 0 : params.getSplitDigitSeparator();
					boolean reverseSplitDigits = params.isReverseSplitDigits();
					boolean uppercase = params.isUppercase();
					if(reverseSplitDigits) {
						getSplitLowerString(radix, 0, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
						if(leadingZeroCount != 0) {
							appendable.append(splitDigitSeparator);
							getSplitLeadingZeros(leadingZeroCount, splitDigitSeparator, stringPrefix, appendable);
						}
					} else {
						if(leadingZeroCount != 0) {
							getSplitLeadingZeros(leadingZeroCount, splitDigitSeparator, stringPrefix, appendable);
							appendable.append(splitDigitSeparator);
						}
						getSplitLowerString(radix, 0, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
					}
					return 0;
				}
			}
			return getLowerStandardString(segmentIndex, params, appendable);
		}
		if(isFullRange()) {
			String wildcard = params.getWildcards().wildcard;
			if(wildcard != null) {
				if(wildcard.equals(getDefaultSegmentWildcardString())) {
					setDefaultAsFullRangeWildcardString();//cache
				}
				boolean splitDigits = params.isSplitDigits();
				if(splitDigits) {
					int radix = params.getRadix();
					if(appendable == null) {
						int len = getMaxDigitCount(radix);
						int count = len * (wildcard.length() + 1) - 1;
						return count;
					}
					char splitDigitSeparator = params.getSplitDigitSeparator() == null ? 0 : params.getSplitDigitSeparator();
					getSplitChar(getMaxDigitCount(radix), splitDigitSeparator, wildcard, "", appendable);
					return 0;
				}
				return getFullRangeString(wildcard, appendable);
			}
		}
		return getRangeString(segmentIndex, params, appendable);
	}
	
	protected int getRangeString(int segmentIndex, AddressSegmentParams params, StringBuilder appendable) {
		boolean splitDigits = params.isSplitDigits();
		int radix = params.getRadix();
		int leadingZeroCount = params.getLeadingZeros(segmentIndex);
		Wildcards wildcards = params.getWildcards();
		String rangeSeparator = wildcards.rangeSeparator;
		int rangeDigitCount = wildcards.singleWildcard == null ? 0 : getRangeDigitCount(radix);
		
		int lowerLeadingZeroCount = adjustLowerLeadingZeroCount(leadingZeroCount, radix);
		int upperLeadingZeroCount = adjustUpperLeadingZeroCount(leadingZeroCount, radix);
		//check the case where we can use the result of getWildcardString which is cached.
		//It must have same radix and no chopped digits, and no splitting or reversal of digits.
		//We can insert leading zeros, string prefix, and a different separator string if necessary.
		//Also, we cannot in the case of full range (in which case we are only here because we do not want '*')
		if(rangeDigitCount == 0 && 
				radix == getDefaultTextualRadix() && 
				!splitDigits &&
				!isFullRange()) {
			String str = getWildcardString();
			String rangeSep = getDefaultRangeSeparatorString();
			String stringPrefix = params.getSegmentStrPrefix();
			int prefLen = stringPrefix.length();
			if(lowerLeadingZeroCount == 0 && upperLeadingZeroCount == 0 &&
					prefLen == 0 &&
					rangeSeparator.equals(rangeSep)) {
				if(appendable == null) {
					return str.length();
				}
				appendable.append(str);
				return 0;
			} else {
				if(appendable == null) {
					int count = str.length() + (rangeSeparator.length() - rangeSep.length())  + lowerLeadingZeroCount + upperLeadingZeroCount;
					if(prefLen > 0) {
						count += prefLen << 1;
					}
					return count;
				} else {
					int firstEnd = str.indexOf(rangeSep);
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					if(lowerLeadingZeroCount > 0) {
						getLeadingZeros(lowerLeadingZeroCount, appendable);
					}
					appendable.append(str.substring(0, firstEnd));
					appendable.append(rangeSeparator);
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					if(upperLeadingZeroCount > 0) {
						getLeadingZeros(upperLeadingZeroCount, appendable);
					}
					appendable.append(str.substring(firstEnd + rangeSep.length()));
					return 0;
				}
			}
		}
		/*
		 split digits that result in digit ranges of * are similar to range digits range digits
		 eg f00-fff is both f__ and f.*.*
		 One difference is that for decimal last range digit is 0-5 (ie 255) but for split we only check full range (0-9)
		 eg 200-255 is 2__  but not 2.*.*
		 another difference: when calculating range digits, the count is 0 unless the entire range can be written as range digits
		 eg f10-fff has no range digits but is f.1-f.*
		 */
		if(!splitDigits && leadingZeroCount < 0 && appendable == null) {
			String stringPrefix = params.getSegmentStrPrefix();
			int prefLen = stringPrefix.length();
			int charLength = getMaxDigitCount(radix);
			if(rangeDigitCount != 0) {
				int count = charLength;
				if(prefLen > 0) {
					count += prefLen;
				}
				return count;
			}
			int count = charLength << 1;
			if(prefLen > 0) {
				count += prefLen << 1;
			}
			count += rangeSeparator.length();
			return count;
		}
		rangeDigitCount = adjustRangeDigits(rangeDigitCount);
		if(rangeDigitCount != 0) {
			if(splitDigits) {
				return getSplitRangeDigitString(segmentIndex, params, appendable);
			} else {
				return getRangeDigitString(segmentIndex, params, appendable);
			}
		}
		if(splitDigits) {
			return getSplitRangeString(segmentIndex, params, appendable);
		}
		return getRangeString(segmentIndex, params, lowerLeadingZeroCount, upperLeadingZeroCount, false, appendable);
	}
	
	protected int getSplitRangeDigitString(
			int segmentIndex,
			AddressSegmentParams params,
			StringBuilder appendable) {
		int radix = params.getRadix();
		int leadingZerosCount = params.getLeadingZeros(segmentIndex);
		leadingZerosCount = adjustLowerLeadingZeroCount(leadingZerosCount, radix);
		String stringPrefix = params.getSegmentStrPrefix();
		if(appendable == null) {
			int len = getLowerStringLength(radix) + leadingZerosCount;
			int count = (len << 1) - 1;
			int prefLen = stringPrefix.length();
			if(prefLen > 0) {
				count += len * prefLen;
			}
			return count;
		} else {
			Wildcards wildcards = params.getWildcards();
			int rangeDigits = adjustRangeDigits(getRangeDigitCount(radix));
			char splitDigitSeparator = params.getSplitDigitSeparator() == null ? 0 : params.getSplitDigitSeparator();
			boolean reverseSplitDigits = params.isReverseSplitDigits();
			boolean uppercase = params.isUppercase();
			if(reverseSplitDigits) {
				getSplitChar(rangeDigits, splitDigitSeparator, wildcards.singleWildcard, stringPrefix, appendable);
				appendable.append(splitDigitSeparator);
				getSplitLowerString(radix, rangeDigits, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
				if(leadingZerosCount > 0) {
					appendable.append(splitDigitSeparator);
					getSplitLeadingZeros(leadingZerosCount, splitDigitSeparator, stringPrefix, appendable);
				}
			} else {
				if(leadingZerosCount != 0) {
					getSplitLeadingZeros(leadingZerosCount, splitDigitSeparator, stringPrefix, appendable);
					appendable.append(splitDigitSeparator);
				}
				getSplitLowerString(radix, rangeDigits, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
				appendable.append(splitDigitSeparator);
				getSplitChar(rangeDigits, splitDigitSeparator, wildcards.singleWildcard, stringPrefix, appendable);
			}
		}
		return 0;
	}
	
	protected int getRangeDigitString(
			int segmentIndex,
			AddressSegmentParams params,
			StringBuilder appendable) {
		int radix = params.getRadix();
		int leadingZerosCount = params.getLeadingZeros(segmentIndex);
		leadingZerosCount = adjustLowerLeadingZeroCount(leadingZerosCount, radix);
		String stringPrefix = params.getSegmentStrPrefix();
		int prefLen = stringPrefix.length();
		Wildcards wildcards = params.getWildcards();
		int rangeDigits = adjustRangeDigits(getRangeDigitCount(radix));
		if(appendable == null) {
			return getLowerStringLength(radix) + leadingZerosCount + prefLen;
		} else {
			if(prefLen > 0) {
				appendable.append(stringPrefix);
			}
			if(leadingZerosCount > 0) {
				getLeadingZeros(leadingZerosCount, appendable);
			}
			boolean uppercase = params.isUppercase();
			getLowerString(radix, rangeDigits, uppercase, appendable);
			for(int i = 0; i < rangeDigits; i++) {
				appendable.append(wildcards.singleWildcard);
			}
		}
		return 0;
	}
	
	int adjustRangeDigits(int rangeDigits) {
		if(rangeDigits != 0) {
			//Note: ranges like ___ intended to represent 0-fff cannot work because the range does not include 2 digit and 1 digit numbers
			//This only happens when the lower value is 0 and there is more than 1 range digit
			//That's because you can then omit any leading zeros.
			//Ranges like f___ representing f000-ffff are fine.
			if(!includesZero() || rangeDigits == 1) { 
				return rangeDigits;
			}
		}
		return 0;
	}
	protected int getRangeString(
			int segmentIndex,
			AddressSegmentParams params,
			int lowerLeadingZerosCount,
			int upperLeadingZerosCount,
			boolean maskUpper,
			StringBuilder appendable) {
		String stringPrefix = params.getSegmentStrPrefix();
		int radix = params.getRadix();
		String rangeSeparator = params.getWildcards().rangeSeparator;
		boolean uppercase = params.isUppercase();
		return getRangeString(rangeSeparator, lowerLeadingZerosCount, upperLeadingZerosCount, stringPrefix, radix, uppercase, maskUpper, appendable);
	}
	
	protected int getRangeString(
			String rangeSeparator,
			int lowerLeadingZerosCount,
			int upperLeadingZerosCount,
			String stringPrefix,
			int radix,
			boolean uppercase,
			boolean maskUpper,
			StringBuilder appendable) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		int prefLen = stringPrefix.length();
		boolean hasStringPrefix = prefLen > 0;
		if(appendable == null) {
			int count = lowerLeadingZerosCount + upperLeadingZerosCount + 
					getLowerStringLength(radix) + getUpperStringLength(radix) + rangeSeparator.length();
			if(hasStringPrefix) {
				count += prefLen << 1;
			}
			return count;
		} else {
			if(hasStringPrefix) {
				appendable.append(stringPrefix);
			}
			if(lowerLeadingZerosCount > 0) {
				getLeadingZeros(lowerLeadingZerosCount, appendable);
			}
			getLowerString(radix, uppercase, appendable);
			appendable.append(rangeSeparator);
			if(hasStringPrefix) {
				appendable.append(stringPrefix);
			}
			if(upperLeadingZerosCount > 0) {
				getLeadingZeros(upperLeadingZerosCount, appendable);
			}
			if(maskUpper) {
				getUpperStringMasked(radix, uppercase, appendable);
			} else {
				getUpperString(radix, uppercase, appendable);
			}
		}
		return 0;
	}
	
	protected int getSplitRangeString(
			int segmentIndex,
			AddressSegmentParams params,
			StringBuilder appendable) {
		String stringPrefix = params.getSegmentStrPrefix();
		int radix = params.getRadix();
		int leadingZeroCount = params.getLeadingZeros(segmentIndex);
		//for split ranges, it is the leading zeros of the upper value that matters
		leadingZeroCount = adjustUpperLeadingZeroCount(leadingZeroCount, radix);
		Wildcards wildcards = params.getWildcards();
		boolean uppercase = params.isUppercase();
		char splitDigitSeparator = params.getSplitDigitSeparator() == null ? 0 : params.getSplitDigitSeparator();
		boolean reverseSplitDigits = params.isReverseSplitDigits();
		String rangeSeparator = wildcards.rangeSeparator;
		if(appendable == null) {
			return getSplitRangeStringLength(
					rangeSeparator,
					wildcards.wildcard,
					leadingZeroCount,
					radix,
					uppercase, 
					splitDigitSeparator,
					reverseSplitDigits,
					stringPrefix);
		} else {
			boolean hasLeadingZeros = leadingZeroCount != 0;
			if(hasLeadingZeros && !reverseSplitDigits) {
				getSplitLeadingZeros(leadingZeroCount, splitDigitSeparator, stringPrefix, appendable);
				appendable.append(splitDigitSeparator);
				hasLeadingZeros = false;
			}
			getSplitRangeString(
					rangeSeparator,
					wildcards.wildcard,
					radix,
					uppercase, 
					splitDigitSeparator,
					reverseSplitDigits,
					stringPrefix,
					appendable);
			if(hasLeadingZeros) {
				appendable.append(splitDigitSeparator);
				getSplitLeadingZeros(leadingZeroCount, splitDigitSeparator, stringPrefix, appendable);
			}
		}
		return 0;
	}
	@FunctionalInterface
	protected static interface SegmentCreator<R extends AddressSegment> {
		R applyAsInt(int low, int high);
	}
	@FunctionalInterface
	protected static interface IntBinaryIteratorProvider<R> {
		Iterator<R> applyAsInt(boolean isLowest, boolean isHighest, int low, int high);
	}
	protected static <T extends AddressSegment> AddressComponentSpliterator<T> createSegmentSpliterator(
			T splitForIteration,
			int value,
			int upperValue,
			Supplier<Iterator<T>> iteratorProvider,
			IntBinaryIteratorProvider<T> subIteratorProvider,
			SegmentCreator<T> itemProvider) {
		return new AddressSegmentSpliterator<T>(splitForIteration, value, upperValue, iteratorProvider, subIteratorProvider, itemProvider);
	}
	
	static boolean testRange(BigInteger lowerValue, BigInteger upperValue, BigInteger finalUpperValue, BigInteger networkMask, BigInteger hostMask) {
		return lowerValue.equals(lowerValue.and(networkMask)) && finalUpperValue.equals(upperValue.or(hostMask));
	}
	
	static boolean testRange(BigInteger lowerValue, BigInteger upperValue, BigInteger finalUpperValue, int bitCount, int divisionPrefixLen) {
		BigInteger networkMask = AddressDivisionGroupingBase.ALL_ONES.shiftLeft(bitCount - divisionPrefixLen);
		BigInteger hostMask = networkMask.not();
		return testRange(lowerValue, upperValue, finalUpperValue, networkMask, hostMask);
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.standard;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.BiFunction;
import java.util.function.BooleanSupplier;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.LongSupplier;
import java.util.function.Predicate;
import java.util.function.Supplier;
import inet.ipaddr.Address;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.AddressSegmentSeries;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.IPAddressSeqRange;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.NetworkMismatchException;
import inet.ipaddr.SizeMismatchException;
import inet.ipaddr.format.AddressDivisionBase;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.string.AddressStringDivisionSeries;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * AddressDivisionGrouping objects consist of a series of AddressDivision objects, each division containing one or more segments.
 * <p>
 * AddressDivisionGrouping objects are immutable.  This also makes them thread-safe.
 * <p>
 * AddressDivision objects use long to represent their values, so this places a cap on the size of the divisions in AddressDivisionGrouping.
 * <p>
 *  @author sfoley
 */
public class AddressDivisionGrouping extends AddressDivisionGroupingBase {
	private static final long serialVersionUID = 4L;
	
	public static interface DivisionValueProvider {
		long getValue(int segmentIndex);
	}
	
	public static interface DivisionLengthProvider {
		int getLength(int segmentIndex);
	}
	/* caches objects to avoid recomputing them */
	protected static class SectionCache<R extends AddressSegmentSeries> {
		public R lower;
		public R lowerNonZeroHost;
		public R upper;
		public boolean lowerNonZeroHostIsNull;
		public SectionCache() {}
	}
	
	/* the various string representations - these fields are for caching */
	protected static class StringCache {
		public String canonicalString;
		public String hexString;
		public String hexStringPrefixed;
	}
	public AddressDivisionGrouping(AddressDivision divisions[]) {
		super(divisions);
	}
	
	public AddressDivisionGrouping(AddressDivision divisions[], boolean checkDivisions) {
		super(divisions, checkDivisions);
	}
	
	@Override
	public AddressDivision getDivision(int index) {
		return (AddressDivision) super.getDivision(index);
	}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		byte bytes[] = new byte[(getBitCount() + 7) >> 3];
		int byteCount = bytes.length;
		int divCount = getDivisionCount();
		for(int k = divCount - 1, byteIndex = byteCount - 1, bitIndex = 8; k >= 0; k--) {
			AddressDivision div = getDivision(k);
			long segmentValue = low ? div.getDivisionValue() : div.getUpperDivisionValue();
			int divBits = div.getBitCount();
			//write out this entire segment
			while(divBits > 0) {
				bytes[byteIndex] |= segmentValue << (8 - bitIndex);
				segmentValue >>>= bitIndex;
				if(divBits < bitIndex) {
					bitIndex -= divBits;
					break;
				} else {
					divBits -= bitIndex;
					bitIndex = 8;
					byteIndex--;
				}
			}
		}
		return bytes;
	}
	protected static Integer cacheBits(int i) {
		return ParsedAddressGrouping.cache(i);
	}
	protected static <R extends AddressSection, S extends AddressSegment> boolean overlaps(R original, R other) {
		//check if they are comparable first
		int count = original.getSegmentCount();
		if(count != other.getSegmentCount()) {
			return false;
		}
		for(int i = count - 1; i >= 0; i--) {
			AddressSegment seg = original.getSegment(i);
			if(!seg.overlaps(other.getSegment(i))) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * Returns whether the values of this division grouping contain the prefix block for the given prefix length
	 * 
	 * @param prefixLength
	 * @return
	 */
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		checkSubnet(this, prefixLength);
		int divisionCount = getDivisionCount();
		int prevBitCount = 0;
		for(int i = 0; i < divisionCount; i++) {
			AddressDivision division = getDivision(i);
			int bitCount = division.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength < totalBitCount) {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!division.isPrefixBlock(division.getDivisionValue(), division.getUpperDivisionValue(), divPrefixLen)) {
					return false;
				}
				for(++i; i < divisionCount; i++) {
					division = getDivision(i);
					if(!division.isFullRange()) {
						return false;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	
	/**
	 * Returns whether the values of this division grouping match the prefix block for the given prefix length
	 * @param prefixLength
	 * @return
	 */
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		checkSubnet(this, prefixLength);
		int divisionCount = getDivisionCount();
		int prevBitCount = 0;
		for(int i = 0; i < divisionCount; i++) {
			AddressDivision division = getDivision(i);
			int bitCount = division.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLength >= totalBitCount) {
				if(division.isMultiple()) {
					return false;
				}
			} else {
				int divPrefixLen = Math.max(0, prefixLength - prevBitCount);
				if(!division.isSinglePrefixBlock(division.getDivisionValue(), division.getUpperDivisionValue(), divPrefixLen)) {
					return false;
				}
				for(++i; i < divisionCount; i++) {
					division = getDivision(i);
					if(!division.isFullRange()) {
						return false;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	
	@Override
	public int hashCode() {
		int res = hashCode;
		if(res == 0) {
			res = 1;
			int count = getDivisionCount();
			for(int i = 0; i < count; i++) {
				AddressDivision combo = getDivision(i);
				res = adjustHashCode(res, combo.getDivisionValue(), combo.getUpperDivisionValue());
			}
			hashCode = res;
		}
		return res;
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof AddressDivisionGrouping && super.isSameGrouping(other);
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof AddressDivisionGrouping) {
			AddressDivisionGrouping other = (AddressDivisionGrouping) o;
			// we call isSameGrouping on the other object to defer to subclasses IPv4 and IPv6 which check for type IPv4AddressSection and IPv6AddressSection
			return other.isSameGrouping(this);
		}
		return false;
	}
	
	protected static long getLongCount(IntUnaryOperator countProvider, int segCount) {
		if(segCount == 0) {
			// groupings with no divisions have the single value 0
			return 1;
		}
		long result = countProvider.applyAsInt(0);
		for(int i = 1; i < segCount; i++) {
			result *= countProvider.applyAsInt(i);
		}
		return result;
	}
	// note: only to be used when you already know the total size fits into a long, and you know that the count of each segment fits into an int
	protected static <R extends AddressSection, S extends AddressSegment> long longPrefixCount(R section, int prefixLength) {
		int bitsPerSegment = section.getBitsPerSegment();
		int bytesPerSegment = section.getBytesPerSegment();
		int networkSegmentIndex = getNetworkSegmentIndex(prefixLength, bytesPerSegment, bitsPerSegment);
		int hostSegmentIndex = getHostSegmentIndex(prefixLength, bytesPerSegment, bitsPerSegment);
		boolean hasPrefixedSegment = (networkSegmentIndex == hostSegmentIndex);
		return getLongCount(i -> {
			if(hasPrefixedSegment && i == networkSegmentIndex) {
				int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, i);
				return AddressDivision.getPrefixValueCount(section.getSegment(i), segmentPrefixLength);
			}
			AddressSegment segment = section.getSegment(i);
			int valueCount = (segment.getUpperSegmentValue() - segment.getSegmentValue()) + 1;
			return valueCount;
		}, networkSegmentIndex + 1);
	}
	// note: only to be used when you already know the total size fits into a long, and you know that the count of each segment fits into an int
	protected static <R extends AddressSection, S extends AddressSegment> long longCount(R section, int segCount) {
		long result = getLongCount(i -> {
			AddressSegment segment = section.getSegment(i);
			int valueCount = (segment.getUpperSegmentValue() - segment.getSegmentValue()) + 1;
			return valueCount;
		}, segCount);
		return result;
	}
	protected static Integer getPrefixedSegmentPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		return ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	
	protected static int getNetworkSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getNetworkSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	protected static int getHostSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	
	protected static Integer getSegmentPrefixLength(int bitsPerSegment, Integer prefixLength, int segmentIndex) {
		return ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	
	protected static Integer getSegmentPrefixLength(int segmentBits, int segmentPrefixedBits) {
		return ParsedAddressGrouping.getDivisionPrefixLength(segmentBits, segmentPrefixedBits);
	}
	
	protected static int getNetworkPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		return ParsedAddressGrouping.getNetworkPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
	}
	protected int getAdjustedPrefix(boolean nextSegment, int bitsPerSegment, boolean skipBitCountPrefix) {
		Integer prefix = getPrefixLength();
		int bitCount = getBitCount();
		if(nextSegment) {
			if(prefix == null) {
				if(getMinPrefixLengthForBlock() == 0) {
					return 0;
				}
				return bitCount;
			}
			if(prefix == bitCount) {
				return bitCount;
			}
			int existingPrefixLength = prefix.intValue();
			int adjustment = existingPrefixLength % bitsPerSegment;
			return existingPrefixLength + bitsPerSegment - adjustment;
		} else {
			if(prefix == null) {
				if(getMinPrefixLengthForBlock() == 0) {
					return 0;
				}
				if(skipBitCountPrefix) {
					prefix = bitCount;
				} else {
					return bitCount;
				}
			} else if(prefix == 0) {
				return 0;
			}
			int existingPrefixLength = prefix.intValue();
			int adjustment = ((existingPrefixLength - 1) % bitsPerSegment) + 1;
			return existingPrefixLength - adjustment;
		}
	}
	
	protected int getAdjustedPrefix(int adjustment, boolean floor, boolean ceiling) {
		Integer prefix = getPrefixLength();
		if(prefix == null) {
			if(getMinPrefixLengthForBlock() == 0) {
				prefix = cacheBits(0);
			} else {
				prefix = cacheBits(getBitCount());
			}
		}
		int result = prefix + adjustment;
		if(ceiling) {
			result = Math.min(getBitCount(), result);
		}
		if(floor) {
			result = Math.max(0, result);
		}
		return result;
	}
	
	/**
	 * In the case where the prefix sits at a segment boundary, and the prefix sequence is null - null - 0, 
	 * this changes to prefix sequence of null - x - 0, where x is segment bit length.
	 * 
	 * Note: We allow both [null, null, 0] and [null, x, 0] where x is segment length.  However, to avoid inconsistencies when doing segment replacements, 
	 * and when getting subsections, in the calling constructor we normalize [null, null, 0] to become [null, x, 0].
	 * We need to support [null, x, 0] so that we can create subsections and full addresses ending with [null, x] where x is bit length.
	 * So we defer to that when constructing addresses and sections.
	 * Also note that in our append/appendNetowrk/insert/replace we have special handling for cases like inserting [null] into [null, 8, 0] at index 2.
	 * The straight replace would give [null, 8, null, 0] which is wrong.
	 * In that code we end up with [null, null, 8, 0] by doing a special trick:
	 * We remove the end of [null, 8, 0] and do an append [null, 0] and we'd remove prefix from [null, 8] to get [null, null] and then we'd do another append to get [null, null, null, 0]
	 * The final step is this normalization here that gives [null, null, 8, 0]
	 * 
	 * However, when users construct AddressDivisionGrouping or IPAddressDivisionGrouping, either one is allowed: [null, null, 0] and [null, x, 0].  
	 * Since those objects cannot be further subdivided with getSection/getNetworkSection/getHostSection or grown with appended/inserted/replaced, 
	 * there are no inconsistencies introduced, we are simply more user-friendly.
	 * Also note that normalization of AddressDivisionGrouping or IPAddressDivisionGrouping is really not possible without the address creator objects we use for addresses and sections,
	 * that allow us to recreate new segments of the correct type.
	 * 
	 * @param sectionPrefixBits
	 * @param segments
	 * @param segmentBitCount
	 * @param segmentByteCount
	 * @param segProducer
	 */
	protected static <S extends IPAddressSegment> void normalizePrefixBoundary(
			int sectionPrefixBits,
			S segments[],
			int segmentBitCount,
			int segmentByteCount,
			Function<S, S> segProducer) {
		//we've already verified segment prefixes in super constructor.  We simply need to check the case where the prefix is at a segment boundary,
		//whether the network side has the correct prefix
		int networkSegmentIndex = getNetworkSegmentIndex(sectionPrefixBits, segmentByteCount, segmentBitCount);
		if(networkSegmentIndex >= 0) {
			S segment = segments[networkSegmentIndex];
			if(!segment.isPrefixed()) {
				segments[networkSegmentIndex] = segProducer.apply(segment);
			}
		}
	}
	protected static <S extends AddressSegment> S[] setPrefixedSegments(
			AddressNetwork<?> network,
			int sectionPrefixBits,
			S segments[],
			int segmentBitCount,
			int segmentByteCount,
			AddressSegmentCreator<S> segmentCreator,
			BiFunction<S, Integer, S> segProducer) {
		boolean allPrefsSubnet = network.getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		for(int i = (sectionPrefixBits == 0) ? 0 : getNetworkSegmentIndex(sectionPrefixBits, segmentByteCount, segmentBitCount); i < segments.length; i++) {
			Integer pref = getPrefixedSegmentPrefixLength(segmentBitCount, sectionPrefixBits, i);
			if(pref != null) {
				segments[i] = segProducer.apply(segments[i], pref);
				if(allPrefsSubnet) {
					if(++i < segments.length) {
						S allSeg = segmentCreator.createSegment(0, cacheBits(0));
						Arrays.fill(segments, i, segments.length, allSeg);
					}
				}
			}
		}
		return segments;
	}
	@FunctionalInterface
	protected interface SegPrefFunction<S> {
	    S apply(S s, Integer u, Integer v);
	}
	
	protected static <R extends AddressSection, S extends AddressSegment> S[] removePrefix(
			R original,
			S segments[],
			int segmentBitCount,
			SegPrefFunction<S> prefixSetter //this one takes both new and old prefix and both zeros out old pref and applies new one
			) {
		Integer oldPrefix = original.getPrefixLength();
		if(oldPrefix != null) {
			segments = segments.clone();
			int networkSegIndex = 0;
			if(oldPrefix > 0) {
				networkSegIndex = getNetworkSegmentIndex(oldPrefix, original.getBytesPerSegment(), segmentBitCount);
			}
			for(int i = networkSegIndex; i < segments.length; i++) {
				Integer oldPref = getPrefixedSegmentPrefixLength(segmentBitCount, oldPrefix, i);
				segments[i] = prefixSetter.apply(segments[i], oldPref, null);
			}
		}
		return segments;
	}
	protected static boolean prefixEquals(AddressSection first, AddressSection other, int otherIndex) {
		if(otherIndex < 0) {
			return false;
		}
		Integer prefixLength = first.getPrefixLength();
		int prefixedSection;
		if(prefixLength == null) {
			prefixedSection = first.getSegmentCount();
			int oIndex = prefixedSection + otherIndex;
			if(oIndex > other.getSegmentCount()) {
				return false;
			}
		} else {
			prefixedSection = getNetworkSegmentIndex(prefixLength, first.getBytesPerSegment(), first.getBitsPerSegment());
			if(prefixedSection >= 0) {
				int oIndex = prefixedSection + otherIndex;
				if(oIndex >= other.getSegmentCount()) {
					return false;
				}
				AddressSegment one = first.getSegment(prefixedSection);
				AddressSegment two = other.getSegment(oIndex);
				int segPrefixLength = getPrefixedSegmentPrefixLength(one.getBitCount(), prefixLength, prefixedSection);
				if(!one.prefixEquals(two, segPrefixLength)) {
					return false;
				}
			}
		}
		while(--prefixedSection >= 0) {
			AddressSegment one = first.getSegment(prefixedSection);
			AddressSegment two = other.getSegment(prefixedSection + otherIndex);
			if(!one.equals(two)) {
				return false;
			}
		}
		return true;
	}
	protected static <S extends AddressSegment> S[] createSegments(
			S segments[],
			long highBytes,
			long lowBytes,
			int bitsPerSegment,
			AddressNetwork<S> network,
			Integer prefixLength) {
		AddressSegmentCreator<S> creator = network.getAddressCreator();
		int segmentMask = ~(~0 << bitsPerSegment);
		int lowIndex = Math.max(0, segments.length - (Long.SIZE / bitsPerSegment));
		int segmentIndex = segments.length - 1;
		long bytes = lowBytes;
		while(true) {
			while(true) {
				Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
				int value = segmentMask & (int) bytes;
				S seg = creator.createSegment(value, segmentPrefixLength);
				if(!isCompatibleNetworks(network, seg.getNetwork())) {
					throw new NetworkMismatchException(seg);
				}
				segments[segmentIndex] = seg;
				if(--segmentIndex < lowIndex) {
					break;
				}
				bytes >>>= bitsPerSegment;
			}
			if(lowIndex == 0) {
				break;
			}
			lowIndex = 0;
			bytes = highBytes;
		}
		return segments;
	}
	protected static boolean isCompatibleNetworks(AddressNetwork<?> one, AddressNetwork<?> two) {
		return one.getPrefixConfiguration().equals(two.getPrefixConfiguration());
	}
	protected static <S extends AddressSegment> S[] createSegments(
			S segments[],
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			int bytesPerSegment,
			int bitsPerSegment,
			AddressNetwork<S> network,
			Integer prefixLength) {
		AddressSegmentCreator<S> creator = network.getAddressCreator();
		int segmentCount = segments.length;
		for(int segmentIndex = 0; segmentIndex < segmentCount; segmentIndex++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
			if(segmentPrefixLength != null && segmentPrefixLength == 0 && network.getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				S allSeg = creator.createSegment(0, cacheBits(0));
				if(!isCompatibleNetworks(network, allSeg.getNetwork())) {
					throw new NetworkMismatchException(allSeg);
				}
				Arrays.fill(segments, segmentIndex, segmentCount, allSeg);
				break;
			}
			
			int value = 0, value2 = 0;
			if(lowerValueProvider == null) {
				value = upperValueProvider.getValue(segmentIndex);
			} else {
				value = lowerValueProvider.getValue(segmentIndex);
				if(upperValueProvider != null) {
					value2 = upperValueProvider.getValue(segmentIndex);
				}
			}
			S seg = (lowerValueProvider != null && upperValueProvider != null) ? 
					creator.createSegment(value, value2, segmentPrefixLength) : 
						creator.createSegment(value, segmentPrefixLength);
			if(!isCompatibleNetworks(network, seg.getNetwork())) {
				throw new NetworkMismatchException(seg);
			}
			segments[segmentIndex] = seg;
		}
		return segments;
	}
	protected static <S extends AddressSegment> S[] toSegments(
			S segments[],
			byte bytes[],
			int startIndex,
			int endIndex,
			int bytesPerSegment,
			int bitsPerSegment,
			AddressNetwork<S> network,
			Integer prefixLength) {
		if(endIndex < 0 || endIndex > bytes.length) {
			throw new AddressValueException(endIndex);
		}
		if(startIndex < 0 || startIndex > endIndex) {
			throw new AddressValueException(startIndex);
		}
		AddressSegmentCreator<S> creator = network.getAddressCreator();
		int segmentCount = segments.length;
		int expectedByteCount = segmentCount * bytesPerSegment;
		
		//We allow two formats of bytes:
		//1. two's complement: top bit indicates sign.  Ranging over all 16-byte lengths gives all addresses, from both positive and negative numbers
		//  Also, we allow sign extension to shorter and longer byte lengths.  For example, -1, -1, -2 is the same as just -2.  So if this were IPv4, we allow -1, -1, -1, -1, -2 and we allow -2.
		//  This is compatible with BigInteger.  If we have a positive number like 2, we allow 0, 0, 0, 0, 2 and we allow just 2.  
		//  But the top bit must be 0 for 0-sign extension. So if we have 255 as a positive number, we allow 0, 255 but not 255.  
		//  Just 255 is considered negative and equivalent to -1, and extends to -1, -1, -1, -1 or the address 255.255.255.255, not 0.0.0.255
		//
		//2. Unsigned values
		//  We interpret 0, -1, -1, -1, -1 as 255.255.255.255 even though this is not a sign extension of -1, -1, -1, -1.
		//  In this case, we also allow any 4 byte value to be considered a positive unsigned number, and thus we always allow leading zeros.
		//  In the case of extending byte array values that are shorter than the required length, 
		//  unsigned values must have a leading zero in cases where the top bit is 1, because the two's complement format takes precedence.
		//  So the single value 255 must have an additional 0 byte in front to be considered unsigned, as previously shown.
		//  The single value 255 is considered -1 and is extended to become the address 255.255.255.255, 
		//  but for the unsigned positive value 255 you must use the two bytes 0, 255 which become the address 0.0.0.255.
		//  Once again, this is compatible with BigInteger.
		
		int missingBytes = expectedByteCount + startIndex - endIndex;
		
		//First we handle the situation where we have too many bytes.  Extra bytes can be all zero-bits, or they can be the negative sign extension of all one-bits.
		if(missingBytes < 0) {
			int expectedStartIndex = endIndex - expectedByteCount;
			int higherStartIndex = expectedStartIndex - 1;
			byte expectedExtendedValue = bytes[higherStartIndex];
			if(expectedExtendedValue != 0) {
				int mostSignificantBit = bytes[expectedStartIndex] >>> 7;
				if(mostSignificantBit != 0) {
					if(expectedExtendedValue != -1) {//0xff
						throw new AddressValueException(expectedExtendedValue);
					}
				} else {
					throw new AddressValueException(expectedExtendedValue);
				}
			}
			while(startIndex < higherStartIndex) {
				if(bytes[--higherStartIndex] != expectedExtendedValue) {
					throw new AddressValueException(expectedExtendedValue);
				}
			}
			startIndex = expectedStartIndex;
			missingBytes = 0;
		}
		boolean allPrefixedAddressesAreSubnets = network.getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		for(int i = 0, segmentIndex = 0; i < expectedByteCount; segmentIndex++) {
			Integer segmentPrefixLength = getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
			if(allPrefixedAddressesAreSubnets && segmentPrefixLength != null && segmentPrefixLength == 0) {
				S allSeg = creator.createSegment(0, cacheBits(0));
				if(!isCompatibleNetworks(network, allSeg.getNetwork())) {
					throw new NetworkMismatchException(allSeg);
				}
				Arrays.fill(segments, segmentIndex, segmentCount, allSeg);
				break;
			}
			int value = 0;
			int k = bytesPerSegment + i;
			int j = i;
			if(j < missingBytes) {
				int mostSignificantBit = bytes[startIndex] >>> 7;
				if(mostSignificantBit == 0) {//sign extension
					j = missingBytes;
				} else {//sign extension
					int upper = Math.min(missingBytes, k);
					for(; j < upper; j++) {
						value <<= 8;
						value |= 0xff;
					}
				}
			}
			for(; j < k; j++) {
				int byteValue = 0xff & bytes[startIndex + j - missingBytes];
				value <<= 8;
				value |= byteValue;
			}
			i = k;
			
			S seg = creator.createSegment(value, segmentPrefixLength);
			if(!isCompatibleNetworks(network, seg.getNetwork())) {
				throw new NetworkMismatchException(seg);
			}
			segments[segmentIndex] = seg;
		}
		return segments;
	}
	protected static <R extends AddressSection, S extends AddressSegment> S[] createSingle(
			R original,
			AddressSegmentCreator<S> segmentCreator,
			IntFunction<S> segProducer) {
		int segmentCount = original.getSegmentCount();
		S segs[] = segmentCreator.createSegmentArray(segmentCount);
		for(int i = 0; i < segmentCount; i++) {
			segs[i] = segProducer.apply(i);
		}
		return segs;
	}
	protected static <R extends AddressSegmentSeries> R getSingleLowestOrHighestSection(R section) {
		if(!section.isMultiple() && !(section.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets())) {
			return section;
		}
		return null;
	}
	protected static <R extends AddressSection, S extends AddressSegment> R reverseSegments(R section, AddressCreator<?, R, ?, S> creator, IntFunction<S> segProducer, boolean removePrefix) {
		int count = section.getSegmentCount();
		S newSegs[] = creator.createSegmentArray(count);
		int halfCount = count >>> 1;
		int i = 0;
		boolean isSame = !removePrefix || !section.isPrefixed();//when reversing, the prefix must go
		for(int j = count - 1; i < halfCount; i++, j--) {
			newSegs[j] = segProducer.apply(i);
			newSegs[i] = segProducer.apply(j);
			if(isSame && !(newSegs[i].equals(section.getSegment(i)) && newSegs[j].equals(section.getSegment(j)))) {
				isSame = false;
			}
		}
		if((count & 1) == 1) {//the count is odd, handle the middle one
			newSegs[i] = segProducer.apply(i);
			if(isSame && !newSegs[i].equals(section.getSegment(i))) {
				isSame = false;
			}
		}
		if(isSame) {
			return section;//We can do this because for ipv6 startIndex stays the same and for mac startIndex and extended stays the same
		}
		return creator.createSectionInternal(newSegs);
	}
	
	protected static <R extends AddressSection, S extends AddressSegment> R reverseBits(
			boolean perByte, R section, AddressCreator<?, R, ?, S> creator, IntFunction<S> segBitReverser, boolean removePrefix) {
		if(perByte) {
			boolean isSame = !removePrefix || !section.isPrefixed();//when reversing, the prefix must go
			int count = section.getSegmentCount();
			S newSegs[] = creator.createSegmentArray(count);
			for(int i = 0; i < count; i++) {
				newSegs[i] = segBitReverser.apply(i);
				if(isSame && !newSegs[i].equals(section.getSegment(i))) {
					isSame = false;
				}
			}
			if(isSame) {
				return section;//We can do this because for ipv6 startIndex stays the same and for mac startIndex and extended stays the same
			}
			return creator.createSectionInternal(newSegs);
		}
		return reverseSegments(section, creator, segBitReverser, removePrefix);
	}
	
	protected static <R extends AddressSection, S extends AddressSegment> R reverseBytes(
			boolean perSegment, R section, AddressCreator<?, R, ?, S> creator, IntFunction<S> segByteReverser, boolean removePrefix) {
		if(perSegment) {
			boolean isSame = !removePrefix || !section.isPrefixed();//when reversing, the prefix must go
			int count = section.getSegmentCount();
			S newSegs[] = creator.createSegmentArray(count);
			for(int i = 0; i < count; i++) {
				newSegs[i] = segByteReverser.apply(i);
				if(isSame && !newSegs[i].equals(section.getSegment(i))) {
					isSame = false;
				}
			}
			if(isSame) {
				return section;//We can do this because for ipv6 startIndex stays the same and for mac startIndex and extended stays the same
			}
			return creator.createSectionInternal(newSegs);
		}
		return reverseSegments(section, creator, segByteReverser, removePrefix);
	}
	protected static interface GroupingCreator<S extends AddressDivisionBase> {
		S createDivision(long value, long upperValue, int bitCount, int radix);
	}
	
	protected <S extends AddressDivisionBase> S[] createNewDivisions(int bitsPerDigit, GroupingCreator<S> groupingCreator, IntFunction<S[]> groupingArrayCreator) {
		return createNewPrefixedDivisions(bitsPerDigit, null, null,
				(value, upperValue, bitCount, radix, network, prefixLength) -> groupingCreator.createDivision(value, upperValue, bitCount, radix),
				groupingArrayCreator);
	}
	
	protected static interface PrefixedGroupingCreator<S extends AddressDivisionBase> {
		S createDivision(long value, long upperValue, int bitCount, int radix, IPAddressNetwork<?, ?, ?, ?, ?> network, Integer prefixLength);
	}
	
	/**
	 * 
	 * @param bitsPerDigit
	 * @param network can be null if networkPrefixLength is null
	 * @param networkPrefixLength
	 * @param groupingCreator
	 * @param groupingArrayCreator
	 * @throws AddressValueException if bitsPerDigit is larger than 32
	 * @return
	 */
	protected <S extends AddressDivisionBase> S[] createNewPrefixedDivisions(int bitsPerDigit, IPAddressNetwork<?, ?, ?, ?, ?> network, Integer networkPrefixLength, PrefixedGroupingCreator<S> groupingCreator, IntFunction<S[]> groupingArrayCreator) {
		if(bitsPerDigit >= Integer.SIZE) {
			//keep in mind once you hit 5 bits per digit, radix 32, you need 32 different digits, and there are only 26 alphabet characters and 10 digit chars, so 36
			//so once you get higher than that, you need a new character set.
			//AddressLargeDivision allows all the way up to base 85
			throw new AddressValueException(bitsPerDigit);
		}
		int bitCount = getBitCount();
		List<Integer> bitDivs = new ArrayList<Integer>(bitsPerDigit);
		//ipv6 octal:
		//seg bit counts: 63, 63, 2
		//ipv4 octal:
		//seg bit counts: 30, 2
		int largestBitCount = Long.SIZE - 1;
		largestBitCount -= largestBitCount % bitsPerDigit;
		do {
			if(bitCount <= largestBitCount) {
				int mod = bitCount % bitsPerDigit;
				int secondLast = bitCount - mod;
				if(secondLast > 0) {
					bitDivs.add(cacheBits(secondLast));
				}
				if(mod > 0) {
					bitDivs.add(cacheBits(mod));
				}
				break;
			} else {
				bitCount -= largestBitCount;
				bitDivs.add(cacheBits(largestBitCount));
			}
		} while(true);
		int bitDivSize = bitDivs.size();
		S divs[] = groupingArrayCreator.apply(bitDivSize);
		int currentSegmentIndex = 0;
		AddressDivision seg = getDivision(currentSegmentIndex);
		long segLowerVal = seg.getDivisionValue();
		long segUpperVal = seg.getUpperDivisionValue();
		int segBits = seg.getBitCount();
		int bitsSoFar = 0;
		int radix = AddressDivision.getRadixPower(BigInteger.valueOf(2), bitsPerDigit).intValue();
		//fill up our new divisions, one by one
		for(int i = bitDivSize - 1; i >= 0; i--) {
			int originalDivBitSize, divBitSize;
			originalDivBitSize = divBitSize = bitDivs.get(i);
			long divLowerValue, divUpperValue;
			divLowerValue = divUpperValue = 0;
			while(true) {
				if(segBits >= divBitSize) {
					int diff = segBits - divBitSize;
					divLowerValue |= segLowerVal >>> diff;
					long shift = ~(~0L << diff);
					segLowerVal &= shift;
					divUpperValue |= segUpperVal >>> diff;
					segUpperVal &= shift;
					segBits = diff;
					Integer segPrefixBits = networkPrefixLength == null ? null : getSegmentPrefixLength(originalDivBitSize, networkPrefixLength - bitsSoFar);
					S div = groupingCreator.createDivision(divLowerValue, divUpperValue, originalDivBitSize, radix, network, segPrefixBits);
					divs[bitDivSize - i - 1] = div;
					if(segBits == 0 && i > 0) {
						//get next seg
						seg = getDivision(++currentSegmentIndex);
						segLowerVal = seg.getDivisionValue();
						segUpperVal = seg.getUpperDivisionValue();
						segBits = seg.getBitCount();
					}
					break;
				} else {
					int diff = divBitSize - segBits;
					divLowerValue |= segLowerVal << diff;
					divUpperValue |= segUpperVal << diff;
					divBitSize = diff;
					
					//get next seg
					seg = getDivision(++currentSegmentIndex);
					segLowerVal = seg.getDivisionValue();
					segUpperVal = seg.getUpperDivisionValue();
					segBits = seg.getBitCount();
				}
			}
			bitsSoFar += originalDivBitSize;
		}
		return divs;
	}
	/**
	 * Splits a subnet into two
	 * <p>
	 * Returns false if it cannot be done
	 * 
	 * @param beingSplit
	 * @param transformer
	 * @param segmentCreator
	 * @param originalSegments
	 * @param networkSegmentIndex if this index matches hostSegmentIndex, splitting will attempt to split the network part of this segment
	 * @param hostSegmentIndex splitting will work with the segments prior to this one
	 * @param prefixLength
	 * @return
	 */
	protected static <I extends AddressSegmentSeries, S extends AddressSegment> boolean split(
			SplitterSink<I, ?> beingSplit,
			Function<S[], I> transformer,
			AddressSegmentCreator<S> segmentCreator,
			S originalSegments[],
			int networkSegmentIndex, //for regular iterators (not prefix block), networkSegmentIndex is last segment (count - 1) - it is only instrumental with prefix iterators
			int hostSegmentIndex, // for regular iterators hostSegmentIndex is past last segment (count) - it is only instrumental with prefix iterators
			Integer prefixLength) {
		int i = 0;
		S lowerSeg, upperSeg;
		lowerSeg = upperSeg = null;
		boolean isSplit = false;
		for(; i < hostSegmentIndex; i++) {
			S seg = originalSegments[i];
			// if segment multiple, split into two
			if(seg.isMultiple()) {
				isSplit = true;
				int lower = seg.getSegmentValue();
				int upper = seg.getUpperSegmentValue();
				int size = upper - lower;
				int mid = lower + (size >>> 1);
				Integer pref = getSegmentPrefixLength(seg.getBitCount(), prefixLength, i);
				lowerSeg = segmentCreator.createSegment(lower, mid, pref);
				upperSeg = segmentCreator.createSegment(mid + 1, upper, pref);
				break;
			}
		}
		if(i == networkSegmentIndex && !isSplit) {
			// prefix or prefix block iterators: no need to differentiate, handle both as prefix, iteration will handle the rest
			S seg = originalSegments[i];
			int segBitCount = seg.getBitCount();
			Integer pref = getSegmentPrefixLength(segBitCount, prefixLength, i);
			int shiftAdjustment = segBitCount - pref;
			int lower = seg.getSegmentValue();
			int upper = seg.getUpperSegmentValue();
			int originalLower = lower, originalUpper = upper;
			lower >>>= shiftAdjustment;
			upper >>>= shiftAdjustment;
			if(lower != upper) {
				isSplit = true;
				int size = upper - lower;
				int mid = lower + (size >>> 1);
				int next = mid + 1;
				mid = (mid << shiftAdjustment) | ~(~0 << shiftAdjustment);
				next <<= shiftAdjustment;
				lowerSeg = segmentCreator.createSegment(originalLower, mid, pref);
				upperSeg = segmentCreator.createSegment(next, originalUpper, pref);
			}
		}
		if(isSplit) {
			int len = originalSegments.length;
			S lowerSegs[] = segmentCreator.createSegmentArray(len);
			S upperSegs[] = segmentCreator.createSegmentArray(len);
			System.arraycopy(originalSegments, 0, lowerSegs, 0, i);
			System.arraycopy(originalSegments, 0, upperSegs, 0, i);
			int j = i + 1;
			lowerSegs[i] = lowerSeg;
			upperSegs[i] = upperSeg;
			System.arraycopy(originalSegments, j, lowerSegs, j, len - j);
			System.arraycopy(originalSegments, j, upperSegs, j, len - j);
			beingSplit.setSplitValues(transformer.apply(lowerSegs), transformer.apply(upperSegs));
		}
		return isSplit;
	}
	
	protected static <R extends AddressSection, S extends AddressSegment> Iterator<R> iterator(
			boolean useOriginal,
			R original,
			AddressCreator<?, R, ?, S> creator,
			Iterator<S[]> iterator,
			Integer prefixLength) {
		if(useOriginal) {
			return new Iterator<R>() {
				R orig = original;
				@Override
				public R next() {
					if(orig == null) {
			    		throw new NoSuchElementException();
			    	}
					R result = orig;
			    	orig = null;
				    return result;
			    }
				@Override
				public boolean hasNext() {
					return orig != null;
				}
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		return new Iterator<R>() {
			@Override
			public R next() {
				if(!iterator.hasNext()) {
		    		throw new NoSuchElementException();
		    	}
				S next[] = iterator.next();
				return createIteratedSection(next, creator, prefixLength);
			}
			@Override
			public boolean hasNext() {
				return iterator.hasNext();
			}
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	
	protected static <T extends Address, S extends AddressSegment> T createIteratedAddress(
			S next[],
			AddressCreator<T, ?, ?, S> creator,
			Integer prefixLength) {
		return creator.createAddressInternal(next, prefixLength, true);
	}
	protected static <R extends AddressSection, S extends AddressSegment> R createIteratedSection(
			S next[],
			AddressCreator<?, R, ?, S> creator,
			Integer prefixLength) {
		return creator.createPrefixedSectionInternal(next, prefixLength, true);
	}
	
	// this iterator function used by addresses and segment arrays, for iterators that are not prefix or prefix block iterators
	protected static <S extends AddressSegment> Iterator<S[]> segmentsIterator(
			int divCount,
			AddressSegmentCreator<S> segmentCreator,
			Supplier<S[]> segSupplier,
			IntFunction<Iterator<S>> segIteratorProducer,
			Predicate<S[]> excludeFunc) {
		return segmentsIterator(divCount, segmentCreator, segSupplier, segIteratorProducer, excludeFunc, divCount - 1, divCount, null);
	}
	/**
	 * Used to produce regular iterators with or without zero-host values, and prefix block iterators
	 * @param segmentCreator
	 * @param segSupplier
	 * @param segIteratorProducer
	 * @param excludeFunc
	 * @param networkSegmentIndex
	 * @param hostSegmentIndex
	 * @param hostSegIteratorProducer used to produce prefix iterators for the prefix and prefix block iterators, or identity iterators for the block iterators that only iterate through top segments
	 * @return
	 */
	protected static <S extends AddressSegment> Iterator<S[]> segmentsIterator(
			int divCount,
			AddressSegmentCreator<S> segmentCreator,
			Supplier<S[]> segSupplier,//provides the original segments in an array for a single valued iterator
			IntFunction<Iterator<S>> segIteratorProducer,
			Predicate<S[]> excludeFunc,
			int networkSegmentIndex,
			int hostSegmentIndex,
			IntFunction<Iterator<S>> hostSegIteratorProducer) {
		if(segSupplier != null) {
			return new Iterator<S[]>() {
				S result[] = segSupplier.get(); {
					if(excludeFunc != null && excludeFunc.test(result)) {
						result = null;
					}
				}
				
				@Override
				public boolean hasNext() {
					return result != null;
				}
			    @Override
				public S[] next() {
			    	if(result == null) {
			    		throw new NoSuchElementException();
			    	}
			    	S res[] = result;
			    	result = null;
			    	return res;
			    }
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		
		return new Iterator<S[]>() {
			private boolean done;
				
			@SuppressWarnings("unchecked")
			private final Iterator<S> variations[] = new Iterator[divCount];
			
			private S nextSet[] = segmentCreator.createSegmentArray(divCount);  {
				updateVariations(0);
				for(int i = networkSegmentIndex + 1; i < divCount; i++) {//for regular iterators (not prefix block), networkSegmentIndex is last segment (count - 1)
					variations[i] = hostSegIteratorProducer.apply(i);
					nextSet[i] = variations[i].next();
				}
				if(excludeFunc != null && excludeFunc.test(nextSet)) {
					increment();
				}
			}
			
			private void updateVariations(int start) {
				int i = start;
				for(; i < hostSegmentIndex; i++) {
					variations[i] = segIteratorProducer.apply(i);
					nextSet[i] = variations[i].next();
				}
				if(i == networkSegmentIndex) {
					variations[i] = hostSegIteratorProducer.apply(i);
					nextSet[i] = variations[i].next();
				}
			}
			
			@Override
			public boolean hasNext() {
				return !done;
			}
			
		    @Override
			public S[] next() {
		    	if(done) {
		    		throw new NoSuchElementException();
		    	}
		    	return increment();
		    }
		    
		    private S[] increment() {
		    	S previousSegs[] = null;
		    	for(int j = networkSegmentIndex; j >= 0; j--) {//for regular iterators (not prefix block), networkSegmentIndex is last segment (count - 1)
		    		while(variations[j].hasNext()) {
		    			if(previousSegs == null) {
		    				previousSegs = nextSet.clone();
		    			}
		    			nextSet[j] = variations[j].next();
		    			updateVariations(j + 1);
		    			if(excludeFunc != null && excludeFunc.test(nextSet)) {
		    				j = networkSegmentIndex;
						} else {
							return previousSegs;
						}
		    		}
		    	}
		    	done = true;
		    	return previousSegs == null ? nextSet : previousSegs;
		    }
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	protected static <T extends Address, S extends AddressSegment> Iterator<T> iterator(
			boolean useOriginal,
			T original,
			AddressCreator<T, ?, ?, S> creator,
			Iterator<S[]> iterator, /* unused if original not null */
			Integer prefixLength /* if the segments themselves do not have associated prefix length, one can be supplied here */) {
		if(useOriginal) {
			return new Iterator<T>() {
				T orig = original;
				@Override
				public boolean hasNext() {
					return orig != null;
				}
			    @Override
				public T next() {
			    	if(orig == null) {
			    		throw new NoSuchElementException();
			    	}
			    	T result = orig;
			    	orig = null;
			    	return result;
			    }
			
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		return new Iterator<T>() {
			@Override
			public boolean hasNext() {
				return iterator.hasNext();
			}
		
		    @Override
			public T next() {
		    	if(!hasNext()) {
		    		throw new NoSuchElementException();
		    	}
		    	S[] next = iterator.next();
		    	return createIteratedAddress(next, creator, prefixLength);
		    }
		
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	
	protected static void checkOverflow(
			long increment,
			LongSupplier lower,
			LongSupplier upper,
			LongSupplier counter,
			BooleanSupplier isSequential,
			LongSupplier maxValue) {
		if(increment < 0) {
			if(lower.getAsLong() < -increment) {
				throw new AddressValueException(increment);
			}
		} else if(isSequential.getAsBoolean()) {
			if(increment > maxValue.getAsLong() - lower.getAsLong()) {
				throw new AddressValueException(increment);
			}
		} else {
			long count = counter.getAsLong();
			if(increment >= count && increment - (count - 1) > maxValue.getAsLong() - upper.getAsLong()) {
				throw new AddressValueException(increment);
			}
		}
	}
	
	protected static void checkOverflow(
			long increment,
			BigInteger bigIncrement,
			Supplier<BigInteger> lower,
			Supplier<BigInteger> upper,
			Supplier<BigInteger> counter,
			BooleanSupplier isSequential,
			Supplier<BigInteger> maxValue) {
		checkOverflow(increment < 0, bigIncrement, lower, upper, counter, isSequential, maxValue);
	}
	
	protected static void checkOverflow(
			BigInteger bigIncrement,
			Supplier<BigInteger> lower,
			Supplier<BigInteger> upper,
			Supplier<BigInteger> counter,
			BooleanSupplier isSequential,
			Supplier<BigInteger> maxValue) {
		checkOverflow(bigIncrement.signum() < 0, bigIncrement, lower, upper, counter, isSequential, maxValue);
	}
	
	private static void checkOverflow(
			boolean incrementIsNegative,
			BigInteger bigIncrement,
			Supplier<BigInteger> lower,
			Supplier<BigInteger> upper,
			Supplier<BigInteger> counter,
			BooleanSupplier isSequential,
			Supplier<BigInteger> maxValue) {
		if(incrementIsNegative) {
			if(lower.get().compareTo(bigIncrement.negate()) < 0) {
				throw new AddressValueException(bigIncrement);
			}
		} else if(isSequential.getAsBoolean()) {
			if(bigIncrement.compareTo(maxValue.get().subtract(lower.get())) > 0) {
				throw new AddressValueException(bigIncrement);
			}
		} else {
			BigInteger count = counter.get();
			if(bigIncrement.compareTo(count) >= 0 && bigIncrement.subtract(count.subtract(BigInteger.ONE)).compareTo(maxValue.get().subtract(upper.get())) > 0) {
				throw new AddressValueException(bigIncrement);
			}
		}
	}
	
	/**
	 * Handles the cases in which we can use longs rather than BigInteger
	 * 
	 * @param section
	 * @param increment
	 * @param addrCreator
	 * @param lowerProducer
	 * @param upperProducer
	 * @param prefixLength
	 * @return
	 */
	protected static <R extends AddressSection, S extends AddressSegment> R fastIncrement(
			R section,
			long increment,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(increment >= 0) {
			BigInteger count = section.getCount();
			if(count.compareTo(LONG_MAX) <= 0) {
				long longCount = count.longValue();
				if(longCount > increment) {
					if(longCount == increment + 1) {
						return upperProducer.get();
					}
					return incrementRange(section, increment, addrCreator, lowerProducer, prefixLength);
				}
				BigInteger upperValue = section.getUpperValue();
				if(upperValue.compareTo(LONG_MAX) <= 0) {
					return increment(
							section,
							increment,
							addrCreator,
							count::longValue,
							() -> section.getValue().longValue(),
							upperValue::longValue,
							lowerProducer,
							upperProducer,
							prefixLength);
				}
			}
		} else {
			BigInteger value = section.getValue();
			if(value.compareTo(LONG_MAX) <= 0) {
				return add(lowerProducer.get(), value.longValue(), increment, addrCreator, prefixLength);
			}
		}
		return null;
	}
	//this does not handle overflow, overflow should be checked before calling this
	protected static <R extends AddressSection, S extends AddressSegment> R increment(
			R section,
			long increment,
			AddressCreator<?, R, ?, S> addrCreator, 
			LongSupplier counter,
			LongSupplier lower,
			LongSupplier upper,
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(!section.isMultiple()) {
			return add(section, lower.getAsLong(), increment, addrCreator, prefixLength);
		}
		boolean isDecrement = increment <= 0;
		if(isDecrement) {
			//we know lowerValue + increment >= 0 because we already did an overflow check
			return add(lowerProducer.get(), lower.getAsLong(), increment, addrCreator, prefixLength);
		} 
		long count = counter.getAsLong();
		if(count > increment) {
			if(count == increment + 1) {
				return upperProducer.get();
			}
			return incrementRange(section, increment, addrCreator, lowerProducer, prefixLength);
		}
		long upperValue = upper.getAsLong();
		if(increment <= Long.MAX_VALUE - upperValue) {
			return add(upperProducer.get(), upperValue, increment - (count - 1), addrCreator, prefixLength);
		}
		return add(upperProducer.get(), BigInteger.valueOf(increment - (count - 1)), addrCreator, prefixLength);
	}
	//this does not handle overflow, overflow should be checked before calling this
	protected static <R extends AddressSection, S extends AddressSegment> R increment(
			R section,
			long increment,
			BigInteger bigIncrement,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(!section.isMultiple()) {
			return add(section, bigIncrement, addrCreator, prefixLength);
		}
		boolean isDecrement = increment <= 0;
		if(isDecrement) {
			return add(lowerProducer.get(), bigIncrement, addrCreator, prefixLength);
		}
		BigInteger count = section.getCount();
		BigInteger incrementPlus1 = bigIncrement.add(BigInteger.ONE);
		int countCompare = count.compareTo(incrementPlus1);
		if(countCompare <= 0) {
			if(countCompare == 0) {
				return upperProducer.get();
			}
			return add(upperProducer.get(), incrementPlus1.subtract(count), addrCreator, prefixLength);
		}
		return incrementRange(section, increment, addrCreator, lowerProducer, prefixLength);
	}
	
	//this does not handle overflow, overflow should be checked before calling this
	protected static <R extends AddressSection, S extends AddressSegment> R increment(
			R section,
			BigInteger bigIncrement,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Supplier<R> upperProducer,
			Integer prefixLength) {
		if(!section.isMultiple()) {
			return add(section, bigIncrement, addrCreator, prefixLength);
		}
		boolean isDecrement = bigIncrement.signum() <= 0;
		if(isDecrement) {
			return add(lowerProducer.get(), bigIncrement, addrCreator, prefixLength);
		}
		BigInteger count = section.getCount();
		BigInteger incrementPlus1 = bigIncrement.add(BigInteger.ONE);
		int countCompare = count.compareTo(incrementPlus1);
		if(countCompare <= 0) {
			if(countCompare == 0) {
				return upperProducer.get();
			}
			return add(upperProducer.get(), incrementPlus1.subtract(count), addrCreator, prefixLength);
		}
		return incrementRange(section, bigIncrement, addrCreator, lowerProducer, prefixLength);
	}
	
	/**
	 * 
	 * @param section
	 * @param increment
	 * @param addrCreator
	 * @param rangeIncrement the positive value of the number of increments through the range (0 means take lower or upper value in range)
	 * @param isDecrement
	 * @param lowerProducer
	 * @param upperProducer
	 * @param prefixLength
	 * @return
	 */
	@SuppressWarnings("unchecked")
	protected static <R extends AddressSection, S extends AddressSegment> R incrementRange(
			R section,
			long increment,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Integer prefixLength) {
		if(increment == 0) {
			return lowerProducer.get();
		}
		int segCount = section.getSegmentCount();
		S newSegments[];
		if(segCount > 0) {
			int i = segCount - 1;
			AddressSegment seg = section.getSegment(i);
			int bitCount = seg.getBitCount();
			newSegments = addrCreator.createSegmentArray(segCount);
			while(true) {
				int segValue = seg.getSegmentValue();
				long revolutions;
				int remainder;
				S newSegment;
				long segRange = seg.getValueCount();
				if(bitCount == IPv6Address.BITS_PER_SEGMENT && segRange == IPv6Address.MAX_VALUE_PER_SEGMENT + 1) {
					revolutions = increment >>> IPv6Address.BITS_PER_SEGMENT;
					remainder = (int) (increment & IPv6Address.MAX_VALUE_PER_SEGMENT);
					newSegment = addrCreator.createSegment(remainder);
				} else if(bitCount == IPv4Address.BITS_PER_SEGMENT && segRange == IPv4Address.MAX_VALUE_PER_SEGMENT + 1) {
					revolutions = increment >>> IPv4Address.BITS_PER_SEGMENT;
					remainder = (int) (increment & IPv4Address.MAX_VALUE_PER_SEGMENT);
					newSegment = addrCreator.createSegment(remainder);
				} else if(segRange == 1) {
					revolutions = increment;
					newSegment = addrCreator.createSegment(segValue);
				} else {
					revolutions = increment / segRange;
					remainder = (int) (increment % segRange);
					newSegment = addrCreator.createSegment(segValue + remainder);
				}
				newSegments[i] = newSegment;
				if(revolutions == 0) {
					for(i--; i >= 0; i--) {
						AddressSegment original = section.getSegment(i);
						newSegments[i] = addrCreator.createSegment(original.getSegmentValue());
					}
					break;
				}
				if(--i < 0) {
					break;
				}
				increment = revolutions;
				seg = section.getSegment(i);
			}
		} else {
			newSegments = (S[]) section.getSegments();
		}
		return createIteratedSection(newSegments, addrCreator, prefixLength);
	}
	
	private static <R extends AddressSection, S extends AddressSegment> R incrementRange(
			R section,
			BigInteger bigIncrement,
			AddressCreator<?, R, ?, S> addrCreator, 
			Supplier<R> lowerProducer,
			Integer prefixLength) {
		if(bigIncrement.signum() == 0) {
			return lowerProducer.get();
		}
		int segCount = section.getSegmentCount();
		S newSegments[] = addrCreator.createSegmentArray(segCount);
		for(int i = segCount - 1; i >= 0; i--) {
			AddressSegment seg = section.getSegment(i);
			int segValue = seg.getSegmentValue();
			long segRange = (seg.getUpperSegmentValue() - segValue) + 1L;
			BigInteger divs[] = bigIncrement.divideAndRemainder(BigInteger.valueOf(segRange)); 
			BigInteger revolutions = divs[0];
			int remainder = divs[1].intValue();
			S newSegment = addrCreator.createSegment(segValue + remainder);
			newSegments[i] = newSegment;
			if(revolutions.signum() == 0) {
				for(i--; i >= 0; i--) {
					AddressSegment original = section.getSegment(i);
					newSegments[i] = addrCreator.createSegment(original.getSegmentValue());
				}
				break;
			} else {
				bigIncrement = revolutions;
			}
		}
		return createIteratedSection(newSegments, addrCreator, prefixLength);
	}
	
	//this does not handle overflow, overflow should be checked before calling this
	protected static <R extends AddressSection, S extends AddressSegment> R add(
			R section, BigInteger increment, AddressCreator<?, R, ?, S> addrCreator, Integer prefixLength) {
		if(section.isMultiple()) {
			throw new IllegalArgumentException();
		}
		int segCount = section.getSegmentCount();
		BigInteger fullValue = section.getValue();
		fullValue = fullValue.add(increment);
		byte bytes[] = fullValue.toByteArray();
		return addrCreator.createSectionInternal(bytes, segCount, prefixLength, true);
	}
	
	protected static <R extends AddressSection, S extends AddressSegment> R add(
			R section, long fullValue, long increment, AddressCreator<?, R, ?, S> addrCreator, Integer prefixLength) {
		if(section.isMultiple()) {
			throw new IllegalArgumentException();
		}
		int segCount = section.getSegmentCount();
		S newSegs[] = addrCreator.createSegmentArray(segCount);
		createSegments(
					newSegs,
					0,
					fullValue + increment,
					section.getBitsPerSegment(),
					addrCreator.getNetwork(),
					prefixLength);
		return createIteratedSection(newSegs, addrCreator, prefixLength);
	}
	
	
	// Use this for IPv4 and also for when IPv6 has the first 5 segments with no diff (seg equal to getLower), 
	// and if MAC is 6 segments or the first segment of 8 has no diff.
	// Callers should have checked for matching segment counts.
	protected static Long enumerateSmall(AddressSegmentSeries series, AddressSegmentSeries otherSeries) {
		if(otherSeries.isMultiple()) {
			return null;
		} else if(otherSeries == series) { // both the same individual address
			return 0L;
		}
		return enumerateSmallImpl(series, otherSeries);
	}
	
	protected static Long enumerateSmallImpl(AddressSegmentSeries series, AddressSegmentSeries otherSeries) {
		if(series.isMultiple()) {
			if(!series.isSequential()) {
				if(series.getUpper().compareTo(otherSeries) < 0) {
					return (otherSeries.getValue().longValue() - series.getUpperValue().longValue()) + (series.getCount().longValue() - 1L);
				} else if(series.getLower().compareTo(otherSeries) <= 0) {
					long total = 0;
					long cumulativeSize = 1;
					for(int i = series.getSegmentCount() - 1; ; i--) {
						AddressSegment segment = series.getSegment(i), otherSegment = otherSeries.getSegment(i);
						int otherValue = otherSegment.getSegmentValue();
						int segValue = segment.getSegmentValue();
						if(otherValue < segValue || otherValue > segment.getUpperSegmentValue()) {
							return null;
						}
						total += cumulativeSize * (otherValue - segValue);
						if(i == 0) {
							return total;
						}
						cumulativeSize *= segment.getValueCount();
					}
				}
			}
		}
		return otherSeries.getValue().longValue() - series.getValue().longValue();
	}
	protected static BigInteger enumerateBig(AddressSegmentSeries series, AddressSegmentSeries otherSeries) {
		int segmentCount = series.getSegmentCount();
		if(segmentCount != otherSeries.getSegmentCount()) {
			throw new SizeMismatchException(series, otherSeries);
		} else if(otherSeries.isMultiple()) {
			return null;
		} else if(otherSeries == series) { // both the same individual address
			return BigInteger.ZERO;
		}
		
		// If the initial segments beyond 63 bits match, which is probably the case for most subnets, 
		// then we can just use long values to calculate
		boolean initialSegsMatch = true;
		int bitsPerSegment = series.getBitsPerSegment();
		int totalBits = ParsedAddressGrouping.getTotalBits(segmentCount, series.getBytesPerSegment(), bitsPerSegment);
		int i = 0;
		while(totalBits > Long.SIZE) {
			AddressSegment seg = series.getSegment(i);
			AddressSegment otherSeg = otherSeries.getSegment(i);
			if(!seg.matches(otherSeg.getSegmentValue())) {
				initialSegsMatch = false;
				break;
			}
			totalBits -= bitsPerSegment;
			i++;
		}
		if(initialSegsMatch) {
			// if there are exactly 64 bits left, we also need the top bit to match too, the sign bit
			if(totalBits == Long.SIZE) {
				AddressSegment seg = series.getSegment(i);
				AddressSegment otherSeg = otherSeries.getSegment(i);
				int mask = (1 << bitsPerSegment) >>> 1;
				if(seg.matchesWithMask(otherSeg.getSegmentValue() & mask, mask)) {
					// we can use longs to calculate
					Long result = enumerateSmallImpl(series, otherSeries);
					if(result == null) {
						return null;
					}
					return BigInteger.valueOf(result);
				}
			} else {
				// we can use longs to calculate
				Long result = enumerateSmallImpl(series, otherSeries);
				if(result == null) {
					return null;
				}
				return BigInteger.valueOf(result);
			}
		}
		
		// we use BigIntegers to calculate
		
		if(series.isMultiple()) {
			if(!series.isSequential()) {
				if(series.getUpper().compareTo(otherSeries) < 0) {
					return otherSeries.getValue().subtract(series.getUpperValue()).add(series.getCount().subtract(BigInteger.ONE));
				} else if(series.getLower().compareTo(otherSeries) <= 0) {
					BigInteger total = BigInteger.ZERO;
					BigInteger cumulativeSize = BigInteger.ONE;
					for(int j = series.getSegmentCount() - 1; ; j--) {
						AddressSegment segment = series.getSegment(j), otherSegment = otherSeries.getSegment(j);
						int otherValue = otherSegment.getSegmentValue();
						int segValue = segment.getSegmentValue();
						if(otherValue < segValue || otherValue > segment.getUpperSegmentValue()) {
							return null;
						}
						total = total.add(cumulativeSize.multiply(BigInteger.valueOf(otherValue - segValue)));
						if(j == 0) {
							return total;
						}
						cumulativeSize = cumulativeSize.multiply(segment.getCount());
					}
				}
			}
		}
		return otherSeries.getValue().subtract(series.getValue());
	}
	protected static BigInteger count(IntUnaryOperator segmentValueCountProvider, int segCount, int safeMultiplies, long safeLimit) {
		int i = 0;
		BigInteger result = BigInteger.ONE;
		if(segCount == 0) {
			return result;
		}
		while(true) {
			long curResult = segmentValueCountProvider.applyAsInt(i++);
			if(i == segCount) {
				return mult(result, curResult);
			}
			int limit = i + safeMultiplies;
			if(segCount <= limit) {
				// all multiplies are safe
				while(i < segCount) {
					curResult *= segmentValueCountProvider.applyAsInt(i++);
				}
				return mult(result, curResult);
			}
			// do the safe multiplies which cannot overflow
			while(i < limit) {
				curResult *= segmentValueCountProvider.applyAsInt(i++);
			}
			// do as many additional multiplies as current result allows
			while(curResult <= safeLimit) {
				curResult *= segmentValueCountProvider.applyAsInt(i++);
				if(i == segCount) {
					return mult(result, curResult);
				}
			}
			result = mult(result, curResult);
		}
	}
	
	private static BigInteger mult(BigInteger currentResult, long newResult) {
		if(newResult == 1) {
			return currentResult;
		}
		BigInteger newBig = BigInteger.valueOf(newResult);
		if(currentResult == BigInteger.ONE) {
			return newBig;
		}
		return currentResult.multiply(newBig);
	}
	
	protected static <R extends AddressSection, S extends AddressSegment> R getSection(
			int index,
			int endIndex,
			R section,
			AddressCreator<?, R, ?, S> creator) {
		if(index == 0 && endIndex == section.getSegmentCount()) {
			return section;
		}
		int segmentCount = endIndex - index;
		if(segmentCount < 0) {
			throw new IndexOutOfBoundsException();
		}
		S segs[] = creator.createSegmentArray(segmentCount);
		section.getSegments(index, endIndex, segs, 0);
		return creator.createSectionInternal(segs);
	}
	
	protected static <R extends AddressSection, S extends AddressSegment> R append(
			R section,
			R other,
			AddressCreator<?, R, ?, S> creator) {
		int otherSegmentCount = other.getSegmentCount();
		int segmentCount = section.getSegmentCount();
		int totalSegmentCount = segmentCount + otherSegmentCount;
		S segs[] = creator.createSegmentArray(totalSegmentCount);
		section.getSegments(0, segmentCount, segs, 0);
		if(section.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			S allSegment = creator.createSegment(0, cacheBits(0));
			Arrays.fill(segs, segmentCount, totalSegmentCount, allSegment);
		} else {
			other.getSegments(0, otherSegmentCount, segs, segmentCount);
		}
		return creator.createSectionInternal(segs);
	}
	
	protected static <R extends AddressSection, S extends AddressSegment> R replace(
			R section,
			int index,
			int endIndex,
			R replacement,
			int replacementStartIndex,
			int replacementEndIndex,
			AddressCreator<?, R, ?, S> creator,
			boolean appendNetwork,
			boolean isMac) {
		int otherSegmentCount = replacementEndIndex  - replacementStartIndex;
		int segmentCount = section.getSegmentCount();
		int totalSegmentCount = segmentCount + otherSegmentCount - (endIndex - index);
		S segs[] = creator.createSegmentArray(totalSegmentCount);
		section.getSegments(0, index, segs, 0);
		if(index < totalSegmentCount) {
			if(section.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() &&
					(appendNetwork ?
							(getHostSegmentIndex(section.getPrefixLength(), section.getBytesPerSegment(), section.getBitsPerSegment()) < index) :
							(getNetworkSegmentIndex(section.getPrefixLength(), section.getBytesPerSegment(), section.getBitsPerSegment()) < index)) && 
					(isMac || index > 0)) { 
				S allSegment = creator.createSegment(0, cacheBits(0));
				Arrays.fill(segs, index, totalSegmentCount, allSegment);
				return creator.createSectionInternal(segs);
			}
			replacement.getSegments(replacementStartIndex, replacementEndIndex, segs, index);
			if(index + otherSegmentCount < totalSegmentCount) {
				if(replacement.isPrefixed() && section.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && 
						getNetworkSegmentIndex(replacement.getPrefixLength(), replacement.getBytesPerSegment(), replacement.getBitsPerSegment()) < replacementEndIndex && 
						(isMac || otherSegmentCount > 0)) {
					S allSegment = creator.createSegment(0, cacheBits(0));
					Arrays.fill(segs, index + otherSegmentCount, totalSegmentCount, allSegment);
				} else {
					section.getSegments(endIndex, segmentCount, segs, index + otherSegmentCount);
				}
			}
		}
		return creator.createSectionInternal(segs);
	}
	
	protected static <R extends AddressSection, S extends AddressSegment> R createSectionInternal(AddressCreator<?, R, ?, S> creator, S[] segments, int startIndex, boolean extended) {
		return creator.createSectionInternal(segments, startIndex, extended);
	}
	
	protected boolean isDualString() throws IncompatibleAddressException {
		int count = getDivisionCount();
		for(int i = 0; i < count; i++) {
			AddressDivision division = getDivision(i);
			if(division.isMultiple()) {
				//at this point we know we will return true, but we determine now if we must throw IncompatibleAddressException
				boolean isLastFull = true;
				AddressDivision lastDivision = null;
				for(int j = count - 1; j >= 0; j--) {
					division = getDivision(j);
					if(division.isMultiple()) {
						if(!isLastFull) {
							throw new IncompatibleAddressException(division, i, lastDivision, i + 1, "ipaddress.error.segmentMismatch");
						}
						isLastFull = division.isFullRange();
					} else {
						isLastFull = false;
					}
					lastDivision = division;
				}
				return true;
			}
		}
		return false;
	}
	protected static <T extends AddressStringDivisionSeries, E extends AddressStringDivisionSeries> String 
			toNormalizedStringRange(AddressStringParams<T> params, T lower, T upper, CharSequence zone) {
		int length = params.getStringLength(lower, null) + params.getStringLength(upper, zone);
		StringBuilder builder;
		String separator = params.getWildcards().rangeSeparator;
		if(separator != null) {
			length += separator.length();
			builder = new StringBuilder(length);
			params.append(params.append(builder, lower, null).append(separator), upper, zone);
		} else {
			builder = new StringBuilder(length);
			params.append(params.append(builder, lower, null), upper, zone);
		}
		AddressStringParams.checkLengths(length, builder);
		return builder.toString();
	}
	protected void checkSegmentCount(AddressSection sec) throws SizeMismatchException {
		if(sec.getDivisionCount() != getDivisionCount()) {
			throw new SizeMismatchException(this, sec);
		}
	}
	/**
	 * Represents a clear way to create a specific type of string.
	 * 
	 * @author sfoley
	 */
	public static class StringOptions extends StringOptionsBase {
		
		public static class Wildcards {
			public final String rangeSeparator;//cannot be null
			public final String wildcard;//can be null
			public final String singleWildcard;//can be null
			
			public Wildcards() {
				this(Address.RANGE_SEPARATOR_STR, Address.SEGMENT_WILDCARD_STR, null);
			}
			
			public Wildcards(String wildcard, String singleWildcard) {
				this(Address.RANGE_SEPARATOR_STR, wildcard, singleWildcard);
			}
			
			public Wildcards(String rangeSeparator) {
				this(rangeSeparator, null, null);
			}
			
			public Wildcards(String rangeSeparator, String wildcard, String singleWildcard) {
				if(rangeSeparator == null) {
					rangeSeparator = Address.RANGE_SEPARATOR_STR;
				}
				this.rangeSeparator = rangeSeparator;
				this.wildcard = wildcard;
				this.singleWildcard = singleWildcard;
			}
			
			@Override
			public String toString() {
				return "range separator: " + rangeSeparator + "\nwildcard: " + wildcard + "\nsingle wildcard: " + singleWildcard;
			}
		}
		
		public final Wildcards wildcards;
		public final boolean expandSegments;
		public final int base;
		public final String segmentStrPrefix;
		public final Character separator;
		public final String addrLabel;
		public final boolean reverse;
		public final boolean splitDigits;
		public final boolean uppercase;
		
		
		protected StringOptions(
				int base,
				boolean expandSegments,
				Wildcards wildcards,
				String segmentStrPrefix,
				Character separator,
				String label,
				boolean reverse,
				boolean splitDigits,
				boolean uppercase) {
			this.expandSegments = expandSegments;
			this.wildcards = wildcards;
			this.base = base;
			if(segmentStrPrefix == null) {
				throw new NullPointerException("segment str");
			}
			this.segmentStrPrefix = segmentStrPrefix;
			this.separator = separator;
			if(label == null) {
				throw new NullPointerException("label");
			}
			this.addrLabel = label;
			this.reverse = reverse;
			this.splitDigits = splitDigits;
			this.uppercase = uppercase;
		}
		
		public static class Builder {
			
			public static final Wildcards DEFAULT_WILDCARDS = new Wildcards();
		
			protected Wildcards wildcards = DEFAULT_WILDCARDS;
			protected boolean expandSegments;
			protected int base;
			protected String segmentStrPrefix = "";
			protected Character separator;
			protected String addrLabel = "";
			protected boolean reverse;
			protected boolean splitDigits;
			protected boolean uppercase;
			
			public Builder(int base) {
				this.base = base;
				this.separator = ' ';
			}
			
			public Builder(int base, char separator) {
				this.base = base;
				this.separator = separator;
			}
			
			public Builder setWildcards(Wildcards wildcards) {
				this.wildcards = wildcards;
				return this;
			}
			
			public Builder setReverse(boolean reverse) {
				this.reverse = reverse;
				return this;
			}
			
			public Builder setUppercase(boolean uppercase) {
				this.uppercase = uppercase;
				return this;
			}
			public Builder setSplitDigits(boolean splitDigits) {
				this.splitDigits = splitDigits;
				return this;
			}
			
			public Builder setExpandedSegments(boolean expandSegments) {
				this.expandSegments = expandSegments;
				return this;
			}
			
			public Builder setRadix(int base) {
				this.base = base;
				return this;
			}
			
			/*
			 * separates the divisions of the address, typically ':' or '.', but also can be null for no separator
			 */
			public Builder setSeparator(Character separator) {
				this.separator = separator;
				return this;
			}
			
			public Builder setAddressLabel(String label) {
				this.addrLabel = label;
				return this;
			}
			
			public Builder setSegmentStrPrefix(String prefix) {
				this.segmentStrPrefix = prefix;
				return this;
			}
			
			public StringOptions toOptions() {
				return new StringOptions(base, expandSegments, wildcards, segmentStrPrefix, separator, addrLabel, reverse, splitDigits, uppercase);
			}
		}
	}
}

/*
 * Copyright 2016-2020 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.standard;
import java.util.Arrays;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.InconsistentPrefixException;
import inet.ipaddr.format.AddressDivisionGroupingBase;
import inet.ipaddr.format.AddressDivisionSeries;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * IPAddressDivisionGrouping objects consist of a series of IPAddressDivision objects, each division containing one or more segments.
 * <p>
 * With the IPAddressSection subclass, each division is one segment (eg either groupings of 4 like 1.2.3.4 or groupings of 8 like 1:2:3:4:5:6:7:8). 
 * <p>
 * For IPv6, a compressed segment still counts as one of the groupings, it is simply not printed as part of the text representation.
 * <p>
 * Alternative groupings include ipv4 groupings define by inet_aton (eg groupings of 1, 2, or 3 divisions like 1, 1.2, and 1.2.3) and the mixed ipv6/ipv4 representation of ipv6 addresses (eg a grouping of 10 divisions like a:b:c:d:e:f:1.2.3.4)
 * <p>
 * IPAddressDivisionGrouping objects are immutable.  Some of the derived state is created upon demand and cached.  This also makes them thread-safe.
 * <p>
 * IPAddressDivisionGrouping objects may be associated with a prefix length, in which case that number of bits in the upper-most
 * portion of the object represent a prefix, while the remaining bits assume all possible values.
 * <p>
 * IPAddressDivision objects use long to represent their values, so this places a cap on the size of the divisions in IPAddressDivisionGrouping.
 * <p>
 *  @author sfoley
 */
public class IPAddressDivisionGrouping extends AddressDivisionGrouping implements IPAddressDivisionSeries {
	private static final long serialVersionUID = 4L;
	
	private final IPAddressNetwork<?, ?, ?, ?, ?> network;
	protected static final RangeCache ZEROS_CACHE = new RangeCache();
	
	static {
		if(RangeCache.PRELOAD_CACHE) {
			ZEROS_CACHE.preloadCache(-1);
		}
	}
	/**
	 * Constructs a grouping of IPAddress divisions.
	 * <p>
	 * Note: If the grouping is prefixed and the prefix length aligns with a division boundary, 
	 * then we allow as division prefix lengths both 
	 * null:null:x:0:0 where is x is the division bit count and 
	 * null:null:null:0:0, which are essentially equivalent.
	 * The overall prefix length of this example grouping is the division bit count tripled.
	 * For further discussion of this, see {@link AddressDivisionGrouping#normalizePrefixBoundary(int, IPAddressSegment[], int, int, java.util.function.Function)}
	 * 
	 * @param divisions
	 * @param network
	 * @throws NullPointerException if network is null or a division is null
	 */
	public IPAddressDivisionGrouping(IPAddressDivision divisions[], IPAddressNetwork<?, ?, ?, ?, ?> network) throws AddressValueException {
		super(divisions);
		if(network == null) {
			throw new NullPointerException(getMessage("ipaddress.error.nullNetwork"));
		}
		this.network = network;
		int totalPrefixBits = 0;
		for(int i = 0; i < divisions.length; i++) {
			IPAddressDivision division = divisions[i];
			/**
			 * Across an address prefixes are:
			 * (null):...:(null):(1 to x):(0):...:(0)
			 */
			Integer divPrefix = division.getDivisionPrefixLength();
			if(divPrefix != null) {
				cachedPrefixLength = cacheBits(totalPrefixBits + divPrefix);
				for(++i; i < divisions.length; i++) {
					division = divisions[i];
					divPrefix = division.getDivisionPrefixLength();
					if(divPrefix == null || divPrefix != 0) {
						throw new InconsistentPrefixException(divisions[i - 1], division, divPrefix);
					}
				}
				return;
			}
			totalPrefixBits += division.getBitCount();
		}
		cachedPrefixLength = NO_PREFIX_LENGTH;
	}
	
	/**
	 * Constructs a grouping of IPAddress divisions.
	 * <p>
	 * @throws NullPointerException if getNetwork() returns null or a division is null
	 * @param divisions
	 * @param checkSegs
	 */
	protected IPAddressDivisionGrouping(IPAddressDivision divisions[], boolean checkSegs) {
		super(divisions, checkSegs);
		network = getNetwork();//getNetwork() must be overridden in subclasses
		if(network == null) {
			throw new NullPointerException(getMessage("ipaddress.error.nullNetwork"));
		}
	}
	
	@Override
	public IPAddressNetwork<?, ?, ?, ?, ?> getNetwork() {
		return network;
	}
	
	@Override
	public IPAddressDivision getDivision(int index) {
		return (IPAddressDivision) super.getDivision(index);
	}
	
	@Override
	public int isMore(AddressDivisionSeries other) {
		if(!isMultiple()) {
			return other.isMultiple() ? -1 : 0;
		}
		if(!other.isMultiple()) {
			return 1;
		}
		if(isSinglePrefixBlock() && other.isSinglePrefixBlock()) {
			int bits = getBitCount() - getPrefixLength();
			int otherBits = other.getBitCount() - other.getPrefixLength();
			return bits - otherBits;
		}
		return getCount().compareTo(other.getCount());
	}
	
	@Override
	public Integer getPrefixLength() {
		return getNetworkPrefixLength();
	}
	@Override
	public Integer getNetworkPrefixLength() {
		Integer ret = cachedPrefixLength;
		if(ret == null) {
			Integer result = calculatePrefix(this);
			if(result != null) {
				return cachedPrefixLength = result;
			}
			cachedPrefixLength = NO_PREFIX_LENGTH;
			return null;
		}
		if(ret.intValue() == NO_PREFIX_LENGTH.intValue()) {
			return null;
		}
		return ret;
	}
	
	/**
	 * Returns the number of consecutive trailing one or zero bits.
	 * If network is true, returns the number of consecutive trailing zero bits.
	 * Otherwise, returns the number of consecutive trailing one bits.
	 * <p>
	 * This method applies only to the lower value of the range if this division represents multiple values.
	 * 
	 * @param network
	 * @return
	 */
	public int getTrailingBitCount(boolean network) {
		int count = getDivisionCount();
		if(count == 0) {
			return 0;
		}
		long back = network ? 0 : getDivision(0).getMaxValue();
		int bitLen = 0;
		for(int i = count - 1; i >= 0; i--) {
			IPAddressDivision seg = getDivision(i);
			long value = seg.getDivisionValue();
			if(value != back) {
				return bitLen + seg.getTrailingBitCount(network);
			}
			bitLen += seg.getBitCount();
		}
		return bitLen;
	}
	
	/**
	 * Returns the number of consecutive leading one or zero bits.
	 * If network is true, returns the number of consecutive leading one bits.
	 * Otherwise, returns the number of consecutive leading zero bits.
	* <p>
	 * This method applies only to the lower value of the range if this division represents multiple values.
	  * 
	 * @param network
	 * @return
	 */
	public int getLeadingBitCount(boolean network) {
		int count = getDivisionCount();
		if(count == 0) {
			return 0;
		}
		long front = network ? getDivision(0).getMaxValue() : 0;
		int prefixLen = 0;
		for(int i = 0; i < count; i++) {
			IPAddressDivision seg = getDivision(i);
			long value = seg.getDivisionValue();
			if(value != front) {
				return prefixLen + seg.getLeadingBitCount(network);
			}
			prefixLen += seg.getBitCount();
		}
		return prefixLen;
	}
	
	/**
	 * Returns whether this address section represents a subnet block of addresses associated its prefix length.
	 * 
	 * Returns false if it has no prefix length, if it is a single address with a prefix length (ie not a subnet), or if it is a range of addresses that does not include
	 * the entire subnet block for its prefix length.
	 * 
	 * If {@link AddressNetwork#getPrefixConfiguration} is set to consider all prefixes as subnets, this returns true for any grouping with prefix length.
	 * 
	 * @return
	 */
	@Override
	public boolean isPrefixBlock() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null) {
			return false;
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return true;
		}
		return containsPrefixBlock(networkPrefixLength);
	}
	
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		return containsPrefixBlock(this, prefixLength);
	}
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		return containsSinglePrefixBlock(this, prefixLength);
	}
	/**
	 * Returns whether the division grouping range matches the block of values for its prefix length.
	 * In other words, returns true if and only if it has a prefix length and it has just a single prefix.
	 */
	@Override
	public boolean isSinglePrefixBlock() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null) {
			return false;
		}
		return containsSinglePrefixBlock(networkPrefixLength);
	}
	
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		return getPrefixLengthForSingleBlock(this);
	}
	public boolean includesZeroHost() {
		Integer networkPrefixLength = getNetworkPrefixLength();
		if(networkPrefixLength == null || networkPrefixLength >= getBitCount()) {
			return false;
		}
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return true;
		}
		int divCount = getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressDivision div = getDivision(i);
			Integer segmentPrefixLength = div.getDivisionPrefixLength();
			if(segmentPrefixLength != null) {
				long mask = ~(~0L << (div.getBitCount() - segmentPrefixLength));
				if((mask & div.getDivisionValue()) != 0) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = getDivision(i);
					if(!div.includesZero()) {
						return false;
					}
				}
			}
		}
		return true;
	}
	@Override
	protected boolean isSameGrouping(AddressDivisionGroupingBase other) {
		return other instanceof IPAddressDivisionGrouping && super.isSameGrouping(other);
	}
	
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof IPAddressDivisionGrouping) {
			IPAddressDivisionGrouping other = (IPAddressDivisionGrouping) o;
			// we call isSameGrouping on the other object to defer to subclasses IPv4 and IPv6 which check for type IPv4AddressSection and IPv6AddressSection
			return other.isSameGrouping(this); 
		}
		return false;
	}
	protected static boolean prefixContains(IPAddressSection first, IPAddressSection other, int otherIndex) {
		if(otherIndex < 0) {
			return false;
		}
		Integer prefixLength = first.getPrefixLength();
		int prefixedSection;
		if(prefixLength == null) {
			prefixedSection = first.getSegmentCount();
			int oIndex = prefixedSection + otherIndex;
			if(oIndex > other.getSegmentCount()) {
				return false;
			}
		} else {
			prefixedSection = getNetworkSegmentIndex(prefixLength, first.getBytesPerSegment(), first.getBitsPerSegment());
			if(prefixedSection >= 0) {
				int oIndex = prefixedSection + otherIndex;
				if(oIndex >= other.getSegmentCount()) {
					return false;
				}
				IPAddressSegment one = first.getSegment(prefixedSection);
				IPAddressSegment two = other.getSegment(oIndex);
				int segPrefixLength = getPrefixedSegmentPrefixLength(one.getBitCount(), prefixLength, prefixedSection);
				if(!one.prefixContains(two, segPrefixLength)) {
					return false;
				}
			}
		}
		while(--prefixedSection >= 0) {
			IPAddressSegment one = first.getSegment(prefixedSection);
			IPAddressSegment two = other.getSegment(prefixedSection + otherIndex);
			if(!one.contains(two)) {
				return false;
			}
		}
		return true;
	}
	/**
	 * @return the segments which are zero
	 */
	public RangeList getZeroSegments() {
		return getZeroSegments(false);
	}
	/**
	 * @return the segments which are zero or whose prefix-based range includes 0
	 */
	public RangeList getZeroRangeSegments() {
		if(isPrefixed()) {
			return getZeroSegments(true);
		}
		return getZeroSegments();
	}
	
	protected static RangeList getNoZerosRange() {
		return RangeCache.NO_ZEROS;
	}
	
	protected static RangeList getSingleRange(int index, int len) {
		RangeCache cache = ZEROS_CACHE.addRange(index, -1, len);
		return cache.get();
	}
	
	protected RangeList getZeroSegments(boolean includeRanges) {
		RangeCache cache = ZEROS_CACHE;
		int divisionCount = getDivisionCount();
		boolean isFullRangeHost = !getNetwork().getPrefixConfiguration().prefixedSubnetsAreExplicit() && isPrefixBlock();
		includeRanges &= isFullRangeHost;
		int currentIndex = -1, lastIndex = -1, currentCount = 0;
		for(int i = 0; i < divisionCount; i++) {
			IPAddressDivision division = getDivision(i);
			boolean isCompressible = division.isZero() || 
					(includeRanges && division.isPrefixed() && division.isSinglePrefixBlock(0, division.getDivisionPrefixLength()));
			if(isCompressible) {
				if(++currentCount == 1) {
					currentIndex = i;
				}
				if(i == divisionCount - 1) {
					cache = cache.addRange(currentIndex, lastIndex, currentCount);
					lastIndex = currentIndex + currentCount;
				}
			} else if(currentCount > 0) {
				cache = cache.addRange(currentIndex, lastIndex, currentCount);
				lastIndex = currentIndex + currentCount;
				currentCount = 0;
			}
		}
		return cache.get();
	}
	public static class Range {
		public final int index;
		public final int length;
		
		Range(int index, int length) {
			this.index = index;
			this.length = length;
		}
		
		@Override
		public String toString() {
			return "[" + index + ',' + (index + length) + ']';
		}
	}
	
	public static class RangeList {
		final Range ranges[];
		
		RangeList(Range ranges[]) {
			if(ranges == null) {
				throw new NullPointerException();
			}
			this.ranges = ranges;
		}
		public int size() {
			return ranges.length;
		}
		
		public Range getRange(int index) {
			return ranges[index];
		}
		
		@Override
		public String toString() {
			return Arrays.asList(ranges).toString();
		}
	}
	/**
	 * A cache of RangeList objects in a tree structure.
	 * 
	 * Starting from the root of the tree, as you traverse an address grouping from left to right,
	 * if you have another range located at offset x from the last one, and it has length y,
	 * then you follow nextRange[x][y] in the tree.
	 * 
	 * When you have no more ranges (and this no more tree nodes to follow), then you can use the field for the cached ZeroRanges object
	 * which is associated with the path you've followed (which corresponds to the zero-ranges in the address).
	 * 
	 * @author sfoley
	 *
	 */
	private static class RangeCache {
		static boolean PRELOAD_CACHE;
		static final int MAX_DIVISION_COUNT = IPv6Address.SEGMENT_COUNT;
		static final RangeList NO_ZEROS = new RangeList(new Range[0]);
		
		RangeCache nextRange[][];//nextRange[x - 1][y - 1] indicates tree entry for cases where the next range is at offset x from the current one and has length y
		RangeCache parent;//the parent of this entry in the tree
		RangeList zeroRanges;
		Range range;
		
		RangeCache() {
			this(null, MAX_DIVISION_COUNT, null);
			zeroRanges = NO_ZEROS;
		}
		
		private RangeCache(RangeCache parent, int potentialZeroOffsets, Range range) {
			if(potentialZeroOffsets > 0) {
				nextRange = new RangeCache[potentialZeroOffsets][];
				for(int i = 0; i < potentialZeroOffsets; i++) {
					nextRange[i] = new RangeCache[potentialZeroOffsets - i];
				}
			}
			this.parent = parent;
			this.range = range;
		}
		
		private void get(Range ranges[], int rangesIndex) {
			ranges[--rangesIndex] = range;
			if(rangesIndex > 0) {
				parent.get(ranges, rangesIndex);
			}
		}
		
		public RangeList get() {
			RangeList result = zeroRanges;
			if(result == null) {
				int depth = 0;
				RangeCache up = parent;
				while(up != null) {
					depth++;
					up = up.parent;
				}
				Range ranges[] = new Range[depth];
				if(depth > 0) {
					ranges[--depth] = range;
					if(depth > 0) {
						parent.get(ranges, depth);
					}
				}
				zeroRanges = result = new RangeList(ranges);
			}
			return result;
		}
		void preloadCache(int lastIndex) {
			if(nextRange != null) {
				for(int i = 0; i < nextRange.length; i++) {
					RangeCache next[] = nextRange[i];
					for(int j = 0; j < next.length; j++) {
						Range newRange;
						if(lastIndex == -1) {//we are the root ZEROS_CACHE
							newRange = new Range(i + lastIndex + 1, j + 1);
						} else {
							newRange = ZEROS_CACHE.nextRange[i + lastIndex + 1][j].range;
						}
						int nextPotentialZeroIndex = i + lastIndex + j + 3;
						int remainingPotentialZeroOffsets = RangeCache.MAX_DIVISION_COUNT - nextPotentialZeroIndex;
						RangeCache newRangeCache = new RangeCache(this, remainingPotentialZeroOffsets, newRange);
						newRangeCache.get();
						next[j] = newRangeCache;
					}
				}
				for(int i = 0; i < nextRange.length; i++) {
					RangeCache next[] = nextRange[i];
					for(int j = 0; j < next.length; j++) {
						RangeCache nextCache = next[j];
						Range nextRange = nextCache.range;
						nextCache.preloadCache(nextRange.index + nextRange.length);
					}
				}
			}
		}
		
		public RangeCache addRange(int currentIndex, int lastIndex, int currentCount) {
			int offset = currentIndex - lastIndex;//the offset from the end of the last zero-range, which must be at least 1
			int cacheOffset = offset - 1;//since offset must be at least 1 we adjust by 1
			int cacheCount = currentCount - 1;//since currentCount must be at least 1, we adjust by 1
			RangeCache next = nextRange[cacheOffset][cacheCount];
			if(next == null) {
				//we will never reach here when the cache is preloaded.
				synchronized(this) {
					next = nextRange[cacheOffset][cacheCount];
					if(next == null) {
						int nextPotentialZeroIndex = lastIndex + 1;//we adjust by 1 the next potential index since at offset 0 we do not have a 0
						int remainingPotentialZeroOffsets = RangeCache.MAX_DIVISION_COUNT - nextPotentialZeroIndex;
						Range newRange;
						if(this == ZEROS_CACHE) {
							newRange = new Range(currentIndex, currentCount);
						} else {
							RangeCache rootNext = ZEROS_CACHE.nextRange[currentIndex][currentCount - 1];
							if(rootNext == null) {
								ZEROS_CACHE.nextRange[currentIndex][currentCount - 1] = new RangeCache(ZEROS_CACHE, RangeCache.MAX_DIVISION_COUNT, newRange = new Range(currentIndex, currentCount));
							} else {
								newRange = rootNext.range;
							}
						}
						nextRange[cacheOffset][cacheCount] = next = new RangeCache(this, remainingPotentialZeroOffsets, newRange);
					}
				}
			}
			return next;
		}
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.math.BigInteger;
import inet.ipaddr.format.AddressItem;
/**
 * Thrown when an address or address component would be too large or small,
 * when a prefix length is too large or small, or when prefixes across segments are inconsistent.
 * <p>
 * These exceptions are thrown when constructing new address components.  
 * They are not thrown when parsing strings to construct new address components, in which case {@link AddressStringException} is used instead.
 * 
 * @author sfoley
 *
 */
public class AddressValueException extends RuntimeException {
	private static final long serialVersionUID = 1L;
	
	static String errorMessage = getMessage("ipaddress.address.error");
	
	static String getMessage(String key) {
		return AddressStringException.getMessage(key);
	}
	
	public AddressValueException(long value) {
		super(value + ", " + errorMessage + " " + getMessage("ipaddress.error.exceeds.size"));
	}
	
	public AddressValueException(String key, long value) {
		super(value + ", " + errorMessage + " " + getMessage(key));
	}
	
	public AddressValueException(BigInteger value) {
		super(value + ", " + errorMessage + " " + getMessage("ipaddress.error.exceeds.size"));
	}
	
	public AddressValueException(AddressItem one, AddressItem two, int count) {
		super(count + ", " + one + ", " + two + ", " + errorMessage + " " + getMessage("ipaddress.error.exceeds.size"));
	}
	
	public AddressValueException(AddressItem one, AddressItem two) {
		super(one + ", " + two + ", " + errorMessage + " " + getMessage("ipaddress.error.exceeds.size"));
	}
	
	public AddressValueException(AddressItem one, String key) {
		super(one + ", "  + errorMessage + " " + getMessage(key));
	}
	
	public AddressValueException(String message) {
        super(message);
    }
	public AddressValueException(String message, Throwable cause) {
        super(message, cause);
    }
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.function.Supplier;
import java.util.stream.Stream;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.IPStringCache;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.format.standard.AddressDivision;
import inet.ipaddr.format.standard.IPAddressDivision;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressStringWriter;
import inet.ipaddr.format.validate.ParsedIPAddress.BitwiseOrer;
import inet.ipaddr.format.validate.ParsedIPAddress.Masker;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * This represents a single segment of an IP address.  For IPv4, segments are 1 byte.  For IPv6, they are two bytes.
 * 
 * IPAddressSegment objects are immutable and thus also thread-safe.
 * 
 * @author sfoley
 *
 */
public abstract class IPAddressSegment extends IPAddressDivision implements AddressSegment {
	
	private static final long serialVersionUID = 4L;
	
	// These two values define the uniqueness of a segment with respect to equality and comparison, while the prefix is ignored as these values encapsulate the range of addresses created by the prefix.
	private final int value; // the lower value of the segment
	private final int upperValue; // the upper value of a CIDR or other type of range, if not a range it is the same as value
	
	/**
	 * Constructs a segment of an IPv4 or IPv6 address with the given value.
	 * 
	 * @param value the value of the segment
	 */
	protected IPAddressSegment(int value) {
		if(value < 0) {
			throw new AddressValueException(value);
		}
		this.value = this.upperValue = value;
	}
	
	/**
	 * Constructs a segment of an IPv4 or IPv6 address.
	 * 
	 * @param value the value of the segment.
	 * 		If the segmentPrefixLength is non-null, the network prefix of the value is used, and the segment represents all segment values with the same network prefix (all network or subnet segments, in other words).
	 * @param segmentPrefixLength the segment prefix bits, which can be null
	 */
	protected IPAddressSegment(int value, Integer segmentPrefixLength) {
		this(value, value, segmentPrefixLength);
	}
	
	/**
	 * Constructs a segment of an IPv4 or IPv6 address that represents a range of values.
	 * 
	 * @param segmentPrefixLength the segment prefix bits, which can be null.  If segmentPrefixLength is non-null, this segment represents a range of segment values with the given network prefix length.
	 * @param lower the lower value of the range of values represented by the segment.  If segmentPrefixLength is non-null, the lower value becomes the smallest value with the same network prefix.
	 * @param upper the upper value of the range of values represented by the segment.  If segmentPrefixLength is non-null, the upper value becomes the largest value with the same network prefix.
	 */
	protected IPAddressSegment(int lower, int upper, Integer segmentPrefixLength) {
		super(segmentPrefixLength);
		if(lower < 0 || upper < 0) {
			throw new AddressValueException(lower < 0 ? lower : upper);
		}
		if(lower > upper) {
			int tmp = lower;
			lower = upper;
			upper = tmp;
		}
		segmentPrefixLength = getSegmentPrefixLength();
		if(segmentPrefixLength == null || segmentPrefixLength >= getBitCount() || !getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			this.value = lower;
			this.upperValue = upper;
		} else {
			int mask = getSegmentNetworkMask(segmentPrefixLength);
			this.value = lower & mask;
			this.upperValue = upper | getSegmentHostMask(segmentPrefixLength);
		}
	}
	
	@Override
	public abstract IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	
	public boolean isIPv4() {
		return false;
	}
	
	public boolean isIPv6() {
		return false;
	}
	
	public abstract IPVersion getIPVersion();
	protected static Integer getSplitSegmentPrefix(int bitsPerSegment, Integer networkPrefixLength, int segmentIndex) {
		return IPAddressSection.getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, segmentIndex);
	}
	
	@Override
	protected long getDivisionNetworkMask(int bits) {
		return getSegmentNetworkMask(bits);
	}
	
	@Override
	protected long getDivisionHostMask(int bits) {
		return getSegmentHostMask(bits);
	}
	
	protected abstract int getSegmentNetworkMask(int bits);
	
	protected abstract int getSegmentHostMask(int bits);
	
	@Override
	public int getMinPrefixLengthForBlock() {
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getSegmentPrefixLength() == 0) {
			return 0;
		}
		return super.getMinPrefixLengthForBlock();
	}
	
	public static int getMaxSegmentValue(IPVersion version) {
		return version.isIPv4() ? IPv4Address.MAX_VALUE_PER_SEGMENT : IPv6Address.MAX_VALUE_PER_SEGMENT;
	}
	protected boolean isChangedByPrefix(Integer bits, boolean smallerOnly) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		if(smallerOnly) {
			if(isPrefixed()) {
				return hasBits && bits < getSegmentPrefixLength();
			}
		} else {
			if(isPrefixed()) {
				return !hasBits || bits != getSegmentPrefixLength().intValue();
			}
		}
		return hasBits;
	}
	protected <S extends IPAddressSegment> S toPrefixedSegment(Integer segmentPrefixLength, AddressSegmentCreator<S> creator) {
		int lower = getSegmentValue();
		int upper = getUpperSegmentValue();
		boolean hasBits = (segmentPrefixLength != null);
		if(lower != upper) {
			//note that the case where our segmentPrefix is less than the requested prefix bits has already been accounted for in isNetworkChangedByPrefix
			//so we are not handling that here
			if(!hasBits) {
				return creator.createSegment(lower, upper, null);
			}
			return creator.createSegment(lower, upper, segmentPrefixLength);
		}
		return hasBits ? creator.createSegment(lower, segmentPrefixLength) : creator.createSegment(lower);
	}
	@Override
	public boolean isPrefixBlock() {
		return (isPrefixed() && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) || super.isPrefixBlock();
	}
	protected boolean isNetworkChangedByPrefix(Integer bits, boolean withPrefixLength) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		withPrefixLength &= hasBits;
		boolean thisHasPrefix = isPrefixed();
		if(withPrefixLength != thisHasPrefix) {
			return true;
		}
		if(!hasBits || bits != getDivisionPrefixLength()) {
			return true;
		}
		return
			//this call differs from the host side.  On the host side, we check that the network portion is 0
			//on the network side, we check that the host side is the full range, not 0.  
			//This means that any resulting network section is the same regardless of whether a prefix is used: we don't need a prefix.
			!containsPrefixBlock(bits);
	}
	
	protected boolean isNetworkChangedByPrefixNonNull(int prefixBitCount) {
		return !isPrefixed() || prefixBitCount != getDivisionPrefixLength() || !containsPrefixBlock(prefixBitCount);
	}
	
	/**
	 * used by constructors of IPAddressSection, see {@link IPAddress#getNetworkSection(int, boolean)}
	 */
	public IPAddressSegment toNetworkSegment(Integer segmentPrefixLength) {
		return toNetworkSegment(segmentPrefixLength, true);
	}
	
	/**
	 * used by getNetworkSection and by constructors of IPAddressSection, see {@link IPAddress#getNetworkSection(int, boolean)}
	 */
	public abstract IPAddressSegment toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength);
	protected <S extends IPAddressSegment> S toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength, AddressSegmentCreator<S> creator) {
		int newLower = getSegmentValue();
		int newUpper = getUpperSegmentValue();
		boolean hasPrefLen = segmentPrefixLength != null;
		if(hasPrefLen) {
			int mask = getSegmentNetworkMask(segmentPrefixLength);
			newLower &= mask;
			newUpper |= getSegmentHostMask(segmentPrefixLength);
		}
		withPrefixLength = withPrefixLength && hasPrefLen;
		if(newLower != newUpper) {
			//note that the case where our segmentPrefix is less than the requested prefix bits has already been accounted for in isNetworkChangedByPrefix
			//so we are not handling that here
			if(!withPrefixLength) {
				return creator.createSegment(newLower, newUpper, null);
			}
			return creator.createSegment(newLower, newUpper, segmentPrefixLength);
		}
		return withPrefixLength ? creator.createSegment(newLower, segmentPrefixLength) : creator.createSegment(newLower);
	}
	
	/**
	 * used by getHostSection, see {@link IPAddress#getHostSection(int)}
	 */
	public abstract IPAddressSegment toHostSegment(Integer segmentPrefixLength);
	
	protected <S extends IPAddressSegment> S toHostSegment(Integer segmentPrefixLength, AddressSegmentCreator<S> creator) {
		// We need to use Masker:
		// For example, ipv4 0-4, masking with prefix length 7, should become 0-1, not 0-0
		// So you cannot do a straight mask of 0 and 4.
		int mask = (segmentPrefixLength == null) ? 0 : getSegmentHostMask(segmentPrefixLength);
		int lower = getSegmentValue();
		int upper = getUpperSegmentValue();
		Masker masker = maskRange(lower, upper, mask, getMaxValue());
		int newLower = (int) masker.getMaskedLower(lower, mask);
		int newUpper = (int) masker.getMaskedUpper(upper, mask);
		if(newLower != newUpper) {
			return creator.createSegment(newLower, newUpper, null);
		}
		return creator.createSegment(newLower);
	}
	
	protected boolean isHostChangedByPrefix(Integer bits) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		//a host segment has no prefix, so if this remains unchanged it must have no prefix length
		if(isPrefixed()) {
			return true;
		}
		int mask = !hasBits ? 0 : getSegmentHostMask(bits);
		//additionally, the value must match the value for the given network prefix length
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		return value != (value & mask) || upperValue != (upperValue & mask);
	}
	
	protected boolean isChangedBy(int newValue, int newUpperValue, Integer segmentPrefixLength) throws IncompatibleAddressException {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		return value != newValue ||
				upperValue != newUpperValue ||
						(isPrefixed() ? !getSegmentPrefixLength().equals(segmentPrefixLength) : (segmentPrefixLength != null));
	}
	
	protected static Masker maskRange(long value, long upperValue, long maskValue, long maxValue) {
		return AddressDivision.maskRange(value, upperValue, maskValue, maxValue);
	}
	
	public MaskResult maskRange(int maskValue) {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		Masker masker = AddressDivision.maskRange(value, upperValue, maskValue, getMaxSegmentValue());
		return new MaskResult(value, upperValue, maskValue, masker);
	}
	
	protected static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue, long maxValue) {
		return AddressDivision.bitwiseOrRange(value, upperValue, maskValue, maxValue);
	}
	public BitwiseOrResult bitwiseOrRange(int maskValue) {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		BitwiseOrer orer = AddressDivision.bitwiseOrRange(value, upperValue, maskValue, getMaxSegmentValue());
		return new BitwiseOrResult(value, upperValue, maskValue, orer);
	}
	
	/**
	 * If this segment represents a range of values, returns a segment representing just the lowest value in the range, otherwise returns this.
	 * @return
	 */
	@Override
	public abstract IPAddressSegment getLower();
	
	/**
	 * If this segment represents a range of values, returns a segment representing just the highest value in the range, otherwise returns this.
	 * @return
	 */
	@Override
	public abstract IPAddressSegment getUpper();
	
	protected static <S extends IPAddressSegment> S getLowestOrHighest(S original, AddressSegmentCreator<S> segmentCreator, boolean lowest) {
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(!original.isMultiple() && !(isAllSubnets && original.isPrefixed())) {
			return original;
		}
		return segmentCreator.createSegment(lowest ? original.getSegmentValue() : original.getUpperSegmentValue(), 
				isAllSubnets ? null : original.getSegmentPrefixLength());
	}
	@Override
	public abstract Iterable<? extends IPAddressSegment> getIterable();
	@Override
	public abstract Iterator<? extends IPAddressSegment> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> spliterator();
	@Override
	public abstract Stream<? extends IPAddressSegment> stream();
	/**
	 * Iterates through the individual prefix blocks.
	 * <p>
	 * If the series has no prefix length, then this is equivalent to {@link #iterator()}
	 */
	public abstract Iterator<? extends IPAddressSegment> prefixBlockIterator();
	/**
	 * Partitions and traverses through the individual prefix blocks of this segment for its prefix length.
	 * 
	 * @return
	 */
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixBlockSpliterator();
	/**
	 * Returns a sequential stream of the individual prefix blocks of this segment.  For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * 
	 * @return
	 */
	public abstract Stream<? extends IPAddressSegment> prefixBlockStream();
	/**
	 * Iterates through the individual prefixes.
	 * <p>
	 * If the series has no prefix length, then this is equivalent to {@link #iterator()}
	 */
	public abstract Iterator<? extends IPAddressSegment> prefixIterator();
	/**
	 * Partitions and traverses through the individual prefixes of this segment for its prefix length.
	 * 
	 * @return
	 */
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixSpliterator();
	protected static <S extends IPAddressSegment> AddressComponentSpliterator<S> prefixSpliterator(
			S seg, int segPrefLength,
			IPAddressCreator<?, ?, ?, S, ?> creator,
			Supplier<Iterator<S>> iteratorProvider) {
		int bitCount = seg.getBitCount();
		int shiftAdjustment = bitCount - segPrefLength;
		int shiftMask, upperShiftMask;
		if(shiftAdjustment > 0) {
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftMask = ~0;
			upperShiftMask = 0;
		}
		int originalValue = seg.getSegmentValue();
		int originalUpperValue = seg.getUpperSegmentValue();
		int originalValuePrefix = originalValue >>> shiftAdjustment;
		int originalUpperValuePrefix = originalUpperValue >>> shiftAdjustment;
		Integer segPrefixLength = IPAddressSection.cacheBits(segPrefLength);
		IntBinaryIteratorProvider<S> subIteratorProvider = (isLowest, isHighest, value, upperValue) -> {
			if(isLowest || isHighest) {
				value = isLowest ? originalValue : value << shiftAdjustment;
				upperValue = isHighest ?  originalUpperValue : ((upperValue << shiftAdjustment) | upperShiftMask);
				return iterator(null, value, upperValue, bitCount, creator, segPrefixLength, true, false);
			}
			return iterator(null, value << shiftAdjustment, upperValue << shiftAdjustment, bitCount, creator, segPrefixLength, true, true);
		};
		return createSegmentSpliterator(
				seg,
				originalValuePrefix,
				originalUpperValuePrefix,
				iteratorProvider,
				subIteratorProvider,
				(value, upperValue) -> {
					value = (value == originalValuePrefix) ? originalValue : value << shiftAdjustment;
					upperValue = (upperValue == originalUpperValuePrefix) ? 
							originalUpperValue : ((upperValue << shiftAdjustment) | upperShiftMask);
					return creator.createSegment(value, upperValue, segPrefLength);
				});
	}
	/**
	 * Returns a sequential stream of the individual prefixes of this segment.  For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * 
	 * @return
	 */
	public abstract Stream<? extends IPAddressSegment> prefixStream();
	/**
	 * Iterates through the individual prefix blocks according to the given segment prefix length.
	 * Any existing prefix length is disregarded.
	 */
	public abstract Iterator<? extends IPAddressSegment> prefixBlockIterator(int prefixLength);
	
	protected static <S extends IPAddressSegment> AddressComponentSpliterator<S> prefixBlockSpliterator(
			S seg, int segPrefLength,
			IPAddressCreator<?, ?, ?, S, ?> creator,
			Supplier<Iterator<S>> iteratorProvider) {
		int bitCount = seg.getBitCount();
		int shiftAdjustment = bitCount - segPrefLength;
		int shiftMask, upperShiftMask;
		if(shiftAdjustment > 0) {
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftMask = ~0;
			upperShiftMask = 0;
		}
		Integer segmentPrefixLength = IPAddressSection.cacheBits(segPrefLength);
		return createSegmentSpliterator(
				seg,
				seg.getSegmentValue() >>> shiftAdjustment,
				seg.getUpperSegmentValue() >>> shiftAdjustment,
				iteratorProvider,
				(isLowest, isHighest, value, upperValue) -> iterator(
							null,
							value << shiftAdjustment,
							(upperValue << shiftAdjustment) | upperShiftMask,
							bitCount,
							creator,
							segmentPrefixLength,
							true,
							true),
				(value, upperValue) -> creator.createSegment(
						value << shiftAdjustment,
						(upperValue << shiftAdjustment) | upperShiftMask,
						segmentPrefixLength));
	}
	/**
	 * Partitions and traverses through the individual prefix blocks for the given prefix length.
	 * 
	 * @return
	 */
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixBlockSpliterator(int prefixLength);
	/**
	 * Returns a sequential stream of the individual prefix blocks for the given prefix length.  For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * 
	 * @return
	 */
	public abstract Stream<? extends IPAddressSegment> prefixBlockStream(int prefixLength);
	public static int getBitCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BITS_PER_SEGMENT : IPv6Address.BITS_PER_SEGMENT;
	}
	public static int getByteCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
	}
	public static int getDefaultTextualRadix(IPVersion version) {
		return version.isIPv4() ? IPv4Address.DEFAULT_TEXTUAL_RADIX : IPv6Address.DEFAULT_TEXTUAL_RADIX;
	}
	@Override
	public boolean matches(int value) {
		return super.matches(value);
	}
	
	public boolean matchesWithPrefixMask(int value, Integer segmentPrefixLength) {
		return super.matchesWithPrefixMask(value, segmentPrefixLength);
	}
	
	@Override
	public boolean matchesWithMask(int value, int mask) {
		return super.matchesWithMask(value, mask);
	}
	
	@Override
	public boolean matchesWithMask(int lowerValue, int upperValue, int mask) {
		return super.matchesWithMask(lowerValue, upperValue, mask);
	}
	
	/**
	 * @return the same value as {@link #getCount()} as an integer
	 */
	@Override
	public int getValueCount() {
		return getUpperSegmentValue() - getSegmentValue() + 1;
	}
	
	/**
	 * Counts the number of prefixes in this address segment.
	 * <p>
	 * If this segment has no prefix length, this is equivalent to {@link #getValueCount()}
	 * 
	 * @return
	 */
	public int getPrefixValueCount() {
		Integer prefixLength = getSegmentPrefixLength();
		if(prefixLength == null) {
			return (int) getValueCount();
		}
		return getPrefixValueCount(this, prefixLength);
	}
	
	@Override
	public BigInteger getCount() {
		return BigInteger.valueOf(getValueCount());
	}
	
	@Override
	public BigInteger getPrefixCount(int segmentPrefixLength) {
		return BigInteger.valueOf(getPrefixValueCount(segmentPrefixLength));
	}
	
	@Override
	public int getPrefixValueCount(int segmentPrefixLength) {
		if(segmentPrefixLength < 0) {
			throw new PrefixLenException(this, segmentPrefixLength);
		}
		int bitCount = getBitCount();
		if(bitCount <= segmentPrefixLength) {
			return getValueCount();
		}
		int shiftAdjustment = bitCount - segmentPrefixLength;
		return (getUpperSegmentValue() >>> shiftAdjustment) - (getSegmentValue() >>> shiftAdjustment) + 1;
	}
	protected int highByte() {
		return highByte(getSegmentValue());
	}
	
	protected int lowByte() {
		return lowByte(getSegmentValue());
	}
	
	protected static int highByte(int value) {
		return value >> 8;
	}
	
	protected static int lowByte(int value) {
		return value & 0xff;
	}
	
	@Override
	public long getMaxValue() {
		return getMaxSegmentValue();
	}
	@Override
	public boolean isMultiple() {
		return getSegmentValue() != getUpperSegmentValue();
	}
	
	/**
	 * returns the lower value
	 */
	@Override
	public int getSegmentValue() {
		return value;
	}
	
	/**
	 * returns the upper value
	 */
	@Override
	public int getUpperSegmentValue() {
		return upperValue;
	}
	
	/**
	 * returns the lower value as a long, although for individual segments {@link #getSegmentValue()} provides the same value as an int
	 */
	@Override
	public long getDivisionValue() {
		return getSegmentValue();
	}
	
	/**
	 * returns the lower upper value as a long, although for individual segments {@link #getUpperSegmentValue()} provides the same value as an int
	 */
	@Override
	public long getUpperDivisionValue() {
		return getUpperSegmentValue();
	}
	
	@Override
	public abstract IPAddressSegment reverseBits(boolean perByte);
	
	@Override
	public abstract IPAddressSegment reverseBytes();
	/**
	 * @deprecated use {@link #withoutPrefixLength()} and {@link #toZeroHost()}
	 * @return
	 */
	@Deprecated
	public abstract IPAddressSegment removePrefixLength();
	/**
	 * Returns a segment with the same network bits as this segment, 
	 * but with the host bits changed to 0.
	 * <p>
	 * If there is no prefix length associated with this segment, returns an all-zero segment.
	 * <p>
	 * This is nearly equivalent to doing the mask (see {@link #maskRange(int)}) of this segment
	 * with the network mask for the given prefix length,
	 * but when applying a mask to a range of values you can have a non-sequential result.
	 * <p>
	 * With this method, if the resulting series has a range of values, 
	 * then the resulting series range boundaries will have host values of 0, 
	 * but not necessarily all the intervening values.
	 * <p>
	 * For instance, the 1-byte segment range 4-7 with prefix length 6, 
	 * when masked with 252 (the network mask) results in just the single value 4, matching the result of this method.
	 * The 1-byte segment range 4-8 with prefix length 6, 
	 * when masked with 252 results in the two non-sequential values, 4 and 8, 
	 * but the result of this method with prefix length 6 results in the range 4-8, the same as the original segment.
	 * <p>
	 * The default behaviour is that the resultant series will have the same prefix length.
	 * The resultant series will not have a prefix length if {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()} is {@link inet.ipaddr.AddressNetwork.PrefixConfiguration#ALL_PREFIXED_ADDRESSES_ARE_SUBNETS}. 
	 *
	 * @return
	 */
	public abstract IPAddressSegment toZeroHost();
	/**
	 * @deprecated use {@link #toZeroHost()} and {@link #withoutPrefixLength()}
	 * @param zeroed
	 * @return
	 */
	@Deprecated
	public abstract IPAddressSegment removePrefixLength(boolean zeroed);
	/**
	 * Returns a segment with the same values but without a prefix length.
	 * 
	 * @return
	 */
	public abstract IPAddressSegment withoutPrefixLength();
	
	protected static <S extends IPAddressSegment> S toZeroHost(S original, AddressSegmentCreator<S> creator) {
		if(original.isPrefixed()) {
			int lower = original.getSegmentValue();
			int upper = original.getUpperSegmentValue();
			Integer segmentPrefixLength = original.getSegmentPrefixLength();
			int mask = original.getSegmentNetworkMask(segmentPrefixLength);
			int newLower = lower & mask;
			int newUpper = upper & mask;
			boolean allPrefsSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
			if(allPrefsSubnets) {
				return creator.createSegment(newLower, newUpper, null);
			}
			if(newLower == lower && newUpper == upper) {
				return original;
			}
			return creator.createSegment(newLower, newUpper, segmentPrefixLength);
		} else if(original.isZero()) {
			return original;
		}
		return creator.createSegment(0, null);
	}
	
	protected static <S extends IPAddressSegment> S removePrefix(S original, boolean zeroed, AddressSegmentCreator<S> creator) {
		if(original.isPrefixed()) {
			int lower = original.getSegmentValue();
			int upper = original.getUpperSegmentValue();
			if(zeroed) {
				int maskBits = original.getSegmentNetworkMask(original.getSegmentPrefixLength());
				long value = original.getDivisionValue();
				long upperValue = original.getUpperDivisionValue();
				long maxValue = original.getMaxValue();
				Masker masker = maskRange(value, upperValue, maskBits, maxValue);
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(original, maskBits, "ipaddress.error.maskMismatch");
				}
				return creator.createSegment((int) masker.getMaskedLower(lower, maskBits), (int) masker.getMaskedUpper(upper, maskBits), null);
			}
			return creator.createSegment(lower, upper, null);
		}
		return original;
	}
	
	@Override
	public boolean isBoundedBy(int value) {
		return getUpperSegmentValue() < value;
	}
	
	public Integer getSegmentPrefixLength() {
		return getDivisionPrefixLength();
	}
	
	@Override
	public int hashCode() {
		return hash(getSegmentValue(), getUpperSegmentValue(), getBitCount());
	}
	
	static int hash(int lower, int upper, int bitCount) {
		return lower | (upper << bitCount);
	}
	protected boolean isSameValues(AddressSegment otherSegment) {
		//note that it is the range of values that matters, the prefix bits do not
		return getSegmentValue() == otherSegment.getSegmentValue() && getUpperSegmentValue() == otherSegment.getUpperSegmentValue();
	}
	public boolean prefixEquals(IPAddressSegment other) {
		Integer prefLength = getSegmentPrefixLength();
		if(prefLength == null) {
			return equals(other);
		}
		return prefixEquals(other, prefLength);
	}
	
	@Override
	public boolean prefixEquals(AddressSegment other, int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int shift = getBitCount() - prefixLength;
		if(shift <= 0) {
			return isSameValues(other);
		}
		return (other.getSegmentValue() >>> shift) == (getSegmentValue() >>> shift) && 
				(other.getUpperSegmentValue() >>> shift) == (getUpperSegmentValue() >>> shift);
	}
	
	/**
	 * Using the prefix length of this segment, or the whole segment if it has no prefix length,
	 * returns whether the prefix bit value ranges contain the same bits of the given segment.
	 * 
	 * 
	 * @param other
	 * @return
	 */
	public boolean prefixContains(IPAddressSegment other) {
		Integer prefLength = getSegmentPrefixLength();
		if(prefLength == null) {
			return equals(other);
		}
		return prefixContains(other, prefLength);
	}
	
	/**
	 * Returns whether the given prefix bit value ranges contain the same bits of the given segment.
	 * 
	 * @param other
	 * @param prefixLength
	 * @return
	 */
	public boolean prefixContains(IPAddressSegment other, int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int shift = getBitCount() - prefixLength;
		if(shift <= 0) {
			return contains(other);
		}
		return (other.getSegmentValue() >>> shift) >= (getSegmentValue() >>> shift) && 
				(other.getUpperSegmentValue() >>> shift) <= (getUpperSegmentValue() >>> shift);
	}
	/**
	 * 
	 * @param other
	 * @return whether this subnet segment contains the given address segment
	 */
	protected boolean containsSeg(AddressSegment other) {
		return other.getSegmentValue() >= getSegmentValue() && other.getUpperSegmentValue() <= getUpperSegmentValue();
	}
	/**
	 * 
	 * @param other
	 * @return whether this subnet segment overlaps the given address segment
	 */
	protected boolean overlapsSeg(AddressSegment other) {
		return other.getSegmentValue() <= getUpperSegmentValue() && other.getUpperSegmentValue() >= getSegmentValue();
	}
			
	@Override
	public boolean includesZero() {
		return getSegmentValue() == 0;
	}
	
	@Override
	public boolean includesMax() {
		return getUpperSegmentValue() == getMaxSegmentValue();
	}
	
	boolean containsPrefixBlock(int lowerVal, int upperVal, int divisionPrefixLen) {
		return isPrefixBlock(lowerVal, upperVal, divisionPrefixLen);
	}
	
	boolean containsSinglePrefixBlock(int lowerVal, int upperVal, int divisionPrefixLen) {
		return isSinglePrefixBlock(lowerVal, upperVal, divisionPrefixLen);
	}
	@Override
	protected String getDefaultSegmentWildcardString() {
		return Address.SEGMENT_WILDCARD_STR;
	}
	@Override
	public String toHexString(boolean with0xPrefix) {
		return toNormalizedString(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams);
	}
	@Override
	public String toNormalizedString() {
		return toNormalizedString(IPStringCache.canonicalSegmentParams);
	}
	public String toNormalizedString(IPStringOptions options) {
		IPAddressStringWriter<IPAddressStringDivisionSeries> params =  IPAddressSection.toIPParams(options);
		StringBuilder builder = new StringBuilder(params.getDivisionStringLength(this));
		return params.appendDivision(builder, this).toString();
	}
	
	protected static int toUnsignedStringLength(int value, int radix) {
		return AddressDivision.toUnsignedStringLength(value, radix);
	}
	
	protected static StringBuilder toUnsignedString(int value, int radix, StringBuilder appendable) {
		return toUnsignedStringCased(value, radix, 0, false, appendable);
	}
	void setStandardString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int originalLowerValue) {
		if(cachedString == null && isStandardString && originalLowerValue == getDivisionValue()) {
			cachedString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	void setWildcardString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int lowerValue) {
		if(cachedWildcardString == null && isStandardString && lowerValue == getDivisionValue() && lowerValue == getUpperDivisionValue()) {
			cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	
	void setStandardString(
			CharSequence addressStr, 
			boolean isStandardString,
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedString == null) {
			if(isSinglePrefixBlock()) {
				if(isStandardString && rangeLower == getDivisionValue()) {
					cachedString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
				}
			} else if(isFullRange()) {
				cachedString = IPAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue()) {
				long upper = getUpperDivisionValue();
				if(isPrefixed()) {
					upper &= getDivisionNetworkMask(getDivisionPrefixLength());
				}
				if(rangeUpper == upper) {
					cachedString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
				}
			}
		}
	}
	
	void setWildcardString(
			CharSequence addressStr, 
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedWildcardString == null) {
			if(isFullRange()) {
				cachedWildcardString = IPAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue() && rangeUpper == getUpperDivisionValue()) {
				cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
			}
		}
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.IPAddressConverter.DefaultAddressConverter;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSection.TriFunction;
import inet.ipaddr.format.IPAddressRange;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.sql.IPAddressSQLTranslator;
import inet.ipaddr.format.validate.IPAddressProvider;
import inet.ipaddr.format.validate.ParsedHost;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * A single IP address, or a subnet of multiple addresses.  Subnets have one or more segments that are a range of values.
 * <p>
 * IPAddress objects are immutable and cannot change values.  This also makes them thread-safe.
 * <p>
 * String creation:<br>
 * There are various methods used to construct standard address string such as {@link #toCanonicalString()} or {@link #toNormalizedString()}
 * <p>
 * There are also several public classes used to create customized IP address strings.
 * For single strings from an address or address section, you use {@link IPStringOptions} or {@link inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringOptions} along with {@link #toNormalizedString(IPAddressSection.IPStringOptions)}.
 * Or you use one of the methods like {@link #toCanonicalString()} which does the same.
 * <p>
 * For string collections from an address or address section, use {@link inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringBuilderOptions}, {@link inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringBuilderOptions}, {@link IPStringBuilderOptions} along with {@link #toStringCollection(IPAddressSection.IPStringBuilderOptions)} or {@link #toStrings(IPAddressSection.IPStringBuilderOptions)}.
 * Or you use one of the methods {@link #toStandardStringCollection()}, {@link #toAllStringCollection()}, {@link #toStandardStrings()}, {@link #toAllStrings()} which does the same.
 * <p>
 * To construct one from a {@link java.lang.String} use 
 * {@link inet.ipaddr.IPAddressString#toAddress()} or  {@link inet.ipaddr.IPAddressString#getAddress()}, {@link inet.ipaddr.IPAddressString#toHostAddress()} or {@link inet.ipaddr.IPAddressString#getHostAddress()}
 * 
 * @custom.core
 * @author sfoley
 * 
 */
/*
 * Internal details of how this works:
 * 
 * 1. Building single strings steps:
 * StringOptions, IPv6StringOptions provides options for a user to specify a single string to be produced for a given address or section of an address.
 *  When calling toNormalizedString, each is mapped to a single IPv4StringParams/IPv6StringParams/StringParams object used to construct the string.
 *  Each IPv4StringParams/IPv6StringParams/StringParams constructs a single string with its toString method
 *  
 * 
 * 2. Building string collection steps:
 *  IPv4StringBuilderOptions, IPv6StringBuilderOptions, IPStringBuilderOptions provides options to create a set of multiple strings from a single IP Address or section of an address.
 * 	toStringCollection constructs a IPv6StringBuilder/IPv4StringBuilder/IPAddressStringBuilder for that address section
 *  The builder translates the options to a series of IPv4StringParams/IPv6StringParams/StringParams in addAllVariations
 *  When the set is being created, it will use each IPv4StringParams/IPv6StringParams/StringParams object to construct each unique string, using their toString method
 * 
 * 
 * Non-public classes:
 * IPv6StringParams, IPv4StringParams and the base classes StringParams and IPAddressPartStringParams: 
 * 	Used by both single string creation or creating collections of strings, these are not public.
 * IPv6StringBuilder/IPv4StringBuilder/IPAddressStringBuilder, used to create collections of strings, are not public either
 *
 */
public abstract class IPAddress extends Address implements IPAddressSegmentSeries, IPAddressRange {
	private static final long serialVersionUID = 4L;
	/**
	 * @author sfoley
	 *
	 */
	public static enum IPVersion {
		IPV4,
		IPV6;
		
		public boolean isIPv4() {
			return this == IPV4;
		}
		
		public boolean isIPv6() {
			return this == IPV6;
		}
		
		@Override
		public String toString() {
			return isIPv4() ? "IPv4" : "IPv6";
		}
	}
	/**
	 * @custom.core
	 * @author sfoley
	 *
	 */
	public static interface IPAddressValueProvider extends AddressValueProvider {
		IPVersion getIPVersion();
		
		default Integer getPrefixLength() {
			return null;
		}
		
		default String getZone() {
			return null;
		}
	}
	public static final char PREFIX_LEN_SEPARATOR = '/';
	public static final String BINARY_STR_PREFIX = "0b";
	
	/**
	 * The default way by which addresses are converted, initialized to an instance of {@link DefaultAddressConverter}
	 */
	public static final IPAddressConverter DEFAULT_ADDRESS_CONVERTER = new DefaultAddressConverter();
	
	/* a Host representing the address, which is the one used to construct the address if the address was resolved from a Host.  
	 * Note this is different than if the Host was an address itself, in which case the Host holds a reference to the address
	 * but there is no backwards reference to the Host.
	 */
	HostName fromHost;
	
	/* a Host representing the canonical host for this address */
	private HostName canonicalHost;
	
	/**
	 * Represents an IP address or a set of addresses.
	 * @param section the address segments
	 */
	protected IPAddress(IPAddressSection section) {
		super(section);
	}
	
	protected IPAddress(Function<Address, AddressSection> supplier) {
		super(supplier);
	}
	/**
	 * Generates an IPAddressString object for this IPAddress object.
	 * <p>
	 * This same IPAddress object can be retrieved from the resulting IPAddressString object using {@link IPAddressString#getAddress()}
	 * <p>
	 * In general, users are intended to create IPAddress objects from IPAddressString objects, 
	 * while the reverse direction is generally not all that useful.
	 * <p>
	 * However, the reverse direction can be useful under certain circumstances.
	 * <p>
	 * Not all IPAddressString objects can be converted to IPAddress objects, 
	 * as is the case with IPAddressString objects corresponding to the types IPType.INVALID and IPType.EMPTY.
	 * <p>
	 * Not all IPAddressString objects can be converted to IPAddress objects without specifying the IP version, 
	 * as is the case with IPAddressString objects corresponding to the types IPType.PREFIX and  IPType.ALL.
	 * <p>
	 * So in the event you wish to store a collection of IPAddress objects with a collection of IPAddressString objects,
	 * and not all the IPAddressString objects can be converted to IPAddress objects, then you may wish to use a collection
	 * of only IPAddressString objects, in which case this method is useful.
	 * 
	 * @return an IPAddressString object for this IPAddress.
	 */
	@Override
	public IPAddressString toAddressString() {
		if(fromString == null) {
			IPAddressStringParameters params = createFromStringParams();
			fromString = new IPAddressString(toCanonicalString(), this, params); /* address string creation */
		}
		return getAddressfromString();
	}
	
	protected abstract IPAddressStringParameters createFromStringParams();
	
	protected IPAddressString getAddressfromString() {
		return (IPAddressString) fromString;
	}
	/**
	 * If this address was resolved from a host, returns that host.  Otherwise, does a reverse name lookup.
	 */
	public HostName toHostName() {
		HostName host = fromHost;
		if(host == null) {
			fromHost = host = toCanonicalHostName();
		}
		return host;
	}
	void cache(HostIdentifierString string) {
		if(string instanceof HostName) {
			fromHost = (HostName) string;
			fromString = new IPAddressString(fromHost.toString(), this, fromHost.validationOptions.addressOptions);
		} else if(string instanceof IPAddressString) {
			fromString = (IPAddressString) string;
		}
	}
	protected IPAddressProvider getProvider() {
		if(isPrefixed()) {
			if(getNetwork().getPrefixConfiguration().prefixedSubnetsAreExplicit() || !isPrefixBlock()) {
				return IPAddressProvider.getProviderFor(this, withoutPrefixLength()); 
			}
			return IPAddressProvider.getProviderFor(this, toZeroHost(true).withoutPrefixLength());
		}
		return IPAddressProvider.getProviderFor(this, this);
	}
	
	/**
	 * Does a reverse name lookup to get the canonical host name.
	 * Note that the canonical host name may differ on different systems, as it aligns with {@link InetAddress#getCanonicalHostName()}
	 * In particular, on some systems the loopback address has canonical host localhost and on others the canonical host is the same loopback address.
	 */
	public HostName toCanonicalHostName() {
		HostName host = canonicalHost;
		if(host == null) {
			if(isMultiple()) {
				throw new IncompatibleAddressException(this, "ipaddress.error.unavailable.numeric");
			}
			InetAddress inetAddress = toInetAddress();
			String hostStr = inetAddress.getCanonicalHostName();//note: this does not return ipv6 addresses enclosed in brackets []
			if(hostStr.equals(inetAddress.getHostAddress())) {
				//we got back the address, so the host is me
				host = new HostName(hostStr, new ParsedHost(hostStr, getProvider()));
				host.resolvedAddresses = new IPAddress[] {this};
			} else {
				//the reverse lookup succeeded in finding a host string
				//we might not be the default resolved address for the host, so we don't set that field
				host = new HostName(hostStr);
			}
		}
		return host;
	}
	
	@Override
	public abstract IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	/**
	 * Returns the address as an address section comprising all segments in the address.
	 * @return
	 */
	@Override
	public IPAddressSection getSection() {
		return (IPAddressSection) super.getSection();
	}
	@Override
	public IPAddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPAddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	
	/**
	 * Returns all the ways of breaking this address down into segments, as selected.
	 * @return
	 */
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return new IPAddressStringDivisionSeries[] { getSection() };
	}
	
	@Override
	public int getMaxSegmentValue() {
		return IPAddressSegment.getMaxSegmentValue(getIPVersion());
	}
	
	static int getMaxSegmentValue(IPVersion version) {
		return IPAddressSegment.getMaxSegmentValue(version);
	}
	
	@Override
	public BigInteger getNonZeroHostCount() {
		return getSection().getNonZeroHostCount();
	}
	@Override
	public int getBytesPerSegment() {
		return IPAddressSegment.getByteCount(getIPVersion());
	}
	
	static int getBytesPerSegment(IPVersion version) {
		return IPAddressSegment.getByteCount(version);
	}
	
	@Override
	public int getBitsPerSegment() {
		return IPAddressSegment.getBitCount(getIPVersion());
	}
	
	static int getBitsPerSegment(IPVersion version) {
		return IPAddressSegment.getBitCount(version);
	}
	
	@Override
	public int getByteCount() {
		return getSection().getByteCount();
	}
	
	public static int getByteCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BYTE_COUNT : IPv6Address.BYTE_COUNT;
	}
	
	public static int getSegmentCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.SEGMENT_COUNT : IPv6Address.SEGMENT_COUNT;
	}
	
	public static int getBitCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BIT_COUNT : IPv6Address.BIT_COUNT;
	}
	protected abstract IPAddress convertArg(IPAddress arg) throws AddressConversionException;
	
	/**
	 * Finds the lowest and highest single-valued address from the given addresses and subnets and this one,
	 * calling the given BiFunction with the lowest as first argument and the highest as second.
	 * It returns the result returned from the call to the BiFunction.
	 * <p>
	 * For instance, given the IPv4 addresses 1.2.0.0/16 and 1.3.4.5, the lowest is 1.2.0.0 and the highest is 1.3.4.5.
	 * Given the addresses 1.2.0.0/16 and 1.1.4.5, the lowest is 1.1.4.5 and the highest is 1.2.255.255.
	 * <p>
	 * If one of the given addresses or subnets is a different version than this, 
	 * then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * This can be useful for methods that require a range as input, 
	 * like {@link IPAddress#spanWithPrefixBlocks(IPAddress)}, {@link IPAddress#spanWithSequentialBlocks(IPAddress)}, 
	 * {@link IPAddress#coverWithPrefixBlock(IPAddress)}, or {@link IPAddress#toSequentialRange(IPAddress)}.<p>
	 * For instance, to cover multiple addresses with a prefix block:<br><code>
	 * IPAddress coveringAddress = address0.applyToBounds(IPAddress::coverWithPrefixBlock, address1, address2, address3, ...);
	 * </code>
	 */
	public <V> V applyToBounds(BiFunction<? super IPAddress, ? super IPAddress, V> func, IPAddress ...series) {
		AddressComparator lowComparator = Address.ADDRESS_LOW_VALUE_COMPARATOR;
		AddressComparator highComparator = Address.ADDRESS_HIGH_VALUE_COMPARATOR;
		IPAddress lowest = this;
		IPAddress highest = this;
		for(int i = 0; i < series.length; i++) {
			IPAddress next = series[i];
			if(next == null) {
				continue;
			}
			next = convertArg(next);
			if(lowComparator.compare(next, lowest) < 0) {
				lowest = next;
			}
			if(highComparator.compare(next, highest) > 0) {
				highest = next;
			}
		}
		return func.apply(lowest.getLower(), highest.getUpper());
	}
	
	@Override
	public abstract IPAddress getLowerNonZeroHost();
	@Override
	public abstract IPAddress getLower();
	
	@Override
	public abstract IPAddress getUpper();
	
	@Override
	public abstract IPAddress reverseBits(boolean perByte);
	
	@Override
	public abstract IPAddress reverseBytes();
	
	@Override
	public abstract IPAddress reverseBytesPerSegment();
	
	@Override
	public abstract IPAddress reverseSegments();
	
	@Override
	public abstract Iterator<? extends IPAddress> iterator();
	
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> spliterator();
	@Override
	public abstract Stream<? extends IPAddress> stream();
	@Override
	public abstract Iterator<? extends IPAddress> nonZeroHostIterator();
	@Override
	public abstract Iterator<? extends IPAddress> prefixIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> prefixSpliterator();
	@Override
	public abstract Stream<? extends IPAddress> prefixStream();
		
	@Override
	public abstract Iterator<? extends IPAddress> prefixBlockIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends IPAddress> prefixBlockStream();
		
	@Override
	public abstract Iterator<? extends IPAddress> blockIterator(int segmentCount);
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> blockSpliterator(int segmentCount);
	@Override
	public abstract Stream<? extends IPAddress> blockStream(int segmentCount);
	
	@Override
	public Iterator<? extends IPAddress> sequentialBlockIterator() {
		return blockIterator(getSequentialBlockIndex());
	}
	@Override
	public AddressComponentSpliterator<? extends IPAddress> sequentialBlockSpliterator() {
		return blockSpliterator(getSequentialBlockIndex());
	}
	@Override
	public Stream<? extends IPAddress> sequentialBlockStream() {
		return blockStream(getSequentialBlockIndex());
	}
		
	@Override
	public BigInteger getSequentialBlockCount() {
		return getSection().getSequentialBlockCount();
	}
	
	/**
	 * @return an object to iterate over the individual addresses represented by this object.
	 */
	@Override
	public abstract Iterable<? extends IPAddress> getIterable();
	@Override
	public abstract IPAddress increment(long increment) throws AddressValueException;
	@Override
	public abstract IPAddress incrementBoundary(long increment) throws AddressValueException;
	
	@Override
	public boolean isIPAddress() {
		return true;
	}
	@Override
	public IPAddress toIPAddress() {
		return this;
	}
	public boolean isIPv4() {
		return false;
	}
	
	public boolean isIPv6(){
		return false;
	}
	
	@Override
	public IPVersion getIPVersion() {
		return getSection().getIPVersion();
	}
	
	/**
	 * If this address is IPv4, or can be converted to IPv4, returns that {@link IPv4Address}.  Otherwise, returns null.
	 * 
	 * @see #isIPv4Convertible()
	 * @return the address
	 */
	public IPv4Address toIPv4() {
		return null;
	}
	
	/**
	 * 
	 * @return If this address is IPv6, or can be converted to IPv6, returns that {@link IPv6Address}.  Otherwise, returns null.
	 * 
	 * @see #isIPv6Convertible()
	 * @return the address
	 */
	public IPv6Address toIPv6() {
		return null;
	}
	/**
	 * Determines whether this address can be converted to IPv4, if not IPv4 already.  
	 * Override this method to convert in your own way.  If IPv6, the default behaviour
	 * is to convert by IPv4 mapping, see {@link IPv6Address#isIPv4Mapped()}
	 * 
	 * You should also override {@link #toIPv4()} to match the conversion.
	 * 
	 * This method returns true for all IPv4 addresses.
	 * 
	 * @return
	 */
	public abstract boolean isIPv4Convertible();
	/**
	 * Determines whether an address can be converted to IPv6, if not IPv6 already. 
	 * Override this method to convert in your own way.  The default behaviour
	 * is to convert by IPv4 mapping, see {@link IPv4Address#getIPv4MappedAddress()}
	 * 
	 * You should also override {@link #toIPv6()} to match the conversion.
	 * 
	 * This method returns true for all IPv6 addresses.
	 * 
	 * @return
	 */
	public abstract boolean isIPv6Convertible();
	
	/**
	 * Returns whether the address is link local, whether unicast or multicast.
	 * 
	 * @see java.net.InetAddress#isLinkLocalAddress()
	 */
	public abstract boolean isLinkLocal();
	/**
	 * Returns true if the address is link local, site local, organization local, administered locally, or unspecified.
	 * This includes both unicast and multicast.
	 */
	@Override
	public abstract boolean isLocal();
	
	/**
	 * The unspecified address is the address that is all zeros.
	 * 
	 * @return
	 */
	public boolean isUnspecified() {
		return isZero();
	}
	
	/**
	 * Returns whether this address is the address which binds to any address on the local host.
	 * This is the address that has the value of 0, aka the unspecified address.
	 * 
	 * @see java.net.InetAddress#isAnyLocalAddress()
	 */
	public boolean isAnyLocal() {
		return isZero();
	}
	/**
	 * @see java.net.InetAddress#isLoopbackAddress()
	 */
	public abstract boolean isLoopback();
	/**
	 * Converts the highest value of this address to an InetAddress.
	 * If this consists of just a single address and not a subnet, this is equivalent to {@link #toInetAddress()}
	 */
	public InetAddress toUpperInetAddress() {
		return getUpper().toInetAddress();
	}
	
	/**
	 * Converts the lowest value of this address to an InetAddress
	 */
	public InetAddress toInetAddress() {
		return getSection().toInetAddress(this);
	}
	protected InetAddress toInetAddressImpl() {
		try {
			return InetAddress.getByAddress(getSection().getBytesInternal());
		} catch(UnknownHostException e) { /* will never reach here */ return null; }
	}
	
	/**
	 * Creates a sequential range instance from the lowest and highest addresses in this subnet
	 * <p>
	 * The two will represent the same set of individual addresses if and only if {@link #isSequential()} is true.
	 * To get a series of ranges that represent the same set of individual addresses use the {@link #sequentialBlockIterator()} (or {@link #prefixIterator()}),
	 * and apply this method to each iterated subnet.
	 * <p>
	 * If this represents just a single address then the returned instance covers just that single address as well.
	 * 
	 * @return
	 */
	@Override
	public abstract IPAddressSeqRange toSequentialRange();
	/**
	 * Creates a sequential range instance from this and the given address, 
	 * spanning from the lowest to the highest addresses in the two subnets
	 * <p>
	 * If the other address is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * When you have multiple subnets, create a range from lowest to highest with:<br>
	 * <code>
	 * IPAddressSeqRange range = subnet0.applyToBounds(IPAddress::toSequentialRange, subnet1, subnet2, ...);
	 * </code>
	 * <p>
	 * See {@link #applyToBounds(java.util.function.BiFunction, IPAddress...)}
	 * 
	 * @deprecated use {@link #spanWithRange(IPAddress)}
	 * @param other
	 * @return
	 */
	@Deprecated
	public abstract IPAddressSeqRange toSequentialRange(IPAddress other) throws AddressConversionException;
	
	public boolean matches(IPAddressString otherString) {
		//before converting otherString to an address object, check if the strings match
		if(isFromSameString(otherString)) {
			return true;
		}
		IPAddress otherAddr = otherString.getAddress();
		return otherAddr != null && isSameAddress(otherAddr);
	}
	@Override
	protected boolean isFromSameString(HostIdentifierString other) {
		if(fromString != null && other instanceof IPAddressString) {
			IPAddressString fromString = (IPAddressString) this.fromString;
			IPAddressString otherString = (IPAddressString) other;
			return (fromString == otherString || 
					(fromString.fullAddr.equals(otherString.fullAddr) &&
					// We do not call equals() on the validation options, this is intended as an optimization,
					// and probably better to avoid going through all the validation options here
					fromString.validationOptions == otherString.validationOptions));
		}
		return false;
	}
	
	/**
	 * Returns true if this address overlaps the given address or subnet
	 * 
	 * @param other
	 * @return
	 */
	@Override
	public boolean overlaps(IPAddress other) {
		return super.overlaps(other);
	}
	
	/**
	 * Returns true if this address overlaps the given sequential range
	 * 
	 * @param other
	 * @return
	 */
	@Override
	public boolean overlaps(IPAddressSeqRange other) {
		return other.overlaps(this);
	}
	
	/**
	 * Returns whether this contains all values of the given address or subnet
	 * <p>
	 * Implements the same method in {@link IPAddressRange}.
	 * 
	 * @param other
	 * @return
	 */
	@Override
	public boolean contains(IPAddress other) {
		return super.contains(other);
	}
	/**
	 * Returns whether this address contains the non-zero host addresses in the other address or subnet
	 * 
	 * @param other
	 * @return
	 */
	public boolean containsNonZeroHosts(IPAddress other) {
		if(other == this) {
			return true;
		}
		return getSection().containsNonZeroHosts(other.getSection());
	}
	
	/**
	 * Indicates where an address sits relative to the subnet ordering.
	 * <p>
	 * For more details, see the equivalent method {@link #enumerate(Address)}.
	 * This method satisfies the implementation of {@link IPAddressRange}.
	 * 
	 */
	@Override
	public abstract BigInteger enumerate(IPAddress other);
	/**
	 * Returns whether the prefix of this address contains all values of the same bits in the given address or subnet
	 * 
	 * @param other
	 * @return
	 */
	public boolean prefixContains(IPAddress other) {
		if(other == this) {
			return true;
		}
		return getSection().prefixContains(other.getSection());
	}
	
	/**
	 * Returns whether this address has a prefix length and if so, whether the host section is zero for this address or all addresses in this subnet.
	 * If the host section is zero length (there are no host bits at all), returns false.
	 * 
	 * @return
	 */
	public boolean isZeroHost() {
		return getSection().isZeroHost();
	}
	
	/**
	 * Returns whether the host is zero for the given prefix length for this address or all addresses in this subnet.
	 * If this address already has a prefix length, then that prefix length is ignored.
	 * If the host section is zero length (there are no host bits at all), returns false.
	 * 
	 * @return
	 */
	public boolean isZeroHost(int networkPrefixLength) {
		return getSection().isZeroHost(networkPrefixLength);
	}
	@Override
	public boolean contains(IPAddressSeqRange otherRange) {
		return otherRange.isContainedBy(this);
	}
	/**
	 * Applies the mask to this address and then compares values with the given address
	 * 
	 * @param mask
	 * @param other
	 * @return
	 */
	public boolean matchesWithMask(IPAddress other, IPAddress mask) {
		return getSection().matchesWithMask(other.getSection(), mask.getSection());
	}
	//////////////// string creation below ///////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Allows for the creation of a normalized string without creating a full IP address object first.
	 * Instead you can implement the {@link IPAddressValueProvider} interface in whatever way is most efficient.
	 * The string is appended to the provided {@link StringBuilder} instance.
	 * 
	 * @param provider
	 * @param builder
	 */
	public static void toNormalizedString(IPAddressValueProvider provider, StringBuilder builder) {
		IPVersion version = provider.getIPVersion();
		if(version.isIPv4()) {
			toNormalizedString(defaultIpv4Network().getPrefixConfiguration(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), IPv4Address.SEGMENT_COUNT,  IPv4Address.BYTES_PER_SEGMENT,  IPv4Address.BITS_PER_SEGMENT,  IPv4Address.MAX_VALUE_PER_SEGMENT,  IPv4Address.SEGMENT_SEPARATOR,  IPv4Address.DEFAULT_TEXTUAL_RADIX, null, builder);
		} else if(version.isIPv6()) {
			toNormalizedString(defaultIpv6Network().getPrefixConfiguration(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), IPv6Address.SEGMENT_COUNT, IPv6Address.BYTES_PER_SEGMENT, IPv6Address.BITS_PER_SEGMENT, IPv6Address.MAX_VALUE_PER_SEGMENT, IPv6Address.SEGMENT_SEPARATOR, IPv6Address.DEFAULT_TEXTUAL_RADIX, provider.getZone(), builder);
		} else {
			throw new IllegalArgumentException();
		}
	}
	/**
	 * Allows for the creation of a normalized string without creating a full IP address object first.
	 * Instead you can implement the {@link IPAddressValueProvider} interface in whatever way is most efficient.
	 * 
	 * @param provider
	 */
	public static String toNormalizedString(IPAddressValueProvider provider) {
		IPVersion version = provider.getIPVersion();
		if(version.isIPv4()) {
			return IPv4Address.toNormalizedString(defaultIpv4Network(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength());
		} else if(version.isIPv6()) {
			return IPv6Address.toNormalizedString(defaultIpv6Network(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), provider.getZone());
		}
		throw new IllegalArgumentException();
	}
	/**
	 * Creates the normalized string for an address without having to create the address objects first.
	 */
	protected static String toNormalizedString(
			PrefixConfiguration prefixConfiguration,
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			Integer prefixLength,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			char separator,
			int radix,
			CharSequence zone) {
		int length = toNormalizedString(
				prefixConfiguration,
				lowerValueProvider,
				upperValueProvider,
				prefixLength,
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				segmentMaxValue,
				separator,
				radix,
				zone,
				null);
		StringBuilder builder = new StringBuilder(length);
		toNormalizedString(
				prefixConfiguration,
				lowerValueProvider,
				upperValueProvider,
				prefixLength,
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				segmentMaxValue,
				separator,
				radix,
				zone,
				builder);
		IPAddressSection.checkLengths(length, builder);
		return builder.toString();
	}
	protected static int toNormalizedString(
			PrefixConfiguration prefixConfiguration,
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			Integer prefixLength,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			char separator,
			int radix,
			CharSequence zone,
			StringBuilder builder) {
		int segmentIndex, count;
		segmentIndex = count = 0;
		boolean adjustByPrefixLength;
		if(prefixLength != null && prefixConfiguration.allPrefixedAddressesAreSubnets()) {
			if(prefixLength <= 0) {
				adjustByPrefixLength = true;
			} else {
				int totalBitCount = (bitsPerSegment == 8) ? segmentCount << 3 : ((bitsPerSegment == 16) ? segmentCount << 4 : segmentCount * bitsPerSegment);
				adjustByPrefixLength = prefixLength < totalBitCount;
			}
		} else {
			adjustByPrefixLength = false;
		}
		while(true) {
			Integer segmentPrefixLength = IPAddressSection.getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
			if(adjustByPrefixLength && segmentPrefixLength != null && segmentPrefixLength == 0) {
				if(builder == null) {
					count++;
				} else {
					builder.append('0');
				}
			} else {
				int value = 0, value2 = 0;
				if(lowerValueProvider == null) {
					value = upperValueProvider.getValue(segmentIndex);
				} else {
					value = lowerValueProvider.getValue(segmentIndex);
					if(upperValueProvider != null) {
						value2 = upperValueProvider.getValue(segmentIndex);
					}
				}
				if(lowerValueProvider == null || upperValueProvider == null) {
					if(adjustByPrefixLength && segmentPrefixLength != null) {
						value &= ~0 << (bitsPerSegment - segmentPrefixLength);
					}
					if(builder == null) {
						count += IPAddressSegment.toUnsignedStringLength(value, radix);
					} else {
						IPAddressSegment.toUnsignedString(value, radix, builder);
					}
				} else {
					if(adjustByPrefixLength && segmentPrefixLength != null) {
						int mask = ~0 << (bitsPerSegment - segmentPrefixLength);
						value &= mask;
						value2 &= mask;//255, mask is -2147483648, segmentPrefixLength is 7, bitsPer
					}
					if(value == value2) {
						if(builder == null) {
							count += IPAddressSegment.toUnsignedStringLength(value, radix);
						} else {
							IPAddressSegment.toUnsignedString(value, radix, builder);
						}
					} else {
						if(value > value2) {
							int tmp = value2;
							value2 = value;
							value = tmp;
						} 
						if(value == 0 && value2 == segmentMaxValue) {
							if(builder == null) {
								count += IPAddress.SEGMENT_WILDCARD_STR.length();
							} else {
								builder.append(IPAddress.SEGMENT_WILDCARD_STR);
							}
						} else {
							if(builder == null) {
								count += IPAddressSegment.toUnsignedStringLength(value, radix) + 
										IPAddressSegment.toUnsignedStringLength(value2, radix) + 
										IPAddress.RANGE_SEPARATOR_STR.length();
							} else {
								IPAddressSegment.toUnsignedString(value2, radix, IPAddressSegment.toUnsignedString(value, radix, builder).append(IPAddress.RANGE_SEPARATOR_STR));
							}
						}
					}
				}
			}
			if(++segmentIndex >= segmentCount) {
				break;
			}
			if(builder != null) {
				builder.append(separator);
			} // else counting the separators happens just once outside the loop, just below
		}
		if(builder == null) {
			count += segmentCount; // separators
			--count; // no ending separator
		}
		if(zone != null && zone.length() > 0) {
			if(builder == null) {
				count += zone.length() + 1;
			} else {
				builder.append(IPv6Address.ZONE_SEPARATOR).append(zone);
			}
		}
		if(prefixLength != null) {
			if(builder == null) {
				count += IPAddressSegment.toUnsignedStringLength(prefixLength, 10) + 1;
			} else {
				builder.append(IPAddress.PREFIX_LEN_SEPARATOR).append(prefixLength);
			}
		} 
		return count;
	}
	
	/**
	 * This produces a string with no compressed segments and all segments of full length,
	 * which is 4 characters for IPv6 segments and 3 characters for IPv4 segments.
	 * 
	 * Each address has a unique full string, not counting CIDR the prefix, which can give two equal addresses different strings.
	 */
	@Override
	public String toFullString() {
		return getSection().toFullString();
	}
	
	protected void cacheNormalizedString(String str) {
		getSection().cacheNormalizedString(str);
	}
	
	/**
	 * Produces a consistent subnet string that looks like 1.2.*.* or 1:2::/16
	 * 
	 * In the case of IPv4, this means that wildcards are used instead of a network prefix when a network prefix has been supplied.
	 * In the case of IPv6, when a network prefix has been supplied, the prefix will be shown and the host section will be compressed with ::.
	 */
	@Override
	public String toSubnetString() {
		return getSection().toSubnetString();
	}
	
	/**
	 * This produces a string similar to the normalized string but avoids the CIDR prefix.
	 * CIDR addresses will be shown with wildcards and ranges instead of using the CIDR prefix notation.
	 */
	@Override
	public String toNormalizedWildcardString() {
		return getSection().toNormalizedWildcardString();
	}
	
	/**
	 * This produces a string similar to the canonical string but avoids the CIDR prefix.
	 * Addresses with a network prefix length will be shown with wildcards and ranges instead of using the CIDR prefix length notation.
	 * IPv6 addresses will be compressed according to the canonical representation.
	 */
	@Override
	public String toCanonicalWildcardString() {
		return getSection().toCanonicalWildcardString();
	}
	
	/**
	 * This is similar to toNormalizedWildcardString, avoiding the CIDR prefix, but with compression as well.
	 */
	@Override
	public String toCompressedWildcardString() {
		return getSection().toCompressedWildcardString();
	}
	
	
	/**
	 * This is the same as the string from toNormalizedWildcardString except that 
	 * it uses {@link IPAddress#SEGMENT_SQL_WILDCARD} instead of {@link IPAddress#SEGMENT_WILDCARD} and also uses {@link IPAddress#SEGMENT_SQL_SINGLE_WILDCARD}
	 */
	@Override
	public String toSQLWildcardString() {
		 return getSection().toSQLWildcardString();
	}
	
	/**
	 * Returns a string with a CIDR network prefix length if this address has a network prefix length.
	 * For IPv6, the host section will be compressed with ::, for IPv4 the host section will be zeros.
	 * @return
	 */
	@Override
	public String toPrefixLengthString() {
		return getSection().toPrefixLengthString();
	}
	
	/**
	 * Returns a mixed string if it represents a convertible IPv4 address, returns the normalized string otherwise.
	 * @return
	 */
	public String toConvertedString() {
		return toNormalizedString();
	}
	
	/**
	 * Generates the Microsoft UNC path component for this address
	 * 
	 * @return
	 */
	public abstract String toUNCHostName();
	
	/**
	 * Generates the reverse DNS lookup string<p>
	 * For 8.255.4.4 it is 4.4.255.8.in-addr.arpa<br>
	 * For 2001:db8::567:89ab it is b.a.9.8.7.6.5.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa
	 * 
	 *
	 * @throws IncompatibleAddressException if this address is a subnet
	 * @return
	 */
	@Override
	public String toReverseDNSLookupString() {
		return getSection().toReverseDNSLookupString();
	}
	
	/**
	 * Writes this address as a single binary value with always the exact same number of characters
	 * <p>
	 * If this section represents a range of values not corresponding to a prefix, then this is printed as a range of two hex values.
	 */
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		return getSection().toBinaryString();
	}
	
	/**
	 * Writes this address as a single octal value with always the exact same number of characters, with or without a preceding 0 prefix.
	 * <p>
	 * If this section represents a range of values not corresponding to a prefix, then this is printed as a range of two hex values.
	 */
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {
		return getSection().toOctalString(with0Prefix);
	}
	
	/**
	 * Constructs a string representing this address according to the given parameters
	 * 
	 * @throws IncompatibleAddressException for cases in which the requested string cannot be produced, which can generally only occur with specific strings from specific subnets.
	 * 
	 * @param params the parameters for the address string
	 */
	@Override
	public String toNormalizedString(IPStringOptions params) {
		return getSection().toNormalizedString(params);
	}
	
	/**
	 * Returns at most a few dozen string representations:
	 * 
	 * -mixed (1:2:3:4:5:6:1.2.3.4)
	 * -full compressions (a:0:b:c:d:0:e:f or a::b:c:d:0:e:f or a:0:b:c:d::e:f)
	 * -full leading zeros (000a:0000:000b:000c:000d:0000:000e:000f)
	 * -all uppercase and all lowercase (a::a can be A::A)
	 * -combinations thereof
	 * 
	 * @return
	 */
	public String[] toStandardStrings() {
		return toStandardStringCollection().toStrings();
	}
	
	/**
	 * Produces almost all possible string variations
	 * <p>
	 * Use this method with care...  a single IPv6 address can have thousands of string representations.
	 * <p>
	 * Examples:
	 * <ul>
	 * <li>"::" has 1297 such variations, but only 9 are considered standard</li>
	 * <li>"a:b:c:0:d:e:f:1" has 1920 variations, but only 12 are standard</li>
	 * </ul>
	 * <p>
	 * Variations included in this method:
	 * <ul>
	 * <li>all standard variations from {@link #toStandardStrings()}</li>
	 * <li>adding a variable number of leading zeros (::a can be ::0a, ::00a, ::000a)</li>
	 * <li>choosing any number of zero-segments to compress (:: can be 0:0:0::0:0)</li>
	 * <li>mixed representation of all variations (1:2:3:4:5:6:1.2.3.4)</li>
	 * <li>all uppercase and all lowercase (a::a can be A::A)</li>
	 * <li>all combinations of such variations</li>
	 * </ul>
	 * Variations omitted from this method: mixed case of a-f, which you can easily handle yourself with String.equalsIgnoreCase
	 * <p>
	 * @return the strings
	 */
	public String[] toAllStrings() {
		return toAllStringCollection().toStrings();
	}
	
	/**
	 * Rather than using toAllStrings or StandardStrings, 
	 * you can use this method to customize the list of strings produced for this address
	 */
	public String[] toStrings(IPStringBuilderOptions options) {
		return toStringCollection(options).toStrings();
	}
	
	public IPAddressPartStringCollection toStandardStringCollection() {
		return getSection().toStandardStringCollection();
	}
	public IPAddressPartStringCollection toAllStringCollection() {
		return getSection().toAllStringCollection();
	}
	
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions options) {
		return getSection().toStringCollection(options);
	}
	
	public static String toDelimitedSQLStrs(String strs[]) {
		if(strs.length == 0) {
			return "";
		}
		StringBuilder builder = new StringBuilder();
		for(String str : strs) {
			builder.append('\'').append(str).append('\'').append(',');
		}
		return builder.substring(0, builder.length() - 1);
	}
	
	///////////////////// masks and subnets below ///////////////////////
	
	@Override
	public Integer getNetworkPrefixLength() {
		return getSection().getNetworkPrefixLength();
	}
	@Override
	public IPAddress getHostMask() {
		Integer prefLength = getNetworkPrefixLength();
		return getNetwork().getHostMask(prefLength == null ? 0 : prefLength);
	}
	@Override
	public IPAddress getNetworkMask() {
		Integer prefLength = getNetworkPrefixLength();
		return getNetwork().getNetworkMask(prefLength == null ? getBitCount() : prefLength);
	}
	
	@Override
	public boolean includesZeroHost() {
		return getSection().includesZeroHost();
	}
	
	@Override
	public boolean includesZeroHost(int networkPrefixLength) {
		return getSection().includesZeroHost(networkPrefixLength);
	}
	@Override
	public abstract IPAddress toZeroHost(int prefixLength);
	@Override
	public abstract IPAddress toZeroHost();
	
	protected abstract IPAddress toZeroHost(boolean boundariesOnly);
	
	@Override
	public abstract IPAddress toZeroNetwork();
	
	@Override
	public abstract IPAddress toMaxHost(int prefixLength);
	
	@Override
	public abstract IPAddress toMaxHost();
	
	@Override
	public boolean includesMaxHost() {
		return getSection().includesMaxHost();
	}
	
	@Override
	public boolean includesMaxHost(int networkPrefixLength) {
		return getSection().includesMaxHost(networkPrefixLength);
	}
	
	/** 
	 * Returns true if the network section of the address spans just a single value 
	 * <p>
	 * For example, return true for 1.2.3.4/16 and false for 1.2-3.3.4/16
	 */
	public boolean isSingleNetwork() {
		return getSection().isSingleNetwork();
	}
	/**
	 * Returns the smallest set of prefix blocks that spans both this and the supplied address or subnet.
	 * @param other
	 * @return
	 */
	protected static <T extends IPAddress> T[] getSpanningPrefixBlocks(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator,
			UnaryOperator<T> prefixAdder,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		T result = checkPrefixBlockContainment(first, other, prefixAdder);
		if(result != null) {
			T resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		List<IPAddressSegmentSeries> blocks = 
				IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, (orig, one, two) -> IPAddressSection.splitIntoPrefixBlocks(one, two));
		return blocks.toArray(arrayProducer.apply(blocks.size()));
	}
	
	private static <T extends IPAddress> T checkPrefixBlockContainment(
			T first,
			T other,
			UnaryOperator<T> prefixAdder) {
		if(first.contains(other)) {
			return checkPrefixBlockFormat(first, other, true, prefixAdder);
		} else if(other.contains(first)) {
			return checkPrefixBlockFormat(other, first, false, prefixAdder);
		}
		return null;
	}
	
	static <T extends IPAddressSegmentSeries> T checkPrefixBlockFormat(
			T container,
			T contained,
			boolean checkEqual,
			UnaryOperator<T> prefixAdder) {
		T result = null;
		if(container.isPrefixed() && container.isSinglePrefixBlock()) {
			result = container;
		} else if(checkEqual && contained.isPrefixed() && container.isMore(contained) == 0 && contained.isSinglePrefixBlock()) {
			result = contained;
		} else {
			result = prefixAdder.apply(container); // the functor is assignPrefixForSingleBlock, which returns null if cannot be a prefix block
		}
		return result;
	}
	
	protected static <T extends IPAddress, S extends IPAddressSegment> T[] getSpanningSequentialBlocks(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator,
			UnaryOperator<T> prefixRemover,
			IPAddressCreator<T, ?, ?, S, ?> creator) {
		T[] result = checkSequentialBlockContainment(first, other, prefixRemover, creator::createAddressArray);
		if(result != null) {
			return result;
		}
		SeriesCreator seriesCreator = creator::createSequentialBlockAddress;
		TriFunction<T, List<IPAddressSegmentSeries>> operatorFunctor = (orig, one, two) -> IPAddressSection.splitIntoSequentialBlocks(one, two, seriesCreator);
		List<IPAddressSegmentSeries> blocks = IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, operatorFunctor);
		return blocks.toArray(creator.createAddressArray(blocks.size()));
	}
	
	private static <T extends IPAddress> T[] checkSequentialBlockContainment(
			T first,
			T other,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		if(first.contains(other)) {
			return checkSequentialBlockFormat(first, other, true, prefixRemover, arrayProducer);
		} else if(other.contains(first)) {
			return checkSequentialBlockFormat(other, first, false, prefixRemover, arrayProducer);
		}
		return null;
	}
	
	static <T extends IPAddressSegmentSeries> T[] checkSequentialBlockFormat(
			T container,
			T contained,
			boolean checkEqual,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		T result = null;
		if(!container.isPrefixed()) {
			if(container.isSequential()) {
				result = container;
			}
		} else if(checkEqual && !contained.isPrefixed() && container.equals(contained)) {
			if(contained.isSequential()) {
				result = contained;
			}
		} else if(container.isSequential()) {
			result = prefixRemover.apply(container);
		}
		if(result != null) {
			T resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		return null;
	}
	/**
	 * Returns the subnet associated with the prefix length of this address.  If this address has no prefix length, this address is returned.
	 * <p>
	 * For example, if the address is 1.2.3.4/16 it returns the subnet 1.2.*.* /16
	 */
	@Override
	public abstract IPAddress toPrefixBlock();
	@Override
	public abstract IPAddress toPrefixBlock(int networkPrefixLength) throws PrefixLenException;
	/**
	 * Returns the equivalent CIDR address with a prefix length for which the address subnet block matches the range of values in this address.
	 * <p>
	 * If no such prefix length exists, returns null.
	 * <p>
	 * 
	 * Examples:<br>
	 * 1.2.3.4 returns 1.2.3.4/32<br>
	 * 1.2.*.* returns 1.2.0.0/16<br>
	 * 1.2.*.0/24 returns 1.2.0.0/16 <br>
	 * 1.2.*.4 returns null<br>
	 * 1.2.252-255.* returns 1.2.252.0/22<br>
	 * 1.2.3.4/x returns the same address<br>
	 * 
	 * @return
	 */
	@Override
	public IPAddress assignPrefixForSingleBlock() {
		Integer newPrefix = getPrefixLengthForSingleBlock();
		return newPrefix == null ? null : setPrefixLength(newPrefix, false);
	}
	/**
	 * Constructs an equivalent address with the smallest CIDR prefix possible (largest network),
	 * such that the range of values are a set of subnet blocks for that prefix.
	 * 
	 * @return
	 */
	@Override
	public IPAddress assignMinPrefixForBlock() {
		return setPrefixLength(getMinPrefixLengthForBlock(), false);
	}
	/**
	 * If this address is equivalent to the mask for a CIDR prefix block, it returns that prefix length.
	 * Otherwise, it returns null.
	 * A CIDR network mask is all 1 bits in the network section and then all 0 bits in the host section.
	 * A CIDR host mask is all 0 bits in the network section and then all 1 bits in the host section.
	 * The prefix is the length of the network section.
	 * <p>
	 * Also, keep in mind that the prefix length returned by this method is not equivalent to the prefix length used to construct this object.
	 * The prefix length used to construct indicates the network and host section of this address.  
	 * The prefix length returned here indicates the whether the value of this address can be used as a mask for the network and host
	 * section of any other address.  Therefore the two values can be different values, or one can be null while the other is not.
	 * <p>
	 * Just like the mask methods which use the lower value for masking,
	 * this method applies only to the lower value of the range if this address represents multiple values.
	 *
	 * @param network whether to check if we are a network mask or a host mask
	 * @return the prefix length corresponding to this mask, or null if there is no such prefix length
	 */
	public Integer getBlockMaskPrefixLength(boolean network) {
		return getSection().getBlockMaskPrefixLength(network);
	}
	/**
	 * Returns the number of consecutive trailing one or zero bits.
	 * If network is true, returns the number of consecutive trailing zero bits.
	 * Otherwise, returns the number of consecutive trailing one bits.
	 * <p>
	 * This method applies only to the lower value of the range if this address represents multiple values.
	 * 
	 * @param network
	 * @return
	 */
	public int getTrailingBitCount(boolean network) {
		return getSection().getTrailingBitCount(network);
	}
	
	/**
	 * Returns the number of consecutive leading one or zero bits.
	 * If network is true, returns the number of consecutive leading one bits.
	 * Otherwise, returns the number of consecutive leading zero bits.
	 * <p>
	 * This method applies only to the lower value of the range if this address represents multiple values.
	 * 
	 * @param network
	 * @return
	 */
	public int getLeadingBitCount(boolean network) {
		return getSection().getLeadingBitCount(network);
	}
	
	/**
	 * Returns the minimal-size prefix block that covers all the addresses spanning from this subnet to the given subnet.
	 * <p>
	 * If the other address is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * When you have multiple subnets, cover with:<br>
	 * <code>
	 * IPAddress block = subnet0.applyToBounds(IPAddress::coverWithPrefixBlock, subnet1, subnet2, ...);
	 * </code><p>
	 * See {@link #applyToBounds(java.util.function.BiFunction, IPAddress...)}
	 */
	public abstract IPAddress coverWithPrefixBlock(IPAddress other) throws AddressConversionException;
	/**
	 * Produces the list of prefix block subnets that span from this subnet to the given subnet.
	 * <p>
	 * If the other address is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * The resulting array is sorted from lowest address value to highest, regardless of the size of each prefix block.
	 * <p>
	 * From the list of returned subnets you can recover the original range (this to other) by converting each to IPAddressRange with {@link IPAddress#toSequentialRange()}
	 * and them joining them into a single range with {@link IPAddressSeqRange#join(IPAddressSeqRange...)}
	 * <p>
	 * When you have multiple subnets, span with:<br>
	 * <code>
	 * IPAddress blocks[] = subnet0.applyToBounds(IPAddress::spanWithPrefixBlocks, subnet1, subnet2, ...);
	 * </code><p>
	 * See {@link #applyToBounds(java.util.function.BiFunction, IPAddress...)}
	 * 
	 * @param other
	 * @return
	 */
	public abstract IPAddress[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException;
	
	/**
	 * Produces a list of sequential block subnets that span all values from this subnet to the given subnet.
	 * The span will cover the sequence of all addresses from the lowest address in both subnets to the highest address in both subnets.
	 * <p>
	 * Individual block subnets come in the form 1-3.1-4.5.6-8, however that particular subnet is not sequential since address 1.1.5.8 is in the subnet,
	 * the next sequential address 1.1.5.9 is not in the subnet, and a higher address 1.2.5.6 is in the subnet.
	 * Blocks are sequential when the first segment with a range of values is followed by segments that span all values.
	 * <p>
	 * If the other address is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * The resulting array is sorted from lowest address value to highest, regardless of the size of each prefix block.
	 * <p>
	 * From the list of returned subnets you can recover the original range (this and other) by converting each to IPAddressRange with {@link IPAddress#toSequentialRange()}
	 * and them joining them into a single range with {@link IPAddressSeqRange#join(IPAddressSeqRange...)}
	 * <p>
	 * When you have multiple subnets, span with:<br>
	 * <code>
	 * IPAddress blocks[] = subnet0.applyToBounds(IPAddress::spanWithSequentialBlocks, subnet1, subnet2, ...);
	 * </code><p>
	 * See {@link #applyToBounds(java.util.function.BiFunction, IPAddress...)}
	 * 
	 * @param other
	 * @return
	 */
	public abstract IPAddress[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException;
	
	protected List<? extends IPAddressSegmentSeries> spanWithBlocks(boolean prefixBlocks) {
		return spanWithBlocks(this, prefixBlocks);
	}
	
	static List<? extends IPAddressSegmentSeries> spanWithBlocks(IPAddressSegmentSeries orig, boolean prefixBlocks) {
		ArrayList<IPAddressSegmentSeries> list = new ArrayList<IPAddressSegmentSeries>();
		Iterator<? extends IPAddressSegmentSeries> iterator = orig.sequentialBlockIterator();
		while(iterator.hasNext()) {
			IPAddressSegmentSeries sequential = iterator.next();
			if(prefixBlocks) {
				Collections.addAll(list, sequential.spanWithPrefixBlocks());	
			} else {
				Collections.addAll(list, sequential);
			}
		}
		return list;
	}
	
	/**
	 * Produces an IPAddressRange instance that spans this subnet to the given subnet.
	 * <p>
	 * If the other address is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * When you have multiple subnets, span with:<br>
	 * <code>
	 * IPAddressSeqRange range = subnet0.applyToBounds(IPAddress::spanWithRange, subnet1, subnet2, ...);
	 * </code><p>
	 * See {@link #applyToBounds(java.util.function.BiFunction, IPAddress...)}
	 * 
	 * @param other
	 * @return
	 */
	public abstract IPAddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException;
	
	/**
	 * Merges this with the list of addresses to produce the smallest list of prefix blocks.
	 * <p>
	 * For the smallest list of subnets use {@link #mergeToSequentialBlocks(IPAddress...)}.
	 * <p>
	 * If any other address in the list is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()},
	 * which can result in AddressConversionException
	 * <p>
	 * The resulting array is sorted from lowest address value to highest, regardless of the size of each prefix block.
	 * <p>
	 * In version 5.3.1 and earlier, the result was sorted from single address to smallest blocks to largest blocks.
	 * For that ordering, sort with {@link IPAddressSegmentSeries#getPrefixLenComparator()}:<br>
	 * <code>Arrays.sort(result, IPAddressSegmentSeries.getPrefixLenComparator());</code>
	 * <p>
	 * The merging process works with sequential blocks.  
	 * CIDR prefix subnets have just a single sequential block, as does individual addresses.  
	 * So this method works efficiently for most conventionally-used subnets.
	 * <p>
	 * For example, the subnet ::*:*:*:1-ffff has 281474976710656 sequential blocks.
	 * Just like you should avoid iterating through such a large number of blocks, 
	 * you should avoid using this method to merge such a subnet, 
	 * rather than a subnet like ::1-ffff:*:*:*:* which has 1 sequential block, 
	 * or the subnet ::1-ffff:1-ffff:*:*:*:* which has 65535 sequential blocks.
	 * You can use {@link #getSequentialBlockCount()} to get the sequential block count.
	 * <p>
	 * There are alternatives ways to merge into prefix blocks available in this library.
	 * Typically this method is most efficient when merging CIDR prefix blocks and/or individual addresses,
	 * which is likely to be the case for most users most of the time.  
	 * It converts to CIDR prefix blocks prior to merging, if not CIDR prefix blocks or individual addresses already.
	 * <p>
	 * When merging a large number of blocks that are not prefix blocks nor individual addresses, 
	 * it may be more efficient to merge first and then convert to CIDR prefix blocks afterwards.
	 * You can use {@link #mergeToSequentialBlocks(IPAddress...)} to merge, 
	 * and then span each merged element in the result with {@link #spanWithPrefixBlocks()},
	 * giving the same result as this method.
	 * <p>
	 * Sequential ranges provide another option.
	 * You can convert to sequential blocks first with {@link #sequentialBlockIterator()}, 
	 * then convert each sequential block to {@link IPAddressSeqRange} with {@link #toSequentialRange()}, 
	 * then join those sequential ranges with {@link IPAddressSeqRange#join(IPAddressSeqRange...)}, 
	 * then convert them to CIDR prefix blocks with {@link IPAddressSeqRange#spanWithPrefixBlocks()},
	 * giving the same result as this method.
	 * <p>
	 * 
	 * @throws AddressConversionException
	 * @param addresses the addresses to merge with this
	 * @return
	 */
	public abstract IPAddress[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException;
	protected static List<IPAddressSegmentSeries> getMergedPrefixBlocks(IPAddressSegmentSeries sections[]) {
		return IPAddressSection.getMergedPrefixBlocks(sections);
	}
	private static final IPv6Address EMPTY_IPV6_ADDRESS[] = {};
	private static final IPv4Address EMPTY_IPV4_ADDRESS[] = {};
	public static class DualIPv4Pv6Arrays {
		public final IPv4Address addressesIPv4[];
		public final IPv6Address addressesIPv6[];
		
		DualIPv4Pv6Arrays(IPv4Address addressesIPv4[], IPv6Address addressesIPv6[]) {
			this.addressesIPv4 = addressesIPv4;
			this.addressesIPv6 = addressesIPv6;
		}
	}
	/**
	 * merges the given set of IP addresses and subnets into a minimal number of prefix blocks.
	 * 
	 * This function complements the MergeToPrefixBlock methods of each IP address type.
	 * Those instance methods attempt to convert arguments that do not match the IP version of the method receiver, while this function does not.
	 * This static method merges every non-null argument into one of the two returned slices.
	 * 
	 * @param addresses
	 * @return
	 */
	public static DualIPv4Pv6Arrays mergeToDualSequentialBlocks(IPAddress ...addresses) {
		Function<IPAddressSegmentSeries[], List<IPAddressSegmentSeries>> merger = (series) -> {
			SeriesCreator seriesCreator = ((IPAddress) series[0]).getSequentialSeriesCreator();
			return IPAddressSection.getMergedSequentialBlocks(series, seriesCreator);
		};
		return mergeToBlocks(addresses, merger);
	}
	
	protected abstract SeriesCreator getSequentialSeriesCreator();
	
	/**
	 * merges the given set of IP addresses and subnets into a minimal number of prefix blocks.
	 * 
	 * This function complements the MergeToPrefixBlock methods of each IP address type.
	 * Those instance methods attempt to convert arguments that do not match the IP version of the method receiver, while this function does not.
	 * This static method merges every non-null argument into one of the two returned slices.
	 * 
	 * @param addresses
	 * @return
	 */
	public static DualIPv4Pv6Arrays mergeToDualPrefixBlocks(IPAddress ...addresses) {
		return mergeToBlocks(addresses, IPAddressSection::getMergedPrefixBlocks);
	}
	
	private static DualIPv4Pv6Arrays mergeToBlocks(
			IPAddress addresses[], 
			Function<IPAddressSegmentSeries[], List<IPAddressSegmentSeries>> merger) {
		ArrayList<IPAddress> ipv4List = null;
		ArrayList<IPAddress> ipv6List = null;
		for(int i = 0; i < addresses.length; i++) {
			IPAddress addr = addresses[i];
			if(addr != null) {
				if(addr.isIPv4()) {
					if(ipv4List == null) {
						ipv4List = new ArrayList<IPAddress>(addresses.length);
					}
					ipv4List.add(addr);
				} else if(addr.isIPv6()) {
					if(ipv6List == null) {
						ipv6List = new ArrayList<IPAddress>(addresses.length);
					}
					ipv6List.add(addr);
				}
			}
		}
		IPv4Address addressesIPv4[];
		if(ipv4List != null){
			List<IPAddressSegmentSeries> blocks = merger.apply(ipv4List.toArray(new IPAddressSegmentSeries[ipv4List.size()]));
			addressesIPv4 = blocks.toArray(new IPv4Address[blocks.size()]);
		} else {
			addressesIPv4 = EMPTY_IPV4_ADDRESS;
		}
		IPv6Address addressesIPv6[];
		if(ipv6List != null){
			List<IPAddressSegmentSeries> blocks = merger.apply(ipv6List.toArray(new IPAddressSegmentSeries[ipv6List.size()]));
			addressesIPv6 = blocks.toArray(new IPv6Address[blocks.size()]);
		} else {
			addressesIPv6 = EMPTY_IPV6_ADDRESS;
		}
		return new DualIPv4Pv6Arrays(addressesIPv4, addressesIPv6);
	}
	/**
	 * Merges this with the list of subnets to produce the smallest list of block subnets that are sequential.
	 * <p>
	 * Block subnets come in the form 1-3.1-4.5.6-8, however that subnet is not sequential since address 1.1.5.8 is in the subnet,
	 * the next sequential address 1.1.5.9 is not in the subnet, and a higher address 1.2.5.6 is in the subnet.
	 * Blocks are sequential when the first segment with a range of values is followed by segments that span all values.
	 * <p>
	 * This list will eliminate overlaps to produce the smallest list of sequential block subnets, which is the same size or smaller than the list of prefix blocks produced by {@link #mergeToPrefixBlocks(IPAddress...)}
	 * <p>
	 * If the incoming blocks are not sequential, the result could be a longer list, since the list is divided into sequential blocks before merging.
	 * <p>
	 * If any other address in the list is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()},
	 * which can result in AddressConversionException
	 * <p>
	 * The resulting array is sorted by lower address, regardless of the size of each prefix block.
	 * <p>
	 * In version 5.3.1 and earlier, the result was sorted from single address to smallest blocks to largest blocks.
	 * For that ordering, sort with {@link IPAddressSegmentSeries#getPrefixLenComparator()}:<br>
	 * <code>Arrays.sort(result, IPAddressSegmentSeries.getPrefixLenComparator());</code>
	 * <p>
	 * See the javadoc for {@link #mergeToPrefixBlocks(IPAddress...)} for some alternatives for merging subnets.
	 * 
	 * 
	 * @throws AddressConversionException
	 * @param addresses the addresses to merge with this
	 * @return
	 */
	public abstract IPAddress[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException;
	
	protected static <T extends IPAddress, S extends IPAddressSegment> List<IPAddressSegmentSeries> getMergedSequentialBlocks(IPAddressSegmentSeries sections[], IPAddressCreator<T, ?, ?, S, ?> creator) {
		return IPAddressSection.getMergedSequentialBlocks(sections, creator::createSequentialBlockAddress);
	}
	
	/**
	 * Produces the subnet whose addresses are found in both this and the given subnet argument, or null if no such addresses.
	 * <p>
	 * This is also known as the conjunction of the two sets of addresses.
	 * <p>
	 * If the address is not the same version, the default conversion will be applied using {@link #toIPv4()} or {@link #toIPv6()}, and it that fails, {@link AddressConversionException} will be thrown.
	 * <p>
	 * @param other
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 * @return the subnet containing the addresses found in both this and the given subnet
	 */
	public abstract IPAddress intersect(IPAddress other) throws AddressConversionException;
	
	/**
	 * Subtract the given subnet from this subnet, returning an array of subnets for the result (the subnets will not be contiguous so an array is required).
	 * <p>
	 * Computes the subnet difference, the set of addresses in this address subnet but not in the provided subnet.  This is also known as the relative complement of the given argument in this subnet.
	 * <p>
	 * If the address is not the same version, the default conversion will be applied using {@link #toIPv4()} or {@link #toIPv6()}, and it that fails, {@link AddressConversionException} will be thrown.
	 * <p>
	 * @param other
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 * @return the difference
	 */
	public abstract IPAddress[] subtract(IPAddress other) throws AddressConversionException;
	/**
	 * Equivalent to calling {@link #mask(IPAddress, boolean)} with the second argument as false.
	 *<p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * @param mask
	 * @return
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 */
	public abstract IPAddress mask(IPAddress mask) throws AddressConversionException, IncompatibleAddressException;
	
	/**
	 * Applies the given mask to all addresses represented by this IPAddress.
	 * The mask is applied to all individual addresses.
	 * Any existing prefix length is removed beforehand.  If the retainPrefix argument is true, then the existing prefix length will be applied to the result.
	 * <p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * If this represents multiple addresses, and applying the mask to all addresses creates a set of addresses
	 * that cannot be represented as a contiguous range within each segment, then {@link IncompatibleAddressException} is thrown.
	 * <p>
	 * @param mask
	 * @return
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 */
	public abstract IPAddress mask(IPAddress mask, boolean retainPrefix) throws AddressConversionException, IncompatibleAddressException;
	
	/**
	 * Applies the given mask to all addresses represented by this IPAddress while also applying the given prefix length at the same time.
	 * <p>
	 * Any existing prefix length is removed as the mask and new prefix length is applied to all individual addresses.
	 * <p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * If this represents multiple addresses, and applying the mask to all addresses creates a set of addresses
	 * that cannot be represented as a contiguous range within each segment, then {@link IncompatibleAddressException} is thrown.
	 * 
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 */
	public abstract IPAddress maskNetwork(IPAddress mask, int networkPrefixLength) throws AddressConversionException, IncompatibleAddressException;
	/**
	 * Equivalent to calling {@link #bitwiseOr(IPAddress, boolean)} with the second argument as false.
	 * <p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 @param mask
	 * @return
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 */
	public abstract IPAddress bitwiseOr(IPAddress mask) throws AddressConversionException, IncompatibleAddressException;
	/**
	 * Does the bitwise disjunction with this address.  Useful when subnetting.
	 * <p>
	 * The mask is applied to all individual addresses, similar to how the method {@link #mask(IPAddress, boolean)} applies the bitwise conjunction.
	 * Any existing prefix length is removed beforehand.  If the retainPrefix argument is true, then the existing prefix length will be applied to the result.
	 * <p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * If you wish to mask a section of the network, use {@link #bitwiseOrNetwork(IPAddress, int)}
	 * <p>
	 * For instance, you can get the broadcast address for a subnet as follows:
	 * <code>
	 * String addrStr = "1.2.3.4/16";
	 * IPAddress address = new IPAddressString(addrStr).getAddress();
	 * IPAddress hostMask = address.getNetwork().getHostMask(address.getNetworkPrefixLength());//0.0.255.255
	 * IPAddress broadcastAddress = address.bitwiseOr(hostMask); //1.2.255.255
	 * </code>
	 * 
	 * @param mask
	 * @param retainPrefix
	 * @return
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 */
	public abstract IPAddress bitwiseOr(IPAddress mask, boolean retainPrefix) throws AddressConversionException, IncompatibleAddressException;
	
	/**
	 * Does the bitwise disjunction with this address.  Useful when subnetting.
	 * <p>
	 * If the mask is a different version than this, then the default conversion is applied to the other address first using {@link #toIPv4()} or {@link #toIPv6()}
	 * <p>
	 * Any existing prefix length is dropped for the new prefix length and the mask is applied up to the end the new prefix length.
	 * It is similar to how the {@link #maskNetwork(IPAddress, int)} method does the bitwise conjunction.
	 * 
	 * @param mask
	 * @param networkPrefixLength the new prefix length for the address
	 * @return
	 * @throws IncompatibleAddressException if this is a range of addresses and applying the mask results in an address that cannot be represented as a contiguous range within each segment
	 * @throws AddressConversionException if the address argument could not be converted to the same address version as this
	 */
	public abstract IPAddress bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws AddressConversionException, IncompatibleAddressException;
	
	@Override @Deprecated
	public abstract IPAddress removePrefixLength();
	
	@Override @Deprecated
	public abstract IPAddress removePrefixLength(boolean zeroed);
	
	@Override
	public abstract IPAddress withoutPrefixLength();
	
	@Override
	public abstract IPAddress adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract IPAddress adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	/**
	 * Increases or decreases prefix length by the given increment.
	 * <p>
	 * When prefix length is increased, the bits moved within the prefix become zero.
	 * When the prefix is extended beyond the segment series boundary, it is removed.
	 * When a prefix length is decreased, the bits moved outside the prefix become zero,
	 * and if the entire host address contains the zero address, 
	 * then the resulting address is determined {@link IPAddressNetwork#getPrefixConfiguration()}.
	 * <p>
	 * For example, 1.2.0.0/16 adjusted by -8 becomes 1.0.0.0/8.<br>
	 * 1.2.0.0/16 adjusted by 8 becomes 1.2.0.0/24
	 * 
	 * @param adjustment
	 * @return
	 */
	@Override
	public abstract IPAddress adjustPrefixLength(int adjustment);
	@Override
	public abstract IPAddress adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	public abstract IPAddress setPrefixLength(int prefixLength);
	@Override
	public abstract IPAddress setPrefixLength(int prefixLength, boolean zeroed);
	
	/**
	 * Sets the prefix length while allowing the caller to control whether bits moved in or out of the prefix become zero, 
	 * and whether a zero host for the new prefix bits can be translated into a prefix block.  
	 * The latter behaviour only applies to the default prefix handling configuration,
	 * PREFIXED_ZERO_HOSTS_ARE_SUBNETS.  The methods  {@link #setPrefixLength(int, boolean)} and {@link #setPrefixLength(int)}
	 * use a value of true for zeroed and for zeroHostIsBlock.
	 * <p>
	 * For example, when zeroHostIsBlock is true, applying to 1.2.0.0 the prefix length 16 results in 1.2.*.*&#x2f;16 
	 * <p>
	 * Or if you start with 1.2.0.0&#x2f;24, setting the prefix length to 16 results in 
	 * a zero host followed by the existing prefix block, which is then converted to a full prefix block, 1.2.*.*&#x2f;16
	 * <p>
	 * When both zeroed and zeroHostIsBlock are true, applying the prefiix length of 16 to 1.2.4.0&#x2f;24 also results in 
	 * a zero host followed by the existing prefix block, which is then converted to a full prefix block, 1.2.*.*&#x2f;16.
	 * <p>
	 * When both zeroed and zeroHostIsBlock are false, the resulting address always encompasses the same set of addresses as the original,
	 * albeit with a different prefix length.
	 * 
	 * @param prefixLength
	 * @param zeroed
	 * @param zeroHostIsBlock
	 * @return
	 */
	public abstract IPAddress setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock);
	
	@Deprecated
	@Override
	public abstract IPAddress applyPrefixLength(int networkPrefixLength);
	/**
	 * Returns a clause for matching this address.
	 * <p>
	 * If this address is a subnet, this method will attempt to match every address in the subnet.
	 * Therefore it is much more efficient to use getNetworkSection().getStartsWithSQLClause() for a CIDR subnet.
	 * 
	 * @param builder
	 * @param sqlExpression
	 */
	public void getMatchesSQLClause(StringBuilder builder, String sqlExpression) {
		getSection().getStartsWithSQLClause(builder, sqlExpression);
	}
	
	/**
	 * Returns a clause for matching this address.
	 * <p>
	 * Similar to getMatchesSQLClause(StringBuilder builder, String sqlExpression) but allows you to tailor the SQL produced.
	 * 
	 * @param builder
	 * @param sqlExpression
	 * @param translator
	 */
	public void getMatchesSQLClause(StringBuilder builder, String sqlExpression, IPAddressSQLTranslator translator) {
		getSection().getStartsWithSQLClause(builder, sqlExpression, translator);
	}
	
	/**
	 * Removes the prefix length from addresses with a prefix length extending to the end of the address.
	 * @return
	 */
	public IPAddress removeBitCountPrefixLength() {
		if(isPrefixed() && getNetworkPrefixLength() == getBitCount()) {
			return this.withoutPrefixLength();
		}
		return this;
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import inet.ipaddr.format.AddressItem;
/**
 * Represents situations when an address, address section, address segment, or address string represents a valid type or format but 
 * that type does not match the required type or format for a given operation.
 * 
 * All such occurrences occur only from subnet addresses and sections.  These occurrences cannot happen with single-valued address objects.  
 * These occurrences cannot happen when using a standard prefix block subnet with standard masks.
 * 
 * Examples include:
 * <ul>
 * <li>producing non-segmented hex, octal or base 85 strings from a subnet with a range that cannot be represented as a single range of values,
 * </li><li>masking multiple addresses in a way that produces a non-contiguous range of values in a segment,
 * </li><li>reversing values that are not reversible,
 * </li><li>producing strings that are single-segment ranges from subnets which cannot be represented that way,
 * </li><li>producing new formats for which the range of values are incompatible with the new segments 
 * (EUI-64, IPv4 inet_aton formats, IPv4 embedded within IPv6, dotted MAC addresses from standard mac addresses, reverse DNS strings),
 * or
 * </li><li>using a subnet for an operation that requires a single address, such as with @link {@link IPAddress#toCanonicalHostName()}.
 * </li></ul>
 * 
 * @author sfoley
 *
 */
public class IncompatibleAddressException extends RuntimeException {
	
	private static final long serialVersionUID = 4L;
	
	private static String errorMessage = getMessage("ipaddress.address.error");
	
	static String getMessage(String key) {
		return AddressStringException.getMessage(key);
	}
	public IncompatibleAddressException(AddressItem one, String key) {
		super(one + ", " + errorMessage + " " + getMessage(key));
	}
	
	public IncompatibleAddressException(CharSequence one, String key) {
		super(one + ", " + errorMessage + " " + getMessage(key));
	}
	
	public IncompatibleAddressException(long lower, long upper, String key) {
		super(lower + "-" + upper + ", " + errorMessage + " " + getMessage(key));
	}
	
	public IncompatibleAddressException(long lower, long upper, long prefixLengthOrMask, String key) {
		super(lower + "-" + upper + " /" + prefixLengthOrMask + ", " + errorMessage + " " + getMessage(key));
	}
	
	public IncompatibleAddressException(String lower, String upper, String prefixLengthOrMask, String key) {
		super(lower + "-" + upper + " /" + prefixLengthOrMask + ", " + errorMessage + " " + getMessage(key));
	}
	
	public IncompatibleAddressException(AddressItem one, int prefixLengthOrMask, String key) {
		super(one + " /" + prefixLengthOrMask + ", " + errorMessage + " " + getMessage(key));
	}
	
	public IncompatibleAddressException(AddressItem one, int oneIndex, AddressItem two, int twoIndex, String key) {
		super((oneIndex + 1) + ":" + one + ", " + (twoIndex + 1) + ":" + two + ", " + errorMessage + " " + getMessage(key));
	}
	
	public IncompatibleAddressException(AddressItem one, AddressItem two, String key) {
		super(one + ", " + two + ", " + errorMessage + " " + getMessage(key));
	}
	
	public IncompatibleAddressException(String message) {
        super(message);
    }
	public IncompatibleAddressException(String message, Throwable cause) {
        super(message, cause);
    }
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv6;
import java.util.Iterator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.AddressDivisionBase;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
/**
 * This represents a segment of an IPv6 address.  For IPv4, segments are 1 byte.  For IPv6, they are two bytes.
 * 
 * Like String and Integer and various others basic objects, segments are immutable, which also makes them thread-safe.
 * 
 * @author sfoley
 *
 */
public class IPv6AddressSegment extends IPAddressSegment implements Iterable<IPv6AddressSegment> {
	
	private static final long serialVersionUID = 4L;
	public static final int MAX_CHARS = 4;
	public static final int BITS_PER_CHAR = 4;
	/**
	 * Constructs a segment of an IPv6 address with the given value.
	 * 
	 * @throws AddressValueException if value is negative or too large
	 * @param value the value of the segment
	 */
	public IPv6AddressSegment(int value) throws AddressValueException {
		super(value);
		if(value > IPv6Address.MAX_VALUE_PER_SEGMENT) {
			throw new AddressValueException(value);
		}
	}
	
	/**
	 * Constructs a segment of an IPv6 address.
	 * 
	 * @throws AddressValueException if value or prefix length is negative or too large
	 * @param value the value of the segment.  If the segmentPrefixLength is non-null, the network prefix of the value is used, and the segment represents all segment values with the same network prefix.
	 * @param segmentPrefixLength the segment prefix length, which can be null
	 */
	public IPv6AddressSegment(int value, Integer segmentPrefixLength) throws AddressValueException {
		super(value, segmentPrefixLength);
		if(value > IPv6Address.MAX_VALUE_PER_SEGMENT) {
			throw new AddressValueException(value);
		}
		if(segmentPrefixLength != null && segmentPrefixLength > IPv6Address.BIT_COUNT) {
			throw new PrefixLenException(segmentPrefixLength);
		}
	}
	
	/**
	 * Constructs a segment of an IPv6 address with the given range of values.
	 * 
	 * @throws AddressValueException if value or prefix length is negative or too large
	 * @param segmentPrefixLength the segment prefix length, which can be null.    If segmentPrefixLength is non-null, this segment represents a range of segment values with the given network prefix length.
	 * @param lower the lower value of the range of values represented by the segment.  If segmentPrefixLength is non-null, the lower value becomes the smallest value with the same network prefix.
	 * @param upper the upper value of the range of values represented by the segment.  If segmentPrefixLength is non-null, the upper value becomes the largest value with the same network prefix.
	 */
	public IPv6AddressSegment(int lower, int upper, Integer segmentPrefixLength) throws AddressValueException {
		super(lower, upper, segmentPrefixLength);
		if(getUpperSegmentValue() > IPv6Address.MAX_VALUE_PER_SEGMENT) {
			throw new AddressValueException(getUpperSegmentValue());
		}
		if(segmentPrefixLength != null && segmentPrefixLength > IPv6Address.BIT_COUNT) {
			throw new PrefixLenException(segmentPrefixLength);
		}
	}
	
	@Override
	public long getMaxValue() {
		return IPv6Address.MAX_VALUE_PER_SEGMENT;
	}
	@Override
	public boolean isIPv6() {
		return true;
	}
	@Override
	public IPVersion getIPVersion() {
		return IPVersion.IPV6;
	}
	
	@Override
	protected byte[] getBytesImpl(boolean low) {
		int val = low ? getSegmentValue() : getUpperSegmentValue();
		return new byte[] {(byte) (val >>> 8), (byte) (0xff & val)};
	}
	
	@Override
	public IPv6AddressNetwork getNetwork() {
		return Address.defaultIpv6Network();
	}
	
	@Override
	protected int getSegmentNetworkMask(int bits) {
		return getNetwork().getSegmentNetworkMask(bits);
	}
	
	@Override
	protected int getSegmentHostMask(int bits) {
		return getNetwork().getSegmentHostMask(bits);
	}
	
	@Override
	public int getMaxSegmentValue() {
		return getMaxSegmentValue(IPVersion.IPV6);
	}
	
	protected IPv6AddressSegment toPrefixNormalizedSeg() {
		return getSegmentCreator().createSegment(getSegmentValue(), getUpperSegmentValue(), IPv6AddressSection.cacheBits(getBitCount()));
	}
	
	protected IPv6AddressSegment toPrefixedSegment(Integer segmentPrefixLength) {
		if(isChangedByPrefix(segmentPrefixLength, getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets())) {
			return super.toPrefixedSegment(segmentPrefixLength, getSegmentCreator());
		}
		return this;
	}
	
	@Override
	public IPv6AddressSegment toNetworkSegment(Integer segmentPrefixLength) {
		return toNetworkSegment(segmentPrefixLength, true);
	}
	
	@Override
	public IPv6AddressSegment toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength) {
		if(isNetworkChangedByPrefix(segmentPrefixLength, withPrefixLength)) {
			return super.toNetworkSegment(segmentPrefixLength, withPrefixLength, getSegmentCreator());
		}
		return this;
	}
	
	@Override
	public IPv6AddressSegment toHostSegment(Integer bits) {
		if(isHostChangedByPrefix(bits)) {
			return super.toHostSegment(bits, getSegmentCreator());
		}
		return this;
	}
	@Override
	public IPv6AddressSegment getLower() {
		return getLowestOrHighest(this, getSegmentCreator(), true);
	}
	@Override
	public IPv6AddressSegment getUpper() {
		return getLowestOrHighest(this, getSegmentCreator(), false);
	}
	@Override
	public IPv6AddressSegment reverseBits(boolean perByte) {
		if(isMultiple()) {
			if(perByte ? !isReversibleRangePerByte(this) : !isReversibleRange(this)) { // the per-byte case is new
				throw new IncompatibleAddressException(this, "ipaddress.error.reverseRange");
			}
			if(isPrefixed()) {
				AddressSegmentCreator<IPv6AddressSegment> creator = getSegmentCreator();
				return creator.createSegment(getSegmentValue(), getUpperSegmentValue(), null);
			}
			return this;
		}
		AddressSegmentCreator<IPv6AddressSegment> creator = getSegmentCreator();
		int oldVal = getSegmentValue();
		int newVal = reverseBits((short) oldVal);
		if(perByte) {
			newVal = ((newVal & 0xff) << 8) | (newVal >>> 8);
		}
		if(oldVal == newVal && !isPrefixed()) {
			return this;
		}
		return creator.createSegment(newVal);
	}
	
	@Override
	public IPv6AddressSegment reverseBytes() {
		if(isMultiple()) {
			if(isReversibleRange(this)) {
				//reversible ranges end up being the same as the original
				if(isPrefixed()) {
					AddressSegmentCreator<IPv6AddressSegment> creator = getSegmentCreator();
					return creator.createSegment(getSegmentValue(), getUpperSegmentValue(), null);
				}
				return this;
			}
			throw new IncompatibleAddressException(this, "ipaddress.error.reverseRange");
		}
		AddressSegmentCreator<IPv6AddressSegment> creator = getSegmentCreator();
		int value = getSegmentValue();
		int newValue = ((value & 0xff) << 8) | (value >>> 8);
		if(value == newValue && !isPrefixed()) {
			return this;
		}
		return creator.createSegment(newValue);
	}
	
	@Override
	public IPv6AddressSegment toZeroHost() {
		return toZeroHost(this, getSegmentCreator());
	}
	
	@Override @Deprecated
	public IPv6AddressSegment removePrefixLength(boolean zeroed) {
		return removePrefix(this, zeroed, getSegmentCreator());
	}
	
	@Override @Deprecated
	public IPv6AddressSegment removePrefixLength() {
		return removePrefixLength(true);
	}
	
	@Override
	public IPv6AddressSegment withoutPrefixLength() {
		return removePrefix(this, false, getSegmentCreator());
	}
	protected IPv6AddressCreator getSegmentCreator() {
		return getNetwork().getAddressCreator();
	}
	@Override
	public Iterable<IPv6AddressSegment> getIterable() {
		return this;
	}
	
	Iterator<IPv6AddressSegment> iterator(boolean withPrefix) {
		IPv6AddressSegment original;
		if(!withPrefix && isPrefixed() && !isMultiple()) {
			original = withoutPrefixLength();
		} else {
			original = this;
		}
		return iterator(original, getSegmentCreator(), withPrefix ? getSegmentPrefixLength() : null, false, false);
	}
	
	@Override
	public Iterator<IPv6AddressSegment> iterator() {
		return iterator(!getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets());
	}
	
	@Override
	public AddressComponentSpliterator<IPv6AddressSegment> spliterator() {
		IPv6AddressCreator creator = getSegmentCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer segPrefLength = isAllSubnets ? null : getSegmentPrefixLength();
		int bitCount = getBitCount();
		return createSegmentSpliterator(
				this,
				getSegmentValue(),
				getUpperSegmentValue(),
				this::iterator,
				(isLowest, isHighest, value, upperValue) -> iterator(null, value, upperValue, bitCount, creator, segPrefLength, false, false),
				(value, upperValue) -> creator.createSegment(value, upperValue, segPrefLength));
	}
	
	@Override
	public Stream<IPv6AddressSegment> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv6AddressSegment> prefixBlockIterator() {
		return iterator(this, getSegmentCreator(), getSegmentPrefixLength(), true, true);
	}
	
	@Override
	public AddressComponentSpliterator<IPv6AddressSegment> prefixBlockSpliterator() {
		Integer segPrefLength = getSegmentPrefixLength();
		if(segPrefLength == null) {
			return spliterator();
		}
		return prefixBlockSpliterator(segPrefLength);
	}
	
	@Override
	public Stream<IPv6AddressSegment> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	Iterator<IPv6AddressSegment> identityIterator() {
		return identityIterator(this);
	}
	
	@Override
	public Iterator<IPv6AddressSegment> prefixBlockIterator(int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		return iterator(this, getSegmentCreator(), IPv6AddressSection.cacheBits(prefixLength), true, true);
	}
	
	@Override
	public AddressComponentSpliterator<IPv6AddressSegment> prefixBlockSpliterator(int segPrefLength) {
		return prefixBlockSpliterator(
				this,
				segPrefLength,
				getSegmentCreator(),
				this::prefixBlockIterator);
	}
	
	@Override
	public Stream<IPv6AddressSegment> prefixBlockStream(int segPrefLength) {
		return StreamSupport.stream(prefixBlockSpliterator(segPrefLength), false);
	}
	@Override
	public Iterator<IPv6AddressSegment> prefixIterator() {
		return iterator(this, getSegmentCreator(), getSegmentPrefixLength(), true, false);
	}
	
	@Override
	public AddressComponentSpliterator<IPv6AddressSegment> prefixSpliterator() {
		Integer segPrefLength = getSegmentPrefixLength();
		if(segPrefLength == null) {
			return spliterator();
		}
		return prefixSpliterator(
				this,
				segPrefLength,
				getSegmentCreator(),
				this::prefixIterator);
	}
	
	@Override
	public Stream<IPv6AddressSegment> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public int getBitCount() {
		return IPv6Address.BITS_PER_SEGMENT;
	}
	
	@Override
	public int getByteCount() {
		return IPv6Address.BYTES_PER_SEGMENT;
	}
	
	@Override
	public int getDefaultTextualRadix() {
		return IPv6Address.DEFAULT_TEXTUAL_RADIX;
	}
	
	@Override
	public int getMaxDigitCount() {
		return MAX_CHARS;
	}
	
	/**
	 * Converts this IPv6 address segment into smaller segments,
	 * copying them into the given array starting at the given index.
	 * 
	 * If a segment does not fit into the array because the segment index in the array is out of bounds of the array,
	 * then it is not copied.
	 * 
	 * @param segs
	 * @param index
	 */
	public <S extends AddressSegment> void getSplitSegments(S segs[], int index, AddressSegmentCreator<S> creator) {
		if(!isMultiple()) {
			int bitSizeSplit = IPv6Address.BITS_PER_SEGMENT >>> 1;
			Integer myPrefix = getSegmentPrefixLength();
			Integer highPrefixBits = getSplitSegmentPrefix(bitSizeSplit, myPrefix, 0);
			Integer lowPrefixBits = getSplitSegmentPrefix(bitSizeSplit, myPrefix, 1);
			if(index >= 0 && index < segs.length) {
				segs[index] = creator.createSegment(highByte(), highPrefixBits);
			}
			if(++index >= 0 && index < segs.length) {
				segs[index] = creator.createSegment(lowByte(), lowPrefixBits);
			}
		} else {
			getSplitSegmentsMultiple(segs, index, creator);
		}
	}
	
	private <S extends AddressSegment> void getSplitSegmentsMultiple(S segs[], int index, AddressSegmentCreator<S> creator) {
		Integer myPrefix = getSegmentPrefixLength();
		int bitSizeSplit = IPv6Address.BITS_PER_SEGMENT >>> 1;
		int val = getSegmentValue();
		int upperVal = getUpperSegmentValue();
		int highLower = highByte(val);
		int highUpper = highByte(upperVal);
		int lowLower = lowByte(val);
		int lowUpper = lowByte(upperVal);
		boolean highIsMult = highLower != highUpper;
		if(highIsMult) {
			// low values must be full range to be able to split this
			if(lowLower != 0 || lowUpper != ~(~0 << bitSizeSplit)) {
				throw new IncompatibleAddressException(this, "ipaddress.error.splitSeg");
			}
		}
		if(index >= 0 && index < segs.length) {
			Integer highPrefixBits = getSplitSegmentPrefix(bitSizeSplit, myPrefix, 0);
			if(highIsMult) {
				segs[index] = creator.createSegment(highLower, highUpper, highPrefixBits);
			} else {
				segs[index] = creator.createSegment(highLower, highPrefixBits);
			}
		}
		if(++index >= 0 && index < segs.length) {
			Integer lowPrefixBits = getSplitSegmentPrefix(bitSizeSplit, myPrefix, 1);
			if(lowLower == lowUpper) {
				segs[index] = creator.createSegment(lowLower, lowPrefixBits);
			} else {
				segs[index] = creator.createSegment(lowLower, lowUpper, lowPrefixBits);
			}
		}
	}
	
	@Override
	public boolean prefixContains(IPAddressSegment other, int segmentPrefixLength) {
		return this == other || (super.prefixContains(other, segmentPrefixLength) && other instanceof IPv6AddressSegment);
	}
	@Override
	public boolean prefixEquals(AddressSegment other, int segmentPrefixLength) {
		return this == other || (super.prefixEquals(other, segmentPrefixLength) && other instanceof IPv6AddressSegment);
	}
	@Override
	public boolean overlaps(AddressSegment other) {
		return this == other || (overlapsSeg(other) && other instanceof IPv6AddressSegment);
	}
	@Override
	public boolean contains(AddressSegment other) {
		return this == other || (containsSeg(other) && other instanceof IPv6AddressSegment);
	}
	
	@Override
	public boolean equals(Object other) {
		return this == other || (other instanceof IPv6AddressSegment && ((IPv6AddressSegment) other).isSameValues((AddressSegment) this));
	}
	
	@Override
	protected boolean isSameValues(AddressDivisionBase other) {
		return other instanceof IPv6AddressSegment && isSameValues((AddressSegment) other);
	}
	
	@Override
	protected int getRangeDigitCountImpl() {
		int prefix = getMinPrefixLengthForBlock();
		int bitCount = getBitCount();
		if(prefix < bitCount && containsSinglePrefixBlock(prefix)) {
			int bitsPerCharacter = IPv6Address.BITS_PER_SEGMENT / MAX_CHARS;
			if(prefix % bitsPerCharacter == 0) {
				return (bitCount - prefix) / bitsPerCharacter;
			}
		}
		return 0;
	}
	
	protected static int toUnsignedStringLength(int value, int radix) {
		return IPAddressSegment.toUnsignedStringLength(value, radix);
	}
	
	protected static StringBuilder toUnsignedString(int value, int radix, StringBuilder appendable) {
		return IPAddressSegment.toUnsignedString(value, radix, appendable);
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv6;
import java.io.Serializable;
import java.math.BigInteger;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressPositionException;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressConverter;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.validate.Validator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4Address.IPv4AddressConverter;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6AddressCache;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringBuilderOptions;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCache;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCollection;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringOptions;
import inet.ipaddr.ipv6.IPv6AddressTrie.IPv6TrieNode.IPv6TrieKeyData;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
import inet.ipaddr.mac.MACAddressNetwork.MACAddressCreator;
import inet.ipaddr.mac.MACAddressSection;
import inet.ipaddr.mac.MACAddressSegment;
/**
 * An IPv6 address, or a subnet of multiple IPv6 addresses.  Each segment can represent a single value or a range of values.
 * <p>
 * You can construct an IPv6 address from a byte array, from a BigInteger, from a {@link inet.ipaddr.Address.SegmentValueProvider}, 
 * from Inet6Address, from MACAddress, from an {@link IPv6AddressSection} of 8 segments, or from an array of 8  {@link IPv6AddressSegment} objects.
 * <p>
 * To construct one from a {@link java.lang.String} use 
 * {@link inet.ipaddr.IPAddressString#toAddress()} or  {@link inet.ipaddr.IPAddressString#getAddress()}, {@link inet.ipaddr.IPAddressString#toHostAddress()} or {@link inet.ipaddr.IPAddressString#getHostAddress()}
 * <p>
 * An IPv6 address can have an associated zone, typically either a network interface name or a positive integer.
 * An IPv6 zone distinguishes two IPv6 addresses that are the same.
 * <ul>
 * <li>They are used with link-local addresses fe80::/10 to distinguish two interfaces to the link-local network, this is known as the zone id.
 * </li><li>They are used with site-local addresses to distinguish sites, using the site id, also known as the scope id.
 * </li></ul>
 * <p>
 * A zone that consists of a scope id is called a scoped zone.
 * @custom.core
 * @author sfoley
 */
/*
 * rfc 6890 and the earlier 5156 has details on some of the special addresses
 * 
 * For some of the various pre-specified IPv6 address formats (IPv4 mapped, IPv4 translated, IPv4 compatible, etc), 
 * see gestioip.net/docu/ipv6_address_examples.html
 * 
 * A nice summary of IPV6 formats at https://technet.microsoft.com/en-us/library/cc757359(v=ws.10).aspx
 * https://technet.microsoft.com/en-us/library/dd379548(v=ws.10).aspx
 */
public class IPv6Address extends IPAddress implements Iterable<IPv6Address> {
	private static final long serialVersionUID = 4L;
	public static final char SEGMENT_SEPARATOR = ':';
	public static final char ZONE_SEPARATOR = '%';
	public static final char ALTERNATIVE_ZONE_SEPARATOR = '\u00a7';//'§'; javadoc whines about this char 
	public static final char UNC_SEGMENT_SEPARATOR = '-';
	public static final char UNC_ZONE_SEPARATOR = 's';
	public static final char UNC_RANGE_SEPARATOR = ALTERNATIVE_RANGE_SEPARATOR;
	public static final String UNC_RANGE_SEPARATOR_STR = String.valueOf(UNC_RANGE_SEPARATOR);
	public static final String UNC_SUFFIX = ".ipv6-literal.net";
	public static final String REVERSE_DNS_SUFFIX = ".ip6.arpa";
	public static final String REVERSE_DNS_SUFFIX_DEPRECATED = ".ip6.int";
	public static final int BITS_PER_SEGMENT = 16;
	public static final int BYTES_PER_SEGMENT = 2;
	public static final int SEGMENT_COUNT = 8;
	public static final int MIXED_REPLACED_SEGMENT_COUNT = 2; //IPv4Address.BYTE_COUNT / BYTES_PER_SEGMENT;
	public static final int MIXED_ORIGINAL_SEGMENT_COUNT = 6; //SEGMENT_COUNT - MIXED_REPLACED_SEGMENT_COUNT
	public static final int BYTE_COUNT = 16;
	public static final int BIT_COUNT = 128;
	public static final int DEFAULT_TEXTUAL_RADIX = 16;
	public static final int BASE_85_RADIX = 85;
	public static final int MAX_VALUE_PER_SEGMENT = 0xffff;
	/* 
	 * An IPv6 zone distinguishes two IPv6 addresses that are the same.
	 * They are used with link-local addresses fe80::/10 and distinguishes two interfaces to the link-local network, this is known as the zone id.
	 * They are used with site-local addresses to distinguish sites, using the site id, also known as the scope id.
	 * 
	 * A zone that consists of a scope id is called a scoped zone.
	 */
	private final IPv6Zone zone;
	/**
	 * A reference to a scope id by number or a network interface by name.
	 * <p>
	 * An IPv6 zone distinguishes two IPv6 addresses that are the same.
	 * They are used with link-local addresses fe80::/10 to distinguish two interfaces to the link-local network, this is known as the zone id.
	 * They are used with site-local addresses to distinguish sites, using the site id, also known as the scope id.
	 * <p>
	 * A zone that consists of a scope id is called a scoped zone.
	 * <p>
	 * An IPv6 zone will reference an interface by a scoped identifier number or by interface name based on how it was constructed.
	 * If constructed with a numeric identifier, whether integer or string, it will always reference by scoped identifier.
	 * Otherwise, it will always reference by interface name.
	 * <p>
	 * Once constructed, it will always reference using the same method, either interface name or scope id.  
	 * To reference by the other method you must use a different IPv6Zone instance.
	 * <p>
	 * Even though it will always reference using the same method, 
	 * you can use the IPv6Zone instance to look up the scope id if the instance references by interface name,
	 * or to look up the associated interface if the instance references by scope id.
	 * 
	 * 
	 * @custom.core
	 * @author scfoley
	 *
	 */
	public static class IPv6Zone implements Serializable {
		private static final long serialVersionUID = 1L;
		
		String zoneStr;
		private int scopeId;
		private transient NetworkInterface networkInterface;
		private Boolean referencesInterface;
		
		/**
		 * Constructs a zone that will use the given zone string, 
		 * either a non-negative integer indicating a scope identifier, 
		 * or the name of a network interface.
		 * <p>
		 * A scope identifier is indicated by a sequence of decimal digits.
		 * <p>
		 * To create an InetAddress by pairing this zone with an IPv6Address instance,
		 * an interface name must reference an existing interface, otherwise the InetAddress cannot be created.
		 * <p>
		 * See {@link java.net.NetworkInterface}  to get a list of existing interfaces or to look up interfaces by name.
		 * 
		 * @param zoneStr
		 */
		public IPv6Zone(String zoneStr) {
			if(zoneStr == null) {
				throw new NullPointerException();
			}
			this.zoneStr = zoneStr.trim();
			scopeId = -1;
		}
		
		/**
		 * Constructs a zone that will use a scope identifier with the address.
		 * 
		 * @param scopeId
		 */
		public IPv6Zone(int scopeId) {
			if(scopeId < 0) {
				throw new IllegalArgumentException();
			}
			this.scopeId = scopeId;
			referencesInterface = Boolean.FALSE;
		}
		
		/**
		 * Constructs a zone that will use an interface name with the address.
		 * 
		 * @param networkInterface
		 */
		public IPv6Zone(NetworkInterface networkInterface) {
			if(networkInterface == null) {
				throw new NullPointerException();
			}
			this.networkInterface = networkInterface;
			referencesInterface = Boolean.TRUE;
			scopeId = -1;
			zoneStr = networkInterface.getName();
		}
		
		/**
		 * Whether this zone references a network interface.
		 * 
		 * @return
		 */
		public boolean referencesIntf() {
			if(referencesInterface == null) {
				scopeId = checkIfScope(zoneStr);
				referencesInterface = scopeId < 0;
			}
			return referencesInterface;
		}
		
		/**
		 * Whether this zone references a scope identifier.
		 * 
		 * @return
		 */
		public boolean referencesScopeId() {
			return !referencesIntf();
		}
		/**
		 * If this zone references a network interface, returns that interface, 
		 * or null if no interface with the given name exists on the system.
		 * 
		 * If this zone references a scope id, returns the associated interface.
		 * 
		 * @return
		 */
		public NetworkInterface getAssociatedIntf() {
			try {
				if(referencesIntf()) {
					if(networkInterface == null) {
						networkInterface = NetworkInterface.getByName(zoneStr);
					}
				} else {
					if(networkInterface == null) {
						Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
						top:
						while(interfaces.hasMoreElements()) {
							NetworkInterface nif = interfaces.nextElement();
							Enumeration<InetAddress> addrs = nif.getInetAddresses();
							while(addrs.hasMoreElements()) {
								InetAddress addr = addrs.nextElement();
								if(addr instanceof Inet6Address) {
									Inet6Address inetAddr = (Inet6Address) addr;
									if(inetAddr.getScopeId() == scopeId) {
										networkInterface = nif;
										break top;
									}
								}
							}
						}
					}
				}
			} catch(SocketException e) {}
			return networkInterface;
		}
		
		/**
		 * Returns the MAC address of the associated interface
		 * 
		 * @return
		 */
		public MACAddress getAssociatedIntfMacAddr() {
			NetworkInterface intf = getAssociatedIntf();
			try {
				if(intf != null) {
					byte bytes[] = intf.getHardwareAddress();
					if(bytes != null) {
						return new MACAddress(bytes);
					}
				}
			} catch(SocketException e) {}
			return null;
		}
		/**
		 * If this zone references a scoped identifier, returns that identifier.
		 * <p>
		 * If this zone references a network interface, returns the scope identifier for the addresses of that interface,
		 * or -1 if the referenced interface cannot be found on the system, or no single scope identifier was assigned.
		 * 
		 * @return
		 */
		public int getAssociatedScopeId() {
			if(referencesIntf()) {
				if(scopeId == -1) {
					NetworkInterface nif = getAssociatedIntf();
					if(nif != null) {
						Enumeration<InetAddress> addrs = nif.getInetAddresses();
						int newScopeId = -1;
						while(addrs.hasMoreElements()) {
							InetAddress addr = addrs.nextElement();
							if(addr instanceof Inet6Address) {
								Inet6Address inetAddr = (Inet6Address) addr;
								int sid = inetAddr.getScopeId();
								if(sid != 0) {
									if(newScopeId != -1 && sid != newScopeId) {
										// multiple scope ids for the interface
										newScopeId = -1;
										break;
									}
									newScopeId = sid;
								}
							}
						}
						if(newScopeId != -1) {
							this.scopeId = newScopeId;
						}
					}
				}
			}
			return scopeId;
		}
		
		@Override
		public int hashCode() {
			return toString().hashCode();
		}
		
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv6Zone && toString().equals(o.toString());
		}
		
		public String getName() {
			if(zoneStr == null) {
				if(referencesIntf()) {
					zoneStr = networkInterface.getName();
				} else {
					zoneStr = IPv6AddressSegment.toUnsignedString(scopeId, 10,
							new StringBuilder(IPv6AddressSegment.toUnsignedStringLength(scopeId, 10))).toString();
				}
			}
			return zoneStr;
		}
	
		@Override
		public String toString() {
			return getName();
		}
		
		static int checkIfScope(String zoneStr) {
			long digits = 0;
			for(int i = 0, len = zoneStr.length(); i < len; i++) {
				char c = zoneStr.charAt(i);
				int digit = Character.digit(c, 10);
				if(digit < 0) {
					return -1;
				}
				digits = (digits * 10) + digit;
				if(digits > Integer.MAX_VALUE) {
					return -1;
				}
			}
			return (int) digits;
		}
	}
	private transient IPv6StringCache stringCache;
	
	private transient IPv6TrieKeyData cachedTrieKeyData;
	transient IPv6AddressCache addressCache;
	IPv6Address(IPv6AddressSection section, CharSequence zone, boolean checkZone) throws AddressValueException {
		this(section, checkZone ? 
					checkZone(zone) : 
					(zone != null && zone.length() > 0 ? 
							new IPv6Zone(zone.toString()) :
							null));
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * @throws AddressValueException if segment count is not 8 or zone is invalid
	 * @param section
	 * @param zone
	 */
	public IPv6Address(IPv6AddressSection section, IPv6Zone zone) throws AddressValueException {
		super(section);
		if(section.getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv6.invalid.segment.count", section.getSegmentCount());
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section.addressSegmentIndex);
		}
		this.zone = zone;
	}
	
	/**
	 * @deprecated use {@link #IPv6Address(IPv6AddressSection, IPv6Zone)}
	 * @throws AddressValueException if segment count is not 8 or zone is invalid
	 * @param section
	 * @param zone
	 */
	@Deprecated
	public IPv6Address(IPv6AddressSection section, CharSequence zone) throws AddressValueException {
		this(section, zone, true);
	}
	
	public IPv6Address(IPv6AddressSection section) throws AddressValueException {
		this(section, (CharSequence) null);
	}
	/**
	 * Constructs an IPv6 address or subnet.
	 * @throws AddressValueException if segment count is not 8
	 * @param segments the address segments
	 */
	public IPv6Address(IPv6AddressSegment[] segments) throws AddressValueException {
		this(segments, null, null);
	}
	/**
	 * Constructs an IPv6 address or a set of addresses.
	 * 
	 * @throws AddressValueException if segment count is not 8
	 * @param segments the address segments
	 * @param networkPrefixLength
	 * @throws AddressValueException if network prefix length invalid
	 */
	public IPv6Address(IPv6AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		this(segments, networkPrefixLength, null);
	}
	/**
	 * Constructs an IPv6 address or a set of addresses.
	 * 
	 * @deprecated use {@link #IPv6Address(IPv6AddressSegment[], IPv6Zone)}
	 * @param segments the address segments
	 * @param zone the zone or scope id
	 * 
	 * @throws AddressValueException if segment count is not 8 or the zone invalid
	 */
	@Deprecated
	public IPv6Address(IPv6AddressSegment[] segments, CharSequence zone) throws AddressValueException {
		this(segments, checkZone(zone));
	}
	/**
	 * Constructs an IPv6 address or a set of addresses.
	 * 
	 * @param segments the address segments
	 * @param zone the zone or scope id
	 * 
	 * @throws AddressValueException if segment count is not 8 or the zone invalid
	 */
	public IPv6Address(IPv6AddressSegment[] segments, IPv6Zone zone) throws AddressValueException {
		this(segments, null, zone);
	}
	private IPv6Address(IPv6AddressSegment[] segments, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(segments, networkPrefixLength));
		if(segments.length != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv6.invalid.segment.count", segments.length);
		}
		this.zone = zone;
	}
	/**
	 * Constructs an IPv6 address.
	 *
	 * @param inet6Address the java.net address object
	 */
	public IPv6Address(Inet6Address inet6Address) {
		this(inet6Address, inet6Address.getAddress(), null, getZone(inet6Address));
	}
	
	/**
	 * Constructs an IPv6 address.
	 *
	 * @param inet6Address the java.net address object
	 */
	public IPv6Address(Inet6Address inet6Address, Integer networkPrefixLength) {
		this(inet6Address, inet6Address.getAddress(), networkPrefixLength, getZone(inet6Address));
	}
	
	private IPv6Address(Inet6Address inet6Address, byte[] bytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(bytes, 0, bytes.length, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
		getSection().setInetAddress(inet6Address);
	}
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The byte array can be a 16 byte IPv6 address, but may have additional zero-valued bytes, or it may be fewer than 16 bytes.
	 *
	 * @deprecated use {@link #IPv6Address(byte[], IPv6Zone)}
	 * @throws AddressValueException if bytes not equivalent to a 16 byte address
	 * @param bytes the 16 byte IPv6 address in network byte order - if longer than 16 bytes the additional bytes must be zero (and are ignored), if shorter than 16 bytes then the bytes are sign-extended to 16 bytes.
	 * @throws AddressValueException if byte range invalid or zone invalid
	 */
	@Deprecated
	public IPv6Address(byte[] bytes, CharSequence zone) throws AddressValueException {
		this(bytes, checkZone(zone));
	}
	
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The byte array can be a 16 byte IPv6 address, but may have additional zero-valued bytes, or it may be fewer than 16 bytes.
	 *
	 * @throws AddressValueException if bytes not equivalent to a 16 byte address
	 * @param bytes the 16 byte IPv6 address in network byte order - if longer than 16 bytes the additional bytes must be zero (and are ignored), if shorter than 16 bytes then the bytes are sign-extended to 16 bytes.
	 * @throws AddressValueException if byte range invalid or zone invalid
	 */
	public IPv6Address(byte[] bytes, IPv6Zone zone) throws AddressValueException {
		this(bytes, null, zone);
	}
	
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The byte array can be a 16 byte IPv6 address, but may have additional zero-valued bytes, or it may be fewer than 16 bytes.
	 *
	 * @throws AddressValueException if bytes not equivalent to a 16 byte address
	 * @param bytes the 16 byte IPv6 address in network byte order - if longer than 16 bytes the additional bytes must be zero (and are ignored), if shorter than 16 bytes then the bytes are sign-extended to 16 bytes.
	 */
	public IPv6Address(byte[] bytes) throws AddressValueException {
		this(bytes, null, null);
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * Similar to {@link #IPv6Address(byte[])} except that you can specify the start and end of the address in the given byte array.
	 * @throws AddressValueException if byte range invalid
	 */
	public IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, null, null);
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * The byte array can be a 16 byte IPv6 address, but may have additional zero-valued bytes, or it may be fewer than 16 bytes.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * @param bytes the 16 byte IPv6 address in network byte order - if longer than 16 bytes the additional bytes must be zero (and are ignored), if shorter than 16 bytes then the bytes are sign-extended to 16 bytes.
	 * @param networkPrefixLength the CIDR prefix, which can be null for no prefix length
	 * @throws AddressValueException if bytes not equivalent to a 16 byte address
	 */
	public IPv6Address(byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, networkPrefixLength, null);
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * Similar to {@link #IPv6Address(byte[], Integer)} except that you can specify the start and end of the address in the given byte array.
	 */
	public IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, networkPrefixLength, null);
	}
	
	/**
	 * Constructs an IPv6 address.  
	 * <p>
	 * The byte representation from {@link BigInteger#toByteArray()} is used, and the byte array follows the rules according to {@link #IPv6Address(byte[])}.
	 * Either it must be exactly 16 bytes, or if larger then any extra bytes must be significant leading zeros, 
	 * or if smaller it is sign-extended to the required 16 byte length.
	 * <p>
	 * This means that you can end up with the same address from two different values of BigInteger, one positive and one negative.
	 * For instance, -1 and ffffffffffffffffffffffffffffffff are represented by the two's complement byte arrays [ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff] 
	 * and [0,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff] respectively.
	 * Both create the address ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
	 * <p>
	 * In fact, the two's complement byte array [ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff] can be shortened to [ff], the former being the sign-extension of the latter.
	 * So the byte array [ff] also creates the address ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff.
	 * <p>
	 * When using positive integers you end up with the results you expect, the magnitude of the big integer becomes the address.
	 * <p>
	 * When ranging over all 16-byte arrays and constructing BigInteger from those arrays, you range over all possible addresses.
	 * <p>
	 * @throws AddressValueException if value is outside the range of potential values
	 * @param val must be an IPv6 address value.
	 * @throws AddressValueException if val is invalid
	 */
	public IPv6Address(BigInteger val) throws AddressValueException {
		this(val, null, (IPv6Zone) null);
	}
	
	/**
	 * Constructs an IPv6 address.  
	 * <p>
	 * The byte representation from {@link BigInteger#toByteArray()} is used, and the byte array follows the rules according to {@link #IPv6Address(byte[])}.
	 * Either it must be exactly 16 bytes, or if larger then any extra bytes must be significant leading zeros, 
	 * or if smaller it is sign-extended to the required 16 byte length.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * 
	 * @param val
	 * @param networkPrefixLength
	 * @throws AddressValueException if val is invalid
	 */
	public IPv6Address(BigInteger val, Integer networkPrefixLength) throws AddressValueException {
		this(val, networkPrefixLength, (IPv6Zone) null);
	}
	
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The byte representation from {@link BigInteger#toByteArray()} is used, and the byte array follows the rules according to {@link #IPv6Address(byte[])}.
	 * Either it must be exactly 16 bytes, or if larger then any extra bytes must be significant leading zeros, 
	 * or if smaller it is sign-extended to the required 16 byte length.
	 * <p>
	 * @deprecated use {@link #IPv6Address(BigInteger, IPv6Zone)}
	 * @param val
	 * @param zone
	 * @throws AddressValueException if val is invalid or if zone is invalid
	 */
	@Deprecated
	public IPv6Address(BigInteger val, CharSequence zone) throws AddressValueException {
		this(val, checkZone(zone));
	}
	
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The byte representation from {@link BigInteger#toByteArray()} is used, and the byte array follows the rules according to {@link #IPv6Address(byte[])}.
	 * Either it must be exactly 16 bytes, or if larger then any extra bytes must be significant leading zeros, 
	 * or if smaller it is sign-extended to the required 16 byte length.
	 * <p>
	 * @param val
	 * @param zone
	 * @throws AddressValueException if val is invalid or if zone is invalid
	 */
	public IPv6Address(BigInteger val, IPv6Zone zone) throws AddressValueException {
		this(val, null, zone);
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @deprecated use {@link #IPv6Address(BigInteger, Integer, IPv6Zone)}
	 * @param val must be an IPv6 address value
	 * @param networkPrefixLength the CIDR prefix length, which can be null for no prefix length
	 * @param zone the zone or scope id
	 * @throws AddressValueException if value is outside the range of potential values, or if zone is invalid
	 */
	@Deprecated
	public IPv6Address(BigInteger val, Integer networkPrefixLength, CharSequence zone) throws AddressValueException {	
		this(val, networkPrefixLength, checkZone(zone));
	}
	
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param val must be an IPv6 address value
	 * @param networkPrefixLength the CIDR prefix length, which can be null for no prefix length
	 * @param zone the zone or scope id
	 * @throws AddressValueException if value is outside the range of potential values, or if zone is invalid
	 */
	public IPv6Address(BigInteger val, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {	
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSectionInternal(val.toByteArray(), IPv6Address.SEGMENT_COUNT, networkPrefixLength, false));
		this.zone = zone;
	}
	
	private IPv6Address(byte[] bytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		this(bytes, 0, bytes.length, networkPrefixLength, zone);
	}
	
	private IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(bytes, byteStartIndex, byteEndIndex, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
	}
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The highBytes form the more significant 4 bytes of the address.
	 * 
	 * @param highBytes the 4 more significant bytes in network byte order
	 * @param lowBytes the 4 least significant bytes in network byte order
	 * @throws AddressValueException if zone invalid
	 */
	public IPv6Address(long highBytes, long lowBytes, IPv6Zone zone) throws AddressValueException {
		this(highBytes, lowBytes, null, zone);
	}
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * The highBytes form the more significant 4 bytes of the address.
	 *
	 * @param highBytes the 4 more significant bytes in network byte order
	 * @param lowBytes the 4 least significant bytes in network byte order
	 */
	public IPv6Address(long highBytes, long lowBytes) throws AddressValueException {
		this(highBytes, lowBytes, null, null);
	}
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * The highBytes form the more significant 4 bytes of the address.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * @param highBytes the 4 more significant bytes in network byte order
	 * @param lowBytes the 4 least significant bytes in network byte order
	 * @param networkPrefixLength the CIDR prefix, which can be null for no prefix length
	 */
	public IPv6Address(long highBytes, long lowBytes, Integer networkPrefixLength) throws AddressValueException {
		this(highBytes, lowBytes, networkPrefixLength, null);
	}
	private IPv6Address(long highBytes, long lowBytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(highBytes, lowBytes, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
	}
	/**
	 * Constructs an IPv6 address or subnet.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param lowerValueProvider supplies the 2 byte lower values for each segment
	 * @param upperValueProvider supplies the 2 byte upper values for each segment
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 */
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, networkPrefixLength, null);
	}
	/**
	 * Constructs an IPv6 address or subnet.
	 * 
	 * @param lowerValueProvider supplies the 2 byte lower values for each segment
	 * @param upperValueProvider supplies the 2 byte upper values for each segment
	 */
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, null, null);
	}
	
	/**
	 * Constructs an IPv6 address.
	 * <p>
	 * When networkPrefixLength is non-null, depending on the prefix configuration (see {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()},
	 * this object may represent either a single address with that network prefix length, or the prefix subnet block containing all addresses with the same network prefix.
	 * <p>
	 * 
	 * @param valueProvider supplies the 2 byte value for each segment
	 * @param networkPrefixLength the CIDR network prefix length, which can be null for no prefix
	 */
	public IPv6Address(SegmentValueProvider valueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, networkPrefixLength);
	}
	
	/**
	 * Constructs an IPv6 address.
	 * 
	 * @param valueProvider supplies the 2 byte value for each segment
	 */
	public IPv6Address(SegmentValueProvider valueProvider) {
		this(valueProvider, (Integer) null);
	}
	
	/**
	 * Constructs an IPv6 address.
	 *
	 * @deprecated use {@link #IPv6Address(Address.SegmentValueProvider, Address.SegmentValueProvider, IPv6Zone)}
	 * @param lowerValueProvider supplies the 2 byte lower values for each segment
	 * @param upperValueProvider supplies the 2 byte upper values for each segment
	 * @throws AddressValueException if zone is invalid
	 */
	@Deprecated
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, CharSequence zone) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, checkZone(zone));
	}
	
	/**
	 * Constructs an IPv6 address.
	 *
	 * @param lowerValueProvider supplies the 2 byte lower values for each segment
	 * @param upperValueProvider supplies the 2 byte upper values for each segment
	 * @throws AddressValueException if zone is invalid
	 */
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, IPv6Zone zone) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, null, zone);
	}
	
	private IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createFullSectionInternal(lowerValueProvider, upperValueProvider, networkPrefixLength));
		this.zone = zone;
	}
	
	/**
	 * Constructs an IPv6 address from a modified EUI-64 (Extended Unique Identifier) address section and an IPv6 address section network prefix.
	 * <p>
	 * If the supplied MAC section is an 8 byte EUI-64, then it must match the required EUI-64 format of xx-xx-ff-fe-xx-xx
	 * with the ff-fe section in the middle.
	 * 
	 * If the supplied section is a 6 byte MAC-48 or EUI-48, then the ff-fe pattern will be inserted.
	 * <p>
	 * If the supplied section neither 6 nor 8 bytes, or if the 8-byte section does not have required EUI-64 format of xx-xx-ff-fe-xx-xx,
	 * {@link IncompatibleAddressException} will be thrown.
	 * <p>
	 * The constructor will toggle the MAC U/L (universal/local) bit as required with EUI-64.
	 * <p>
	 * Only the first 8 bytes (4 segments) of the IPv6Address are used to construct the address.
	 * <p>
	 * Any prefix length in the MAC address is ignored, while a prefix length in the IPv6 address is preserved but only up to the first 4 segments.
	 * 
	 * @throws IncompatibleAddressException if the MACAddress is an 8 byte MAC address incompatible with EUI-64 IPv6 format
	 * @param prefix an address from which the first four segments will be used as the same initial segments in the returned address
	 * @param eui
	 */
	public IPv6Address(IPv6Address prefix, MACAddress eui) throws IncompatibleAddressException {
		this(prefix.getSection(), eui.getSection());
	}
	
	/**
	 * Constructs an IPv6 address from a modified EUI-64 (Extended Unique Identifier) address section and an IPv6 address section network prefix.
	 * <p>
	 * If the supplied MAC section is an 8 byte EUI-64, then it must match the required EUI-64 format of xx-xx-ff-fe-xx-xx
	 * with the ff-fe section in the middle.
	 * 
	 * If the supplied section is a 6 byte MAC-48 or EUI-48, then the ff-fe pattern will be inserted.
	 * <p>
	 * If the supplied section neither 6 nor 8 bytes, or if the 8-byte section does not have required EUI-64 format of xx-xx-ff-fe-xx-xx,
	 * {@link IncompatibleAddressException} will be thrown.
	 * <p>
	 * The constructor will toggle the MAC U/L (universal/local) bit as required with EUI-64.
	 * <p>
	 * The IPv6 address section must be 8 bytes.
	 * <p>
	 * Any prefix length in the MAC address is ignored, while a prefix length in the IPv6 address is preserved but only up to the first 4 segments.
	 * @throws IncompatibleAddressException if the MACAddress is an 8 byte MAC address incompatible with EUI-64 IPv6 format
	 * @throws AddressValueException  if the IPv6 section is the wrong size or structure
	 * @param section
	 * @param eui
	 */
	public IPv6Address(IPv6AddressSection section, MACAddress eui) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui.getSection());
	}
	
	/**
	 * Constructs an IPv6 address from a modified EUI-64 (Extended Unique Identifier) address and an IPv6 address section network prefix.
	 * <p>
	 * If the supplied address is an 8 byte EUI-64, then it must match the required EUI-64 format of xx-xx-ff-fe-xx-xx
	 * with the ff-fe section in the middle.
	 * 
	 * If the supplied address is a 6 byte MAC-48 or EUI-48, then the ff-fe pattern will be inserted.
	 * <p>
	 * The constructor will toggle the MAC U/L (universal/local) bit as required with EUI-64.
	 * <p>
	 * The IPv6 address section must be 8 bytes.
	 * <p>
	 * Any prefix length in the MAC address is ignored, while a prefix length in the IPv6 address is preserved but only up to the first 4 segments.
	 * @throws IncompatibleAddressException if the MACAddress is an 8 byte MAC address incompatible with EUI-64 IPv6 format
	 * @throws AddressValueException  if the MACAddress or IPv6 sections are the wrong size or structure
	 * @param section
	 * @param eui
	 */
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui, (IPv6Zone) null);
	}
	
	/**
	 * Constructs an IPv6 address from a modified EUI-64 (Extended Unique Identifier) address and an IPv6 address section network prefix.
	 * 
	 * @deprecated use {@link #IPv6Address(IPv6AddressSection, MACAddressSection, IPv6Zone)}
	 * @param section
	 * @param eui
	 * @param zone
	 * @throws IncompatibleAddressException  if the MACAddress is an 8 byte MAC address incompatible with EUI-64 IPv6 format
	 * @throws AddressValueException  if the MACAddress or IPv6 sections are the wrong size or structure, or if zone is invalid
	 */
	@Deprecated
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui, CharSequence zone) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui, checkZone(zone));
	}
	
	/**
	 * Constructs an IPv6 address from a modified EUI-64 (Extended Unique Identifier) address and an IPv6 address section network prefix.
	 * 
	 * @param section
	 * @param eui
	 * @param zone
	 * @throws IncompatibleAddressException  if the MACAddress is an 8 byte MAC address incompatible with EUI-64 IPv6 format
	 * @throws AddressValueException  if the MACAddress or IPv6 sections are the wrong size or structure, or if zone is invalid
	 */
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui, IPv6Zone zone) throws IncompatibleAddressException, AddressValueException  {
		super(thisAddress -> toFullEUI64Section(section, eui, ((IPv6Address) thisAddress).getDefaultCreator(), ((IPv6Address) thisAddress).getMACNetwork().getAddressCreator()));
		this.zone = zone;
	}
	
	static IPv6Zone checkZone(CharSequence zone) throws AddressValueException {
		if(zone == null) {
			return null;
		}
		String zoneStr = zone.toString().trim();
		if(zone.length() == 0) {
			return null;
		}
		int invalidIndex = Validator.validateZone(zoneStr);
		if(invalidIndex >= 0) {
			throw new AddressValueException("ipaddress.error.invalid.zone", invalidIndex);
		}
		return new IPv6Zone(zoneStr);
	}
	IPv6AddressCreator getDefaultCreator() {
		return getNetwork().getAddressCreator();
	}
	IPv6AddressCreator getCreator() {
		IPv6AddressCreator defaultCreator = getDefaultCreator();
		if(!hasZone()) {
			return defaultCreator;
		}
		IPv6AddressCreator creator = new IPv6AddressCreator(getNetwork(), defaultCreator.cache) {// using a lambda for this one results in a big performance hit, so we use anonymous class
			private static final long serialVersionUID = 4L;
			@Override
			protected IPv6Address createAddressInternal(IPv6AddressSegment segments[]) {
				IPv6AddressCreator creator = getDefaultCreator();
				return creator.createAddress(segments, zone); /* address creation */
			}
			@Override
			public IPv6Address createAddress(IPv6AddressSection section) {
				IPv6AddressCreator creator = getDefaultCreator();
				return creator.createAddress(section, zone); /* address creation */
			}
		};
		creator.useSegmentCache = defaultCreator.useSegmentCache;
		return creator;
	}
	private static IPv6Zone getZone(Inet6Address inet6Address) {
		NetworkInterface networkInterface = inet6Address.getScopedInterface();
		if(networkInterface != null) {
			return new IPv6Zone(networkInterface);
		}
		int scopeId = inet6Address.getScopeId();
		if(scopeId != 0) {
			return new IPv6Zone(scopeId);
		}
		return null;
	}
	private static IPv6AddressSection toFullEUI64Section(IPv6AddressSection section, MACAddressSection eui, IPv6AddressCreator creator, MACAddressCreator macCreator) throws AddressValueException, IncompatibleAddressException {
		boolean euiIsExtended = eui.isExtended();
		if(eui.addressSegmentIndex != 0) {
			throw new AddressPositionException(eui, eui.addressSegmentIndex);
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section, section.addressSegmentIndex);
		}
		if(section.getSegmentCount() < 4) {
			throw new AddressValueException(section, "ipaddress.mac.error.not.eui.convertible");
		}
		if(eui.getSegmentCount() != (euiIsExtended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT)) {
			throw new AddressValueException(eui, "ipaddress.mac.error.not.eui.convertible");
		}
		IPv6AddressSegment segments[] = creator.createSegmentArray(8);
		section.getSegments(0, 4, segments, 0);
		Integer prefLength = section.getNetworkPrefixLength();
		Integer prefixLength = prefLength != null && (prefLength <= 64) ? prefLength : null;
		toEUI64Segments(segments, 4, eui, 0, eui.isExtended(), creator, macCreator, prefixLength);
		return creator.createSectionInternal(segments);
	}
	
	static IPv6AddressSegment[] toEUI64Segments(
			IPv6AddressSegment segments[],
			int ipv6StartIndex,
			MACAddressSection eui,
			int euiStartIndex,
			boolean isExtended,
			IPv6AddressCreator creator,
			MACAddressCreator macCreator,
			Integer prefixLength) 
					throws IncompatibleAddressException {
		int euiSegmentIndex = 0;
		int euiSegmentCount = eui.getSegmentCount();
		MACAddressSegment seg0, seg1, seg2, seg3, seg4, seg5, seg6, seg7;
		seg0 = (euiStartIndex == 0 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg1 = (euiStartIndex <= 1 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg2 = (euiStartIndex <= 2 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg3 = (euiStartIndex <= 3 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg4 = (euiStartIndex <= 4 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg5 = (euiStartIndex <= 5 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg6 = (euiStartIndex <= 6 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg7 = (euiStartIndex <= 7 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex) : null;
		boolean isNotNull;
		MACAddressSegment zeroSegment = macCreator.createSegment(0);
		MACAddressSegment ffSegment = macCreator.createSegment(0xff);
		MACAddressSegment feSegment = macCreator.createSegment(0xfe);
		Integer currentPrefix = null;
		if(prefixLength != null) {
			//since the prefix comes from the ipv6 section and not the MAC section, any segment prefix for the MAC section is 0 or null
			//prefixes across segments have the pattern: null, null, ..., null, 0-16, 0, 0, ..., 0
			//So if the overall prefix is 0, then the prefix of every segment is 0
			currentPrefix = 0;
		}
		if((isNotNull = (seg0 != null)) || seg1 != null) {
			if(isNotNull) {
				if(seg1 == null) {
					seg1 = zeroSegment;
				}
			} else {
				seg0 = zeroSegment;
			}
			segments[ipv6StartIndex++] = join(creator, seg0, seg1, true /* only this first one gets the flipped bit */, currentPrefix);
		}
		
		//join 2 and 3 
		if(isExtended) {
			if((isNotNull = (seg2 != null)) || seg3 != null) {
				if(!isNotNull) {
					seg2 = zeroSegment;
					if(!seg3.matches(0xff)) {
						throw new IncompatibleAddressException(eui, "ipaddress.mac.error.not.eui.convertible");
					}
				}
				segments[ipv6StartIndex++] = join(creator, seg2, ffSegment, currentPrefix);
			}
			if((isNotNull = (seg4 != null)) || seg5 != null) {
				if(isNotNull) {
					if(!seg4.matches(0xfe)) {
						throw new IncompatibleAddressException(eui, "ipaddress.mac.error.not.eui.convertible");
					}
					if(seg5 == null) {
						seg5 = zeroSegment;
					}
				}
				segments[ipv6StartIndex++] = join(creator, feSegment, seg5, currentPrefix);
			}
		} else {
			if(seg2 != null) {
				segments[ipv6StartIndex++] = join(creator, seg2, ffSegment, currentPrefix);
			}
			if(seg3 != null) {
				segments[ipv6StartIndex++] = join(creator, feSegment, seg3, currentPrefix);
			}
			if((isNotNull = (seg4 != null)) || seg5 != null) {
				if(isNotNull) {
					if(seg5 == null) {
						seg5 = zeroSegment;
					}
				} else {
					seg4 = zeroSegment;
				}
				segments[ipv6StartIndex++] = join(creator, seg4, seg5, currentPrefix);
			}
		}
		if((isNotNull = (seg6 != null)) || seg7 != null) {
			if(isNotNull) {
				if(seg7 == null) {
					seg7 = zeroSegment;
				}
			} else {
				seg6 = zeroSegment;
			}
			segments[ipv6StartIndex] = join(creator, seg6, seg7, currentPrefix);
		}
		return segments;
	} 
	
	private static IPv6AddressSegment join(IPv6AddressCreator creator, MACAddressSegment macSegment0, MACAddressSegment macSegment1, Integer prefixLength) {
		return join(creator, macSegment0, macSegment1, false, prefixLength);
	}
	
	private static IPv6AddressSegment join(IPv6AddressCreator creator, MACAddressSegment macSegment0, MACAddressSegment macSegment1, boolean flip, Integer prefixLength) {
		if(macSegment0.isMultiple()) {
			// if the high segment has a range, the low segment must match the full range, 
			// otherwise it is not possible to create an equivalent range when joining
			if(!macSegment1.isFullRange()) {
				throw new IncompatibleAddressException(macSegment0, macSegment1, "ipaddress.error.invalidMACIPv6Range");
			}
		}
		int lower0 = macSegment0.getSegmentValue();
		int upper0 = macSegment0.getUpperSegmentValue();
		if(flip) {
			int mask2ndBit = 0x2;
			if(!macSegment0.matchesWithMask(mask2ndBit & lower0, mask2ndBit)) {
				throw new IncompatibleAddressException(macSegment0, "ipaddress.mac.error.not.eui.convertible");
			}
			lower0 ^= mask2ndBit;//flip the universal/local bit
			upper0 ^= mask2ndBit;
		}
		return creator.createSegment(
				(lower0 << 8) | macSegment1.getSegmentValue(), 
				(upper0 << 8) | macSegment1.getUpperSegmentValue(),
				prefixLength);
	}
	@Override
	public IPv6AddressNetwork getNetwork() {
		return defaultIpv6Network();
	}
	
	public MACAddressNetwork getMACNetwork() {
		return defaultMACNetwork();
	}
	
	public IPv4AddressNetwork getIPv4Network() {
		return defaultIpv4Network();
	}
	@Override
	public IPv6AddressSection getSection() {
		return (IPv6AddressSection) super.getSection();
	}
	@Override
	public IPv6AddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPv6AddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	
	@Override
	public IPv6AddressSegment getDivision(int index) {
		return getSegment(index);
	}
	
	@Override
	public IPv6AddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	
	@Override
	public IPv6AddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	public boolean isEUI64() {
		return getSection().isEUI64();
	}
	public MACAddress toEUI(boolean extended) {
		MACAddressSection section = getSection().toEUI(extended);
		if(section == null) {
			return null;
		}
		MACAddressCreator creator = getMACNetwork().getAddressCreator();
		return creator.createAddress(section);
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv6StringBuilderOptions.from(options));
	}
	
	public IPAddressStringDivisionSeries[] getParts(IPv6StringBuilderOptions options) {
		IPAddressStringDivisionSeries parts[] = getSection().getParts(options);
		IPv4Address ipv4Addr = getConverted(options);
		if(ipv4Addr != null) {
			IPAddressStringDivisionSeries ipv4Parts[] = ipv4Addr.getParts(options.ipv4ConverterOptions);
			IPAddressStringDivisionSeries tmp[] = parts;
			parts = new IPAddressStringDivisionSeries[tmp.length + ipv4Parts.length];
			System.arraycopy(tmp, 0, parts, 0, tmp.length);
			System.arraycopy(ipv4Parts,  0, parts, tmp.length, ipv4Parts.length);
		}
		return parts;
	}
	
	@Override
	public int getSegmentCount() {
		return SEGMENT_COUNT;
	}
	
	@Override
	public int getByteCount() {
		return BYTE_COUNT;
	}
	
	@Override
	public int getBitCount() {
		return BIT_COUNT;
	}
	
	void cache(IPv6Address lower, IPv6Address upper) {
		if((lower != null || upper != null) && getSection().getSingleLowestOrHighestSection() == null) {
			getSection().cache(lower != null ? lower.getSection() : null, upper != null ? upper.getSection() : null);
			IPv6AddressCache cache = addressCache;
			if(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null)) {
				synchronized(this) {
					cache = addressCache;
					boolean create = (cache == null);
					if(create) {
						addressCache = cache = new IPv6AddressCache();
						cache.lower = lower;
						cache.upper = upper;
					} else {
						if(cache.lower == null) {
							cache.lower = lower;
						}
						if(cache.upper == null) {
							cache.upper = upper;
						}
					}
				}
			}
		}
	}
	private IPv6Address getLowestOrHighest(boolean lowest, boolean excludeZeroHost) {
		IPv6AddressSection currentSection = getSection();
		IPv6AddressSection sectionResult = currentSection.getLowestOrHighestSection(lowest, excludeZeroHost);
		if(sectionResult == currentSection) {
			return this;
		} else if(sectionResult == null) {
			return null;
		}
		IPv6Address result = null;
		IPv6AddressCache cache = addressCache;
		if(cache == null || 
			(result = lowest ? (excludeZeroHost ? cache.lowerNonZeroHost : cache.lower) : cache.upper) == null) {
			synchronized(this) {
				cache = addressCache;
				boolean create = (cache == null);
				if(create) {
					addressCache = cache = new IPv6AddressCache();
				} else {
					if(lowest) {
						if(excludeZeroHost) {
							create = (result = cache.lowerNonZeroHost) == null;
						} else {
							create = (result = cache.lower) == null;
						}
					} else {
						create = (result = cache.upper) == null;
					}
				}
				if(create) {
					result = getCreator().createAddress(sectionResult);
					if(lowest) {
						if(excludeZeroHost) {
							 cache.lowerNonZeroHost = result;
						} else {
							cache.lower = result;
						}
					} else {
						cache.upper = result;
					}
				}
			}
		}
		return result;
	}
	
	@Override
	public IPv6Address getLowerNonZeroHost() {
		return getLowestOrHighest(true, true);
	}
	
	@Override
	public IPv6Address getLower() {
		return getLowestOrHighest(true, false);
	}
	
	@Override
	public IPv6Address getUpper() {
		return getLowestOrHighest(false, false);
	}
	/**
	 * Returns a pair of longs with the lower address value in the range of this individual address or subnet.
	 * The high bits are in the first element, the low bits in the second.
	 * 
	 * @return
	 */
	public long[] longValues() {
		return getSection().longValues();
	}
	/**
	 * Returns a pair of longs with the upper address value in the range of this individual address or subnet.
	 * The high bits are in the first element, the low bits in the second.
	 * 
	 * @return
	 */
	public long[] upperLongValues() {
		return getSection().upperLongValues();
	}
	IPv6TrieKeyData getTrieKeyCache() {
		IPv6TrieKeyData keyData = cachedTrieKeyData;
		if(keyData == null) {
			keyData = new IPv6TrieKeyData();
			Integer prefLen = getPrefixLength();
			keyData.prefixLength = prefLen;
			long vals[] = longValues();
			keyData.uint64HighVal = vals[0];
			keyData.uint64LowVal = vals[1];
			if(prefLen != null) {
				int bits = prefLen;
				IPv6Address mask = getNetwork().getNetworkMask(bits, false);
				vals = mask.longValues();
				keyData.mask64HighVal = vals[0];
				keyData.mask64LowVal = vals[1];
				if(bits > 63) {
					keyData.nextBitMask64Val = 0x8000000000000000L >>> (bits - 64);
				} else {
					keyData.nextBitMask64Val = 0x8000000000000000L >>> bits;
				}
			}
			cachedTrieKeyData = keyData;
		}
		return keyData;
	}
	/**
	 * Replaces segments starting from startIndex and ending before endIndex with the same number of segments starting at replacementStartIndex from the replacement section
	 * 
	 * @param startIndex
	 * @param endIndex
	 * @param replacement
	 * @param replacementIndex
	 * @throws IndexOutOfBoundsException
	 * @return
	 */
	public IPv6Address replace(int startIndex, int endIndex, IPv6Address replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	/**
	 * Replaces segments starting from startIndex with as many segments as possible from the replacement section
	 * 
	 * @param startIndex
	 * @param replacement
	 * @throws IndexOutOfBoundsException
	 * @return
	 */
	public IPv6Address replace(int startIndex, IPv6AddressSection replacement) {
		int replacementCount = Math.min(IPv6Address.SEGMENT_COUNT - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	@Override
	public IPv6Address reverseBits(boolean perByte) {
		return getCreator().createAddress(getSection().reverseBits(perByte));
	}
	@Override
	public IPv6Address reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	@Override
	public IPv6Address reverseBytesPerSegment() {
		return checkIdentity(getSection().reverseBytesPerSegment());
	}
	@Override
	public IPv6Address reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsNonZeroHostIterator() {
		return getSection().segmentsNonZeroHostIterator();
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	@Override
	public AddressComponentRangeSpliterator<IPv6Address, IPv6AddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getCreator());
	}
	@Override
	public Stream<IPv6AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixBlockIterator() {
		return getSection().prefixIterator(this, getCreator(), true);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getCreator(), true);
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixBlockIterator(int prefixLength) {
		return getSection().prefixIterator(this, getCreator(), true, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixBlockSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getCreator(), true, prefixLength);
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream(int prefixLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv6Address> prefixIterator() {
		return getSection().prefixIterator(this, getCreator(), false);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getCreator(), false);
	}
	@Override
	public Stream<IPv6Address> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixIterator(int prefixLength) {
		return getSection().prefixIterator(this, getCreator(), false, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getCreator(), false, prefixLength);
	}
	@Override
	public Stream<IPv6Address> prefixStream(int prefixLength) {
		return StreamSupport.stream(prefixSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv6Address> blockIterator(int segmentCount) {
		return getSection().blockIterator(this, getCreator(), segmentCount);
	}
	
	@Override
	public AddressComponentSpliterator<IPv6Address> blockSpliterator(int segmentCount) {
		return getSection().blockSpliterator(this, getCreator(), segmentCount);
	}
	
	@Override
	public Stream<IPv6Address> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6Address> sequentialBlockIterator() {
		return (Iterator<IPv6Address>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv6Address> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv6Address>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv6Address> sequentialBlockStream() {
		return (Stream<IPv6Address>) super.sequentialBlockStream();
	}
	@Override
	public Iterator<IPv6Address> iterator() {
		return getSection().iterator(this, getCreator(), null);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> spliterator() {
		return getSection().spliterator(this, getCreator(), false);
	}
	@Override
	public Stream<IPv6Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> nonZeroHostIterator() {
		Predicate<IPv6AddressSegment[]> excludeFunc = null;
		if(includesZeroHost()) {
			int prefLength = getNetworkPrefixLength();
			excludeFunc = segments -> getSection().isZeroHost(segments, prefLength);
		}
		return getSection().iterator(this, getCreator(), excludeFunc);
	}
	@Override
	public Iterable<IPv6Address> getIterable() {
		return this;
	}
	public IPv6Address increment(BigInteger increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv6Address increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	
	@Override
	public IPv6Address incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	/**
	 * If this address is IPv4 convertible, returns that address.
	 * Otherwise, returns null.
	 * <p>
	 * You can also use {@link #isIPv4Convertible()} to determine convertibility.  Both use an instance of {@link IPAddressConverter.DefaultAddressConverter} which uses IPv4-mapped address mappings from rfc 4038.
	 * <p>
	 * Override this method and {@link IPv6Address#isIPv4Convertible()} if you wish to map IPv6 to IPv4 according to the mappings defined by
	 * in {@link IPv6Address#isIPv4Compatible()}, {@link IPv6Address#isIPv4Mapped()}, {@link IPv6Address#is6To4()} or by some other mapping.
	 * <p>
	 * For the reverse mapping, see {@link IPv4Address#toIPv6()} 
	 */
	@Override
	public IPv4Address toIPv4() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.toIPv4(this);
	}
	
	@Override
	public IPv6Address toIPv6() {
		return this;
	}
	
	@Override
	public boolean isIPv6() {
		return true;
	}
	
	/**
	 * Determines whether this address can be converted to IPv4. 
	 * Override this method to convert in your own way.
	 * The default behaviour is to use isIPv4Mapped()
	 * 
	 * You should also override {@link #toIPv4()} to match the conversion.
	 * 
	 * @return
	 */
	@Override
	public boolean isIPv4Convertible() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.isIPv4Convertible(this);
	}
	
	@Override
	public boolean isIPv6Convertible() {
		return true;
	}
	/**
	 * ::ffff:x:x/96 indicates IPv6 address mapped to IPv4
	 */
	public IPv4AddressSection toMappedIPv4Segments() {
		if(isIPv4Mapped()) {
			return getSection().getEmbeddedIPv4AddressSection();
		}
		return null;
	}
	/**
	 * Returns the second and third segments as an {@link IPv4Address}.
	 * 
	 * This can be used for IPv4 or for IPv6 6to4 addresses convertible to IPv4.
	 * 
	 * @return the address
	 */
	public IPv4Address get6To4IPv4Address() {
		return getEmbeddedIPv4Address(2);
	}
	/**
	 * Returns the embedded {@link IPv4Address} in the lowest (least-significant) two segments.
	 * This is used by IPv4-mapped, IPv4-compatible, ISATAP addresses and 6over4 addresses
	 * 
	 * @return the embedded {@link IPv4Address}
	 */
	public IPv4Address getEmbeddedIPv4Address() {
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		return creator.createAddress(getSection().getEmbeddedIPv4AddressSection()); /* address creation */
	}
	
	/**
	 * Produces an IPv4 address from any sequence of 4 bytes in this IPv6 address.
	 * 
	 * @param byteIndex the byte index to start
	 * @throws IndexOutOfBoundsException if the index is less than zero or bigger than 7
	 * @return
	 */
	public IPv4Address getEmbeddedIPv4Address(int byteIndex) {
		if(byteIndex == IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT * IPv6Address.BYTES_PER_SEGMENT) {
			return getEmbeddedIPv4Address();
		}
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		return creator.createAddress(getSection().getEmbeddedIPv4AddressSection(byteIndex, byteIndex + IPv4Address.BYTE_COUNT)); /* address creation */
	}
	
	@Override
	public boolean isLocal() {
		if(isMulticast()) {
			/*
			 [RFC4291][RFC7346]
			 11111111|flgs|scop 
				scope 4 bits
				 1  Interface-Local scope
		         2  Link-Local scope
		         3  Realm-Local scope
		         4  Admin-Local scope
		         5  Site-Local scope
		         8  Organization-Local scope
		         E  Global scope
			 */
			IPv6AddressSegment firstSeg = getSegment(0);
			if(firstSeg.matchesWithMask(8, 0xf)) {
				return true;
			}
			if(firstSeg.getValueCount() <= 5 && 
					(firstSeg.getSegmentValue() & 0xf) >= 1 && (firstSeg.getUpperSegmentValue() & 0xf) <= 5) {
				//all values fall within the range from interface local to site local
				return true;
			}
			
			//source specific multicast
			//rfc4607 and https://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml
			//FF3X::8000:0 - FF3X::FFFF:FFFF	Reserved for local host allocation	[RFC4607]
			if(firstSeg.matchesWithPrefixMask(0xff30, 12) && getSegment(6).matchesWithPrefixMask(0x8000, 1)) {
				return true;
			}
		}
		return isLinkLocal() || isSiteLocal() || isUniqueLocal() || isAnyLocal();
	}
	
	/**
	 * @see java.net.InetAddress#isLinkLocalAddress()
	 */
	@Override
	public boolean isLinkLocal() {
		IPv6AddressSegment firstSeg = getSegment(0);
		return (isMulticast() && firstSeg.matchesWithMask(2, 0xf)) || // ffx2::/16
				//1111 1110 10 .... fe8x currently only in use
				firstSeg.matchesWithPrefixMask(0xfe80, 10);
	}
	
	/**
	 * @see java.net.InetAddress#isSiteLocalAddress()
	 */
	public boolean isSiteLocal() {
		IPv6AddressSegment firstSeg = getSegment(0);
		return (isMulticast() && firstSeg.matchesWithMask(5, 0xf)) ||  // ffx5::/16
				//1111 1110 11 ...
				firstSeg.matchesWithPrefixMask(0xfec0, 10); // deprecated RFC 3879
	}
	
	public boolean isUniqueLocal() {
		//RFC 4193
		return getSegment(0).matchesWithPrefixMask(0xfc00, 7);
	}
	
	/**
	 * Whether the address is IPv4-mapped
	 * 
	 * ::ffff:x:x/96 indicates IPv6 address mapped to IPv4
	 */
	public boolean isIPv4Mapped() {
		//::ffff:x:x/96 indicates IPv6 address mapped to IPv4
		if(getSegment(5).matches(IPv6Address.MAX_VALUE_PER_SEGMENT)) {
			for(int i = 0; i < 5; i++) {
				if(!getSegment(i).isZero()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	
	/**
	 * Whether the address is IPv4-compatible
	 * 
	 * @see java.net.Inet6Address#isIPv4CompatibleAddress()
	 */
	public boolean isIPv4Compatible() {
		return getSegment(0).isZero() && getSegment(1).isZero() && getSegment(2).isZero() &&
				getSegment(3).isZero() && getSegment(4).isZero() && getSegment(5).isZero();
	}
	
	/**
	 * Whether the address is IPv6 to IPv4 relay
	 * @see #get6To4IPv4Address()
	 */
	public boolean is6To4() {
		//2002::/16
		return getSegment(0).matches(0x2002);
	}
	
	/**
	 * Whether the address is 6over4
	 */
	public boolean is6Over4() {
		return getSegment(0).matches(0xfe80) && 
				getSegment(1).isZero() && getSegment(2).isZero() &&
				getSegment(3).isZero() && getSegment(4).isZero() &&
				getSegment(5).isZero();
	}
	
	/**
	 * Whether the address is Teredo
	 */
	public boolean isTeredo() {
		//2001::/32
		return getSegment(0).matches(0x2001) && getSegment(1).isZero();
	}
	/**
	 * Whether the address is ISATAP
	 */
	public boolean isIsatap() {
		// 0,1,2,3 is fe80::
		// 4 can be 0200
		return getSegment(0).matches(0xfe80) &&
				getSegment(1).isZero() &&
				getSegment(2).isZero() &&
				getSegment(3).isZero() &&
				(getSegment(4).isZero() || getSegment(4).matches(0x200)) && 
				getSegment(5).matches(0x5efe);
	}
	
	/**
	 * 
	 * @return Whether the address is IPv4 translatable as in rfc 2765
	 */
	public boolean isIPv4Translatable() { //rfc 2765  
		//::ffff:0:x:x/96 indicates IPv6 addresses translated from IPv4
		return getSegment(4).matches(0xffff) && 
				getSegment(5).isZero() &&
				getSegment(0).isZero() &&
				getSegment(1).isZero() &&
				getSegment(2).isZero() &&
				getSegment(3).isZero();
	}
	
	/**
	 * Whether the address has the well-known prefix for IPv4 translatable addresses as in rfc 6052 and 6144
	 * @return
	 */
	public boolean isWellKnownIPv4Translatable() { //rfc 6052 rfc 6144
		//64:ff9b::/96 prefix for auto ipv4/ipv6 translation
		if(getSegment(0).matches(0x64) && getSegment(1).matches(0xff9b)) {
			for(int i=2; i<=5; i++) {
				if(!getSegment(i).isZero()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	
	@Override
	public boolean isMulticast() {
		// 11111111...
		return getSegment(0).matchesWithPrefixMask(0xff00, 8);
	}
	/**
	 * @see java.net.InetAddress#isLoopbackAddress()
	 */
	@Override
	public boolean isLoopback() {
		//::1
		int i=0;
		for(; i < getSegmentCount() - 1; i++) {
			if(!getSegment(i).isZero()) {
				return false;
			}
		}
		return getSegment(i).matches(1);
	}
	
	@Override
	public IPv6Address intersect(IPAddress other) throws AddressConversionException {
		IPv6AddressSection thisSection = getSection();
		IPv6Address otherAddr = convertArg(other);
		IPv6AddressSection section = thisSection.intersect(otherAddr.getSection());
		if(section == null) {
			return null;
		}
		//if they have the same zone, then use it in the intersection, otherwise ignore the zones
		IPv6AddressCreator creator = isSameZone(otherAddr) ? getCreator() : getDefaultCreator();
		IPv6Address result = creator.createAddress(section);
		return result;
	}
	
	@Override
	public IPv6Address[] subtract(IPAddress other) throws AddressConversionException {
		IPv6AddressSection thisSection = getSection();
		IPv6AddressSection sections[] = thisSection.subtract(convertArg(other).getSection());
		if(sections == null) {
			return null;
		}
		IPv6Address result[] = new IPv6Address[sections.length];
		for(int i = 0; i < result.length; i++) {
			result[i] = getCreator().createAddress(sections[i]); /* address creation */
		}
		return result;
	}
	private IPv6Address checkIdentity(IPv6AddressSection newSection) {
		if(newSection == getSection()) {
			return this;
		}
		return getCreator().createAddress(newSection);
	}
	
	@Override
	public IPv6Address adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	
	@Override
	public IPv6Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public IPv6Address adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	@Override
	public IPv6Address adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength) throws PrefixLenException {
		return setPrefixLength(prefixLength, true);
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength, boolean zeroed) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed, zeroHostIsBlock));
	}
	@Deprecated
	@Override
	public IPv6Address applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().applyPrefixLength(networkPrefixLength));
	}
	@Override @Deprecated
	public IPv6Address removePrefixLength() {
		return removePrefixLength(true);
	}
	
	@Override
	public IPv6Address withoutPrefixLength() {
		return removePrefixLength(false);
	}
	
	@Override @Deprecated
	public IPv6Address removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	@Override
	protected IPv6Address convertArg(IPAddress arg) throws AddressConversionException {
		IPv6Address converted = arg.toIPv6();
		if(converted == null) {
			throw new AddressConversionException(this, arg);
		}
		return converted;
	}
	
	@Override
	public IPv6Address toZeroHost() {
		return toZeroHost(false);
	}
	@Override
	protected IPv6Address toZeroHost(boolean boundariesOnly) {
		if(!isPrefixed()) {
			IPv6AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv6Address addr = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				addr = addr.getLower();
			}
			return addr;
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();//cached
		}
		return checkIdentity(getSection().createZeroHost(boundariesOnly));
	}
	@Override
	public IPv6Address toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		return checkIdentity(getSection().toZeroHost(prefixLength));
	}
	
	@Override
	public IPv6Address toZeroNetwork() {
		if(!isPrefixed()) {
			return getNetwork().getHostMask(getBitCount());
		}
		return checkIdentity(getSection().createZeroNetwork());
	}
	@Override
	public IPv6Address toMaxHost() {
		if(!isPrefixed()) {
			IPv6Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix;
			}
			return resultNoPrefix.setPrefixLength(0);
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();
		}
		return checkIdentity(getSection().createMaxHost());
	}
	
	@Override
	public IPv6Address toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		return checkIdentity(getSection().toMaxHost(prefixLength));
	}
	
	@Override
	public IPv6Address mask(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().mask(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv6Address mask(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return mask(mask, false);
	}
	@Override
	public IPv6Address maskNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().maskNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	
	@Override
	public IPv6Address bitwiseOr(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOr(convertArg(mask).getSection(), retainPrefix));
	}
	
	@Override
	public IPv6Address bitwiseOr(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return bitwiseOr(mask, false);
	}
	
	@Override
	public IPv6Address bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOrNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv6Address getHostMask() {
		return (IPv6Address) super.getHostMask();
	}
	@Override
	public IPv6Address getNetworkMask() {
		return (IPv6Address) super.getNetworkMask();
	}
	@Override
	public IPv6AddressSection getNetworkSection() {
		return getSection().getNetworkSection();
	}
	
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength);
	}
	
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength, withPrefixLength);
	}
	
	@Override
	public IPv6AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getHostSection(networkPrefixLength);
	}
	
	@Override
	public IPv6AddressSection getHostSection() {
		return getSection().getHostSection();
	}
	
	@Override
	public IPv6Address toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv6Address toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().toPrefixBlock(networkPrefixLength));
	}
	@Override
	public IPv6Address assignPrefixForSingleBlock() {
		return (IPv6Address) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv6Address assignMinPrefixForBlock() {
		return (IPv6Address) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv6Address coverWithPrefixBlock() {
		return (IPv6Address) IPv6AddressSection.coverWithPrefixBlock(this, getLower(), getUpper());
	}
	@Override
	public IPv6Address coverWithPrefixBlock(IPAddress other) throws AddressConversionException {
		return IPv6AddressSection.coverWithPrefixBlock(
				this.removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	/**
	 * Produces an array of prefix blocks that cover the same set of addresses as this.
	 * <p>
	 * Unlike {@link #spanWithPrefixBlocks(IPAddress)} this method only includes addresses that are a part of this subnet.
	 */
	@Override
	public IPv6Address[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv6Address[] {removeZone()};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6Address> list = (ArrayList<IPv6Address>) removeZone().spanWithBlocks(true);
		return list.toArray(new IPv6Address[list.size()]);
	}
	
	@Override
	public IPv6Address[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningPrefixBlocks(
				removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6Address::assignPrefixForSingleBlock,
				IPv6Address::withoutPrefixLength,
				getCreator()::createAddressArray);
	}
	
	/**
	 * Produces an array of blocks that are sequential that cover the same set of addresses as this.
	 * <p>
	 * This array can be shorter than that produced by {@link #spanWithPrefixBlocks()} and is never longer.
	 * <p>
	 * Unlike {@link #spanWithSequentialBlocks(IPAddress)} this method only includes addresses that are a part of this subnet.
	 */
	@Override
	public IPv6Address[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv6Address[] { withoutPrefixLength().removeZone() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6Address> list = (ArrayList<IPv6Address>) removeZone().spanWithBlocks(false);
		return list.toArray(new IPv6Address[list.size()]);
	}
	@Override
	public IPv6Address[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningSequentialBlocks(
				this.removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6Address::withoutPrefixLength,
				getDefaultCreator());
	}
	@Override
	public IPv6AddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException {
		return toSequentialRange(other);
	}
	@Override
	public IPv6Address[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSinglePrefixBlock()) {
				return new IPv6Address[] {removeZone()};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv6Address[blocks.size()]);
	}
	private IPAddress[] getConverted(IPAddress... addresses) {
		IPAddress converted[] = new IPAddress[addresses.length + 1];
		for(int i = 0, j = 1; i < addresses.length; i = j++) {
			converted[j] = convertArg(addresses[i]).removeZone();
		}
		converted[0] = removeZone();
		return converted;
	}
	
	@Override
	public IPv6Address[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSequential()) {
				return new IPv6Address[] {removeZone()};
			}
		}
		addresses = addresses.clone();
		for(int i = 0; i < addresses.length; i++) {
			addresses[i] = convertArg(addresses[i]).removeZone();
		}
		
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getDefaultCreator());
		return blocks.toArray(new IPv6Address[blocks.size()]);
	}
	@Override
	protected SeriesCreator getSequentialSeriesCreator() {
		return getDefaultCreator()::createSequentialBlockAddress;
	}
	/**
	 * Returns whether {@link #getZone()} returns a non-null value
	 * 
	 * @return
	 */
	public boolean hasZone() {
		return zone != null;
	}
	/**
	 * The zone or scope id string, which as a string is typically appended to an address with a '%', eg fe80::71a3:2b00:ddd3:753f%16
	 * 
	 * If there is no zone or scope id, returns null.
	 * <p>
	 * See {@link #getIPv6Zone()}
	 * 
	 * @return
	 */
	public String getZone() {
		return getZoneString();
	}
	/**
	 * Returns a new address with the same address values but with the supplied zone.
	 * If the supplied zone is null, equivalent to calling {@link #removeZone()}
	 * 
	 * @param newZone
	 * @return
	 */
	public IPv6Address setZone(IPv6Zone newZone) {
		if(newZone == null) {
			return removeZone();
		}
		return getDefaultCreator().createAddress(getSection(), newZone); /* address creation */
	}
	
	/**
	 * Returns the zone or scope id, consisting of a network interface name or a positive integer scope identifier.
	 * 
	 * If there is no zone or scope id, returns null
	 * <p>
	 * An IPv6 zone distinguishes two IPv6 addresses that are the same.
	 * They are used with link-local addresses fe80::/10 and distinguishes two interfaces to the link-local network, this is known as the zone id.
	 * They are used with site-local addresses to distinguish sites, using the site id, also known as the scope id.
	 * 
	 * A zone that consists of a scope id is called a scoped zone.
	 * 
	 * See {@link #getZone()}
	 * 
	 * @return
	 */
	public IPv6Zone getIPv6Zone() {
		return zone;
	}
	/**
	 * Returns the equivalent address but with no zone.
	 * 
	 * @return
	 */
	public IPv6Address removeZone() {
		if(hasZone()) {
			return getDefaultCreator().createAddress(getSection()); /* address creation */
		}
		return this;
	}
	protected boolean hasNoValueCache() {
		if(addressCache == null) {
			synchronized(this) {
				if(addressCache == null) {
					addressCache = new IPv6AddressCache();
					return true;
				}
			}
		}
		return false;
	}
	
	/**
	 * Converts the lowest value of this address and the associated zone to an Inet6Address. 
	 * <p>
	 * Address with a zone should check for null.
	 * <p>
	 * This will return null if this IPv6 Address has a zone (available from {@link #getIPv6Zone()}),
	 * that zone references a network interface ({@link IPv6Zone#referencesInterface} is true) 
	 * and that network interface (from {@link IPv6Zone#getAssociatedIntf()}) is an IPv4-only interface,
	 * or that interface is not entirely link-local and this address is link-local, 
	 * or that interface is not entirely site-local and this address is site-local.
	 * <p>
	 * This will return null if this IPv6 Address has a zone (available from {@link #getIPv6Zone()}) and:
	 * <ul>
	 * <li>the zone is a scoped id and the address is a global IPv6 address.</li>
	 * <li>the zone specifies an interface that does not exist on this host.</li>
	 * <li>the zone specifies an interface that is IPv4 only.</li>
	 * <li>the zone specifies an interface that is not entirely link-local and this address is link-local.</li>
	 * <li>the zone specifies an interface that is not entirely site-local and this address is site-local.</li>
	 * </ul>
	 * In those cases, the corresponding Java SDK methods such as {@link Inet6Address#getByAddress(String, byte[], NetworkInterface)} 
	 * will throw UnknownHostException when constructed with the same network interface.
	 * <p>
	 * If this address is IPv4-mapped, then any associated zone will be discarded, 
	 * because it is not possible to create an IPv4-mapped Inet6Address with a zone.
	 */
	@Override
	public Inet6Address toInetAddress() {
		if(hasZone()) {
			//we cache the address in here and not in the address section if there is a zone
			Inet6Address result;
			if(hasNoValueCache() || (result = addressCache.inetAddress) == null) {
				addressCache.inetAddress = result = (Inet6Address) toInetAddressImpl();
			}
			return result;
		}
		return (Inet6Address) super.toInetAddress();
	}
	
	@Override
	public Inet6Address toUpperInetAddress() {
		return (Inet6Address) super.toUpperInetAddress();
	}
	@Override
	protected Inet6Address toInetAddressImpl() {
		Inet6Address result;
		byte bytes[] = getSection().getBytesInternal();
		try {
			if(hasZone()) {
				if(zone.referencesScopeId()) {
					result = Inet6Address.getByAddress(null, bytes, zone.getAssociatedScopeId());
				} else if(zone.referencesIntf() && zone.getAssociatedIntf() != null) {
					result = Inet6Address.getByAddress(null, bytes, zone.getAssociatedIntf());
				} else {
					// When the original zone was provided as a string, we use that here.
					// There is no related function that takes a string as third arg, so we reconstruct the address string.
					//
					// When interface name is not known as an interface on the current host, this throws UnknownHostException
					//
					// We need to drop the prefix, and we also need to use the lower address so no wildcards
					//
					// Note that this call to getLower() assumes we want the lower address.  
					// Since toUpperInetAddress calls getUpper().toInetAddress, this works.
					IPv6Address adjusted = getLower().withoutPrefixLength();
					InetAddress resultIP = InetAddress.getByName(adjusted.toNormalizedString());
					if(resultIP instanceof Inet6Address) {
						result = (Inet6Address) resultIP;
					} else {
						// the InetAddress code is throwing away the interface name because the address is IPv4-mapped
						// so the only way to get an IPv6 address, any address at all in fact, requires that we throw it away
						result = Inet6Address.getByAddress(null, bytes, null);
					}
				}
			} else {
				result = Inet6Address.getByAddress(null, bytes, null);
			}
		} catch(UnknownHostException e) {
			result = null;
		}
		return result;
	}
	
	@Override
	@Deprecated
	public IPv6AddressSeqRange toSequentialRange(IPAddress other) {
		return new IPv6AddressSeqRange(this, convertArg(other));
	}
	@Override
	public IPv6AddressSeqRange toSequentialRange() {
		IPv6Address thiz = removeZone().withoutPrefixLength();
		return new IPv6AddressSeqRange(thiz.getLower(), thiz.getUpper(), true);
	}
	
	@Override
	public int hashCode() {
		int result = super.hashCode();
		if(hasZone()) {
			result *= zone.getName().hashCode();
		}
		return result;
	}
	
	@Override
	public boolean isSameAddress(Address other) {
		return other instanceof IPv6Address && super.isSameAddress(other) && isSameZone((IPv6Address) other);
	}
	
	private boolean isSameZone(IPv6Address otherIPv6Address) {
		return Objects.equals(zone, otherIPv6Address.zone);
	}
	/**
	 * 
	 * @param other
	 * @return whether this subnet overlaps the given address
	 */
	@Override
	public boolean overlaps(Address other) {
		if(super.overlaps(other)) {
			//must check the zone too
			if(other != this) {
				IPv6Address otherAddr = (IPv6Address) other;
				if(hasZone() || otherAddr.hasZone()) {
					//if it has a zone, then it does not overlap addresses from other zones
					return isSameZone(otherAddr);
				}
			}
			return true;
		}
		return false;
	}
	/**
	 * 
	 * @param other
	 * @return whether this subnet contains the given address
	 */
	@Override
	public boolean contains(Address other) {
		if(super.contains(other)) {
			//must check the zone too
			if(other != this) {
				IPv6Address otherAddr = (IPv6Address) other;
				if(hasZone() || otherAddr.hasZone()) {
					//if it has a zone, then it does not contain addresses from other zones
					return isSameZone(otherAddr);
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof IPv6Address) {
			return IPv6AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	
	@Override
	public BigInteger enumerate(IPAddress other) {
		if(other.isIPv6()) {
			return IPv6AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	//////////////// string creation below ///////////////////////////////////////////////////////////////////////////////////////////
	@Override
	protected IPAddressStringParameters createFromStringParams() {
		return new IPAddressStringParameters.Builder().
				getIPv4AddressParametersBuilder().setNetwork(getIPv4Network()).getParentBuilder().
				getIPv6AddressParametersBuilder().setNetwork(getNetwork()).getParentBuilder().toParams();
	}
	
	private boolean hasNoStringCache() {
		if(stringCache == null) {
			synchronized(this) {
				if(stringCache == null) {
					if(hasZone()) {
						stringCache = new IPv6StringCache();
						return true;
					} else {
						//when there is no zone, the section and address strings are the same, so we use the same cache
						IPv6AddressSection section = getSection();
						boolean result = section.hasNoStringCache();
						stringCache = section.getStringCache();
						return result;
					}
				}
			}
		}
		return false;
	}
	
	/**
	 * Produces a string in which the lower 4 bytes are expressed as an IPv4 address and the remaining upper bytes are expressed in IPv6 format.
	 * 
	 * This the mixed IPv6/IPv4 format described in RFC 1884 https://tools.ietf.org/html/rfc1884
	 * 
	 * @return
	 */
	public String toMixedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.mixedString) == null) {
			if(hasZone()) {
				stringCache.mixedString = result = toNormalizedString(IPv6StringCache.mixedParams);
			} else {
				result = getSection().toMixedString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	/**
	 * This produces a canonical string.
	 * 
	 * RFC 5952 describes canonical representations.
	 * http://en.wikipedia.org/wiki/IPv6_address#Recommended_representation_as_text
	 * http://tools.ietf.org/html/rfc5952
	 * 
	 * If this has a prefix length, that will be included in the string.
	 */
	@Override
	public String toCanonicalString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalString) == null) {
			if(hasZone()) {
				stringCache.canonicalString = result = toNormalizedString(IPv6StringCache.canonicalParams);
			} else {
				result = getSection().toCanonicalString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	@Override
	public String toFullString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.fullString) == null) {
			if(hasZone()) {
				stringCache.fullString = result = toNormalizedString(IPv6StringCache.fullParams);
			} else {
				result = getSection().toFullString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	/**
	 * Creates the normalized string for an address without having to create the address objects first.
	 * 
	 * @param lowerValueProvider
	 * @param upperValueProvider
	 * @param prefixLength
	 * @param zone
	 * @param network use {@link #defaultIpv6Network()} if there is no custom network in use
	 * @return
	 */
	public static String toNormalizedString(IPv6AddressNetwork network, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
		return toNormalizedString(network.getPrefixConfiguration(), lowerValueProvider, upperValueProvider, prefixLength, SEGMENT_COUNT, BYTES_PER_SEGMENT, BITS_PER_SEGMENT, MAX_VALUE_PER_SEGMENT, SEGMENT_SEPARATOR, DEFAULT_TEXTUAL_RADIX, zone);
	}
	/**
	 * The normalized string returned by this method is consistent with java.net.Inet6address.
	 * 
	 * IPs are not compressed nor mixed in this representation.  If this has a prefix length, that will be included in the string.
	 */
	@Override
	public String toNormalizedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedString) == null) {
			if(hasZone()) {
				stringCache.normalizedString = result = toNormalizedString(IPv6StringCache.normalizedParams);
			} else {
				result = getSection().toNormalizedString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	/**
	 * This compresses the maximum number of zeros and/or host segments with the IPv6 compression notation '::'
	 */
	@Override
	public String toCompressedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.compressedString) == null) {
			if(hasZone()) {
				stringCache.compressedString = result = toNormalizedString(IPv6StringCache.compressedParams);
			} else {
				result = getSection().toCompressedString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toSubnetString() {
		return toPrefixLengthString();
	}
	
	//note this string is used by hashCode
	@Override
	public String toNormalizedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedWildcardString) == null) {
			if(hasZone()) {
				stringCache.normalizedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardNormalizedParams);
			} else {
				result = getSection().toNormalizedWildcardString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	/**
	 * The base 85 string is described by RFC 1924
	 * @return
	 */
	public String toBase85String() throws IncompatibleAddressException {
		//first we see if we obtained this address from a base 85 string
		//in the case of a prefix, applying the prefix changes the value
		IPAddressString originator = getAddressfromString();
		if(originator != null && (!isPrefixed() || getNetworkPrefixLength() == IPv6Address.BIT_COUNT) && 
				originator.isBase85IPv6()) {
			return originator.toString();
		}
		String result;
		if(hasNoStringCache() || (result = stringCache.base85String) == null) {
			if(hasZone()) {
				stringCache.base85String = result = getSection().toBase85String(getZone());
			} else {
				result = getSection().toBase85String();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toCanonicalWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalWildcardString) == null) {
			if(hasZone()) {
				stringCache.canonicalWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCanonicalParams);
			} else {
				result = getSection().toCanonicalWildcardString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toCompressedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.compressedWildcardString) == null) {
			if(hasZone()) {
				stringCache.compressedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCompressedParams);
			} else {
				result = getSection().toCompressedWildcardString();//the cache is shared with the section, so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toSQLWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.sqlWildcardString) == null) {
			if(hasZone()) {
				stringCache.sqlWildcardString = result = toNormalizedString(IPv6StringCache.sqlWildcardParams);
			} else {
				result = getSection().toSQLWildcardString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = (with0xPrefix ? stringCache.hexStringPrefixed : stringCache.hexString)) == null) {
			if(hasZone()) {
				result = getSection().toHexString(with0xPrefix, zone.getName());
				if(with0xPrefix) {
					stringCache.hexStringPrefixed = result;
				} else {
					stringCache.hexString = result;
				}
			} else {
				result = getSection().toHexString(with0xPrefix);//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	private String getZoneString() {
		return hasZone() ? zone.getName() : null;
	}
	
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = stringCache.binaryString) == null) {
			if(hasZone()) {
				result = getSection().toBinaryString(zone.getName());
				stringCache.binaryString = result;
			} else {
				result = getSection().toBinaryString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toSegmentedBinaryString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.segmentedBinaryString) == null) {
			if(hasZone()) {
				result = getSection().toSegmentedBinaryString(zone.getName());
				stringCache.segmentedBinaryString = result;
			} else {
				result = getSection().toSegmentedBinaryString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = (with0Prefix ? stringCache.octalStringPrefixed : stringCache.octalString)) == null) {
			if(hasZone()) {
				result = getSection().toOctalString(with0Prefix, zone.getName());
				if(with0Prefix) {
					stringCache.octalStringPrefixed = result;
				} else {
					stringCache.octalString = result;
				}
			} else {
				result = getSection().toOctalString(with0Prefix);//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	@Override
	public String toPrefixLengthString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.networkPrefixLengthString) == null) {
			if(hasZone()) {
				stringCache.networkPrefixLengthString = result = toNormalizedString(IPv6StringCache.networkPrefixLengthParams);
			} else {
				result = getSection().toPrefixLengthString();//the cache is shared so no need to update it here
			}
		}
		return result;
	}
	
	@Override
	public String toConvertedString() {
		if(isIPv4Convertible()) {
			return toMixedString();
		}
		return toNormalizedString();
	}
	
	@Override
	public String toNormalizedString(IPStringOptions params) {
		return getSection().toNormalizedString(params, getZoneString());
	}
	
	public String toNormalizedString(IPv6StringOptions params) {
		return getSection().toNormalizedString(params, getZoneString());
	}
	/**
	 * Constructs a string representing this address according to the given parameters
	 * 
	 * @param keepMixed if this address was constructed from a string with mixed representation (a:b:c:d:e:f:1.2.3.4), whether to keep it that way (ignored if makeMixed is true in the params argument)
	 * @param params the parameters for the address string
	 */
	public String toNormalizedString(boolean keepMixed, IPv6StringOptions params) {
		if(keepMixed && fromString != null && getAddressfromString().isMixedIPv6() && !params.makeMixed()) {
			params = new IPv6StringOptions(
					params.base,
					params.expandSegments,
					params.wildcardOption,
					params.wildcards,
					params.segmentStrPrefix,
					true,
					params.ipv4Opts,
					params.compressOptions,
					params.separator,
					params.zoneSeparator,
					params.addrLabel,
					params.addrSuffix,
					params.reverse,
					params.splitDigits,
					params.uppercase);
		}
		return toNormalizedString(params);
	}
	
	@Override
	public String toUNCHostName() {
		String result;
		if(hasNoStringCache() || (result = stringCache.uncString) == null) {
			//it seems for unc hosts we not only replace the zone character % with s and the segment separator : with -,
			//we do the same for any such characters appearing in the zone itself as well
			//see https://blogs.msdn.microsoft.com/oldnewthing/20100915-00/?p=12863/
			String newZone;
			if(hasZone()) {
				newZone = zone.getName().replace(IPv6Address.ZONE_SEPARATOR, IPv6Address.UNC_ZONE_SEPARATOR).replace(IPv6Address.SEGMENT_SEPARATOR, IPv6Address.UNC_SEGMENT_SEPARATOR);
			} else {
				newZone = null;
			}
			stringCache.uncString = result = getSection().toNormalizedString(IPv6StringCache.uncParams, newZone);
		}
		return result;
	}
	
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.ALL_OPTS);
	}
	
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv6StringBuilderOptions.from(opts));
	}
	private IPv4Address getConverted(IPv6StringBuilderOptions opts) {
		if(!hasZone() && opts.includes(IPv6StringBuilderOptions.IPV4_CONVERSIONS)) {//we cannot convert to ipv4 if there is a zone
			IPv4AddressConverter converter = opts.converter;
			return converter.toIPv4(this);
		}
		return null;
	}
	
	public IPAddressPartStringCollection toStringCollection(IPv6StringBuilderOptions opts) {
		IPv6StringCollection coll = getSection().toStringCollection(opts, getZoneString());
		IPv4Address ipv4Addr = getConverted(opts);
		if(ipv4Addr != null) {
			IPAddressPartStringCollection ipv4StringCollection = ipv4Addr.toStringCollection(opts.ipv4ConverterOptions);
			coll.addAll(ipv4StringCollection);
		}
		return coll;
	}
	
	/**
	 * @custom.core
	 * @author sfoley
	 *
	 */
	public interface IPv6AddressConverter {
		/**
		 * If the given address is IPv6, or can be converted to IPv6, returns that {@link IPv6Address}.  Otherwise, returns null.
		 */
		IPv6Address toIPv6(IPAddress address);
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.util.Iterator;
import java.util.stream.Stream;
import inet.ipaddr.format.AddressGenericDivision;
import inet.ipaddr.format.util.AddressComponentSpliterator;
/**
 * Represents a single segment of an address.
 * <p>
 * The current implementations of this class are the most common representations of IPv4, IPv6 and MAC; 
 * segments are 1 byte for Ipv4, they are two bytes for Ipv6, and they are 1 byte for MAC addresses.
 * <p>
 * There are alternative forms of dividing addresses into divisions, such as the dotted representation for MAC like 1111.2222.3333,
 * the embedded IPv4 representation for IPv6 like f:f:f:f:f:f:1.2.3.4, the inet_aton formats like 1.2 for IPv4, and so on.
 * <p>
 * If those alternative representations were to follow the general rules for segment representation, then you could reuse this class
 * for those alternative representations.
 * <p>
 * The general rules are that segments have a whole number of bytes, and in a given address all segments have the same length.
 * <p>
 * When alternatives forms do not follow the general rules for segments,
 * you can use the {@link inet.ipaddr.format.standard.AddressDivision} interface instead.  
 * Divisions do not have the restriction that divisions of an address are equal length and a whole number of bytes.
 * Divisions can be grouped using {@link inet.ipaddr.format.standard.AddressDivisionGrouping}.
 * <p>
 * AddressSegment objects are immutable and thus also thread-safe.
 * 
 * @author sfoley
 *
 */
public interface AddressSegment extends AddressComponent, AddressGenericDivision {
	/**
	 * Returns the count of values in this address segment.
	 * 
	 * @return the same value as {@link #getCount()} as an integer
	 */
	int getValueCount();
	/**
	 * Returns the count of prefix values in this address segment for the given prefix bit count.
	 * 
	 * @return the count of values
	 */
	int getPrefixValueCount(int segmentPrefixLength);
	
	/**
	 * returns the lower value
	 */
	int getSegmentValue();
	/**
	 * returns the upper value
	 */
	int getUpperSegmentValue();
	/**
	 * If this segment represents a range of values, returns a segment representing just the lowest value in the range, otherwise returns this.
	 * @return
	 */
	@Override
	AddressSegment getLower();
	/**
	 * If this segment represents a range of values, returns a segment representing just the highest value in the range, otherwise returns this.
	 * @return
	 */
	@Override
	AddressSegment getUpper();
	@Override
	AddressSegment reverseBits(boolean perByte);
	@Override
	AddressSegment reverseBytes();
	@Override
	Iterable<? extends AddressSegment> getIterable();
	@Override
	Iterator<? extends AddressSegment> iterator();
	@Override
	AddressComponentSpliterator<? extends AddressSegment> spliterator();
	@Override
	Stream<? extends AddressSegment> stream();
	boolean matches(int value);
	boolean matchesWithMask(int value, int mask);
	boolean matchesWithMask(int lowerValue, int upperValue, int mask);
	boolean overlaps(AddressSegment other);
	boolean contains(AddressSegment other);
	@Override
	boolean equals(Object other);
	/**
	 * Returns whether the given prefix bits match the same bits of the given segment.
	 * 
	 * @param other
	 * @param prefixLength
	 * @return
	 */
	boolean prefixEquals(AddressSegment other, int prefixLength);
	/**
	 * Analogous to {@link java.math.BigInteger#testBit},
	 * Computes (this &amp; (1 &lt;&lt; n)) != 0), using the lower value of this segment.
	 * 
	 * @see AddressSegmentSeries#testBit(int)
	 * @see #isOneBit(int)
	 * 
	 * @throws IndexOutOfBoundsException if the index is negative or as large as the bit count
	 * 
	 * @param n
	 * @return
	 */
	default boolean testBit(int n) {
		int value = getSegmentValue();
		int bitCount = getBitCount();
		if(n < 0 || n >= bitCount) {
			throw new IndexOutOfBoundsException();
		}
		return (value & (1 << n)) != 0;
	}
	
	/**
	 * Returns true if the bit in the lower value of this segment at the given index is 1, where index 0 is the most significant bit.
	 * 
	 * @see AddressSegmentSeries#isOneBit(int)
	 * @see #testBit(int)
	 * 
	 * @throws IndexOutOfBoundsException if the index is negative or as large as the bit count
	 * 
	 * @param segmentBitIndex
	 * @return
	 */
	default boolean isOneBit(int segmentBitIndex) {
		int value = getSegmentValue();
		int bitCount = getBitCount();
		if(segmentBitIndex < 0 || segmentBitIndex >= bitCount) {
			throw new IndexOutOfBoundsException();
		}
		return (value & (1 << (bitCount - (segmentBitIndex + 1)))) != 0;
	}
	/**
	 * Gets the maximum possible value for this type of segment (for the highest range value of this particular segment, use {@link #getUpper()}
	 * 
	 * @return
	 */
	int getMaxSegmentValue();
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.standard;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Objects;
import inet.ipaddr.Address;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.format.AddressDivisionBase;
import inet.ipaddr.format.validate.ParsedIPAddress;
import inet.ipaddr.format.validate.ParsedIPAddress.BitwiseOrer;
import inet.ipaddr.format.validate.ParsedIPAddress.Masker;
/**
 * A division of an address.
 * 
 * @author sfoley
 *
 */
public abstract class AddressDivision extends AddressDivisionBase {
	private static final long serialVersionUID = 4L;
	protected AddressDivision() {}
	@Override
	protected byte[] getBytesImpl(boolean low) {
		int bitCount = getBitCount();
		byte bytes[] = new byte[getByteCount()];
		int byteIndex = bytes.length - 1;
		long segmentValue = low ? getDivisionValue() : getUpperDivisionValue();
		while(true) {
			bytes[byteIndex] |= segmentValue;
			segmentValue >>= 8;
			if(bitCount <= 8) {
				return bytes;
			}
			bitCount -= 8;
			byteIndex--;
		}
	}
	
	/**
	 * @return whether this segment represents multiple values
	 */
	@Override
	public boolean isMultiple() {
		return getDivisionValue() != getUpperDivisionValue();
	}
	@Override
	public int getMinPrefixLengthForBlock() {
		int result = getBitCount();
		if(!isMultiple()) {
			return result;
		} else if(isFullRange()) {
			return 0;
		}
		int lowerZeros = Long.numberOfTrailingZeros(getDivisionValue());
		if(lowerZeros != 0) {
			int upperOnes = Long.numberOfTrailingZeros(~getUpperDivisionValue());
			if(upperOnes != 0) {
				int prefixedBitCount = Math.min(lowerZeros, upperOnes);
				result -= prefixedBitCount;
			}
		}
		return result;
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		int divPrefix = getMinPrefixLengthForBlock();
		long lowerValue = getDivisionValue();
		long upperValue = getUpperDivisionValue();
		int bitCount = getBitCount();
		if(divPrefix == bitCount) {
			if(lowerValue == upperValue) {
				return AddressDivisionGrouping.cacheBits(divPrefix);
			}
		} else {
			int shift = bitCount - divPrefix;
			if(lowerValue >>> shift == upperValue >>> shift) {
				return AddressDivisionGrouping.cacheBits(divPrefix);
			}
		}
		return null;
	}
	
	@Override
	protected String getDefaultRangeSeparatorString() {
		return Address.RANGE_SEPARATOR_STR;
	}
	
	public long getMaxValue() {
		return ~(~0L << getBitCount());
	}
	
	@Override
	public boolean isZero() {
		return !isMultiple() && includesZero();
	}
	
	@Override
	public boolean includesZero() {
		return getDivisionValue() == 0L;
	}
	
	@Override
	public boolean isMax() {
		return !isMultiple() && includesMax();
	}
	
	@Override
	public boolean includesMax() {
		return getUpperDivisionValue() == getMaxValue();
	}
	
	public abstract long getDivisionValue();
	
	public abstract long getUpperDivisionValue();
	
	@Override
	public int hashCode() {
		int res = hashCode;
		if(res == 0) {
			hashCode = res = createHashCode(getDivisionValue(), getUpperDivisionValue());
		}
		return res;
	}
	
	@Override
	public BigInteger getValue() {
		return BigInteger.valueOf(getDivisionValue());
	}
	
	@Override
	public BigInteger getUpperValue() {
		return BigInteger.valueOf(getUpperDivisionValue());
	}
	
	static boolean testRange(long lowerValue, long upperValue, long finalUpperValue, long networkMask, long hostMask) {
		return lowerValue == (lowerValue & networkMask)
				&& finalUpperValue == (upperValue | hostMask);
	}
	
	/**
	 * Returns whether the division range includes the block of values for its prefix length
	 */
	protected boolean isPrefixBlock(long divisionValue, long upperValue, int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return divisionValue == 0 && upperValue == getMaxValue();
		}
		int bitCount = getBitCount();
		long ones = ~0L;
		long divisionBitMask = ~(ones << bitCount);
		long divisionPrefixMask = ones << (bitCount - divisionPrefixLen);
		long divisionNonPrefixMask = ~divisionPrefixMask;
		return testRange(divisionValue,
				upperValue,
				upperValue,
				divisionPrefixMask & divisionBitMask,
				divisionNonPrefixMask);
	}
	/**
	 * 
	 * @param divisionValue
	 * @param divisionPrefixLen
	 * @return whether the given range of segmentValue to upperValue is equivalent to the range of segmentValue with the prefix of divisionPrefixLen 
	 */
	protected boolean isSinglePrefixBlock(long divisionValue, long upperValue, int divisionPrefixLen) {
		long ones = ~0L;
		int bitCount = getBitCount();
		long divisionBitMask = ~(ones << bitCount);
		long divisionPrefixMask = ones << (bitCount - divisionPrefixLen);
		long divisionNonPrefixMask = ~divisionPrefixMask;
		return testRange(divisionValue,
				divisionValue,
				upperValue,
				divisionPrefixMask & divisionBitMask,
				divisionNonPrefixMask);
	}
	
	/**
	 * Returns true if the possible values of this division fall below the given value.
	 */
	@Override
	public boolean isBoundedBy(int value) {
		return getUpperDivisionValue() < value;
	}
	
	public boolean matches(long value) {
		return !isMultiple() && value == getDivisionValue();
	}
	
	public boolean matchesWithMask(long value, long mask) {
		if(isMultiple()) {
			//we want to ensure that any of the bits that can change from value to upperValue is masked out (zeroed) by the mask.
			//In other words, when masked we need all values represented by this segment to become just a single value
			long diffBits = getDivisionValue() ^ getUpperDivisionValue();
			int leadingZeros = Long.numberOfLeadingZeros(diffBits);
			//the bits that can change are all bits following the first leadingZero bits
			//all the bits that follow must be zeroed out by the mask
			long fullMask = ~0L >>> leadingZeros;
			if((fullMask & mask) != 0L) {
				return false;
			} //else we know that the mask zeros out all the bits that can change from value to upperValue, so now we just compare with either one
		}
		return value == (getDivisionValue() & mask);
	}
	
	/**
	 * returns whether masking with the given mask results in a valid contiguous range for this segment,
	 * and if it does, if it matches the range obtained when masking the given values with the same mask.
	 * 
	 * @param lowerValue
	 * @param upperValue
	 * @param mask
	 * @return
	 */
	public boolean matchesWithMask(long lowerValue, long upperValue, long mask) {
		if(lowerValue == upperValue) {
			return matchesWithMask(lowerValue, mask);
		}
		if(!isMultiple()) {
			//we know lowerValue and upperValue are not the same, so impossible to match those two values with a single value
			return false;
		}
		long thisValue = getDivisionValue();
		long thisUpperValue = getUpperDivisionValue();
		Masker masker = maskRange(thisValue, thisUpperValue, mask, getMaxValue());
		if(!masker.isSequential()) {
			return false;
		}
		return lowerValue == masker.getMaskedLower(thisValue, mask) && upperValue == masker.getMaskedUpper(thisUpperValue, mask);
	}
	
	@Override
	protected boolean isSameValues(AddressDivisionBase other) {
		if(other instanceof AddressDivision) {
			AddressDivision otherDivision = (AddressDivision) other;
			return getDivisionValue() == otherDivision.getDivisionValue() &&
					getUpperDivisionValue() == otherDivision.getUpperDivisionValue();
		}
		return false;
	}
	
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof AddressDivision) {
			// we call isSameValues on the other object to defer to subclasses overriding that method in object o
			// in particular, if the other is IPv4/6/MAC/AddressSection, then we call the overridden isSameGrouping
			// in those classes which check for IPv4/6/MAC type/version.
			// Also, those other classes override equals to ensure flip doesn't go the other way
			AddressDivision other = (AddressDivision) o;
			return getBitCount() == other.getBitCount() && other.isSameValues(this);
		}
		return false;
	}
	
	
	/**
	 * Represents the result of masking a sequential range of values
	 * 
	 * @author seancfoley
	 *
	 */
	public static class MaskResult {
		private final long value, upperValue, maskValue;
		private final Masker masker;
		public MaskResult(long value, long upperValue, long maskValue, Masker masker) {
			this.value = value;
			this.upperValue = upperValue;
			this.maskValue = maskValue;
			this.masker = masker;
		}
		
		/**
		 * The lowest masked value, which is not necessarily the lowest value masked
		 * @return
		 */
		public long getMaskedLower() {
			return masker.getMaskedLower(value, maskValue);
		}
		
		/**
		 * The highest masked value, which is not necessarily the highest value masked
		 * @return
		 */
		public long getMaskedUpper() {
			return masker.getMaskedUpper(upperValue, maskValue);
		}
		
		/**
		 * Whether masking all values in the range results in a sequential set of values
		 * @return
		 */
		public boolean isSequential() {
			return masker.isSequential();
		}
	}
	
	/**
	 * Check that the range resulting from the mask is contiguous, otherwise it cannot be represented by a division or segment instance.
	 * 
	 * For instance, for the range 0 to 3 (bits are 00 to 11), if we mask all 4 numbers from 0 to 3 with 2 (ie bits are 10), 
	 * then we are left with 1 and 3.  2 is not included.  So we cannot represent 1 and 3 as a contiguous range.
	 * 
	 * The underlying rule is that mask bits that are 0 must be above the resulting range in each segment.
	 * 
	 * Any bit in the mask that is 0 must not fall below any bit in the masked segment range that is different between low and high.
	 * 
	 * Any network mask must eliminate the entire division range or keep the entire range.  Any host mask is fine.
	 * 
	 * @param maskValue
	 * @return
	 */
	public boolean isMaskCompatibleWithRange(int maskValue) {
		long value = getDivisionValue();
		long upperValue = getUpperDivisionValue();
		long maxValue = getMaxValue();
		return maskRange(value, upperValue, maskValue, maxValue).isSequential();
	}
	protected static Masker maskRange(long value, long upperValue, long maskValue, long maxValue) {
		return ParsedIPAddress.maskRange(value, upperValue, maskValue, maxValue);
	}
	/**
	 * 
	 * Returns an object that provides the masked values for a range,
	 * which for subnets is an aggregation of all masked individual addresses in the subnet.
	 * See {@link #bitwiseOrRange(long, long, long)}
	 * 
	 * @param value
	 * @param upperValue
	 * @param maskValue
	 * @return an instance that provides the result of masking the values.  With individual addresses, the result is simply value &amp; maskValue.
	 *   But with subnets, returns an object providing lower and upper results along with whether the resulting set of values is sequential.
	 */
	public static MaskResult maskRange(long value, long upperValue, long maskValue) {
		Masker masker = ParsedIPAddress.maskRange(value, upperValue, maskValue);
		return new MaskResult(value, upperValue, maskValue, masker);
	}
	
	
	/**
	 * Represents the result of a bitwise or of a sequential range of values
	 * 
	 * @author seancfoley
	 *
	 */
	public static class BitwiseOrResult {
		private final long value, upperValue, maskValue;
		private final BitwiseOrer masker;
		public BitwiseOrResult(long value, long upperValue, long maskValue, BitwiseOrer masker) {
			this.value = value;
			this.upperValue = upperValue;
			this.maskValue = maskValue;
			this.masker = masker;
		}
		
		/**
		 * The lowest ored value, which is not necessarily the lowest value ored
		 * @return
		 */
		public long getOredLower() {
			return masker.getOredLower(value, maskValue);
		}
		
		/**
		 * The highest ored value, which is not necessarily the highest value ored
		 * @return
		 */
		public long getOredUpper() {
			return masker.getOredUpper(upperValue, maskValue);
		}
		
		/**
		 * Whether masking all values in the range results in a sequential set of values
		 * @return
		 */
		public boolean isSequential() {
			return masker.isSequential();
		}
	}
	
	
	/**
	 * Similar to masking, checks that the range resulting from the bitwise "or" operation is sequential.
	 * 
	 * @param maskValue
	 * @return
	 */
	public boolean isBitwiseOrCompatibleWithRange(int maskValue) {
		if(!isMultiple()) {
			return true;
		}
		long value = getDivisionValue();
		long upperValue = getUpperDivisionValue();
		long maxValue = getMaxValue();
		return bitwiseOrRange(value, upperValue, maskValue, maxValue) != null;
	}
	
	protected static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue, long maxValue) {
		return ParsedIPAddress.bitwiseOrRange(value, upperValue, maskValue, maxValue);
	}
	
	/**
	 * Applies bitwise or to a range of values.   Returns an object that provides the ored values for a range,
	 * which for subnets is an aggregation of all ored individual addresses in the subnet.
	 * See {@link #maskRange(long, long, long)}
	 * 
	 * @param maskValue
	 * @return
	 */
	public static BitwiseOrResult bitwiseOrRange(long value, long upperValue, long maskValue) {
		BitwiseOrer masker = ParsedIPAddress.bitwiseOrRange(value, upperValue, maskValue);
		return new BitwiseOrResult(value, upperValue, maskValue, masker);
	}
	
	public boolean hasUppercaseVariations(int radix, boolean lowerOnly) {
		if(radix < MIN_RADIX) {
			throw new IllegalArgumentException();
		} else if(radix <= 10) {
			return false;
		}
		boolean isPowerOfTwo;
		int shift = 0;
		long mask = 0;
		switch(radix) {
			case 0x10://fast path for base 16
				isPowerOfTwo = true;
				shift = 4; //log2(base)
				mask = 0xf; //2^shift - 1
				break;
			default:
				isPowerOfTwo = (radix & (radix - 1)) == 0;
				if(isPowerOfTwo) {
					shift = Integer.numberOfTrailingZeros(radix);
					mask = ~(~0L << shift); //shift must be 6 digits at most for this shift to work per the java spec (so it must be less than 2^6 = 64)
				}
		}
		boolean handledUpper = false;
		long value = getDivisionValue();
		do {
			while(value > 0) {
				long checkVal = isPowerOfTwo ? (mask & value) : (value % radix);
				if(checkVal >= 0xa) {
					return true;
				}
				if(isPowerOfTwo) {
					value >>>= shift;
				} else {
					value /= radix;
				}
			}
			if(handledUpper || lowerOnly) {
				break;
			}
			value = getUpperDivisionValue();
			handledUpper = true;
		} while(true);
		return false;
	}
	@Override
	public int getDigitCount(int radix) {
		if(!isMultiple() && radix == getDefaultTextualRadix()) {//optimization - just get the string, which is cached, which speeds up further calls to this or getString()
			return getWildcardString().length();
		}
		return getDigitCount(getUpperDivisionValue(), radix);
	}
	@Override
	public int getMaxDigitCount(int radix) {
		int defaultRadix = getDefaultTextualRadix();
		if(radix == defaultRadix) {
			return getMaxDigitCount();
		}
		return getMaxDigitCount(radix, getBitCount(), getMaxValue());
	}
	
	@Override
	protected int adjustLowerLeadingZeroCount(int leadingZeroCount, int radix) {
		return adjustLeadingZeroCount(leadingZeroCount, getDivisionValue(), radix);
	}
	
	@Override
	protected int adjustUpperLeadingZeroCount(int leadingZeroCount, int radix) {
		return adjustLeadingZeroCount(leadingZeroCount, getUpperDivisionValue(), radix);
	}
	
	private int adjustLeadingZeroCount(int leadingZeroCount, long value, int radix) {
		if(leadingZeroCount < 0) {
			int width = getDigitCount(value, radix);
			return Math.max(0, getMaxDigitCount(radix) - width);
		}
		return leadingZeroCount;
	}
	@Override
	protected String getWildcardString() {
		return super.getWildcardString();
	}
	
	@Override
	protected int getLowerStringLength(int radix) {
		return toUnsignedStringLength(getDivisionValue(), radix);
	}
	
	@Override
	protected int getUpperStringLength(int radix) {
		return toUnsignedStringLength(getUpperDivisionValue(), radix);
	}
	@Override
	protected void getLowerString(int radix, boolean uppercase, StringBuilder appendable) {
		toUnsignedStringCased(getDivisionValue(), radix, 0, uppercase, appendable);
	}
	
	@Override
	protected void getUpperString(int radix, boolean uppercase, StringBuilder appendable) {
		toUnsignedStringCased(getUpperDivisionValue(), radix, 0, uppercase, appendable);
	}
	
	@Override
	protected void getUpperStringMasked(int radix, boolean uppercase, StringBuilder appendable) {
		getUpperString(radix, uppercase, appendable);
	}
	@Override
	protected void getLowerString(int radix, int rangeDigits, boolean uppercase, StringBuilder appendable) {
		toUnsignedStringCased(getDivisionValue(), radix, rangeDigits, uppercase, appendable);
	}
	
	@Override
	protected void getSplitLowerString(int radix, int choppedDigits, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix, StringBuilder appendable) {
		toSplitUnsignedString(getDivisionValue(), radix, choppedDigits, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
	}
	
	@Override
	protected void getSplitRangeString(String rangeSeparator, String wildcard, int radix, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix, StringBuilder appendable) {
		toUnsignedSplitRangeString(
			getDivisionValue(),
			getUpperDivisionValue(),
			rangeSeparator,
			wildcard,
			radix,
			uppercase, 
			splitDigitSeparator,
			reverseSplitDigits,
			stringPrefix,
			appendable);
	}
	
	@Override
	protected int getSplitRangeStringLength(String rangeSeparator, String wildcard, int leadingZeroCount, int radix, boolean uppercase, 
			char splitDigitSeparator, boolean reverseSplitDigits, String stringPrefix) {
		return toUnsignedSplitRangeStringLength(
			getDivisionValue(),
			getUpperDivisionValue(),
			rangeSeparator,
			wildcard,
			leadingZeroCount,
			radix,
			uppercase, 
			splitDigitSeparator,
			reverseSplitDigits,
			stringPrefix);
	}
	@Override
	protected String getDefaultLowerString() {
		return toDefaultString(getDivisionValue(), getDefaultTextualRadix());
	}
	
	@Override
	protected String getDefaultRangeString() {
		return getDefaultRangeString(getDivisionValue(), getUpperDivisionValue(), getDefaultTextualRadix());
	}
	protected String getDefaultRangeString(long val1, long val2, int radix) {
		int len1, len2, value1, value2, quotient, remainder; //we iterate on //value == quotient * radix + remainder
		if(radix == 10) {
			if(val2 < 10) {
				len2 = 1;
			} else if(val2 < 100) {
				len2 = 2;
			} else if(val2 < 1000) {
				len2 = 3;
			} else {
				return buildDefaultRangeString(radix);
			}
			value2 = (int) val2;
			if(val1 < 10) {
				len1 = 1;
			} else if(val1 < 100) {
				len1 = 2;
			} else if(val1 < 1000) {
				len1 = 3;
			} else {
				return buildDefaultRangeString(radix);
			}
			value1 = (int) val1;
			
			len2 += len1 + 1;
			char chars[] = new char[len2];
			chars[len1] = IPAddress.RANGE_SEPARATOR;
			char dig[] = DIGITS;
			do {
				//value == quotient * 10 + remainder
				quotient = (value1 * 0xcccd) >>> 19; //floor of n/10 is floor of ((0xcccd * n / (2 ^ 16)) / (2 ^ 3))
				remainder = value1 - ((quotient << 3) + (quotient << 1)); //multiplication by 2 added to multiplication by 2 ^ 3 is multiplication by 2 + 8 = 10
				chars[--len1] = dig[remainder];
				value1 = quotient;
	        } while(value1 != 0);
			do {
				quotient = (value2 * 0xcccd) >>> 19;
				remainder = value2 - ((quotient << 3) + (quotient << 1));
				chars[--len2] = dig[remainder];
				value2 = quotient;
	        } while(value2 != 0);
			return new String(chars);
		} else if(radix == 16) {
			if(val2 < 0x10) {
				len2 = 1;
			} else if(val2 < 0x100) {
				len2 = 2;
			} else if(val2 < 0x1000) {
				len2 = 3;
			} else if(val2 < 0x10000) {
				len2 = 4;
			} else {
				return buildDefaultRangeString(radix);
			}
			value2 = (int) val2;
			if(val1 < 0x10) {
				len1 = 1;
			} else if(val1 < 0x100) {
				len1 = 2;
			} else if(val1 < 0x1000) {
				len1 = 3;
			} else if(val1 < 0x10000) {
				len1 = 4;
			} else {
				return buildDefaultRangeString(radix);
			}
			value1 = (int) val1;
			len2 += len1 + 1;
			char chars[] = new char[len2];
			chars[len1] = IPAddress.RANGE_SEPARATOR;
			char dig[] = DIGITS;
			do {//value1 == quotient * 16 + remainder
				quotient = value1 >>> 4;
				remainder = value1 - (quotient << 4);
				chars[--len1] = dig[remainder];
				value1 = quotient;
			} while(value1 != 0);
			do {
				quotient = value2 >>> 4;
				remainder = value2 - (quotient << 4);
				chars[--len2] = dig[remainder];
				value2 = quotient;
			} while(value2 != 0);
			return new String(chars);
		}
		return buildDefaultRangeString(radix);
	}
	
	private String buildDefaultRangeString(int radix) {
		StringBuilder builder = new StringBuilder(20);
		getRangeString(IPAddress.RANGE_SEPARATOR_STR, 0, 0, "", radix, false, false, builder);
		return builder.toString();
	}
	
	protected static String toDefaultString(long val, int radix) {
		if(radix < MIN_RADIX || radix > MAX_RADIX || val < 0) {
			throw new IllegalArgumentException();
		}
		//0 and 1 are common segment values, and additionally they are the same regardless of radix (even binary)
		//so we have a fast path for them
		if(val == 0L) {
			return "0";
		} else if(val == 1L) {
			return "1";
		}
		int len, quotient, remainder, value; //we iterate on: value == quotient * radix + remainder
		if(radix == 10) {
			if(val < 10) {
				return String.valueOf(DIGITS, (int) val, 1);
			} else if(val < 100) {
				len = 2;
				value = (int) val;
			} else if(val < 1000) {
				len = 3;
				value = (int) val;
			} else {
				return Long.toString(val, radix);
			}
			char chars[] = new char[len];
			char dig[] = DIGITS;
			do {
				//value == quotient * 10 + remainder
				quotient = (value * 0xcccd) >>> 19; //floor of n/10 is floor of ((0xcccd * n / (2 ^ 16)) / (2 ^ 3))
				remainder = value - ((quotient << 3) + (quotient << 1)); //multiplication by 2 added to multiplication by 2 ^ 3 is multiplication by 2 + 8 = 10
				chars[--len] = dig[remainder];
				value = quotient;
	        } while(value != 0);
			return new String(chars);
		} else if(radix == 16) {
			if(val < 0x10) {
				return String.valueOf(DIGITS, (int) val, 1);
			} else if(val < 0x100) {
				len = 2;
				value = (int) val;
			} else if(val < 0x1000) {
				len = 3;
				value = (int) val;
			} else if(val < 0x10000) {
				if(val == 0xffff) {
					return "ffff";
				}
				value = (int) val;
				len = 4;
			} else {
				return Long.toString(val, radix);
			}
			char chars[] = new char[len];
			char dig[] = DIGITS;
			do {//value2 == quotient * 16 + remainder
				quotient = value >>> 4;
				remainder = value - (quotient << 4);
				chars[--len] = dig[remainder];
				value = quotient;
			} while(value != 0);
			return new String(chars);
		}
		return Long.toString(val, radix);
	}
	private static int toUnsignedSplitRangeStringLength(
			long lower,
			long upper,
			String rangeSeparator,
			String wildcard,
			int leadingZerosCount,
			int radix,
			boolean uppercase, 
			char splitDigitSeparator,
			boolean reverseSplitDigits,
			String stringPrefix) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		int digitsLength = -1;//we will count one too many split digit separators in here
		int stringPrefixLength = stringPrefix.length();
		do {
			int upperDigit = (int) (upper % radix);
			int lowerDigit = (int) (lower % radix);
			boolean isFull = (lowerDigit == 0) && (upperDigit == radix - 1);
			if(isFull) {
				digitsLength += wildcard.length() + 1;
			} else {
				//if not full range, they must not be the same either, otherwise they would be illegal for split range.
				//this is because we know whenever entering the loop that upper != lower, and we know this also means the least significant digits must differ.
				digitsLength += (stringPrefixLength << 1) + 4 /* 1 for each digit, 1 for range separator, 1 for split digit separator */;
			}
			upper /= radix;
			lower /= radix;
		} while(upper != lower);
		int remaining = (upper == 0) ? 0 : toUnsignedStringLength(upper, radix);
		remaining += leadingZerosCount;
		if(remaining > 0) {
			digitsLength += remaining * (stringPrefixLength + 2 /* one for each splitDigitSeparator, 1 for each digit */);
		}
		return digitsLength;
	}
	protected static BigInteger getRadixPower(BigInteger radix, int power) {
		return AddressDivisionBase.getRadixPower(radix, power);
	}
	private static void toSplitUnsignedString(
			long value,
			int radix,
			int choppedDigits,
			boolean uppercase, 
			char splitDigitSeparator,
			boolean reverseSplitDigits,
			String stringPrefix,
			StringBuilder appendable) {
		int front = appendable.length();
		appendDigits(value, radix, choppedDigits, uppercase, splitDigitSeparator, stringPrefix, appendable);
		if(!reverseSplitDigits) {
			int back = appendable.length() - 1;
			int stringPrefixLen = stringPrefix.length();
			front += stringPrefixLen;
			while(front < back) {
				char frontChar = appendable.charAt(front);
				appendable.setCharAt(front, appendable.charAt(back));
				appendable.setCharAt(back, frontChar);
				front += 2;
				back -= 2;
				front += stringPrefixLen;
				back -= stringPrefixLen;
			}
		}
	}
	
	private static void toUnsignedSplitRangeString(
			long lower,
			long upper,
			String rangeSeparator,
			String wildcard,
			int radix,
			boolean uppercase, 
			char splitDigitSeparator,
			boolean reverseSplitDigits,
			String stringPrefix,
			StringBuilder appendable) {
		//A split can be invalid.  Consider xxx.456-789.
		//The number 691, which is in the range 456-789, is not in the range 4-7.5-8.6-9
		//In such cases we throw IncompatibleAddressException
		//To avoid such cases, we must have lower digits covering the full range, for example 400-799 in which lower digits are both 0-9 ranges.
		//If we have 401-799 then 500 will not be included when splitting.
		//If we have 400-798 then 599 will not be included when splitting.
		//If we have 410-799 then 500 will not be included when splitting.
		//If we have 400-789 then 599 will not be included when splitting.
		int front = appendable.length();
		appendDigits(lower, upper, rangeSeparator, wildcard, radix, uppercase, splitDigitSeparator, reverseSplitDigits, stringPrefix, appendable);
		if(!reverseSplitDigits) {
			int back = appendable.length() - 1;
			while(front < back) {
				char frontChar = appendable.charAt(front);
				appendable.setCharAt(front++, appendable.charAt(back));
				appendable.setCharAt(back--, frontChar);
			}
		}
	}
	private static void appendDigits(
			long value,
			int radix,
			int choppedDigits,
			boolean uppercase, 
			char splitDigitSeparator,
			String stringPrefix,
			StringBuilder appendable) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		boolean useInts = value <= Integer.MAX_VALUE;
		int value2 = useInts ? (int) value : radix;
		char dig[] = uppercase ? UPPERCASE_DIGITS : DIGITS;
		int index;
		int prefLen = stringPrefix.length();
		while(value2 >= radix) {
			if(useInts) {
				int val = value2;
				value2 /= radix;
				if(choppedDigits > 0) {
					choppedDigits--;
					continue;
				}
				index = val % radix;
			} else {
				long val = value;
				value /= radix;
				if(value <= Integer.MAX_VALUE) {
					useInts = true;
					value2 = (int) value;
				}
				if(choppedDigits > 0) {
					choppedDigits--;
					continue;
				}
				index = (int) (val % radix);
			}
			if(prefLen > 0) {
				appendable.append(stringPrefix);
			}
			appendable.append(dig[index]);
			appendable.append(splitDigitSeparator);
		}
		if(choppedDigits == 0) {
			if(prefLen > 0) {
				appendable.append(stringPrefix);
			}
			appendable.append(dig[value2]);
		}
	}
	
	private static void appendDigits(
			long lower,
			long upper,
			String rangeSeparator,
			String wildcard,
			int radix,
			boolean uppercase, 
			char splitDigitSeparator,
			boolean reverseSplitDigits,
			String stringPrefix, 
			StringBuilder appendable) {
		if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		char dig[] = uppercase ? UPPERCASE_DIGITS : DIGITS;
		boolean previousWasFullRange = true;
		boolean useInts = upper <= Integer.MAX_VALUE;
		int upperInt, lowerInt;
		if(useInts) {
			upperInt = (int) upper;
			lowerInt = (int) lower;
		} else {
			upperInt = lowerInt = radix;
		}
		int prefLen = stringPrefix.length();
		while(true) {
			int upperDigit, lowerDigit;
			if(useInts) {
				int ud = upperInt;
				upperDigit = upperInt % radix;
				upperInt /= radix;
				if(ud == lowerInt) {
					lowerInt = upperInt;
					lowerDigit = upperDigit;
				} else {
					lowerDigit = lowerInt % radix;
					lowerInt /= radix;
				}
			} else {
				long ud = upper;
				upperDigit = (int) (upper % radix);
				upper /= radix;
				if(ud == lower) {
					lower = upper;
					lowerDigit = upperDigit;
				} else {
					lowerDigit = (int) (lower % radix);
					lower /= radix;
				}
				if(upper <= Integer.MAX_VALUE) {
					useInts = true;
					upperInt = (int) upper;
					lowerInt = (int) lower;
				}
			}
			if(lowerDigit == upperDigit) {
				previousWasFullRange = false;
				if(reverseSplitDigits) {
					if(prefLen > 0) {
						appendable.append(stringPrefix);
					}
					appendable.append(dig[lowerDigit]);
				} else {
					//in this case, whatever we do here will be completely reversed following this method call
					appendable.append(dig[lowerDigit]);
					for(int k = prefLen - 1; k >= 0; k--) {
						appendable.append(stringPrefix.charAt(k));
					}
				}
			} else {
				if(!previousWasFullRange) {
					throw new IncompatibleAddressException(lower, upper, "ipaddress.error.splitMismatch");
				}
				previousWasFullRange = (lowerDigit == 0) && (upperDigit == radix - 1);
				if(previousWasFullRange && wildcard != null) {
					if(reverseSplitDigits) {
						appendable.append(wildcard);
					} else {
						//in this case, whatever we do here will be completely reversed following this method call
						for(int k = wildcard.length() - 1; k >= 0; k--) {
							appendable.append(wildcard.charAt(k));
						}
					}
				} else {
					if(reverseSplitDigits) {
						if(prefLen > 0) {
							appendable.append(stringPrefix);
						}
						appendable.append(dig[lowerDigit]);
						appendable.append(rangeSeparator);
						appendable.append(dig[upperDigit]);
					} else {
						//in this case, whatever we do here will be completely reversed following this method call
						appendable.append(dig[upperDigit]);
						appendable.append(rangeSeparator);
						appendable.append(dig[lowerDigit]);
						for(int k = prefLen - 1; k >= 0; k--) {
							appendable.append(stringPrefix.charAt(k));
						}
					}
				}
			}
			if(upperInt == 0) {
				break;
			}
			appendable.append(splitDigitSeparator);
		}
	}
	@Override
	protected int getRangeDigitCount(int radix) {
		if(!isMultiple()) {
			return 0;
		} else if(radix == getDefaultTextualRadix()) {
			return getRangeDigitCountImpl();
		} else if(radix < MIN_RADIX || radix > MAX_RADIX) {
			throw new IllegalArgumentException();
		}
		return calculateRangeDigitCount(radix, getDivisionValue(), getUpperDivisionValue(), getMaxValue());
	}
	
	protected int getRangeDigitCountImpl() {
		return calculateRangeDigitCount(getDefaultTextualRadix(), getDivisionValue(), getUpperDivisionValue(), getMaxValue());
	}
	private static int calculateRangeDigitCount(int radix, long value, long upperValue, long maxValue) {
		int factor = radix;
		int numDigits = 1;
		while(true) {
			long lowerRemainder = value % factor;
			if(lowerRemainder == 0) {
				//Consider in ipv4 the segment 24_  
				//what does this mean?  It means 240 to 249 (not 240 to 245)
				//Consider 25_.  It means 250-255.
				//so the last digit ranges between 0-5 or 0-9 depending on whether the front matches the max possible front of 25.
				//If the front matches, the back ranges from 0 to the highest value of 255.
				//if the front does not match, the back must range across all values for the radix (0-9)
				long max = (maxValue / factor == upperValue / factor) ? maxValue % factor : factor - 1;
				long upperRemainder = upperValue % factor;
				if(upperRemainder == max) {
					//whatever range there is must be accounted entirely by range digits, otherwise the range digits is 0
					//so here we check if that is the case
					if(upperValue - upperRemainder == value) {
						return numDigits;
					} else {
						numDigits++;
						factor *= radix;
						continue;
					}
				}
			}
			return 0;
		}
	}
	
	protected static int reverseBits(byte b) {
		int x = b;
		x = ((x & 0xaa) >>> 1) | ((x & 0x55) << 1);
		x = ((x & 0xcc) >>> 2) | ((x & 0x33) << 2);
		x = (0xff & ((x >>> 4) | (x << 4)));
		return x;
	}
	
	protected static int reverseBits(short b) {
		int x = b;
		x = ((x & 0xaaaa) >>> 1) | ((x & 0x5555) << 1);
		x = ((x & 0xcccc) >>> 2) | ((x & 0x3333) << 2);
		x = ((x & 0xf0f0) >>> 4) | ((x & 0x0f0f) << 4);
		return 0xffff & ((x >>> 8) | (x << 8));
	}
	
	protected static int reverseBits(int i) {
		int x = i;
		x = ((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1);
		x = ((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2);
		x = ((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4);
		x = ((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8);
		return (x >>> 16) | (x << 16);
	}
	
	protected static <S extends AddressSegment> int getPrefixValueCount(S segment, int segmentPrefixLength) {
		int shiftAdjustment = segment.getBitCount() - segmentPrefixLength;
		return (segment.getUpperSegmentValue() >>> shiftAdjustment) - (segment.getSegmentValue() >>> shiftAdjustment) + 1;
	}
	protected static <S extends AddressSegment> Iterator<S> identityIterator(S original) {
		return new Iterator<S>() {
			boolean done;
			
			@Override
			public boolean hasNext() {
				return !done;
			}
	
		   @Override
			public S next() {
		    	if(!hasNext()) {
		    		throw new NoSuchElementException();
		    	}
		    	done = true;
		    	return original;
	    	}
	
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	protected static <S extends AddressSegment> Iterator<S> iterator(
			S original,
			AddressSegmentCreator<S> creator,
			Integer segmentPrefixLength,
			boolean isPrefixIterator,
			boolean isBlockIterator) {
		return iterator(
				original,
				original.getSegmentValue(),
				original.getUpperSegmentValue(),
				original.getBitCount(),
				creator,
				segmentPrefixLength,
				isPrefixIterator,
				isBlockIterator);
	}
	protected static <S extends AddressSegment> Iterator<S> iterator(
			S original,
			int originalLower,
			int originalUpper,
			int bitCount,
			AddressSegmentCreator<S> creator,
			Integer segmentPrefixLength,
			boolean isPrefixIterator,
			boolean isBlockIterator) {
		int shiftAdjustment, shiftMask, upperShiftMask;
		if(isPrefixIterator) {
			shiftAdjustment = bitCount - segmentPrefixLength;
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftAdjustment = shiftMask = upperShiftMask = 0;
		}
		if(original != null && !original.isMultiple()) {
			return new Iterator<S>() {
				boolean done;
				
				@Override
				public boolean hasNext() {
					return !done;
				}
		
			   @Override
				public S next() {
			    	if(!hasNext()) {
			    		throw new NoSuchElementException();
			    	}
			    	done = true;
			    	if(isBlockIterator) {
			    		return creator.createSegment(
			    				originalLower & shiftMask,
			    				originalUpper | upperShiftMask,
			    				segmentPrefixLength);
			    	}
			    	return original;
			    }
		
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		if(isPrefixIterator) {
			if(isBlockIterator) {
				return new Iterator<S>() {
					private boolean notDone = true;
					private int current = originalLower, last = originalUpper; {
						current >>>= shiftAdjustment;
						last >>>= shiftAdjustment;
					}
					
					@Override
					public boolean hasNext() {
						return notDone;
					}
				
				    @Override
					public S next() {
				    	if(!notDone) {
				    		throw new NoSuchElementException();
				    	}
				    	int cur = current;
			    		int blockLow = cur << shiftAdjustment;
			    		S result = creator.createSegment(blockLow, blockLow | upperShiftMask, segmentPrefixLength);
		    			if(++cur > last) {
		    				notDone = false;
		    			} else {
		    				current = cur;
		    			}
				    	return result;
				    }
				
				    @Override
					public void remove() {
				    	throw new UnsupportedOperationException();
				    }
				};
			}
			return new Iterator<S>() {
				private boolean notDone = true, notFirst;
				private int current = originalLower, last = originalUpper; {
					current >>>= shiftAdjustment;
					last >>>= shiftAdjustment;
				}
				
				@Override
				public boolean hasNext() {
					return notDone;
				}
			
			    @Override
				public S next() {
			    	if(!notDone) {
			    		throw new NoSuchElementException();
			    	}
			    	int cur = current;
		    		int blockLow = cur << shiftAdjustment;
		    		int blockHigh = blockLow | upperShiftMask;
		    		current = ++cur;
		    		int low, high;
		    		if(notFirst) {
		    			low = blockLow;
		    		} else {
		    			low = originalLower;
		    			notFirst = true;
		    		}
		    		boolean notDne = cur <= last;
		    		if(notDne) {
		    			high = blockHigh;
		    		} else {
		    			high = originalUpper;
		    			notDone = false;
		    		}
		    		return creator.createSegment(low, high, segmentPrefixLength);
			    }
			
			    @Override
				public void remove() {
			    	throw new UnsupportedOperationException();
			    }
			};
		}
		return new Iterator<S>() {
			private boolean notDone = true;
			private int current = originalLower, last = originalUpper;
			
			@Override
			public boolean hasNext() {
				return notDone;
			}
		
		    @Override
			public S next() {
		    	if(!notDone) {
		    		throw new NoSuchElementException();
		    	}
		    	S result = creator.createSegment(current, segmentPrefixLength);
		    	notDone = ++current <= last;
		    	return result;
		    }
		
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	
	protected static <S extends AddressSegment> S setPrefixedSegment(
			S original,
			Integer oldSegmentPrefixLength,
			Integer newSegmentPrefixLength,
			boolean zeroed,
			AddressSegmentCreator<S> creator) {
		if(Objects.equals(oldSegmentPrefixLength, newSegmentPrefixLength)) {
			return original;
		}
		int newLower, newUpper;
		if(zeroed) {
			int prefixMask;
			int bitCount = original.getBitCount();
			int allOnes = ~0;
			if(oldSegmentPrefixLength != null) {
				if(newSegmentPrefixLength == null) {
					prefixMask = allOnes << (bitCount - oldSegmentPrefixLength);
				} else if(oldSegmentPrefixLength > newSegmentPrefixLength) {
					prefixMask = allOnes << (bitCount - newSegmentPrefixLength);
					prefixMask |= ~(allOnes << (bitCount - oldSegmentPrefixLength));
				} else {
					prefixMask = allOnes << (bitCount - oldSegmentPrefixLength);
					prefixMask |= ~(allOnes << (bitCount - newSegmentPrefixLength));
				}
			} else {
				// we know newSegmentPrefixLength != null
				prefixMask = allOnes << (bitCount - newSegmentPrefixLength);
			}
			int value = original.getSegmentValue();
			int upperValue = original.getUpperSegmentValue();
			long maxValue = ~(~0L << original.getBitCount());
			Masker masker = maskRange(value, upperValue, prefixMask, maxValue);
			if(!masker.isSequential()) {
				throw new IncompatibleAddressException(original, "ipaddress.error.maskMismatch");
			}
			newLower = (int) masker.getMaskedLower(value, prefixMask);
			newUpper = (int) masker.getMaskedUpper(upperValue, prefixMask);
		} else {
			newLower = original.getSegmentValue();
			newUpper = original.getUpperSegmentValue();
		}
		return creator.createSegment(newLower, newUpper, newSegmentPrefixLength);
	}
	
	// Consider the case of reversing the bits of a range
	// Any range that can be successfully reversed must span all bits (otherwise after flipping you'd have a range in which the lower bit is constant, which is impossible in any contiguous range)
	// So that means at least one value has 0xxxx and another has 1xxxx (using 5 bits for our example). This means you must have the values 01111 and 10000 since the range is contiguous.
	// But reversing a range twice results in the original again, meaning the reversed must also be reversible, so the reversed also has 01111 and 10000.
	// So this means both the original and the reversed also have those two patterns flipped, which are 00001 and 11110.
	// So this means both ranges must span from at most 1 to at least 11110.
	// However, the two remaining values, 0 and 11111, are optional, as they are boundary value and remain themselves when reversed, and hence have no effect on whether the reversed range is contiguous.
	// So the only reversible ranges are 0-11111, 0-11110, 1-11110, and 1-11111.
	//-----------------------
	// Consider the case of reversing each of the bytes of a range.
	//
	// You can apply your argument to the top multiple byte.
	// which means it is 0 or 1 to 254 or 255.
	// Suppose there is another byte to follow
	// If you take the upper byte range, and you hold it constant, then reversing the next byte applies the same argument to that byte.  
	// And so the lower byte must span from at most 1 to at least 11111110.
	// This argument holds when holding the upper byte constant at any value.
	// So the lower byte must span from at most 1 to at least 111111110 for any value.
	// So you have x 00000001-x 111111110 and y 00000001-y 111111110 and so on.
	
	// But all the bytes form a range, so you must also have the values in-between.
	// So that means you have 1 00000001 to 1 111111110 to 10 111111110 to 11 111111110 all the way to x 11111110, where x is at least 11111110.
	// In all cases, the upper byte lower value is at most 1, and 1 < 10000000.
	// That means you always have 10000000 00000000.
	// So you have the reverse as well (as argued above, for any value we also have the reverse).
	// So you always have 00000001 00000000.
	//
	// In other words, if the upper byte has lower 0, then the full bytes lower must be at most 0 00000001
	// Otherwise, when the upper byte has lower 1, the the full bytes lower is at most 1 00000000.
	//
	// In other words, if any upper byte has lower value 1, then all lower values to follow are 0.
	// If all upper bytes have lower value 0, then the next byte is permitted to have lower value 1.
	// In summary, any upper byte having lower of 1 forces the remaining lower values to be 0.
	// WHen the upper bytes are all zero, and thus the lower is at most 0 0 0 0 1, 
	// then the only remaining lower value is 0 0 0 0 0.  This reverses to itself, so it is optional.
	//
	// The same argument applies to upper boundaries.
	//
	// You need to check each byte in order.  Single valued do not matter.  First time you hit multi-valued byte x,
	// It must have lower value 0 or 1.  It must have upper value max or max - 1.
	// The following byte must be multiple of course.  
	// If the lower value of x is 0, then the next byte can have lower value 0 or 1.
	// Otherwise, the next byte and all bytes to follow must have lower value 0.
	// Same applies to the upper boundary. 
	// So you keep track as you go whether lower value can be 1 (if not then 0), and whether upper value can be max - 1 (if not then max).
	
		
	//-----------------------
	// Consider the case of reversing the bytes of a range.
	// Any range that can be successfully reversed must span all bits
	// (otherwise after flipping you'd have a range in which a lower bit is constant, which is impossible in any contiguous range)
	// So that means at least one value has 0xxxxx and another has 1xxxxx (we use 6 bits for our example, and we assume each byte has 3 bits).
	// This means you must have the values 011111 and 100000 since the range is contiguous.
	// But reversing a range twice results in the original again, meaning the reversed must also be reversible, so the reversed also has 011111 and 100000.
	// So this means both the original and the reversed also have those two bytes in each flipped, which are 111011 and 000100.
	// So the range must have 000100, 011111, 100000, 111011, so it must be at least 000100 to 111011.
	// So what if the range does not have 000001?  then the reversed range cannot have 001000, the byte-reversed address.
	// But we know it spans 000100 to 111011. So the original must have 000001.
	// What if it does not have 111110?  Then the reversed cannot have 110111, the byte-reversed address.
	// But we know it ranges from 000100 to 111011.  So the original must have 111110.
	// So it must range from 000001 to 111110.  The only remaining values in question are 000000 and 111111.
	// But once again, the two remaining values are optional, because they byte-reverse to themselves.
	// So for the byte-reverse case, we have the same potential ranges as in the bit-reverse case: 0-111111, 0-111110, 1-111110, and 1-111111
	
	protected static <S extends AddressSegment> boolean isReversibleRangePerByte(S seg) {
		int byteCount = seg.getByteCount();
		int bitCount = seg.getBitCount();
		int val = seg.getSegmentValue();
		int upperVal = seg.getUpperSegmentValue();
		for(int i = 1; i <= byteCount; i++) {
			int bitShift = i << 3;
			int shift = bitCount - bitShift;
			int byteVal = 0xff & (val >> shift);
			int upperByteVal = 0xff & (upperVal >> shift);
			if(byteVal != upperByteVal) {
				if(byteVal > 1 || upperByteVal < 254) {
					return false;
				}
				if(++i <= byteCount) {
					boolean lowerIsZero = byteVal == 1;
					boolean upperIsMax = upperByteVal == 254;
					do {
						bitShift = i<<3;
						shift = bitCount - bitShift;
						byteVal = 0xff & (val >> shift);
						upperByteVal = 0xff & (upperVal >> shift);
						if(lowerIsZero) {
							if(byteVal != 0) {
								return false;
							}
						} else {
							if(byteVal > 1) {
								return false;
							}
							lowerIsZero = byteVal == 1;
						}
						if(upperIsMax) {
							if(upperByteVal != 255) {
								return false;
							}
						} else {
							if(upperByteVal < 254) {
								return false;
							}
							upperIsMax = upperByteVal == 254;
						}
						i++;
					} while(i <= byteCount);
				}
				return true;
			}
		}
		return true;
	}
	
	protected static <S extends AddressSegment> boolean isReversibleRange(S segment) {
		return segment.getSegmentValue() <= 1 && segment.getUpperSegmentValue() >= segment.getMaxSegmentValue() - 1;
	}
}
/*
 * Copyright 2016-2018 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.string;
import inet.ipaddr.AddressNetwork;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.format.standard.AddressDivision;
/**
 * A generic part of an IP address for the purpose of producing a string for the address.
 * It is divided into a series of combinations of individual address divisions ({@link AddressDivision}).
 * The number of such series is the division count.
 * 
 * @author sfoley
 *
 */
public interface IPAddressStringDivisionSeries extends AddressStringDivisionSeries {
	
	IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	
	@Override
	IPAddressStringDivision getDivision(int index);
	
	/**
	 * Returns whether this address section represents a subnet block of addresses corresponding to the prefix of this series.
	 * 
	 * Returns false if it has no prefix length, if it is a single address with a prefix length (ie not a subnet), or if it is a range of addresses that does not include
	 * the entire subnet block for its prefix length.
	 * 
	 * If {@link AddressNetwork#getPrefixConfiguration} is set to consider all prefixes as subnets, this returns true for any section with a non-null prefix length.
	 * 
	 * @return
	 */
	boolean isPrefixBlock();
	
	/**
	 * Whether there exists a prefix length
	 */
	boolean isPrefixed();
	/**
	 * The number of bits in the upper-most portion of the segment bits representing a prefix, while the remaining bits can assume all possible values.
	 *
	 * For an IP address returns the network prefix, which is 16 for an address like 1.2.0.0/16
	 * If there is no prefix length, returns null.
	 * 
	 * @return the prefix length or null if there is none
	 */
	Integer getPrefixLength();
}
/*
 * Copyright 2016-2022 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InterfaceAddress;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.Function;
import inet.ipaddr.Address.AddressValueProvider;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.IPAddress.IPAddressValueProvider;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping.RangeList;
import inet.ipaddr.format.validate.HostIdentifierStringValidator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
/**
 * Represents a network of addresses of a single IP version providing a collection of standard addresses components for that version, such as masks and loopbacks.
 * 
 * @author sfoley
 *
 */
public abstract class IPAddressNetwork<
		T extends IPAddress, 
		R extends IPAddressSection,
		E extends IPAddressSection,
		S extends IPAddressSegment,
		J extends InetAddress> 
	extends AddressNetwork<S> {
	
	private static final long serialVersionUID = 4L;
	private final T subnetsMasksWithPrefix[];
	private final T subnetMasks[];
	private final T networkAddresses[];
	private final T hostMasks[];
	private final int networkSegmentMasks[];
	private final int hostSegmentMasks[];
	private transient T loopback;
	private transient String loopbackStrings[];
	public static abstract class IPAddressCreator<T extends IPAddress, R extends IPAddressSection, E extends IPAddressSection, S extends IPAddressSegment, J extends InetAddress> extends AddressCreator<T, R, E, S> {
		private static final long serialVersionUID = 4L;
		
		private IPAddressNetwork<T, R, E, S, J> owner;
		protected IPAddressCreator(IPAddressNetwork<T, R, E, S, J> owner) {
			this.owner = owner;
		}
		@Override
		public IPAddressNetwork<T, R, E, S, J> getNetwork() {
			return owner;
		}
		
		@Override
		protected S createSegmentInternal(int value, Integer segmentPrefixLength, CharSequence addressStr, int originalVal, boolean isStandardString, int lowerStringStartIndex, int lowerStringEndIndex) {
			S segment = createSegment(value, segmentPrefixLength);
			segment.setStandardString(addressStr, isStandardString, lowerStringStartIndex, lowerStringEndIndex, originalVal);
			segment.setWildcardString(addressStr, isStandardString, lowerStringStartIndex, lowerStringEndIndex, originalVal);
			return segment;
		}
		
		@Override
		protected S createRangeSegmentInternal(int lower, int upper, Integer segmentPrefixLength, CharSequence addressStr, int originalLower, int originalUpper, boolean isStandardString, boolean isStandardRangeString, int lowerStringStartIndex, int lowerStringEndIndex, int upperStringEndIndex) {
			S segment = createSegment(lower, upper, segmentPrefixLength);
			segment.setStandardString(addressStr, isStandardString,  isStandardRangeString, lowerStringStartIndex, lowerStringEndIndex, upperStringEndIndex, originalLower, originalUpper);
			segment.setWildcardString(addressStr, isStandardRangeString, lowerStringStartIndex, upperStringEndIndex, originalLower, originalUpper);
			return segment;
		}
		
		protected abstract R[] createSectionArray(int length);
		@Override
		protected abstract R createSectionInternal(S segments[]);
		protected abstract R createEmbeddedSectionInternal(IPAddressSection encompassingSection, S segments[]);
		@Override
		protected R createPrefixedSectionInternal(S segments[], Integer prefix) {
			return createPrefixedSectionInternal(segments, prefix, false);
		}
		@Override
		protected abstract R createPrefixedSectionInternal(S segments[], Integer prefix, boolean singleOnly);
		public abstract R createFullSectionInternal(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix);
		public abstract R createSection(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix);
		public abstract R createSection(byte bytes[], Integer prefix);
		public abstract R createSection(S segments[], Integer networkPrefixLength);
		public abstract R createSection(S segments[]);
		protected abstract T[] createAddressArray(int length);
		public T createAddress(S segments[]) {
			return createAddress(createSection(segments));
		}
		public T createAddress(S segments[], Integer prefix) {
			return createAddress(createSection(segments, prefix));
		}
		@Override
		protected T createAddressInternal(S segments[]) {
			return createAddress(createSectionInternal(segments));
		}
		@Override
		protected T createAddressInternal(S segments[], Integer prefix, boolean singleOnly) {
			return createAddress(createPrefixedSectionInternal(segments, prefix, singleOnly));
		}
		@Override
		protected T createAddressInternal(S segments[], Integer prefix) {
			return createAddress(createPrefixedSectionInternal(segments, prefix));
		}
		protected T createAddressInternal(S segments[], CharSequence zone) {
			return createAddressInternal(createSectionInternal(segments), zone);
		}
		public T createAddress(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix) {
			return createAddress(createFullSectionInternal(lowerValueProvider, upperValueProvider, prefix));
		}
		// used by IPAddressGenerator
		public T createAddress(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefix, CharSequence zone) {
			return createAddressInternal(createFullSectionInternal(lowerValueProvider, upperValueProvider, prefix), zone);
		}
		protected R createSectionInternal(byte bytes[], int segmentCount, Integer prefix) {
			return createSectionInternal(bytes, segmentCount, prefix, false);
		}
		
		protected abstract R createSection(byte bytes[], int byteStartIndex, int byteEndIndex, int segmentCount, Integer prefix);
		public T createAddress(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix) {
			return createAddress(createSection(bytes, byteStartIndex, byteEndIndex, getAddressSegmentCount(), prefix));
		}
		//use by IPAddressGenerator
		public T createAddress(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefix, CharSequence zone) {
			return createAddressInternal(createSection(bytes, byteStartIndex, byteEndIndex, getAddressSegmentCount(), prefix), zone);
		}
		protected T createAddressInternal(byte bytes[], Integer prefix) {
			return createAddress(createSectionInternal(bytes, getAddressSegmentCount(), prefix));
		}
		protected T createAddressInternal(byte bytes[], Integer prefix, CharSequence zone) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), prefix), zone);
		}
		@Override
		protected T createAddressInternal(byte bytes[], CharSequence zone) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), null), zone);
		}
		protected T createAddressInternal(byte bytes[], Integer prefix, CharSequence zone, HostName fromHost) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), prefix), zone, fromHost);
		}
		protected T createAddressInternal(byte bytes[], Integer prefix, HostName fromHost) {
			return createAddressInternal(createSectionInternal(bytes, getAddressSegmentCount(), prefix), fromHost);
		}
		public T createAddress(byte bytes[], Integer prefix) {
			return createAddress(createSection(bytes, prefix));
		}
		public T createAddress(byte bytes[]) {
			return createAddress(createSection(bytes, null));
		}
		@Override
		protected T createAddressInternal(R section, CharSequence zone, HostIdentifierString from) {
			T result = createAddressInternal(section, zone);
			result.cache(from);
			return result;
		}
		@Override
		protected T createAddressInternal(R section, HostIdentifierString from) {
			T result = createAddress(section);
			result.cache(from);
			return result;
		}
		protected abstract T createAddress(J inetAddress);
		protected abstract T createAddress(J inetAddress, Integer networkPrefixLength);
		/* this method exists and is protected because zone makes no sense for IPv4 so we do not expose it as public (internally it is always null) */
		protected abstract T createAddressInternal(R section, CharSequence zone);
		@Override
		public abstract T createAddress(R section);
		protected abstract int getAddressSegmentCount();
		
		public T createSequentialBlockAddress(IPAddressSegmentSeries address, int index, int lowerVal, int upperVal) {
			S[] segments = createSequentialBlockSegments(address, index, lowerVal, upperVal);
			return createAddressInternal(segments);
		}
		public R createSequentialBlockSection(IPAddressSegmentSeries series, int index, int lowerVal, int upperVal) {
			S[] segments = createSequentialBlockSegments(series, index, lowerVal, upperVal);
			return createSectionInternal(segments);
		}
		private S[] createSequentialBlockSegments(IPAddressSegmentSeries series, int index, int lowerVal, int upperVal) {
			S segments[] = createSegmentArray(series.getSegmentCount());
			series.getSegments(0, index, segments, 0);
			segments[index] = createSegment(lowerVal, upperVal, null);
			if(++index < segments.length) {
				S allRangeSegment = createSegment(0, getMaxValuePerSegment(), null);
				do {
					segments[index] = allRangeSegment;
				} while(++index < segments.length);
			}
			return segments;
		}
	}
	private IPAddressCreator<T, R, E, S, J> creator;
	@SuppressWarnings("unchecked")
	protected IPAddressNetwork(Class<T> addressType) {
		IPVersion version = getIPVersion();
		int bitSize = IPAddress.getBitCount(version);
		this.subnetsMasksWithPrefix = (T[]) Array.newInstance(addressType, bitSize + 1);
		this.subnetMasks = this.subnetsMasksWithPrefix.clone();
		this.networkAddresses = this.subnetsMasksWithPrefix.clone();
		this.hostMasks = this.subnetsMasksWithPrefix.clone();
		this.creator = createAddressCreator();
		int segmentBitSize = IPAddressSegment.getBitCount(version);
		int fullMask = ~(~0 << segmentBitSize); // segmentBitSize must be 5 bits at most for this shift to work per the java spec integer shift ishl operation (so it must be less than 2^5 = 32)
		networkSegmentMasks = new int[segmentBitSize + 1];
		hostSegmentMasks = networkSegmentMasks.clone();
		for(int i = 0; i <= segmentBitSize; i++) {
			int networkMask = this.networkSegmentMasks[i] = fullMask & (fullMask << (segmentBitSize - i));
			this.hostSegmentMasks[i] = ~networkMask & fullMask;
		}
	}
	
	@Override
	public void clearCaches() {
		Arrays.fill(subnetsMasksWithPrefix, null);//this cache has prefixed addresses
		Arrays.fill(subnetMasks, null);
		Arrays.fill(networkAddresses, null);
		Arrays.fill(hostMasks, null);
		loopback = null;
		loopbackStrings = null;
		super.clearCaches();
	}
	public boolean isIPv4() {
		return false;
	}
	public boolean isIPv6() {
		return false;
	}
	public abstract IPVersion getIPVersion();
	
	protected abstract BiFunction<T, Integer, S> getSegmentProducer();
	
	protected abstract Function<T, R> getSectionProducer();
	
	protected abstract IPAddressCreator<T, R, E, S, J> createAddressCreator();
	@Override
	public IPAddressCreator<T, R, E, S, J> getAddressCreator() {
		return creator;
	}
	public T getLoopback() {
		if(loopback == null) {
			synchronized(this) {
				if(loopback == null) {
					loopback = createLoopback();
				}
			}
		}
		return loopback;
	}
	
	protected abstract T createLoopback();
	
	public String[] getStandardLoopbackStrings() {
		if(loopbackStrings == null) {
			synchronized(this) {
				if(loopbackStrings == null) {
					loopbackStrings = getLoopback().toStandardStrings();
				}
			}
		}
		return loopbackStrings;
	}
	
	public int getSegmentNetworkMask(int segmentPrefixLength) {
		//the 0th array are masks of just 1 segment and 1 segment is always less than 32 bits, so we can cast to an int
		return (int) networkSegmentMasks[segmentPrefixLength];
	}
	
	public int getSegmentHostMask(int segmentPrefixLength) {
		//the 0th array are masks of just 1 segment and 1 segment is always less than 32 bits, so we can cast to an int
		return (int) hostSegmentMasks[segmentPrefixLength];
	}
	
	/**
	 * The tne network mask is a single address with zeros corresponding to the host section of the address.
	 * It may or may not include the prefix length of the network.
	 * 
	 * @param networkPrefixLength
	 * @return
	 */
	public T getNetworkMask(int networkPrefixLength) {
		return getNetworkMask(networkPrefixLength, true);
	}
	
	/**
	 * The network address is the subnet of all address with the same network mask.
	 * For example, 1.2.0.0/16 is a network address when it includes all addresses 1.2.*.*,
	 * rather than just being the single address, the mask 1.2.0.0
	 * <p>
	 * 
	 * @param networkPrefixLength
	 * @return
	 */
	public T getNetworkAddress(int networkPrefixLength) {
		return getMask(networkPrefixLength, networkAddresses, true, true, true);
	}
	
	public T getNetworkMask(int networkPrefixLength, boolean withPrefixLength) {
		return getMask(networkPrefixLength, withPrefixLength ? subnetsMasksWithPrefix : subnetMasks, true, withPrefixLength, false);
	}
	
	public R getNetworkMaskSection(int networkPrefixLength) {
		return getSectionProducer().apply(getNetworkMask(networkPrefixLength, true));
	}
	
	public T getHostMask(int networkPrefixLength) {
		return getMask(networkPrefixLength, hostMasks, false, false, false);
	}
	
	public R getHostMaskSection(int networkPrefixLength) {
		return getSectionProducer().apply(getHostMask(networkPrefixLength));
	}
	
	@SuppressWarnings("unchecked")
	private T getMask(int networkPrefixLength, T cache[], boolean network, boolean withPrefixLength, boolean networkAddress) {
		int bits = networkPrefixLength;
		IPVersion version = getIPVersion();
		int addressBitLength = IPAddress.getBitCount(version);
		if(bits < 0 || bits > addressBitLength) {
			throw new PrefixLenException(bits, version);
		}
		int cacheIndex = bits;
		T subnet = cache[cacheIndex];
		if(subnet == null) {
			int onesSubnetIndex, zerosSubnetIndex;
			if(network) {
				onesSubnetIndex = addressBitLength;
				zerosSubnetIndex = 0;
			} else {
				onesSubnetIndex = 0;
				zerosSubnetIndex = addressBitLength;
			}
			T onesSubnet = cache[onesSubnetIndex];
			T zerosSubnet = cache[zerosSubnetIndex];
			if(onesSubnet == null || zerosSubnet == null) {
				synchronized(cache) {
					int segmentCount = IPAddress.getSegmentCount(version);
					int bitsPerSegment = IPAddress.getBitsPerSegment(version);
					int bytesPerSegment = IPAddress.getBytesPerSegment(version);
					onesSubnet = cache[onesSubnetIndex];
					if(onesSubnet == null) {
						IPAddressCreator<T, ?, ?, S, ?> creator = getAddressCreator();
						S newSegments[] = creator.createSegmentArray(segmentCount);
						int maxSegmentValue = IPAddress.getMaxSegmentValue(version);
						if(network && withPrefixLength) {
							S segment = creator.createSegment(maxSegmentValue, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, addressBitLength) /* null */ );
							Arrays.fill(newSegments, 0, newSegments.length - 1, segment);
							S lastSegment = creator.createSegment(maxSegmentValue, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, bitsPerSegment) /* bitsPerSegment */ );
							newSegments[newSegments.length - 1] = lastSegment;
							onesSubnet = creator.createAddressInternal(newSegments, cacheBits(addressBitLength)); /* address creation */
						} else {
							S segment = creator.createSegment(maxSegmentValue);
							Arrays.fill(newSegments, segment);
							onesSubnet = creator.createAddressInternal(newSegments); /* address creation */
						}
						initMaskCachedValues(onesSubnet.getSection(), network, withPrefixLength, networkAddress, addressBitLength, onesSubnetIndex, segmentCount, bitsPerSegment, bytesPerSegment);
						cache[onesSubnetIndex] = onesSubnet;
					}
					zerosSubnet = cache[zerosSubnetIndex];
					if(zerosSubnet == null) {
						IPAddressCreator<T, ?, ?, S, ?> creator = getAddressCreator();
						S newSegments[] = creator.createSegmentArray(segmentCount);
						S seg;
						if(network && withPrefixLength) {
							seg = creator.createSegment(0, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, 0) /* 0 */);
							Arrays.fill(newSegments, seg);
							zerosSubnet = creator.createAddressInternal(newSegments, cacheBits(0)); /* address creation */
							if(getPrefixConfiguration().zeroHostsAreSubnets() && !networkAddress) {
								zerosSubnet = (T) zerosSubnet.getLower();
							}
						} else {
							seg = creator.createSegment(0);
							Arrays.fill(newSegments, seg);
							zerosSubnet = creator.createAddressInternal(newSegments); /* address creation */
						}
						initMaskCachedValues(zerosSubnet.getSection(), network, withPrefixLength, networkAddress, addressBitLength, zerosSubnetIndex, segmentCount, bitsPerSegment, bytesPerSegment);
						cache[zerosSubnetIndex] = zerosSubnet;
					}
				}
			}
			
			synchronized(cache) {
				subnet = cache[cacheIndex];
				if(subnet == null) {			
					BiFunction<T, Integer, S> segProducer = getSegmentProducer();				
					int segmentCount = IPAddress.getSegmentCount(version);
					int bitsPerSegment = IPAddress.getBitsPerSegment(version);
					int bytesPerSegment = IPAddress.getBytesPerSegment(version);
					int prefix = bits;
					S onesSegment = segProducer.apply(onesSubnet, 0);
					S zerosSegment = segProducer.apply(zerosSubnet, 0);
					IPAddressCreator<T, ?, ?, S, ?> creator = getAddressCreator();
					
					ArrayList<S> segmentList = new ArrayList<S>(segmentCount);
					int i = 0;
					for(; bits > 0; i++, bits -= bitsPerSegment) {
						if(bits <= bitsPerSegment) {
							S segment = null;
							
							//first do a check whether we have already created a segment like the one we need
							int offset = ((bits - 1) % bitsPerSegment) + 1;
							for(int j = 0, entry = offset; j < segmentCount; j++, entry += bitsPerSegment) {
								if(entry != cacheIndex) { //we already know that the entry at cacheIndex is null
									T prev = cache[entry];
									if(prev != null) {
										segment = segProducer.apply(prev, j);
										break;
									}
								}
							}
							
							//if none of the other addresses with a similar segment are created yet, we need a new segment.
							if(segment == null) {
								int mask = getSegmentNetworkMask(bits);
								if(network) {
									if(withPrefixLength) {
										segment = creator.createSegment(mask, IPAddressSection.getSegmentPrefixLength(bitsPerSegment, bits));
									} else {
										segment = creator.createSegment(mask);
									}
								} else {
									segment = creator.createSegment(getSegmentHostMask(bits));
								}
							}
							segmentList.add(segment);
						} else {
							segmentList.add(network ? onesSegment : zerosSegment);
						}
					}
					for(; i<segmentCount; i++) {
						segmentList.add(network ? zerosSegment : onesSegment);
					}
					S newSegments[] = creator.createSegmentArray(segmentList.size());
					segmentList.toArray(newSegments);
					if(network && withPrefixLength) {
						subnet = creator.createAddressInternal(newSegments, cacheBits(prefix)); /* address creation */
						if(getPrefixConfiguration().zeroHostsAreSubnets() && !networkAddress) {
							subnet = (T) subnet.getLower();
						}
					} else {
						subnet = creator.createAddressInternal(newSegments); /* address creation */
					}
					//initialize the cache fields since we know what they are now - they do not have to be calculated later
					initMaskCachedValues(subnet.getSection(), network, withPrefixLength, networkAddress, addressBitLength, prefix, segmentCount, bitsPerSegment, bytesPerSegment);
					cache[cacheIndex] = subnet; //last thing is to put into the cache - don't put it there before we are done with it
				} // end subnet from cache is null
			} //end synchronized
		} // end subnet from cache is null
		return subnet;
	}
	private void initMaskCachedValues(
			IPAddressSection section, 
			boolean network,
			boolean withPrefixLength,
			boolean networkAddress,
			int addressBitLength, 
			int networkPrefixLength,
			int segmentCount, 
			int bitsPerSegment,
			int bytesPerSegment) {
		Integer cachedNetworkPrefix, cachedMinPrefix, cachedEquivalentPrefix;
		BigInteger cachedCount;
		RangeList zeroSegments, zeroRanges;
		boolean hasZeroRanges = network ? addressBitLength - networkPrefixLength >= bitsPerSegment : networkPrefixLength >= bitsPerSegment;
		RangeList noZeros = IPAddressSection.getNoZerosRange();
		if(hasZeroRanges) {
			int rangeIndex, rangeLen;
			if(network) {
				int segmentIndex = IPAddressSection.getNetworkSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment) + 1;
				rangeIndex = segmentIndex;
				rangeLen = segmentCount - segmentIndex;
			} else {
				rangeIndex = 0;
				rangeLen = IPAddressSection.getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
			}
			zeroRanges = IPAddressSection.getSingleRange(rangeIndex, rangeLen);
			zeroSegments = (network && withPrefixLength && !getPrefixConfiguration().prefixedSubnetsAreExplicit()) ? noZeros : zeroRanges;
		} else {
			zeroSegments = zeroRanges = noZeros;
		}
		Integer npl = cacheBits(networkPrefixLength);
		if(network && withPrefixLength) {
			if(getPrefixConfiguration().prefixedSubnetsAreExplicit() || (getPrefixConfiguration().zeroHostsAreSubnets() && !networkAddress)) {
				cachedEquivalentPrefix = cachedMinPrefix = cacheBits(addressBitLength);
				cachedNetworkPrefix = npl;
				cachedCount = BigInteger.ONE;
			} else {
				cachedEquivalentPrefix = cachedMinPrefix = cachedNetworkPrefix = npl;
				cachedCount = BigInteger.valueOf(2).pow(addressBitLength - networkPrefixLength);
			}
		} else {
			cachedEquivalentPrefix = cachedMinPrefix = cacheBits(addressBitLength);
			cachedNetworkPrefix = null;
			cachedCount = BigInteger.ONE;
		}
		section.initCachedValues(npl, network, cachedNetworkPrefix, cachedMinPrefix, cachedEquivalentPrefix, cachedCount, zeroSegments, zeroRanges);
	}
	
	protected static Integer cacheBits(int i) {
		return IPAddressSection.cacheBits(i);
	}
	public static String getPrefixString(int networkPrefixLength) {
		return new StringBuilder(HostIdentifierStringValidator.MAX_PREFIX_CHARS + 1).append(IPAddress.PREFIX_LEN_SEPARATOR).append(networkPrefixLength).toString();
	}
	/**
	 * <p>
	 * A factory of address strings or host names, which can be particularly useful if you are using your own network, 
	 * or if you are using your own validation options.
	 * <p>
	 *  
	 * @author sfoley
	 *
	 */
	public static class IPAddressGenerator implements Serializable {
		private static final long serialVersionUID = 4L;
		
		protected final IPAddressStringParameters options;
		
		public IPAddressGenerator() {
			this(null);
		}
		
		/**
		 * Copies the default string options but inserts the given networks.
		 * Either argument can be null to use the default networks.
		 * 
		 * @param ipv4Network
		 * @param ipv6Network
		 */
		public IPAddressGenerator(IPv4AddressNetwork ipv4Network, IPv6AddressNetwork ipv6Network) {
			this(new IPAddressStringParameters.Builder().
						getIPv4AddressParametersBuilder().setNetwork(ipv4Network).
						getParentBuilder().
						getIPv6AddressParametersBuilder().setNetwork(ipv6Network).
							getEmbeddedIPv4AddressParametersBuilder().setNetwork(ipv4Network).
							getEmbeddedIPv4AddressParentBuilder().
						getParentBuilder().
					toParams());
		}
		
		public IPAddressGenerator(IPAddressStringParameters options) {
			if(options == null) {
				options = IPAddressString.DEFAULT_VALIDATION_OPTIONS;
			}
			this.options = options;
		}
		protected String toNormalizedString(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			if(version == IPVersion.IPV4) {
				IPv4AddressNetwork network = options.getIPv4Parameters().getNetwork();
				return IPv4Address.toNormalizedString(network, lowerValueProvider, upperValueProvider, prefixLength);
			}
			if(version == IPVersion.IPV6) {
				IPv6AddressNetwork network = options.getIPv6Parameters().getNetwork();
				return IPv6Address.toNormalizedString(network, lowerValueProvider, upperValueProvider, prefixLength, zone);
			}
			throw new IllegalArgumentException();
		}
		
		public IPAddress from(InetAddress inetAddress) {
			if(inetAddress instanceof Inet4Address) {
				return getIPv4Creator().createAddress((Inet4Address) inetAddress);
			} else if(inetAddress instanceof Inet6Address) {
				return getIPv6Creator().createAddress((Inet6Address) inetAddress);
			}
			return null;
		}
		
		public IPAddress from(InetAddress inetAddress, Integer prefixLength) {
			if(inetAddress instanceof Inet4Address) {
				return getIPv4Creator().createAddress((Inet4Address) inetAddress, prefixLength);
			} else if(inetAddress instanceof Inet6Address) {
				return getIPv6Creator().createAddress((Inet6Address) inetAddress, prefixLength);
			}
			return null;
		}
		
		public IPAddress from(InterfaceAddress interfaceAddress) {
			InetAddress inetAddress = interfaceAddress.getAddress();
			if(inetAddress instanceof Inet4Address) {
				return getIPv4Creator().createAddress((Inet4Address) inetAddress, cacheBits(interfaceAddress.getNetworkPrefixLength()));
			} else if(inetAddress instanceof Inet6Address) {
				return getIPv6Creator().createAddress((Inet6Address) inetAddress, cacheBits(interfaceAddress.getNetworkPrefixLength()));
			}
			return null;
		}
		
		public IPAddress from(byte bytes[]) {
			return from(bytes, 0, bytes.length, null, null);
		}
		
		public IPAddress from(byte bytes[], int byteStartIndex, int byteEndIndex) {
			return from(bytes, byteStartIndex, byteEndIndex, null, null);
		}
		
		public IPAddress from(byte bytes[], int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) {
			return from(bytes, byteStartIndex, byteEndIndex, networkPrefixLength, null);
		}
	
		public IPAddress from(byte bytes[], Integer prefixLength) {
			return from(bytes, 0, bytes.length, prefixLength, null);
		}
		
		private IPAddress from(byte bytes[], int byteStartIndex, int byteEndIndex, Integer prefixLength, CharSequence zone) {
			if(byteEndIndex - byteStartIndex < IPv6Address.BYTE_COUNT) {
				return getIPv4Creator().createAddress(bytes, byteStartIndex, byteEndIndex, prefixLength);
			}
			return getIPv6Creator().createAddress(bytes, byteStartIndex, byteEndIndex, prefixLength, zone);
		}
	
		public IPAddress from(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return from(version, lowerValueProvider, upperValueProvider, prefixLength, null);
		}
	
		private IPv4AddressCreator getIPv4Creator() {
			IPv4AddressNetwork network = options.getIPv4Parameters().getNetwork();
			IPv4AddressCreator addressCreator = network.getAddressCreator();
			return addressCreator;
		}
	
		private IPv6AddressCreator getIPv6Creator() {
			IPv6AddressNetwork network = options.getIPv6Parameters().getNetwork();
			IPv6AddressCreator addressCreator = network.getAddressCreator();
			return addressCreator;
		}
		private IPAddress from(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			if(version == IPVersion.IPV4) {
				return getIPv4Creator().createAddress(lowerValueProvider, upperValueProvider, prefixLength);
			}
			if(version == IPVersion.IPV6) {
				return getIPv6Creator().createAddress(lowerValueProvider, upperValueProvider, prefixLength, zone);
			}
			throw new IllegalArgumentException();
		}
	}
	/**
	 * Choose a map of your choice to implement a cache of addresses and/or host names.
	 * <p>
	 * You can also use this class without a cache to serve as a factory of addresses or host names, 
	 * which can be particularly useful if you are using your own network, or if you are using your own validation options.
	 * <p>
	  * For long-running programs or servers that handle many addresses, the benefits of using a cache are that
	 * <ul>
	 * <li>the lookup can provide the same objects for different strings that identify the same host name or address</li>
	 * <li>parsing and resolving repeated instances of the same address or host string is minimized.  Both IPAddressString and HostName cache their parsed and resolved addresses.</li>
	 * <li>other functionality is optimized through caching, since Host Name, IPAddressString, and IPAddress also caches objects such as generated strings.  With cached objects, switching between host names, address strings and numeric addresses is constant time.</li>
	 * </ul><p>
	 * You choose the map of your choice to be the backing map for the cache.
	 * For example, for thread-safe access to the cache, ConcurrentHashMap is a good choice.
	 * For maps of bounded size, LinkedHashMap provides the removeEldestEntry method to override to implement LRU or other eviction mechanisms.
	 * 
	 * @author sfoley
	 *
	 * @param <T> the type to be cached, typically either IPAddressString or HostName
	 */
	public static abstract class HostIDStringAddressGenerator<T extends HostIdentifierString> implements Serializable {
		private static final long serialVersionUID = 4L;
		
		private final IPAddressGenerator addressGenerator;
		protected final Map<String, T> backingMap;
		
		public HostIDStringAddressGenerator() {
			this(null, null);
		}
		
		public HostIDStringAddressGenerator(IPAddressStringParameters options) {
			this(null, options);
		}
		
		public HostIDStringAddressGenerator(Map<String, T> backingMap) {
			this(backingMap, null);
		}
		
		public HostIDStringAddressGenerator(Map<String, T> backingMap, IPAddressStringParameters options) {
			this.backingMap = backingMap;
			this.addressGenerator = new IPAddressGenerator(options);
		}
		
		public Map<String, T> getBackingMap() {
			return backingMap;
		}
		
		public static SegmentValueProvider getValueProvider(byte bytes[]) {
			int segmentByteCount = (bytes.length == IPv4Address.BYTE_COUNT) ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
			return getValueProvider(bytes, segmentByteCount);
		}
		
		public static SegmentValueProvider getValueProvider(byte bytes[], int segmentByteCount) {
			return segmentIndex -> {	
				int value = 0;
				for(int start = segmentIndex * segmentByteCount, end = start + segmentByteCount; start < end; start++) {
					value = (value << 8) | (0xff & bytes[start]);
				}
				return value;
			};
		}
		
		public T get(byte bytes[]) {
			IPVersion version = bytes.length == IPv4Address.BYTE_COUNT ? IPVersion.IPV4 : IPVersion.IPV6;
			int segmentByteCount = version.isIPv4() ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
			return get(version, getValueProvider(bytes, segmentByteCount), null, null, null);
		}
		public T get(AddressValueProvider addressProvider) {
			if(addressProvider instanceof IPAddressValueProvider) {
				return get((IPAddressValueProvider) addressProvider);
			}
			return get(addressProvider.getSegmentCount() == IPv4Address.SEGMENT_COUNT ? IPVersion.IPV4 : IPVersion.IPV6, 
					addressProvider.getValues(), addressProvider.getUpperValues(), null, null);	
		}
		public T get(IPAddressValueProvider addressProvider) {
			return get(addressProvider.getIPVersion(), addressProvider.getValues(), addressProvider.getUpperValues(), addressProvider.getPrefixLength(), addressProvider.getZone());
		}
		public T get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return get(version, lowerValueProvider, upperValueProvider, prefixLength, null);
		}
		public T get(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return get(IPVersion.IPV6, lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
		private T get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			if(backingMap == null) {
				IPAddress addr = addressGenerator.from(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
				return create(addr);
			}
			String key = toNormalizedString(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
			T result = backingMap.get(key);
			if(result == null) {
				IPAddress addr = addressGenerator.from(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
				addr.cacheNormalizedString(key);
				
				//get the object that wraps the address, either HostName or IPAddressString or other
				result = create(addr);
				T existing = backingMap.putIfAbsent(key, result);
				if(existing == null) {
					added(result);
				} else {
					result = existing;
					//Since we have the address, we can make the existing host identifier string entry wrap the address
					//cache(result, addr);
				}
			}
			return result;
		}
		protected String toNormalizedString(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return addressGenerator.toNormalizedString(version, lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
		protected abstract T create(IPAddress addr);
		protected abstract void cache(T result, IPAddress addr);
		
		protected abstract void added(T added);
	}
	
	/**
	 * Choose a map of your choice to implement a cache of address strings and their associated addresses.
	 * 
	 * The map will map string representations of the address to IPAddressString objects, which in turn cache any resulting IPAddress objects.
	 * 
	 * Those objects are all themselves thread-safe, but the cache will only be thread-safe if you choose a thread-safe map such as ConcurrentHashMap.
	 *
	 * @author sfoley
	 *
	 */
	public static class IPAddressStringGenerator extends HostIdentifierStringGenerator<IPAddressString> {
		private static final long serialVersionUID = 4L;
		private final HostIDStringAddressGenerator<IPAddressString> addressGenerator;
		@SuppressWarnings("serial")
		public IPAddressStringGenerator(Map<String, IPAddressString> backingMap, IPAddressStringParameters options) {
			super(backingMap);
			addressGenerator = new HostIDStringAddressGenerator<IPAddressString>(backingMap, options) {
				
				@Override
				protected IPAddressString create(IPAddress addr) {
					return addr.toAddressString();
				}
				
				@Override
				protected void cache(IPAddressString result, IPAddress addr) {
					result.cacheAddress(addr);
				}
				@Override
				protected void added(IPAddressString added) {
					IPAddressStringGenerator.this.added(added);
				}
			};
		}
		public IPAddressStringGenerator(Map<String, IPAddressString> backingMap) {
			this(backingMap, null);
		}
		public IPAddressStringGenerator(IPAddressStringParameters options) {
			this(null, options);
		}
		public IPAddressStringGenerator() {
			this(null, null);
		}
		@Override
		protected IPAddressString create(String addressString) {
			IPAddressStringParameters options = addressGenerator.addressGenerator.options;
			return options == null ? new IPAddressString(addressString) : new IPAddressString(addressString, options);
		}
		public static SegmentValueProvider getValueProvider(byte bytes[]) {
			return HostIDStringAddressGenerator.getValueProvider(bytes);
		}
		@Override
		public IPAddressString get(byte bytes[]) {
			return addressGenerator.get(bytes);
		}
		public IPAddressString get(IPAddressValueProvider addressProvider) {
			return addressGenerator.get(addressProvider);
		}
		@Override
		public IPAddressString get(AddressValueProvider addressProvider) {
			return addressGenerator.get(addressProvider);
		}
		public IPAddressString get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return addressGenerator.get(version, lowerValueProvider, upperValueProvider, prefixLength);
		}
		public IPAddressString get(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return addressGenerator.get(lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
	}
	/**
	 * Choose a map of your choice to implement a cache of host names and resolved addresses.
	 * 
	 * The map will map string representations of the host to HostName objects.
	 * 
	 * Those HostName objects in turn cache any resulting IPAddressString objects if the string represents an address, 
	 * or any IPAddress objects obtained from resolving the HostName.
	 * 
	 * Those objects are all themselves thread-safe, but the cache will only be thread-safe if you choose a thread-safe map such as ConcurrentHashMap.
	 *
	 * @author sfoley
	 *
	 */
	public static class HostNameGenerator extends HostIdentifierStringGenerator<HostName> {
		private static final long serialVersionUID = 4L;
		
		private final HostIDStringAddressGenerator<HostName> addressGenerator;
		private final HostNameParameters options;
		
		@SuppressWarnings("serial")
		public HostNameGenerator(Map<String, HostName> backingMap, HostNameParameters options, boolean reverseLookup) {
			super(backingMap);
			addressGenerator = new HostIDStringAddressGenerator<HostName>(backingMap, options.addressOptions) {
				@Override
				protected HostName create(IPAddress addr) {
					if(reverseLookup) {
						return new HostName(addr.toInetAddress().getHostName());
					}
					return new HostName(addr);
				}
				
				@Override
				protected void cache(HostName result, IPAddress addr) {
					result.cacheAddress(addr);
				}
				@Override
				protected void added(HostName added) {
					HostNameGenerator.this.added(added);
				}
			};
			this.options = options;
		}
		
		public HostNameGenerator(Map<String, HostName> backingMap) {
			this(backingMap, HostName.DEFAULT_VALIDATION_OPTIONS, false);
		}
		
		public HostNameGenerator(HostNameParameters options) {
			this(null, options, false);
		}
		
		public HostNameGenerator() {
			this(null, null, false);
		}
		@Override
		protected HostName create(String key) {
			return options == null ? new HostName(key) : new HostName(key, options);
		}
		
		public static SegmentValueProvider getValueProvider(byte bytes[]) {
			return HostIDStringAddressGenerator.getValueProvider(bytes);
		}
		
		@Override
		public HostName get(byte bytes[]) {
			return addressGenerator.get(bytes);
		}
		
		@Override
		public HostName get(AddressValueProvider addressProvider) {
			return addressGenerator.get(addressProvider);
		}
		
		public HostName get(IPVersion version, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
			return addressGenerator.get(version, lowerValueProvider, upperValueProvider, prefixLength);
		}
		
		public HostName get(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
			return addressGenerator.get(lowerValueProvider, upperValueProvider, prefixLength, zone);
		}
	}
}
/*
 * Copyright 2020-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import inet.ipaddr.Address;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.AddressSegmentSeries;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.format.util.AddressTrie.TrieNode.FollowingBits;
import inet.ipaddr.format.util.AddressTrie.TrieNode.KeyCompareResult;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
import inet.ipaddr.format.util.BinaryTreeNode.BlockSizeNodeIterator;
import inet.ipaddr.format.util.BinaryTreeNode.Bounds;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker.Change;
import inet.ipaddr.format.util.BinaryTreeNode.Indents;
import inet.ipaddr.format.util.BinaryTreeNode.KeySpliterator;
import inet.ipaddr.format.util.BinaryTreeNode.NodeIterator;
import inet.ipaddr.format.util.BinaryTreeNode.NodeSpliterator;
import inet.ipaddr.format.util.BinaryTreeNode.PostOrderNodeIterator;
import inet.ipaddr.format.util.BinaryTreeNode.PreOrderNodeIterator;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * A compact binary trie (aka compact binary prefix tree, or binary radix trie), for addresses and/or CIDR prefix block subnets.
 * The prefixes in used by the prefix trie are the CIDR prefixes, or the full address in the case of individual addresses with no prefix length.  
 * The elements of the trie are CIDR prefix blocks or addresses.
 * <p>
 * This trie data structure allows you to check an address for containment in many subnets at once, in constant time.  
 * The trie allows you to check a subnet for containment of many smaller subnets or addresses at once, in constant time.
 * The trie allows you to check for equality of a subnet or address with a large number of subnets or addresses at once.
 *<p>
 * The trie can also be used as the backing structure for a {@link AddressTrieSet} which is a {@link java.util.NavigableSet}.
 * Unlike {@link java.util.TreeSet} this data structure provides access to the nodes and the associated subtrie with each node,
 * which corresponds with their associated CIDR prefix block subnets.
 * <p>
 * There is only a single possible trie for any given set of address and subnets.  For one thing, this means they are automatically balanced.
 * Also, this makes access to subtries and to the nodes themselves more useful, allowing for many of the same operations performed on the original trie.  
 * <p>
 * Each node has either a prefix block or a single address as its key.  
 * Each prefix block node can have two sub-nodes, each sub-node a prefix block or address contained by the node.
 * <p>
 * There are more nodes in the trie than there are elements in the set.  
 * A node is considered "added" if it was explicitly added to the trie and is included as an element when viewed as a set.
 * There are non-added prefix block nodes that are generated in the trie as well.
 * When two or more added addresses share the same prefix up until they differ with the bit at index x, 
 * then a prefix block node is generated (if not already added to the trie) for the common prefix of length x,
 * with the nodes for those addresses to be found following the lower 
 * or upper sub-nodes according to the bit at index x + 1 in each address.
 * If that bit is 1, the node can be found by following the upper sub-node, 
 * and when it is 0, the lower sub-node.  
 * <p>
 * Nodes that were generated as part of the trie structure only 
 * because of other added elements are not elements of the represented set.
 * The set elements are the elements that were explicitly added.
 * <p>
 * You can work with parts of the trie, starting from any node in the trie,
 * calling methods that start with any given node, such as iterating or spliterating the subtrie,
 * finding the first or last in the subtrie, doing containment checks with the subtrie, and so on.
 * <p>
 * The binary trie structure defines a natural ordering of the trie elements.  
 * Addresses of equal prefix length are sorted by prefix value.  Addresses with no prefix length are sorted by address value.
 * Addresses of differing prefix length are sorted according to the bit that follows the shorter prefix length in the address with the longer prefix length,
 * whether that bit is 0 or 1 determines if that address is ordered before or after the address of shorter prefix length.
 * <p>
 * The unique and pre-defined structure for a trie means that different means of traversing the trie can be more meaningful.
 * This trie implementation provides 8 different ways of iterating through the trie:
 * <ul><li>1, 2: the natural sorted trie order, forward and reverse (spliterating is also an option for these two orders).  Use {@link #nodeIterator(boolean)}, {@link #iterator()} or {@link #descendingIterator()}.  A comparator is also provided for this order.
 * </li><li>3, 4: pre-order tree traversal, in which parent node is visited before sub-nodes, with sub-nodes visited in forward or reverse order
 * </li><li>5, 6: post-order tree traversal, in which sub-nodes are visited before parent nodes, with sub-nodes visited in forward or reverse order
 * </li><li>7, 8: prefix-block order, in which larger prefix blocks are visited before smaller, and blocks of equal size are visited in forward or reverse sorted order
 * </li></ul>
 * <p>
 * 
 * All of these orderings are useful in specific contexts.
 * <p>
 * You can do lookup and containment checks on all the subnets and addresses in the trie at once, in constant time.
 * A generic trie data structure lookup is O(m) where m is the entry length. 
 * For this trie, which operates on address bits, entry length is capped at 128 bits for IPv6 and 32 bits for IPv4.
 * That makes lookup a constant time operation.  
 * Subnet containment or equality checks are also constant time since they work the same way as lookup, by comparing prefix bits.
 * <p>
 * For a generic trie data structure, construction is O(m * n) where m is entry length and n is the number of addresses,
 * but for this trie, since entry length is capped at 128 bits for IPv6 and 32 bits for IPv4, construction is O(n),
 * in linear proportion to the number of added elements.
 *<p>
 * This trie also allows for constant time size queries (count of added elements, not node count), by storing sub-trie size in each node. 
 * It works by updating the size of every node in the path to any added or removed node.
 * This does not change insertion or deletion operations from being constant time (because tree-depth is limited to address bit count). 
 * At the same this makes size queries constant time, rather than being O(n) time.
 * <p>
 * This class is abstract and has a subclass for each address version or type. 
 * A single trie can use just a single address type or version, since it works with bits alone,
 * and this cannot distinguish between different versions and types in the trie structure. 
 * More specifically, using different address bit lengths would:
 * <ul>
 * <li>break the concept of containment, for example IPv6 address 0::/8 would be considered to contain IPv4 address 0.2.3.4
 * </li><li>break the concept of equality, for example MAC 1:2:3:*:*:* and IPv4 1.2.3.0/24 would be considered the same since they have the same prefix bits and length 
 * </li></ul><p>
 * Instead, you could aggregate multiple subtries to create a collection of multiple address types or versions.
 * You can use the method {@link #toString(boolean, AddressTrie...)} for a String that represents multiple tries as a single tree.
 * <p>
 * Tries are thread-safe when not being modified (elements added or removed), but are not thread-safe when one thread is modifying the trie.
 * For thread safety when modifying, one option is to use {@link Collections#synchronizedNavigableSet(java.util.NavigableSet)} on {@link #asSet()}.
 * <p>
 * 
 * @author scfoley
 *
 * @param <E> the type of the address keys
 */
// Note: We do not allow direct access to tries that have non-null bounds.
// Such tries can only be accessed indirectly through the Set and Map classes.
// Methods like removeElementsContainedBy, elementsContainedBy, elementsContaining, and elementContains (and perhaps a couple others) would be inaccurate,
//	as they do not account for the bounds.
// Those methods used by the Set and Map classes do account for the bounds.
// Also, many methods here give access to the nodes, and the nodes themselves do not account for the bounds.
// That in particular would make things quite confusing for users, in which the trie methods and the node methods produce different results.
//
// So overall, we do not allow direct access to AddressTrie objects that have bounds, mostly because of the potential confusion,
// and because it would force us to alter the API for methods like elementsContainedBy in a way that makes the API inferior.
//
// We do allow the Set and Map classes to produce an AddressTrie even when bounded, 
// but that AddressTrie is a clone of the bounded trie that has only the bounded nodes.
// So, overall, we do provide the same functionality, you just have to generate a new trie from the bounded set or map.
//
// Also, by storing the bounds strictly inside the AddressTrie, we avoid the complications of making the Bounds part of the API,
// which would make all the operations quite tricky and in some cases expensive.
// For instance, here we can cache the bounded root and reuse it.  
// Making the bounds part of the API would also double the API method count and make the API quite cumbersome,
// even if it is not public.
//
// So for all those reasons, the bounds are stored in the tries, but tries with bounds are not directly accessible.
// The API then remains quite full-fledged, with full access to the nodes, while at the same time the Set and Map API
// also remains full-fledged.  Finally, Map and Set users can get a non-bounds trie for any bounded Set or Map,
// should they really want one.
// 
public abstract class AddressTrie<E extends Address> extends AbstractTree<E> {
	private static final long serialVersionUID = 1L;
	protected static class AddressBounds<E extends Address> extends Bounds<E> {
		private static final long serialVersionUID = 1L;
		
		E oneAboveUpperBound, oneBelowUpperBound, oneAboveLowerBound, oneBelowLowerBound;
		
		AddressBounds(E lowerBound, E upperBound, Comparator<? super E> comparator) {
			this(lowerBound, true, upperBound, false, comparator);
		}
		
		AddressBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			super(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
			if(lowerBound != null) {
				checkBlockOrAddress(lowerBound, true);
			}
			if(upperBound != null) {
				checkBlockOrAddress(upperBound, true);
			}
		}
		
		static <E extends Address> AddressBounds<E> createNewBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			if(lowerBound != null) {
				if(lowerInclusive && lowerBound.isZero()) {
					lowerBound = null;
				}
			}
			if(upperBound != null) {
				if(upperInclusive && upperBound.isMax()) {
					upperBound = null;
				}
			}
			if(lowerBound == null && upperBound == null) {
				return null;
			}
			return new AddressBounds<E>(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
		}
		
		@Override
		AddressBounds<E> createBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			return new AddressBounds<E>(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
		}
		
		@Override
		AddressBounds<E> restrict(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive) {
			return (AddressBounds<E>) super.restrict(lowerBound, lowerInclusive, upperBound, upperInclusive);
		}
		
		@Override
		AddressBounds<E> intersect(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive) {
			return (AddressBounds<E>) super.intersect(lowerBound, lowerInclusive, upperBound, upperInclusive);
		}
		
		
		// matches the value just above the upper bound (only applies to discrete quantities)
		@Override
		boolean isAdjacentAboveUpperBound(E addr) {
			E res = oneAboveUpperBound;
			if(res == null) {
				res = increment(upperBound);
				oneAboveUpperBound = res;
			}
			return res != null && res.equals(addr);
		}
		
		// matches the value just below the lower bound (only applies to discrete quantities)
		@Override
		boolean isAdjacentBelowLowerBound(E addr) {
			E res = oneBelowLowerBound;
			if(res == null) {
				res = decrement(lowerBound);
				oneBelowLowerBound = res;
			}
			return res != null && res.equals(addr);
		}
		
		// matches the value just below the upper bound (only applies to discrete quantities)
		@Override
		boolean isAdjacentBelowUpperBound(E addr) { 
			E res = oneBelowUpperBound;
			if(res == null) {
				res = decrement(upperBound);
				oneBelowUpperBound = res;
			}
			return res != null && res.equals(addr);
		}
		
		// matches the value just above the lower bound (only applies to discrete quantities)
		@Override
		boolean isAdjacentAboveLowerBound(E addr) {
			E res = oneAboveLowerBound;
			if(res == null) {
				res = increment(lowerBound);
				oneAboveLowerBound = res;
			}
			return res != null && res.equals(addr);
		}
		
		@Override
		boolean isMax(E addr) {
			return addr.isMax();
		}
		@Override
		boolean isMin(E addr) {
			return addr.isZero();
		}
		
		@Override
		public String toCanonicalString(String separator) {
			Function<? super E, String> stringer = Address::toCanonicalString;
			return toString(stringer, separator, stringer);
		}
	}
	
	protected static enum Operation {
		// Given an address/subnet key E
	    INSERT, // add node for E if not already there
	    REMAP, // alters nodes based on the existing nodes and their values
	    LOOKUP, // find node for E, traversing all containing elements along the way
	    NEAR, // closest match, going down trie to get element considered closest.
	    	// Whether one thing is closer than another is determined by the sorted order.
	    	// For example, for subnet 1.2.0.0/16, 1.2.128.0 is closest address on the high side, 1.2.127.255 is closest address on the low side
	    CONTAINING, // find a single node whose key contains E
	    ALL_CONTAINING, // list the nodes whose keys contain E
	    INSERTED_DELETE, // remove node for E
	    SUBTREE_DELETE // remove nodes whose keys are contained by E
	}
	
	// not optimized for size, since only temporary, to be used for a single operation
	protected static class OpResult<E extends Address> implements KeyCompareResult, FollowingBits, Serializable {
		private static final long serialVersionUID = 1L;
		E addr;
		
		// whether near is searching for a floor or ceiling
		// a floor is greatest element below addr
		// a ceiling is lowest element above addr
		boolean nearestFloor; 
		
		// whether near cannot be an exact match
		boolean nearExclusive;
		
		Operation op;
		
		OpResult() {}
		
		OpResult(E addr, Operation op) {
			this(addr, op, false, false);
		}
		OpResult(E addr, boolean floor, boolean exclusive) {
			this(addr, Operation.NEAR, floor, exclusive);
		}
		private OpResult(E addr, Operation op, boolean floor, boolean exclusive) {
			this.addr = addr;
			this.op = op;
			this.nearestFloor = floor;
			this.nearExclusive = exclusive;
		}
		// do not use with Operation.NEAR, INSERT, REMAP, INSERTED_DELETE, SUBTREE_DELETE
		OpResult<E> reset(E addr, Operation op) {
			this.addr = addr;
			this.op = op;
			return this;
		}
		
		OpResult<E> resetNear(E addr, boolean floor, boolean exclusive) {
			this.nearestFloor = floor;
			this.nearExclusive = exclusive;
			return reset(addr, Operation.NEAR);
		}
		
		// Do not use with Operation.NEAR, INSERT, REMAP, INSERTED_DELETE, SUBTREE_DELETE,
		// We'd need to do more cleaning if we did.
		void clean() {
			addr = null;
			op = null;
			
			// contains and lookups
			exists = false;
			existingNode = containing = containingEnd = 
					smallestContaining = largestContaining = 
					containedBy = null;
			
			// near
			nearestFloor = nearExclusive = false;
			nearestNode = backtrackNode = null;
			
			// deletions
			deleted = null;
			
			// adds and puts
			newValue = existingValue = null;
			inserted = added = addedAlready = null;
			// remaps
			remapper = null;
		}
		// lookups:
		// an inserted tree element matches the supplied argument
		// exists is set to true only for "added" nodes
		boolean exists;
		// the matching tree element, when doing a lookup operation, or the pre-existing node for an insert operation
		// existingNode is set for both added and not added nodes
		TrieNode<E> existingNode;
		// the closest tree element, when doing a near operation
		TrieNode<E> nearestNode;
		// if searching for a floor/lower, and the nearest node is above addr, then we must backtrack to get below
		// if searching for a ceiling/higher, and the nearest node is below addr, then we must backtrack to get above
		TrieNode<E> backtrackNode;
		
		// contains:  
		// A linked list of the tree elements, from largest to smallest, 
		// that contain the supplied argument, and the end of the list
		TrieNode<E> containing, containingEnd;
		
		// Of the tree nodes with elements containing the subnet or address,
		// those with the smallest or largest subnet or address
		TrieNode<E> smallestContaining, largestContaining;
		// contained by: 
		// this tree is contained by the supplied argument
		TrieNode<E> containedBy;
		// deletions:
		// this tree was deleted
		TrieNode<E> deleted;
		// adds and puts:
		// new and existing values for add, put and remap operations
		Object newValue, existingValue;
	
		// this added tree node was newly created for an add
		TrieNode<E> inserted;
		// this added tree node previously existed but had not been added yet
		TrieNode<E> added;
		// this added tree node was already added to the trie
		TrieNode<E> addedAlready;
		// remaps:
		Function<?, ?> remapper;
		static <E extends Address> TrieNode<E> getNextAdded(TrieNode<E> node) {
			while(node != null && !node.isAdded()) {
				// Since only one of upper and lower can be populated, whether we start with upper or lower does not matter
				TrieNode<E> next = node.getUpperSubNode();
				if(next == null) {
					node = node.getLowerSubNode();
				} else {
					node = next;
				}
			}
			return node;
		}
		TrieNode<E> getContaining() {
			TrieNode<E> containing = getNextAdded(this.containing);
			this.containing = containing;
			if(containing != null) {
				TrieNode<E> current = containing;
				do {
					TrieNode<E> next = current.getUpperSubNode();
					TrieNode<E> nextAdded;
					if(next == null) {
						next = current.getLowerSubNode();
						nextAdded = getNextAdded(next);
						if(next != nextAdded) {
							current.setLower(nextAdded);
						}
					} else {
						nextAdded = getNextAdded(next);
						if(next != nextAdded) {
							current.setUpper(nextAdded);
						}
					}
					current = nextAdded;
				} while(current != null);
			}
			return containing;
		}
		// add to the list of tree elements that contain the supplied argument
		void addContaining(TrieNode<E> containingSub) {
			TrieNode<E> cloned = containingSub.clone();
			if(containing == null) {
				containing = cloned;
			} else {
				Comparator<BinaryTreeNode<E>> comp = nodeComparator();
				if(comp.compare(containingEnd, cloned) > 0) {
					containingEnd.setLower(cloned);
				} else {
					containingEnd.setUpper(cloned);
				}
				containingEnd.adjustCount(1);
			}
			containingEnd = cloned;
		}
		
		//
		//
		//
		// for searching
		
		long followingBits;
		
		@Override
		public void setFollowingBits(long bits) {
			followingBits = bits;
		}
		
		TrieNode<E> node;
		
		@Override
		public void bitsMatch() {
			E existingAddr = node.getKey();
			Integer existingPref = existingAddr.getPrefixLength();
			Integer newPrefixLen = addr.getPrefixLength();
			containedBy = node;
			if(existingPref == null) {
				if(newPrefixLen == null) {
					// note that "added" is already true here, 
					// we can only be here if explicitly inserted already 
					// since it is a non-prefixed full address
					node.handleMatch(this);
				} else if(newPrefixLen == existingAddr.getBitCount()) {
					node.handleMatch(this);
				} else  {
					node.handleContained(this, newPrefixLen);
				}
			} else { 
				// we know newPrefixLen != null since we know all of the bits of newAddr match, 
				// which is impossible if newPrefixLen is null and existingPref not null
				if(newPrefixLen.intValue() == existingPref.intValue()) {
					if(node.isAdded()) {
						node.handleMatch(this);
					} else {
						node.handleNodeMatch(this);
					}
				} else if(existingPref == existingAddr.getBitCount()) { 
					node.handleMatch(this);
				} else { // existing prefix > newPrefixLen
					node.handleContained(this, newPrefixLen);
				}
			}
		}
		@Override
		public void bitsDoNotMatch(int matchedBits) {
			node.handleSplitNode(this, matchedBits);
		}
		@Override
		public FollowingBits bitsMatchPartially() {
			if(node.isAdded()) {
				node.handleContains(this);
				if(op == Operation.CONTAINING) {
					return null;
				}
			}
			return this;
		}
	}
	/**
	 * A comparator that provides the same ordering used by the trie,
	 * an ordering that works with prefix block subnets and individual addresses.
	 * The comparator is consistent with the equality and hashcode of address instances
	 * and can be used in other contexts.  However, it only works with prefix blocks and individual addresses,
	 * not with addresses like 1-2.3.4.5-6 which cannot be differentiated using this comparator from 1.3.4.5
	 * and is thus not consistent with equals and hashcode for subnets that are not CIDR prefix blocks.
	 * <p>
	 * The comparator first compares the prefix of addresses, with the full address value considered the prefix when 
	 * there is no prefix length, ie when it is a single address.  It takes the minimum m of the two prefix lengths and
	 * compares those m prefix bits in both addresses.  The ordering is determined by which of those two values is smaller or larger.
	 * <p>
	 * If those two values match, then it looks at the address with longer prefix.  
	 * If both prefix lengths match then both addresses are equal.
	 * Otherwise it looks at bit m in the address with larger prefix.  If 1 it is larger and if 0 it is smaller than the other.
	 * <p>
	 * When comparing an address with a prefix p and an address without, the first p bits in both are compared, and if equal,
	 * the bit at index p in the non-prefixed address determines the ordering, if 1 it is larger and if 0 it is smaller than the other.
	 * <p>
	 * When comparing an address with prefix length matching the bit count to an address with no prefix, they are considered equal if the bits match.
	 * For instance, 1.2.3.4/32 is equal to 1.2.3.4, and thus the trie does not allow 1.2.3.4/32 in the trie since it is indistinguishable from 1.2.3.4, 
	 * instead 1.2.3.4/32 is converted to 1.2.3.4 when inserted into the trie.
	 * <p>
	 * When comparing 0.0.0.0/0, which has no prefix, to other addresses, the first bit in the other address determines the ordering.
	 * If 1 it is larger and if 0 it is smaller than 0.0.0.0/0.
	 * 
	 * 
	 * @author scfoley
	 *
	 * @param <E>
	 */
	public static class AddressComparator<E extends Address> implements Comparator<E>, Serializable {
		private static final long serialVersionUID = 1L;
		@Override
		public int compare(E o1, E o2) {
			if(o1 == o2) {
				return 0;
			}
			int segmentCount = o1.getSegmentCount();
			int bitsPerSegment = o1.getBitsPerSegment();
			Integer o1Pref = o1.getPrefixLength();
			Integer o2Pref = o2.getPrefixLength();
			int bitsMatchedSoFar = 0;
			int i = 0;
			while(true) {
				AddressSegment segment1 = o1.getSegment(i);
				AddressSegment segment2 = o2.getSegment(i);
				Integer pref1 = getSegmentPrefLen(o1, o1Pref, bitsPerSegment, bitsMatchedSoFar, segment1);
				Integer pref2 = getSegmentPrefLen(o2, o2Pref, bitsPerSegment, bitsMatchedSoFar, segment2);
				int segmentPref2;
				if(pref1 != null) {
					int segmentPref1 = pref1;
					if(pref2 != null && (segmentPref2 = pref2) <= segmentPref1) {
						int matchingBits = getMatchingBits(segment1, segment2, segmentPref2, bitsPerSegment);
						if(matchingBits >= segmentPref2) {
							if(segmentPref2 == segmentPref1) {
								// same prefix block
								return 0;
							}
							// segmentPref2 is shorter prefix, prefix bits match, so depends on bit at index segmentPref2
							return segment1.isOneBit(segmentPref2) ? 1 : -1;
						}
						return segment1.getSegmentValue() - segment2.getSegmentValue();
					} else {
						int matchingBits = getMatchingBits(segment1, segment2, segmentPref1, bitsPerSegment);
						if(matchingBits >= segmentPref1) {
							if(segmentPref1 < bitsPerSegment) {
								return segment2.isOneBit(segmentPref1) ? -1 : 1;
							} else if(++i == segmentCount) {
								return 1; // o1 with prefix length matching bit count is the bigger
							} // else must check the next segment
						} else {
							return segment1.getSegmentValue() - segment2.getSegmentValue();
						}
					}
				} else if(pref2 != null) {
					segmentPref2 = pref2;
					int matchingBits = getMatchingBits(segment1, segment2, segmentPref2, bitsPerSegment);
					if(matchingBits >= pref2) {
						if(segmentPref2 < bitsPerSegment) {
							return segment1.isOneBit(segmentPref2) ? 1 : -1;
						} else if(++i == segmentCount) {
							return -1; // o2 with prefix length matching bit count is the bigger
						} // else must check the next segment
					} else {
						return segment1.getSegmentValue() - segment2.getSegmentValue();
					}
				} else {
					int matchingBits = getMatchingBits(segment1, segment2, bitsPerSegment, bitsPerSegment);
					if(matchingBits < bitsPerSegment) { // no match - the current subnet/address is not here
						return segment1.getSegmentValue() - segment2.getSegmentValue();
					} else if(++i == segmentCount) {
						// same address
						return 0;
					} // else must check the next segment
				}
				bitsMatchedSoFar += bitsPerSegment;
			}
		}
	}
	/**
	 * Returns the next address according to the trie ordering
	 * 
	 * @param <E>
	 * @param addr
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public static <E extends Address> E increment(E addr) {
		if(addr.isMax()) {
			return null;
		}
		if(addr.isIPAddress()) {
			IPAddress ipaddr = addr.toIPAddress();
			if(addr.isPrefixed()) {
				return (E) ipaddr.getUpper().setPrefixLength(ipaddr.getPrefixLength() + 1).toZeroHost();
			}
			return (E) ipaddr.toPrefixBlock(ipaddr.getBitCount() - (ipaddr.getTrailingBitCount(false) + 1));
		}
		
		if(addr.isPrefixed()) {
			return (E) addr.getUpper().setPrefixLength(addr.getPrefixLength() + 1).toPrefixBlock().getLower();
		}
		int trailingBitCount = 0;
		for(int i = addr.getSegmentCount() - 1; i >= 0; i--) {
			AddressSegment seg = addr.getSegment(i);
			if(!seg.isMax()) {
				trailingBitCount += Integer.numberOfTrailingZeros(~seg.getSegmentValue());
				break;
			}
			trailingBitCount += seg.getBitCount();
		}
		return (E) addr.setPrefixLength(addr.getBitCount() - (trailingBitCount + 1)).toPrefixBlock();
	}
	/**
	 * Returns the previous address according to the trie ordering
	 * 
	 * @param <E>
	 * @param addr
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public static <E extends Address> E decrement(E addr) {
		if(addr.isZero()) {
			return null;
		}
		if(addr.isIPAddress()) {
			IPAddress ipaddr = addr.toIPAddress();
			if(addr.isPrefixed()) {
				return (E) ipaddr.getLower().setPrefixLength(ipaddr.getPrefixLength() + 1).toMaxHost();
			}
			return (E) ipaddr.toPrefixBlock(ipaddr.getBitCount() - (ipaddr.getTrailingBitCount(true) + 1));
		}
		
		if(addr.isPrefixed()) {
			return (E) addr.getLower().setPrefixLength(addr.getPrefixLength() + 1).toPrefixBlock().getUpper();
		}
		int trailingBitCount = 0;
		for(int i = addr.getSegmentCount() - 1; i >= 0; i--) {
			AddressSegment seg = addr.getSegment(i);
			if(!seg.isZero()) {
				trailingBitCount += Integer.numberOfTrailingZeros(seg.getSegmentValue());
				break;
			}
			trailingBitCount += seg.getBitCount();
		}
		return (E) addr.setPrefixLength(addr.getBitCount() - (trailingBitCount + 1)).toPrefixBlock();
	}
	public static class TrieComparator<E extends Address> implements Comparator<BinaryTreeNode<E>>, Serializable {
		private static final long serialVersionUID = 1L;
		Comparator<E> comparator;
		TrieComparator(Comparator<E> comparator) {
			this.comparator = comparator;
		}
		@Override
		public int compare(BinaryTreeNode<E> tree1, BinaryTreeNode<E> tree2) {
			E o1 = tree1.getKey();
			E o2 = tree2.getKey();
			return comparator.compare(o1, o2);
		}
	};
	/**
	 * A node for a compact binary prefix trie whose elements are prefix block subnets or addresses,
	 * 
	 * @author scfoley
	 *
	 * @param <E>
	 */
	public static abstract class TrieNode<E extends Address> extends BinaryTreeNode<E> implements AddressTrieOps<E> {
		private static final long serialVersionUID = 1L;
		protected TrieNode(E item) {
			super(item);
		}
		/**
		 * Returns the node for the subnet block containing this node.
		 * 
		 * @return
		 */
		@Override
		public TrieNode<E> getParent() {
			return (TrieNode<E>) super.getParent();
		}
		/**
		 * Returns the sub-node whose address is largest in value
		 * 
		 * @return
		 */
		@Override
		public TrieNode<E> getUpperSubNode() {
			return (TrieNode<E>) super.getUpperSubNode();
		}
		/**
		 * Returns the sub node whose address is smallest in value
		 * 
		 * @return
		 */
		@Override
		public TrieNode<E> getLowerSubNode() {
			return (TrieNode<E>) super.getLowerSubNode();
		}
		private TrieNode<E> findNodeNear(E addr, boolean below, boolean exclusive) {
			addr = checkBlockOrAddress(addr, true);
			return findNodeNearNoCheck(addr, below, exclusive);
		}
		
		private TrieNode<E> findNodeNearNoCheck(E addr, boolean below, boolean exclusive) {
			OpResult<E> result = new OpResult<>(addr, below, exclusive);
			matchBits(result);
			TrieNode<E> backtrack = result.backtrackNode;
			if(backtrack != null) {
				TrieNode<E> parent = backtrack.getParent();
				while(parent != null && 
						(backtrack == (below ? parent.getLowerSubNode() : parent.getUpperSubNode()))) {
					backtrack = parent;
					parent = backtrack.getParent();
				}
				
				if(parent != null) {
					if(parent.isAdded()) {
						result.nearestNode = parent;
					} else {
						result.nearestNode = (below ? parent.previousAddedNode() : parent.nextAddedNode());
					}
				}
			}
			return result.nearestNode;
		}
		@Override
		public TrieNode<E> previousAddedNode() {
			return (TrieNode<E>) super.previousAddedNode();
		}
		@Override
		public TrieNode<E> nextAddedNode() {
			return (TrieNode<E>) super.nextAddedNode();
		}
		@Override
		public TrieNode<E> nextNode() {
			return (TrieNode<E>) super.nextNode();
		}
		@Override
		public TrieNode<E> previousNode() {
			return (TrieNode<E>) super.previousNode();
		}
		@Override
		public TrieNode<E> firstNode() {
			return (TrieNode<E>) super.firstNode();
		}
		@Override
		public TrieNode<E> firstAddedNode() {
			return (TrieNode<E>) super.firstAddedNode();
		}
		@Override
		public TrieNode<E> lastNode() {
			return (TrieNode<E>) super.lastNode();
		}
		@Override
		public TrieNode<E> lastAddedNode() {
			return (TrieNode<E>) super.lastAddedNode();
		}
		@Override
		public TrieNode<E> lowerAddedNode(E addr) {
			return findNodeNear(addr, true, true);
		}
		TrieNode<E> lowerNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, true, true);
		}
		@Override
		public E lower(E addr) {
			return getNodeKey(lowerAddedNode(addr));
		}
		@Override
		public TrieNode<E> floorAddedNode(E addr) {
			return findNodeNear(addr, true, false);
		}
		TrieNode<E> floorNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, true, false);
		}
		@Override
		public E floor(E addr) {
			return getNodeKey(floorAddedNode(addr));
		}
		@Override
		public TrieNode<E> higherAddedNode(E addr) {
			return findNodeNear(addr, false, true);
		}
		TrieNode<E> higherNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, false, true);
		}
		@Override
		public E higher(E addr) {
			return getNodeKey(higherAddedNode(addr));
		}
		@Override
		public TrieNode<E> ceilingAddedNode(E addr) {
			return findNodeNear(addr, false, false);
		}
		TrieNode<E> ceilingNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, false, false);
		}
		@Override
		public E ceiling(E addr) {
			return getNodeKey(ceilingAddedNode(addr));
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> nodeIterator(boolean forward) {
			return (Iterator<? extends TrieNode<E>>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> allNodeIterator(boolean forward) {
			return (Iterator<? extends TrieNode<E>>) super.allNodeIterator(forward);
		}
		/**
		 * Iterates the added nodes, ordered by keys from largest prefix blocks to smallest and then to individual addresses,
		 *  in the sub-trie with this node as the root.
		 * <p>
		 * This iterator supports the {@link java.util.Iterator#remove()} operation.
		 * 
		 * @param lowerSubNodeFirst if true, for blocks of equal size the lower is first, otherwise the reverse order
		 * @return
		 */
		@SuppressWarnings("unchecked")
		public Iterator<? extends TrieNode<E>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<? extends TrieNode<E>>) super.blockSizeNodeIterator(lowerSubNodeFirst, true);
		}
		/**
		 * Iterates all the nodes, ordered by keys from largest prefix blocks to smallest and then to individual addresses,
		 *  in the sub-trie with this node as the root.
		 * <p>
		 * This iterator supports the {@link java.util.Iterator#remove()} operation.
		 * 
		 * @param lowerSubNodeFirst if true, for blocks of equal size the lower is first, otherwise the reverse order
		 * @return
		 */
		@SuppressWarnings("unchecked")
		public Iterator<? extends TrieNode<E>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<? extends TrieNode<E>>) super.blockSizeNodeIterator(lowerSubNodeFirst, false);
		}
		/**
		 * Iterates all nodes, ordered by keys from largest prefix blocks to smallest and then to individual addresses,
		 *  in the sub-trie with this node as the root.
		 * 
		 * @return
		 */
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<? extends TrieNode<E>, E, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<? extends TrieNode<E>, E, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends TrieNode<E>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<? extends TrieNode<E>, E, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<? extends TrieNode<E>, E, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends TrieNode<E>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends TrieNode<E>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@Override
		public Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward) {
			return nodeSpliterator(forward, true);
		}
		@Override
		public Spliterator<? extends TrieNode<E>> allNodeSpliterator(boolean forward) {
			return nodeSpliterator(forward, false);
		}
		@SuppressWarnings("unchecked")
		Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward, boolean addedNodesOnly) {
			Comparator<BinaryTreeNode<E>> comp = forward ? nodeComparator() : reverseNodeComparator();
			Spliterator<? extends BinaryTreeNode<E>> spliterator = new NodeSpliterator<E>(
					forward,
					comp,
					this,
					forward ? firstNode() : lastNode(),
					getParent(),
					size(),
					changeTracker,
					addedNodesOnly /* added only */);
			return (Spliterator<? extends TrieNode<E>>) spliterator;
		}
		@Override
		public Spliterator<E> spliterator() {
			return new KeySpliterator<E>(nodeSpliterator(true, true), comparator());
		}
		@Override
		public Spliterator<E> descendingSpliterator() {
			return new KeySpliterator<E>(nodeSpliterator(false, true), reverseComparator());
		}
		@Override
		public boolean contains(E addr) {
			return doLookup(addr).exists;
		}
		@Override
		public boolean remove(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.INSERTED_DELETE);
			matchBits(result);
			return result.exists;
		}
		@Override
		public TrieNode<E> getNode(E addr) {
			return doLookup(addr).existingNode;
		}
		@Override
		public TrieNode<E> removeElementsContainedBy(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.SUBTREE_DELETE);
			matchBits(result);
			return result.deleted;
		}
		@Override
		public TrieNode<E> elementsContainedBy(E addr) {
			return doLookup(addr).containedBy;
		}
		// only added nodes are added to the linked list
		@Override
		public TrieNode<E> elementsContaining(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.ALL_CONTAINING);
			matchBits(result);
			return result.getContaining();
		}
		@Override
		public E longestPrefixMatch(E addr) {
			TrieNode<E> node = longestPrefixMatchNode(addr);
			return node == null ? null : node.getKey();
		}
		@Override
		public TrieNode<E> longestPrefixMatchNode(E addr) {
			return doLookup(addr).smallestContaining;
		}
		@Override
		public E shortestPrefixMatch(E addr) {
			TrieNode<E> node = shortestPrefixMatchNode(addr);
			return node == null ? null : node.getKey();
		}
		@Override
		public TrieNode<E> shortestPrefixMatchNode(E addr) {
			return doElementContains(addr);
		}
		@Override
		public boolean elementContains(E addr) {
			return doElementContains(addr) != null;
		}
		private TrieNode<E> doElementContains(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.CONTAINING);
			matchBits(result);
			return result.largestContaining;
		}
		protected OpResult<E> doLookup(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.LOOKUP);
			matchBits(result);
			return result;
		}
		private void removeSubtree(OpResult<E> result) {
			result.deleted = this;
			clear();
		}
		protected void removeOp(OpResult<E> result) {
			result.deleted = this;
			remove();
		}
		void matchBits(OpResult<E> result) {
			matchBitsFromIndex(0, result);
		}
		// traverses the tree, matching bits with prefix block nodes, until we can match no longer,
		// at which point it completes the operation, whatever that operation is
		void matchBitsFromIndex(int bitIndex, OpResult<E> result) {
			TrieNode<E> matchNode = this; 
			E newAddr = result.addr;
			Operation op = result.op;
			TrieKeyData newKeyData = getTrieKeyCache(newAddr);
			boolean simpleMatch = newKeyData != null && op != Operation.INSERT && op != Operation.NEAR && op != Operation.REMAP;
			E existingAddr = getKey();
			while(true) {
				result.node = matchNode;
				boolean continueToNext = matchAddressBits(simpleMatch, newAddr, existingAddr, bitIndex, result, newKeyData);
				if(continueToNext) {
					int bits = existingAddr.getPrefixLength();
					// matched all node bits up the given count, so move into sub-nodes
					matchNode = matchNode.matchSubNode(bits, result);
					if(matchNode == null) {
						// reached the end of the line
						break;
					}
					// Matched a sub-node.  
					// The sub-node was chosen according to the next bit. 
					// That bit is therefore now a match,
					// so increment the matched bits by 1, and keep going.
					bitIndex = bits + 1;
					existingAddr = matchNode.getKey();
				} else {
					break;
				}
			}
			result.node = null;
		}
		static interface FollowingBits {
			void setFollowingBits(long bits);
		}
		static interface KeyCompareResult {
			void bitsMatch();
			void bitsDoNotMatch(int matchedBits);
			// When this is called, if the returned value is non-null, 
			// then setFollowingBits must be called on the returned instance with either zero or a non-zero value
			// to indicate if the next bit following the prefix length of the node's address is 0 or 1 in the supplied address.
			FollowingBits bitsMatchPartially();
		}
		
		// Providing TrieKeyData for trie keys makes lookup faster.
		// However, it is optional, tries will work without it.
		protected static class TrieKeyData {
			// currently trie optimizations exist for 32 or 128 bits,
			// so providing TrieKeyData for other bit sizes provides no benefit at this time
			public Integer prefixLength;
			// 32 bit key caches must override these 4 methods:
			public boolean is32Bits() {
				return false;
			}
			public int getUint32Val() {
				return 0;
			}
			public int getMask32Val() {
				return 0;
			}
			public int getNextBitMask32Val() {
				return 0;
			}
			// 128 bit key caches must override these 6 methods:
			public boolean is128Bits() {
				return false;
			}
			public long getUint64LowVal() {
				return 0;
			}
			public long getUint64HighVal() {
				return 0;
			}
			public long getMask64HighVal() {
				return 0;
			}
			public long getMask64LowVal() {
				return 0;
			}
			public long getNextBitMask64Val() {
				return 0;
			}
		}
		protected TrieKeyData getTrieKeyCache(E addr) {
			return null;
		}
	
		boolean matchAddressBits(boolean simpleSearch, E newAddr, E existingAddr, int bitIndex, TrieNode.KeyCompareResult handleMatch, TrieKeyData newTrieCache)  {
			
			// this is the optimized path for the case where we do not need to know how many of the initial bits match in a mismatch
			// when we have a match, all bits match
			// when we have a mismatch, we do not need to know how many of the initial bits match
			// So there is no callback for a mismatch here.
			// The non-optimized code has 8 cases, 2 for each fully nested if or else block
			// I have added comments to see how this code matches up to those 8 cases
			if(simpleSearch) {
				TrieKeyData existingTrieCache = getTrieKeyCache(existingAddr);
				if(existingTrieCache != null) {
					if(existingTrieCache.is32Bits()) {
						if(newTrieCache.is32Bits()) {
							int existingVal = existingTrieCache.getUint32Val();
							Integer existingPrefLen = existingTrieCache.prefixLength;
							if(existingPrefLen == null) {
								int newVal = newTrieCache.getUint32Val();
								if(newVal == existingVal) {
									handleMatch.bitsMatch();
								} else {
									Integer newPrefLen = newTrieCache.prefixLength;
									if(newPrefLen != null) {
										int newMask = newTrieCache.getMask32Val();
										if((newVal & newMask) == (existingVal & newMask)) {
											// rest of case 1 and rest of case 5
											handleMatch.bitsMatch();
										}
									}
								}
							} else {
								int existingPrefLenBits = existingPrefLen;
								Integer newPrefLen = newTrieCache.prefixLength;
								if(existingPrefLenBits == 0) {
									if(newPrefLen != null && newPrefLen == 0) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											followingBits.setFollowingBits(newTrieCache.getUint32Val() & 0x80000000);
											return true;
										}
									}
								} else if(existingPrefLenBits == bitIndex) { // optimized case where no matching is required because bit index had advanced by just one
									if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											int nextBitMask = existingTrieCache.getNextBitMask32Val();
											followingBits.setFollowingBits(newTrieCache.getUint32Val() & nextBitMask);
											return true;
										}
									}
								} else {
									int existingMask = existingTrieCache.getMask32Val();
									int newVal = newTrieCache.getUint32Val();
									if((newVal & existingMask) == (existingVal & existingMask)) {
										if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
											handleMatch.bitsMatch();
										} else {
											FollowingBits followingBits = handleMatch.bitsMatchPartially();
											if(followingBits != null) {
												int nextBitMask = existingTrieCache.getNextBitMask32Val();
												followingBits.setFollowingBits(newVal & nextBitMask);
												return true;
											}
										}
									} else if(newPrefLen != null) {
										int newPrefLenBits = newPrefLen;
										if(existingPrefLenBits > newPrefLenBits) {
											int newMask = newTrieCache.getMask32Val();
											if((newTrieCache.getUint32Val() & newMask) == (existingVal & newMask)) {
												// rest of case 1 and rest of case 5
												handleMatch.bitsMatch();
											}
										}
									} // else case 4, 7
								}
							}
							return false;
						}
					} else if(existingTrieCache.is128Bits()) {
						if(newTrieCache != null && newTrieCache.is128Bits()) {
							Integer existingPrefLen = existingTrieCache.prefixLength;
							if(existingPrefLen == null) {
								long newLowVal = newTrieCache.getUint64LowVal();
								long existingLowVal = existingTrieCache.getUint64LowVal();
								if(newLowVal == existingLowVal &&
									newTrieCache.getUint64HighVal() == existingTrieCache.getUint64HighVal()) {
									handleMatch.bitsMatch();
								} else {
									Integer newPrefLen = newTrieCache.prefixLength;
									if(newPrefLen != null) {
										long newMaskLow = newTrieCache.getMask64LowVal();
										if((newLowVal & newMaskLow) == (existingLowVal & newMaskLow)) {
											long newMaskHigh = newTrieCache.getMask64HighVal();
											if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
												// rest of case 1 and rest of case 5
												handleMatch.bitsMatch();
											}
										}
									} // else case 4, 7
								}
							} else {
								int existingPrefLenBits = existingPrefLen;
								Integer newPrefLen = newTrieCache.prefixLength;
								if(existingPrefLenBits == 0) {
									if(newPrefLen != null && newPrefLen == 0) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											followingBits.setFollowingBits(newTrieCache.getUint64HighVal() & 0x8000000000000000L);
											return true;
										}
									}
								} else if(existingPrefLenBits == bitIndex) { // optimized case where no matching is required because bit index had advanced by just one
									if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											long nextBitMask = existingTrieCache.getNextBitMask64Val();
											if(bitIndex > 63) /* IPv6BitCount - 65 */ {
												followingBits.setFollowingBits(newTrieCache.getUint64LowVal() & nextBitMask);
											} else {
												followingBits.setFollowingBits(newTrieCache.getUint64HighVal() & nextBitMask);
											}
											return true;
										}
									}
								} else if(existingPrefLenBits > 64) {
									long existingMaskLow = existingTrieCache.getMask64LowVal();
									long newLowVal = newTrieCache.getUint64LowVal();
									if((newLowVal & existingMaskLow) == (existingTrieCache.getUint64LowVal() & existingMaskLow)) {
										long existingMaskHigh = existingTrieCache.getMask64HighVal();
										if((newTrieCache.getUint64HighVal() & existingMaskHigh) == (existingTrieCache.getUint64HighVal() & existingMaskHigh)) {
											if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
												handleMatch.bitsMatch();
											} else {
												FollowingBits followingBits = handleMatch.bitsMatchPartially();
												if(followingBits != null) {
													long nextBitMask = existingTrieCache.getNextBitMask64Val();
													followingBits.setFollowingBits(newLowVal & nextBitMask);
													return true;
												}
											}
										} else if(newPrefLen != null && existingPrefLenBits > newPrefLen) {
											long newMaskLow = newTrieCache.getMask64LowVal();
											if((newTrieCache.getUint64LowVal() & newMaskLow) == (existingTrieCache.getUint64LowVal() & newMaskLow)) {
												long newMaskHigh = newTrieCache.getMask64HighVal();
												if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
													// rest of case 1 and rest of case 5
													handleMatch.bitsMatch();
												}
											}
										} // else case 4, 7
									} else if(newPrefLen != null && existingPrefLenBits > newPrefLen) {
										long newMaskLow = newTrieCache.getMask64LowVal();
										if((newTrieCache.getUint64LowVal()&newMaskLow) == (existingTrieCache.getUint64LowVal()&newMaskLow)) {
											long newMaskHigh = newTrieCache.getMask64HighVal();
											if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
												// rest of case 1 and rest of case 5
												handleMatch.bitsMatch();
											}
										}
									} // else case 4, 7
								} else if(existingPrefLenBits == 64) {
									if(newTrieCache.getUint64HighVal() == existingTrieCache.getUint64HighVal()) {
										if(newPrefLen != null && newPrefLen <= 64) {
											handleMatch.bitsMatch();
										} else {
											FollowingBits followingBits = handleMatch.bitsMatchPartially();
											if(followingBits != null) {
												followingBits.setFollowingBits(newTrieCache.getUint64LowVal() & 0x8000000000000000L);
												return true;
											}
										}
									} else {
										if(newPrefLen != null && newPrefLen < 64) {
											long newMaskHigh = newTrieCache.getMask64HighVal();
											if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
												// rest of case 1 and rest of case 5
												handleMatch.bitsMatch();
											}
										}
									} // else case 4, 7
								} else { // existingPrefLen < 64
									long existingMaskHigh = existingTrieCache.getMask64HighVal();
									long newHighVal = newTrieCache.getUint64HighVal();
									if((newHighVal & existingMaskHigh) == (existingTrieCache.getUint64HighVal() & existingMaskHigh)) {
										if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
											handleMatch.bitsMatch();
										} else {
											FollowingBits followingBits = handleMatch.bitsMatchPartially();
											if(followingBits != null) {
												long nextBitMask = existingTrieCache.getNextBitMask64Val();
												followingBits.setFollowingBits(newHighVal & nextBitMask);
												return true;
											}
										}
									} else if(newPrefLen != null && existingPrefLenBits > newPrefLen) {
										long newMaskHigh = newTrieCache.getMask64HighVal();
										if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
											// rest of case 1 and rest of case 5
											handleMatch.bitsMatch();
										}
									} // else case 4, 7
								}
							}
							return false;
						}
					}
				}
			}
			int bitsPerSegment = existingAddr.getBitsPerSegment();
			int bytesPerSegment = existingAddr.getBytesPerSegment();
			int segmentIndex = ParsedAddressGrouping.getHostSegmentIndex(bitIndex, bytesPerSegment, bitsPerSegment);
			int segmentCount = existingAddr.getSegmentCount();
			if(newAddr.getSegmentCount() != segmentCount || bitsPerSegment != newAddr.getBitsPerSegment()) {
				throw new IllegalArgumentException(getMessage("ipaddress.error.mismatched.bit.size"));
			}
			Integer existingPref = existingAddr.getPrefixLength();
			Integer newPrefLen = newAddr.getPrefixLength();
			// this block handles cases like where we matched matching ::ffff:102:304 to ::ffff:102:304/127,
			// and we found a subnode to match, but we know the final bit is a match due to the subnode being lower or upper,
			// so there is actually not more bits to match
			if(segmentIndex >= segmentCount) {
				// all the bits match
				handleMatch.bitsMatch();
				return false;
			}
			int bitsMatchedSoFar = ParsedAddressGrouping.getTotalBits(segmentIndex, bytesPerSegment, bitsPerSegment);
			while(true) {
				AddressSegment existingSegment = existingAddr.getSegment(segmentIndex);
				AddressSegment newSegment = newAddr.getSegment(segmentIndex);
				Integer segmentPref = getSegmentPrefLen(existingAddr, existingPref, bitsPerSegment, bitsMatchedSoFar, existingSegment);
				Integer newSegmentPref = getSegmentPrefLen(newAddr, newPrefLen, bitsPerSegment, bitsMatchedSoFar, newSegment);
				int newPrefixLen;
				if(segmentPref != null) {	
					int segmentPrefLen = segmentPref;
					if(newSegmentPref != null && (newPrefixLen = newSegmentPref) <= segmentPrefLen) {
						int matchingBits = getMatchingBits(existingSegment, newSegment, newPrefixLen, bitsPerSegment);
						if(matchingBits >= newPrefixLen) { 
							handleMatch.bitsMatch();
						} else {
							// no match - the bits don't match
							// matchingBits < newPrefLen < segmentPrefLen
							handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
						}
					} else {
						int matchingBits = getMatchingBits(existingSegment, newSegment, segmentPrefLen, bitsPerSegment);
						if(matchingBits >= segmentPrefLen) { // match - the current subnet/address is a match so far, and we must go further to check smaller subnets
							FollowingBits followingBits = handleMatch.bitsMatchPartially();
							if(followingBits != null) {
								// calculate the followingBitsFlag
								// check if at end of segment, advance to next if so
								if(segmentPrefLen == bitsPerSegment) {
									segmentIndex++;
									if(segmentIndex == segmentCount) {
										return true;
									}
									newSegment = newAddr.getSegment(segmentIndex);
									segmentPrefLen = 0;
								}
								// check the bit for followingBitsFlag
								if(newSegment.isOneBit(segmentPrefLen)) {
									followingBits.setFollowingBits(0x8000000000000000L);
								}
								return true;
							}
							return false;
						}
						// matchingBits < segmentPrefLen - no match - the bits in current prefix do not match the prefix of the existing address
						handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
					}
					return false;
				} else if(newSegmentPref != null) {
					newPrefixLen = newSegmentPref;
					int matchingBits = getMatchingBits(existingSegment, newSegment, newPrefixLen, bitsPerSegment);
					if(matchingBits >= newPrefixLen) { // the current bits match the current prefix, but the existing has no prefix
						handleMatch.bitsMatch();
					} else {
						// no match - the current subnet does not match the existing address
						handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
					}
					return false;
				} else {
					int matchingBits = getMatchingBits(existingSegment, newSegment, bitsPerSegment, bitsPerSegment);
					if(matchingBits < bitsPerSegment) { // no match - the current subnet/address is not here
						handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
						return false;
					} else if(++segmentIndex == segmentCount) { // match - the current subnet/address is a match
						// note that "added" is already true here, we can only be here if explicitly inserted already since it is a non-prefixed full address
						handleMatch.bitsMatch();
						return false;
					}
					bitsMatchedSoFar += bitsPerSegment;
				}
			}
		}
		private void handleContained(OpResult<E> result, int newPref) {
			Operation op = result.op;
			if(op == Operation.INSERT) {
				// if we have 1.2.3.4 and 1.2.3.4/32, and we are looking at the last segment,
				// then there are no more bits to look at, and this makes the former a sub-node of the latter.
				// In most cases, however, there are more bits in existingAddr, the latter, to look at.
				replace(result, newPref);
			} else  if(op == Operation.SUBTREE_DELETE) {
				removeSubtree(result);
			} else if(op == Operation.NEAR) {
				findNearest(result, newPref);
			} else if(op == Operation.REMAP) {
				remapNonExistingReplace(result, newPref);
			} 
		}
		private boolean handleContains(OpResult<E> result) {
			if(result.op == Operation.CONTAINING) {
				result.largestContaining = this;
				return true;
			} else if(result.op == Operation.ALL_CONTAINING) {
				result.addContaining(this);
				return true;
			}
			result.smallestContaining = this;
			return false;
		}
		private void handleSplitNode(OpResult<E> result, int totalMatchingBits) {
			E newAddr = result.addr;
			Operation op = result.op;	
			if(op == Operation.INSERT) {
				split(result, totalMatchingBits, createNew(newAddr));
			} else if(op == Operation.NEAR) {
				findNearest(result, totalMatchingBits);
			} else if(op == Operation.REMAP) {
				remapNonExistingSplit(result, totalMatchingBits);
			} 
		}
		// a node exists for the given key but the node is not added,
		// so not a match, but a split not required
		private void handleNodeMatch(OpResult<E> result) {
			Operation op = result.op;
			if(op == Operation.LOOKUP) {
				result.existingNode = this;
			} else if(op == Operation.INSERT) {
				existingAdded(result);
			} else if(op == Operation.SUBTREE_DELETE) {
				removeSubtree(result);
			} else if(op == Operation.NEAR) {
				findNearestFromMatch(result);
			} else if(op == Operation.REMAP) {
				remapNonAdded(result);
			}
		}
		private void handleMatch(OpResult<E> result) {
			result.exists = true;
			if(!handleContains(result)) {
				Operation op = result.op;
				if(op == Operation.LOOKUP) {
					matched(result);
				} else if(op == Operation.INSERT) {
					matchedInserted(result);
				} else if(op == Operation.INSERTED_DELETE) {
					removeOp(result);
				} else if(op == Operation.SUBTREE_DELETE) {
					removeSubtree(result);
				} else if(op == Operation.NEAR) {
					if(result.nearExclusive) {
						findNearestFromMatch(result);
					} else {
						matched(result);
					}
				} else if(op == Operation.REMAP) {
					remapMatch(result);
				}
			}
		}
		private void remapNonExistingReplace(OpResult<E> result, int totalMatchingBits) {
			if(remap(result, false)) {
				replace(result, totalMatchingBits);
			}
		}
		private void remapNonExistingSplit(OpResult<E> result, int totalMatchingBits) {
			if(remap(result, false)) {
				split(result, totalMatchingBits, createNew(result.addr));
			}
		}
		private TrieNode<E> remapNonExisting(OpResult<E> result) {
			if(remap(result, false)) {
				return createNew(result.addr);
			}
			return null;
		}
		private void remapNonAdded(OpResult<E> result) {
			if(remap(result, false)) {
				existingAdded(result);
			}
		}
		private void remapMatch(OpResult<E> result) {
			result.existingNode = this;
			if(remap(result, true)) {
				matchedInserted(result);
			}
		}
		/**
		 * Remaps the value for a node to a new value.  
		 * This operation, which works on mapped values, is for maps, so this base method here does nothing,
		 * but is overridden in map subclasses.
		 * 
		 * @param result
		 * @param match
		 * @return true if a new node needs to be created (match is null) or added (match is non-null)
		 */
		boolean remap(OpResult<E> result, boolean isMatch) {
			return false;
		}
		// this node matched when doing a lookup
		private void matched(OpResult<E> result) {
			result.existingNode = this;
			result.nearestNode = this;
		}
		// ** overridden by map trie **
		// similar to matched, but when inserting we see it already there.
		// this added node had already been added before
		void matchedInserted(OpResult<E> result) {
			result.existingNode = this;
			result.addedAlready = this;
		}
		// this node previously existed but was not added til now
		private void existingAdded(OpResult<E> result) {
			result.existingNode = this;
			result.added = this;
			added(result);
		}
		// this node is newly inserted and added
		private void inserted(OpResult<E> result) {
			result.inserted = this;
			added(result);
		}
		// ** overridden by map trie **
		void added(OpResult<E> result) {
			setNodeAdded(true);
			adjustCount(1);
			changeTracker.changed();
		}
		/**
		 * The current node and the new node both become sub-nodes of a new block node taking the position of the current node.
		 * 
		 * @param totalMatchingBits
		 * @param newAddr
		 */
		@SuppressWarnings("unchecked")
		private void split(OpResult<E> result, int totalMatchingBits, TrieNode<E> newSubNode) {
			E key = getKey();
			E newBlock;
			if(key.isIPAddress()) {
				newBlock = (E) key.toIPAddress().toPrefixBlock(totalMatchingBits);
			} else {
				newBlock = (E) key.setPrefixLength(totalMatchingBits).toPrefixBlock();
			}
			replaceToSub(newBlock, totalMatchingBits, newSubNode);
			newSubNode.inserted(result);
		}
		/**
		 * The current node is replaced by the new node and becomes a sub-node of the new node.
		 * 
		 * @param totalMatchingBits
		 * @param newAddr
		 */
		private void replace(OpResult<E> result, int totalMatchingBits) {
			result.containedBy = this;
			TrieNode<E> newNode = replaceToSub(result.addr, totalMatchingBits, null);
			newNode.inserted(result);
		}
		/**
		 * The current node is replaced by a new block of the given address.
		 * The current node and given node become sub-nodes.
		 * 
		 * @param newAssignedAddr
		 * @param result
		 * @param totalMatchingBits
		 * @param newSubNode
		 * @return
		 */
		private TrieNode<E> replaceToSub(E newAssignedAddr, int totalMatchingBits, TrieNode<E> newSubNode) {
			TrieNode<E> newNode = createNew(newAssignedAddr);
			newNode.size = size;
			TrieNode<E> parent = getParent();
			if(parent.getUpperSubNode() == this) {
				parent.setUpper(newNode);
			} else if(parent.getLowerSubNode() == this) {
				parent.setLower(newNode);
			}
			E existingAddr = getKey();
			if(totalMatchingBits < existingAddr.getBitCount() && 
					existingAddr.isOneBit(totalMatchingBits)) {
				if(newSubNode != null) {
					newNode.setLower(newSubNode);
				}
				newNode.setUpper(this);
			} else {
				newNode.setLower(this);
				if(newSubNode != null) {
					newNode.setUpper(newSubNode);
				}
			}
			return newNode;
		}
		// only called when lower/higher and not floor/ceiling since for a match ends things for the latter
		private void findNearestFromMatch(OpResult<E> result) {
			if(result.nearestFloor) {
				// looking for greatest element < queried address
				// since we have matched the address, we must go lower again,
				// and if we cannot, we must backtrack
				TrieNode<E> lower = getLowerSubNode();
				if(lower == null) {
					// no nearest node yet
					result.backtrackNode = this;
				} else {
					TrieNode<E> last;
					do {
						last = lower;
						lower = lower.getUpperSubNode();
					} while(lower != null);
					result.nearestNode = last;
				}
			} else {
				// looking for smallest element > queried address
				TrieNode<E> upper = getUpperSubNode();
				if(upper == null) {
					// no nearest node yet
					result.backtrackNode = this;
				} else {
					TrieNode<E> last;
					do {
						last = upper;
						upper = upper.getLowerSubNode();
					} while(upper != null);
					result.nearestNode = last;
				}
			}
		}
		private void findNearest(OpResult<E> result, int differingBitIndex) {
			E thisAddr = getKey();
			if(differingBitIndex < thisAddr.getBitCount() && thisAddr.isOneBit(differingBitIndex)) {
				// this element and all below are > than the query address
				if(result.nearestFloor) {
					// looking for greatest element < or <= queried address, so no need to go further
					// need to backtrack and find the last right turn to find node < than the query address again
					result.backtrackNode = this;
				} else {
					// looking for smallest element > or >= queried address
					TrieNode<E> lower = this, last;
					do {
						last = lower;
						lower = lower.getLowerSubNode();
					} while(lower != null);
					result.nearestNode = last;
				}
			} else {
				// this element and all below are < than the query address
				if(result.nearestFloor) {
					// looking for greatest element < or <= queried address
					TrieNode<E> upper = this, last;
					do {
						last = upper;
						upper = upper.getUpperSubNode();
					} while(upper != null);
					result.nearestNode = last;
				} else {
					// looking for smallest element > or >= queried address, so no need to go further
					// need to backtrack and find the last left turn to find node > than the query address again
					result.backtrackNode = this;
				}
			}
		}
		/**
		 * Initializes the tree with the given node
		 * 
		 * @param node
		 */
		void init(TrieNode<E> node) {
			E newAddr = node.getKey();
			if(newAddr.getBitCount() > 0 && newAddr.isOneBit(0)) {
				setUpper(node);
			} else {
				setLower(node);
			}
			size = (isAdded() ? 1 : 0) + node.size;
		}
		
		private TrieNode<E> matchSubNode(int bitIndex, OpResult<E> result) {
			E newAddr = result.addr;
			if(!FREEZE_ROOT && isEmpty()) {
				if(result.op == Operation.REMAP) {
					remapNonAdded(result);
				} else if(result.op == Operation.INSERT) {
					setKey(newAddr);
					existingAdded(result);
				}
			} else if(bitIndex >= newAddr.getBitCount()) {
				// we matched all bits, yet somehow we are still going
				// this can only happen when matching 1.2.3.4/32 to 1.2.3.4
				// which should never happen and so we do nothing
			} else if(result.followingBits != 0L) {
				result.setFollowingBits(0);
				TrieNode<E> upper = getUpperSubNode();
				if(upper == null) {
					// no match
					Operation op = result.op;
					if(op == Operation.INSERT) {
						upper = createNew(newAddr);
						setUpper(upper);
						upper.inserted(result);
					} else if(op == Operation.NEAR) {
						if(result.nearestFloor) {
							// With only one sub-node at most, normally that would mean this node must be added.
							// But there is one exception, when we are the non-added root node.
							// So must check for added here.
							if(isAdded()) {
								result.nearestNode = this;
							} else {
								// check if our lower sub-node is there and added.  It is underneath addr too.
								// find the highest node in that direction.
								TrieNode<E> lower = getLowerSubNode();
								if(lower != null) {
									TrieNode<E> res = lower;
									TrieNode<E> next = res.getUpperSubNode();
									while(next != null) {
										res = next;
										next = res.getUpperSubNode();
									}
									result.nearestNode = res;
								}
							}
						} else {
							result.backtrackNode = this;
						}
					} else if(op == Operation.REMAP) {
						upper = remapNonExisting(result);
						if(upper != null) {
							setUpper(upper);
							upper.inserted(result);
						}
					}
				} else {
					return upper;
				}
			} else {
				TrieNode<E> lower = getLowerSubNode();
				if(lower == null) {
					// no match
					Operation op = result.op;
					if(op == Operation.INSERT) {
						lower = createNew(newAddr);
						setLower(lower);
						lower.inserted(result);
					} else if(op == Operation.NEAR) {
						if(result.nearestFloor) {
							result.backtrackNode = this;
						} else {
							// With only one sub-node at most, normally that would mean this node must be added.
							// But there is one exception, when we are the non-added root node.
							// So must check for added here.
							if(isAdded()) {
								result.nearestNode = this;
							} else {
								// check if our upper sub-node is there and added.  It is above addr too.
								// find the highest node in that direction.
								TrieNode<E> upper = getUpperSubNode();
								if(upper != null) {
									TrieNode<E> res = upper;
									TrieNode<E> next = res.getLowerSubNode();
									while(next != null) {
										res = next;
										next = res.getLowerSubNode();
									}
									result.nearestNode = res;
								}
							}
						}
					} else if(op == Operation.REMAP) {
						lower = remapNonExisting(result);
						if(lower != null) {
							setLower(lower);
							lower.inserted(result);
						}
					} 
				} else {
					return lower;
				}
			}
			return null;
		}
		private TrieNode<E> createNew(E newAddr) {
			TrieNode<E> newNode = createNewImpl(newAddr);
			newNode.changeTracker = changeTracker;
			return newNode;
		}
		protected abstract TrieNode<E> createNewImpl(E newAddr);
		
		protected abstract AddressTrie<E> createNewTree();
		/**
		 * Creates a new sub-trie, copying the nodes starting with this node as root. 
		 * The nodes are copies of the nodes in this sub-trie, but their keys and values are not copies.
		 */
		public AddressTrie<E> asNewTrie() {
			AddressTrie<E> newTrie = createNewTree();
			newTrie.addTrie(this);
			return newTrie;
		}
		
		@Override
		public TrieNode<E> cloneTree() {
			return (TrieNode<E>) super.cloneTree();
		}
		@Override
		public TrieNode<E> clone() {
			return (TrieNode<E>) super.clone();
		}
		@Override
		TrieNode<E> cloneTreeBounds(Bounds<E> bounds) {
			return (TrieNode<E>) super.cloneTreeBounds(bounds);
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof TrieNode && super.equals(o);
		}
	}
	static final TrieComparator<?> comparator = new TrieComparator<>(new AddressComparator<>());
	static final TrieComparator<?> reverseComparator = new TrieComparator<>(Collections.reverseOrder(new AddressComparator<>()));
	AddressTrieSet<E> set;
	AddressBounds<E> bounds;
	private TrieNode<E> subRoot; // if bounded, the root of the subtrie, which can change
	private Change subRootChange; // if trie was modified since last check for subroot, must check for new subroot
	protected AddressTrie(TrieNode<E> root) {
		super(root);
		root.changeTracker = new ChangeTracker();
	}
	protected AddressTrie(TrieNode<E> root, AddressBounds<E> bounds) {
		super(root);
		if(root.changeTracker == null) {
			root.changeTracker = new ChangeTracker();
		}
		this.bounds = bounds;
	}
	private static Integer getSegmentPrefLen(
			AddressSegmentSeries addr,
			Integer prefLen,
			int bitsPerSegment,
			int bitsMatchedSoFar,
			AddressSegment segment) {
		if(segment instanceof IPAddressSegment) {
			return ((IPAddressSegment) segment).getSegmentPrefixLength();
		} else if(prefLen != null) {
			Integer result = prefLen - bitsMatchedSoFar;
			if(result <= bitsPerSegment) {
				if(result < 0) {
					result = 0;
				}
				return result;
			}
		}
		return null;
	}
	private static int getMatchingBits(AddressSegment segment1, AddressSegment segment2, int maxBits, int bitsPerSegment) {
		if(maxBits == 0) {
			return 0;
		}
		int val1 = segment1.getSegmentValue();
		int val2 = segment2.getSegmentValue();
		int xor = val1 ^ val2;
		switch(bitsPerSegment) {
		case IPv4Address.BITS_PER_SEGMENT:
			return numberOfLeadingZerosByte(xor);
		case IPv6Address.BITS_PER_SEGMENT:
			return numberOfLeadingZerosShort(xor);
		default:
			return Integer.numberOfLeadingZeros(xor) + bitsPerSegment - Integer.SIZE;
		}
	}
	private static int numberOfLeadingZerosShort(int i) {
		int half = i >>> 8;
		if(half == 0) {
			return 8 + numberOfLeadingZerosByte(i & 0xff);
		}
		return numberOfLeadingZerosByte(half);
	}
	private static int numberOfLeadingZerosByte(int i) {
		if (i <= 0) {
			if(i == 0){
				return 8;
			}
			return 0;
		}
		int n = 1;
		if (i >>> 4 == 0) { n += 4; i <<= 4; }
		if (i >>> 6 == 0) { n += 2; i <<= 2; }
		n -= i >>> 7;
		return n;
	}
	@Override
	public boolean isEmpty() {
		if(bounds == null) {
			return super.isEmpty();
		}
		// we avoid calculating size for bounded tries
		return firstAddedNode() == null;
    }
	/**
	 * Returns the number of nodes in the trie, which is more than the number of added elements.
	 * 
	 * @return
	 */
	@Override
	public int nodeSize() {
		if(bounds == null) {
			return super.nodeSize();
		}
		int totalCount = 0;
		Iterator<? extends TrieNode<E>> iterator = allNodeIterator(true);
		while(iterator.hasNext()) {
			totalCount++;
			iterator.next();
		}
		return totalCount;
	}
	@Override
	public int size() {
		if(bounds == null) {
			return super.size();
		}
		int totalCount = 0;
		Iterator<? extends TrieNode<E>> iterator = nodeIterator(true);
		while(iterator.hasNext()) {
			TrieNode<E> node = iterator.next();
			if(node.isAdded() && bounds.isInBounds(node.getKey())) {
				totalCount++;
			}
		}
		return totalCount;
	}
	
	@Override
	public boolean add(E addr) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		TrieNode<E> root = absoluteRoot();
		OpResult<E> result = new OpResult<>(addr, Operation.INSERT);
		root.matchBits(result);
		return !result.exists;
	}
	static void throwOutOfBounds() {
		throw new IllegalArgumentException(getMessage("ipaddress.error.address.out.of.range"));
	}
	protected void adjustRoot(E addr) {}
	@Override
	public TrieNode<E> addNode(E addr) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		TrieNode<E> root = absoluteRoot();
		OpResult<E> result = new OpResult<>(addr, Operation.INSERT);
		root.matchBits(result);
		TrieNode<E> node = result.existingNode;
		if(node == null) {
			node = result.inserted;
		}
		return node;
	}
	static abstract class SubNodesMapping<E extends Address, N extends SubNodesMapping<E, N>> {
		// subNodes is the list of direct and indirect added sub-nodes in the original trie
		ArrayList<AssociativeTrieNode<E, N>> subNodes;
		
		abstract Object getUnderlyingValue();
	}
	
	protected static class SubNodesMappingBasic<E extends Address> extends SubNodesMapping<E, SubNodesMappingBasic<E>> {
		
		@Override
		Object getUnderlyingValue() {
			return null;
		}
	}
	
	
	/**
	 * Provides an associative trie in which the root and each added node are mapped to a list of their respective direct added nodes.
	 * This trie provides an alternative non-binary tree structure of the added nodes.
	 * It is used by {@link #toAddedNodesTreeString()} to produce a string showing the alternative structure.
	 * If there are no non-added nodes in this trie, then the alternative tree structure provided by this method is the same as the original trie.
	 *
	 * @return
	 */
	public abstract AddedTreeBase<E, ? extends SubNodesMapping<E, ? extends SubNodesMapping<E, ?>>> constructAddedNodesTree(); 
	/**
	* Constructs a trie in which added nodes are mapped to their list of added sub-nodes.
	* This trie provides an alternative non-binary tree structure of the added nodes.
	* It is used by ToAddedNodesTreeString to produce a string showing the alternative structure.
	* If there are no non-added nodes in this trie, 
	* then the alternative tree structure provided by this method is the same as the original trie.
	* 
	* @return
	*/
	protected void contructAddedTree(AssociativeAddressTrie<E, SubNodesMappingBasic<E>> emptyTrie) {
		emptyTrie.addTrie(absoluteRoot()); // does not add values
		
		CachingIterator<? extends AssociativeTrieNode<E, SubNodesMappingBasic<E>>, E, 
				AssociativeTrieNode<E, SubNodesMappingBasic<E>>> cachingIterator =
				emptyTrie.containingFirstAllNodeIterator(true);
		
		while(cachingIterator.hasNext()) {
			AssociativeTrieNode<E, SubNodesMappingBasic<E>> newNext = cachingIterator.next(), parent;
			
			// populate the values from the original trie into the new trie
			newNext.setValue(new SubNodesMappingBasic<E>());
			
			// cache this node with its sub-nodes
			cachingIterator.cacheWithLowerSubNode(newNext);
			cachingIterator.cacheWithUpperSubNode(newNext);
			
			// the cached object is our parent
			if(newNext.isAdded()) {
				parent = cachingIterator.getCached();
				if(parent != null) {
					// find added parent, or the root if no added parent
					// this part would be tricky if we accounted for the bounds,
					// maybe we'd have to filter on the bounds, and also look for the sub-root
					while(!parent.isAdded()) {
						AssociativeTrieNode<E, SubNodesMappingBasic<E>> parentParent = parent.getParent();
						if(parentParent == null) {
							break;
						}
						parent = parentParent;
					}
					// store ourselves with that added parent or root
					SubNodesMappingBasic<E> mappedNodes = parent.getValue();
					ArrayList<AssociativeTrieNode<E, SubNodesMappingBasic<E>>> addedSubs = mappedNodes.subNodes;
					if(addedSubs == null) {
						addedSubs = new ArrayList<AssociativeTrieNode<E, SubNodesMappingBasic<E>>>(newNext.size() - 1);
						mappedNodes.subNodes = addedSubs;
					}
					addedSubs.add(newNext);
				} // else root
			}
		}
		SubNodesMappingBasic<E> value = emptyTrie.getRoot().getValue();
		if(value != null && value.subNodes != null) {
			value.subNodes.trimToSize();
		}
		Iterator<? extends AssociativeTrieNode<E, SubNodesMappingBasic<E>>> iter = emptyTrie.allNodeIterator(true);
		while(iter.hasNext()) {
			SubNodesMappingBasic<E> list = iter.next().getValue();
			if(list != null && list.subNodes != null) {
				list.subNodes.trimToSize();
			}
		}
	}
	/**
	 * Provides a flattened version of the trie showing only the contained added nodes and their containment structure, which is non-binary.
	 * The root node is included, which may or may not be added.
	 * <p>
	 * See {@link #constructAddedNodesTree()}
	 * 
	 * @return
	 */
	public abstract String toAddedNodesTreeString();
	
	protected static <E extends Address, N extends SubNodesMapping<E, N>> String toAddedNodesTreeString(AssociativeAddressTrie<E, N> addedTree) {
		AssociativeTrieNode<E, N> root = addedTree.absoluteRoot();
		return toAddedNodesTreeString(root);
	}
	
	protected static <E extends Address, N extends SubNodesMapping<E, N>> String toAddedNodesTreeString(AssociativeTrieNode<E, N> root) {
		class IndentsNode {
			Indents indents;
			AssociativeTrieNode<E, N> node;
			IndentsNode(Indents indents, AssociativeTrieNode<E, N> node) {
				this.indents = indents;
				this.node = node;
			}
		}
		
		Deque<IndentsNode> stack = null;
		StringBuilder builder = new StringBuilder();
		builder.append('\n');
		AssociativeTrieNode<E, N> nextNode = root;
		String nodeIndent = "", subNodeIndent = "";
		IndentsNode nextItem;
		while(true) {
			SubNodesMapping<E, N> nextNodeList = nextNode.getValue();
			TrieNode.toNodeString(builder.append(nodeIndent), nextNode.isAdded(), nextNode.getKey(), nextNodeList.getUnderlyingValue()).append('\n');
			ArrayList<AssociativeTrieNode<E, N>> nextNodes = nextNodeList.subNodes;
			if(nextNodes != null && nextNodes.size() > 0) {
				
				AssociativeTrieNode<E, N> nNode, next;
				int i = nextNodes.size() - 1;
				Indents lastIndents = new Indents(
						subNodeIndent + BinaryTreeNode.RIGHT_ELBOW,
						subNodeIndent + BinaryTreeNode.BELOW_ELBOWS);
				nNode = nextNodes.get(i);
				next = nNode;
				if(stack == null) {
					stack = new ArrayDeque<>(root.size());
				}
				stack.addFirst(new IndentsNode(lastIndents, next));
				if(nextNodes.size() > 1) {
					Indents firstIndents = new Indents(
							subNodeIndent + BinaryTreeNode.LEFT_ELBOW,
							subNodeIndent + BinaryTreeNode.IN_BETWEEN_ELBOWS);
					for(--i; i >= 0; i--) {
						nNode = nextNodes.get(i);
						next = nNode;
						stack.addFirst(new IndentsNode(firstIndents, next));
					}
				}
			}
			if(stack == null) {
				break;
			}
			nextItem = stack.pollFirst();
			if(nextItem == null) {
				break;
			}
			nextNode = nextItem.node;
			Indents nextIndents = nextItem.indents;
			nodeIndent = nextIndents.nodeIndent;
			subNodeIndent = nextIndents.subNodeInd;
		}
		return builder.toString();
	}
	TrieNode<E> addNode(OpResult<E> result, TrieNode<E> fromNode, TrieNode<E> nodeToAdd, boolean withValues) {
		fromNode.matchBitsFromIndex(fromNode.getKey().getPrefixLength(), result);
		TrieNode<E> node = result.existingNode;
		return node == null ? result.inserted : node;
	}
	
	// Note: this method not called from sets or maps, so bounds does not apply
	TrieNode<E> addTrie(TrieNode<E> tree, boolean withValues) {
		CachingIterator<? extends TrieNode<E>, E, TrieNode<E>> iterator = 
				tree.containingFirstAllNodeIterator(true);
		TrieNode<E> toAdd = iterator.next();
		OpResult<E> result = new OpResult<>(toAdd.getKey(), Operation.INSERT);
		TrieNode<E> firstNode;
		TrieNode<E> root = absoluteRoot();
		boolean firstAdded = toAdd.isAdded();
		boolean addedOne = false;
		if(firstAdded) {
			addedOne = true;
			adjustRoot(toAdd.getKey());
			firstNode = addNode(result, root, toAdd, withValues);
		} else {
			firstNode = root;
		}
		TrieNode<E> lastAddedNode = firstNode;
		while(iterator.hasNext()) {
			iterator.cacheWithLowerSubNode(lastAddedNode);
			iterator.cacheWithUpperSubNode(lastAddedNode);
			toAdd = iterator.next();
			TrieNode<E> cachedNode = iterator.getCached();
			if(toAdd.isAdded()) {
				E addrNext = toAdd.getKey();
				if(!addedOne) {
					addedOne = true;
					adjustRoot(addrNext);
				}
				result.addr = addrNext;
				result.existingNode = null;
				result.inserted = null;
				result.setFollowingBits(0);
				lastAddedNode = addNode(result, cachedNode, toAdd, withValues);
			} else {
				lastAddedNode = cachedNode;
			}
		}
		if(!firstAdded) {
			firstNode = getNode(tree.getKey());
		}
		return firstNode;
	}
	@Override
	public TrieNode<E> addTrie(TrieNode<E> trie) {
		return addTrie(trie, false);
	}
	@Override
	public boolean contains(E addr) {
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return false;
			}
		}
		return absoluteRoot().contains(addr);
	}
	@Override
	public boolean remove(E addr) {
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return false;
			}
		}
		return absoluteRoot().remove(addr);
	}
	
	// The following four methods do not work when there are bounds, 
	// and have counterparts to be used from sets and maps
	@Override
	public TrieNode<E> removeElementsContainedBy(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().removeElementsContainedBy(addr);
	}
	@Override
	public TrieNode<E> elementsContainedBy(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().elementsContainedBy(addr);
	}
	@Override
	public TrieNode<E> elementsContaining(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().elementsContaining(addr);
	}
	
	@Override
	public E longestPrefixMatch(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().longestPrefixMatch(addr);
	}
	// only added nodes are added to the linked list
	@Override
	public TrieNode<E> longestPrefixMatchNode(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().longestPrefixMatchNode(addr);
	}
	@Override
	public E shortestPrefixMatch(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().shortestPrefixMatch(addr);
	}
	@Override
	public TrieNode<E> shortestPrefixMatchNode(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().shortestPrefixMatchNode(addr);
	}
	@Override
	public boolean elementContains(E addr) {
		if(bounds != null) {
			// should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().elementContains(addr);
	}
	// Is this subtrie affected by the "reverse" setting?  Well, we are gonna wrap it, so wrap it with the same reverse setting.
	@SuppressWarnings("unchecked")
	AddressTrie<E> elementsContainedByToSubTrie(E addr) {
		// We just construct a subtrie with bounds determined by the prefix block of E, nothing more is needed here
		AddressBounds<E> newBounds;
		E lower = (E) addr.getLower().withoutPrefixLength();
		E upper = (E) addr.getUpper().withoutPrefixLength();
		if(bounds == null) {
			newBounds = AddressBounds.createNewBounds(lower, true, upper, true, comparator());
		} else {
			newBounds = bounds.intersect(lower, true, upper, true);
		}
		if(newBounds == bounds) {
			return this;
		}
		return createSubTrie(newBounds);
	}
	AddressTrie<E> elementsContainingToTrie(E addr) {
		if(isEmpty()) {
			return this;
		}
		// this creates a completely new linked list of nodes with just the containing elements
		// then create an AddressTrie around then with the same bounds
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return createNew(bounds);
		}
		TrieNode<E> node = subRoot.elementsContaining(addr); // creates the new containing linked list
		if(node == null) {
			return createNew(bounds);
		}
		if (size() == node.size()) {
			return this;
		}
		return createNewSameBoundsFromList(node);
	}
	boolean elementContainsBounds(E addr) {
		if(bounds == null) {
			return elementContains(addr);
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return false;
		}
		TrieNode<E> node = subRoot.elementsContaining(addr); // creates the new containing linked list
		if(node == null) {
			return false;
		}
		// Now we need to know if any of the nodes are within the bounds
		return !createNewSameBoundsFromList(node).isEmpty();
	}
	TrieNode<E> smallestElementContainingBounds(E addr) {
		if(bounds == null) {
			return longestPrefixMatchNode(addr);
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return null;
		}
		TrieNode<E> node = subRoot.longestPrefixMatchNode(addr);
		if(node == null) {
			return null;
		}
		if(!bounds.isInBounds(node.getKey())) {
			node = subRoot.elementsContaining(addr); // creates the new containing linked list
			TrieNode<E> next, lastInBounds = bounds.isInBounds(node.getKey()) ? node : null;
			do {
				if((next = node.getLowerSubNode()) != null) {
					node = next;
					if(bounds.isInBounds(node.getKey())) {
						lastInBounds = node;
					}
				} else if((next = node.getUpperSubNode()) != null) {
					node = next;
					if(bounds.isInBounds(node.getKey())) {
						lastInBounds = node;
					}
				}
			} while(next != null);
			node = lastInBounds;
		}
		return node;
	}
	E longestPrefixMatchBounds(E addr) {
		TrieNode<E> node = smallestElementContainingBounds(addr);
		return node == null ? null : node.getKey();
	}
	// creates a new one-node trie with a new root and the given bounds
	protected abstract AddressTrie<E> createNew(AddressBounds<E> bounds);
	// create a trie with the same root as this one, but different bounds
	protected abstract AddressTrie<E> createSubTrie(AddressBounds<E> bounds);
	private AddressTrie<E> createNewSameBoundsFromList(TrieNode<E> node) {
		AddressTrie<E> newTrie = createNew(bounds);
		TrieNode<E> root = newTrie.absoluteRoot();
		if(node.getKey().equals(root.getKey())) {
			newTrie.root = node;
		} else {
			root.init(node);
		}
		ChangeTracker tracker = root.changeTracker;
		node.changeTracker = tracker;
		TrieNode<E> next = node;
		while(true) {
			TrieNode<E> lower = next.getLowerSubNode();
			if(lower == null) {
				next = next.getUpperSubNode();
				if(next == null) {
					break;
				}
			} else {
				next = lower;
			}
			next.changeTracker = tracker;
		}
		// change tracker needs to be in place before calculating size, which requires an iterator, which uses change tracker
		newTrie.root.size = BinaryTreeNode.SIZE_UNKNOWN;
		newTrie.root.size();
		return newTrie;
	}
	@Override
	public TrieNode<E> getNode(E addr) {
		TrieNode<E> subRoot;
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return null;
			}
			subRoot = getRoot();
			if(subRoot == null) {
				return null;
			}
		} else {
			subRoot = absoluteRoot();
		}
		return subRoot.getNode(addr);
	}
	@Override
	public Iterator<? extends TrieNode<E>> allNodeIterator(boolean forward) {
		if(bounds != null) {
			// This cannot work with bounds because we need to find the iterator boundary using ceiling/floor/high/lower,
			// which only work with added nodes.  Other iterators which filter based on the bounds can work.
			// Should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().allNodeIterator(forward);
	}
	/**
	 * Iterates the added nodes in the trie, ordered by keys from largest prefix blocks to smallest, and then to individual addresses.
	 * <p>
	 * This iterator supports the {@link java.util.Iterator#remove()} operation.
	 * 
	 * @param lowerSubNodeFirst if true, for blocks of equal size the lower is first, otherwise the reverse order
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public Iterator<? extends TrieNode<E>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().blockSizeNodeIterator(lowerSubNodeFirst);
		} else {
			iterator = new BlockSizeNodeIterator<E>(
					size(),
					bounds,
					true,
					getRoot(),
					!lowerSubNodeFirst,
					absoluteRoot().changeTracker);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	/**
	 * Iterates all nodes in the trie, ordered by keys from largest prefix blocks to smallest, and then to individual addresses.
	 * <p>
	 * This iterator supports the {@link java.util.Iterator#remove()} operation.
	 * 
	 * @param lowerSubNodeFirst if true, for blocks of equal size the lower is first, otherwise the reverse order
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public Iterator<? extends TrieNode<E>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().blockSizeAllNodeIterator(lowerSubNodeFirst);
		} else { // at this time this is unreachable, we do not call this from set or map
			iterator = new BlockSizeNodeIterator<E>(
					0,
					bounds,
					false,
					getRoot(),
					!lowerSubNodeFirst,
					absoluteRoot().changeTracker);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	/**
	 * Iterates all nodes, ordered by keys from largest prefix blocks to smallest, and then to individual addresses.
	 * <p>
	 * This iterator supports the {@link java.util.Iterator#remove()} operation.
	 * 
	 * @return
	 */
	public <C> CachingIterator<? extends TrieNode<E>, E, C> blockSizeCachingAllNodeIterator() {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> containingFirstIterator(boolean forwardSubNodeOrder) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containingFirstIterator(forwardSubNodeOrder);
		} else {
			if(forwardSubNodeOrder) {
				iterator = new PreOrderNodeIterator<E, Object>(
					bounds,
					true,
					true, // added only
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			} else {
				iterator = new PostOrderNodeIterator<E, Object>(
					bounds,
					false,
					true, // added only
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			}
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<? extends TrieNode<E>, E, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		CachingIterator<? extends BinaryTreeNode<E>, E, C> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containingFirstAllNodeIterator(forwardSubNodeOrder);
		} else { // at this time this is unreachable, we do not call this from set or map
			if(forwardSubNodeOrder) {
				iterator = new PreOrderNodeIterator<E, C>(
					bounds,
					true,
					false, // added only
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			} else {
				iterator = new PostOrderNodeIterator<E, C>(
					bounds,
					false,
					false, // added only
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			}
		}
		return (CachingIterator<? extends TrieNode<E>, E, C>) iterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> containedFirstIterator(boolean forwardSubNodeOrder) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containedFirstIterator(forwardSubNodeOrder);
		} else {
			iterator = containedFirstBoundedIterator(forwardSubNodeOrder, true);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	private Iterator<? extends BinaryTreeNode<E>> containedFirstBoundedIterator(boolean forwardSubNodeOrder, boolean addedNodesOnly) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(forwardSubNodeOrder) {
			BinaryTreeNode<E> startNode = absoluteRoot().firstPostOrderNode();
			iterator = new PostOrderNodeIterator<E, Object>(
					bounds,
					true, // forward
					addedNodesOnly, // added only
					startNode,
					null,
					absoluteRoot().changeTracker);
		} else {
			BinaryTreeNode<E> startNode = absoluteRoot().lastPreOrderNode();
			iterator = new PreOrderNodeIterator<E, Object>(
					bounds,
					false, // forward
					addedNodesOnly, // added only
					startNode,
					null,
					absoluteRoot().changeTracker);
		}
		return iterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containedFirstAllNodeIterator(forwardSubNodeOrder);
		} else {
			iterator = containedFirstBoundedIterator(forwardSubNodeOrder, false);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	@Override
	public Spliterator<E> spliterator() {
		return new KeySpliterator<E>(nodeSpliterator(true, true), comparator());
	}
	@Override
	public Spliterator<E> descendingSpliterator() {
		return new KeySpliterator<E>(nodeSpliterator(false, true), reverseComparator());
	}
	@Override
	public Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward) {
		return nodeSpliterator(forward, true);
	}
	@Override
	public Spliterator<? extends TrieNode<E>> allNodeSpliterator(boolean forward) {
		if(bounds != null) {
			// This cannot work with bounds because we need to find the iterator boundary using ceiling/floor/high/lower,
			// which only work with added nodes.  Other iterators which filter based on the bounds can work.
			// Should never reach here when there are bounds, since this is not exposed from set/map code
			throw new Error();
		}
		return absoluteRoot().nodeSpliterator(forward, false);
	}
	@SuppressWarnings("unchecked")
	Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward, boolean addedNodesOnly) {
		Spliterator<? extends TrieNode<E>> spliterator;
		if(bounds == null) {
			spliterator = absoluteRoot().nodeSpliterator(forward, addedNodesOnly);
		} else {
			Comparator<BinaryTreeNode<E>> comp = forward ? nodeComparator() : reverseNodeComparator();
			Spliterator<? extends BinaryTreeNode<E>> split = new NodeSpliterator<E>(
					forward,
					comp,
					getRoot(),
					forward ? firstAddedNode() : lastAddedNode(),
					forward ? getIteratingUpperBoundary() : getIteratingLowerBoundary(),
					size(),
					absoluteRoot().changeTracker,
					addedNodesOnly);
			spliterator = (Spliterator<? extends TrieNode<E>>) split;
		}
		return spliterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> nodeIterator(boolean forward) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().nodeIterator(forward);
		} else {
			iterator = new NodeIterator<E>(
				forward,
				true,
				forward ? firstAddedNode() : lastAddedNode(),
				forward ? getIteratingUpperBoundary() : getIteratingLowerBoundary(),
				absoluteRoot().changeTracker);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	@Override
	public TrieNode<E> firstNode() {
		return absoluteRoot().firstNode();
	}
	@Override
	public TrieNode<E> firstAddedNode() {
		if(bounds == null) {
			return absoluteRoot().firstAddedNode();
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isLowerBounded() ?
				(bounds.lowerInclusive ? subRoot.ceilingNodeNoCheck(bounds.lowerBound) : subRoot.higherNodeNoCheck(bounds.lowerBound)) :
					subRoot.firstAddedNode();
			return (node == null || bounds.isAboveUpperBound(node.getKey())) ? null : node;
		}
		return null;
	}
	private TrieNode<E> getIteratingUpperBoundary() {
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return null;
		}
		if(bounds.isUpperBounded()) {
			return bounds.upperInclusive ? subRoot.higherNodeNoCheck(bounds.upperBound) : subRoot.ceilingNodeNoCheck(bounds.upperBound);//floorNodeBounded(bounds.lowerBound);
		}
		return subRoot.getParent();
	}
	@Override
	public TrieNode<E> lastNode() {
		return absoluteRoot().lastNode();
	}
	@Override
	public TrieNode<E> lastAddedNode() {
		if(bounds == null) {
			return absoluteRoot().lastAddedNode();
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isUpperBounded() ?
					(bounds.upperInclusive ? 
							subRoot.floorNodeNoCheck(bounds.upperBound) : subRoot.lowerNodeNoCheck(bounds.upperBound)) : 
						subRoot.lastAddedNode();
			return (node == null || bounds.isBelowLowerBound(node.getKey())) ? null : node;
		}
		return null;
	}
	private TrieNode<E> getIteratingLowerBoundary() {
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return null;
		}
		if(bounds.isLowerBounded()) {
			return bounds.lowerInclusive ? subRoot.lowerNodeNoCheck(bounds.lowerBound) : subRoot.floorNodeNoCheck(bounds.lowerBound);
		}
		return subRoot.getParent();
	}
	/**
	 * Returns a comparator for the trie order
	 * 
	 * @return
	 */
	public Comparator<E> getComparator() {
		return comparator();
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<E> comparator() {
		return (Comparator<E>) comparator.comparator;
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<BinaryTreeNode<E>> nodeComparator() {
		return (TrieComparator<E>) comparator;
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<E> reverseComparator() {
		return (Comparator<E>) reverseComparator.comparator;
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<BinaryTreeNode<E>> reverseNodeComparator() {
		return (TrieComparator<E>) reverseComparator;
	}
	/**
	 * Returns a java.util.NavigableSet that uses this as the backing data structure.
	 * Added elements of this trie are the elements in the set.
	 * 
	 * @return
	 */
	public AddressTrieSet<E> asSet() {
		AddressTrieSet<E> set = this.set;
		if(set == null) {
			set = new AddressTrieSet<E>(this);
		}
		return set;
	}
	protected TrieNode<E> absoluteRoot() {
		return (TrieNode<E>) root;
	}
	@Override
	public TrieNode<E> getRoot() {
		if(bounds == null) {
			return absoluteRoot();
		}
		if(subRootChange != null && !absoluteRoot().changeTracker.isChangedSince(subRootChange)) {
			// was previously calculated and there has been no change to the trie since then
			return subRoot;
		}
		TrieNode<E> current = absoluteRoot();
		do {
			E currentKey = current.getKey();
			if(bounds.isLowerBounded() && bounds.isBelowLowerBound(currentKey)) {
				current = current.getUpperSubNode();
			} else if(bounds.isUpperBounded() && bounds.isAboveUpperBound(currentKey)) {
				current = current.getLowerSubNode();
			} else {
				// inside the bounds
				break;
			}
		} while(current != null);
		subRootChange = absoluteRoot().changeTracker.getCurrent();
		subRoot = current;
		return current;
	}
	@Override
	public TrieNode<E> lowerAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().lowerAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return lowerNodeBounded(addr);
	}
	private TrieNode<E> lowerNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isAboveUpperBound(addr) ? 
					lastAddedNode() : subRoot.lowerNodeNoCheck(addr);
			return (node == null || bounds.isBelowLowerBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E lower(E addr) {
		return getNodeKey(lowerAddedNode(addr));
	}
	@Override
	public TrieNode<E> floorAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().floorAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return floorNodeBounded(addr);
	}
	private TrieNode<E> floorNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isAboveUpperBound(addr) ? 
					lastAddedNode() : subRoot.floorNodeNoCheck(addr);
			return (node == null || bounds.isBelowLowerBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E floor(E addr) {
		return getNodeKey(floorAddedNode(addr));
	}
	@Override
	public TrieNode<E> higherAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().higherAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return higherNodeBounded(addr);
	}
	private TrieNode<E> higherNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isBelowLowerBound(addr) ? 
					firstAddedNode() : subRoot.higherNodeNoCheck(addr);
			return (node == null || bounds.isAboveUpperBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E higher(E addr) {
		return getNodeKey(higherAddedNode(addr));
	}
	@Override
	public TrieNode<E> ceilingAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().ceilingAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return ceilingNodeBounded(addr);
	}
	private TrieNode<E> ceilingNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isBelowLowerBound(addr) ? 
					firstAddedNode() : subRoot.ceilingNodeNoCheck(addr);
			return (node == null || bounds.isAboveUpperBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E ceiling(E addr) {
		return getNodeKey(ceilingAddedNode(addr));
	}
	static <E extends Address> E getNodeKey(TrieNode<E> node) {
		return (node == null) ? null : node.getKey();
	}
	@Override
	public void clear() {
		if(bounds == null) {
			super.clear();
		} else {
			Iterator<? extends BinaryTreeNode<E>> iterator = nodeIterator(true);
			while(iterator.hasNext()) {
				BinaryTreeNode<E> node = iterator.next();
				if(bounds.isInBounds(node.getKey())) {
					iterator.remove();
				}
			}
		}
	}
	@Override
	public AddressTrie<E> clone() {
		AddressTrie<E> result = (AddressTrie<E>) super.clone();
		result.set = null;
		if(bounds == null) {
			result.root = getRoot().cloneTree();
		} else {
			TrieNode<E> root = absoluteRoot();
			if(bounds.isInBounds(root.getKey())) {
				result.root = root.cloneTreeBounds(bounds);
			} else {
				// clone the root ourselves, then clone the trie starting from the subroot, and make it a child of the root
				BinaryTreeNode<E> clonedRoot = root.cloneTreeNode(new ChangeTracker()); // clone root node only
				result.root = clonedRoot;
				clonedRoot.setNodeAdded(false); // not in bounds, so not part of new trie
				clonedRoot.setLower(null);
				clonedRoot.setUpper(null);
				TrieNode<E> subRoot = getRoot();
				if(subRoot != null) {
					TrieNode<E> subCloned = subRoot.cloneTreeBounds(bounds);
					if(subCloned != null) {
						result.absoluteRoot().init(subCloned);// attach cloned sub-root to root
					} else {
						clonedRoot.size = clonedRoot.isAdded() ? 1 : 0;
					}
				} else {
					clonedRoot.size = clonedRoot.isAdded() ? 1 : 0;
				}
			}
			result.bounds = null;
		}
		return result;
	}
	/**
	 * Returns whether the given argument is a trie with a set of nodes that equal the set of nodes in this trie
	 */
	@Override
	public boolean equals(Object o) {
		return o instanceof AddressTrie && super.equals(o);
	}
	@Override
	public String toString() {
		if(bounds == null) {
			return super.toString();
		}
		return toString(true);
	}
	String noBoundsString() { // useful for debugging
		return absoluteRoot().toTreeString(true, true);
	}
	@Override
	public String toString(boolean withNonAddedKeys) {
		if(bounds == null) {
			return super.toString(withNonAddedKeys);
		}
		StringBuilder builder = new StringBuilder("\n");
		printTree(builder, new Indents(), withNonAddedKeys);
		return builder.toString();
	}
	void printTree(StringBuilder builder, Indents indents, boolean withNonAddedKeys) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return;
		}
		subRoot.printTree(builder, indents, withNonAddedKeys, true, 
				this.<Indents>containingFirstAllNodeIterator(true));
	}
	/**
	 * Produces a visual representation of the given tries joined by a single root node, with one node per line.
	 * 
	 * @param withNonAddedKeys
	 * @param tries
	 * @return
	 */
	public static String toString(boolean withNonAddedKeys, AddressTrie<?> ...tries) {
		int totalEntrySize = 0;
		for(int i=0; i < tries.length; i++) {
			totalEntrySize += tries[i].size();
		}
		StringBuilder builder = new StringBuilder(totalEntrySize * 120);
		builder.append('\n').append(BinaryTreeNode.NON_ADDED_NODE_CIRCLE);
		boolean isEmpty = tries == null;
		if(!isEmpty) {
			AddressTrie<?> lastTree = null;
			int lastTreeIndex;
			for(lastTreeIndex = tries.length - 1; lastTreeIndex >= 0; lastTreeIndex--) {
				if(tries[lastTreeIndex] != null) {
					lastTree = tries[lastTreeIndex];
					break;
				}
			}
			isEmpty = lastTree == null;
			if(!isEmpty) {
				int totalSize = lastTree.size();
				for(int i = 0; i < lastTreeIndex; i++) {
					AbstractTree<?> tree = tries[i];
					if(tree != null) {
						totalSize += tree.size();
					}
				}
				if(withNonAddedKeys) {
					builder.append(' ').append(Address.SEGMENT_WILDCARD_STR).append(" (").append(totalSize).append(')');
				}
				builder.append('\n');
				for(int i = 0; i < lastTreeIndex; i++) {
					AddressTrie<?> tree = tries[i];
					if(tree != null) {
						tree.printTree(builder, new Indents(BinaryTreeNode.LEFT_ELBOW, BinaryTreeNode.IN_BETWEEN_ELBOWS), withNonAddedKeys);
					}
				}
				lastTree.printTree(builder, new Indents(BinaryTreeNode.RIGHT_ELBOW, BinaryTreeNode.BELOW_ELBOWS), withNonAddedKeys);
			}
		}
		if(isEmpty) {
			if(withNonAddedKeys) {
				builder.append(' ').append(Address.SEGMENT_WILDCARD_STR).append(" (0)");
			}
			builder.append('\n');
		}
		return builder.toString();
	}
}
/*
 * Copyright 2016-2020 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.math.BigInteger;
import java.util.Comparator;
import java.util.Iterator;
import java.util.stream.Stream;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
/**
 * Represents a series of IP address segments.
 * <p>
 * Provides methods relevant to IP addresses and IP address sections in addition to the more general methods pertaining to address and address sections in AddressSegmentSeries.
 * 
 * 
 * @author sfoley
 *
 */
public interface IPAddressSegmentSeries extends IPAddressDivisionSeries, AddressSegmentSeries {
	/**
	 * Returns a comparator to sort series by prefix length.
	 * 
	 * @return
	 */
	static Comparator<? super IPAddressSegmentSeries> getPrefixLenComparator() {
		return IPAddressSection.mergeListComparator;
	}
	
	/**
	 * Returns the version of this segment series
	 * 
	 * @return
	 */
	IPVersion getIPVersion();
	
	/**
	 * Returns the equivalent address series with the smallest CIDR prefix possible (largest network),
	 * such that the range of values of this address includes the subnet prefix block for that prefix.
	 * 
	 * @see #toPrefixBlock()
	 * @see #assignPrefixForSingleBlock()
	 * @return
	 */
	IPAddressSegmentSeries assignMinPrefixForBlock();
	
	/**
	 * Returns the equivalent CIDR address series with a prefix length for which the subnet block for that prefix matches the range of values in this series.
	 * In short, the returned series is a single block of address segment series.
	 * Another way of looking at it: if the range matches the range associated with some prefix length, then it returns the address series with that prefix length.
	 * <p>
	 * If no such prefix length exists, returns null.
	 * <p>
	 * If this address represents just a single address, "this" is returned.
	 * <p>
	 * The methods {@link #assignMinPrefixForBlock}, {@link #assignPrefixForSingleBlock} can be compared as follows.<p>
	 * {@link #assignMinPrefixForBlock} finds the smallest prefix length possible for this subnet and returns that subnet.<br>
	 * {@link #assignPrefixForSingleBlock} finds the smallest prefix length possible for this subnet that results in just a single prefix and returns that subnet.<br>
	 * <p>
	 * For example, given the address 1-2.2.3.* /16<br>
	 * {@link #assignMinPrefixForBlock} returns 1-2.2.3.* /24 if the prefix configuration is the default or is not ALL_PREFIXES_ARE_SUBNETS, otherwise 1-2.2.*.* /16, in order to return the subnet with the smallest prefix length <br>
	 * {@link #assignPrefixForSingleBlock} returns null because any prefix length will end up with at least two prefixes due to the first segment spanning two values: 1-2.
	 * <p>
	 * For another example, for the address 1.2.*.* /16 or the address 1.2.*.* both methods return 1.2.*.* /16.
	 * 
	 * @see #toPrefixBlock()
	 * @see #assignMinPrefixForBlock()
	 * @return
	 */
	IPAddressSegmentSeries assignPrefixForSingleBlock();
	/**
	 * Returns the minimal-size prefix block that covers all the values in this series.
	 * The resulting block will have a larger series count than this, unless this series is already a prefix block.
	 */
	IPAddressSegmentSeries coverWithPrefixBlock();
	/**
	 * Produces an array of prefix blocks that spans the same set of values.
	 */
	IPAddressSegmentSeries[] spanWithPrefixBlocks();
	/**
	 * Produces an array of blocks that are sequential that cover the same set of values.
	 * This array can be shorter than that produced by {@link #spanWithPrefixBlocks()} and is never longer.
	 */
	IPAddressSegmentSeries[] spanWithSequentialBlocks();
	/**
	 * If this series has a prefix length, returns the subnet block for that prefix. If this series has no prefix length, this series is returned.
	 * 
	 * @return the subnet block for the prefix length
	 */
	@Override
	IPAddressSegmentSeries toPrefixBlock();
	/** 
	 * Returns the segment series of the same length that spans all hosts.
	 * The network prefix length will be the one provided, and the network values will match the same of this series.
	 * 
	 * @param networkPrefixLength
	 * @return
	 */
	IPAddressSegmentSeries toPrefixBlock(int networkPrefixLength) throws PrefixLenException;
	/**
	 * Returns the host mask associated with the CIDR network prefix length of this series.
	 * If this series has no prefix length, then the whole series is considered a host and the all ones host mask is returned.
	 * 
	 * @return
	 */
	IPAddressSegmentSeries getHostMask();
	/**
	 * Returns the network mask associated with the CIDR network prefix length of this series.
	 * If this series has no prefix length, then the whole series is considered network and the all ones network mask is returned.
	 * 
	 * @return
	 */
	IPAddressSegmentSeries getNetworkMask();
	/**
	 * Returns the host section of the series.  The returned section will have only as many segments as needed
	 * as determined by the existing CIDR network prefix length.  If this series has no CIDR prefix length, the returned host section will 
	 * be the full section associated with a prefix length of 0.
	 * 
	 * @return
	 */
	IPAddressSection getHostSection();
	/**
	 * Returns the host section of the address as indicated by the network prefix length provided.  The returned section will have only as many segments as needed
	 * to hold the host as indicated by the provided network prefix length.
	 * 
	 * @param networkPrefixLength
	 * @return
	 */
	IPAddressSection getHostSection(int networkPrefixLength);
	/**
	 * Returns the network section of the series if the series has a CIDR network prefix length, 
	 * otherwise it returns the entire series as a prefixed series with prefix matching the address bit length.
	 * 
	 * @return
	 */
	IPAddressSection getNetworkSection();
	
	/**
	 * Returns the network section of the series.  The returned section will have only as many segments as needed as indicated by networkPrefixLength.
	 * It will have networkPrefixLength as its associated prefix length,
	 * unless this address already has a smaller prefix length, in which case the existing prefix length is retained.
	 * 
	 * @param networkPrefixLength
	 * @return
	 */
	IPAddressSection getNetworkSection(int networkPrefixLength);
	
	/**
	 * Returns the network section of the series.  The returned section will have only as many segments as needed as indicated by networkPrefixLength.  
	 * If withPrefixLength is true, it will have networkPrefixLength as its associated prefix length,
	 * unless this series already has a smaller prefix length, in which case the existing prefix length is retained.
	 * 
	 * @param networkPrefixLength
	 * @param withPrefixLength whether the resulting section will have networkPrefixLength as the associated prefix length or not
	 * @return
	 */
	IPAddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength);
	/**
	 * This produces a string with no compressed segments and all segments of full length,
	 * which is 4 characters for IPv6 segments and 3 characters for IPv4 segments.
	 */
	String toFullString();
	/**
	 * Returns a string with a CIDR prefix length if this section has a network prefix length.
	 * For IPv6, the host section will be compressed with ::, for IPv4 the host section will be zeros.
	 * @return
	 */
	String toPrefixLengthString();
	/**
	 * Produces a consistent subnet string.
	 * 
	 * In the case of IPv4, this means that wildcards are used instead of a network prefix.
	 * In the case of IPv6, a prefix will be used and the host section will be compressed with ::.
	 */
	String toSubnetString();
	/**
	 * This produces a string similar to the normalized string and avoids the CIDR prefix.
	 * CIDR addresses will be shown with wildcards and ranges instead of using the CIDR prefix notation.
	 */
	String toNormalizedWildcardString();
	/**
	 * This produces a string similar to the canonical string and avoids the CIDR prefix.
	 * Addresses with a network prefix length will be shown with wildcards and ranges instead of using the CIDR prefix length notation.
	 * IPv6 addresses will be compressed according to the canonical representation.
	 */
	String toCanonicalWildcardString();
	/**
	 * This is similar to toNormalizedWildcardString, avoiding the CIDR prefix, but with compression as well.
	 */
	String toCompressedWildcardString();
	/**
	 * This is the same as the string from toNormalizedWildcardString except that 
	 * it uses {@link IPAddress#SEGMENT_SQL_WILDCARD} instead of {@link IPAddress#SEGMENT_WILDCARD} and also uses {@link IPAddress#SEGMENT_SQL_SINGLE_WILDCARD}
	 */
	String toSQLWildcardString();
	/**
	 * Generates the reverse DNS lookup string
	 * For 8.255.4.4 it is 4.4.255.8.in-addr.arpa
	 * For 2001:db8::567:89ab it is b.a.9.8.7.6.5.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa
	 * 
	 *
	 * @throws IncompatibleAddressException if this address is a subnet
	 * @return
	 */
	String toReverseDNSLookupString();
	/**
	 * Writes this IP address segment series as a single binary value with always the exact same number of characters
	 * 
	 * If this section represents a range of values outside of the network prefix length, then this is printed as a range of two binary values.
	 */
	String toBinaryString() throws IncompatibleAddressException;
	/**
	 * Writes this IP address segment series as a segments of binary values preceded by the "0b" prefix.
	 */
	String toSegmentedBinaryString();
	/**
	 * Writes this IP address segment series as a single octal value with always the exact same number of characters, with or without a preceding 0 prefix.
	 * 
	 * If this section represents a range of values outside of the network prefix length, then this is printed as a range of two hex values.
	 */
	String toOctalString(boolean with0Prefix) throws IncompatibleAddressException;
	IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions options);
	
	/**
	 * Creates a customized string from this series.
	 * 
	 * @param stringOptions
	 * @return
	 */
	String toNormalizedString(IPStringOptions stringOptions);
	@Override
	IPAddressNetwork<?,?,?,?,?> getNetwork();
	@Override
	IPAddressSection getSection();
	@Override
	IPAddressSection getSection(int index);
	@Override
	IPAddressSection getSection(int index, int endIndex);
	@Override
	IPAddressSegment getSegment(int index);
	@Override
	IPAddressSegment[] getSegments();
	/**
	 * Gets the count of single value series that this series may represent, but excluding series whose host is zero.
	 * The host is determined by the CIDR prefix length, if there is one.
	 * <p>
	 * If this address series has no range of values, then there is only one such address, or none if it has a zero host.
	 * <p>
	 * If this has no CIDR network prefix length, then it is equivalent to {@link #getCount()}.
	 * 
	 * @return
	 */
	BigInteger getNonZeroHostCount();
	/**
	 * Similar to {@link #getLower()}, but will not return a series that has a prefix length and whose host value is zero.
	 * If this series has no prefix length, returns the same series as {@link #getLower()}.
	 * 
	 * @return the lowest IP address series whose host is non-zero, or null if no such address section exists.
	 */
	IPAddressSegmentSeries getLowerNonZeroHost();
	@Override
	IPAddressSegmentSeries getLower();
	@Override
	IPAddressSegmentSeries getUpper();
	@Override
	Iterable<? extends IPAddressSegmentSeries> getIterable();
	@Override
	Iterator<? extends IPAddressSegmentSeries> iterator();
	@Override
	AddressComponentSpliterator<? extends IPAddressSegmentSeries> spliterator();
	@Override
	Stream<? extends IPAddressSegmentSeries> stream();
	@Override
	Iterator<? extends IPAddressSegmentSeries> prefixIterator();
	@Override
	AddressComponentSpliterator<? extends IPAddressSegmentSeries> prefixSpliterator();
	@Override
	Stream<? extends IPAddressSegmentSeries> prefixStream();
	@Override
	Iterator<? extends IPAddressSegmentSeries> prefixBlockIterator();
	@Override
	AddressComponentSpliterator<? extends IPAddressSegmentSeries> prefixBlockSpliterator();
	@Override
	Stream<? extends IPAddressSegmentSeries> prefixBlockStream();
	/**
	 * Similar to the iterator, but series with a host of zero are skipped.
	 * @return
	 */
	Iterator<? extends IPAddressSegmentSeries> nonZeroHostIterator();
	/**
	 * Iterates through series that can be obtained by iterating through all the upper segments up to the given segment count.
	 * Segments following remain the same in all iterated series.
	 * <p>
	 * For instance, given the IPv4 subnet 1-2.3-4.5-6.7, given the count argument 2, 
	 * it will iterate through 1.3.5-6.7, 1.4.5-6.7, 2.3.5-6.7, 2.4.5-6.7
	 * 
	 * @param segmentCount
	 * @return
	 */
	Iterator<? extends IPAddressSegmentSeries> blockIterator(int segmentCount);
	/**
	 * Partitions and traverses through the individual sequential blocks created from each of the individual values up to the given segment count. 
	 * 
	 * @return
	 */
	AddressComponentSpliterator<? extends IPAddressSegmentSeries> blockSpliterator(int segmentCount);
	/**
	 * Returns a sequential stream of the individual blocks created from each of the individual values up to the given segment count.  
	 * For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * 
	 * @return
	 */
	Stream<? extends IPAddressSegmentSeries> blockStream(int segmentCount);
	/**
	 * Iterates through the sequential series that make up this series.
	 * Generally this means finding the count of segments for which the segments that follow are not full range, and then using {@link #blockIterator(int)} with that segment count.
	 * <p>
	 * For instance, given the IPv4 subnet 1-2.3-4.5-6.7-8, it will iterate through 1.3.5.7-8, 1.3.6.7-8, 1.4.5.7-8, 1.4.6.7-8, 2.3.5.7-8, 2.3.6.7-8, 2.4.6.7-8, 2.4.6.7-8.
	 * <p>
	 * Use {@link #getSequentialBlockCount()} to get the count of iterated elements.
	 * 
	 * @return
	 */
	Iterator<? extends IPAddressSegmentSeries> sequentialBlockIterator();
	/**
	 * Partitions and traverses through the individual sequential blocks.
	 * 
	 * @return
	 */
	AddressComponentSpliterator<? extends IPAddressSegmentSeries> sequentialBlockSpliterator();
	/**
	 * Returns a sequential stream of the individual sequential blocks.  For a parallel stream, call {@link Stream#parallel()} on the returned stream.
	 * <p>
	 * Use {@link #getSequentialBlockCount()} to get the count of streamed elements.
	 * 
	 * @return
	 */
	Stream<? extends IPAddressSegmentSeries> sequentialBlockStream();
	/**
	 * provides the count of elements from the {@link #sequentialBlockIterator()}, the minimal number of sequential sub-series that comprise this series
	 * @return
	 */
	BigInteger getSequentialBlockCount();
	@Override
	Iterator<? extends IPAddressSegment[]> segmentsIterator();
	@Override
	AddressComponentRangeSpliterator<? extends IPAddressSegmentSeries, ? extends IPAddressSegment[]> segmentsSpliterator();
	@Override
	Stream<? extends IPAddressSegment[]> segmentsStream();
	/**
	 * Similar to the segments iterator, but series with a host of zero are skipped.
	 * 
	 * @return
	 */
	Iterator<? extends IPAddressSegment[]> segmentsNonZeroHostIterator();
	@Override
	IPAddressSegmentSeries increment(long increment);
	@Override
	IPAddressSegmentSeries incrementBoundary(long increment);
	/**
	 * Returns the segment series with a host of zero, the host being the bits following the prefix length.
	 * If the series has no prefix length, then it returns an all-zero series.
	 * <p>
	 * The default behaviour is that the resultant series will have the same prefix length.
	 * The resultant series will not have a prefix length if {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()} is {@link inet.ipaddr.AddressNetwork.PrefixConfiguration#ALL_PREFIXED_ADDRESSES_ARE_SUBNETS}. 
	 * <p>
	 * For instance, you can get the network address for a subnet as follows:
	 * <code>
	 * String addrStr = "1.2.3.4/16";
	 * IPAddress address = new IPAddressString(addrStr).getAddress();
	 * IPAddress networkAddress = address.toZeroHost(); //1.2.0.0
	 * </code>
	 * 
	 * @see #toZeroNetwork()
	 * 
	 * @return
	 */
	IPAddressSegmentSeries toZeroHost();
	/**
	 * Produces the series with host values of 0 for the given prefix length.
	 * <p>
	 * If this series has the same prefix length, then the resulting series will too, otherwise the resulting series will have no prefix length.
	 * <p>
	 * This is nearly equivalent to doing the mask (bitwise conjunction) of this address series with the network mask for the given prefix length,
	 * but without the possibility of IncompatibleAddressException that can occur when applying a mask to a range of values.
	 * Instead, in this case, if the resulting series has a range of values, then the resulting series range boundaries will have host values of 0, but not necessarily the intervening values.
	 * <p>
	 * For instance, you can get the network address for a subnet of prefix length 16 as follows:
	 * <code>
	 * String addrStr = "1.2.3.4";
	 * IPAddress address = new IPAddressString(addrStr).getAddress();
	 * IPAddress networkAddress = address.toZeroHost(16); //1.2.0.0
	 * </code>
	 * 
	 * @param prefixLength
	 * @return
	 */
	IPAddressSegmentSeries toZeroHost(int prefixLength);
	/**
	 * Returns the segment series with a network of zero, the network being the bits within the prefix length.
	 * If the series has no prefix length, then it returns an all-zero series.
	 * <p>
	 * The default behaviour is that the resultant series will have the same prefix length.
	 * The resultant series will not have a prefix length if {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()} is {@link inet.ipaddr.AddressNetwork.PrefixConfiguration#ALL_PREFIXED_ADDRESSES_ARE_SUBNETS}. 
	 * <p>
	 * @see #toZeroHost()
	 * 
	 * @return
	 */
	IPAddressSegmentSeries toZeroNetwork();
	/**
	 * Returns whether the series has a host of zero.  If the series has no prefix length, or the prefix length matches the bit count, then returns false.
	 * 
	 * Otherwise, it checks whether all bits past the prefix are zero.
	 * 
	 * @return
	 */
	boolean includesZeroHost();
	/**
	 * Returns whether all bits past the given prefix length are zero.
	 * 
	 * @return
	 */
	boolean includesZeroHost(int prefixLength);
	/**
	 * Produces the series with host values of all one bits for the given prefix length.
	 * <p>
	 * If this series has the same prefix length, then the resulting series will too, otherwise the resulting series will have no prefix length.
	 * <p>
	 * This is nearly equivalent to doing the bitwise or (bitwise disjunction) of this address series with the network mask for the given prefix length,
	 * but without the possibility of IncompatibleAddressException that can occur when applying a mask to a range of values.
	 * Instead, in this case, if the resulting series has a range of values, then the resulting series range boundaries will have host values of all ones, but not necessarily  the intervening values.
	 * <p>
	 * For instance, you can get the broadcast address for a subnet of prefix length 16 as follows:
	 * <code>
	 * String addrStr = "1.2.3.4";
	 * IPAddress address = new IPAddressString(addrStr).getAddress();
	 * IPAddress broadcastAddress = address.toMaxHost(16); //1.2.255.255
	 * </code>
	 * 
	 * @param prefixLength
	 * @return
	 */
	IPAddressSegmentSeries toMaxHost(int prefixLength);
	/**
	 * Returns the segment series with a host of all ones.
	 * If the series has no prefix length, then it returns an all-ones series.
	 * <p>
	 * The resultant series will have the same prefix length if {@link inet.ipaddr.AddressNetwork#getPrefixConfiguration()} is not {@link inet.ipaddr.AddressNetwork.PrefixConfiguration#ALL_PREFIXED_ADDRESSES_ARE_SUBNETS}, 
	 * otherwise it will no longer have a prefix length.
	 * <p>
	 * For instance, you can get the broadcast address for a subnet as follows:
	 * <code>
	 * String addrStr = "1.2.3.4/16";
	 * IPAddress address = new IPAddressString(addrStr).getAddress();
	 * IPAddress broadcastAddress = address.toMaxHost(); //1.2.255.255
	 * </code>
	 * 
	 * @return
	 */
	IPAddressSegmentSeries toMaxHost();
	/**
	 * Returns whether the series has a host of all ones.  If the series has no prefix length, or the prefix length matches the bit count, then returns false.
	 * 
	 * Otherwise, it checks whether all bits past the prefix are ones.
	 * 
	 * @return
	 */
	boolean includesMaxHost();
	
	/**
	 * Returns whether all bits past the given prefix length are all ones.
	 * 
	 * @return
	 */
	boolean includesMaxHost(int prefixLength);
	
	@Override
	IPAddressSegmentSeries reverseSegments();
	
	/**
	 * Returns a new series which has the bits reversed.
	 * <p>
	 * If this has an associated prefix length, then the prefix length is dropped in the reversed series.
	 * <p>
	 * If this represents a range of values that cannot be reversed,
	 * because reversing the range results in a set of addresses that cannot be described by a range, then this throws {@link IncompatibleAddressException}.
	 * In such cases you can call {@link #iterator()}, {@link #getLower()}, {@link #getUpper()} or some other method to transform the address 
	 * into an address representing a single value before reversing.
	 * <p>
	 * @param perByte if true, only the bits in each byte are reversed, if false, then all bits in the address are reversed
	 * @throws IncompatibleAddressException if this is a subnet that cannot be reversed
	 * @return
	 */
	@Override
	IPAddressSegmentSeries reverseBits(boolean perByte);
	@Override
	IPAddressSegmentSeries reverseBytes();
	@Override
	IPAddressSegmentSeries reverseBytesPerSegment();
	
	@Override @Deprecated
	IPAddressSegmentSeries removePrefixLength();
	
	@Override
	IPAddressSegmentSeries withoutPrefixLength();
	
	@Override  @Deprecated
	IPAddressSegmentSeries removePrefixLength(boolean zeroed);
	
	@Override
	IPAddressSegmentSeries adjustPrefixBySegment(boolean nextSegment);
	
	@Override
	IPAddressSegmentSeries adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	
	@Override
	IPAddressSegmentSeries adjustPrefixLength(int adjustment);
	
	@Override
	IPAddressSegmentSeries adjustPrefixLength(int adjustment, boolean zeroed);
	
	@Override
	IPAddressSegmentSeries setPrefixLength(int prefixLength);
	
	@Override
	IPAddressSegmentSeries setPrefixLength(int prefixLength, boolean zeroed);
	@Override @Deprecated
	IPAddressSegmentSeries applyPrefixLength(int networkPrefixLength);
}
/*
 * Copyright 2018-2022 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv6;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.function.Function;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressSeqRange;
import inet.ipaddr.NetworkMismatchException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
/**
 * Represents an arbitrary range of IPv6 addresses.
 * 
 * See {@link IPAddressSeqRange} for more details.
 * <p>
 * @custom.core
 * @author sfoley
 *
 */
public class IPv6AddressSeqRange extends IPAddressSeqRange implements Iterable<IPv6Address> {
	
	private static final long serialVersionUID = 1L;
	private static final BigInteger LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);
	private static final IPv6AddressSeqRange EMPTY[] = {};
	IPv6AddressSeqRange(IPv6Address first, IPv6Address second, boolean preSet) {
		super(first, second, preSet);
	}
	public IPv6AddressSeqRange(IPv6Address first, IPv6Address second) {
		super(
			first,
			second,
			IPv6Address::getLower,
			IPv6Address::getUpper,
			a -> a.withoutPrefixLength().removeZone());
		if(!first.getNetwork().isCompatible(second.getNetwork())) {
			throw new NetworkMismatchException(first, second);
		}
	}
	
	private IPv6AddressSeqRange(IPAddress first, IPAddress second) {
		super(first, second);
	}
	
	@Override
	public IPv6Address getLower() {
		return (IPv6Address) super.getLower();
	}
	
	@Override
	public IPv6Address getUpper() {
		return (IPv6Address) super.getUpper();
	}
	
	private IPv6AddressCreator getAddressCreator() {
		return getLower().getDefaultCreator();
	}
	@Override
	public Iterable<IPv6Address> getIterable() {
		return this;
	}
	@Override
	public Iterator<IPv6Address> iterator() {
		IPv6Address lower = getLower();
		IPv6Address upper = getUpper();
		AddressCreator<IPv6Address, ?, ?, IPv6AddressSegment> creator = getAddressCreator();
		if(!isMultiple()) {
			return iterator(lower, creator);
		}
		int divCount = lower.getSegmentCount();
		return iterator(
				lower,
				upper,
				creator,
				IPv6Address::getSegment,
				(seg, segIndex) -> seg.iterator(),
				(addr1, addr2, index) -> addr1.getSegment(index).getSegmentValue() == addr2.getSegment(index).getSegmentValue(),
				divCount - 1,
				divCount,
				null);
	}
	
	@Override
	public AddressComponentRangeSpliterator<IPv6AddressSeqRange, IPv6Address> spliterator() {
		int segmentCount = getLower().getSegmentCount();
		IPv6AddressCreator creator = getAddressCreator();
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSpliterator(
				this,
				spliterator -> {
					IPv6AddressSeqRange range = spliterator.getAddressItem();
					return split(
						spliterator,
						(segsLower, segsUpper) -> new IPv6AddressSeqRange(
								creator.createAddressInternal(segsLower),
								creator.createAddressInternal(segsUpper)),
						creator,
						range.getLower().getSection().getSegmentsInternal(),
						range.getUpper().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						null);
				},
				(lowest, highest, range) -> range.iterator(),
				IPv6AddressSeqRange::getCount,
				range -> range.getCount().compareTo(LONG_MAX) <= 0,
				range -> range.getCount().longValue());
	}
	@Override
	public Stream<IPv6Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public IPv6Address coverWithPrefixBlock() {
		return getLower().coverWithPrefixBlock(getUpper());
	}
	@Override
	public IPv6Address[] spanWithPrefixBlocks() {
		return getLower().spanWithPrefixBlocks(getUpper());
	}
	@Override
	public IPv6Address[] spanWithSequentialBlocks() {
		return getLower().spanWithSequentialBlocks(getUpper());
	}
	@Override
	protected IPv6AddressSeqRange create(IPAddress lower, IPAddress upper) {
		return new IPv6AddressSeqRange(lower, upper);
	}
	/* (non-Javadoc)
	 * @see inet.ipaddr.IPAddressRange#createPair(inet.ipaddr.IPAddress, inet.ipaddr.IPAddress, inet.ipaddr.IPAddress, inet.ipaddr.IPAddress)
	 */
	@Override
	protected IPv6AddressSeqRange[] createPair(IPAddress lower1, IPAddress upper1,
			IPAddress lower2, IPAddress upper2) {
		return new IPv6AddressSeqRange[] { create(lower1, upper1), create(lower2, upper2) };
	}
	/* (non-Javadoc)
	 * @see inet.ipaddr.IPAddressRange#createSingle(inet.ipaddr.IPAddress, inet.ipaddr.IPAddress)
	 */
	@Override
	protected IPv6AddressSeqRange[] createSingle(IPAddress lower, IPAddress upper) {
		return new IPv6AddressSeqRange[] { create(lower, upper) };
	}
	
	@Override
	protected IPv6AddressSeqRange[] createSingle() {
		return new IPv6AddressSeqRange[] { this };
	}
	
	@Override
	protected IPv6AddressSeqRange[] createEmpty() {
		return EMPTY;
	}
	/* (non-Javadoc)
	 * @see inet.ipaddr.IPAddressRange#prefixBlockIterator(int)
	 */
	@Override
	public Iterator<IPv6Address> prefixBlockIterator(int prefLength) {
		if(prefLength < 0) {
			throw new PrefixLenException(prefLength);
		}
		IPv6Address lower = getLower();
		IPv6Address upper = getUpper();
		AddressCreator<IPv6Address, ?, ?, IPv6AddressSegment> creator = getAddressCreator();
		int bitsPerSegment = lower.getBitsPerSegment();
		int bytesPerSegment = lower.getBytesPerSegment();
		int segCount = lower.getSegmentCount();
		Integer prefLengths[] = new Integer[segCount];
		int shifts[] = new int[segCount];
		int networkSegIndex = 0;
		if(prefLength > 0) {
			networkSegIndex = getNetworkSegmentIndex(prefLength, bytesPerSegment, bitsPerSegment);
		}
		for(int i = networkSegIndex; i < segCount; i++) {
			Integer segPrefLength = ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, prefLength, i);
			prefLengths[i] = segPrefLength;
			shifts[i] = bitsPerSegment - segPrefLength;
		}
		int hostSegIndex = getHostSegmentIndex(prefLength, bytesPerSegment, bitsPerSegment);
		return iterator(
				lower,
				upper,
				creator,
				IPv6Address::getSegment,
				(seg, segIndex) -> seg.iterator(),
				(addr1, addr2, index) -> {
					Integer segPrefLength = prefLengths[index];
					if(segPrefLength == null) {
						return addr1.getSegment(index).getSegmentValue() == addr2.getSegment(index).getSegmentValue();
					}
					int shift = shifts[index];
					return addr1.getSegment(index).getSegmentValue() >>> shift == addr2.getSegment(index).getSegmentValue() >>> shift;
				},
				networkSegIndex,
				hostSegIndex,
				(seg, index) -> {
					Integer segPrefLength = prefLengths[index];
					if(segPrefLength == null) {
						return seg.iterator();
					}
					return seg.prefixBlockIterator(segPrefLength);
				});
	}
	@Override
	public AddressComponentRangeSpliterator<IPv6AddressSeqRange, IPv6Address> prefixBlockSpliterator(int prefLength) {
		if(prefLength < 0) {
			throw new PrefixLenException(prefLength);
		}
		IPv6Address lower = getLower();
		int bitsPerSegment = lower.getBitsPerSegment();
		int bytesPerSegment = lower.getBytesPerSegment();
		IPv6AddressCreator creator = getAddressCreator();
		Integer prefixLength = IPv6AddressSection.cacheBits(prefLength);
		int networkSegIndex = getNetworkSegmentIndex(prefLength, bytesPerSegment, bitsPerSegment);
		int hostSegIndex = getHostSegmentIndex(prefLength, bytesPerSegment, bitsPerSegment);
		return createSpliterator(
				this,
				spliterator -> {
					IPv6AddressSeqRange range = spliterator.getAddressItem();
					return split(
						spliterator,
						(segsLower, segsUpper) -> new IPv6AddressSeqRange(
								creator.createAddressInternal(segsLower),
								creator.createAddressInternal(segsUpper)),
						creator,
						range.getLower().getSection().getSegmentsInternal(),
						range.getUpper().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefixLength);
				},
				(isLowest, isHighest, range) -> range.prefixBlockIterator(prefLength),
				range -> range.getPrefixCount(prefLength),
				range -> range.getPrefixCount(prefLength).compareTo(LONG_MAX) <= 0,
				range -> range.getPrefixCount(prefLength).longValue());	
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream(int prefLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefLength), false);
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AddressSeqRange> prefixIterator(int prefixLength) {
		return (Iterator<IPv6AddressSeqRange>) super.prefixIterator(prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6AddressSeqRange> prefixSpliterator(int prefLength) {
		if(prefLength < 0) {
			throw new PrefixLenException(prefLength);
		}
		IPv6Address lower = getLower();
		int bitsPerSegment = lower.getBitsPerSegment();
		int bytesPerSegment = lower.getBytesPerSegment();
		IPv6AddressCreator creator = getAddressCreator();
		Integer prefixLength = IPv6AddressSection.cacheBits(prefLength);
		int networkSegIndex = getNetworkSegmentIndex(prefLength, bytesPerSegment, bitsPerSegment);
		int hostSegIndex = getHostSegmentIndex(prefLength, bytesPerSegment, bitsPerSegment);
		return createPrefixSpliterator(
				this,
				spliterator -> {
					IPv6AddressSeqRange range = spliterator.getAddressItem();
					return split(
						spliterator,
						(segsLower, segsUpper) -> new IPv6AddressSeqRange(
								creator.createAddressInternal(segsLower),
								creator.createAddressInternal(segsUpper)),
						creator,
						range.getLower().getSection().getSegmentsInternal(),
						range.getUpper().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefixLength);
				},
				(isLowest, isHighest, range) -> (isLowest || isHighest) ? range.prefixIterator(prefLength) : rangedIterator(range.prefixBlockIterator(prefLength)),
				range -> range.getPrefixCount(prefLength),
				range -> range.getPrefixCount(prefLength).compareTo(LONG_MAX) <= 0,
				range -> range.getPrefixCount(prefLength).longValue());	
	}
	@Override
	public Stream<IPv6AddressSeqRange> prefixStream(int prefLength) {
		return StreamSupport.stream(prefixSpliterator(prefLength), false);
	}
	
	public String toIPv6String(Function<IPv6Address, String> lowerStringer, String separator, Function<IPv6Address, String> upperStringer) {
		return lowerStringer.apply(getLower()) + separator + upperStringer.apply(getUpper());
	}
	
	@Override
	public IPv6AddressSeqRange intersect(IPAddressSeqRange other) {
		return (IPv6AddressSeqRange) super.intersect(other);
	}
	
	@Override
	public IPv6AddressSeqRange join(IPAddressSeqRange other) {
		return (IPv6AddressSeqRange) super.join(other);
	}
	
	@Override
	public IPv6AddressSeqRange[] subtract(IPAddressSeqRange other) {
		return (IPv6AddressSeqRange[]) super.subtract(other);
	}
	@Override
	public IPv6AddressSeqRange toSequentialRange() {
		return this;
	}
}
/*
 * Copyright 2016-2022 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.format.validate.HostIdentifierStringValidator;
import inet.ipaddr.format.validate.IPAddressProvider;
import inet.ipaddr.format.validate.Validator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.mac.MACAddress;
/**
 * Parses the string representation of an IP address.  Such a string can represent just a single address like 1.2.3.4 or 1:2:3:4:6:7:8, or a subnet like 1.2.0.0/16 or 1.*.1-3.1-4 or 1111:222::/64.
 * <p>
 * This supports a much wider range of address string formats than InetAddress.getByName.  It supports subnet formats, provides specific error messages, and allows more specific configuration.
 * <p>
 * You can control all of the supported formats using {@link IPAddressStringParameters.Builder} to build a parameters instance of {@link IPAddressStringParameters}.
 * When not using the constructor that takes a {@link IPAddressStringParameters}, a default instance of {@link IPAddressStringParameters} is used that is generally permissive.
 * <p>
 * <h2>Supported formats</h2>
 * Both IPv4 and IPv6 are supported.
 * <p>
 * Subnets are supported:
 * <ul>
 * <li>wildcards '*' and ranges '-' (for example 1.*.2-3.4), useful for working with subnets</li>
 * <li>the wildcard '*' can span multiple segments, so you can represent all addresses with '*', all IPv4 with '*.*', or all IPv6 with '*:*'</li>
 * <li>SQL wildcards '%' and '_', although '%' is considered an SQL wildcard only when it is not considered an IPv6 zone indicator</li>
 * <li>CIDR network prefix length addresses, like 1.2.0.0/16, which is equivalent to 1.2.*.* (all-zero hosts are the full subnet, non-zero hosts are single addresses)</li>
 * <li>address/mask pairs, in which the mask is applied to the address, like 1.2.3.4/255.255.0.0, which is also equivalent to 1.2.*.*</li>
 * </ul>
 * <p>
 * You can combine these variations, such as 1.*.2-3.4/255.255.255.0
 * <p>
 * IPv6 is fully supported:
 * <ul>
 * <li>IPv6 addresses like ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</li>
 * <li>IPv6 zones or scope identifiers, like ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff%zone</li>
 * <li>IPv6 mixed addresses are supported, which are addresses for which the last two IPv6 segments are represented as IPv4, like ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255</li>
 * <li>IPv6 compressed addresses like ::1</li>
 * <li>A single value of 32 hex digits like 00aa00bb00cc00dd00ee00ff00aa00bb with or without a preceding hex delimiter 0x</li>
 * <li>A base 85 address comprising 20 base 85 digits like 4)+k&amp;C#VzJ4br&gt;0wv%Yp as in rfc 1924 https://tools.ietf.org/html/rfc1924</li>
 * <li>Binary, preceded by 0b, either with binary segments that comprise all 16 bits like ::0b0000111100001111 or a single segment address of 0b followed by 128 binary bits.
 * </ul>
 * <p>
 * All of the above subnet variations work for IPv6, whether network prefix lengths, masks, ranges or wildcards.
 * Similarly, all the above subnet variations work for any supported IPv4 format, such as the standard dotted-decimal IPv4 format as well as the inet_aton formats listed below.
 * <p>
 * This class support all address formats of the C routine inet_pton and the Java method java.net.InetAddress.getByName.
 * This class supports all IPv4 address formats of the C routine inet_aton as follows:
 * <ul>
 * <li>IPv4 hex: 0x1.0x2.0x3.0x4 (0x prefix)</li>
 * <li>IPv4 octal: 01.02.03.0234.  Note this clashes with the same address interpreted as dotted decimal</li>
 * <li>3-part IPv4: 1.2.3 (which is interpreted as 1.2.0.3 (ie the third part covers the last two)</li>
 * <li>2-part IPv4: 1.2 (which is interpreted as 1.0.0.2 (ie the 2nd part covers the last 3)</li>
 * <li>1-part IPv4: 1 (which is interpreted as 0.0.0.1 (ie the number represents all 4 segments, and can be any number of digits less than the 32 digits which would be interpreted as IPv6)</li>
 * <li>hex or octal variants of 1, 2, and 3 part, such as 0xffffffff (which is interpreted as 255.255.255.255)</li>
 * </ul>
 * Also supported are binary segments of a 0b followed by binary digits like 0b1.0b1010.2.3, or a single segment address of 0b followed by all 32 bits.
 * <br>
 * inet_aton (and this class) allows mixing octal, hex and decimal (e.g. 0xa.11.013.11 which is equivalent to 11.11.11.11).  
 * String variations using prefixes, masks, ranges, and wildcards also work for inet_aton style.
 * The same can be said of binary segments, they can be mixed with all other formats.
 * <p>
 * Note that there is ambiguity when supporting both inet_aton octal and dotted-decimal leading zeros, like 010.010.010.010 which can 
 * be interpreted as octal or decimal, thus it can be either 8.8.8.8 or 10.10.10.10, with the default behaviour using the former interpretation<p>
 * This behaviour can be controlled by {@link IPAddressStringParameters.Builder#getIPv4AddressParametersBuilder()} and 
 * {@link inet.ipaddr.ipv4.IPv4AddressStringParameters.Builder#allowLeadingZeros(boolean)} 
 * <p>
 * Some additional formats:
 * <ul>
 * <li>null or empty strings are interpreted as the loopback, in the same way as InetAddress.getByName interprets null or empty strings</li>
 * <li>as noted previously, the single wildcard address "*" represents all addresses both ipv4 and ipv6, 
 * although you need to give it some help when converting to IPAddress by specifying the IP version in {@link #getAddress(IPVersion)} or {@link #toAddress(IPVersion)}</li>
 * <li>specifying CIDR prefix lengths with no corresponding addresses are interpreted as the corresponding network mask.  For instance,
 *  /64 is interpreted as the 64 bit network mask (ie 64 ones followed by 64 zeros)</li>
 * </ul>
 * <p>
 * If you have an address in which segments have been delimited with commas, such as "1,2.3.4,5.6", you can parse this with {@link #parseDelimitedSegments(String)}
 * which gives an iterator of strings.  For "1,2.3.4,5.6" you will iterate through "1.3.4.6", "1.3.5.6", "2.3.4.6" and "2.3.5.6".
 * You can count the number of elements in such an iterator with {@link #countDelimitedAddresses(String)}.  
 * Each string can then be used to construct an IPAddressString.
 * <p>
 * <h2>Usage</h2>
 * Once you have constructed an IPAddressString object, you can convert it to an IPAddress object with various methods.  
 * It is as simple as:<br>
 * <pre><code>
 * {@link IPAddress} address = new {@link IPAddressString}("1.2.3.4").{@link #getAddress()};
 * </code></pre>
 * <p>
 * If your application takes user input IP addresses, you can validate with:
 * <pre><code>
 * try {
 *  {@link IPAddress} address = new IPAddressString("1.2.3.4").{@link #toAddress()};
 * } catch({@link AddressStringException} e) {
 *	//e.getMessage() provides description of validation failure
 * }
 * </code></pre>
 * Most address strings can be converted to an IPAddress object using {@link #getAddress()} or {@link #toAddress()}.  In most cases the IP version is determined by the string itself.
 * <p>
 * There are a few exceptions, cases in which the version is unknown or ambiguous, for which {@link #getAddress()} returns null:
 * <ul>
 * <li>strings which do not represent valid addresses (eg "bla")</li>
 * <li>ambiguous address strings (eg "/32" is a prefix that could be IPv4 or IPv6).  For such strings you can provide the IPv4/IPv6 version to {@link #getAddress(IPVersion)} to get an address.</li>
 * <li>the "all" address "*" which represents all IPv4 and IPv6 addresses.  For this string you can provide the IPv4/IPv6 version to {@link #getAddress(IPVersion)} to get an address representing either all IPv4 or all IPv6 addresses.</li>
 * <li>empty string "" is interpreted as the default loopback address.  You can provide the ipv4/ipv6 version to{@link #getAddress(IPVersion)}to get the loopback version of your choice.</li>
 * </ul>
 * <p>
 * The other exception is a subnet in which the range of values in a segment of the subnet are not sequential, for which {@link #getAddress()} throws {@link IncompatibleAddressException} because there is no single IPAddress value, there would be many.
 * An IPAddress instance requires that all segments can be represented as a range of values.
 * There are only two unusual circumstances when this can occur:
 * <ul>
 * <li>using masks on subnets specified with wildcard or range characters causing non-sequential segments such as the final IPv4 segment of 0.0.0.* with mask 0.0.0.128, 
 * this example translating to the two addresses 0.0.0.0 and 0.0.0.128, so the last IPv4 segment cannot be represented as a sequential range of values.</li>
 * <li>using wildcards or range characters in the IPv4 section of an IPv6 mixed address causing non-sequential segments such as the last IPv6 segment of ::ffff:0.0.*.0, 
 * this example translating to the addresses ::ffff:0:100, ::ffff:0:200, , ::ffff:0:300, ..., so the last IPv6 segment cannot be represented as a sequential range of values.</li>
 * </ul>
 * These exceptions do not occur with non-subnets (ie individual addresses), nor can they occur with standard CIDR prefix-based subnets.
 * <p>
 * This class is thread-safe.  In fact, IPAddressString objects are immutable.  
 * An IPAddressString object represents a single IP address representation that cannot be changed after construction.
 * Some of the derived state is created upon demand and cached, such as the derived IPAddress instances.
 * <p>
 * This class has a few methods with analogs in IPAddress, such as {@link #contains(IPAddressString)}, {@link #getSequentialRange()},
 * {@link #prefixEquals(IPAddressString)}, {@link #isIPv4()}, and {@link #isIPv6()}.
 * Such methods are provided to make creating the IPAddress instance unnecessary when no such IPAddress instance is needed for other reasons.  
 * <p>
 * For some methods, like {@link #getSequentialRange()} and {@link #getDivisionGrouping()},
 * there might not even be an associated IPAddress due to IncompatibleAddressException.  
 * However, this is generally only the case with subnets that have non-standard and unusual formats or masks.
 * 
 * @custom.core
 * @author sfoley
 *
 */
/*
 * The test class IPAddressTest and other test classes can be used to validate any changes to this class and others.
 * 
 * A nice summary exists at http://www.gestioip.net/docu/ipv6_address_examples.html
 * 
 * Some discussion of formats is https://tools.ietf.org/html/draft-main-ipaddr-text-rep-00
 * Discussion of theses formats: http://tools.ietf.org/html/draft-main-ipaddr-text-rep-02
 * RFCs of interest are 2732, 2373, 3986, 4291, 5952, 2765, 1918, 3513 (IPv4 rfcs 1123 0953) 1883 1884 (original spec of 3 string representations of IPv6), 4007 6874 for IPv6 zone identifier or scope id
 * Early ones: 2460, 2553, 1122, 1812
 * 
 * Nice cheat sheet for IPv6: http://www.roesen.org/files/ipv6_cheat_sheet.pdf
 * 
 * Nice summary on zones and parsing http://veithen.github.io/2013/12/30/how-to-correctly-parse-ipv6-addresses.html
 * 
 * Nice resource on IPv6 vs IPv4 and lots of stuff including MAC: 
 * https://communities.bmc.com/docs/DOC-19235
 * Another: https://www.midnightfreddie.com/ipv6-ipv4-similar.html
 * 
 * Some parsing code for various languages: https://rosettacode.org/wiki/Parse_an_IP_Address
 * http://www.cisco.com/c/en/us/support/docs/ip/routing-information-protocol-rip/13788-3.html
 */
public class IPAddressString implements HostIdentifierString, Comparable<IPAddressString> {
	private static final long serialVersionUID = 4L;
	/* 
	 * Generally permissive, settings are the default constants in IPAddressStringParameters.  
	 * % denotes a zone, not an SQL wildcard (allowZone is true), 
	 * and leading zeros are considered decimal, not octal (allow_inet_aton_octal is false).
	 */
	public static final IPAddressStringParameters DEFAULT_VALIDATION_OPTIONS = new IPAddressStringParameters.Builder().toParams();
	private static final IPAddressString ipv4MappedPrefix = new IPAddressString("::ffff:0:0/96");
	final IPAddressStringParameters validationOptions;
	
	/* the full original string address */
	final String fullAddr;
	
	// fields for validation state
	
	/* exceptions and booleans for validation - for type INVALID both of ipv6Exception and ipv4Exception are non-null */
	private AddressStringException validateException;
	// an object created by parsing that will provide the associated IPAddress(es)
	private IPAddressProvider addressProvider = IPAddressProvider.NO_TYPE_PROVIDER;
	
	/**
	 * Constructs an IPAddressString instance using the given String instance.
	 * 
	 * @param addr the address in string format, either IPv4 like a.b.c.d or IPv6 like a:b:c:d:e:f:g:h or a:b:c:d:e:f:h.i.j.k or a::b or some other valid IPv4 or IPv6 form.
	 * 		IPv6 addresses are allowed to terminate with a scope id which starts with a % symbol.
	 *		Both types of addresses can terminate with a network prefix value like a.b.c.d/24 or ::/24
	 *  	Optionally, you can specify just a network prefix value like /24, which represents the associated masks 255.255.255.0/24 or ffff:ff00::/24.
	 * <p>
	 *		Both IPv4 and IPv6 addresses can terminate with a mask instead of a prefix length, like a.b.c.d/255.0.0.0 or ::/ffff::
	 *		If a terminating mask is equivalent to a network prefix, then it will be the same as specifying the prefix, so a.b.c.d/16 is the same as a.b.c.d/255.255.0.0
	 *		If a terminating mask is not equivalent to a network prefix, then the mask will simply be applied to the address to produce a single address.
	 * <p>
	 *		You can also alter the addresses to include ranges using the wildcards * and -, such as 1.*.1-2.3.
	 */
	public IPAddressString(String addr) {
		this(addr, DEFAULT_VALIDATION_OPTIONS);
	}
	
	/**
	 * @param addr the address in string format
	 * 
	 * 	This constructor allows you to alter the default validation options.
	 */
	public IPAddressString(String addr, IPAddressStringParameters valOptions) {
		if(addr == null) {
			fullAddr = addr = "";
		} else {
			addr = addr.trim();
			fullAddr = addr;
		}
		this.validationOptions = valOptions;
	}
	/**
	 * Provides an address string instance for an existing address.
	 * <p> 
	 * Not all valid address strings can be converted to address objects,
	 * such as the all address"*", or empty strings "", or prefix only addresses like "/32",
	 * so it can be useful to maintain a set of address strings instances.
	 * <p>
	 * Even though the address exists already, the options provide the networks in use by the address, as well as options for creating new addresses from this address.
	 * 
	 * @param address
	 * @param network
	 */
	IPAddressString(String addrString, IPAddress address, IPAddressStringParameters valOptions) {
		validationOptions = valOptions; 
		fullAddr = addrString;
		addressProvider = address.getProvider();
	}
	void cacheAddress(IPAddress address) {
		if(addressProvider.isUninitialized()) {
			addressProvider = address.getProvider();
		}
	}
	public IPAddressStringParameters getValidationOptions() {
		return validationOptions;
	}
	/**
	 * Returns whether this address string has an associated prefix length.
	 * If so, the prefix length is given by {@link #getNetworkPrefixLength()}
	 * 
	 * @return whether this address string has an associated prefix length
	 */
	public boolean isPrefixed() {
		return getNetworkPrefixLength() != null;
	}
	/**
	 * If this address is a valid address with an associated network prefix length then this returns that prefix length, otherwise returns null.
	 * The prefix length may be expressed explicitly with the notation "\xx" where xx is a decimal value, or it may be expressed implicitly as a network mask such as /255.255.0.0
	 * 
	 * @return the prefix length or null
	 */
	public Integer getNetworkPrefixLength() {
		if(isValid()) {
			return addressProvider.getProviderNetworkPrefixLength();
		}
		return null;
	}
	
	/**
	 * If a mask was provided with this address string, this returns the resulting mask value.
	 * 
	 * @return
	 */
	public IPAddress getMask() {
		if(isValid()) {
			return addressProvider.getProviderMask();
		}
		return null;
	}
	
	/**
	 * Returns whether the address represents a valid specific IP address or subnet, either IPv4 or IPv6, 
	 * as opposed to an empty string, the address representing all addresses of all types, a prefix length, or an invalid format.
	 * 
	 * @return whether the address represents a valid specific IP address.
	 */
	public boolean isIPAddress() {
		return isValid() && addressProvider.isProvidingIPAddress();
	}
	/**
	 * Returns true if the string represents all IP addresses, such as the string "*"
	 * You can denote all IPv4 addresses with *.*, or all IPv6 addresses with *:*
	 * 
	 * @return whether the address represents the set all all valid IP addresses (as opposed to an empty string, a specific address, a prefix length, or an invalid format).
	 */
	public boolean isAllAddresses() {
		return isValid() && addressProvider.isProvidingAllAddresses();
	}
	
	/**
	 * Returns whether this address string represents only a prefix length with no associated address value,
	 * as opposed to an empty string, an address with or without a prefix length, or an invalid format.
	 * 
	 * @return whether the address represents a valid IP address network prefix length
	 */
	public boolean isPrefixOnly() {
		return isValid() && addressProvider.isProvidingPrefixOnly();
	}
	
	/**
	 * Returns true if the address string is empty (zero-length).
	 * @return
	 */
	public boolean isEmpty() {
		return isValid() && addressProvider.isProvidingEmpty();
	}
	
	/**
	 * Returns true if the address is IPv4 (with or without a network prefix, with or without wildcard segments).
	 * @return
	 */
	public boolean isIPv4() {
		return isValid() && addressProvider.isProvidingIPv4();
	}
	/**
	 * Returns true if the address is IPv6 (with or without a network prefix, with or without wildcard segments).
	 * @return
	 */
	public boolean isIPv6() {
		return isValid() && addressProvider.isProvidingIPv6();
	}
	/**
	 * Returns true if the address is an IPv6 IPv4-mapped address.
	 * @return
	 */
	public boolean isIPv4Mapped() {
		return isIPv6() && ipv4MappedPrefix.prefixEquals(this);
	}
	/**
	 * If this address string represents an IPv6 address, returns whether the lower 4 bytes were represented as IPv4
	 * @return
	 */
	public boolean isMixedIPv6() {
		return isIPv6() && addressProvider.isProvidingMixedIPv6();
	}
	
	/**
	 * If this address string represents an IPv6 address, returns whether the string was base 85
	 * @return
	 */
	public boolean isBase85IPv6() {
		return isIPv6() && addressProvider.isProvidingBase85IPv6();
	}
	
	/**
	 * Returns the IP address version if {@link #isIPAddress()} returns true, otherwise returns null
	 * 
	 * @return the version
	 */
	public IPVersion getIPVersion() {
		if(isValid()) {
			return addressProvider.getProviderIPVersion();// this can also be null
		}
		return null;
	}
	
	/**
	 * Returns whether this string represents a loopback IP address.
	 * 
	 * @see java.net.InetAddress#isLoopbackAddress()
	 */
	public boolean isLoopback() {
		IPAddress val = getAddress();
		return val != null && val.isLoopback();
	}
	/**
	 * Returns whether this string represents an IP address whose value is zero.
	 * 
	 */
	public boolean isZero() {
		IPAddress value = getAddress();
		return value != null && value.isZero();
	}
	/**
	 * Returns whether this is a valid address string format.
	 * 
	 * The accepted IP address formats are:
	 * an IPv4 address, an IPv6 address, a network prefix alone, the address representing all addresses of all types, or an empty string.
	 * If this method returns false, and you want more details, call validate() and examine the thrown exception.
	 * <p>
	 * see {@link #validate()} or {@link #getAddressStringException()}
	 * 
	 * @return whether this is a valid address string format
	 */
	public boolean isValid() {
		if(addressProvider.isUninitialized()) {
			try {
				validate();
				return true;
			} catch(AddressStringException e) {
				return false;
			}
		}
		return !addressProvider.isInvalid();
	}
	/**
	 * Returns the parse exception thrown by validate, rather than throwing it.
	 * If there is no AddressStringException, then the string is a valid format.
	 * However, IncompatibleAddressException can be thrown if the format cannot be translated into the desired result,
	 * whether that is an address, a sequential range, or a division grouping.
	 * The translation fails only for subnets with non-standard formats or non-standard masks.
	 * <p>
	 * See {@link #validate()} or {@link #isValid()}
	 * 
	 * @return the parsing exception, if there is one
	 */
	public AddressStringException getAddressStringException() {
		if(!addressProvider.isInvalid()) { // Avoid throwing the exception the second time with this check
			try {
				validate();
			} catch(AddressStringException e) { 
				return e;/* note that this exception is cached by validate */
			}
		}
		return validateException;
	}
	/**
	 * Validates that this string is a valid IPv4 address, and if not, throws an exception with a descriptive message indicating why it is not.
	 * @throws AddressStringException
	 */
	public void validateIPv4() throws AddressStringException {
		validate(IPVersion.IPV4);
		checkIPv4Exception();
	}
	/**
	 * Validates that this string is a valid IPv6 address, and if not, throws an exception with a descriptive message indicating why it is not.
	 * @throws AddressStringException
	 */
	public void validateIPv6() throws AddressStringException {
		validate(IPVersion.IPV6);
		checkIPv6Exception();
	}
	
	/**
	 * Validates that this string is a valid address, and if not, throws an exception with a descriptive message indicating why it is not.
	 * @throws AddressStringException
	 */
	@Override
	public void validate() throws AddressStringException {
		validate(null);
	}
	
	private void checkIPv4Exception() throws AddressStringException {
		IPVersion version = addressProvider.getProviderIPVersion();
		if(version != null && version.isIPv6()) {
			throw new AddressStringException("ipaddress.error.address.is.ipv6");
		} else if(validateException != null) {
			throw validateException;
		}
	}
	
	private void checkIPv6Exception() throws AddressStringException {
		IPVersion version = addressProvider.getProviderIPVersion();
		if(version != null && version.isIPv4()) {
			throw new AddressStringException("ipaddress.error.address.is.ipv4");
		} else if(validateException != null) {
			throw validateException;
		}
	}
	
	private boolean isValidated(IPVersion version) throws AddressStringException {
		if(!addressProvider.isUninitialized()) {
			if(version == null) {
				if(validateException != null) {
					throw validateException; // the two exceptions are the same, so we can choose either one
				}
			} else if(version.isIPv4()) {
				checkIPv4Exception();
			} else if(version.isIPv6()) {
				checkIPv6Exception();
			}
			return true;
		}
		return false;
	}
	protected HostIdentifierStringValidator getValidator() {
		return Validator.VALIDATOR;
	}
	
	private void validate(IPVersion version) throws AddressStringException {
		if(isValidated(version)) {
			return;
		}
		synchronized(this) {
			if(isValidated(version)) {
				return;
			}
			//we know nothing about this address.  See what it is.
			try {
				addressProvider = getValidator().validateAddress(this);
			} catch(AddressStringException e) {
				validateException = e;
				addressProvider = IPAddressProvider.INVALID_PROVIDER;
				throw e;
			} 
		}
	}
	/**
	 * Validates that the string has the format "/x" for a valid prefix length x.
	 * @param ipVersion IPv4, IPv6, or null if you do not know in which case it will be assumed that it can be either
	 * @param networkPrefixLength the network prefix length integer as a string, eg "24"
	 * @return the network prefix length
	 * @throws IncompatibleAddressException if invalid with an appropriate message
	 */
	public static int validateNetworkPrefixLength(IPVersion ipVersion, CharSequence networkPrefixLength) throws PrefixLenException {
		try {
			return Validator.VALIDATOR.validatePrefix(networkPrefixLength, ipVersion);
		} catch(AddressStringException e) {
			throw new PrefixLenException(networkPrefixLength, ipVersion, e);
		}
	}
	
	public static void validateNetworkPrefix(IPVersion ipVersion, int networkPrefixLength, boolean allowPrefixesBeyondAddressSize) throws PrefixLenException {
		boolean asIPv4 = (ipVersion != null && ipVersion.isIPv4());
		if(networkPrefixLength > (asIPv4 ? IPv4Address.BIT_COUNT : IPv6Address.BIT_COUNT)) {
			throw new PrefixLenException(networkPrefixLength, ipVersion);
		}
	}
	
	@Override
	public int hashCode() {
		if(isValid()) {
			try {
				return addressProvider.providerHashCode();
			} catch(IncompatibleAddressException e) {}
		}
		return toString().hashCode();
	}
	/**
	 * All address strings are comparable.  If two address strings are invalid, their strings are compared.
	 * Otherwise, address strings are compared according to which type or version of string, and then within each type or version
	 * they are compared using the comparison rules for addresses.
	 * 
	 * @param other
	 * @return
	 */
	@Override
	public int compareTo(IPAddressString other) {
		if(this == other) {
			return 0;
		}
		boolean isValid = isValid();
		boolean otherIsValid = other.isValid();
		if(isValid || otherIsValid) {
			try {
				return addressProvider.providerCompare(other.addressProvider);
			} catch(IncompatibleAddressException e) {}
		}
		return toString().compareTo(other.toString());
	}
	
	/**
	 * Similar to {@link #equals(Object)}, but instead returns whether the prefix of this address matches the same of the given address,
	 * using the prefix length of this address.
	 * <p>
	 * In other words, determines if the other address is in the same prefix subnet using the prefix length of this address.
	 * <p>
	 * It this address has no prefix length, returns false.  The other address need not have an associated prefix length for this method to return true.
	 * <p>
	 * If this address string or the given address string is invalid, returns false.
	 * 
	 * @param other
	 * @return
	 */
	public boolean prefixEquals(IPAddressString other) {
		// getting the prefix 
		if(other == this && !isPrefixOnly()) {
			return true;
		}
		if(!isValid()) {
			return false;
		}
		if(other.addressProvider.isUninitialized()) { // other not yet validated - if other is validated no need for this quick contains
			// do the quick check that uses only the String of the other, matching til the end of the prefix length, for performance
			Boolean directResult = addressProvider.prefixEquals(other.fullAddr);
			if(directResult != null) {
				return directResult.booleanValue();
			}
		}
		if(other.isValid()) {
			Boolean directResult = addressProvider.prefixEquals(other.addressProvider); 
			if(directResult != null) {
				return directResult.booleanValue();
			}
			IPAddress thisAddress = getAddress();
			if(thisAddress != null) {
				IPAddress otherAddress = other.getAddress();
				if(otherAddress != null) {
					return thisAddress.prefixEquals(otherAddress);
				}
			}
			// one or both addresses are null, so there is no prefix to speak of
		}
		return false;
	}
	
	/**
	 * Similar to {@link #prefixEquals(IPAddressString)}, but instead returns whether the prefix of this address contains the same of the given address,
	 * using the prefix length of this address.
	 * <p>
	 * In other words, determines if the other address is in one of the same prefix subnets using the prefix length of this address.
	 * <p>
	 * It this address has no prefix length, returns false.  The other address need not have an associated prefix length for this method to return true.
	 * <p>
	 * If this address string or the given address string is invalid, returns false.
	 * 
	 * @param other
	 * @return
	 */
	public boolean prefixContains(IPAddressString other) {
		if(other == this && !isPrefixOnly()) {
			return true;
		}
		if(!isValid()) {
			return false;
		}
		if(other.addressProvider.isUninitialized()) { // other not yet validated - if other is validated no need for this quick contains
			// do the quick check that uses only the String of the other, matching til the end of the prefix length, for performance
			Boolean directResult = addressProvider.prefixContains(other.fullAddr);
			if(directResult != null) {
				return directResult.booleanValue();
			}
		}
		if(other.isValid()) {
			Boolean directResult = addressProvider.prefixContains(other.addressProvider); 
			if(directResult != null) {
				return directResult.booleanValue();
			}
			IPAddress thisAddress = getAddress();
			if(thisAddress != null) {
				IPAddress otherAddress = other.getAddress();
				if(otherAddress != null) {
					return thisAddress.prefixContains(otherAddress);
				}
			}
			// one or both addresses are null, so there is no prefix to speak of
		}
		return false;
	}
	/**
	 * Two IPAddressString objects are equal if they represent the same set of addresses.
	 * Whether one or the other has an associated network prefix length is not considered.
	 * 
	 * If an IPAddressString is invalid, it is equal to another address only if the other address was constructed from the same string.
	 * 
	 */
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof IPAddressString) {
			IPAddressString other = (IPAddressString) o;	
			// if they have the same string, they must be the same,
			// but the converse is not true, if they have different strings, they can
			// still be the same because IPv6 addresses have many representations
			// and additional things like leading zeros can have an effect for IPv4
			
			// Also note that we do not call equals() on the validation options, this is intended as an optimization,
			// and probably better to avoid going through all the validation objects here
			boolean stringsMatch = toString().equals(other.toString());
			if(stringsMatch && validationOptions == other.validationOptions) {
				return true;
			}
			if(isValid()) {
				if(other.isValid()) {
					Boolean directResult = addressProvider.parsedEquals(other.addressProvider);
					if(directResult != null) {
						return directResult.booleanValue();
					}
					try {
						// When a value provider produces no value, equality and comparison are based on the enum IPType,
						// which can be null.
						return addressProvider.providerEquals(other.addressProvider);
					} catch(IncompatibleAddressException e) {
						return stringsMatch;
					}
				}
			} else if(!other.isValid()) {
				return stringsMatch; // Two invalid addresses are not equal unless strings match, regardless of validation options
			}
		}
		return false;
	}
	
	/**
	 * Returns whether the address subnet identified by this address string contains the address identified by the given string.
	 * <p>
	 * If this address string or the given address string is invalid then returns false.
	 * 
	 * @param other
	 * @return
	 */
	public boolean contains(IPAddressString other) {
		if(isValid()) {
			if(other == this) {
				return true;
			}
			if(other.addressProvider.isUninitialized()) { // other not yet validated - if other is validated no need for this quick contains
				//do the quick check that uses only the String of the other
				Boolean directResult = addressProvider.contains(other.fullAddr);
				if(directResult != null) {
					return directResult.booleanValue();
				}
			}
			if(other.isValid()) {
				// note the quick result also handles the case of "all addresses"
				Boolean directResult = addressProvider.contains(other.addressProvider);
				if(directResult != null) {
					return directResult.booleanValue();
				}
				IPAddress addr = getAddress();
				if(addr != null) {
					IPAddress otherAddress = other.getAddress();
					if(otherAddress != null) {
						return addr.contains(otherAddress);
					}
				}
			}
		}
		return false;
	}
	/**
	 * If this address string was constructed from a host address with prefix length, 
	 * then this provides just the host address, rather than the address 
	 * provided by {@link #getAddress()} that incorporates the prefix.
	 * <p>
	 * Otherwise this returns the same object as {@link #getAddress()}.
	 * <p>
	 * This method returns null for invalid formats, the equivalent method {@link #toHostAddress()} throws exceptions for invalid formats.
	 * 
	 * @return
	 */
	public IPAddress getHostAddress() {
		if(!addressProvider.isInvalid()) { // Avoid the exception the second time with this check
			try {
				return toHostAddress();
			} catch(AddressStringException e) { /* note that this exception is cached, it is not lost forever */
			} catch(IncompatibleAddressException e) { /* this will be rethrown each time attempting to construct address */ }
		}
		return null;
	}
	
	/**
	 * Similar to {@link #toAddress(inet.ipaddr.IPAddress.IPVersion)}, but returns null rather than throwing an exception with the address is invalid or does not match the supplied version.
	 * 
	 */
	public IPAddress getAddress(IPVersion version) {
		if(!addressProvider.isInvalid()) { // Avoid the exception the second time with this check
			try {
				return toAddress(version);
			} catch(AddressStringException e) { /* note that this exception is cached, it is not lost forever */
			} catch(IncompatibleAddressException e) { /* this will be rethrown each time attempting to construct address */ }
		}
		return null;
	}
	
	/**
	 * If this represents an ip address, returns that address.  Otherwise, returns null.
	 * <p>
	 * This method will return null for invalid formats.  Use {@link #toAddress()} for an equivalent method that throws exceptions for invalid formats.
	 * <p>
	 * If you have a prefix address and you wish to get only the host without the prefix, use {@link #getHostAddress()}
	 * 
	 * @return the address
	 */
	@Override
	public IPAddress getAddress() {
		if(!addressProvider.isInvalid()) { // Avoid the exception the second time with this check
			try {
				return toAddress();
			} catch(AddressStringException e) { /* note that this exception is cached, it is not lost forever */
			} catch(IncompatibleAddressException e) { /* this will be rethrown each time attempting to construct address */ }
		}
		return null;
	}
	
	/**
	 * Returns whether the addresses returned by this IPAddressString are sequential, 
	 * meaning that if any address has a numerical value that lies in between the numerical values of two addresses represented by this IPAddressString,
	 * then that address is also represented by this IPAddressString.  In other words, the represented range of address values is sequential.
	 * <p>
	 * When the IPAddressString is sequential, it can be represented exactly by the IPAddressSeqRange returned from {@link #getSequentialRange()}.
	 * In some cases, no IPAddress instance can be obtained from {@link #getAddress()} or {@link #toAddress()}, in the cases where {@link #toAddress()} throws IncompatibleAddressException,
	 * but if the IPAddressString is sequential, you can obtain a IPAddressSeqRange to represent the IPAddressString instead.
	 * 
	 * @return
	 */
	public boolean isSequential() {
		return isValid() && addressProvider.isSequential();
	}
	
	/**
	 * Returns a representation of the address string, the address string represented "as-is", converted to value ranges with bit sizes matching the original string. 
	 * The returned series has the same division count and division bit sizes as in the original string.
	 * The method does not attempt to convert to the standard segment counts or bit sizes of IPv4 or IPv6. 
	 * For the IPv4 or IPv6 representation, use {@link #getAddress()}. 
	 * <p>
	 * Examples of strings that do not have the standard segment counts and bit lengths include 
	 * IPv6 addresses in mixed IPv6/IPv4 format, compressed IPv6 addresses, IPv6 addresses expressed as a single segment, 
	 * IPv4 addresses in inet_aton form with fewer than 4 segments, and IPv4 or IPv6 addresses in which multiple segments are covered by the '*' wildcard.
	 * <p>
	 * The returned types is either IPAddressDivisionGrouping or IPAddressLargeDivisionGrouping in cases where one of the divisions is 64 bits or large.
	 * This does not return instances of IPAddress, for that you should call {@link #getAddress()} or {@link #toAddress()}
	 * <p>
	 * This can be useful for parsing formats that do not convert directly to a single instance of IPAddress, 
	 * such as ranges of non-segmented IPv6 address values like aaaabbbbccccddddeeeeffffaaaabbb-ffffeeeeddddccccbbbbaaaabbbbaaaa,
	 * which in most cases cannot be converted to 8 ipv6 segment ranges and thus cannot be converted to a single IPAddress instance.
	 * <p>
	 * If the string used to construct this object is not a known format (empty string, address, range of addresses, or prefix) then null is returned.
	 * <p>
	 * If the string used to construct this object is a valid subnet format with a non-standard mask, and the masked result has divisions that are not sequential ranges, then null is returned.
	 * <p>
	 * An equivalent method that throws exceptions for invalid or incompatible formats is {@link #toDivisionGrouping()}
	 * <p>
	 * @return
	 */
	public IPAddressDivisionSeries getDivisionGrouping() {
		if(!addressProvider.isInvalid()) { // Avoid the exception the second time with this check
			try {
				validate();
				return addressProvider.getDivisionGrouping();
			} catch(AddressStringException e) { /* note that this exception is cached, it is not lost forever */
			} catch(IncompatibleAddressException e) { /* this will be rethrown each time attempting to construct address */ }
		}
		return null;
	}
	
	/**
	 * Returns the range of sequential addresses from the lowest address specified in this address string to the highest.
	 * <p>
	 * Since not all IPAddressString instances describe a sequential series of addresses, 
	 * this does not necessarily match the exact set of addresses specified by the string.  
	 * For example, 1-2.3.4.1-2 produces the sequential range 1.3.4.1 to 2.3.4.2 that includes the address 1.255.255.2 not specified by the string.
	 * <p>
	 * The sequential range matches the same set of addresses as the address string or the address when {@link #isSequential()} is true.
	 * Otherwise, the range includes addresses not specified by the address string.
	 * <p>
	 * This method can also produce a range for a string for which no IPAddress instance can be created, 
	 * those cases where {@link #isValid()} returns true but {@link #toAddress()} throws IncompatibleAddressException and {@link #getAddress()} returns null.
	 * The range cannot be produced for the other cases where {@link #getAddress()} returns null, those that are version-ambiguous and do not throw IncompatibleAddressException,
	 * such as the all address '*' or the version-ambiguous prefix length '/32'.
	 * <p>
	 * This is similar to {@link #toSequentialRange()} except that for invalid address strings, null is returned rather than throwing an exception.
	 * @return
	 */
	public IPAddressSeqRange getSequentialRange() {
		if(!addressProvider.isInvalid()) { // Avoid the exception the second time with this check
			try {
				validate();
				return addressProvider.getProviderSeqRange();
			} catch(AddressStringException e) { /* note that this exception is cached, it is not lost forever */ }
			// catching IncompatibleAddressException not necessary since it is not thrown, once parsed there is always an upper and lower
		}
		return null;
	}
	
	/**
	 * Returns a representation of the address string, the address string represented "as-is", converted to value ranges with bit sizes matching the original string. 
	 * The returned series has the same division count and division bit sizes as in the original string.
	 * The method does not attempt to convert to the standard segment counts or bit sizes of IPv4 or IPv6. 
	 * For the IPv4 or IPv6 representation, use {@link #getAddress()}. 
	 * <p>
	 * If the string used to construct this object is not a known format (empty string, address, range of addresses, or prefix) then this method throws {@link AddressStringException}.
	 * <p>
	 * If the string used to construct this object is a valid subnet format with a non-standard mask, and the masked result has divisions that are not sequential ranges, then this method throws {@link IncompatibleAddressException}.
	 * <p>
	 * An equivalent method that does not throw exceptions for invalid or incompatible formats is {@link #getDivisionGrouping()}
	 * <p>
	 * Examples of strings that do not have the standard segment counts and bit lengths include 
	 * IPv6 addresses in mixed IPv6/IPv4 format, compressed IPv6 addresses, IPv6 addresses expressed as a single segment, 
	 * IPv4 addresses in inet_aton form with fewer than 4 segments, and IPv4 or IPv6 addresses in which multiple segments are covered by the '*' wildcard.
	 * <p>
	 * The returned type is either IPAddressDivisionGrouping or IPAddressLargeDivisionGrouping.  It is IPAddressLargeDivisionGrouping in cases where one of the divisions is 64 bits or large.
	 * This does not return instances of IPAddress, for that you should call {@link #getAddress()} or {@link #toAddress()}
	 * <p>
	 * This can be useful for parsing formats that do not convert directly to a single instance of IPAddress, 
	 * such as ranges of non-segmented IPv6 address values like aaaabbbbccccddddeeeeffffaaaabbb-ffffeeeeddddccccbbbbaaaabbbbaaaa,
	 * which in most cases cannot be converted to 8 ipv6 segment ranges and thus cannot be converted to a single IPAddress instance.
	 * 
	 * @return
	 */
	public IPAddressDivisionSeries toDivisionGrouping() throws AddressStringException, IncompatibleAddressException {
		validate();
		return addressProvider.getDivisionGrouping();
	}
	/**
	 * Returns the range of sequential addresses from the lowest address specified in this address string to the highest.
	 * <p>
	 * Since not all IPAddressString instances describe a sequential series of addresses, 
	 * this does not necessarily match the exact set of addresses listed by the string.  
	 * For example, 1-2.3.4.1-2 produces the sequential range 1.3.4.1 to 2.3.4.2 that includes the address 1.255.255.2 not specified by the string.
	 * <p>
	 * The sequential range matches the same set of addresses as the address string or the address when {@link #isSequential()} is true.
	 * Otherwise, the range includes addresses not specified by the address string.
	 * <p>
	 * This method can also produce a range for a string for which no IPAddress instance can be created.  This method does not throw IncompatibleAddressException. 
	 * This method does not throw for those cases where {@link #isValid()} returns true but {@link #toAddress()} throws IncompatibleAddressException and {@link #getAddress()} returns null.
	 * <p>
	 * There are some cases where this method returns null.  The range cannot be produced for the other cases where {@link #getAddress()} returns null, those that are version-ambiguous and do not throw IncompatibleAddressException,
	 * such as the all address '*' or the version-ambiguous prefix '/32'.
	 * <p>
	 * Keep in mind that all single addresses, all subnets using written in the canonical address formats, 
	 * and all subnets with standard network or host masks, all of these have an associated IPAddress instance.
	 * <p>
	 * The exceptional cases are those subnets represented in formats supported by IPAddressString that cannot be represented in the canonical formats but can be . 
	 * This includes IPv6 mixed address subnets that cannot be converted to canonical IPv6 format like ::0-1.2.0-1.4,
	 * subnets with non-standard masks like 0-2.2.3.4/2.0.0.0, and subnets represented with non-canonical segments like the IPv4 subnet 1.5000-6000
	 * or the IPv6 subnet 1234567890abcdef1234567890abcdef-1234567890abcdef1234567890abcdef.
	 * <p>
	 * This method is equivalent to {@link #getSequentialRange()} except that for invalid address string formats, AddressStringException is thrown by this method.
	 * <p>
	 * @return
	 */
	public IPAddressSeqRange toSequentialRange() throws AddressStringException {
		validate();
		return addressProvider.getProviderSeqRange();
	}
	/**
	 * If this address string was constructed from a string comprising of a host address with prefix length or mask, 
	 * then this provides just the host address, rather than the address with the prefix or mask applied that is
	 * provided by {@link #toAddress()}.
	 * <p>
	 * Otherwise this returns the same object as {@link #toAddress()}.
	 * <p>
	 * This method throws exceptions for invalid formats, the equivalent method {@link #getHostAddress()} will simply return null in such cases.
	 * <p>
	 * If this instance of IPAddressString did not originate from a string, but from an IPAddress, 
	 * then this will return an address that parses from a string to the same IPAddress (with prefix length added to the string if necessary to match).
	 * <p>
	 * This method is is intended to operate on the string that is wrapped by IPAddressString (visible from {@link #toString()})
	 * <p>
	 * @return
	 */
	public IPAddress toHostAddress() throws AddressStringException, IncompatibleAddressException {
		validate(); // call validate so that we throw consistently, cover type == INVALID, and ensure the addressProvider exists
		return addressProvider.getProviderHostAddress();
	}
	
	/**
	 * Produces the {@link IPAddress} of the specified address version corresponding to this IPAddressString.
	 * <p>
	 * In most cases the string indicates the address version and calling {@link #toAddress()} is sufficient, with a few exceptions.
	 * <p>
	 * When this object represents only a network prefix length, 
	 * specifying the address version allows the conversion to take place to the associated mask for that prefix length.
	 * <p>
	 * When this object represents all addresses, specifying the address version allows the conversion to take place 
	 * to the associated representation of all IPv4 or all IPv6 addresses.
	 * <p>
	 * When this object represents the empty string and that string is interpreted as a loopback, then it returns
	 * the corresponding loopback address.  If empty strings are not interpreted as loopback, null is returned.
	 * <p>
	 * When this object represents an ipv4 or ipv6 address, it returns that address if and only if that address matches the provided version.
	 * <p>
	 * If the string used to construct this object is an invalid format, 
	 * or a format that does not match the provided version, then this method throws {@link AddressStringException}.
	 * <p>
	 * @param version the address version that this address should represent.
	 * @return the address or null if the parsed address version does not match
	 * @throws AddressStringException
	 * @throws IncompatibleAddressException address in proper format cannot be converted to an address: for masks inconsistent with associated address range, or ipv4 mixed segments that cannot be joined into ipv6 segments
	 */
	public IPAddress toAddress(IPVersion version) throws AddressStringException, IncompatibleAddressException {
		validate(); // call validate so that we throw consistently, cover type == INVALID, and ensure the addressProvider exists
		return addressProvider.getProviderAddress(version);
	}
	/**
	 * Produces the {@link IPAddress} corresponding to this IPAddressString.  
	 * <p>
	 * If this object does not represent a specific IPAddress or a ranged IPAddress, null is returned,
	 * which may be the case if this object represents only a network prefix or if it represents the empty address string.
	 * <p>
	 * If the string used to construct this object is not a known format (empty string, address, range of addresses, or prefix) then this method throws {@link AddressStringException}.
	 * <p>
	 * An equivalent method that does not throw exception for invalid formats is {@link #getAddress()}
	 * <p>
	 * If you have a prefixed address and you wish to get only the host rather than the address with the prefix, use {@link #toHostAddress()}
	 * <p>
	 * 
	 * As long as this object represents a valid address (but not necessarily a specific address), this method does not throw.
	 * <p>
	 * @throws AddressStringException if the address format is invalid
	 * @throws IncompatibleAddressException if a valid address string representing multiple addresses cannot be represented<br>
	 * 	This happens only for masks inconsistent with the associated address ranges, or ranges in ipv4 mixed segments that cannot be joined into ipv6 segments
	 * 
	 */
	@Override
	public IPAddress toAddress() throws AddressStringException, IncompatibleAddressException {
		validate(); //call validate so that we throw consistently, cover type == INVALID, and ensure the addressProvider exists
		return addressProvider.getProviderAddress();
	}
	
	/**
	 * Increases or decreases prefix length to the next segment boundary of the given address version's standard segment boundaries.
	 * <p>
	 * This acts on address strings with an associated prefix length, whether or not there is also an associated address value, see {@link IPAddressString#isPrefixOnly()}.
	 * If there is no associated address value then the segment boundaries are considered to be at each byte, much like IPv4.
	 * <p>
	 * If the address string has prefix length 0 and represents all addresses of the same version,
	 * and the prefix length is being decreased, then the address representing all addresses of any version is returned.
	 * <p>
	 * Follows the same rules as {@link #adjustPrefixLength(int)} when there is an associated address value:<br>
	 * When prefix length is increased, the bits moved within the prefix become zero.
	 * When a prefix length is decreased, the bits moved outside the prefix become zero.
	 * 
	 * Also see {@link IPAddress#adjustPrefixBySegment(boolean)}
	 * @param nextSegment whether to move prefix to previous or following segment boundary
	 * @return
	 */
	public IPAddressString adjustPrefixBySegment(boolean nextSegment) {
		if(isPrefixOnly()) {
			// Use IPv4 segment boundaries
			int bitsPerSegment = IPv4Address.BITS_PER_SEGMENT;
			int existingPrefixLength = getNetworkPrefixLength();
			int newBits;
			if(nextSegment) {
				int adjustment = existingPrefixLength % bitsPerSegment;
				newBits = Math.min(IPv6Address.BIT_COUNT, existingPrefixLength + bitsPerSegment - adjustment);
			} else {
				int adjustment = ((existingPrefixLength - 1) % bitsPerSegment) + 1;
				newBits = Math.max(0, existingPrefixLength - adjustment);
			}
			return new IPAddressString(IPAddressNetwork.getPrefixString(newBits), validationOptions);
		}
		IPAddress address = getAddress();
		if(address == null) {
			return null;
		}
		Integer prefix = address.getNetworkPrefixLength();
		if(!nextSegment && prefix != null && prefix == 0 && address.isMultiple() && address.isPrefixBlock()) {
			return new IPAddressString(IPAddress.SEGMENT_WILDCARD_STR, validationOptions);
		}
		return address.adjustPrefixBySegment(nextSegment).toAddressString();
	}
	
	/**
	 * Increases or decreases prefix length by the given increment.
	 * <p>
	 * This acts on address strings with an associated prefix length, whether or not there is also an associated address value.
	 * <p>
	 * If the address string has prefix length 0 and represents all addresses of the same version,
	 * and the prefix length is being decreased, then the address representing all addresses of any version is returned.
	 * <p>
	 * When there is an associated address value and the prefix length is increased, the bits moved within the prefix become zero, 
	 * and if prefix length is extended beyond the segment series boundary, it is removed.
	 * When there is an associated address value 
	 * and the prefix length is decreased, the bits moved outside the prefix become zero.
	 * 
	 * Also see {@link IPAddress#adjustPrefixLength(int)}
	 * @param adjustment
	 * @return
	 */
	public IPAddressString adjustPrefixLength(int adjustment) {
		if(isPrefixOnly()) {
			int newBits = adjustment > 0 ? Math.min(IPv6Address.BIT_COUNT, getNetworkPrefixLength() + adjustment) : Math.max(0, getNetworkPrefixLength() + adjustment);
			return new IPAddressString(IPAddressNetwork.getPrefixString(newBits), validationOptions);
		}
		IPAddress address = getAddress();
		if(address == null) {
			return null;
		}
		if(adjustment == 0 && isPrefixed()) {
			return this;
		}
		Integer prefix = address.getNetworkPrefixLength();
		if(prefix != null && prefix + adjustment < 0 && address.isPrefixBlock()) {
			return new IPAddressString(IPAddress.SEGMENT_WILDCARD_STR, validationOptions);
		}
		return address.adjustPrefixLength(adjustment).toAddressString();
	}
	
	/**
	 * Given a string with comma delimiters to denote segment elements, this method will count the possible combinations.
	 * <p>
	 * For example, given "1,2.3.4,5.6" this method will return 4 for the possible combinations: "1.3.4.6", "1.3.5.6", "2.3.4.6" and "2.3.5.6"
	 * <p>
	 * @param str
	 * @return
	 */
	public static int countDelimitedAddresses(String str) {
		int segDelimitedCount = 0;
		int result = 1;
		for(int i = 0; i < str.length(); i++) {
			char c = str.charAt(i);
			if(isDelimitedBoundary(c)) {
				if(segDelimitedCount > 0) {
					result *= segDelimitedCount + 1;
					segDelimitedCount = 0;
				}
			} else if(c == SEGMENT_VALUE_DELIMITER) {
				segDelimitedCount++;
			}
		}
		if(segDelimitedCount > 0) {
			result *= segDelimitedCount + 1;
		}
		return result;
	}
	
	private static boolean isDelimitedBoundary(char c) {
		return c == IPv4Address.SEGMENT_SEPARATOR ||
				c == IPv6Address.SEGMENT_SEPARATOR ||
				c == Address.RANGE_SEPARATOR ||
				c == MACAddress.DASHED_SEGMENT_RANGE_SEPARATOR;
	}
	
	/**
	 * Given a string with comma delimiters to denote segment elements, this method will provide an iterator to iterate through the possible combinations.
	 * <p>
	 * For example, given "1,2.3.4,5.6" this will iterate through "1.3.4.6", "1.3.5.6", "2.3.4.6" and "2.3.5.6"
	 * <p>
	 * Another example: "1-2,3.4.5.6" will iterate through "1-2.4.5.6" and "1-3.4.5.6".
	 * <p>
	 * This method will not validate strings.  Each string produced can be validated using an instance of IPAddressString.
	 * 
	 * @param str
	 * @return
	 */
	public static Iterator<String> parseDelimitedSegments(String str) { 
		List<List<String>> parts = null;
		int lastSegmentStartIndex = 0;
		int lastPartIndex = 0;
		int lastDelimiterIndex = 0;
		boolean anyDelimited = false;
		List<String> delimitedList = null;
		for(int i = 0; i < str.length(); i++) {
			char c = str.charAt(i);
			if(isDelimitedBoundary(c)) {
				if(delimitedList != null) {
					if(parts == null) {
						parts = new ArrayList<List<String>>(8);
					}
					addParts(str, parts, lastSegmentStartIndex, lastPartIndex, lastDelimiterIndex, delimitedList, i);
					lastPartIndex = i;
					delimitedList = null;
				}
				lastSegmentStartIndex = lastDelimiterIndex = i + 1; 
			} else if(c == SEGMENT_VALUE_DELIMITER) {
				anyDelimited = true;
				if(delimitedList == null) {
					delimitedList = new ArrayList<String>();
				}
				String sub = str.substring(lastDelimiterIndex, i);
				delimitedList.add(sub);
				lastDelimiterIndex = i + 1;
			}
		}
		if(anyDelimited) {
			if(delimitedList != null) {
				if(parts == null) {
					parts = new ArrayList<List<String>>(8);
				}
				addParts(str, parts, lastSegmentStartIndex, lastPartIndex, lastDelimiterIndex, delimitedList, str.length());
			} else {
				parts.add(Arrays.asList(new String[] {str.substring(lastPartIndex, str.length())}));
			}
			return iterator(parts);
		}
		return new Iterator<String>() {
			boolean done;
			
			@Override
			public boolean hasNext() {
				return !done;
			}
		    @Override
			public String next() {
		    	if(done) {
		    		throw new NoSuchElementException();
		    	}
		    	done = true;
		    	return str;
		    }
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	
	private static Iterator<String> iterator(List<List<String>> parts) {
		return new Iterator<String>() {
			private boolean done;
			final int partCount = parts.size();
			
			@SuppressWarnings("unchecked")
			private final Iterator<String> variations[] = new Iterator[partCount];
			
			private String nextSet[] = new String[partCount];  {
				updateVariations(0);
			}
			
			private void updateVariations(int start) {
				for(int i = start; i < partCount; i++) {
					variations[i] = parts.get(i).iterator();
					nextSet[i] = variations[i].next();
				}
			}
			
			@Override
			public boolean hasNext() {
				return !done;
			}
			
		    @Override
			public String next() {
		    	if(done) {
		    		throw new NoSuchElementException();
		    	}
		    	StringBuilder result = new StringBuilder();
		    	for(int i = 0; i < partCount; i++) {
		    		result.append(nextSet[i]);
		    	}
		    	increment();
		    	return result.toString();
		    }
		    
		    private void increment() {
		    	for(int j = partCount - 1; j >= 0; j--) {
		    		if(variations[j].hasNext()) {
		    			nextSet[j] = variations[j].next();
		    			updateVariations(j + 1);
		    			return;
		    		}
		    	}
		    	done = true;
		    }
		    @Override
			public void remove() {
		    	throw new UnsupportedOperationException();
		    }
		};
	}
	private static void addParts(String str, List<List<String>> parts, int lastSegmentStartIndex, int lastPartIndex,
			int lastDelimiterIndex, List<String> delimitedList, int i) {
		String sub = str.substring(lastDelimiterIndex, i);
		delimitedList.add(sub);
		if(lastPartIndex != lastSegmentStartIndex) {
			parts.add(Arrays.asList(new String[] {str.substring(lastPartIndex, lastSegmentStartIndex)}));
		}
		parts.add(delimitedList);
	}
	/**
	 * Converts this address to a prefix length
	 * 
	 * @return the prefix of the indicated IP type represented by this address or null if this address is valid but cannot be represented by a network prefix length
	 * @throws AddressStringException if the address is invalid
	 */
	public String convertToPrefixLength() throws AddressStringException {
		IPAddress address = getAddress();
		Integer prefix;
		if(address == null) {
			prefix = getNetworkPrefixLength(); // handles prefix-only, but also handles cases of IncompatibleAddressException in which there is a prefix length
			if(prefix == null) {
				return null;
			}
		} else {
			prefix = address.getBlockMaskPrefixLength(true);
			if(prefix == null) {
				return null;
			}
		}
		return IPAddressSegment.toUnsignedString(prefix, 10, 
				new StringBuilder(IPAddressSegment.toUnsignedStringLength(prefix, 10) + 1).append(IPAddress.PREFIX_LEN_SEPARATOR)).toString();
	}
	private static String toNormalizedString(IPAddressProvider addressProvider) throws IncompatibleAddressException {
		String result;
		if(addressProvider.isProvidingAllAddresses()) {
			result = IPAddress.SEGMENT_WILDCARD_STR;
		} else if(addressProvider.isProvidingEmpty()) {
			result = "";
		} else if(addressProvider.isProvidingPrefixOnly()) {
			result = IPAddressNetwork.getPrefixString(addressProvider.getProviderNetworkPrefixLength());
		} else if(addressProvider.isProvidingIPAddress()) {
			result = addressProvider.getProviderAddress().toNormalizedString();
		} else {
			result = null;
		}
		return result;
	}
	
	@Override
	public String toNormalizedString() {
		if(isValid()) {
			try {
				return toNormalizedString(addressProvider);
			} catch(IncompatibleAddressException e) {}
		}
		return toString();
	}
	/**
	 * Gives us the original string provided to the constructor.  
	 * For variations on this string, call {@link #getAddress()}/{@link #toAddress()} and then use string methods on the address object.
	 */
	@Override
	public String toString() {
		return fullAddr;
	}
}
/*
 * Copyright 2016-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv4;
import java.util.Iterator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.AddressDivisionBase;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSegment;
/**
 * This represents a segment of an IPv4 address.  For IPv4, segments are 1 byte.  For IPv6, they are two bytes.
 * 
 * Like String and Integer and various others basic objects, segments are immutable, which also makes them thread-safe.
 * 
 * @author sfoley
 *
 */
public class IPv4AddressSegment extends IPAddressSegment implements Iterable<IPv4AddressSegment> {
	
	private static final long serialVersionUID = 4L;
	/**
	 * When printed with the default radix of 10, the max number of characters per segment
	 */
	public static final int MAX_CHARS = 3;
	/**
	 * Constructs a segment of an IPv4 address with the given value.
	 * 
	 * @throws AddressValueException if value is negative or too large
	 * @param value the value of the segment
	 */
	public IPv4AddressSegment(int value) throws AddressValueException {
		super(value);
		if(value > IPv4Address.MAX_VALUE_PER_SEGMENT) {
			throw new AddressValueException(value);
		}
	}
	
	/**
	 * Constructs a segment of an IPv4 address.
	 * 
	 * @throws AddressValueException if value or prefix length is negative or too large
	 * @param value the value of the segment.  If the segmentPrefixLength is non-null, the network prefix of the value is used, and the segment represents all segment values with the same network prefix.
	 * @param segmentPrefixLength the segment prefix, which can be null
	 */
	public IPv4AddressSegment(int value, Integer segmentPrefixLength) throws AddressValueException {
		super(value, segmentPrefixLength);
		if(value > IPv4Address.MAX_VALUE_PER_SEGMENT) {
			throw new AddressValueException(value);
		}
		if(segmentPrefixLength != null && segmentPrefixLength > IPv4Address.BIT_COUNT) {
			throw new PrefixLenException(segmentPrefixLength);
		}
	}
	
	/**
	 * Constructs a segment of an IPv4 address that represents a range of values.
	 * 
	 * @throws AddressValueException if either lower or upper value or prefix length is negative or too large
	 * @param segmentPrefixLength the segment prefix length, which can be null.    If segmentPrefixLength is non-null, this segment represents a range of segment values with the given network prefix length.
	 * @param lower the lower value of the range of values represented by the segment.  If segmentPrefixLength is non-null, the lower value becomes the smallest value with the same network prefix.
	 * @param upper the upper value of the range of values represented by the segment.  If segmentPrefixLength is non-null, the upper value becomes the largest value with the same network prefix.
	 */
	public IPv4AddressSegment(int lower, int upper, Integer segmentPrefixLength) throws AddressValueException {
		super(lower, upper, segmentPrefixLength);
		if(getUpperSegmentValue() > IPv4Address.MAX_VALUE_PER_SEGMENT) {
			throw new AddressValueException(getUpperSegmentValue());
		}
		if(segmentPrefixLength != null && segmentPrefixLength > IPv4Address.BIT_COUNT) {
			throw new PrefixLenException(segmentPrefixLength);
		}
	}
	
	@Override
	public long getMaxValue() {
		return IPv4Address.MAX_VALUE_PER_SEGMENT;
	}
	@Override
	public boolean isIPv4() {
		return true;
	}
	
	@Override
	public IPVersion getIPVersion() {
		return IPVersion.IPV4;
	}
	
	@Override
	protected byte[] getBytesImpl(boolean low) {
		return new byte[] {(byte) (low ? getSegmentValue() : getUpperSegmentValue())};
	}
	
	@Override
	protected int getSegmentNetworkMask(int bits) {
		return getNetwork().getSegmentNetworkMask(bits);
	}
	
	@Override
	protected int getSegmentHostMask(int bits) {
		return getNetwork().getSegmentHostMask(bits);
	}
	
	@Override
	public int getMaxSegmentValue() {
		return getMaxSegmentValue(IPVersion.IPV4);
	}
	
	protected IPv4AddressSegment toPrefixNormalizedSeg() {
		return getSegmentCreator().createSegment(getSegmentValue(), getUpperSegmentValue(), IPv4AddressSection.cacheBits(getBitCount()));
	}
	
	protected IPv4AddressSegment toPrefixedSegment(Integer segmentPrefixLength) {
		if(isChangedByPrefix(segmentPrefixLength, getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets())) {
			return super.toPrefixedSegment(segmentPrefixLength, getSegmentCreator());
		}
		return this;
	}
	@Override
	public IPv4AddressSegment toNetworkSegment(Integer segmentPrefixLength) {
		return toNetworkSegment(segmentPrefixLength, true);
	}
	
	@Override
	public IPv4AddressSegment toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength) {
		if(isNetworkChangedByPrefix(segmentPrefixLength, withPrefixLength)) {
			return super.toNetworkSegment(segmentPrefixLength, withPrefixLength, getSegmentCreator());
		}
		return this;
	}
	@Override
	public IPv4AddressSegment toHostSegment(Integer bits) {
		if(isHostChangedByPrefix(bits)) {
			return super.toHostSegment(bits, getSegmentCreator());
		}
		return this;
	}
	@Override
	public IPv4AddressSegment getLower() {
		return getLowestOrHighest(this, getSegmentCreator(), true);
	}
	
	@Override
	public IPv4AddressSegment getUpper() {
		return getLowestOrHighest(this, getSegmentCreator(), false);
	}
	
	@Override
	public IPv4AddressNetwork getNetwork() {
		return Address.defaultIpv4Network();
	}
	public IPv4AddressCreator getSegmentCreator() {
		return getNetwork().getAddressCreator();
	}
	
	@Override
	public Iterable<IPv4AddressSegment> getIterable() {
		return this;
	}
	
	Iterator<IPv4AddressSegment> iterator(boolean withPrefix) {
		IPv4AddressSegment original;
		if(!withPrefix && isPrefixed() && !isMultiple()) {
			original = withoutPrefixLength();
		} else {
			original = this;
		}
		return iterator(original, getSegmentCreator(), withPrefix ? getSegmentPrefixLength() : null, false, false);
	}
	@Override
	public Iterator<IPv4AddressSegment> iterator() {
		return iterator(!getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets());
	}
	
	@Override
	public AddressComponentSpliterator<IPv4AddressSegment> spliterator() {
		IPv4AddressCreator creator = getSegmentCreator();
		boolean isAllSubnets = getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		Integer segPrefLength = isAllSubnets ? null : getSegmentPrefixLength();
		int bitCount = getBitCount();
		return createSegmentSpliterator(
				this,
				getSegmentValue(),
				getUpperSegmentValue(),
				this::iterator,
				(isLowest, isHighest, value, upperValue) -> iterator(null, value, upperValue, bitCount, creator, segPrefLength, false, false),
				(value, upperValue) -> creator.createSegment(value, upperValue, segPrefLength));
	}
	@Override
	public Stream<IPv4AddressSegment> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv4AddressSegment> prefixBlockIterator() {
		return iterator(this, getSegmentCreator(), getSegmentPrefixLength(), true, true);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4AddressSegment> prefixBlockSpliterator() {
		Integer segPrefLength = getSegmentPrefixLength();
		if(segPrefLength == null) {
			return spliterator();
		}
		return prefixBlockSpliterator(segPrefLength);
	}
	
	@Override
	public Stream<IPv4AddressSegment> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv4AddressSegment> prefixIterator() {
		return iterator(this, getSegmentCreator(), getSegmentPrefixLength(), true, false);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4AddressSegment> prefixSpliterator() {
		Integer segPrefLength = getSegmentPrefixLength();
		if(segPrefLength == null) {
			return spliterator();
		}
		return prefixSpliterator(
				this,
				segPrefLength,
				getSegmentCreator(),
				this::prefixIterator);
	}
	@Override
	public Stream<IPv4AddressSegment> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv4AddressSegment> prefixBlockIterator(int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		return iterator(this, getSegmentCreator(), IPv4AddressSection.cacheBits(prefixLength), true, true);
	}
	
	@Override
	public AddressComponentSpliterator<IPv4AddressSegment> prefixBlockSpliterator(int segPrefLength) {
		return prefixBlockSpliterator(
				this,
				segPrefLength,
				getSegmentCreator(),
				this::prefixBlockIterator);
	}
	@Override
	public Stream<IPv4AddressSegment> prefixBlockStream(int segPrefLength) {
		return StreamSupport.stream(prefixBlockSpliterator(segPrefLength), false);
	}
	Iterator<IPv4AddressSegment> identityIterator() {
		return identityIterator(this);
	}
	
	@Override
	public int getBitCount() {
		return IPv4Address.BITS_PER_SEGMENT;
	}
	@Override
	public int getByteCount() {
		return IPv4Address.BYTES_PER_SEGMENT;
	}
	
	@Override
	public int getDefaultTextualRadix() {
		return IPv4Address.DEFAULT_TEXTUAL_RADIX;
	}
	
	@Override
	public int getMaxDigitCount() {
		return MAX_CHARS;
	}
	
	@Override
	public IPv4AddressSegment reverseBits(boolean perByte) {
		return reverseBits();
	}
	
	public IPv4AddressSegment reverseBits() {
		if(isMultiple()) {
			if(isReversibleRange(this)) {
				if(isPrefixed()) {
					AddressSegmentCreator<IPv4AddressSegment> creator = getSegmentCreator();
					return creator.createSegment(getSegmentValue(), getUpperSegmentValue(), null);
				}
				return this;
			}
			throw new IncompatibleAddressException(this, "ipaddress.error.reverseRange");
		}
		int oldVal = getSegmentValue();
		int newVal = reverseBits((byte) oldVal);
		if(oldVal == newVal && !isPrefixed()) {
			return this;
		}
		AddressSegmentCreator<IPv4AddressSegment> creator = getSegmentCreator();
		return creator.createSegment(newVal);
	}
	
	@Override
	public IPv4AddressSegment reverseBytes() {
		// Since a segment is already one byte, already reversed, but we do need to remove the prefix
		return removePrefix(this, false, getSegmentCreator());
	}
	
	@Override
	public IPv4AddressSegment toZeroHost() {
		return toZeroHost(this, getSegmentCreator());
	}
	
	@Override @Deprecated
	public IPv4AddressSegment removePrefixLength(boolean zeroed) {
		return removePrefix(this, zeroed, getSegmentCreator());
	}
	
	@Override @Deprecated
	public IPv4AddressSegment removePrefixLength() {
		return removePrefixLength(true);
	}
	
	@Override
	public IPv4AddressSegment withoutPrefixLength() {
		return removePrefix(this, false, getSegmentCreator());
	}
	@Override
	public boolean prefixContains(IPAddressSegment other, int segmentPrefixLength) {
		return this == other || (super.prefixContains(other, segmentPrefixLength) && other instanceof IPv4AddressSegment);
	}
	@Override
	public boolean prefixEquals(AddressSegment other, int segmentPrefixLength) {
		return this == other || (super.prefixEquals(other, segmentPrefixLength) && other instanceof IPv4AddressSegment);
	}
	@Override
	public boolean overlaps(AddressSegment other) {
		return this == other || (overlapsSeg(other) && other instanceof IPv4AddressSegment);
	}
	@Override
	public boolean contains(AddressSegment other) {
		return this == other || (containsSeg(other) && other instanceof IPv4AddressSegment);
	}
	
	@Override
	public boolean equals(Object other) {
		return this == other || (other instanceof IPv4AddressSegment && ((IPv4AddressSegment) other).isSameValues((AddressSegment) this));
	}
	
	@Override
	protected boolean isSameValues(AddressDivisionBase other) {
		return other instanceof IPv4AddressSegment && isSameValues((AddressSegment) other);
	}
	
	/**
	 * Joins with another IPv4 segment to produce a IPv6 segment.
	 * 
	 * @param creator
	 * @param low
	 * @return
	 */
	 public IPv6AddressSegment join(IPv6AddressCreator creator, IPv4AddressSegment low) throws IncompatibleAddressException {
		int shift = IPv4Address.BITS_PER_SEGMENT;
		Integer prefix = getJoinedSegmentPrefixLength(shift, getSegmentPrefixLength(), low.getSegmentPrefixLength());
		if(isMultiple()) {
			// if the high segment has a range, the low segment must match the full range, 
			// otherwise it is not possible to create an equivalent range when joining
			if(!low.isFullRange()) {
				throw new IncompatibleAddressException(this, low, "ipaddress.error.invalidMixedRange");
			}
		}
		return creator.createSegment(
				(getSegmentValue() << shift) | low.getSegmentValue(), 
				(getUpperSegmentValue() << shift) | low.getUpperSegmentValue(),
				prefix);
	}
	static Integer getJoinedSegmentPrefixLength(int bitsPerSegment, Integer highBits, Integer lowBits) {
		if(lowBits == null) {
			return null;
		}
		if(lowBits == 0) {
			return highBits;
		}
		return IPv4AddressSection.cacheBits(lowBits + bitsPerSegment);
	}
}
/*
 * Copyright 2016-2018 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
/**
 * An object for writing an IP address part string in a specific format.
 * 
 * @author sfoley
 */
public interface IPAddressStringWriter<T extends IPAddressStringDivisionSeries> extends AddressDivisionWriter {
	
	/**
	 * 
	 * @param addr
	 * @return the number of segment separators in the string produced by these params
	 */
	int getTrailingSeparatorCount(T addr);
	
	char getTrailingSegmentSeparator();
	
	/**
	 * 
	 * @param addr
	 * @return the string produced by these params
	 */
	String toString(T addr);
	
	/**
	 * 
	 * @param addr
	 * @return the string produced by these params
	 */
	String toString(T addr, CharSequence zone);
}
/*
 * Copyright 2016-2020 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.validate;
import java.io.Serializable;
import inet.ipaddr.Address;
import inet.ipaddr.AddressSection;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.HostIdentifierString;
/**
 * Has methods for creating addresses, segments and sections that are available to the parser.
 * 
 * @author sfoley
 *
 * @param <T>
 * @param <R>
 * @param <E>
 * @param <S>
 */
public abstract class ParsedAddressCreator<T extends Address, R extends AddressSection, E extends AddressSection, S extends AddressSegment> implements Serializable {
	
	private static final long serialVersionUID = 4L;
	
	public void clearCaches() {
		for(int i = 0; i < Validator.MASK_CACHE.length; i++) {
			Validator.MASK_CACHE[i] = null;
		}
	}
	
	public void setSegmentCaching(boolean enable) {}
	public abstract S[] createSegmentArray(int length);
	public abstract S createSegment(int lower, int upper, Integer segmentPrefixLength);
	/* 
	 * These methods (with "Internal" in the name) are for internal use only.  
	 * The originating IPAddressString or Host is cached inside the created address.
	 * Also, byte arrays are not cloned, they are used by the resulting address.
	 * Also, segment arrays are not cloned, they is used by the resulting address or address section.
	 */
	protected abstract S createSegmentInternal(int value, Integer segmentPrefixLength, CharSequence addressStr, int originalVal, boolean isStandardString, int lowerStringStartIndex, int lowerStringEndIndex);
	
	protected abstract S createRangeSegmentInternal(int lower, int upper, Integer segmentPrefixLength, CharSequence addressStr, int originalLower, int originalUpper, boolean isStandardString, boolean isStandardRangeString, int lowerStringStartIndex, int lowerStringEndIndex, int upperStringEndIndex);
	protected abstract R createSectionInternal(S segments[]);
	
	protected abstract R createPrefixedSectionInternal(S segments[], Integer prefix);
	
	protected abstract R createPrefixedSectionInternal(S segments[], Integer prefix, boolean singleOnly);
	protected R createSectionInternal(S segments[], E embeddedSection, Integer prefix, boolean singleOnly) {
		return createPrefixedSectionInternal(segments, prefix, singleOnly);
	}
	
	protected R createSectionInternal(S segments[], E embeddedSection) {
		return createSectionInternal(segments);
	}
	
	protected R createSectionInternal(S segments[], E embeddedSection, Integer prefix) {
		return createPrefixedSectionInternal(segments, prefix);
	}
	
	protected abstract T createAddressInternal(byte bytes[], CharSequence zone);
	
	protected abstract T createAddressInternal(R section, HostIdentifierString from);
	
	protected abstract T createAddressInternal(R section, CharSequence zone, HostIdentifierString from);
	
	protected T createAddressInternal(S segments[], HostIdentifierString from, Integer prefix) {
		return createAddressInternal(createPrefixedSectionInternal(segments, prefix), from);
	}
	
	protected T createAddressInternal(S segments[], CharSequence zone, HostIdentifierString from, Integer prefix) {
		return createAddressInternal(createPrefixedSectionInternal(segments, prefix), zone, from);
	}
	
	protected abstract T createAddressInternal(R section, CharSequence zone, HostIdentifierString from, T lower, T upper);
	
	protected abstract int getMaxValuePerSegment();
}
/*
 * Copyright 2018-2024 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.IPAddressSection.IPAddressSeqRangePrefixSpliterator;
import inet.ipaddr.IPAddressSection.IPAddressSeqRangeSpliterator;
import inet.ipaddr.IPAddressSection.SegFunction;
import inet.ipaddr.IPAddressSection.SeqRangeIteratorProvider;
import inet.ipaddr.format.AddressComponentRange;
import inet.ipaddr.format.IPAddressRange;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
/**
 * This class can be used to represent an arbitrary range of consecutive IP addresses.  
 * <p>
 * Note that the IPAddress and IPAddressString classes allow you to specify a range of values for each segment.
 * That allows you to represent single addresses, any address prefix subnet (eg 1.2.0.0/16 or 1:2:3:4::/64) or any subnet that can be represented with segment ranges (1.2.0-255.* or 1:2:3:4:*), see
 * {@link IPAddressString} for details.
 * <p>
 * IPAddressString and IPAddress cover all potential subnets and addresses that can be represented by a single address string of 4 or less segments for IPv4, and 8 or less segments for IPv6.
 * <p>
 * This class allows the representation of any sequential address range, including those that cannot be represented by IPAddress.
 * <p>
 * String representations include the full address for both the lower and upper bounds of the range.
 *  
 * @custom.core
 * @author sfoley
 *
 */
public abstract class IPAddressSeqRange implements IPAddressRange {
	
	private static final long serialVersionUID = 1L;
	public static final String DEFAULT_RANGE_SEPARATOR = " -> ";
	private static final IPAddressSeqRange EMPTY_RANGES[] = new IPAddressSeqRange[0];
	protected final IPAddress lower, upper;
	
	private transient BigInteger count;
	private transient int hashCode;
	protected <T extends IPAddress> IPAddressSeqRange(T first, T second, boolean preSet) {
		lower = first;
		upper = second;
	}
	protected <T extends IPAddress> IPAddressSeqRange(
			T first, 
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			UnaryOperator<T> prefixLenRemover) {
		boolean f;
		if((f = first.contains(other)) || other.contains(first)) {
			T addr = f ? prefixLenRemover.apply(first) : prefixLenRemover.apply(other);
			lower = getLower.apply(addr);
			upper = getUpper.apply(addr);
		} else {
			T firstLower = getLower.apply(first);
			T otherLower = getLower.apply(other);
			T firstUpper = getUpper.apply(first);
			T otherUpper = getUpper.apply(other);
			T lower = compareLowValues(firstLower, otherLower) > 0 ? otherLower : firstLower;
			T upper = compareLowValues(firstUpper, otherUpper) < 0 ? otherUpper : firstUpper;
			this.lower = prefixLenRemover.apply(lower);
			this.upper = prefixLenRemover.apply(upper);
		}
	}
	
	protected <T extends IPAddress> IPAddressSeqRange(
			T first, 
			T second) {
		lower = first;
		upper = second;
	}
	private static boolean versionsMatch(IPAddress one, IPAddress two) {
		if(one.getClass().equals(two.getClass())) {
			return true;
		}
		// here we use type checks and not: if(!lower.getIPVersion().equals(other.getIPVersion())) 
		// This is because we construct ranges based on type, 
		// all we need is both to be the same type IPvxAddress to be able to construct an IPvxAddressSeqRange,
		// so we might as well stick with that principle here.
		if(one instanceof IPv4Address) {
			return two instanceof IPv4Address;
		}
		return two instanceof IPv6Address;
	}
	
	private static int compareLowValues(IPAddress one, IPAddress two) {
		return AddressComparator.compareSegmentValues(false, one.getSection(), two.getSection());
	}
	@Override
	public BigInteger getCount() {
		BigInteger result = count;
		if(result == null) {
			count = result = getCountImpl();
		}
		return result;
	}
	@Override
	public boolean isMultiple() {
		BigInteger count = this.count;
		if(count == null) {
			return IPAddressRange.super.isMultiple();
		}
		return !count.equals(BigInteger.ONE);
	}
	/**
	 * 
	 * @param other the range to compare, which does not need to range across the same address space
	 * @return whether this range spans more addresses than the provided range.
	 */
	public boolean isMore(IPAddressSeqRange other) {
		return getCount().compareTo(other.getCount()) > 0;
	}
	protected BigInteger getCountImpl() {
		return IPAddressRange.super.getCount();
	}
	@Override
	public abstract Iterable<? extends IPAddress> getIterable();
	protected static int getNetworkSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getNetworkSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	protected static int getHostSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		return ParsedAddressGrouping.getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
	}
	/**
	 * Iterates through the range of prefix blocks in this range instance using the given prefix length.
	 * 
	 * @param prefLength
	 * @return
	 */
	@Override
	public abstract Iterator<? extends IPAddress> prefixBlockIterator(int prefLength);
	@Override
	public abstract AddressComponentRangeSpliterator<? extends IPAddressSeqRange, ? extends IPAddress> prefixBlockSpliterator(int prefLength);
	@Override
	public abstract Stream<? extends IPAddress> prefixBlockStream(int prefLength);
	protected static interface IPAddressSeqRangeSplitterSink<S, T>{
		void setSplitValues(S left, S right);
		
		S getAddressItem();
	};
	
	@FunctionalInterface
	protected static interface IPAddressSeqRangeIteratorProvider<S, T> extends SeqRangeIteratorProvider<S,T>{}
	
	protected static <S extends AddressComponentRange, T> AddressComponentRangeSpliterator<S, T> createSpliterator(
			S forIteration,
			Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
			IPAddressSeqRangeIteratorProvider<S, T> iteratorProvider,
			ToLongFunction<S> longSizer) {
		return new IPAddressSeqRangeSpliterator<S, T>(forIteration, splitter, iteratorProvider, longSizer);
	}
	
	protected static <S extends AddressComponentRange, T> AddressComponentRangeSpliterator<S, T> createSpliterator(
			S forIteration,
			Predicate<IPAddressSeqRangeSplitterSink<S, T>> splitter,
			IPAddressSeqRangeIteratorProvider<S, T> iteratorProvider,
			Function<S, BigInteger> sizer,
			Predicate<S> downSizer,
			ToLongFunction<S> longSizer) {
		return new IPAddressSeqRangeSpliterator<S, T>(forIteration, splitter, iteratorProvider, sizer, downSizer, longSizer);
	}
	protected static <S extends AddressComponentRange> AddressComponentSpliterator<S> createPrefixSpliterator(
			S forIteration,
			Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
			IPAddressSeqRangeIteratorProvider<S, S> iteratorProvider,
			ToLongFunction<S> longSizer) {
		return new IPAddressSeqRangePrefixSpliterator<S>(forIteration, splitter, iteratorProvider, longSizer);
	}
	
	protected static <S extends AddressComponentRange> AddressComponentSpliterator<S> createPrefixSpliterator(
			S forIteration,
			Predicate<IPAddressSeqRangeSplitterSink<S, S>> splitter,
			IPAddressSeqRangeIteratorProvider<S, S> iteratorProvider,
			Function<S, BigInteger> sizer,
			Predicate<S> downSizer,
			ToLongFunction<S> longSizer) {
		return new IPAddressSeqRangePrefixSpliterator<S>(forIteration, splitter, iteratorProvider, sizer, downSizer, longSizer);
	}
	
	protected static <R,A extends IPAddress> Iterator<R> rangedIterator(Iterator<A> iter) {
		return new Iterator<R>() {
			@Override
			public boolean hasNext() {
				return iter.hasNext();
			}
			@SuppressWarnings("unchecked")
			@Override
			public R next() {
				return (R) iter.next().toSequentialRange();
			}
		};
	}
	/**
	 * Iterates through the range of prefixes in this range instance using the given prefix length.
	 * <p>
	 * Since a range between two arbitrary addresses cannot always be represented with a single IPAddress instance,
	 * the returned iterator iterates through {@link IPAddressSeqRange} instances.
	 * <p>
	 * For instance, if iterating from 1.2.3.4 to 1.2.4.5 with prefix 8, the range shares the same prefix 1,
	 * but the range cannot be represented by the address 1.2.3-4.4-5 which does not include 1.2.3.255 or 1.2.4.0 both of which are in the original range.
	 * Nor can the range be represented by 1.2.3-4.0-255 which includes 1.2.4.6 and 1.2.3.3, both of which were not in the original range.
	 * An IPAddressSeqRange is thus required to represent that prefixed range.
	 * 
	 * @param prefixLength
	 * @return
	 */
	@Override
	public Iterator<? extends IPAddressSeqRange> prefixIterator(int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		if(!isMultiple()) {
			return new Iterator<IPAddressSeqRange>() {
				IPAddressSeqRange orig = IPAddressSeqRange.this;
				@Override
				public boolean hasNext() {
					return orig != null;
				}
			    @Override
				public IPAddressSeqRange next() {
			    	if(orig == null) {
			    		throw new NoSuchElementException();
			    	}
			    	IPAddressSeqRange result = orig;
			    	orig = null;
			    	return result;
			    }
			};
		}
		return new Iterator<IPAddressSeqRange>() {
			Iterator<? extends IPAddress> prefixBlockIterator = prefixBlockIterator(prefixLength);
			private boolean first = true;
			@Override
			public boolean hasNext() {
				return prefixBlockIterator.hasNext();
			}
		    @Override
			public IPAddressSeqRange next() {
		    	IPAddress next = prefixBlockIterator.next();
		    	if(first) {
		    		first = false;
		    		// next is a prefix block
		    		IPAddress lower = getLower();
		    		if(hasNext()) {
			    		if(!lower.includesZeroHost(prefixLength)) {
			    			return create(lower, next.getUpper());
			    		}
		    		} else {
		    			IPAddress upper = getUpper();
		    			if(!lower.includesZeroHost(prefixLength) || !upper.includesMaxHost(prefixLength)) {
		    				return create(lower, upper);
		    			}
		    		}
		    	} else if(!hasNext()) {
		    		IPAddress upper = getUpper();
		    		if(!upper.includesMaxHost(prefixLength)) {
		    			return create(next.getLower(), upper);
		    		}
		    	}
		    	return next.toSequentialRange();
		    }
		};
	}
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSeqRange> prefixSpliterator(int prefLength);
	
	@Override
	public abstract Stream<? extends IPAddressSeqRange> prefixStream(int prefLength);
	@FunctionalInterface
	protected interface SegValueComparator<T> {
	    boolean apply(T segmentSeries1, T segmentSeries2, int index);
	}
	/**
	 * Splits a sequential range into two.
	 * <p>
	 * Returns false if it cannot be done.
	 * 
	 * @param beingSplit
	 * @param transformer
	 * @param segmentCreator
	 * @param originalSegments
	 * @param networkSegmentIndex if this index matches hostSegmentIndex, splitting will attempt to split the network part of this segment
	 * @param hostSegmentIndex splitting will work with the segments prior to this one
	 * @param prefixLength
	 * @return
	 */
	protected static <I extends IPAddressSeqRange, T extends IPAddressRange, S extends AddressSegment> boolean split(
			IPAddressSeqRangeSplitterSink<I, T> sink,
			BiFunction<S[], S[], I> transformer,
			AddressSegmentCreator<S> segmentCreator,
			S originalSegmentsLower[],
			S originalSegmentsUpper[],
			int networkSegmentIndex, //for regular iterators (not prefix block), networkSegmentIndex is last segment (count - 1) - it is only instrumental with prefix iterators
			int hostSegmentIndex, // for regular iterators hostSegmentIndex is past last segment (count) - it is only instrumental with prefix iterators
			Integer prefixLength) {
		int i = 0;
		S lowerSeg, upperSeg;
		lowerSeg = upperSeg = null;
		boolean isSplit = false;
		for(; i < hostSegmentIndex; i++) {
			S segLower = originalSegmentsLower[i];
			S segUpper = originalSegmentsUpper[i];
			int lower = segLower.getSegmentValue();
			int upper = segUpper.getSegmentValue();
			// if multiple, split into two
			if(lower != upper) {
				isSplit = true;
				int size = upper - lower;
				int mid = lower + (size >>> 1);
				lowerSeg = segmentCreator.createSegment(mid);
				upperSeg = segmentCreator.createSegment(mid + 1);
				break;
			}
		}
		if(i == networkSegmentIndex && !isSplit) {
			// prefix or prefix block iterators: no need to differentiate, handle both as prefix, iteration will handle the rest
			S segLower = originalSegmentsLower[i];
			S segUpper = originalSegmentsUpper[i];
			int segBitCount = segLower.getBitCount();
			Integer pref = IPAddressSection.getSegmentPrefixLength(segBitCount, prefixLength, i);
			int shiftAdjustment = segBitCount - pref;
			int lower = segLower.getSegmentValue();
			int upper = segUpper.getSegmentValue();
			lower >>>= shiftAdjustment;
			upper >>>= shiftAdjustment;
			if(lower != upper) {
				isSplit = true;
				int size = upper - lower;
				int mid = lower + (size >>> 1);
				int next = mid + 1;
				mid = (mid << shiftAdjustment) | ~(~0 << shiftAdjustment);
				next <<= shiftAdjustment;
				lowerSeg = segmentCreator.createSegment(mid);
				upperSeg = segmentCreator.createSegment(next);
			}
		}
		if(isSplit) {
			int len = originalSegmentsLower.length;
			S lowerUpperSegs[] = segmentCreator.createSegmentArray(len);
			S upperLowerSegs[] = segmentCreator.createSegmentArray(len);
			System.arraycopy(originalSegmentsLower, 0, lowerUpperSegs, 0, i);
			System.arraycopy(originalSegmentsLower, 0, upperLowerSegs, 0, i);
			int j = i + 1;
			lowerUpperSegs[i] = lowerSeg;
			upperLowerSegs[i] = upperSeg;
			Arrays.fill(lowerUpperSegs, j, lowerUpperSegs.length, segmentCreator.createSegment(lowerSeg.getMaxSegmentValue()));
			Arrays.fill(upperLowerSegs, j, upperLowerSegs.length, segmentCreator.createSegment(0));
			sink.setSplitValues(transformer.apply(originalSegmentsLower, lowerUpperSegs), transformer.apply(upperLowerSegs, originalSegmentsUpper));
		}
		return isSplit;
	}
	@Override
	public abstract Iterator<? extends IPAddress> iterator();
	@Override
	public abstract AddressComponentRangeSpliterator<? extends IPAddressSeqRange, ? extends IPAddress> spliterator();
	
	@Override
	public abstract Stream<? extends IPAddress> stream();
	/*
	 * This iterator is used for the case where the range is non-multiple
	 */
	protected static <T extends Address, S extends AddressSegment> Iterator<T> iterator(T original, AddressCreator<T, ?, ?, S> creator) {
		return IPAddressSection.iterator(original, creator, null);
	}
	
	/*
	 This iterator is (not surprisingly) 2 to 3 times faster (based on measurements I've done) than an iterator that uses the increment method like:
	 
	 return iterator(a -> a.increment(1));
	 
	 protected Iterator<T> iterator(UnaryOperator<T> incrementor) {
	 	return new Iterator<T>() {
			BigInteger count = getCount();
			T current = lower;
					
			@Override
			public boolean hasNext() {
				return count.signum() != 0;
			}
			@Override
			public T next() {
				if(hasNext()) {
					T result = current;
					current = incrementor.apply(current);
					count = count.subtract(BigInteger.ONE);
					return result;
				}
				throw new NoSuchElementException();
			}
		};
	 }
	 */
	protected static <T extends IPAddress, S extends IPAddressSegment> Iterator<T> iterator(
			T lower,
			T upper,
			AddressCreator<T, ?, ?, S> creator,
			SegFunction<T, S> segProducer,
			SegFunction<S, Iterator<S>> segmentIteratorProducer,
			SegValueComparator<T> segValueComparator,
			int networkSegmentIndex,
			int hostSegmentIndex,
			SegFunction<S, Iterator<S>> prefixedSegIteratorProducer) {
		int divCount = lower.getSegmentCount();
		
		// at any given point in time, this list provides an iterator for the segment at each index
		ArrayList<Supplier<Iterator<S>>> segIteratorProducerList = new ArrayList<Supplier<Iterator<S>>>(divCount);
		
		// at any given point in time, finalValue[i] is true if and only if we have reached the very last value for segment i - 1
		// when that happens, the next iterator for the segment at index i will be the last
		boolean finalValue[] = new boolean[divCount + 1];
		
		// here is how the segment iterators will work:
		// the low and high values at each segment are low, high
		// the maximum possible values for any segment are min, max
		// we first find the first k >= 0 such that low != high for the segment at index k
		
		//	the initial set of iterators at each index are as follows:
		//    for i < k finalValue[i] is set to true right away.
		//		we create an iterator from seg = new Seg(low)
		//    for i == k we create a wrapped iterator from Seg(low, high), wrapper will set finalValue[i] once we reach the final value of the iterator
		//    for i > k we create an iterator from Seg(low, max)
		// 
		// after the initial iterator has been supplied, any further iterator supplied for the same segment is as follows:
		//    for i <= k, there was only one iterator, there will be no further iterator
		//    for i > k,
		//	  	if i == 0 or of if flagged[i - 1] is true, we create a wrapped iterator from Seg(low, high), wrapper will set finalValue[i] once we reach the final value of the iterator
		//      otherwise we create an iterator from Seg(min, max)
		//
		// By following these rules, we iterate through all possible addresses	
		boolean notDiffering = true;
		finalValue[0] = true;
		S allSegShared = null;
		for(int i = 0; i < divCount; i++) {
			SegFunction<S, Iterator<S>> segIteratorProducer;
			if(prefixedSegIteratorProducer != null && i >= networkSegmentIndex) {
				segIteratorProducer = prefixedSegIteratorProducer;
			} else {
				segIteratorProducer = segmentIteratorProducer;
			}
			S lowerSeg = segProducer.apply(lower, i);
			int indexi = i;
			if(notDiffering) {
				notDiffering = segValueComparator.apply(lower, upper, i);
				if(notDiffering) {
					// there is only one iterator and it produces only one value
					finalValue[i + 1] = true;
					Iterator<S> iterator = segIteratorProducer.apply(lowerSeg, i);
					segIteratorProducerList.add(() -> iterator);
				} else {
					// in the first differing segment the only iterator will go from segment value of lower address to segment value of upper address
					Iterator<S> iterator = segIteratorProducer.apply(
							creator.createSegment(lowerSeg.getSegmentValue(), upper.getSegment(i).getSegmentValue(), null), i);
					
					// the wrapper iterator detects when the iterator has reached its final value
					Iterator<S> wrappedFinalIterator = new Iterator<S>() {
						@Override
						public boolean hasNext() {
							return iterator.hasNext();
						}
						@Override
						public S next() {
							S next = iterator.next();
							if(!iterator.hasNext()) {
								finalValue[indexi + 1] = true;
							}
							return next;
						}
					};
					segIteratorProducerList.add(() -> wrappedFinalIterator);
				}
			} else {
				// in the second and all following differing segments, rather than go from segment value of lower address to segment value of upper address
				// we go from segment value of lower address to the max seg value the first time through
				// then we go from the min value of the seg to the max seg value each time until the final time,
				// the final time we go from the min value to the segment value of upper address
				// we know it is the final time through when the previous iterator has reached its final value, which we track
				
				// the first iterator goes from the segment value of lower address to the max value of the segment
				Iterator<S> firstIterator = segIteratorProducer.apply(creator.createSegment(lowerSeg.getSegmentValue(), lower.getMaxSegmentValue(), null), i);
				
				// the final iterator goes from 0 to the segment value of our upper address
				Iterator<S> finalIterator = segIteratorProducer.apply(creator.createSegment(0, upper.getSegment(i).getSegmentValue(), null), i);
				
				// the wrapper iterator detects when the final iterator has reached its final value
				Iterator<S> wrappedFinalIterator = new Iterator<S>() {
					@Override
					public boolean hasNext() {
						return finalIterator.hasNext();
					}
					@Override
					public S next() {
						S next = finalIterator.next();
						if(!finalIterator.hasNext()) {
							finalValue[indexi + 1] = true;
						}
						return next;
					}
				};
				if(allSegShared == null) {
					allSegShared = creator.createSegment(0, lower.getMaxSegmentValue(), null);
				}
				// all iterators after the first iterator and before the final iterator go from 0 the max segment value,
				// and there will be many such iterators
				S allSeg = allSegShared;
				Supplier<Iterator<S>> finalIteratorProducer = () -> finalValue[indexi] ?  wrappedFinalIterator : segIteratorProducer.apply(allSeg, indexi);
				segIteratorProducerList.add(() -> {
					//the first time through, we replace the iterator producer so the first iterator used only once
					segIteratorProducerList.set(indexi, finalIteratorProducer);
					return firstIterator;
				});
			}
		}
		IntFunction<Iterator<S>> iteratorProducer = iteratorIndex -> segIteratorProducerList.get(iteratorIndex).get();
		return IPAddressSection.iterator(null, creator,
				IPAddressSection.iterator(
						lower.getSegmentCount(),
						creator,
						iteratorProducer, 
						networkSegmentIndex,
						hostSegmentIndex,
						iteratorProducer)
			);
	}
	
	/**
	 * Returns the lowest address in the sequential range, the one with the lowest numeric value
	 */
	@Override
	public IPAddress getLower() {
		return lower;
	}
	
	/**
	 * Returns the highest address in the sequential range, the one with the highest numeric value
	 */
	@Override
	public IPAddress getUpper() {
		return upper;
	}
	
	public String toNormalizedString(String separator) {
		Function<IPAddress, String> stringer = IPAddress::toNormalizedString;
		return toString(stringer, separator, stringer);
	}
	/**
	 * Produces a normalized string for the address range.
	 * It has the format "lower -&gt; upper" where lower and upper are the normalized strings for the lowest and highest addresses in the range, given by {@link #getLower()} and {@link #getUpper()}.
	 */
	@Override
	public String toNormalizedString() {
		return toNormalizedString(DEFAULT_RANGE_SEPARATOR);
	}
	/**
	 * Produces a canonical string for the address range with the given separator string.
	 */
	public String toCanonicalString(String separator) {
		Function<IPAddress, String> stringer = IPAddress::toCanonicalString;
		return toString(stringer, separator, stringer);
	}
	/**
	 * Produces a canonical string for the address range.
	 * It has the format "lower -&gt; upper" where lower and upper are the canonical strings for the lowest and highest addresses in the range, given by {@link #getLower()} and {@link #getUpper()}.
	 */
	@Override
	public String toCanonicalString() {
		return toCanonicalString(DEFAULT_RANGE_SEPARATOR);
	}
	public String toString(Function<? super IPAddress, String> lowerStringer, String separator, Function<? super IPAddress, String> upperStringer) {
		return lowerStringer.apply(getLower()) + separator + upperStringer.apply(getUpper());
	}
	/**
	 * Produces the canonical string for the address, also available from {@link #toCanonicalString()}.
	 */
	@Override
	public String toString() {
		return toCanonicalString();
	}
	/**
	 * Returns the minimal-size prefix block that covers all the addresses in this range.
	 * The resulting block will have a larger count than this, unless this range already directly corresponds to a prefix block.
	 */
	@Override
	public abstract IPAddress coverWithPrefixBlock();
	
	@Override
	public abstract IPAddress[] spanWithPrefixBlocks();
	@Override
	public abstract IPAddress[] spanWithSequentialBlocks();
	
	/**
	 * Joins the given ranges into the fewest number of ranges.
	 * This method can handle null ranges, which are ignored.
	 * The returned array will never be null and will be sorted by ascending lowest range value. 
	 * 
	 * @param ranges
	 * @return
	 */
	public static IPAddressSeqRange[] join(IPAddressSeqRange... ranges) {
		if(ranges.length == 0) {
			return EMPTY_RANGES;
		}
		ranges = ranges.clone();
		// null entries are automatic joins
		int joinedCount = 0;
		for(int i = 0, j = ranges.length - 1; i <= j; i++) {
			if(ranges[i] == null) {
				joinedCount++;
				while(ranges[j] == null && j > i) {
					j--;
					joinedCount++;
				}
				if(j > i) {
					ranges[i] = ranges[j];
					ranges[j] = null;
					j--;
				}
			}
		}
		int len = ranges.length - joinedCount;
		Arrays.sort(ranges, 0, len, Address.ADDRESS_LOW_VALUE_COMPARATOR);
		for(int i = 0; i < len; ) {
			IPAddressSeqRange range = ranges[i];
			IPAddress currentLower = range.getLower();
			IPAddress currentUpper = range.getUpper();
			boolean didJoin = false;
			int j = i + 1;
			for(; j < len; j++) {
				IPAddressSeqRange range2 = ranges[j];
				IPAddress nextLower = range2.getLower();
				if(!versionsMatch(nextLower, currentUpper)) {
					break;
				}
				if(compareLowValues(currentUpper, nextLower) >= 0
						|| currentUpper.increment(1).equals(nextLower)) {
					// join them
					joinedCount++;
					IPAddress nextUpper = range2.getUpper();
					if(compareLowValues(currentUpper, nextUpper) < 0) {
						currentUpper = nextUpper;
					}
					ranges[j] = null;
					didJoin = true;
				} else break;
			}
			if(didJoin) {
				ranges[i] = range.create(currentLower, currentUpper);
			}
			i = j;
		}
		if(joinedCount == 0) {
			return ranges;
		}
		if(ranges.length == joinedCount) {
			return EMPTY_RANGES;
		}
		IPAddressSeqRange joined[] = new IPAddressSeqRange[ranges.length - joinedCount];
		if(joined.length > 0) {
			for(int i = 0, j = 0; ; i++) {
				IPAddressSeqRange range = ranges[i];
				if(range == null) {
					continue;
				}
				joined[j++] = range;
				if(j >= joined.length) {
					break;
				}
			}
		}
		return joined;
	}
	boolean isContainedBy(IPAddress other) {
		IPAddress lower = getLower(), upper = getUpper();
		if(!versionsMatch(lower, other)) {
			return false;
		}
		int segCount = lower.getSegmentCount();
		for(int i = 0; i < segCount; i++) {
			IPAddressSegment lowerSeg = lower.getSegment(i);
			IPAddressSegment upperSeg = upper.getSegment(i);
			int lowerSegValue = lowerSeg.getSegmentValue();
			int upperSegValue = upperSeg.getSegmentValue();
			IPAddressSegment otherSeg = other.getSegment(i);
			int otherSegLowerValue = otherSeg.getSegmentValue();
			int otherSegUpperValue = otherSeg.getUpperSegmentValue();
			if(lowerSegValue < otherSegLowerValue || upperSegValue > otherSegUpperValue) {
				return false;
			}
			if(lowerSegValue != upperSegValue) {
				for(int j = i + 1; j < segCount; j++) {
					otherSeg = other.getSegment(j);
					if(!otherSeg.isFullRange()) {
						return false;
					}
				}
				break;
			}
		}
		return true;
	}
	
	/**
	 * Returns true if this sequential range overlaps the given address or subnet.
	 * 
	 * @param other
	 * @return
	 */
	@Override
	public boolean overlaps(IPAddress other) {
		IPAddress lower = getLower(), upper = getUpper();
		if(!versionsMatch(lower, other)) {
			return false;
		}
		int segCount = lower.getSegmentCount();
		for(int i = 0; i < segCount; i++) {
			IPAddressSegment lowerSeg = lower.getSegment(i);
			IPAddressSegment upperSeg = upper.getSegment(i);
			int lowerSegValue = lowerSeg.getSegmentValue();
			int upperSegValue = upperSeg.getSegmentValue();
			IPAddressSegment otherSeg = other.getSegment(i);
			int otherSegLowerValue = otherSeg.getSegmentValue();
			int otherSegUpperValue = otherSeg.getUpperSegmentValue();
			if(lowerSegValue == upperSegValue) {
				if(lowerSegValue < otherSegLowerValue || lowerSegValue > otherSegUpperValue) {
					return false;
				}
			} else {
				if(otherSegLowerValue < upperSegValue && otherSegUpperValue > lowerSegValue) {
					return true;
				} else if(otherSegLowerValue == upperSegValue) {
					for(int j = i + 1; j < segCount; j++) {
						otherSeg = other.getSegment(j);
						upperSeg = upper.getSegment(j);
						upperSegValue = upperSeg.getSegmentValue();
						otherSegLowerValue = otherSeg.getSegmentValue();
						if(otherSegLowerValue < upperSegValue) {
							return true;
						} else if(otherSegLowerValue > upperSegValue) {
							return false;
						}
					}
					break;
				} else if(otherSegUpperValue == lowerSegValue) {
					for(int j = i + 1; j < segCount; j++) {
						otherSeg = other.getSegment(j);
						lowerSeg = lower.getSegment(j);
						lowerSegValue = lowerSeg.getSegmentValue();
						otherSegUpperValue = otherSeg.getUpperSegmentValue();
						if(otherSegUpperValue > lowerSegValue) {
							return true;
						} else if(otherSegUpperValue < lowerSegValue) {
							return false;
						}
					}
					break;
				} else {
					return false;
				}
			}
		}
		return true;
	}
	
	/**
	 * Returns true if this sequential range overlaps the given sequential range.
	 * 
	 * @param other
	 * @return
	 */
	@Override
	public boolean overlaps(IPAddressSeqRange other) {
		IPAddress otherLower = other.getLower();
		IPAddress upper = getUpper();
		if(!versionsMatch(upper, otherLower)) {
			return false;
		}
		return compareLowValues(otherLower, upper) <= 0 && compareLowValues(other.getUpper(), getLower()) >= 0;
	}
	// we choose to not make this public
	// it is simply wrong to do an instanceof in the IPAddressRange interface, it assumes you know all implementors, 
	// it will not work if/when someone adds a new implementation.
	// If you do not know how an IPAddressRange is implemented, can you do the contains?  
	// Yes, but only by iterating, which is damn ugly for large ranges.
	// Now that we have toSequentialRange() in IPAddressRange, it is easy to do this for sequential subnets.
	// And for non-sequential, there is no simple way of doing it, 
	// in IPAddress you need to either go through the segments, or you need to go through the sequential blocks,
	// and there is no general way to do it for any implementation of IPAddressRange.
	private boolean containsRange(IPAddressRange other) {
		IPAddress otherLower = other.getLower();
		IPAddress lower = getLower();
		if(!versionsMatch(lower, otherLower)) {
			return false;
		}
		return compareLowValues(otherLower, lower) >= 0 && compareLowValues(other.getUpper(), getUpper()) <= 0;
	}
	
	@Override
	public boolean contains(IPAddress other) {
		return containsRange(other);
	}
	
	@Override
	public boolean contains(IPAddressSeqRange other) {
		return containsRange(other);
	}
	/**
	 * Returns the distance of the given address from the initial value of this range.  Indicates where an address sits relative to the range ordering.
	 * <p>
	 * If within or above the range, it is the distance to the lower boundary of the sequential range.  If below the, returns the number of addresses following the address to the lower range boundary.
	 * <p>
	 * The method does not return null if this range does not contain the address.  You can call {@link #contains(IPAddress)} or you can compare with {@link #getCount()} to check for containment.
	 * An address is in the range if 0 &lt;= {@link #enumerate(IPAddress)} &lt; {@link #getCount()}.
	 * <p>
	 * Returns null when the argument is a multi-valued subnet. The argument must be an individual address.
	 * <p>
	 * If the given address does not have the same version or type as the addresses in this range, then null is returned.
	 */
	@Override
	public BigInteger enumerate(IPAddress other) {
		IPAddress lower = getLower();
		if(other == lower) {
			return BigInteger.ZERO;
		} else if(other == getUpper()) { 
			return getCount().subtract(BigInteger.ONE);
		}
		return lower.enumerate(other);
	}
	/**
	 * Returns whether the address or subnet represents a range of values that are sequential.
	 * <p>
	 * IP address sequential ranges are sequential by definition, so this returns true.
	 * 
	 * @return true
	 */
	@Override
	public boolean isSequential() {
		return true;
	}
	
	@Override
	public int hashCode() {
		int res = hashCode;
		if(res == 0) {
			res = 31 * getLower().hashCode() + getUpper().hashCode();
			hashCode = res;
		}
		return res;
	}
	/**
	 * Returns whether the given sequential address range is equal to this sequential address range.
 	 * Two sequential address ranges are equal if their lower and upper range boundaries are equal.
	 */
	@Override
	public boolean equals(Object o) {
		if(o instanceof IPAddressSeqRange) {
			IPAddressSeqRange otherRange = (IPAddressSeqRange) o;
				return getLower().equals(otherRange.getLower()) && getUpper().equals(otherRange.getUpper());
			}
			return false;
	}
	
	/**
	 * Returns the intersection of this range with the given range, a range which includes those addresses in both this and the given range.
	 * @param other
	 * @return
	 */
	public IPAddressSeqRange intersect(IPAddressSeqRange other) {
		IPAddress lower = getLower();
		IPAddress upper = getUpper();
		IPAddress otherLower = other.getLower();
		IPAddress otherUpper = other.getUpper();
		if(!versionsMatch(lower, otherLower)) {
			return null;
		}
		if(compareLowValues(lower, otherLower) <= 0) {
			if(compareLowValues(upper, otherUpper) >= 0) {
				return other;
			} else if(compareLowValues(upper, otherLower) < 0) {
				return null;
			}
			return create(otherLower, upper);
		} else if(compareLowValues(otherUpper, upper) >= 0) {
			return this;
		} else if(compareLowValues(otherUpper, lower) < 0) {
			return null;
		}
		return create(lower, otherUpper);
	}
	
	/**
	 * Joins two ranges if they are contiguous ranges.
	 * 
	 * If this range overlaps the given range,
	 * or if the highest value of the lower range is one below the lowest value of the higher range,
	 * then the two are joined into a new larger range that is returned.
	 * <p>
	 * Otherwise, null is returned.
	 * 
	 * @param other
	 * @return
	 */
	public IPAddressSeqRange join(IPAddressSeqRange other) {
		IPAddress lower = getLower();
		IPAddress upper = getUpper();
		IPAddress otherLower = other.getLower();
		IPAddress otherUpper = other.getUpper();
		if(!versionsMatch(lower, otherLower)) {
			return null;
		}
		int lowerComp = compareLowValues(lower, otherLower);
		if(!overlaps(other)) {
			if(lowerComp >= 0) {
				if(otherUpper.increment(1).equals(lower)) {
					return create(otherLower, upper);
				}
			} else {
				if(upper.increment(1).equals(otherLower)) {
					return create(lower, otherUpper);
				}
			}
			return null;
		}
		int upperComp = compareLowValues(upper, otherUpper);
		IPAddress lowestLower, highestUpper;
		if(lowerComp >= 0) {
			if(lowerComp == 0 && upperComp == 0) {
				return this;
			}
			lowestLower = otherLower;
		} else {
			lowestLower = lower;
		}
		highestUpper = upperComp >= 0 ? upper : otherUpper;
		return create(lowestLower, highestUpper);
	}
	/**
	 * Extend this sequential range to include all address in the given range, which can be an IPAddress or IPAddressSeqRange.
	 * If the argument has a different IP version than this, null is returned.
	 * Otherwise, this method returns the range that includes this range, the given range, and all addresses in-between.
	 * 
	 * @param other
	 * @return
	 */
	public IPAddressSeqRange extend(IPAddressRange other) {
		IPAddress lower = getLower();
		IPAddress upper = getUpper();
		IPAddress otherLower = other.getLower();
		IPAddress otherUpper = other.getUpper();
		if(!versionsMatch(lower, otherLower)) {
			return null;
		}
		int lowerComp = compareLowValues(lower, otherLower);
		int upperComp = compareLowValues(upper, otherUpper);
		if(lowerComp > 0) { // 
			if(upperComp <= 0) { // ol l u ou
				return other.toSequentialRange();
			}
			// ol l ou u or ol ou l u
			return create(otherLower, upper);
		}
		// lowerComp <= 0
		if(upperComp >= 0) { // l ol ou u
			return this;
		}
		return create(lower, otherUpper);// l ol u ou or l u ol ou
	}
	/**
	 * Subtracts the given range from this range, to produce either zero, one, or two address ranges that contain the addresses in this range and not in the given range.
	 * If the result has length 2, the two ranges are ordered by ascending lowest range value. 
	 * 
	 * @param other
	 * @return
	 */
	public IPAddressSeqRange[] subtract(IPAddressSeqRange other) {
		IPAddress lower = getLower();
		IPAddress upper = getUpper();
		IPAddress otherLower = other.getLower();
		IPAddress otherUpper = other.getUpper();
		if(!versionsMatch(lower, otherLower)) {
			return createSingle();
		}
		if(compareLowValues(lower, otherLower) < 0) {
			if(compareLowValues(upper, otherUpper) > 0) { // l ol ou u
				return createPair(lower, otherLower.increment(-1), otherUpper.increment(1), upper);
			} else {
				int comp = compareLowValues(upper, otherLower);
				if(comp < 0) { // l u ol ou
					return createSingle();
				}
				return createSingle(lower, otherLower.increment(-1)); // l ol u ou (includes l u == ol ou)
			}
		} else if(compareLowValues(otherUpper, upper) >= 0) { // ol l u ou
			return createEmpty();
		} else {
			int comp = compareLowValues(otherUpper, lower);
			if(comp < 0) {
				return createSingle(); // ol ou l u
			}
			return createSingle(otherUpper.increment(1), upper); // ol l ou u  (includes  ol ou == l u)
		}
	}
	
	protected abstract IPAddressSeqRange create(IPAddress lower, IPAddress upper);
	
	protected abstract IPAddressSeqRange[] createPair(IPAddress lower1, IPAddress upper1, IPAddress lower2, IPAddress upper2);
	
	protected abstract IPAddressSeqRange[] createSingle(IPAddress lower, IPAddress upper);
	
	protected abstract IPAddressSeqRange[] createSingle();
	
	protected abstract IPAddressSeqRange[] createEmpty();
	@Override
	public boolean containsPrefixBlock(int prefixLen) {
		IPAddressSection.checkSubnet(lower, prefixLen);
		int divCount = lower.getDivisionCount();
		int bitsPerSegment = lower.getBitsPerSegment();
		int i = getHostSegmentIndex(prefixLen, lower.getBytesPerSegment(), bitsPerSegment);
		if(i < divCount) {
			IPAddressSegment div = lower.getSegment(i);
			IPAddressSegment upperDiv = upper.getSegment(i);
			int segmentPrefixLength = IPAddressSection.getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLen, i);
			if(!div.containsPrefixBlock(div.getSegmentValue(), upperDiv.getSegmentValue(), segmentPrefixLength)) {
				return false;
			}
			for(++i; i < divCount; i++) {
				div = lower.getSegment(i);
				upperDiv = upper.getSegment(i);
				//is full range?
				if(!div.includesZero() || !upperDiv.includesMax()) {
					return false;
				}
			}
		}
		return true;
	}
	
	@Override
	public boolean containsSinglePrefixBlock(int prefixLen) {
		IPAddressSection.checkSubnet(lower, prefixLen);
		int prevBitCount = 0;
		int divCount = lower.getDivisionCount();
		for(int i = 0; i < divCount; i++) {
			IPAddressSegment div = lower.getSegment(i);
			IPAddressSegment upperDiv = upper.getSegment(i);
			int bitCount = div.getBitCount();
			int totalBitCount = bitCount + prevBitCount;
			if(prefixLen >= totalBitCount) {
				if(!div.isSameValues(upperDiv)) {
					return false;
				}
			} else  {
				int divPrefixLen = Math.max(0, prefixLen - prevBitCount);
				if(!div.containsSinglePrefixBlock(div.getSegmentValue(), upperDiv.getSegmentValue(), divPrefixLen)) {
					return false;
				}
				for(++i; i < divCount; i++) {
					div = lower.getSegment(i);
					upperDiv = upper.getSegment(i);
					//is full range?
					if(!div.includesZero() || !upperDiv.includesMax()) {
						return false;
					}
				}
				return true;
			}
			prevBitCount = totalBitCount;
		}
		return true;
	}
	
	@Override
	public int getBitCount() {
		return getLower().getBitCount();
	}
	@Override
	public byte[] getBytes() {
		return getLower().getBytes();
	}
	@Override
	public byte[] getBytes(byte[] bytes) {
		return getLower().getBytes(bytes);
	}
	@Override
	public byte[] getBytes(byte[] bytes, int index) {
		return getLower().getBytes(bytes, index);
	}
	@Override
	public byte[] getUpperBytes() {
		return getUpper().getUpperBytes();
	}
	@Override
	public byte[] getUpperBytes(byte[] bytes) {
		return getUpper().getUpperBytes(bytes);
	}
	@Override
	public byte[] getUpperBytes(byte[] bytes, int index) {
		return getUpper().getUpperBytes(bytes, index);
	}
	@Override
	public BigInteger getValue() {
		return getLower().getValue();
	}
	@Override
	public BigInteger getUpperValue() {
		return getUpper().getValue();
	}
	/**
	 * Returns whether this sequential range spans from the zero address to itself.
	 */
	@Override
	public boolean isZero() {
		return includesZero() && !isMultiple();
	}
	/**
	 * Returns whether this sequential range's lower value is the zero address.
	 */
	@Override
	public boolean includesZero() {
		return getLower().isZero();
	}
	/**
	 * Returns whether this sequential range spans from the highest address, the address whose bits are all ones, to itself.
	 */
	@Override
	public boolean isMax() {
		return includesMax() && !isMultiple();
	}
	/**
	 * Returns whether this sequential range's upper value is the highest address, the address whose bits are all ones.
	 */
	@Override
	public boolean includesMax() {
		return getUpper().isMax();
	}
}
/*
 * Copyright 2018-2022 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.validate;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.Objects;
import inet.ipaddr.Address;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.HostIdentifierString;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork;
import inet.ipaddr.IPAddressSection;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.IPAddressSeqRange;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.format.AddressItem;
import inet.ipaddr.format.IPAddressDivisionSeries;
import inet.ipaddr.format.large.IPAddressLargeDivision;
import inet.ipaddr.format.large.IPAddressLargeDivisionGrouping;
import inet.ipaddr.format.standard.IPAddressBitsDivision;
import inet.ipaddr.format.standard.IPAddressDivisionGrouping;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv4.IPv4AddressSegment;
import inet.ipaddr.ipv4.IPv4AddressSeqRange;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.ipv6.IPv6AddressSegment;
/**
 * The result from parsing a valid address string.  This can be converted into an {@link IPv4Address} or {@link IPv6Address} instance.
 * 
 * @author sfoley
 *
 */
public class ParsedIPAddress extends IPAddressParseData implements IPAddressProvider {
	private static final long serialVersionUID = 4L;
	private static final ExtendedMasker DEFAULT_MASKER = new ExtendedMasker(true);
	private static final ExtendedMasker DEFAULT_NON_SEQUENTIAL_MASKER = new ExtendedMasker(false);
	
	private static final ExtendedFullRangeMasker EXTENDED_FULL_RANGE_MASKERS[] = new ExtendedFullRangeMasker[(Long.SIZE << 1) + 1];
	private static final ExtendedFullRangeMasker EXTENDED_SEQUENTIAL_FULL_RANGE_MASKERS[] = new ExtendedFullRangeMasker[(Long.SIZE << 1) + 1];
	
	private static final WrappedMasker WRAPPED_FULL_RANGE_MASKERS[] = new WrappedMasker[Long.SIZE + 1];
	private static final WrappedMasker WRAPPED_SEQUENTIAL_FULL_RANGE_MASKERS[] = new WrappedMasker[Long.SIZE + 1];
	
	private static final FullRangeMasker FULL_RANGE_MASKERS[] = new FullRangeMasker[Long.SIZE + 1];
	private static final FullRangeMasker SEQUENTIAL_FULL_RANGE_MASKERS[] = new FullRangeMasker[Long.SIZE + 1];
	
	private static final BitwiseOrer DEFAULT_OR_MASKER = new BitwiseOrer(true);
	private static final BitwiseOrer DEFAULT_NON_SEQUENTIAL_OR_MASKER = new BitwiseOrer(false);
	private static final FullRangeBitwiseOrer FULL_RANGE_OR_MASKERS[] = new FullRangeBitwiseOrer[Long.SIZE + 1];
	private static final FullRangeBitwiseOrer SEQUENTIAL_FULL_RANGE_OR_MASKERS[] = new FullRangeBitwiseOrer[Long.SIZE + 1];
	private static final BigInteger ONE_EXTENDED = new BigInteger(1, new byte[] {1, 0, 0, 0, 0, 0, 0, 0, 0});
	private static final BigInteger HIGH_BIT = new BigInteger(1, new byte[] {(byte) 0x80, 0, 0, 0, 0, 0, 0, 0});
	private static final BigInteger ONE_SHIFTED[] = new BigInteger[64];
	private static final BigInteger ONE_SHIFTED_EXTENDED[] = new BigInteger[64];
	private static final BigInteger NETWORK_MASK_EXTENDED[] = new BigInteger[64];
	private static final BigInteger HOST_MASK_EXTENDED[] = new BigInteger[64];
	
	static class CachedIPAddresses<T extends IPAddress> implements Serializable {
		
		private static final long serialVersionUID = 4L;
		
		//address is 1.2.0.0/16 and hostAddress is 1.2.3.4 for the string 1.2.3.4/16
		protected T address, hostAddress;
		
		CachedIPAddresses() {}
		public CachedIPAddresses(T address) {
			this(address, address);
		}
		
		public CachedIPAddresses(T address, T hostAddress) {
			this.address = address;
			this.hostAddress = hostAddress;
		}
		
		public T getAddress() {
			return address;
		}
		
		public T getHostAddress() {
			return hostAddress;
		}
	}
	
	abstract class TranslatedResult<T extends IPAddress, R extends IPAddressSection> extends CachedIPAddresses<T> {
		private static final long serialVersionUID = 4L;
		
		private R section, hostSection, lowerSection, upperSection;
		
		private IncompatibleAddressException joinHostException, joinAddressException /* inet_aton, single seg */, mixedException, maskException;
		private IPAddressSeqRange range;
		private T rangeLower, rangeUpper;
		private IPAddressDivisionSeries series;
		abstract ParsedAddressCreator<T, R, ?, ?> getCreator();
		
		@Override
		public T getAddress() {
			if(address == null) {
				// If an address is present we use it to construct the range.
				// So we need only share the boundaries when they were constructed first.
				if(range == null) {
					address = getCreator().createAddressInternal(section, getZone(), originator);
				} else {
					address = getCreator().createAddressInternal(section, getZone(), originator, rangeLower, rangeUpper);
				}
			}
			return address;
		}
		
		boolean hasLowerSection() {
			return lowerSection != null;
		}
		
		boolean hasHostAddress() {
			return hostAddress != null;
		}
		
		boolean hasAddress() {
			return address != null;
		}
		@Override
		public T getHostAddress() {
			if(hostSection == null) {
				return getAddress();
			}
			if(hostAddress == null) {
				hostAddress = getCreator().createAddressInternal(hostSection, getZone(), null);
			}
			return hostAddress;
		}
		
		R getSection() {
			return section;
		}
		
		private CharSequence getZone() {
			return getQualifier().getZone();
		}
		
		boolean withoutSections() {
			return section == null;
		}
		
		boolean withoutAddressException() {
			return joinAddressException == null && mixedException == null && maskException == null;
		}
		
		boolean withoutRange() {
			return range == null;
		}
		
		boolean withoutGrouping() {
			return series == null;
		}
		
		IPAddressSeqRange createRange() {
			//we need to add zone in order to reuse the lower and upper
			rangeLower = getCreator().createAddressInternal(lowerSection, getZone(), null);
			rangeUpper = upperSection == null ? rangeLower : getCreator().createAddressInternal(upperSection, getZone(), null);
			return range = rangeLower.spanWithRange(rangeUpper);
		}
		
		// when this is used, the host address, regular address, and range boundaries are not used
		IPAddress getValForMask() {
			return getCreator().createAddressInternal(lowerSection, null, null);
		}
	}
	
	private final IPAddressStringParameters options;
	private final HostIdentifierString originator;
	
	private TranslatedResult<?,?> values;
	private Masker maskers[];
	private Masker mixedMaskers[];
	ParsedIPAddress(
			HostIdentifierString from, 
			CharSequence addressString,
			IPAddressStringParameters options) {
		super(addressString);
		this.options = options;
		this.originator = from;
	}
	
	private IPv6AddressCreator getIPv6AddressCreator() {
		return getParameters().getIPv6Parameters().getNetwork().getAddressCreator();
	}
	
	private IPv4AddressCreator getIPv4AddressCreator() {
		return getParameters().getIPv4Parameters().getNetwork().getAddressCreator();
	}
	
	@Override
	public boolean isProvidingIPAddress() {
		return true;
	}
	
	@Override
	public IPAddressProvider.IPType getType() {
		return IPType.from(getProviderIPVersion());
	}
	
	@Override
	public IPAddressStringParameters getParameters() {
		return options;
	}
	void createSections(boolean doAddress, boolean doRangeBoundaries, boolean withUpper) {
		IPVersion version = getProviderIPVersion();
		if(version.isIPv4()) {
			createIPv4Sections(doAddress, doRangeBoundaries, withUpper);
		} else if(version.isIPv6()) {
			createIPv6Sections(doAddress, doRangeBoundaries, withUpper);
		}
	}
	@Override
	public IPAddressSeqRange getProviderSeqRange() {
		TranslatedResult<?,?> val = values;
		if(val == null || val.range == null) {
			synchronized(this) {
				val = values;
				if(val == null || val.range == null) {
					if(val != null && !val.withoutSections() && val.withoutAddressException()) {
						val.range = val.getAddress().toSequentialRange();
					} else {
						createSections(false, true, true);
						val = values;
						// creates lower, upper, then range from the two
						val.createRange();
						if(isDoneTranslating()) {
							releaseSegmentData();
						}
					}
				}
			}
		}
		return val.range;
	}
	// This is for parsed addresses which are masks in and of themselves.
	// With masks, only the lower value matters.
	IPAddress getValForMask() {
		TranslatedResult<?,?> val = values;
		if(val == null || !val.hasLowerSection()) {
			synchronized(this) {
				val = values;
				if(val == null || !val.hasLowerSection()) {
					createSections(false, true, false);
					val = values;
					releaseSegmentData(); // As a mask value, we can release our data sooner, there will be no request for address or division grouping
				}
			}
		}
		// requests for masks are single-threaded, so locking no longer required
		return val.getValForMask();
	}
	
	// this is for parsed addresses which have associated masks
	@Override
	public IPAddress getProviderMask() {
		return getQualifier().getMaskLower();
	}
	boolean isDoneTranslating() {
		TranslatedResult<?,?> val = values;
		return !val.withoutSections() /* address sections created */ && 
				(val.withoutAddressException() /* range can be created from sections */
						|| !val.withoutRange() /* range already created (from sections or boundaries) */) &&
				!val.withoutGrouping();
	}
	TranslatedResult<?,?> getCachedAddresses(boolean forHostAddr)  {
		TranslatedResult<?,?> val = values;
		if(val == null || val.withoutSections()) {
			synchronized(this) {
				val = values;
				if(val == null || val.withoutSections()) {
					createSections(true, false, false);
					val = values;
					if(isDoneTranslating()) {
						releaseSegmentData();
					}
				} 
				if(forHostAddr) {
					val.getHostAddress();
				} else {
					val.getAddress();
				}
			}
		} else {
			if(forHostAddr ? !val.hasHostAddress() : !val.hasAddress()) {
				synchronized(this) {
					if(forHostAddr) {
						val.getHostAddress();
					} else {
						val.getAddress();
					}
				}
			}
		}
		return val;
	}
	@Override
	public IPAddress getProviderHostAddress() throws IncompatibleAddressException {
		TranslatedResult<?,?> addrs = getCachedAddresses(true);
		if(addrs.mixedException != null) {
			throw addrs.mixedException;
		} else if(addrs.joinHostException != null) {
			throw addrs.joinHostException;
		}
		return addrs.getHostAddress();
	}
	
	@Override
	public IPAddress getProviderAddress() throws IncompatibleAddressException {
		TranslatedResult<?,?> addrs = getCachedAddresses(false);
		if(addrs.mixedException != null) {
			throw addrs.mixedException;
		} else if(addrs.maskException != null) {
			throw addrs.maskException;
		} else if(addrs.joinAddressException != null) {
			throw addrs.joinAddressException;
		}
		return addrs.getAddress();
	}
	
	@Override
	public IPAddress getProviderAddress(IPVersion version) throws IncompatibleAddressException {
		IPVersion thisVersion = getProviderIPVersion();
		if(!version.equals(thisVersion)) {
			return null;
		}
		return getProviderAddress();
	}
	
	@Override
	public IPAddressDivisionSeries getDivisionGrouping() throws IncompatibleAddressException {
		TranslatedResult<?,?> val = values;
		IPAddressDivisionSeries grouping = null;
		if(val != null) {
			grouping = val.series;
			if(grouping != null) {
				return grouping;
			}
		}		
		if(val == null || (val.withoutSections() && val.withoutRange())) {
			// we need the bit lengths and maskers that are calculated when constructing,
			// so we construct here since not done already
			synchronized(this) {
				val = values;
				if(val == null || (val.withoutSections() && val.withoutRange())) {
					createSections(true, false, false); // create addresses
				}
			}
		}
		// at this point values is not null
		val = values;
		grouping = val.series;
		if(grouping == null) {
			synchronized(val) {
				grouping = val.series;
				if(grouping == null) {
					ParsedHostIdentifierStringQualifier qualifier = getQualifier();
					IPVersion version = getProviderIPVersion();
					int defaultRadix;
					IPAddressNetwork<?, ?, ?, ?, ?> network;
					if(version.isIPv4()) {
						defaultRadix = IPv4Address.DEFAULT_TEXTUAL_RADIX;
						network = getParameters().getIPv4Parameters().getNetwork();
					} else {
						defaultRadix = IPv6Address.DEFAULT_TEXTUAL_RADIX;
						network = getParameters().getIPv6Parameters().getNetwork();
					}
					PrefixConfiguration prefixConfiguration = network.getPrefixConfiguration();
					boolean mixed = isProvidingMixedIPv6();
					AddressParseData addrParseData = getAddressParseData();
					int segmentCount = addrParseData.getSegmentCount();
					int totalCount = segmentCount;
					if(mixed) {
						totalCount += mixedParsedAddress.getSegmentCount();
					}
					Integer prefLength = getPrefixLength(qualifier);
					IPAddress mask = getProviderMask();
					if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
						mask = null;//we don't do any masking if the mask is a subnet mask, instead we just map it to the corresponding prefix length
					}
					boolean hasMask = mask != null;
					boolean isPrefixSubnet = false;
					if(prefLength != null) {
						if(prefixConfiguration.allPrefixedAddressesAreSubnets()) {
							isPrefixSubnet = true;
						} else if(prefixConfiguration.zeroHostsAreSubnets()) {
							// Note: the mask is not needed for this check
							// This is because you can only have a prefix length with network mask
							// In such cases we convert the mask to the prefix length and do not apply the mask.
							// So here we do not apply the mask either.
							if(mixed) {
								int k = segmentCount;
								isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_LOWER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_LOWER)),
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_EXTENDED_LOWER)),
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_UPPER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_UPPER)),
										i -> (i < k ? addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER) : mixedParsedAddress.getValue(i - k, AddressParseData.KEY_EXTENDED_UPPER)),
										i -> (i < k ? addrParseData.getBitLength(i) : mixedParsedAddress.getBitLength(i - k)),
										totalCount,
										prefLength,
										prefixConfiguration,
										false);
							} else {
								isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
										i -> addrParseData.getValue(i, AddressParseData.KEY_LOWER),
										i -> addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER),
										i -> addrParseData.getValue(i, AddressParseData.KEY_UPPER),
										i -> addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER),
										i -> addrParseData.getBitLength(i),
										totalCount,
										prefLength,
										prefixConfiguration,
										false);
							}
						} else {
							isPrefixSubnet = false;
						}
					}
					boolean isLarge = false;
					for(int i = 0; i < segmentCount; i++) {
						int bitLength = addrParseData.getBitLength(i);
						if(bitLength >= Long.SIZE) {
							isLarge = true;
							break;
						}
					}
					boolean isMergedMixed;
					if(mixed && (isMergedMixed = addrParseData.isMergedMixed(segmentCount - 1))) {
						totalCount--;
						segmentCount--;
						if(!isLarge && addrParseData.getBitLength(segmentCount) + mixedParsedAddress.getBitLength(0) >= Long.SIZE) {
							isLarge = true;
						}
					} else {
						isMergedMixed = false;
					}
					long maskVal = 0, extendedMaskVal = 0;
					int maskBits = 0;
					if(hasMask) {
						// using the mask as an address allows us to line up the segments into two longs
						int bitsPerSegment = mask.getBitsPerSegment();
						for(int i = 0; i < IPv4Address.SEGMENT_COUNT; i++) {
							maskVal = (maskVal << bitsPerSegment) | mask.getSegment(i).getSegmentValue();
						}
						if(mask.isIPv6()) {
							extendedMaskVal = maskVal; maskVal = 0;
							int remainingSegs = IPv6Address.SEGMENT_COUNT >> 1;
							for(int i = 0; i < remainingSegs; i++) {
								maskVal = (maskVal << bitsPerSegment) | mask.getSegment(i + IPv4Address.SEGMENT_COUNT).getSegmentValue();
							}
							maskBits = bitsPerSegment * IPv6Address.SEGMENT_COUNT;
						} else {
							maskBits = bitsPerSegment * IPv4Address.SEGMENT_COUNT;
						}
					}
					int bitsSoFar = 0;
					int divRadix;
					if(isLarge) {
						IPAddressLargeDivision divs[] = new IPAddressLargeDivision[totalCount];
						for(int i = 0; i < totalCount; i++) {
							long lower, upper, extendedLower, extendedUpper;
							int bitLength;
							boolean isExtended;
							boolean isNotMixed = i < segmentCount;
							if(isNotMixed) {
								bitLength = addrParseData.getBitLength(i);
								isExtended = bitLength > Long.SIZE;
								if(addrParseData.isWildcard(i)) {
									extendedLower = lower = 0;
									if(isExtended) {
										upper = 0xffffffffffffffffL;
										int shift = bitLength - Long.SIZE;
										// shift must be 6 bits at most for this shift to work per the java spec (so it must be less than 2^6 = 64)
										extendedUpper = shift == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << shift);
									} else {
										extendedUpper = 0;
										// bitLength must be 6 bits at most for this shift to work per the java spec (so it must be less than 2^6 = 64)
										upper = bitLength == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << bitLength);
									}
								} else {
									lower = addrParseData.getValue(i, AddressParseData.KEY_LOWER);
									upper = addrParseData.getValue(i, AddressParseData.KEY_UPPER);
									extendedLower = addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER);
									extendedUpper = addrParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER);
								}
								divRadix = defaultRadix;
							} else if(isMergedMixed && i == segmentCount) {
								isNotMixed = true;
								// merge the last IPv6 segment with the first IPv4 segment
								bitLength = addrParseData.getBitLength(i) + mixedParsedAddress.getBitLength(0);
								extendedLower = lower = 0;
								isExtended = bitLength > Long.SIZE;
								if(isExtended) {
									upper = 0xffffffffffffffffL;
									// shift must be 6 bits at most for this shift to work per the java spec (so it must be less than 2^6 = 64)
									int shift = bitLength - Long.SIZE;
									extendedUpper = shift == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << shift);
								} else {
									// bitLength must be 6 bits at most for this shift to work per the java spec (so it must be less than 2^6 = 64)
									upper = bitLength == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << bitLength);
									extendedUpper = 0;
								}
								divRadix = defaultRadix;
							} else {
								int adjusted = i - segmentCount;
								bitLength = mixedParsedAddress.getBitLength(adjusted);
								isExtended = false;
								extendedLower = extendedUpper = 0;
								if(mixedParsedAddress.isWildcard(adjusted)) {
									lower = 0;
									upper =  ~(~0L << bitLength);
								} else {
									lower = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_LOWER);
									upper = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_UPPER);
								}
								divRadix = IPv4Address.DEFAULT_TEXTUAL_RADIX;
							}
							Integer divPrefixLength;
							if(prefLength == null) {
								divPrefixLength = null;
								if(hasMask) {
									ExtendedMasker masker = (ExtendedMasker) (isNotMixed ? maskers[i] : mixedParsedAddress.maskers[i]);
									if(!masker.isSequential()) {
										throw new IncompatibleAddressException(lower, upper, (extendedMaskVal << 64) | maskVal, "ipaddress.error.maskMismatch");
									}
									long divMask;
									if(isExtended) {
										// adjust the extended mask by shrinking it downwards
										// adjust lower mask by the same amount, copy in the upper mask too
										int extraMaskBits = maskBits - bitLength;
										long extendedDivMask = extendedMaskVal >>> extraMaskBits;
										divMask = (maskVal >>> extraMaskBits) | (extendedMaskVal << (Long.SIZE - extraMaskBits));
										extendedLower = masker.getExtendedMaskedLower(extendedLower, extendedDivMask);
										extendedUpper = masker.getExtendedMaskedUpper(extendedUpper, extendedDivMask);
										lower = masker.getMaskedLower(lower, divMask);
										upper = masker.getMaskedUpper(upper, divMask);
									} else {
										// same as below
										if(maskBits > Long.SIZE) {
											int extendedBits = maskBits - Long.SIZE;
											if(extendedBits >= bitLength) {
												divMask = extendedMaskVal >>> (extendedBits - bitLength);
											} else {
												int shortBits = bitLength - extendedBits;
												divMask = (extendedMaskVal << (shortBits)) | (maskVal >> (Long.SIZE - shortBits));
											}
										} else {
											divMask = maskVal >>> (maskBits - bitLength);
										}
										lower = masker.getMaskedLower(lower, divMask);
										upper = masker.getMaskedUpper(upper, divMask);
									}
									maskBits -= bitLength;
								}
							} else {
								divPrefixLength = ParsedAddressGrouping.getDivisionPrefixLength(bitLength, prefLength - bitsSoFar);
								if(isPrefixSubnet && divPrefixLength != null && divPrefixLength < bitLength) {
									// for values larger than 64 bits, the "extended" values are the upper (aka most significant, leftmost) bits
									int unextendedBitLength, unextendedDivPrefixLength;
									if(isExtended) {
										int extendedDivBitLength = bitLength - Long.SIZE;
										unextendedBitLength = Long.SIZE;
										if(divPrefixLength > extendedDivBitLength) {
											unextendedDivPrefixLength = divPrefixLength - extendedDivBitLength;
										} else {
											unextendedDivPrefixLength = 0;
											int shift = extendedDivBitLength - divPrefixLength;
											if(shift == Long.SIZE) {
												extendedLower = 0;
												extendedUpper = 0xffffffffffffffffL;
											} else {
												long networkMask = ~0L << shift;
												extendedLower = extendedLower & networkMask;
												extendedUpper = extendedUpper | ~networkMask;
											}
										}
									} else {
										unextendedBitLength = bitLength;
										unextendedDivPrefixLength = divPrefixLength;
									}
									int shift = unextendedBitLength - unextendedDivPrefixLength;
									if(shift == Long.SIZE) {
										lower = 0;
										upper = 0xffffffffffffffffL;
									} else {
										long networkMask = ~0L << shift;
										lower = lower & networkMask;
										upper = upper | ~networkMask;
									}
								}
							}
							int numBytes = (bitLength + 7) / Byte.SIZE;
							byte lowerBytes[] = toBytes(lower, extendedLower, numBytes);
							byte upperBytes[] = toBytes(upper, extendedUpper, numBytes);
							divs[i] = new IPAddressLargeDivision(lowerBytes, upperBytes, bitLength, divRadix, network, divPrefixLength);
							bitsSoFar += bitLength;
						}
						grouping = new IPAddressLargeDivisionGrouping(divs, network);
					} else {
						IPAddressBitsDivision divs[] = new IPAddressBitsDivision[totalCount];
						for(int i = 0; i < totalCount; i++) {
							long lower, upper;
							int bitLength;
							if(i < segmentCount) {
								bitLength = addrParseData.getBitLength(i);
								if(addrParseData.isWildcard(i)) {
									lower = 0;
									upper = ~(~0L << bitLength);
								} else {
									lower = addrParseData.getValue(i, AddressParseData.KEY_LOWER);
									upper = addrParseData.getValue(i, AddressParseData.KEY_UPPER);
								}
								divRadix = defaultRadix;
							} else if(isMergedMixed && i == segmentCount) {
								// merge the last IPv6 segment with the first IPv4 segment
								bitLength = addrParseData.getBitLength(i) + mixedParsedAddress.getBitLength(0);
								lower = 0;
								upper = ~(~0L << bitLength);
								divRadix = defaultRadix;
							} else {
								int adjusted = i - segmentCount;
								bitLength = mixedParsedAddress.getBitLength(adjusted);
								if(mixedParsedAddress.isWildcard(adjusted)) {
									lower = 0;
									upper =  ~(~0L << bitLength);
								} else {
									lower = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_LOWER);
									upper = mixedParsedAddress.getValue(adjusted, AddressParseData.KEY_UPPER);
								}
								divRadix = IPv4Address.DEFAULT_TEXTUAL_RADIX;
							}
							Integer divPrefixLength;
							if(prefLength == null) {
								divPrefixLength = null;
								if(hasMask) {
									Masker masker = maskers[i];
									if(!masker.isSequential()) {
										throw new IncompatibleAddressException(lower, upper, maskVal, "ipaddress.error.maskMismatch");
									}
									long divMask;
									if(maskBits > Long.SIZE) {
										int extendedBits = maskBits - Long.SIZE;
										if(extendedBits >= bitLength) {
											divMask = extendedMaskVal >>> (extendedBits - bitLength);
										} else {
											int shortBits = bitLength - extendedBits;
											divMask = (extendedMaskVal << (shortBits)) | (maskVal >> (Long.SIZE - shortBits));
										}
									} else {
										divMask = maskVal >>> (maskBits - bitLength);
									}	
									maskBits -= bitLength;
									lower = masker.getMaskedLower(lower, divMask);
									upper = masker.getMaskedUpper(upper, divMask);
								}
							} else {
								divPrefixLength = ParsedAddressGrouping.getDivisionPrefixLength(bitLength, prefLength - bitsSoFar);
								if(isPrefixSubnet && divPrefixLength != null) {
									long networkMask = ~0L << (bitLength - divPrefixLength);
									lower = lower & networkMask;
									upper = upper | ~networkMask;
		
								}
							}
							divs[i] = new IPAddressBitsDivision(lower, upper, bitLength, divRadix, network, divPrefixLength);
							bitsSoFar += bitLength;
						}
						grouping = new IPAddressDivisionGrouping(divs, network);
					}
					val.series = grouping;
					if(isDoneTranslating()) {
						releaseSegmentData();
					}
				}
			}
		}
		return grouping;
	}
	public static class BitwiseOrer implements Serializable {
		private static final long serialVersionUID = 1L;
		private final boolean isSequential;
		public BitwiseOrer(boolean isSequential) {
			this.isSequential = isSequential;
		}
		public long getOredLower(long value, long maskValue) {
			return value | maskValue;
		}
		public long getOredUpper(long upperValue, long maskValue) {
			return upperValue | maskValue;
		}
		public boolean isSequential() {
			return isSequential;
		}
	}
	
	// These can be cached by the int used to construct
	public static class FullRangeBitwiseOrer extends BitwiseOrer {
		private static final long serialVersionUID = 1L;
		private final long upperMask;
		public final int fullRangeBit;
		public FullRangeBitwiseOrer(int fullRangeBit, boolean isSequential) {
			super(isSequential);
			this.fullRangeBit = fullRangeBit;
			upperMask = ~0L >>> fullRangeBit;
		}
		
		@Override
		public long getOredLower(long value, long maskValue) {
			return super.getOredLower(value & ~upperMask, maskValue);
		}
		
		@Override
		public long getOredUpper(long upperValue, long maskValue) {
			return super.getOredUpper(upperValue | upperMask, maskValue);
		}
	}
	
	/**
	 * The analog to SpecificValueMasker for oring
	 * @author seancfoley
	 *
	 */
	public static class SpecificValueBitwiseOrer extends BitwiseOrer {
		private static final long serialVersionUID = 1L;
		private final long lower, upper;
		
		public SpecificValueBitwiseOrer(long lower, long upper) {
			super(false);
			this.lower = lower;
			this.upper = upper;
		}
		
		@Override
		public long getOredLower(long value, long maskValue) {
			return super.getOredLower(lower, maskValue);
		}
		
		@Override
		public long getOredUpper(long upperValue, long maskValue) {
			return super.getOredUpper(upper, maskValue);
		}
	}
	public static abstract class Masker implements Serializable {
		private static final long serialVersionUID = 1L;
		private final boolean isSequential;
		
		public Masker(boolean isSequential) {
			this.isSequential = isSequential;
		}
		
		/**
		 * The lowest masked value, which is not necessarily the lowest value masked
		 * @param upperValue
		 * @param maskValue
		 * @return
		 */
		public long getMaskedLower(long value, long maskValue) {
			return value & maskValue;
		}
		
		/**
		 * The highest masked value, which is not necessarily the highest value masked
		 * @param upperValue
		 * @param maskValue
		 * @return
		 */
		public long getMaskedUpper(long upperValue, long maskValue) {
			return upperValue & maskValue;
		}
		
		/**
		 * Whether masking all values in the range results in a sequential set of values
		 * @return
		 */
		public boolean isSequential() {
			return isSequential;
		}
	}
	// These can be cached by the int used to construct
	public static class FullRangeMasker extends Masker {
		private static final long serialVersionUID = 1L;
		private final long upperMask;
		public final int fullRangeBit;
		
		public FullRangeMasker(int fullRangeBit, boolean isSequential) {
			super(isSequential);
			this.fullRangeBit = fullRangeBit;
			upperMask = ~0L >>> fullRangeBit;
		}
		
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(value & ~upperMask, maskValue);
		}
		
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upperValue | upperMask, maskValue);
		}
	}
	/**
	 * When the part of a mask covering a range of values is a mix of ones and zeros,
	 * then there may be an intermediate value in the range that when masked, produces the new
	 * upper and lower values.  
	 * 
	 * For instance, consider the simple range 2 to 5 with mask of 2.
	 * The value when masked to give the lowest masked value is not the lowest in the range 2, it is 5.  Masking 5 with 2 gives 0.
	 * The value when masked to give the highest masked value is not the highest in the range 5, it is 2.  Masking 2 with 2 gives 2.
	 * 
	 * When the mask has a 0 in the highest bit in the range of values, then the two values that give the highest and lowest are
	 * 0000... and 1111....  This is because in any range 0xxxx to 1xxxx, the values 01111 and 10000 are in the range (they must be there
	 * to get from 0xxxx to 1xxxx.  And so if you ignore the top bit, the values 0000 and 1111 always give you the lowest and highest.
	 * In this case, FullRangeMasker can be used instead of this class.  For instance, you can use the values 011 to 100 (ie 3 and 4)
	 * to get the ranged values 2 and 0 in the example above.
	 * 
	 * However, when the mask has a 1 bit to match the highest bit in the range of values, you cannot use 01111... and 10000...
	 * In such cases, there are other values that when masked produce the new lowest and highest.
	 * For example, with the range 1 (001) to 6 (110) and the mask of 5 (101), 
	 * the lowest value when masked is 2 (010) to give 0,
	 * and the highest value when masked is 5 (101), to give masked value of 5.
	 * Neither of these values are the range boundaries 1 or 6.  Neither of these values is all ones or all zeros.
	 * This situation can occur when the mask itself is not all ones or all zeros, and when the highest bit in the range (the 3rd bit, ie 100 in the example)
	 * has a corresponding value of 1 in the given mask (101 in the example).
	 * 
	 * 
	 * @author seancfoley
	 *
	 */
	public static class SpecificValueMasker extends Masker {
		private static final long serialVersionUID = 1L;
		private final long lower, upper;
		
		public SpecificValueMasker(long lower, long upper) {
			super(false);
			this.lower = lower;
			this.upper = upper;
		}
		
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(lower, maskValue);
		}
		
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upper, maskValue);
		}
	}
	public static class ExtendedMasker extends Masker {
		private static final long serialVersionUID = 1L;
		public ExtendedMasker(boolean isSequential) {
			super(isSequential);
		}
		
		@Deprecated
		public long getExtendedLowerMasked(long extendedValue, long extendedMaskValue) {
			return getExtendedMaskedLower(extendedValue, extendedMaskValue);
		}
		
		@Deprecated
		public long getExtendedUpperMasked(long extendedUpperValue, long extendedMaskValue) {
			return getExtendedMaskedUpper(extendedUpperValue, extendedMaskValue);
		}
		
		public long getExtendedMaskedLower(long extendedValue, long extendedMaskValue) {
			return extendedValue & extendedMaskValue;
		}
		
		public long getExtendedMaskedUpper(long extendedUpperValue, long extendedMaskValue) {
			return extendedUpperValue & extendedMaskValue;
		}
	}
	// These can be cached by the int used to construct
	public static class ExtendedFullRangeMasker extends ExtendedMasker {
		private static final long serialVersionUID = 1L;
		private final long upperMask, extendedUpperMask;
		ExtendedFullRangeMasker(int fullRangeBit, boolean isSequential) {
			super(isSequential);
			if(fullRangeBit >= Long.SIZE) {
				extendedUpperMask = 0;
				upperMask = ~0L >>> (fullRangeBit - Long.SIZE);
			} else {
				extendedUpperMask = ~0L >>> fullRangeBit;
				upperMask = 0xffffffffffffffffL;
			}
		}
		
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(value & ~upperMask, maskValue);
		}
		
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upperValue | upperMask, maskValue);
		}
		
		@Override
		public long getExtendedMaskedLower(long extendedValue, long extendedMaskValue) {
			return super.getExtendedMaskedLower(extendedValue & ~extendedUpperMask, extendedMaskValue);
		}
		
		@Override
		public long getExtendedMaskedUpper(long extendedUpperValue, long extendedMaskValue) {
			return super.getMaskedUpper(extendedUpperValue | extendedUpperMask, extendedMaskValue);
		}
	}
	
	public static class ExtendedSpecificValueMasker extends ExtendedMasker {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private final long extendedLower, lower, extendedUpper, upper;
		
		public ExtendedSpecificValueMasker(long extendedLower, long lower, long extendedUpper, long upper) {
			super(false);
			this.lower = lower;
			this.upper = upper;
			this.extendedLower = extendedLower;
			this.extendedUpper = extendedUpper;
		}
		
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return super.getMaskedLower(lower, maskValue);
		}
		
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return super.getMaskedUpper(upper, maskValue);
		}
		
		@Override
		public long getExtendedMaskedLower(long extendedValue, long extendedMaskValue) {
			return super.getExtendedMaskedLower(extendedLower, extendedMaskValue);
		}
		
		@Override
		public long getExtendedMaskedUpper(long extendedUpperValue, long extendedMaskValue) {
			return super.getExtendedMaskedUpper(extendedUpper, extendedMaskValue);
		}
	}
	
	public static class WrappedMasker extends ExtendedMasker {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private final Masker masker;
		
		WrappedMasker(Masker masker) {
			super(masker.isSequential());
			this.masker = masker;
		}
		
		@Override
		public long getMaskedLower(long value, long maskValue) {
			return masker.getMaskedLower(value, maskValue);
		}
		
		@Override
		public long getMaskedUpper(long upperValue, long maskValue) {
			return masker.getMaskedUpper(upperValue, maskValue);
		}
	}
	
	/**
	 * @deprecated use maskExtendedRange
	 * 
	 * @param value
	 * @param extendedValue
	 * @param upperValue
	 * @param extendedUpperValue
	 * @param maskValue
	 * @param extendedMaskValue
	 * @param maxValue
	 * @param extendedMaxValue
	 * @return
	 */
	@Deprecated
	public static ExtendedMasker maskRange(
			long value, long extendedValue, 
			long upperValue, long extendedUpperValue, 
			long maskValue, long extendedMaskValue, 
			long maxValue, long extendedMaxValue) {
		return maskExtendedRange(value, extendedValue, 
				upperValue, extendedUpperValue, 
				maskValue, extendedMaskValue, 
				maxValue, extendedMaxValue);
	}
			
	public static ExtendedMasker maskExtendedRange(
			long value, long extendedValue, 
			long upperValue, long extendedUpperValue, 
			long maskValue, long extendedMaskValue, 
			long maxValue, long extendedMaxValue) {
		
		//algorithm:
		//here we find the highest bit that is part of the range, highestDifferingBitInRange (ie changes from lower to upper)
		//then we find the highest bit in the mask that is 1 that is the same or below highestDifferingBitInRange (if such a bit exists)
		
		//this gives us the highest bit that is part of the masked range (ie changes from lower to upper after applying the mask)
		//if this latter bit exists, then any bit below it in the mask must be 1 to include the entire range.
		
		long extendedDiffering = extendedValue ^ extendedUpperValue;
		if(extendedDiffering == 0) {
			// the top is single-valued so just need to check the lower part
			Masker masker = maskRange(value, upperValue, maskValue, maxValue);
			if(masker == DEFAULT_MASKER) {
				return DEFAULT_MASKER;
			}
			if(masker instanceof FullRangeMasker) {
				int fullRangeBit = ((FullRangeMasker) masker).fullRangeBit;
				WrappedMasker cache[] = masker.isSequential() ? WRAPPED_SEQUENTIAL_FULL_RANGE_MASKERS : WRAPPED_FULL_RANGE_MASKERS;
				WrappedMasker result = cache[fullRangeBit];
				if(result == null) {
					cache[fullRangeBit] = result = new WrappedMasker(masker);
				}
				return result;
			}
			return new WrappedMasker(masker);
		}
		if(extendedValue > extendedUpperValue) {
			throw new IllegalArgumentException("value > upper value");
		}
		if((maskValue == maxValue && extendedMaskValue == extendedMaxValue /* all ones mask */) ||
				(maskValue == 0 && extendedMaskValue == 0 /* all zeros mask */)) {
			return DEFAULT_MASKER;
		}
		int highestDifferingBitInRange = Long.numberOfLeadingZeros(extendedDiffering);
		long extendedDifferingMasked = extendedMaskValue & (~0L >>> highestDifferingBitInRange);
		int highestDifferingBitMasked;
		if(extendedDifferingMasked != 0) {
			boolean differingIsLowestBit = (extendedDifferingMasked == 1);
			highestDifferingBitMasked = Long.numberOfLeadingZeros(extendedDifferingMasked);
			boolean maskedIsSequential;
			long hostMask = ~0L >>> (highestDifferingBitMasked + 1);
			if(!differingIsLowestBit) { // Anything below highestDifferingBitMasked in the mask must be ones.
				//for the first mask bit that is 1, all bits that follow must also be 1
				maskedIsSequential = (extendedMaskValue & hostMask) == hostMask && maskValue == maxValue; //check if all ones below
			} else {
				maskedIsSequential = maskValue == maxValue;
			}
			if(value == 0 && extendedValue == 0 && 
					upperValue == maxValue && extendedUpperValue == extendedMaxValue) {
				// full range
				if(maskedIsSequential) {
					return DEFAULT_MASKER;
				} else {
					return DEFAULT_NON_SEQUENTIAL_MASKER;
				}
			}
			if(highestDifferingBitMasked > highestDifferingBitInRange) {
				if(maskedIsSequential) {
					// We need to check that the range is larger enough that when chopping off the top it remains sequential
					
					// Note: a count of 2 in the extended could equate to a count of 2 total!
					// upper: xxxxxxx1 00000000
					// lower: xxxxxxx0 11111111
					// Or, it could be everything:
					// upper: xxxxxxx1 11111111
					// lower: xxxxxxx0 00000000
					// So for that reason, we need to check the full count here and not just extended
					
					int shift = Long.SIZE - highestDifferingBitMasked; // highestDifferingBitMasked > 0 so shift < 64 which is required for long left shift
					BigInteger countRequiredForSequential = ONE_SHIFTED_EXTENDED[shift];
					if(countRequiredForSequential == null) {
						countRequiredForSequential = ONE_SHIFTED_EXTENDED[shift] = BigInteger.valueOf(1L << shift).shiftLeft(Long.SIZE);
					}
					BigInteger upperBig = new BigInteger(1, toBytesSizeAdjusted(upperValue, extendedUpperValue, 16));
					BigInteger lowerBig = new BigInteger(1, toBytesSizeAdjusted(value, extendedValue, 16));
					BigInteger count = upperBig.subtract(lowerBig).add(BigInteger.ONE);
					maskedIsSequential = count.compareTo(countRequiredForSequential) >= 0;
				}
				ExtendedFullRangeMasker cache[] = maskedIsSequential ? EXTENDED_SEQUENTIAL_FULL_RANGE_MASKERS : EXTENDED_FULL_RANGE_MASKERS;
				ExtendedFullRangeMasker result = cache[highestDifferingBitMasked];
				if(result == null) {
					cache[highestDifferingBitMasked] = result = new ExtendedFullRangeMasker(highestDifferingBitMasked, maskedIsSequential);
				}
				return result;
			} else if(!maskedIsSequential) {
				BigInteger bigHostMask = HOST_MASK_EXTENDED[highestDifferingBitMasked];
				if(bigHostMask == null) {
					bigHostMask = BigInteger.valueOf(hostMask);
					bigHostMask = bigHostMask.shiftLeft(Long.SIZE);
					byte b = (byte) 0xff;
					bigHostMask = bigHostMask.or(new BigInteger(1, new byte[] {b, b, b, b, b, b, b, b}));
					HOST_MASK_EXTENDED[highestDifferingBitMasked] = bigHostMask;
				}
				BigInteger bigHostZeroed = NETWORK_MASK_EXTENDED[highestDifferingBitMasked];
				if(bigHostZeroed == null) {
					bigHostZeroed = NETWORK_MASK_EXTENDED[highestDifferingBitMasked] = bigHostMask.not();
				}
				BigInteger upperBig = new BigInteger(1, toBytesSizeAdjusted(upperValue, extendedUpperValue, 16));
				BigInteger lowerBig = new BigInteger(1, toBytesSizeAdjusted(value, extendedValue, 16));
				BigInteger upperToBeMaskedBig = upperBig.and(bigHostZeroed);
				BigInteger lowerToBeMaskedBig = lowerBig.or(bigHostMask);
				BigInteger maskBig = new BigInteger(1, toBytesSizeAdjusted(maskValue, extendedMaskValue, 16));
				for(int nextBit = 128 - (highestDifferingBitMasked + 1) - 1; nextBit >= 0; nextBit--) {
					if(maskBig.testBit(nextBit)) {
						BigInteger candidate = upperToBeMaskedBig.setBit(nextBit);
						if(candidate.compareTo(upperBig) <= 0) {
							upperToBeMaskedBig = candidate;
						}
						candidate = lowerToBeMaskedBig.clearBit(nextBit);
						if(candidate.compareTo(lowerBig) >= 0) {
							lowerToBeMaskedBig = candidate;
						}
					} //else
					// keep our upperToBeMaskedBig bit as 0
					// keep our lowerToBeMaskedBig bit as 1
				}
				return new ExtendedSpecificValueMasker(
						lowerToBeMaskedBig.shiftRight(Long.SIZE).longValue(), 
						lowerToBeMaskedBig.longValue(), 
						upperToBeMaskedBig.shiftRight(Long.SIZE).longValue(), 
						upperToBeMaskedBig.longValue());
			}
			return DEFAULT_MASKER;
			
		}
		// When masking, the top becomes single-valued.
		
		// We go to the lower values to find highestDifferingBitMasked.
		
		// At this point, the highest differing bit in the lower range is 0
		// and the highestDifferingBitMasked is the first 1 bit in the lower mask
		
		if(maskValue == 0) {
			// the mask zeroes out everything,
			return DEFAULT_MASKER;
		}
		boolean maskedIsSequential = true;
		int highestDifferingBitMaskedLow = Long.numberOfLeadingZeros(maskValue);
		if(maskValue != maxValue && highestDifferingBitMaskedLow < Long.SIZE - 1) {
			//for the first mask bit that is 1, all bits that follow must also be 1
			long hostMask = ~0L >>> (highestDifferingBitMaskedLow + 1); // this shift of since case of highestDifferingBitMaskedLow of 64 and 63 taken care of, so the shift is < 64
			maskedIsSequential = (maskValue & hostMask) == hostMask; //check if all ones below
		}
		if(maskedIsSequential) {
			// Note: a count of 2 in the lower values could equate to a count of everything in the full range:
			// upper: xxxxxx10 00000000
			// lower: xxxxxxx0 11111111
			// Another example:
			// upper: xxxxxxx1 00000001
			// lower: xxxxxxx0 00000000
			// So for that reason, we need to check the full count here and not just lower values
			
			// We need to check that the range is larger enough that when chopping off the top it remains sequential
			BigInteger countRequiredForSequential;
			if(highestDifferingBitMaskedLow == 0) {
				countRequiredForSequential = ONE_EXTENDED;
			} else if(highestDifferingBitMaskedLow == 1) { // need this case because 1 << 63 is a negative number
				countRequiredForSequential = HIGH_BIT;
			} else {
				int shift = Long.SIZE - highestDifferingBitMaskedLow;
				countRequiredForSequential = ONE_SHIFTED[shift];
				if(countRequiredForSequential == null) {
					countRequiredForSequential = ONE_SHIFTED[shift] = BigInteger.valueOf(1L << shift);
				}
			}
			BigInteger upperBig = new BigInteger(1, toBytesSizeAdjusted(upperValue, extendedUpperValue, 16));
			BigInteger lowerBig = new BigInteger(1, toBytesSizeAdjusted(value, extendedValue, 16));
			BigInteger count = upperBig.subtract(lowerBig).add(BigInteger.ONE);
			maskedIsSequential = count.compareTo(countRequiredForSequential) >= 0;
		}
		highestDifferingBitMasked = highestDifferingBitMaskedLow + Long.SIZE;
		ExtendedFullRangeMasker cache[] = maskedIsSequential ? EXTENDED_SEQUENTIAL_FULL_RANGE_MASKERS : EXTENDED_FULL_RANGE_MASKERS;
		ExtendedFullRangeMasker result = cache[highestDifferingBitMasked];
		if(result == null) {
			cache[highestDifferingBitMasked] = result = new ExtendedFullRangeMasker(highestDifferingBitMasked, maskedIsSequential);
		}
		return result;
	}
	/**
	 * 
	 * @param value
	 * @param upperValue
	 * @param maskValue
	 * @return an instance what will produce the result of masking the values
	 * -1 if not compatible and x where x >= 0 if compatible.
	 *  If x is 0, then the resulting masked range is (value & maskValue) to (upperValue & maskValue).
	 *  If x > 0, then the resulting masked range is (value & maskValue & lowerMask) to ((upperValue & maskValue) | upperMask)
	 *  	where upperMask is ~0 >>> x and lowerMask = ~upperMask.
	 */
	public static Masker maskRange(long value, long upperValue, long maskValue) {
		return maskRange(value, upperValue, maskValue, -1);
	}
	
	public static Masker maskRange(long value, long upperValue, long maskValue, long maxValue) {
		if(value == upperValue) {
			return DEFAULT_MASKER;
		}
		if(value > upperValue) {
			throw new IllegalArgumentException("value > upper value");
		}
		if(maskValue == 0 || maskValue == maxValue) {
			return DEFAULT_MASKER;
		}
		
		//algorithm:
		//here we find the highest bit that is part of the range, highestDifferingBitInRange (ie changes from lower to upper)
		//then we find the highest bit in the mask that is 1 that is the same or below highestDifferingBitInRange (if such a bit exists)
		
		//this gives us the highest bit that is part of the masked range (ie changes from lower to upper after applying the mask)
		//if this latter bit exists, then any bit below it in the mask must be 1 to remain sequential.
		
		long differing = value ^ upperValue;
		if(differing != 1) {
			int highestDifferingBitInRange = Long.numberOfLeadingZeros(differing);
			long maskMask = ~0L >>> highestDifferingBitInRange;
			long differingMasked = maskValue & maskMask;
			boolean foundDiffering = (differingMasked != 0);
			if(foundDiffering) {
				// Anything below highestDifferingBitMasked in the mask must be ones.
				// Also, if we have masked out any 1 bit in the original, then anything that we do not mask out that follows must be all 1s
				int highestDifferingBitMasked = Long.numberOfLeadingZeros(differingMasked); // first one bit in the mask covering the range
				long hostMask = (highestDifferingBitMasked == Long.SIZE - 1) ? 0 : ~0L >>> (highestDifferingBitMasked + 1);//for the first mask bit that is 1, all bits that follow must also be 1
				boolean maskedIsSequential = (maskValue & hostMask) == hostMask;
				if(maxValue == -1 && 
						(!maskedIsSequential || highestDifferingBitMasked > highestDifferingBitInRange)) {
					int highestOneBit = Long.numberOfLeadingZeros(upperValue);
					// note we know highestOneBit < 64, otherwise differing would be 1 or 0
					maxValue = ~0L >>> highestOneBit;
				}
				if(value == 0 && upperValue == maxValue) {
					// full range
					if(maskedIsSequential) {
						return DEFAULT_MASKER;
					} else {
						return DEFAULT_NON_SEQUENTIAL_MASKER;
					}
				}
				if(highestDifferingBitMasked > highestDifferingBitInRange) {
					if(maskedIsSequential) {
						// the count will determine if the masked range is sequential
						if(highestDifferingBitMasked < Long.SIZE - 1) {
							long count = upperValue - value + 1;
							
							// if original range is 0xxxx to 1xxxx and our mask starts with a single 0 so the mask is 01111, 
							// then our new range covers 4 bits at most (could be less).
							// If the range covers 4 bits, we need to know if that range covers the same count of values as 0000 to 1111.
							// If so, the resulting range is not disjoint.
							// How do we know the range is disjoint otherwise?  We know because it has the values 1111 and 0000.
							// In order to go from 0xxxx to 1xxxx you must cross the consecutive values 01111 and 10000.
							// These values are consecutive in the original range (ie 01111 is followed by 10000) but in the new range
							// they are farthest apart and we need the entire range to fill the gap between them.
							// That count of values for the entire range is 1111 - 0000 + 1 = 10000
							// So in this example, the first bit in the original range is bit 0, highestDifferingBitMasked is 1,
							// and the range must cover 2 to the power of (5 - 1),
							// or 2 to the power of bit count - highestDifferingBitMasked, or 1 shifted by that much. 
							
							long countRequiredForSequential = 1L << (Long.SIZE - highestDifferingBitMasked);
							if(count < countRequiredForSequential) {
								// the resulting masked values are disjoint, not sequential
								maskedIsSequential = false;
							}
						} // else count of 2 is good enough, even if the masked range does not cover both values, then the result is a single value, which is also sequential
						// another way of looking at it: when the range is just two, we do not need to see if the masked range covers all values in between, as there is no values in between
					}
					// The range part of the values will go from 0 to the mask itself.
					// This is because we know that if the range is 0xxxx... to 1yyyy..., then 01111... and 10000... are also in the range,
					// since that is the only way to transition from 0xxxx... to 1yyyy...
					// Because the mask has no 1 bit at the top bit, then we know that when masking with those two values 01111... and 10000...
					// we get the mask itself and 00000 as the result.
					FullRangeMasker cache[] = maskedIsSequential ? SEQUENTIAL_FULL_RANGE_MASKERS : FULL_RANGE_MASKERS;
					FullRangeMasker result = cache[highestDifferingBitMasked];
					if(result == null) {
						cache[highestDifferingBitMasked] = result = new FullRangeMasker(highestDifferingBitMasked, maskedIsSequential);
					}
					return result;
				} else if(!maskedIsSequential) {
					long hostZeroed = ~hostMask;
					long upperToBeMasked = upperValue & hostZeroed;
					long lowerToBeMasked = value | hostMask;
					// we find a value in the range that will produce the highest and lowest values when masked
					for(long nextBit = (1 << (Long.SIZE - (highestDifferingBitMasked + 1) - 1)); nextBit != 0; nextBit >>>= 1) {
						// check if the bit in the mask is 1
						if((maskValue & nextBit) != 0) {
							long candidate = upperToBeMasked | nextBit;
							if(candidate <= upperValue) {
								upperToBeMasked = candidate;
							}
							candidate = lowerToBeMasked & ~nextBit;
							if(candidate >= value) {
								lowerToBeMasked = candidate;
							}
						} //else
							// keep our upperToBeMasked bit as 0
							// keep our lowerToBeMasked bit as 1
					}
					return new SpecificValueMasker(lowerToBeMasked, upperToBeMasked);
				} // else fall through to default masker
			} 
		} 
		return DEFAULT_MASKER;
	}
	public static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue) {
		return bitwiseOrRange(value, upperValue, maskValue, -1);
	}
		
	public static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue, long maxValue) {
		if(value == upperValue) {
			return DEFAULT_OR_MASKER;
		}
		if(value > upperValue) {
			throw new IllegalArgumentException("value > upper value");
		}
		if(maskValue == 0 || maskValue == maxValue) {
			return DEFAULT_OR_MASKER;
		}
		
		//algorithm:
		//here we find the highest bit that is part of the range, highestDifferingBitInRange (ie changes from lower to upper)
		//then we find the highest bit in the mask that is 0 that is the same or below highestDifferingBitInRange (if such a bit exists)
		
		//this gives us the highest bit that is part of the masked range (ie changes from lower to upper after applying the mask)
		//if this latter bit exists, then any bit below it in the mask must be 0 to include the entire range.
		
		long differing = value ^ upperValue;
		if(differing != 1) {
			int highestDifferingBitInRange = Long.numberOfLeadingZeros(differing);
			long maskMask = ~0L >>> highestDifferingBitInRange;
			long differingMasked = maskValue & maskMask;
			boolean foundDiffering = (differingMasked != maskMask);// mask not all ones
			if(foundDiffering) {
				int highestDifferingBitMasked = Long.numberOfLeadingZeros(~differingMasked & maskMask); // first 0 bit in the part of the mask covering the range
				long hostMask = (highestDifferingBitMasked == Long.SIZE - 1) ? 0 : ~0L >>> (highestDifferingBitMasked + 1); // after that first 0 bit, all bits that follow must also be 0
				boolean maskedIsSequential = (maskValue & hostMask) == 0;
				if(maxValue == -1 && 
						(!maskedIsSequential || highestDifferingBitMasked > highestDifferingBitInRange)) {
					int highestOneBit = Long.numberOfLeadingZeros(upperValue);
					// note we know highestOneBit < 64, otherwise differing would be 1 or 0, so shift is OK
					maxValue = ~0L >>> highestOneBit;
				}
				if(value == 0 && upperValue == maxValue) {
					// full range
					if(maskedIsSequential) {
						return DEFAULT_OR_MASKER;
					} else {
						return DEFAULT_NON_SEQUENTIAL_OR_MASKER;
					}
				}
				if(highestDifferingBitMasked > highestDifferingBitInRange) {
					if(maskedIsSequential) {
						// the count will determine if the ored range is sequential
						if(highestDifferingBitMasked < Long.SIZE - 1) {
							long count = upperValue - value + 1;
							long countRequiredForSequential = 1L << (Long.SIZE - highestDifferingBitMasked);
							if(count < countRequiredForSequential) {
								// the resulting ored values are disjoint, not sequential
								maskedIsSequential = false;
							}
						}
					}
					FullRangeBitwiseOrer cache[] = maskedIsSequential ? SEQUENTIAL_FULL_RANGE_OR_MASKERS : FULL_RANGE_OR_MASKERS;
					FullRangeBitwiseOrer result = cache[highestDifferingBitMasked];
					if(result == null) {
						cache[highestDifferingBitMasked] = result = new FullRangeBitwiseOrer(highestDifferingBitMasked, maskedIsSequential);
					}
					return result;
				} else if(!maskedIsSequential) {
					long hostZeroed = ~hostMask;
					long upperToBeMasked = upperValue & hostZeroed;
					long lowerToBeMasked = value | hostMask;
					for(long nextBit = (1L << (Long.SIZE - (highestDifferingBitMasked + 1) - 1)); nextBit != 0; nextBit >>>= 1) {
						// check if the bit in the mask is 0
						if((maskValue & nextBit) == 0) {
							long candidate = upperToBeMasked | nextBit;
							if(candidate <= upperValue) {
								upperToBeMasked = candidate;
							}
							candidate = lowerToBeMasked & ~nextBit;
							if(candidate >= value) {
								lowerToBeMasked = candidate;
							}
						} //else
							// keep our upperToBeMasked bit as 0
							// keep our lowerToBeMasked bit as 1
					}
					return new SpecificValueBitwiseOrer(lowerToBeMasked, upperToBeMasked);
				}
			}
		}
		return DEFAULT_OR_MASKER;
	}
	// converts to a byte array but strips leading zero bytes
	static byte[] toBytesSizeAdjusted(long val, long extended, int numBytes) {
		// Find first nonzero byte
		int adjustedNumBytes = numBytes;
		for(int j = 1, boundary = numBytes - 8, adj = numBytes + boundary; j <= numBytes; j++) {
			byte b;
			if(j <= boundary) {
				b = (byte) (extended >>> ((numBytes - j) << 3));
			} else {
				b = (byte) (val >>> ((adj - j) << 3));
			}
			if(b != 0) {
				break;
			}
			adjustedNumBytes--;
		}
		return toBytes(val, extended, adjustedNumBytes);
	}
	static byte[] toBytes(long val, long extended, int numBytes) {
		byte bytes[] = new byte[numBytes];
		for(int j = numBytes - 1, boundary = numBytes - 8; j >= 0; j--) {
			if(j >= boundary) {
				bytes[j] = (byte) (val & 0xff);
				val >>>= Byte.SIZE;
			} else {
				bytes[j] = (byte) (extended & 0xff);
				extended >>>= Byte.SIZE;
			}
		}
		return bytes;
	}
	
	private boolean groupingIsSequential() {
		try {
			return getDivisionGrouping().isSequential();
		} catch(IncompatibleAddressException e) {
			// division groupings avoid all IncompatibleAddressException caused by regrouping the values into segments of different size
			// that takes care of two of the sources of IncompatibleAddressException: joining mixed segs, and expanding inet_aton ipv4 or single-segment ipv6 into the standard number of ipv4 or ipv6 segments
			
			// Those remaining are the IncompatibleAddressException caused by masks, which are the result of individual divisions becoming non-sequential
			// So in such cases, you know we are not sequential.  So we return false.
			// the usual caveat is that this cannot happen with standard network or host masks
			return false;
		}
	}
	
	@Override
	public boolean isSequential() {
		TranslatedResult<?,?> val = values;
		if(val != null) {
			// check address first
			if(!val.withoutSections()) {
				// address already there, use it if we can
				if(val.withoutAddressException()) {
					return val.getAddress().isSequential();
				}
				return groupingIsSequential();
			}
			if(!val.withoutGrouping()) {
				return groupingIsSequential();
			}
		}
		// neither address nor grouping is there, create the address
		val = getCachedAddresses(false);
		if(val.withoutAddressException()) {
			return val.getAddress().isSequential();
		}
		return groupingIsSequential();
	}
	
	// skips contains checking for addresses already parsed - 
	// so this is not a case of unusual string formatting, because this is not for comparing strings,
	// but more a case of whether the parsing data structures are easy to use or not
	private boolean skipContains(boolean skipMixed) {
		AddressParseData parseData = getAddressParseData();
		int segmentCount = parseData.getSegmentCount();
		
		// first we must excluded cases where the segments line up differently than standard, although we do not exclude ipv6 compressed
		if(isProvidingIPv4()) {
			if(segmentCount != IPv4Address.SEGMENT_COUNT) { // accounts for is_inet_aton_joined, singleSegment and wildcard segments
				return true;
			}
		} else {
			int expectedSegmentCount;
			if(isProvidingMixedIPv6()) {
				if(skipMixed) {
					return true;
				}
				expectedSegmentCount = IPv6Address.SEGMENT_COUNT - 2;
			} else {
				expectedSegmentCount = IPv6Address.SEGMENT_COUNT;
			}
			if(segmentCount != expectedSegmentCount && !isCompressed()) { // accounts for single segment and wildcard segments
				return true;
			}
		}
		// exclude non-standard masks which will modify segment values from their parsed values
		IPAddress mask = getProviderMask();
		if(mask != null && mask.getBlockMaskPrefixLength(true) == null) { // handles non-standard masks
			return true;
		}
		return false;
	}
	@Override
	public Boolean contains(String other) {
		AddressParseData parseData = getAddressParseData();
		int segmentData[] = parseData.getSegmentData(); //grab this field for thread safety, other threads can make it disappear
		if(segmentData == null) {
			return null;
		}
		if(skipContains(true)) {
			return null;
		}
		if(has_inet_aton_value || hasIPv4LeadingZeros || isBinary) {
			//you need to skip inet_aton completely because it can screw up where prefix matches up with digits
			//you need to skip ipv4 leading zeros because addresses like 01.02.03.04 can change value depending on the validation options (octal or decimal)
			return null;
		}
		Integer pref = getProviderNetworkPrefixLength();
		IPAddressStringParameters options = getParameters();
		IPAddressNetwork<? extends IPAddress, ?, ?, ?, ?> network = (isProvidingIPv4() ? options.getIPv4Parameters() : options.getIPv6Parameters()).getNetwork();
		if(pref != null && !isPrefixSubnet(pref, network, segmentData)) {
			// this algorithm only works to check that the non-prefix host portion is valid,
			// it does not attempt to check containment of the host or match the host,
			// it depends on the host being full range in the containing address
			return null;
		}
		return matchesPrefix(other, segmentData);
	}
	
	@Override
	public Boolean prefixContains(String other) {
		Boolean b = prefixEquals(other);
		if(b != null && b.booleanValue()) {
			return b;
		}
		return null;
	}
	
	@Override
	public Boolean prefixEquals(String other) {
		AddressParseData parseData = getAddressParseData();
		int segmentData[] = parseData.getSegmentData(); //grab this field for thread safety, other threads can make it disappear
		if(segmentData == null) {
			return null;
		}
		if(skipContains(true)) {
			return null;
		}
		if(has_inet_aton_value || hasIPv4LeadingZeros || isBinary) {
			//you need to skip inet_aton completely because it can screw up where prefix matches up with digits
			//you need to skip ipv4 leading zeros because addresses like 01.02.03.04 can change value depending on the validation options (octal or decimal)
			return null;
		}
		return matchesPrefix(other, segmentData);
	}
	
	private Boolean matchesPrefix(String other, int segmentData[]) {
		int otherLen = other.length();
		// If other has a prefix length, then we end up returning false when we look at the end of the other string to ensure the other string is valid
		// Checking for prefix subnets in here is too expensive
		// Also, we don't want to start validating prefix strings as well, too expensive
		// A prefix can only change a "true" result to "false", so all the places we return false below are still fine
		// However, we only give up at the very end, so here we do a quick check first
		boolean isIPv4 = isProvidingIPv4();
		if(otherLen >= 4)	{
			char prefixLenSep = IPAddress.PREFIX_LEN_SEPARATOR;
			if(other.charAt(otherLen - 2) == prefixLenSep || other.charAt(otherLen - 3) == prefixLenSep) {
				return null;
			}
			if(!isIPv4) {
				if(other.charAt(otherLen - 4) == prefixLenSep) {
					return null;
				}
			}
		}
		AddressParseData parseData = getAddressParseData();
		Integer pref = getProviderNetworkPrefixLength();
		int expectedCount;
		boolean compressedAlready = false;
		boolean networkSegIsCompressed = false;
		boolean prefixIsMidSegment;
		int prefixEndCharIndex, remainingSegsCharIndex, networkSegIndex, networkSegCharIndex, networkSegsCount, adjustment; // prefixEndCharIndex points to separator following prefixed seg if whole seg is prefixed, remainingSegsCharIndex points to next digit
		remainingSegsCharIndex = networkSegCharIndex = networkSegIndex = networkSegsCount = adjustment = 0;
		if(pref == null) {
			expectedCount = isIPv4 ? IPv4Address.SEGMENT_COUNT : IPv6Address.SEGMENT_COUNT;
			networkSegIndex = expectedCount - 1;
			prefixEndCharIndex = getIndex(networkSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData);
			if(otherLen > prefixEndCharIndex) {
				return null;
			}
			prefixIsMidSegment = false;
		} else if(pref == 0) {
			prefixIsMidSegment = false;
			expectedCount = isIPv4 ? IPv4Address.SEGMENT_COUNT : IPv6Address.SEGMENT_COUNT;
			prefixEndCharIndex = 0;
		} else {
			if(isIPv4) {
				expectedCount = IPv4Address.SEGMENT_COUNT;
				int bitsPerSegment = IPv4Address.BITS_PER_SEGMENT;
				int bytesPerSegment = IPv4Address.BYTES_PER_SEGMENT;
				networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
				prefixEndCharIndex = getIndex(networkSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData);
				Integer segPrefLength = ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, pref, networkSegIndex);
				prefixIsMidSegment = segPrefLength != bitsPerSegment;
				networkSegsCount = networkSegIndex + 1;
				remainingSegsCharIndex = prefixEndCharIndex + 1;
				if(prefixIsMidSegment) {
					networkSegCharIndex = getIndex(networkSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
				}
			} else {
				expectedCount = IPv6Address.SEGMENT_COUNT;
				int bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
				int bytesPerSegment = IPv6Address.BYTES_PER_SEGMENT;
				networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
				int missingSegmentCount = IPv6Address.SEGMENT_COUNT - parseData.getSegmentCount();
				int compressedSegIndex = getConsecutiveSeparatorSegmentIndex();
				compressedAlready = compressedSegIndex <= networkSegIndex;//any part of network prefix is compressed
				networkSegIsCompressed = compressedAlready && compressedSegIndex + missingSegmentCount >= networkSegIndex;//the segment with the prefix boundary is compressed		
				Integer segPrefLength = ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, pref, networkSegIndex);
				if(networkSegIsCompressed) {
					prefixIsMidSegment = segPrefLength != bitsPerSegment;
					networkSegsCount = networkSegIndex + 1;
					prefixEndCharIndex = getIndex(compressedSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData) + 1; //to include all zeros in prefix we must include both seps, in other cases we include no seps at alls
					if (prefixIsMidSegment && compressedSegIndex > 0) {
						networkSegCharIndex = getIndex(compressedSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
					}
					remainingSegsCharIndex = prefixEndCharIndex + 1;
				} else {
					int actualNetworkSegIndex;
					if(compressedSegIndex < networkSegIndex) {
						actualNetworkSegIndex = networkSegIndex - missingSegmentCount;
					} else {
						actualNetworkSegIndex = networkSegIndex;
					}
					prefixEndCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX, segmentData);
					adjustment = IPv6AddressSegment.MAX_CHARS - ((segPrefLength + 3) >> 2); // divide by IPv6AddressSegment.BITS_PER_CHAR
					if(adjustment > 0) {
						prefixIsMidSegment = true;
						remainingSegsCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_UPPER_STR_START_INDEX, segmentData);
						if(remainingSegsCharIndex + adjustment > prefixEndCharIndex) {
							adjustment = prefixEndCharIndex - remainingSegsCharIndex;
						}
						prefixEndCharIndex -= adjustment;
						networkSegsCount = networkSegIndex;
						networkSegCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
					} else {
						prefixIsMidSegment = segPrefLength != bitsPerSegment;
						networkSegsCount = actualNetworkSegIndex + 1;
						remainingSegsCharIndex = prefixEndCharIndex + 1;
						if(prefixIsMidSegment) {
							networkSegCharIndex = getIndex(actualNetworkSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX, segmentData);
						}
					}
				}
			}
		}
		CharSequence str = this.str;
		int otherSegmentCount = 0;
		boolean currentSegHasNonZeroDigits = false;
		for(int i = 0; i < prefixEndCharIndex; i++) {
			char c = str.charAt(i);
			char otherChar;
			if(i < otherLen) {
				otherChar = other.charAt(i);
			} else {
				otherChar = 0;
			}
			if(c != otherChar) {
				if(c >= '1' && c <= '9') {
				} else if(c >= 'a' && c <= 'f') {
				} else if(c >= 'A' && c <= 'F') {
					char adjustedChar = (char) (c - ('A' - 'a'));
					if(c == adjustedChar) {
						continue;
					}
				} else if(c <= Address.RANGE_SEPARATOR && c >= Address.SEGMENT_SQL_WILDCARD) {
					if(c == Address.SEGMENT_WILDCARD || c == Address.RANGE_SEPARATOR || c == Address.SEGMENT_SQL_WILDCARD) {
						return null;
					}
				} else if(c == Address.SEGMENT_SQL_SINGLE_WILDCARD) {
					return null;
				}
				
				if(otherChar >= 'A' && otherChar <= 'F') {
					char adjustedChar = (char) (otherChar - ('A' - 'a'));
					if(otherChar == adjustedChar) {
						continue;
					}
				} 
				
				if(prefixIsMidSegment && (i >= networkSegCharIndex || networkSegCharIndex == 1)) { //networkSegCharIndex == 1 accounts for :: start to address
					// when prefix is not on seg boundary, we can have the same prefix without matching digits
					// the host part can change the digits of the network part, particularly for ipv4
					// this is true for ipv6 too when you consider host and network part of each digit
					// this is also true when the digit count in the segments do not match,
					// also note that f: and fabc: match prefix of 4 by string chars, but prefix does not match due to difference in digits in each segment
					// So, in general, when mismatch of prefix chars we cannot conclude mismatch of prefix unless we are comparing entire segments (ie prefix is on seg boundary)
					return null;
				}
				
				if(hasRange(otherSegmentCount)) {
					return null;
				}
				if(otherChar >= '1' && otherChar <= '9') {
				} else if(otherChar >= 'a' && otherChar <= 'f') {
				} else {
					if(otherChar <= Address.RANGE_SEPARATOR && otherChar >= Address.SEGMENT_SQL_WILDCARD) {
						if(otherChar == Address.SEGMENT_WILDCARD || otherChar == Address.RANGE_SEPARATOR || otherChar == Address.SEGMENT_SQL_WILDCARD) {
							return null;
						}
					} else if(otherChar == Address.SEGMENT_SQL_SINGLE_WILDCARD) {
						return null;
					}
					
					if(!currentSegHasNonZeroDigits) {
						//we know that this address has no ipv4 leading zeros, we abort this method in such cases.
						//However, we do want to handle all the following cases and return null for each.
						//We do not handle differing numbers of leading zeros
						//We do not handle ipv6 compression in different places
						//So we want to handle segments that start like all of these cases:
						
						//other 01
						//this  1
						
						//other 00
						//this  1
						
						//other 00
						//this  :
						
						//other 0:
						//this  :
						
						//other 00
						//this  0:
						
						//other :
						//this  0
						
						//Those should all return null since they might in fact represent matching segments.
						//However, the following should return FALSE when there are no leading zeros and no compression:
						
						//other 0.
						//this  1
						
						//other 1
						//this  0.
						
						//other 0:
						//this  1
						
						//other 1
						//this  0:
						
						//So in summary, we first check that we have not matched non-zero values first (ie digitCount must be 0)
						//All the null cases involve one or the other starting with 0.
						//If the other is an ipv6 segment separator, return null.
						//Otherwise, if the zero is not the end of segment, we have leading zeros which we do not handle here, so we return null.
						//Otherwise, return false.  This is because we have a zero segment, and the other is not (it is neither compressed nor 0).
						//Actually, we return false only if the 0 segment is the other string, because if the 0 segment is this it is only one segment while the other may be multi-segment.
						//If the other might be multi-segment, we defer to the segment check that will tell us if we must have matching segments here.
						if(c == '0') {
							if(otherChar == IPv6Address.SEGMENT_SEPARATOR || otherChar == 0) {
								return null;
							}
							int k = i + 1;
							if(k < str.length()) {
								char nextChar = str.charAt(k);
								if(nextChar != IPv4Address.SEGMENT_SEPARATOR  && nextChar != IPv6Address.SEGMENT_SEPARATOR) {
									return null;
								}
							}
							//defer to the segment check
						} else if(otherChar == '0') {
							if(c == IPv6Address.SEGMENT_SEPARATOR) {
								return null;
							}
							int k = i + 1;
							if(k < otherLen) {
								char nextChar = other.charAt(k);
								if(nextChar != IPv4Address.SEGMENT_SEPARATOR  && nextChar != IPv6Address.SEGMENT_SEPARATOR) {
									return null;
								}
							}
							return Boolean.FALSE;
						}
					}
					if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
						return Boolean.FALSE; // we've alreqdy accounted for the case of container address 0 segment, so it is non-zero, so ending matching segment here is false match
					} else if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
						if(!isIPv4) {
							return null; //mixed address
						}
						otherSegmentCount++;
					}
				}
				
				//if other is a range like 3-3 must return null
				for(int k = i + 1; k < otherLen; k++) {
					otherChar = other.charAt(k);
					if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
						return Boolean.FALSE;
					} else if(otherChar <= IPAddress.PREFIX_LEN_SEPARATOR && otherChar >= Address.SEGMENT_SQL_WILDCARD) {
						if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
							if(!isIPv4) {
								return null; //mixed address
							}
							otherSegmentCount++;
						} else {
							if(otherChar == IPAddress.PREFIX_LEN_SEPARATOR || otherChar == Address.SEGMENT_WILDCARD || 
									otherChar == Address.RANGE_SEPARATOR || otherChar == Address.SEGMENT_SQL_WILDCARD ||
									otherChar == Address.SEGMENT_SQL_SINGLE_WILDCARD) {
								return null;
							}
						}
					}
				}
				if(isIPv4) {
					// if we match ipv4 seg count and we see no wildcards or other special chars, we can conclude non-containment
					if(otherSegmentCount + 1 == IPv4Address.SEGMENT_COUNT) {
						return Boolean.FALSE;
					}
				} else {
					// for ipv6 we have already checked for compression and special chars.  If we are not single segment, then we can conclude non-containment
					if(otherSegmentCount > 0) {
						return Boolean.FALSE;
					}
				}
				return null;
			}
			if(c != '0') {
				boolean isSegmentEnd = c == IPv6Address.SEGMENT_SEPARATOR || c == IPv4Address.SEGMENT_SEPARATOR;
				if(isSegmentEnd) {
					otherSegmentCount++;
					currentSegHasNonZeroDigits = false;
				} else {
					currentSegHasNonZeroDigits = true;
				}
			}
		}
		// At this point we know the prefix matches, so we need to prove that the provided string is indeed a valid ip address
		if(pref != null) {
			if(prefixEndCharIndex == otherLen) {  
				if(networkSegsCount != expectedCount) {
					// we are ok if compressed and networkSegsCount <= expectedCount which is 8 for ipv6, for example 1::/64 matching 1::, there are only 4 network segs
					if(!compressedAlready || networkSegsCount > expectedCount) {
						return null;
					}
				}
			} else {
				if(isIPv4) {
					if(pref != 0) {
						//we must match the same number of chars til end of segment, otherwise we might not have matched that last segment at all
						//we also cannot make conclusions when not matching due to '-' or '_' characters or matching leading zeros
						int segmentEndIndex = prefixEndCharIndex + adjustment;
						if(otherLen < segmentEndIndex) {
							return null;
						}
						if(otherLen != segmentEndIndex && other.charAt(segmentEndIndex) != IPv4Address.SEGMENT_SEPARATOR) {
							return null;
						}
						for(int n = prefixEndCharIndex; n < segmentEndIndex; n++) {
							char otherChar = other.charAt(n);
							if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
								return null;
							}
						}
					}
					
					//now count the remaining segments and check those chars
					int digitCount = 0;
					int remainingSegCount = 0;
					boolean firstIsHighIPv4 = false;
					int i = remainingSegsCharIndex;
					for(; i < otherLen; i++) {
						char otherChar = other.charAt(i);
						if(otherChar <= '9' && otherChar >= '0') {
							if(digitCount == 0 && otherChar >= '3') {
								firstIsHighIPv4 = true;
							}
							++digitCount;
						} else if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
							if(digitCount == 0) {
								return Boolean.FALSE;
							}
							if(firstIsHighIPv4) {
								if(digitCount >= IPv4AddressSegment.MAX_CHARS) {
									return Boolean.FALSE;
								}
							} else if(digitCount > IPv4AddressSegment.MAX_CHARS) {
								return null;//leading zeros or inet_aton formats
							}
							digitCount = 0;
							remainingSegCount++;
							firstIsHighIPv4 = false;
						} else { 
							return null; //some other character, possibly base 85, also '/' or wildcards
						}
					} // end for
					if(digitCount == 0) {
						return Boolean.FALSE;
					}
					if(digitCount > IPv4AddressSegment.MAX_CHARS) {
						return null;
					} else if(firstIsHighIPv4 && digitCount == IPv4AddressSegment.MAX_CHARS) {
						return null;
					}
					int totalSegCount = networkSegsCount + remainingSegCount + 1;
					if(totalSegCount != expectedCount) {
						return null;
					}
				} else {
					if(pref != 0) {
						// we must match the same number of chars til end of segment, otherwise we might not have matched that last segment at all
						// we also cannot make conclusions when not matching due to '-' or '_' characters or matching leading zeros
						// end of prefixed segment must be followed by separator eg 1:2 is prefix and must be followed by :
						// also note this handles 1:2:: as prefix
						int segmentEndIndex = prefixEndCharIndex + adjustment;
						if(otherLen < segmentEndIndex) {
							return null;
						}
						if(otherLen != segmentEndIndex && other.charAt(segmentEndIndex) != IPv6Address.SEGMENT_SEPARATOR) {
							return null;
						}
						for(int n = prefixEndCharIndex; n < segmentEndIndex; n++) {
							char otherChar = other.charAt(n);
							if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
								return null;
							}
						}
					}
					
					//now count the remaining segments and check those chars
					int digitCount = 0;
					int remainingSegCount = 0;
					int i = remainingSegsCharIndex;
					for(; i < otherLen; i++) {
						char otherChar = other.charAt(i);		
						if(otherChar <= '9' && otherChar >= '0') {
							++digitCount;
						} else if((otherChar >= 'a' && otherChar <= 'f') || (otherChar >= 'A' && otherChar <= 'F')) {
							++digitCount;
						} else if(otherChar == IPv4Address.SEGMENT_SEPARATOR) {
							return null; // could be ipv6/ipv4 mixed
						} else if(otherChar == IPv6Address.SEGMENT_SEPARATOR) {
							if(digitCount > IPv6AddressSegment.MAX_CHARS) {
								return null;//possibly leading zeros or ranges
							}
							if(digitCount == 0) {
								if(compressedAlready) {
									return Boolean.FALSE;
								}
								compressedAlready = true;
							} else {
								digitCount = 0;
							}
							remainingSegCount++;
						} else { 
							return null; //some other character, possibly base 85, also '/' or wildcards
						}
					} // end for
					if(digitCount == 0) {
						int prevIndex = i - 1;
						if(prevIndex < 0) {
							return Boolean.FALSE;
						}
						char prevChar = other.charAt(prevIndex);
						if(prevChar != IPv6Address.SEGMENT_SEPARATOR) { // cannot end with empty segment unless prev segment also empty
							return Boolean.FALSE;
						}
					} else if(digitCount > IPv6AddressSegment.MAX_CHARS) {
						return null;
					}
					int totalSegCount = networkSegsCount + remainingSegCount + 1;
					if(totalSegCount > expectedCount || (totalSegCount < expectedCount && !compressedAlready)) {
						return null;
					}
					if(networkSegIsCompressed && expectedCount - remainingSegCount <= networkSegIndex) {
						//consider 1:: and you are looking at segment 7
						//So we look at the front and we see it matches 1::
						//But what if the end is 1::3:4:5?
						return null;
					}
				}
			}
		}
		return Boolean.TRUE;
	}
	@Override
	public Boolean contains(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				// one or the other value not yet created, so take the shortcut that provides an answer most (but not all) of the time
				// An answer is provided for all normalized, conventional or canonical addresses
				return contains((ParsedIPAddress) other, false, false);
			} // else we defer to the values-based containment check (in the caller), which is best since it is ready to go
		}
		return null;
	}
	@Override
	public Boolean parsedEquals(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				// one or the other value not yet created, so take the shortcut that provides an answer most (but not all) of the time
				// An answer is provided for all normalized, conventional or canonical addresses
				ParsedIPAddress parsedOther = (ParsedIPAddress) other;
				Boolean result = contains(parsedOther, false, true);
				if(result != null) {
					return result && Objects.equals(getQualifier().getZone(), parsedOther.getQualifier().getZone());
				} // else we defer to the values-based equality check (in the caller), which is best since it is ready to go.
			}
		}
		return null;
	}
	@Override
	public Boolean prefixContains(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				// one or the other value not yet created, so take the shortcut that provides an answer most (but not all) of the time
				// An answer is provided for all normalized, conventional or canonical addresses
				return contains((ParsedIPAddress) other, true, false);
			} // else we defer to the values-based containment check (in the caller), which is best since it is ready to go.
		}
		return null;
	}
	
	@Override
	public Boolean prefixEquals(IPAddressProvider other) {
		if(other instanceof ParsedIPAddress) {
			CachedIPAddresses<?> vals = values;
			CachedIPAddresses<?> otherVals = values;
			if(vals == null || otherVals == null) {
				// one or the other value not yet created, so take the shortcut that provides an answer most (but not all) of the time
				// An answer is provided for all normalized, conventional or canonical addresses
				return contains((ParsedIPAddress) other, true, true);
			} // else we defer to the values-based containment check (in the caller), which is best since it is ready to go.
		}
		return null;
	}
	//not used for invalid, or cases where parseData.isEmpty or parseData.isAll
	private Boolean contains(ParsedIPAddress other, boolean networkOnly, boolean equals) {
		AddressParseData parseData = getAddressParseData();
		AddressParseData otherParseData = other.getAddressParseData();
		int segmentData[] = parseData.getSegmentData(); //grab this field for thread safety, other threads can make it disappear
		int otherSegmentData[] = otherParseData.getSegmentData(); //grab this field for thread safety, other threads can make it disappear
		if(segmentData == null || otherSegmentData == null) {
			return null;
		}
		Integer pref = getProviderNetworkPrefixLength();
		boolean skipMixed = !networkOnly || pref == null || pref > (IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT << 4);
		if(skipContains(skipMixed) || other.skipContains(skipMixed)) { // this excludes mixed addresses, amongst others
			return null;
		}
		IPVersion ipVersion = getProviderIPVersion();
		if(!ipVersion.equals(other.getProviderIPVersion())) {
			return Boolean.FALSE;
		}
		int max;
		IPAddressNetwork<? extends IPAddress, ?, ?, ?, ?> network;
		boolean compressedAlready, otherCompressedAlready;
		int expectedSegCount, expectedOtherSegCount, bitsPerSegment, bytesPerSegment;
		IPAddressStringParameters options = getParameters();
		int segmentCount = parseData.getSegmentCount();
		int otherSegmentCount = otherParseData.getSegmentCount();
		if(isProvidingIPv4()) {
			max = IPv4Address.MAX_VALUE_PER_SEGMENT;
			expectedSegCount = expectedOtherSegCount = IPv4Address.SEGMENT_COUNT;
			bitsPerSegment = IPv4Address.BITS_PER_SEGMENT;
			bytesPerSegment = IPv4Address.BYTES_PER_SEGMENT;
			network = options.getIPv4Parameters().getNetwork();
			compressedAlready = true;
			otherCompressedAlready = true;
		} else {
			max = IPv6Address.MAX_VALUE_PER_SEGMENT;
			expectedSegCount = expectedOtherSegCount = IPv6Address.SEGMENT_COUNT;
			if(isProvidingMixedIPv6()) {
				expectedSegCount -= 2;
			}
			if(other.isProvidingMixedIPv6()) {
				expectedOtherSegCount -= 2;
			}
			bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
			bytesPerSegment = IPv6Address.BYTES_PER_SEGMENT;
			network = options.getIPv6Parameters().getNetwork();
			compressedAlready = expectedSegCount == segmentCount;
			otherCompressedAlready = expectedOtherSegCount == otherSegmentCount;
		}
		PrefixConfiguration prefConf = network.getPrefixConfiguration();
		boolean zeroHostsAreSubnets = prefConf.zeroHostsAreSubnets();
		boolean allPrefixedAddressesAreSubnets = prefConf.allPrefixedAddressesAreSubnets();
		Integer otherPref = other.getProviderNetworkPrefixLength();
		int networkSegIndex, hostSegIndex, endIndex, otherHostAllSegIndex, hostAllSegIndex;
		endIndex = segmentCount;
		
		// determine what indexes to use for network, host, and prefix block adjustments (hostAllSegIndex and otherHostAllSegIndex)
		Integer adjustedOtherPref = null;
		if(pref == null) {
			networkOnly = false;
			hostAllSegIndex = hostSegIndex = expectedSegCount;
			otherHostAllSegIndex = expectedOtherSegCount;
			networkSegIndex = hostSegIndex - 1;
		} else if(networkOnly) {
			hostAllSegIndex = otherHostAllSegIndex = hostSegIndex = ParsedAddressGrouping.getHostSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			// we treat the other as if it were a prefix block of the same prefix length
			// this allows us to compare entire segments for prefixEquals, ignoring the host values
			adjustedOtherPref = pref;
		} else {
			otherHostAllSegIndex = expectedOtherSegCount;
			hostSegIndex = ParsedAddressGrouping.getHostSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			networkSegIndex = ParsedAddressGrouping.getNetworkSegmentIndex(pref, bytesPerSegment, bitsPerSegment);
			if(allPrefixedAddressesAreSubnets || 
					(zeroHostsAreSubnets && isPrefixSubnet(pref, network, segmentData))) {
				hostAllSegIndex = hostSegIndex;
				if(!equals) {
					// no need to look at host for containment when a prefix subnet
					networkOnly = true;
				}
			} else {
				hostAllSegIndex = expectedSegCount;
			}
		}
		// Now determine if the other is a prefix block subnet, and if so, adjust otherHostAllSegIndex
		if(otherPref != null) {
			int otherPrefLen = otherPref.intValue();
			if (adjustedOtherPref == null || otherPrefLen < adjustedOtherPref) {
				int otherHostIndex = ParsedAddressGrouping.getHostSegmentIndex(otherPrefLen, bytesPerSegment, bitsPerSegment);
				if(otherHostIndex < otherHostAllSegIndex &&
						(allPrefixedAddressesAreSubnets || (zeroHostsAreSubnets && other.isPrefixSubnet(otherPrefLen, network, otherSegmentData)))) {
					otherHostAllSegIndex = otherHostIndex;
				}
			} else {
				otherPref = adjustedOtherPref;
			}
		} else {
			otherPref = adjustedOtherPref;
		}
		
		int i = 0, j = 0, normalizedCount = 0;
		int compressedCount, otherCompressedCount;
		compressedCount = otherCompressedCount = 0;
		while(i < endIndex || compressedCount > 0) {
			if(networkOnly && normalizedCount > networkSegIndex) {
				break;
			}		
			long lower, upper;
		    if(compressedCount > 0) {
		    	lower = upper = 0;
		    } else {
		    	lower = getValue(i, AddressParseData.KEY_LOWER, segmentData);
		    	upper = getValue(i, AddressParseData.KEY_UPPER, segmentData);
		    }
		    if(normalizedCount >= hostAllSegIndex) { // we've reached the prefixed segment
			   	Integer segPrefLength = ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, pref, normalizedCount);
				lower &= network.getSegmentNetworkMask(segPrefLength);
				upper |= network.getSegmentHostMask(segPrefLength);
			}
			long otherLower, otherUpper;
			if(normalizedCount > otherHostAllSegIndex) {
				otherLower = 0;
				otherUpper = max;
			} else {
				if(otherCompressedCount > 0) {
					otherLower = otherUpper = 0;
				} else {
					otherLower = getValue(j, AddressParseData.KEY_LOWER, otherSegmentData);
					otherUpper = getValue(j, AddressParseData.KEY_UPPER, otherSegmentData);
				}
				if(normalizedCount == otherHostAllSegIndex) { // we've reached the prefixed segment
					Integer segPrefLength = ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, otherPref, normalizedCount);
					otherLower &= network.getSegmentNetworkMask(segPrefLength);
					otherUpper |= network.getSegmentHostMask(segPrefLength);
				}
			}
			if(equals ? (lower != otherLower || upper != otherUpper) : (lower > otherLower || upper < otherUpper)) {
				return Boolean.FALSE;
			}
			if(!compressedAlready) {
				if(compressedCount > 0) {
					if(--compressedCount == 0) {
						compressedAlready = true;
					}
				} else if(isCompressed(i, segmentData)) {
					i++;
					compressedCount = expectedSegCount - segmentCount;
				} else {
					i++;
				}
			} else {
				i++;
			}
			if(!otherCompressedAlready) {
				if(otherCompressedCount > 0) {
					if(--otherCompressedCount == 0) {
						otherCompressedAlready = true;
					}
				} else if(other.isCompressed(j, otherSegmentData)) {
					j++;
					otherCompressedCount = expectedOtherSegCount - otherSegmentCount;
				} else {
					j++;
				}
			} else {
				j++;
			}
			normalizedCount++;
		}
		return Boolean.TRUE;
	}
	//we do not call this method with parse data from inet_aton or single segment strings, so the cast to int is fine.
	//this is only for addresses with standard segment counts, although we do allow compressed.
	protected boolean isPrefixSubnet(Integer networkPrefixLength, IPAddressNetwork<?, ?, ?, ?, ?> network, int segmentData[]) {
		IPVersion version = network.getIPVersion();
		int bytesPerSegment = IPAddressSection.bytesPerSegment(version);
		int bitsPerSegment = IPAddressSection.bitsPerSegment(version);
		int max = IPAddressSegment.getMaxSegmentValue(version);
		PrefixConfiguration prefConf = network.getPrefixConfiguration();
		AddressParseData addressParseData = getAddressParseData();
		int segmentCount = addressParseData.getSegmentCount();
		if(isCompressed()) {
			int compressedCount = IPv6Address.SEGMENT_COUNT - segmentCount;
			int compressedIndex = addressParseData.getConsecutiveSeparatorSegmentIndex();
			return ParsedAddressGrouping.isPrefixSubnet(
					segmentIndex -> {
						if(segmentIndex >= compressedIndex) {
							if(segmentIndex - compressedIndex < compressedCount) {
								return 0;
							}
							segmentIndex -= compressedCount;
						}
						return (int) getValue(segmentIndex, AddressParseData.KEY_LOWER, segmentData);
					},
					segmentIndex -> {
						if(segmentIndex >= compressedIndex) {
							if(segmentIndex - compressedIndex < compressedCount) {
								return 0;
							}
							segmentIndex -= compressedCount;
						}
						return (int) getValue(segmentIndex, AddressParseData.KEY_UPPER, segmentData);
					},
					segmentCount + compressedCount,
					bytesPerSegment,
					bitsPerSegment,
					max,
					networkPrefixLength,
					prefConf,
					false);
		}
		//we do not enter this method with parse data from inet_aton or single segment strings, so the cast to int is fine
		return ParsedAddressGrouping.isPrefixSubnet(
				segmentIndex -> (int) getValue(segmentIndex, AddressParseData.KEY_LOWER, segmentData),
				segmentIndex -> (int) getValue(segmentIndex, AddressParseData.KEY_UPPER, segmentData),
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				max,
				networkPrefixLength,
				prefConf,
				false);
	}
	@Override 
	public Integer getProviderNetworkPrefixLength() {
		return getQualifier().getEquivalentPrefixLength();
	}
	private static <S extends IPAddressSegment> S[] allocateSegments(
			S segments[],
			S originalSegments[],
			AddressSegmentCreator<S> creator,
			int segmentCount,
			int originalCount) {
		if(segments == null) {
			segments = creator.createSegmentArray(segmentCount);
			if(originalCount > 0) {
				System.arraycopy(originalSegments, 0, segments, 0, originalCount);
			}
		}
		return segments;
	}
	private void createIPv4Sections(boolean doAddress, boolean doRangeBoundaries, boolean withUpper) {
		ParsedHostIdentifierStringQualifier qualifier = getQualifier();
		IPAddress mask = getProviderMask();
		if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
			mask = null; // we don't do any masking if the mask is a subnet mask, instead we just map it to the corresponding prefix length
		}
		boolean hasMask = mask != null;
		AddressParseData addrParseData = getAddressParseData();
		int segmentCount = addrParseData.getSegmentCount();
		if(hasMask && maskers == null) {
			maskers = new Masker[segmentCount];
		}
		IPv4AddressCreator creator = getIPv4AddressCreator();
		int ipv4SegmentCount = IPv4Address.SEGMENT_COUNT;
		int missingCount = ipv4SegmentCount - segmentCount;
		
		IPv4AddressSegment[] hostSegments, segments, lowerSegments, upperSegments = null;
		hostSegments = upperSegments = null;
		if(doAddress) {
			segments = creator.createSegmentArray(ipv4SegmentCount);
			lowerSegments = null;
		} else if(doRangeBoundaries) {
			lowerSegments = creator.createSegmentArray(ipv4SegmentCount);
			segments = null;
		} else {
			return;
		}
		@SuppressWarnings("unchecked")
		TranslatedResult<IPv4Address, IPv4AddressSection> finalResult = 
				(TranslatedResult<IPv4Address, IPv4AddressSection>) values;
		if(values == null) {
			values = finalResult = new TranslatedResult<IPv4Address, IPv4AddressSection>() {
				/**
				 * 
				 */
				private static final long serialVersionUID = 1L;
				@Override
				ParsedAddressCreator<IPv4Address, IPv4AddressSection, ?, ?> getCreator() {
					return getIPv4AddressCreator();
				}
			};
		}
		boolean expandedSegments = (missingCount <= 0);
		int expandedStart, expandedEnd;
		expandedStart = expandedEnd = -1;
		CharSequence addressString = str;
		boolean maskedIsDifferent = false;
		for(int i = 0, normalizedSegmentIndex = 0; i < segmentCount; i++) {
			long lower = addrParseData.getValue(i, AddressParseData.KEY_LOWER);
			long upper = addrParseData.getValue(i, AddressParseData.KEY_UPPER);
			if(!expandedSegments) {
				//check for any missing segments that we should account for here
				boolean isLastSegment = i == segmentCount - 1;
				boolean isWildcard = addrParseData.isWildcard(i);
				expandedSegments = isLastSegment;
				if(!expandedSegments) {
					// if we are inet_aton, we must wait for last segment
					// otherwise, we check if we are wildcard and no other wildcard further down
					expandedSegments = !is_inet_aton_joined() && isWildcard;
					if(expandedSegments) {
						for(int j = i + 1; j < segmentCount; j++) {
							if(addrParseData.isWildcard(j)) {//another wildcard further down
								expandedSegments = false;
								break;
							}
						}
					}
				} 
				if(expandedSegments) {
					if(isWildcard) {
						upper = 0xffffffff >>> ((3 - missingCount) << 3);
					} else {
						expandedStart = i;
						expandedEnd = i + missingCount;
					}
					int bits = IPv4Address.BITS_PER_SEGMENT * (missingCount + 1);
					long maskedLower, maskedUpper;
					if(hasMask) {
						long divMask = 0;
						for(int k = 0; k <= missingCount; k++) {
							divMask = (divMask << IPv4Address.BITS_PER_SEGMENT) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
						}
						Masker masker = maskers[i];
						if(masker == null) {
							long maxValue = (bits == Integer.SIZE) ? 0xffffffffL : ~(~0 << bits);
							maskers[i] = masker = maskRange(lower, upper, divMask, maxValue);
						}
						if(!masker.isSequential() && finalResult.maskException == null) {
							finalResult.maskException = new IncompatibleAddressException(lower, upper, divMask, "ipaddress.error.maskMismatch");
						}
						maskedLower = masker.getMaskedLower(lower, divMask);
						maskedUpper = masker.getMaskedUpper(upper, divMask);
						maskedIsDifferent = maskedIsDifferent || maskedLower != lower || maskedUpper != upper;
					} else {
						maskedLower = lower;
						maskedUpper = upper;
					}
					int shift = bits;
					int count = missingCount;
					while(count >= 0) { //add the missing segments
						shift -= IPv4Address.BITS_PER_SEGMENT;
						Integer currentPrefix = getSegmentPrefixLength(normalizedSegmentIndex, IPv4Address.BITS_PER_SEGMENT, qualifier);
						int segmentBitsMask = IPv4Address.MAX_VALUE_PER_SEGMENT;
						int hostSegLower = (int) (lower >>> shift) & segmentBitsMask;
						int hostSegUpper = (lower == upper) ? hostSegLower : (int) (upper >>> shift) & segmentBitsMask;
						int maskedSegLower, maskedSegUpper;
						if(hasMask) {
							maskedSegLower = (int) (maskedLower >>> shift) & segmentBitsMask;
							maskedSegUpper = (maskedLower == maskedUpper) ? maskedSegLower : (int) (maskedUpper >>> shift) & segmentBitsMask;
						} else {
							maskedSegLower = hostSegLower;
							maskedSegUpper = hostSegUpper;
						}
						if(doAddress) {
							if(maskedIsDifferent || currentPrefix != null) {
								hostSegments = allocateSegments(hostSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
								hostSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV4,
										hostSegLower,
										hostSegUpper,
										false,
										i,
										null,
										creator);
							}
							segments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV4,
								maskedSegLower,
								maskedSegUpper,
								false,
								i,
								currentPrefix,
								creator);
						}
						if(doRangeBoundaries) {
							boolean isRange = maskedSegLower != maskedSegUpper;
							if(!doAddress || isRange) {
								if(doAddress) {
									lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
								} // else segments already allocated
								lowerSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV4,
										maskedSegLower,
										maskedSegLower,
										false,
										i,
										currentPrefix,
										creator);
							} else if(lowerSegments != null) {
								lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
							}
							if(withUpper) {
								if(isRange) {
									upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv4SegmentCount, normalizedSegmentIndex);
									upperSegments[normalizedSegmentIndex] = createSegment(
											addressString,
											IPVersion.IPV4,
											maskedSegUpper,
											maskedSegUpper,
											false,
											i,
											currentPrefix,
											creator);
								} else if(upperSegments != null) {
									upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
								}
							}
						}
						++normalizedSegmentIndex;
						count--;
					}
					addrParseData.setBitLength(i, bits);
					continue;
				} //end handle inet_aton joined segments
			}
			long hostLower = lower, hostUpper = upper;
			Masker masker = null;
			boolean unmasked = true;
			if(hasMask) {
				masker = maskers[i];
				int maskInt = mask.getSegment(normalizedSegmentIndex).getSegmentValue();
				if(masker == null) {
					maskers[i] = masker = maskRange(lower, upper, maskInt, creator.getMaxValuePerSegment());
				}
				if(!masker.isSequential() && finalResult.maskException == null) {
					finalResult.maskException = new IncompatibleAddressException(lower, upper, maskInt, "ipaddress.error.maskMismatch");
				}
				lower = (int) masker.getMaskedLower(lower, maskInt);
				upper = (int) masker.getMaskedUpper(upper, maskInt);
				unmasked = hostLower == lower && hostUpper == upper;
				maskedIsDifferent = maskedIsDifferent || !unmasked;
			}
			Integer segmentPrefixLength = getSegmentPrefixLength(normalizedSegmentIndex, IPv4Address.BITS_PER_SEGMENT, qualifier);
			if(doAddress) {
				if(maskedIsDifferent || segmentPrefixLength != null) {
					hostSegments = allocateSegments(hostSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
					hostSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV4,
							(int) hostLower,
							(int) hostUpper,
							true,
							i,
							null,
							creator);
				}
				segments[normalizedSegmentIndex] = createSegment(
						addressString,
						IPVersion.IPV4,
						(int) lower,
						(int) upper,
						unmasked,
						i,
						segmentPrefixLength,
						creator);
			}
			if(doRangeBoundaries) {
				boolean isRange = lower != upper;
				if(!doAddress || isRange) {
					if(doAddress) {
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv4SegmentCount, normalizedSegmentIndex);
					} // else segments already allocated
					lowerSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV4,
							(int) lower,
							(int) lower,
							false,
							i,
							segmentPrefixLength,
							creator);
				} else if(lowerSegments != null) {
					lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
				}
				if(withUpper) {
					if(isRange) {
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv4SegmentCount, normalizedSegmentIndex);
						upperSegments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV4,
								(int) upper,
								(int) upper,
								false,
								i,
								segmentPrefixLength,
								creator);
					} else if(upperSegments != null) {
						upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
					}
				}
			}
			normalizedSegmentIndex++;
			addrParseData.setBitLength(i, IPv4Address.BITS_PER_SEGMENT);
		}
		ParsedAddressCreator<IPv4Address, IPv4AddressSection, ?, IPv4AddressSegment> addressCreator = creator;
		Integer prefLength = getPrefixLength(qualifier);
		IPv4AddressSection result, hostResult = null;
		if(doAddress) {
			finalResult.section = result = addressCreator.createPrefixedSectionInternal(segments, prefLength);
			if(hostSegments != null) {
				finalResult.hostSection = hostResult = addressCreator.createSectionInternal(hostSegments);
				if(checkExpandedValues(hostResult, expandedStart, expandedEnd)) {
					finalResult.joinHostException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				}
			}
			if(checkExpandedValues(result, expandedStart, expandedEnd)) {
				finalResult.joinAddressException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				if(hostResult == null) {
					finalResult.joinHostException = finalResult.joinAddressException;
				}
			}
		}
		if(doRangeBoundaries) {
			// if we have a prefix subnet, it is possible our lower and upper boundaries exceed what appears in the parsed address
			Integer prefixLength = getPrefixLength(qualifier);
			boolean isPrefixSubnet;
			if(prefixLength != null) {
				IPAddressNetwork<?, ?, ?, ?, ?> network = getParameters().getIPv4Parameters().getNetwork();
				IPv4AddressSegment[] lowerSegs, upperSegs;
				if(doAddress) {
					lowerSegs = upperSegs = segments;
				} else {
					lowerSegs = lowerSegments;
					upperSegs = (upperSegments == null) ? lowerSegments : upperSegments;
				}
				isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
						segmentIndex -> lowerSegs[segmentIndex].getSegmentValue(),
						segmentIndex -> upperSegs[segmentIndex].getUpperSegmentValue(),
						lowerSegs.length,
						IPv4Address.BYTES_PER_SEGMENT,
						IPv4Address.BITS_PER_SEGMENT,
						IPv4Address.MAX_VALUE_PER_SEGMENT,
						prefixLength,
						network.getPrefixConfiguration(),
						false);
				if(isPrefixSubnet) {
					if(lowerSegments == null) {
						//allocate lower segments from address segments
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv4SegmentCount, ipv4SegmentCount);
					}
					if(upperSegments == null) {
						//allocate upper segments from lower segments
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv4SegmentCount, ipv4SegmentCount);
					}
				}
			} else {
				isPrefixSubnet = false;
			}
			if(lowerSegments != null) {
				finalResult.lowerSection = addressCreator.createPrefixedSectionInternal(lowerSegments, prefLength, true).getLower();
			}
			if(upperSegments != null) {
				IPv4AddressSection section = addressCreator.createPrefixedSectionInternal(upperSegments, prefLength);
				if(isPrefixSubnet) {
					section = section.toPrefixBlock();
				}
				finalResult.upperSection = section.getUpper();
			}
		}
	}
	private void createIPv6Sections(boolean doAddress, boolean doRangeBoundaries, boolean withUpper) {
		ParsedHostIdentifierStringQualifier qualifier = getQualifier();
		IPAddress mask = getProviderMask();
		if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
			mask = null;//we don't do any masking if the mask is a subnet mask, instead we just map it to the corresponding prefix length
		}
		boolean hasMask = mask != null;
		AddressParseData addressParseData = getAddressParseData();
		int segmentCount = addressParseData.getSegmentCount();
		if(hasMask && maskers == null) {
			maskers = new Masker[segmentCount];
		}
		IPv6AddressCreator creator = getIPv6AddressCreator();
		int ipv6SegmentCount = IPv6Address.SEGMENT_COUNT;
		
		IPv6AddressSegment[] hostSegments, segments, lowerSegments, upperSegments = null;
		hostSegments = upperSegments = null;
		if(doAddress) {
			segments = creator.createSegmentArray(ipv6SegmentCount);
			lowerSegments = null;
		} else if(doRangeBoundaries) {
			lowerSegments = creator.createSegmentArray(ipv6SegmentCount);
			segments = null;
		} else {
			return;
		}
		@SuppressWarnings("unchecked")
		TranslatedResult<IPv6Address,IPv6AddressSection> finalResult = 
				(TranslatedResult<IPv6Address, IPv6AddressSection>) values;
		if(values == null) {
			values = finalResult = new TranslatedResult<IPv6Address,IPv6AddressSection>() {
				/**
				 * 
				 */
				private static final long serialVersionUID = 1L;
				@Override
				ParsedAddressCreator<IPv6Address, IPv6AddressSection, ?, ?> getCreator() {
					return getIPv6AddressCreator();
				}
			};
		}
		boolean mixed = isProvidingMixedIPv6();
		int normalizedSegmentIndex = 0;
		int missingSegmentCount = (mixed ? IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT : ipv6SegmentCount) - segmentCount;
		boolean expandedSegments = (missingSegmentCount <= 0);
		int expandedStart, expandedEnd;
		expandedStart = expandedEnd = -1;
		CharSequence addressString = str;
		boolean maskedIsDifferent = false;
		
		//get the segments for IPv6
		for(int i = 0; i < segmentCount; i++) {
			long lower = addressParseData.getValue(i, AddressParseData.KEY_LOWER);
			long upper = addressParseData.getValue(i, AddressParseData.KEY_UPPER);
			
			if(!expandedSegments) {
				boolean isLastSegment = i == segmentCount - 1;
				boolean isWildcard = addressParseData.isWildcard(i);
				boolean isCompressed = isCompressed(i);
				
				// figure out if this segment should be expanded
				expandedSegments = isLastSegment || isCompressed;
				if(!expandedSegments) {
					// we check if we are wildcard and no other wildcard or compressed segment further down
					if(expandedSegments = isWildcard) {
						for(int j = i + 1; j < segmentCount; j++) {
							if(addressParseData.isWildcard(j) || isCompressed(j)) {
								expandedSegments = false;
								break;
							}
						}
					}
				} 
				if(expandedSegments) {
					long lowerHighBytes, upperHighBytes;
					boolean hostIsRange;
					 if(isCompressed) {
						lower = upper = lowerHighBytes = upperHighBytes = 0;
						hostIsRange = false;
					} else if(isWildcard) {
						if(missingSegmentCount > 3) {
							upperHighBytes = 0xffffffffffffffffL >>> ((7 - missingSegmentCount) << 4);
							upper = 0xffffffffffffffffL;
						} else {
							upperHighBytes = 0;
							upper = 0xffffffffffffffffL >>> ((3 - missingSegmentCount) << 4);
						}
						lower = lowerHighBytes = 0;
						hostIsRange = true;
					} else {
						if(missingSegmentCount > 3) {
							lowerHighBytes = addressParseData.getValue(i, AddressParseData.KEY_EXTENDED_LOWER);//the high half of the lower value
							upperHighBytes = addressParseData.getValue(i, AddressParseData.KEY_EXTENDED_UPPER);//the high half of the upper value
							hostIsRange = (lower != upper) || (lowerHighBytes != upperHighBytes);
						} else {
							lowerHighBytes = upperHighBytes = 0;
							hostIsRange = (lower != upper);
						}
						expandedStart = i;
						expandedEnd = i + missingSegmentCount;
					}
					int bits = IPv6Address.BITS_PER_SEGMENT * (missingSegmentCount + 1);
					long maskedLower, maskedUpper, maskedLowerHighBytes, maskedUpperHighBytes;
					boolean maskedIsRange;
					if(hasMask) {
						// line up the mask segments into two longs
						if(isCompressed) {
							maskers[i] = DEFAULT_MASKER;
							maskedLower = maskedUpper = maskedLowerHighBytes = maskedUpperHighBytes = 0;
							maskedIsRange = false;
						} else {
							int bitsPerSegment = IPv6Address.BITS_PER_SEGMENT;
							long maskVal = 0;
							if(missingSegmentCount >= 4) {
								ExtendedMasker masker = (ExtendedMasker) maskers[i];
								long extendedMaskVal = 0;
								int extendedCount = missingSegmentCount - 3;
								for(int k = 0; k < extendedCount; k++) {
									extendedMaskVal = (extendedMaskVal << bitsPerSegment) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
								}
								for(int k = extendedCount; k <= missingSegmentCount; k++) {
									maskVal = (maskVal << bitsPerSegment) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
								}
								if(masker == null) {
									// shift must be 6 bits at most for this shift to work per the java spec (so it must be less than 2^6 = 64)
									long extendedMaxValue = bits == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << (bits - Long.SIZE));
									maskers[i] = masker = maskExtendedRange(
											lower, lowerHighBytes, 
											upper, upperHighBytes, 
											maskVal, extendedMaskVal, 
											0xffffffffffffffffL, extendedMaxValue);
								}
								if(!masker.isSequential() && finalResult.maskException == null) {
									int byteCount = (missingSegmentCount + 1) * IPv6Address.BYTES_PER_SEGMENT;
									finalResult.maskException = new IncompatibleAddressException(
										new BigInteger(1, toBytesSizeAdjusted(lower, lowerHighBytes, byteCount)).toString(), 
										new BigInteger(1, toBytesSizeAdjusted(upper, upperHighBytes, byteCount)).toString(), 
										new BigInteger(1, toBytesSizeAdjusted(maskVal, extendedMaskVal, byteCount)).toString(),
										"ipaddress.error.maskMismatch");
								}
								maskedLowerHighBytes = masker.getExtendedMaskedLower(lowerHighBytes, extendedMaskVal);
								maskedUpperHighBytes = masker.getExtendedMaskedUpper(upperHighBytes, extendedMaskVal);
								maskedLower = masker.getMaskedLower(lower, maskVal);
								maskedUpper = masker.getMaskedUpper(upper, maskVal);
								maskedIsRange = (maskedLower != maskedUpper) || (maskedLowerHighBytes != maskedUpperHighBytes);
								maskedIsDifferent = maskedIsDifferent || maskedLower != lower || maskedUpper != upper|| maskedLowerHighBytes != lowerHighBytes || maskedUpperHighBytes != upperHighBytes;
							} else {
								Masker masker = maskers[i];
								for(int k = 0; k <= missingSegmentCount; k++) {
									maskVal = (maskVal << bitsPerSegment) | mask.getSegment(normalizedSegmentIndex + k).getSegmentValue();
								}
								if(masker == null) {
									// shift must be 6 bits at most for this shift to work per the java spec (so it must be less than 2^6 = 64)
									long maxValue = bits == Long.SIZE ? 0xffffffffffffffffL : ~(~0L << bits);
									maskers[i] = masker = maskRange(lower, upper, maskVal, maxValue);
								}
								if(!masker.isSequential() && finalResult.maskException == null) {
									finalResult.maskException = new IncompatibleAddressException(lower, upper, maskVal, "ipaddress.error.maskMismatch");
								}
								maskedLowerHighBytes = maskedUpperHighBytes = 0;
								maskedLower = masker.getMaskedLower(lower, maskVal);
								maskedUpper = masker.getMaskedUpper(upper, maskVal);
								maskedIsRange = maskedLower != maskedUpper;
								maskedIsDifferent = maskedIsDifferent || maskedLower != lower || maskedUpper != upper;
							}
						}
					} else {
						maskedLowerHighBytes = lowerHighBytes;
						maskedUpperHighBytes = upperHighBytes;
						maskedLower = lower;
						maskedUpper = upper;
						maskedIsRange = hostIsRange;
					}
					int shift = bits;
					int count = missingSegmentCount;
					while(count >= 0) { // add the missing segments
						Integer currentPrefix = getSegmentPrefixLength(normalizedSegmentIndex, IPv6Address.BITS_PER_SEGMENT, qualifier);
						int hostSegLower, hostSegUpper, maskedSegLower, maskedSegUpper;
						if(isCompressed) {
							hostSegLower = hostSegUpper = maskedSegLower = maskedSegUpper = 0;
						} else {
							shift -= IPv6Address.BITS_PER_SEGMENT;
							int segmentBitsMask = IPv6Address.MAX_VALUE_PER_SEGMENT;
							if(count >= 4) {
								int shorterShift = shift - (IPv6Address.BITS_PER_SEGMENT << 2);
								hostSegLower = (int) (lowerHighBytes >>> shorterShift) & segmentBitsMask;
								hostSegUpper = hostIsRange ? (int) (upperHighBytes >>> shorterShift) & segmentBitsMask : hostSegLower;
								if(hasMask) {
									maskedSegLower = (int) (maskedLowerHighBytes >>> shorterShift) & segmentBitsMask;
									maskedSegUpper = maskedIsRange ? (int) (maskedUpperHighBytes >>> shorterShift) & segmentBitsMask : maskedSegLower;
								} else {
									maskedSegLower = hostSegLower;
									maskedSegUpper = hostSegUpper;
								}
							} else {
								hostSegLower = (int) (lower >>> shift) & segmentBitsMask;
								hostSegUpper = hostIsRange ? (int) (upper >>> shift) & segmentBitsMask : hostSegLower;
								if(hasMask) {
									maskedSegLower = (int) (maskedLower >>> shift) & segmentBitsMask;
									maskedSegUpper = maskedIsRange ? (int) (maskedUpper >>> shift) & segmentBitsMask : maskedSegLower;
								} else {
									maskedSegLower = hostSegLower;
									maskedSegUpper = hostSegUpper;
								}
							}
						}
						if(doAddress) {
							if(maskedIsDifferent || currentPrefix != null) {
								hostSegments = allocateSegments(hostSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
								hostSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV6,
										hostSegLower,
										hostSegUpper,
										false,
										i,
										null,
										creator);
							}
							segments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV6,
								maskedSegLower,
								maskedSegUpper,
								false,
								i,
								currentPrefix,
								creator);
						}
						if(doRangeBoundaries) {
							boolean isSegRange = maskedSegLower != maskedSegUpper;
							if(!doAddress || isSegRange) {
								if(doAddress) {
									lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
								} // else segments already allocated
								lowerSegments[normalizedSegmentIndex] = createSegment(
										addressString,
										IPVersion.IPV6,
										maskedSegLower,
										maskedSegLower,
										false,
										i,
										currentPrefix,
										creator);
								
							} else if(lowerSegments != null) {
								lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
							}
							if(withUpper) {
								if(isSegRange) {
									upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, normalizedSegmentIndex);
									upperSegments[normalizedSegmentIndex] = createSegment(
											addressString,
											IPVersion.IPV6,
											maskedSegUpper,
											maskedSegUpper,
											false,
											i,
											currentPrefix,
											creator);
								} else if(upperSegments != null) {
									upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
								}
							}
						}
						++normalizedSegmentIndex;
						count--;
					}
					addressParseData.setBitLength(i, bits);
					continue;
				} //end handle joined segments
			}
			long hostLower = lower, hostUpper = upper;
			Masker masker = null;
			boolean unmasked = true;
			if(hasMask) {
				masker = maskers[i];
				int maskInt = mask.getSegment(normalizedSegmentIndex).getSegmentValue();
				if(masker == null) {
					maskers[i] = masker = maskRange(lower, upper, maskInt, creator.getMaxValuePerSegment());
				}
				if(!masker.isSequential() && finalResult.maskException == null) {
					finalResult.maskException = new IncompatibleAddressException(lower, upper, maskInt, "ipaddress.error.maskMismatch");
				}
				lower = (int) masker.getMaskedLower(lower, maskInt);
				upper = (int) masker.getMaskedUpper(upper, maskInt);
				unmasked =  hostLower == lower && hostUpper == upper;
				maskedIsDifferent = maskedIsDifferent || !unmasked;
			}
			Integer segmentPrefixLength = getSegmentPrefixLength(normalizedSegmentIndex, IPv6Address.BITS_PER_SEGMENT, qualifier);
			if(doAddress) {
				if(maskedIsDifferent || segmentPrefixLength != null) {
					hostSegments = allocateSegments(hostSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
					hostSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV6,
							(int) hostLower,
							(int) hostUpper,
							true,
							i,
							null,
							creator);
				}
				segments[normalizedSegmentIndex] = createSegment(
					addressString,
					IPVersion.IPV6,
					(int) lower,
					(int) upper,
					unmasked,
					i,
					segmentPrefixLength,
					creator);
			}
			if(doRangeBoundaries) {
				boolean isRange = lower != upper;
				if(!doAddress || isRange) {
					if(doAddress) {
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
					} // else segments already allocated
					lowerSegments[normalizedSegmentIndex] = createSegment(
							addressString,
							IPVersion.IPV6,
							(int) lower,
							(int) lower,
							false,
							i,
							segmentPrefixLength,
							creator);
				} else if(lowerSegments != null) {
					lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
				}
				if(withUpper) {
					if(isRange) {
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, normalizedSegmentIndex);
						upperSegments[normalizedSegmentIndex] = createSegment(
								addressString,
								IPVersion.IPV6,
								(int) upper,
								(int) upper,
								false,
								i,
								segmentPrefixLength,
								creator);
					} else if(upperSegments != null) {
						upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
					}
				}
			}
			normalizedSegmentIndex++;
			addressParseData.setBitLength(i, IPv6Address.BITS_PER_SEGMENT);
		}
		ParsedAddressCreator<?, IPv6AddressSection, IPv4AddressSection, IPv6AddressSegment> addressCreator = creator;
		Integer prefLength = getPrefixLength(qualifier);
		if(mixed) {
			IPv4AddressSeqRange ipv4Range = (IPv4AddressSeqRange) mixedParsedAddress.getProviderSeqRange();
			if(hasMask && mixedMaskers == null) {
				mixedMaskers = new Masker[IPv4Address.SEGMENT_COUNT];
			}
			for(int n = 0; n < 2; n++) {
				int m = n << 1;
				Integer segmentPrefixLength = getSegmentPrefixLength(normalizedSegmentIndex, IPv6Address.BITS_PER_SEGMENT, qualifier);
				
				IPv4AddressSegment oneLow = ipv4Range.getLower().getSegment(m);
				int o = m + 1;
				IPv4AddressSegment twoLow = ipv4Range.getLower().getSegment(o);
				IPv4AddressSegment oneUp = ipv4Range.getUpper().getSegment(m);
				IPv4AddressSegment twoUp = ipv4Range.getUpper().getSegment(o);
				int oneLower = oneLow.getSegmentValue();
				int twoLower = twoLow.getSegmentValue();
				int oneUpper = oneUp.getSegmentValue();
				int twoUpper = twoUp.getSegmentValue();
				
				int originalOneLower = oneLower;
				int originalTwoLower = twoLower;
				int originalOneUpper = oneUpper;
				int originalTwoUpper = twoUpper;
				
				if(hasMask) {
					int maskInt = mask.getSegment(normalizedSegmentIndex).getSegmentValue();
					int shift = IPv4Address.BITS_PER_SEGMENT;
					int shiftedMask = maskInt >> shift;
					Masker masker = mixedMaskers[m];
					if(masker == null) {
						mixedMaskers[m] = masker = maskRange(oneLower, oneUpper, shiftedMask, IPv4Address.MAX_VALUE_PER_SEGMENT);
					}
					if(!masker.isSequential() && finalResult.maskException == null) {
						finalResult.maskException = new IncompatibleAddressException(oneLower, oneUpper, shiftedMask, "ipaddress.error.maskMismatch");
					}
					oneLower = (int) masker.getMaskedLower(oneLower, shiftedMask);
					oneUpper = (int) masker.getMaskedUpper(oneUpper, shiftedMask);
					masker = mixedMaskers[m + 1];
					if(masker == null) {
						mixedMaskers[m + 1] = masker = maskRange(twoLower, twoUpper, maskInt, IPv4Address.MAX_VALUE_PER_SEGMENT);
					}
					if(!masker.isSequential() && finalResult.maskException == null) {
						finalResult.maskException = new IncompatibleAddressException(twoLower, twoUpper, maskInt, "ipaddress.error.maskMismatch");
					}
					twoLower = (int) masker.getMaskedLower(twoLower, maskInt);
					twoUpper = (int) masker.getMaskedUpper(twoUpper, maskInt);
					maskedIsDifferent = maskedIsDifferent || oneLower != originalOneLower || oneUpper != originalOneUpper ||
							twoLower != originalTwoLower || twoUpper != originalTwoUpper;
				}
				boolean isRange = oneLower != oneUpper || twoLower != twoUpper;
				if(doAddress) {
					boolean doHostSegment = maskedIsDifferent || segmentPrefixLength != null;
					if(doHostSegment) {
						hostSegments = allocateSegments(hostSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
					}
					if(!isRange) {
						if(doHostSegment) {
							hostSegments[normalizedSegmentIndex] = createIPv6Segment(originalOneLower, originalTwoLower, null, creator);
						}
						segments[normalizedSegmentIndex] = createIPv6Segment(
								oneLower,
								twoLower,
								segmentPrefixLength,
								creator);
					} else {
						if(doHostSegment) {
							hostSegments[normalizedSegmentIndex] = createIPv6RangeSegment(
									finalResult,
									ipv4Range,
									originalOneLower,
									originalOneUpper,
									originalTwoLower,
									originalTwoUpper,
									null,
									creator);
						}
						segments[normalizedSegmentIndex] = createIPv6RangeSegment(
								finalResult,
								ipv4Range,
								oneLower,
								oneUpper,
								twoLower,
								twoUpper,
								segmentPrefixLength,
								creator);
					}
				}
				if(doRangeBoundaries) {
					if(!doAddress || isRange) {
						if(doAddress) {
							lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, normalizedSegmentIndex);
						} // else segments already allocated
						lowerSegments[normalizedSegmentIndex] = createIPv6Segment(
								oneLower,
								twoLower,
								segmentPrefixLength,
								creator);
					} else if(lowerSegments != null) {
						lowerSegments[normalizedSegmentIndex] = segments[normalizedSegmentIndex];
					}
					if(withUpper) {
						if(isRange) {
							upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, normalizedSegmentIndex);
							upperSegments[normalizedSegmentIndex] = createIPv6Segment(
									oneUpper,
									twoUpper,
									segmentPrefixLength, // we must keep prefix length for upper to get prefix subnet creation
									creator);
						} else if(upperSegments != null) {
							upperSegments[normalizedSegmentIndex] = lowerSegments[normalizedSegmentIndex];
						}
					}
				}
				normalizedSegmentIndex++;
			}
		}
		IPv6AddressSection result, hostResult = null;
		if(doAddress) {
			if(hostSegments != null) {
				finalResult.hostSection = hostResult = addressCreator.createSectionInternal(hostSegments);
				if(checkExpandedValues(hostResult, expandedStart, expandedEnd)) {
					finalResult.joinHostException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				}
			}
			finalResult.section = result = addressCreator.createPrefixedSectionInternal(segments, prefLength);
			if(checkExpandedValues(result, expandedStart, expandedEnd)) {
				finalResult.joinAddressException = new IncompatibleAddressException(addressString, "ipaddress.error.invalid.joined.ranges");
				if(hostResult == null) {
					finalResult.joinHostException = finalResult.joinAddressException;
				}
			}
		}
		if(doRangeBoundaries) {
			Integer prefixLength = getPrefixLength(qualifier);
			boolean isPrefixSubnet;
			if(prefixLength != null) {
				IPAddressNetwork<?, ?, ?, ?, ?> network = getParameters().getIPv6Parameters().getNetwork();
				IPv6AddressSegment[] lowerSegs, upperSegs;
				if(doAddress) {
					lowerSegs = upperSegs = segments;
				} else {
					lowerSegs = lowerSegments;
					upperSegs = (upperSegments == null) ? lowerSegments : upperSegments;
				}
				isPrefixSubnet = ParsedAddressGrouping.isPrefixSubnet(
						segmentIndex -> lowerSegs[segmentIndex].getSegmentValue(),
						segmentIndex -> upperSegs[segmentIndex].getUpperSegmentValue(),
						lowerSegs.length,
						IPv6Address.BYTES_PER_SEGMENT,
						IPv6Address.BITS_PER_SEGMENT,
						IPv6Address.MAX_VALUE_PER_SEGMENT,
						prefixLength,
						network.getPrefixConfiguration(),
						false);
				if(isPrefixSubnet) {
					if(lowerSegments == null) {
						//allocate lower segments from address segments
						lowerSegments = allocateSegments(lowerSegments, segments, creator, ipv6SegmentCount, ipv6SegmentCount);
					}
					if(upperSegments == null) {
						//allocate upper segments from lower segments
						upperSegments = allocateSegments(upperSegments, lowerSegments, creator, ipv6SegmentCount, ipv6SegmentCount);
					}
				}
			} else {
				isPrefixSubnet = false;
			}
			if(lowerSegments != null) {
				finalResult.lowerSection = addressCreator.createPrefixedSectionInternal(lowerSegments, prefLength, true).getLower(); // getLower needed for all prefix subnet config
			}
			if(upperSegments != null) {
				IPv6AddressSection section = addressCreator.createPrefixedSectionInternal(upperSegments, prefLength);
				if(isPrefixSubnet) {
					section = section.toPrefixBlock();
				}
				finalResult.upperSection = section.getUpper();
			}
		}
	}
	
	/*
	 * When expanding a set of segments into multiple, it is possible that the new segments do not accurately
	 * cover the same ranges of values.  This occurs when there is a range in the upper segments and the lower
	 * segments do not cover the full range (as is the case in the original unexpanded segment).
	 * 
	 * This does not include compressed 0 segments or compressed '*' segments, as neither can have the issue.
	 * 
	 * Returns true if the expansion was invalid.
	 * 
	 */
	private static boolean checkExpandedValues(IPAddressSection section, int start, int end) {
		if(section != null && start < end) {
			IPAddressSegment seg = section.getSegment(start);
			boolean lastWasRange = seg.isMultiple();
			do {
				seg = section.getSegment(++start);
				if(lastWasRange) {
					if(!seg.isFullRange()) {
						return true;
					}
				} else {
					lastWasRange = seg.isMultiple();
				}
			} while(start < end);
		}
		return false;
	}
	private <S extends IPAddressSegment> S createSegment(
			CharSequence addressString,
			IPVersion version,
			int val,
			int upperVal,
			boolean useFlags,
			int parsedSegIndex,
			Integer segmentPrefixLength,
			ParsedAddressCreator<?, ?, ?, S> creator) {
		AddressParseData parseData = getAddressParseData();
		if(val != upperVal) {
			return createRangeSeg(addressString, version, val, upperVal,
					useFlags, parseData, parsedSegIndex,
					segmentPrefixLength, creator);
		}
		S result;
		if(!useFlags) {
			result = creator.createSegment(val, val, segmentPrefixLength);
		} else {
			result = creator.createSegmentInternal(
				val,
				segmentPrefixLength,
				addressString,
				val,
				parseData.getFlag(parsedSegIndex, AddressParseData.KEY_STANDARD_STR),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_END_INDEX));
		}
		return result;
	}
	/*
	 * create an IPv6 segment by joining two IPv4 segments
	 */
	private IPv6AddressSegment createIPv6Segment(int value1, int value2, Integer segmentPrefixLength, IPv6AddressCreator creator) {
		int value = (value1 << IPv4Address.BITS_PER_SEGMENT) | value2;
		IPv6AddressSegment result = creator.createSegment(value, segmentPrefixLength);
		return result;
	}
	/*
	 * create an IPv6 segment by joining two IPv4 segments
	 */
	private static IPv6AddressSegment createIPv6RangeSegment(
			TranslatedResult<?,?> finalResult,
			AddressItem item,
			int upperRangeLower,
			int upperRangeUpper,
			int lowerRangeLower,
			int lowerRangeUpper,
			Integer segmentPrefixLength,
			IPv6AddressCreator creator) {
		int shift = IPv4Address.BITS_PER_SEGMENT;
		if(upperRangeLower != upperRangeUpper) {
			//if the high segment has a range, the low segment must match the full range, 
			//otherwise it is not possible to create an equivalent IPv6 range when joining two IPv4 ranges
			if(segmentPrefixLength != null && creator.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				if(segmentPrefixLength > shift) {
					int lowerPrefixLength = segmentPrefixLength - shift;
					
					int fullMask = ~(~0 << shift); //allBitSize must be 6 digits at most for this shift to work per the java spec (so it must be less than 2^6 = 64)
					int networkMask = fullMask & (fullMask << (shift - lowerPrefixLength));
					int hostMask = ~networkMask & fullMask;
					lowerRangeLower &= networkMask;
					lowerRangeUpper |= hostMask;
					if(finalResult.mixedException == null && lowerRangeLower != 0 || lowerRangeUpper != IPv4Address.MAX_VALUE_PER_SEGMENT) {
						finalResult.mixedException = new IncompatibleAddressException(item, "ipaddress.error.invalidMixedRange");
					}
				} else {
					lowerRangeLower = 0;
					lowerRangeUpper = IPv4Address.MAX_VALUE_PER_SEGMENT;
				}
			} else if(finalResult.mixedException == null && lowerRangeLower != 0 || lowerRangeUpper != IPv4Address.MAX_VALUE_PER_SEGMENT) {
				finalResult.mixedException = new IncompatibleAddressException(item, "ipaddress.error.invalidMixedRange");
			}
		}
		return creator.createSegment(
				(upperRangeLower << shift) | lowerRangeLower,
				(upperRangeUpper << shift) | lowerRangeUpper,
				segmentPrefixLength);
	}
	private static <S extends IPAddressSegment> S createRangeSeg(
			CharSequence addressString,
			IPVersion version,
			int stringLower,
			int stringUpper,
			boolean useFlags,
			AddressParseData parseData,
			int parsedSegIndex,
			Integer segmentPrefixLength,
			ParsedAddressCreator<?, ?, ?, S> creator) {
		int lower = stringLower, upper = stringUpper;
		S result;
		if(!useFlags) {
			result = creator.createSegment(lower, upper, segmentPrefixLength);
		} else {
			result = creator.createRangeSegmentInternal(
				lower,
				upper,
				segmentPrefixLength,
				addressString,
				stringLower,
				stringUpper,
				parseData.getFlag(parsedSegIndex, AddressParseData.KEY_STANDARD_STR),
				parseData.getFlag(parsedSegIndex, AddressParseData.KEY_STANDARD_RANGE_STR),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_START_INDEX),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_LOWER_STR_END_INDEX),
				parseData.getIndex(parsedSegIndex, AddressParseData.KEY_UPPER_STR_END_INDEX));
		}
		return result;
	}
	private static <S extends IPAddressSegment> S createFullRangeSegment(
			IPVersion version,
			int stringLower,
			int stringUpper,
			int parsedSegIndex,
			Integer segmentPrefixLength,
			Integer mask,
			ParsedAddressCreator<?, ?, ?, S> creator) {
		boolean hasMask = (mask != null);
		if(hasMask) {
			int maskInt = mask.intValue();
			Masker masker = maskRange(stringLower, stringUpper, maskInt, creator.getMaxValuePerSegment());
			if(!masker.isSequential()) {
				throw new IncompatibleAddressException(stringLower, stringUpper, maskInt, "ipaddress.error.maskMismatch");
			}
			stringLower = (int) masker.getMaskedLower(stringLower, maskInt);
			stringUpper = (int) masker.getMaskedUpper(stringUpper, maskInt);
		}
		S result = createRangeSeg(null, version, stringLower, stringUpper,
				false, null, parsedSegIndex, segmentPrefixLength, creator);
		return result;
	}
	static IPAddress createAllAddress(
			IPVersion version,
			ParsedHostIdentifierStringQualifier qualifier,
			HostIdentifierString originator, 
			IPAddressStringParameters options) {
		int segmentCount = IPAddress.getSegmentCount(version);
		IPAddress mask = qualifier.getMaskLower();
		if(mask != null && mask.getBlockMaskPrefixLength(true) != null) {
			mask = null;//we don't do any masking if the mask is a subnet mask, instead we just map it to the corresponding prefix length
		}
		boolean hasMask = mask != null;
		Integer prefLength = getPrefixLength(qualifier);
		if(version.isIPv4()) {
			ParsedAddressCreator<IPv4Address, IPv4AddressSection, ?, IPv4AddressSegment> creator = options.getIPv4Parameters().getNetwork().getAddressCreator();
			IPv4AddressSegment segments[] = creator.createSegmentArray(segmentCount);
			for(int i = 0; i < segmentCount; i++) {
				Integer segmentMask = hasMask ? cacheSegmentMask(mask.getSegment(i).getSegmentValue()) : null;
				segments[i] = createFullRangeSegment(
						version,
						0,
						IPv4Address.MAX_VALUE_PER_SEGMENT,
						i,
						getSegmentPrefixLength(i, version, qualifier),
						segmentMask,
						creator);
			}
			return creator.createAddressInternal(segments, originator, prefLength);
		} else {
			ParsedAddressCreator<IPv6Address, IPv6AddressSection, ?, IPv6AddressSegment> creator = options.getIPv6Parameters().getNetwork().getAddressCreator();
			IPv6AddressSegment segments[] = creator.createSegmentArray(segmentCount);
			for(int i = 0; i < segmentCount; i++) {
				Integer segmentMask = hasMask ? cacheSegmentMask(mask.getSegment(i).getSegmentValue()) : null;
				segments[i] = createFullRangeSegment(
						version,
						0,
						IPv6Address.MAX_VALUE_PER_SEGMENT,
						i,
						getSegmentPrefixLength(i, version, qualifier),
						segmentMask,
						creator);
			}
			return creator.createAddressInternal(segments, qualifier.getZone(), originator, prefLength);
		}
	}
	private static Integer getPrefixLength(ParsedHostIdentifierStringQualifier qualifier) {
		return qualifier.getEquivalentPrefixLength();
	}
	/**
	 * Across the address prefixes are:
	 * IPv6: (null):...:(null):(1 to 16):(0):...:(0)
	 * or IPv4: ...(null).(1 to 8).(0)...
	 * 
	 * @param segmentIndex
	 * @return
	 */
	private static Integer getSegmentPrefixLength(int segmentIndex, int bitsPerSegment, ParsedHostIdentifierStringQualifier qualifier) {
		Integer bits = getPrefixLength(qualifier);
		return ParsedAddressGrouping.getSegmentPrefixLength(bitsPerSegment, bits, segmentIndex);
	}
	
	/**
	 * Across the address prefixes are:
	 * IPv6: (null):...:(null):(1 to 16):(0):...:(0)
	 * or IPv4: ...(null).(1 to 8).(0)...
	 * 
	 * @param segmentIndex
	 * @param version
	 * @return
	 */
	private static Integer getSegmentPrefixLength(int segmentIndex, IPVersion version, ParsedHostIdentifierStringQualifier qualifier) {
		return getSegmentPrefixLength(segmentIndex, IPAddressSection.bitsPerSegment(version), qualifier);
	}
	
	private static Integer cacheSegmentMask(int i) {
		return ParsedAddressGrouping.cache(i);
	}
}
/*
 * Copyright 2022 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.ipv4;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.function.Function;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressSeqRange;
import inet.ipaddr.NetworkMismatchException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.standard.AddressCreator;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
/**
 * Represents an arbitrary range of IPv4 addresses.
 * 
 * See {@link IPAddressSeqRange} for more details.
 * 
 * @custom.core
 * @author sfoley
 *
 */
public class IPv4AddressSeqRange extends IPAddressSeqRange implements Iterable<IPv4Address> {
	private static final long serialVersionUID = 1L;
	private static final IPv4AddressSeqRange EMPTY[] = {};
		
	IPv4AddressSeqRange(IPv4Address first, IPv4Address second, boolean preSet) {
		super(first, second, preSet);
	}
	
	public IPv4AddressSeqRange(IPv4Address first, IPv4Address second) {
		super(
			first,
			second,
			IPv4Address::getLower,
			IPv4Address::getUpper,
			IPv4Address::withoutPrefixLength);
		if(!first.getNetwork().isCompatible(second.getNetwork())) {
			throw new NetworkMismatchException(first, second);
		}
	}
	private IPv4AddressSeqRange(IPAddress first, IPAddress second) {
		super(first, second);
	}
	@Override
	public IPv4Address getLower() {
		return (IPv4Address) super.getLower();
	}
	@Override
	public IPv4Address getUpper() {
		return (IPv4Address) super.getUpper();
	}
	private IPv4AddressCreator getAddressCreator() {
		return getLower().getNetwork().getAddressCreator();
	}
	/**
	 * Equivalent to {@link #getCount()} but returns a long
	 * 
	 * @return
	 */
	public long getIPv4Count() {
		return getUpper().longValue() - getLower().longValue() + 1;
	}
	/**
	 * Equivalent to {@link #getPrefixCount(int)} but returns a long
	 * 
	 * @return
	 */
	public long getIPv4PrefixCount(int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(this, prefixLength);
		}
		int bitCount = getBitCount();
		if(bitCount <= prefixLength) {
			return getIPv4Count();
		}
		int shiftAdjustment = bitCount - prefixLength;
		long upperAdjusted = getUpper().longValue() >>> shiftAdjustment;
		long lowerAdjusted = getLower().longValue() >>> shiftAdjustment;
		return upperAdjusted - lowerAdjusted + 1;
	}
	@Override
	protected BigInteger getCountImpl() {
		return BigInteger.valueOf(getIPv4Count());
	}
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		return BigInteger.valueOf(getIPv4PrefixCount(prefixLength));
	}
	@Override
	public Iterable<IPv4Address> getIterable() {
		return this;
	}
	@Override
	public Iterator<IPv4Address> iterator() {
		IPv4Address lower = getLower();
		IPv4Address upper = getUpper();
		AddressCreator<IPv4Address, ?, ?, IPv4AddressSegment> creator = getAddressCreator();
		if(!isMultiple()) {
			return iterator(lower, creator);
		}
		int divCount = lower.getSegmentCount();
		return iterator(
				lower,
				upper,
				creator,
				IPv4Address::getSegment,
				(seg, segIndex) -> seg.iterator(),
				(addr1, addr2, index) -> addr1.getSegment(index).getSegmentValue() == addr2.getSegment(index).getSegmentValue(),
				divCount - 1,
				divCount,
				null);
	}
	
	@Override
	public AddressComponentRangeSpliterator<IPv4AddressSeqRange, IPv4Address> spliterator() {
		int segmentCount = getLower().getSegmentCount();
		IPv4AddressCreator creator = getAddressCreator();
		int networkSegIndex = segmentCount - 1;
		int hostSegIndex = segmentCount;
		return createSpliterator(this,
				sink -> {
					IPv4AddressSeqRange range = sink.getAddressItem();
					return split(
						sink,
						(segsLower, segsUpper) -> new IPv4AddressSeqRange(
								creator.createAddressInternal(segsLower),
								creator.createAddressInternal(segsUpper)),
						creator,
						range.getLower().getSection().getSegmentsInternal(),
						range.getUpper().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						null);
				},
				(lowest, highest, range) -> range.iterator(),
				IPv4AddressSeqRange::getIPv4Count);
	}
	@Override
	public Stream<IPv4Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixBlockIterator(int prefLength) {
		if(prefLength < 0) {
			throw new PrefixLenException(prefLength);
		}
		IPv4Address lower = getLower();
		IPv4Address upper = getUpper();
		AddressCreator<IPv4Address, ?, ?, IPv4AddressSegment> creator = getAddressCreator();
		int bitsPerSegment = lower.getBitsPerSegment();
		int bytesPerSegment = lower.getBytesPerSegment();
		int segCount = lower.getSegmentCount();
		Integer prefLengths[] = new Integer[segCount];
		int shifts[] = new int[segCount];
		int networkSegIndex = 0;
		if(prefLength > 0) {
			networkSegIndex = getNetworkSegmentIndex(prefLength, bytesPerSegment, bitsPerSegment);
		}
		for(int i = networkSegIndex; i < segCount; i++) {
			Integer segPrefLength = ParsedAddressGrouping.getPrefixedSegmentPrefixLength(bitsPerSegment, prefLength, i);
			prefLengths[i] = segPrefLength;
			shifts[i] = bitsPerSegment - segPrefLength;
		}
		int hostSegIndex = getHostSegmentIndex(prefLength, bytesPerSegment, bitsPerSegment);
		return iterator(
				lower,
				upper,
				creator,
				IPv4Address::getSegment,
				(seg, segIndex) -> seg.iterator(),
				(addr1, addr2, index) -> {
					Integer segPrefLength = prefLengths[index];
					if(segPrefLength == null) {
						return addr1.getSegment(index).getSegmentValue() == addr2.getSegment(index).getSegmentValue();
					}
					int shift = shifts[index];
					return addr1.getSegment(index).getSegmentValue() >>> shift == addr2.getSegment(index).getSegmentValue() >>> shift;
				},
				networkSegIndex,
				hostSegIndex,
				(seg, index) -> {
					Integer segPrefLength = prefLengths[index];
					if(segPrefLength == null) {
						return seg.iterator();
					}
					return seg.prefixBlockIterator(segPrefLength);
				});
	}
	@Override
	public AddressComponentRangeSpliterator<IPv4AddressSeqRange, IPv4Address> prefixBlockSpliterator(int prefLength) {
		if(prefLength < 0) {
			throw new PrefixLenException(prefLength);
		}
		IPv4Address lower = getLower();
		int bitsPerSegment = lower.getBitsPerSegment();
		int bytesPerSegment = lower.getBytesPerSegment();
		IPv4AddressCreator creator = getAddressCreator();
		Integer prefixLength = IPv4AddressSection.cacheBits(prefLength);
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, bytesPerSegment, bitsPerSegment);
		int hostSegIndex = getHostSegmentIndex(prefixLength, bytesPerSegment, bitsPerSegment);
		return createSpliterator(
				this,
				sink -> {
					IPv4AddressSeqRange range = sink.getAddressItem();
					return split(
						sink,
						(segsLower, segsUpper) -> new IPv4AddressSeqRange(
								creator.createAddressInternal(segsLower),
								creator.createAddressInternal(segsUpper)),
						creator,
						range.getLower().getSection().getSegmentsInternal(),
						range.getUpper().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefixLength);
				},
				(isLowest, isHighest, range) -> range.prefixBlockIterator(prefLength),
				range -> range.getIPv4PrefixCount(prefLength));
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream(int prefLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefLength), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AddressSeqRange> prefixIterator(int prefixLength) {
		return (Iterator<IPv4AddressSeqRange>) super.prefixIterator(prefixLength);
	}
	@Override
	public Stream<IPv4AddressSeqRange> prefixStream(int prefLength) {
		return StreamSupport.stream(prefixSpliterator(prefLength), false);
	}
	@Override
	public AddressComponentSpliterator<IPv4AddressSeqRange> prefixSpliterator(int prefLength) {
		if(prefLength < 0) {
			throw new PrefixLenException(prefLength);
		}
		IPv4Address lower = getLower();
		int bitsPerSegment = lower.getBitsPerSegment();
		int bytesPerSegment = lower.getBytesPerSegment();
		IPv4AddressCreator creator = getAddressCreator();
		Integer prefixLength = IPv4AddressSection.cacheBits(prefLength);
		int networkSegIndex = getNetworkSegmentIndex(prefixLength, bytesPerSegment, bitsPerSegment);
		int hostSegIndex = getHostSegmentIndex(prefixLength, bytesPerSegment, bitsPerSegment);
		return createPrefixSpliterator(
				this,
				sink -> {
					IPv4AddressSeqRange range = sink.getAddressItem();
					return split(
						sink,
						(segsLower, segsUpper) -> new IPv4AddressSeqRange(
								creator.createAddressInternal(segsLower),
								creator.createAddressInternal(segsUpper)),
						creator,
						range.getLower().getSection().getSegmentsInternal(),
						range.getUpper().getSection().getSegmentsInternal(),
						networkSegIndex,
						hostSegIndex,
						prefixLength);
				},
				(isLowest, isHighest, range) -> (isLowest || isHighest) ? range.prefixIterator(prefLength) : rangedIterator(range.prefixBlockIterator(prefLength)),
				range -> range.getIPv4PrefixCount(prefLength));
	}
	@Override
	public IPv4Address coverWithPrefixBlock() {
		return getLower().coverWithPrefixBlock(getUpper());
	}
	@Override
	public IPv4Address[] spanWithPrefixBlocks() {
		return getLower().spanWithPrefixBlocks(getUpper());
	}
	@Override
	public IPv4Address[] spanWithSequentialBlocks() {
		return getLower().spanWithSequentialBlocks(getUpper());
	}
	@Override
	public int getMinPrefixLengthForBlock() {
		int result = getBitCount();
		int lowerZeros = Integer.numberOfTrailingZeros(getLower().intValue());
		if(lowerZeros != 0) {
			int upperOnes = Integer.numberOfTrailingZeros(~getUpper().intValue());
			if(upperOnes != 0) {
				int prefixedBitCount = Math.min(lowerZeros, upperOnes);
				result -= prefixedBitCount;
			}
		}
		return result;
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		int divPrefix = getMinPrefixLengthForBlock();
		int lowerValue = getLower().intValue();
		int upperValue = getUpper().intValue();
		int bitCount = getBitCount();
		if(divPrefix == bitCount) {
			if(lowerValue == upperValue) {
				return IPv4AddressSection.cacheBits(divPrefix);
			}
		} else {
			int shift = bitCount - divPrefix;
			if(lowerValue >>> shift == upperValue >>> shift) {
				return IPv4AddressSection.cacheBits(divPrefix);
			}
		}
		return null;
	}
	@Override
	protected IPv4AddressSeqRange create(IPAddress lower, IPAddress upper) {
		return new IPv4AddressSeqRange(lower, upper);
	}
	/* (non-Javadoc)
	 * @see inet.ipaddr.IPAddressRange#createPair(inet.ipaddr.IPAddress, inet.ipaddr.IPAddress, inet.ipaddr.IPAddress, inet.ipaddr.IPAddress)
	 */
	@Override
	protected IPv4AddressSeqRange[] createPair(IPAddress lower1, IPAddress upper1,
			IPAddress lower2, IPAddress upper2) {
		return new IPv4AddressSeqRange[] {create(lower1, upper1), create(lower2, upper2)};
	}
	/* (non-Javadoc)
	 * @see inet.ipaddr.IPAddressRange#createSingle(inet.ipaddr.IPAddress, inet.ipaddr.IPAddress)
	 */
	@Override
	protected IPv4AddressSeqRange[] createSingle(IPAddress lower, IPAddress upper) {
		return new IPv4AddressSeqRange[] {
			create(lower, upper)
		};
	}
	
	@Override
	protected IPv4AddressSeqRange[] createSingle() {
		return new IPv4AddressSeqRange[] { this };
	}
	
	@Override
	protected IPv4AddressSeqRange[] createEmpty() {
		return EMPTY;
	}
	
	public String toIPv4String(Function<IPv4Address, String> lowerStringer, String separator, Function<IPv4Address, String> upperStringer) {
		return lowerStringer.apply(getLower()) + separator + upperStringer.apply(getUpper());
	}
	
	@Override
	public IPv4AddressSeqRange intersect(IPAddressSeqRange other) {
		return (IPv4AddressSeqRange) super.intersect(other);
	}
	
	@Override
	public IPv4AddressSeqRange join(IPAddressSeqRange other) {
		return (IPv4AddressSeqRange) super.join(other);
	}
	
	@Override
	public IPv4AddressSeqRange[] subtract(IPAddressSeqRange other) {
		return (IPv4AddressSeqRange[]) super.subtract(other);
	}
	
	@Override
	public IPv4AddressSeqRange toSequentialRange() {
		return this;
	}
}
/*
 * Copyright 2016-2018 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr.format.util;
import inet.ipaddr.format.string.AddressStringDivision;
/**
 * An object for writing an address part string in a specific format.
 * 
 * @author sfoley
 */
public interface AddressDivisionWriter {
	
	StringBuilder appendDivision(StringBuilder builder, AddressStringDivision div);
	
	int getDivisionStringLength(AddressStringDivision seg);
}
/*
 * Copyright 2016-2022 Sean C Foley
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     or at
 *     https://github.com/seancfoley/IPAddress/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package inet.ipaddr;
import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.InterfaceAddress;
import java.net.UnknownHostException;
import java.util.Objects;
import java.util.function.Function;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.format.validate.HostIdentifierStringValidator;
import inet.ipaddr.format.validate.ParsedHost;
import inet.ipaddr.format.validate.ParsedHostIdentifierStringQualifier;
import inet.ipaddr.format.validate.Validator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
/**
 * An internet host name.  Can be a fully qualified domain name, a simple host name, or an ip address string.
 * Can also include a port number or service name (which maps to a port).
 * Can include a prefix length or mask for either an ipaddress or host name string.  An IPv6 address can have an IPv6 zone.
 * <p>
 * <h2>Supported formats</h2>
 * You can use all host or address formats supported by nmap and all address formats supported by {@link IPAddressString}.
 * All manners of domain names are supported. When adding a prefix length or mask to a host name string, it is to denote the subnet of the resolved address.
 * <p>
 * Validation is done separately from DNS resolution to avoid unnecessary DNS lookups.
 * <p>
 * See rfc 3513, 2181, 952, 1035, 1034, 1123, 5890 or the list of rfcs for IPAddress.  For IPv6 addresses in host, see rfc 2732 specifying [] notation
 * and 3986 and 4038 (combining IPv6 [] with prefix or zone) and SMTP rfc 2821 for alternative uses of [] for both IPv4 and IPv6
 * <p>
 * 
 * @custom.core
 * @author sfoley
 */
public class HostName implements HostIdentifierString, Comparable<HostName> {
	private static final long serialVersionUID = 4L;
	private static  IPAddress EMPTY_ADDRS[] = new IPAddress[0];
	
	public static final char LABEL_SEPARATOR = '.';
	public static final char IPV6_START_BRACKET = '[', IPV6_END_BRACKET = ']';
	public static final char PORT_SEPARATOR = ':';
	
	/* Generally permissive, settings are the default constants in HostNameParameters */
	public static final HostNameParameters DEFAULT_VALIDATION_OPTIONS = new HostNameParameters.Builder().toParams();
	private static final HostNameParameters DEFAULT_SOCKET_ADDR_VALIDATION_OPTIONS = DEFAULT_VALIDATION_OPTIONS.toBuilder().expectPort(true).toParams();
	/* the original host in string format */
	private final String host;
	
	/* normalized strings representing the host */
	private transient String normalizedString, normalizedWildcardString;
	/* the host broken into its parsed components */
	private ParsedHost parsedHost;
	private HostNameException validationException;
	/* The address if this host represents an ip address, or the addresses obtained when this host is resolved. */
	IPAddress resolvedAddresses[];
	
	/* validation options */
	final HostNameParameters validationOptions;
	/**
	 * Constructs a host name from an IP address.
	 * 
	 * @param addr
	 */
	public HostName(IPAddress addr) {
		host = addr.toNormalizedString();
		parsedHost = new ParsedHost(host, addr.getProvider());
		validationOptions = null;
	}
	
	/**
	 * Constructs a host name from an IP address and a port.
	 * 
	 * @param addr
	 */
	public HostName(IPAddress addr, int port) {
		ParsedHostIdentifierStringQualifier qualifier = new ParsedHostIdentifierStringQualifier(null, port);
		host = toNormalizedString(addr, port);
		parsedHost = new ParsedHost(host, addr.getProvider(), qualifier);
		validationOptions = null;
	}
	
	/**
	 * Constructs a host name from an InetSocketAddress.
	 * 
	 * @param inetSocketAddr
	 */
	public HostName(InetSocketAddress inetSocketAddr) {
		if(!inetSocketAddr.isUnresolved()) {
			// we take the resolved addresses from the socket address, even though in here we might have gotten more
			resolvedAddresses = new IPAddress[] {toIPAddress(inetSocketAddr.getAddress(), IPAddressString.DEFAULT_VALIDATION_OPTIONS)};
		}
		// We will parse and normalize as usual.
		// There is no way to know if we are getting a 
		// host name string here or an ip address literal without parsing it ourselves.
		// This is true even when the socket address is resolved, 
		// we have no way of knowing if it started as an ip address literal or not,
		// without parsing the original string.
		int port = inetSocketAddr.getPort();
		String hostStr = inetSocketAddr.getHostString().trim();
		StringBuilder builder = new StringBuilder(hostStr.length() + 6); // 1 ':' and max 5 for port, largest being 65535
		toNormalizedString(port, builder.append(hostStr));
		host = builder.toString();
		validationOptions = DEFAULT_SOCKET_ADDR_VALIDATION_OPTIONS; // we need exportPort to be true in the validation options so ::1:8080 is interpreted as ::1 with port 8080 and not IPv6 ::1:8080
	}
	/**
	 * Constructs a host name from an address with prefix length, which can be null.
	 * 
	 * @param inetAddr
	 */
	public HostName(InetAddress inetAddr, Integer prefixLength) {
		this(toIPAddress(inetAddr, IPAddressString.DEFAULT_VALIDATION_OPTIONS, prefixLength));
	}
	
	/**
	 * Constructs a host name from an InterfaceAddress.
	 * 
	 * @param interfaceAddr
	 */
	public HostName(InterfaceAddress interfaceAddr) {
		this(interfaceAddr.getAddress(), IPAddressNetwork.cacheBits(interfaceAddr.getNetworkPrefixLength()));
	}
	
	/**
	 * Constructs a host name from an IP address.
	 * 
	 * @param inetAddr
	 */
	public HostName(InetAddress inetAddr) {
		this(inetAddr, IPAddressString.DEFAULT_VALIDATION_OPTIONS);
	}
	
	/**
	 * Constructs a host name from an IP address, allowing control over conversion to an IPAddress instance.
	 * 
	 * @param inetAddr
	 */
	public HostName(InetAddress inetAddr, IPAddressStringParameters addressOptions) {
		this(toIPAddress(inetAddr, addressOptions));
	}
	
	private static IPAddress toIPAddress(InetAddress inetAddr, IPAddressStringParameters addressOptions) {
		return inetAddr instanceof Inet4Address ?
				addressOptions.getIPv4Parameters().getNetwork().getAddressCreator().createAddress((Inet4Address) inetAddr) :
				addressOptions.getIPv6Parameters().getNetwork().getAddressCreator().createAddress((Inet6Address) inetAddr);
	}
	
	private static IPAddress toIPAddress(InetAddress inetAddr, IPAddressStringParameters addressOptions, Integer prefixLength) {
		return inetAddr instanceof Inet4Address ?
				addressOptions.getIPv4Parameters().getNetwork().getAddressCreator().createAddress((Inet4Address) inetAddr, prefixLength) :
				addressOptions.getIPv6Parameters().getNetwork().getAddressCreator().createAddress((Inet6Address) inetAddr, prefixLength);
	}
	
	HostName(String hostStr, ParsedHost parsed) {
		host = hostStr;
		parsedHost = parsed;
		validationOptions = null;
	}
	
	/**
	 * Constructs a host name instance from the given string.  
	 * Supports string host names and ip addresses.  
	 * Also allows masks, ports, service name strings, and prefix lengths, both with addresses and host name strings.
	 * Any {@link IPAddressString} format is supported.
	 * @param host
	 */
	public HostName(String host) {
		this(host, DEFAULT_VALIDATION_OPTIONS);
	}
	/**
	 * Similar to {@link #HostName(String)}, but allows you to control which elements are allowed and which are not, 
	 * using the given options.  The default options used by {@link #HostName(String)} are permissive.
	 * @param host
	 * @param options
	 */
	public HostName(String host, HostNameParameters options) {
		if(options == null) {
			throw new NullPointerException();
		}
		validationOptions = options;
		this.host = (host == null) ? "" : host.trim();
	}
	void cacheAddress(IPAddress addr) {
		if(parsedHost == null) {
			parsedHost = new ParsedHost(host, addr.getProvider());
		}
	}
	/**
	 * Supplies the validation options used to validate this host name, whether the default or the one supplied with {@link #HostName(String, HostNameParameters)}
	 * 
	 * @return
	 */
	public HostNameParameters getValidationOptions() {
		return validationOptions;
	}
	/**
	 * Validates that this string is a valid host name or IP address, and if not, throws an exception with a descriptive message indicating why it is not.
	 * @throws HostNameException
	 */
	@Override
	public void validate() throws HostNameException {
		if(parsedHost != null) {
			return;
		}
		if(validationException != null) {
			throw validationException;
		}
		synchronized(this) {
			if(parsedHost != null) {
				return;
			} else if(validationException != null) {
				throw validationException;
			}
			try {
				parsedHost = getValidator().validateHost(this);
			} catch(HostNameException e) {
				validationException = e;
				throw e;
			}
		}
	}
	
	protected HostIdentifierStringValidator getValidator() {
		return Validator.VALIDATOR;
	}
	/**
	 * Returns whether this represents a valid host name or address format.
	 * @return
	 */
	public boolean isValid() {
		if(parsedHost != null) {
			return true;
		} else if(validationException != null) {
			return false;
		}
		try {
			validate();
			return true;
		} catch(HostNameException e) {
			return false;
		}
	}
	
	/**
	 * Returns whether this represents, or resolves to, 
	 * a host or address representing the same host.
	 * 
	 * @return whether this represents or resolves to the localhost host or a loopback address
	 */
	public boolean resolvesToSelf() {
		return isSelf() || (getAddress() != null && resolvedAddresses[0].isLoopback());
	}
	
	/**
	 * Returns whether this represents a host or address representing the same host.
	 * Also see {@link #isLocalHost()} and {@link #isLoopback()}
	 * 
	 * @return whether this is the localhost host or a loopback address
	 */
	public boolean isSelf() {
		return isLocalHost() || isLoopback();
	}
	
	/**
	 * Returns whether this host is "localhost"
	 * @return
	 */
	public boolean isLocalHost() {
		return isValid() && host.equalsIgnoreCase("localhost");
	}
	
	/**
	 * Returns whether this host has the loopback address, such as
	 * [::1] (aka [0:0:0:0:0:0:0:1]) or 127.0.0.1
	 * 
	 * Also see {@link #isSelf()}
	 */
	public boolean isLoopback() {
		return isAddress() && asAddress().isLoopback();
	}
	
	/**
	 * Returns the InetAddress associated with this host.  This will attempt to resolve a host name string if the string is not already an IP address.
	 * 
	 * @return
	 * @throws HostNameException when validation fails
	 * @throws UnknownHostException when resolve fails
	 */
	public InetAddress toInetAddress() throws HostNameException, UnknownHostException {
		validate();
		return toAddress().toInetAddress();
	}
	
	/**
	 * Provides a normalized string which is lowercase for host strings, and which is a normalized string for addresses.
	 * @return
	 */
	@Override
	public String toNormalizedString() {
		String result = normalizedString;
		if(result == null) {
			normalizedString = result = toNormalizedString(false);
		}
		return result;
	}
	
	private String toNormalizedWildcardString() {//used by hashCode
		String result = normalizedWildcardString;
		if(result == null) {
			normalizedWildcardString = result = toNormalizedString(true);
		}
		return result;
	}
	
	private static void translateReserved(IPv6Address addr, String str, StringBuilder builder) {
	//private static CharSequence translateReserved(IPv6Address addr, String str, StringBuilder builder) {
		//This is particularly targeted towards the zone
//		if(!addr.hasZone()) {
//			return str;
//		}
		if(!addr.hasZone()) {
			builder.append(str);
			return;
			//return str;
		}
		
		int index = str.indexOf(IPv6Address.ZONE_SEPARATOR);
		StringBuilder translated = builder;
		//StringBuilder translated = new StringBuilder(((str.length() - index) * 3) + index);
		translated.append(str, 0, index);
		translated.append("%25");
		for(int i = index + 1; i < str.length(); i++) {
			char c = str.charAt(i);
			if(Validator.isReserved(c)) {
				translated.append('%');
				IPAddressSegment.toUnsignedString(c, 16, translated);
			} else {
				translated.append(c);
			}
		}
		//return translated;
		return;
	}
	
	private static String toNormalizedString(IPAddress addr, int port) {
		StringBuilder builder = new StringBuilder();
		toNormalizedString(addr, false, builder);
		toNormalizedString(port, builder);
		return builder.toString();
	}
	
	private String toNormalizedString(boolean wildcard) {
		if(isValid()) {
			StringBuilder builder = new StringBuilder();
			if(isAddress()) {
				toNormalizedString(asAddress(), wildcard, builder);
			} else if(isAddressString()) {
				builder.append(asAddressString().toNormalizedString());
			} else {
				builder.append(parsedHost.getHost());
				/*
				 * If prefix or mask is supplied and there is an address, it is applied directly to the address provider, so 
				 * we need only check for those things here
				 * 
				 * Also note that ports and prefix/mask cannot appear at the same time, so this does not interfere with the port code below.
				 */
				Integer networkPrefixLength = parsedHost.getEquivalentPrefixLength();
				if(networkPrefixLength != null) {
					builder.append(IPAddress.PREFIX_LEN_SEPARATOR);
					IPAddressSegment.toUnsignedString(networkPrefixLength, 10, builder);
				} else {
					IPAddress mask = parsedHost.getMask();
					if(mask != null) {
						builder.append(IPAddress.PREFIX_LEN_SEPARATOR).append(mask.toNormalizedString());
					}
				}
			}
			Integer port = parsedHost.getPort();
			if(port != null) {
				toNormalizedString(port, builder);
			} else {
				String service = parsedHost.getService();
				if(service != null) {
					builder.append(PORT_SEPARATOR).append(service);
				}
			}
			return builder.toString();
		}
		return host;
	}
	
	private static void toNormalizedString(int port, StringBuilder builder) {
		builder.append(PORT_SEPARATOR);
		IPAddressSegment.toUnsignedString(port, 10, builder);
	}
	
	private static void toNormalizedString(IPAddress addr, boolean wildcard, StringBuilder builder) {
		if(addr.isIPv6()) {
			if(!wildcard && addr.isPrefixed()) {//prefix needs to be outside the brackets
				builder.append(IPV6_START_BRACKET);
				String normalized = addr.toNormalizedString();
				int index = normalized.indexOf(IPAddress.PREFIX_LEN_SEPARATOR);
				translateReserved(addr.toIPv6(), normalized.substring(0, index), builder);
				builder.append(IPV6_END_BRACKET).append(normalized.substring(index));
			} else {
				builder.append(IPV6_START_BRACKET);
				translateReserved(addr.toIPv6(), addr.toNormalizedWildcardString(), builder);
				builder.append(IPV6_END_BRACKET);
			}
		} else {
			builder.append(wildcard ? addr.toNormalizedWildcardString() : addr.toNormalizedString());
		}
	}
	
	/**
	 * Returns true if the given object is a host name and {@link #matches(HostName)} this one.
	 */
	@Override
	public boolean equals(Object o) {
		return o instanceof HostName && matches((HostName) o);
	}
	@Override
	public int hashCode() {
		return toNormalizedWildcardString().hashCode();
	}
	
	/**
	 * Returns an array of normalized strings for this host name instance.
	 * 
	 * If this represents an IP address, the address segments are separated into the returned array.
	 * If this represents a host name string, the domain name segments are separated into the returned array,
	 * with the top-level domain name (right-most segment) as the last array element.
	 * 
	 * The individual segment strings are normalized in the same way as {@link #toNormalizedString()}
	 * 
	 * Ports, service name strings, prefix lengths, and masks are all omitted from the returned array.
	 * 
	 * @return
	 */
	public String[] getNormalizedLabels() {
		if(isValid()) {
			return parsedHost.getNormalizedLabels();
		} else if(host.length() == 0) {
			return new String[0];
		}
		return new String[] {host};
	}
	
	/**
	 * Returns the host string normalized but without port, service, prefix or mask.
	 * 
	 * If an address, returns the address string normalized, but without port, service, prefix, mask, or brackets for IPv6.
	 * 
	 * To get a normalized string encompassing all details, use toNormalizedString()
	 * 
	 * If not a valid host, returns null
	 * 
	 * @return
	 */
	public String getHost() {
		if(isValid()) {
			return parsedHost.getHost();
		}
		return null;
	}
	
	/**
	 * Returns whether the given host matches this one.  For hosts to match, they must represent the same addresses or have the same host names.
	 * Hosts are not resolved when matching.  Also, hosts must have the same port and service.  They must have the same masks if they are host names.
	 * Even if two hosts are invalid, they match if they have the same invalid string.
	 * 
	 * @param host
	 * @return
	 */
	public boolean matches(HostName host) {
		if(this == host) {
			return true;
		}
		if(isValid()) {
			if(host.isValid()) {
				ParsedHost parsedHost = this.parsedHost;
				ParsedHost otherParsedHost = host.parsedHost;
				if(parsedHost.isAddressString()) {
					return otherParsedHost.isAddressString()
							&& parsedHost.asGenericAddressString().equals(otherParsedHost.asGenericAddressString())
							&& Objects.equals(parsedHost.getPort(), otherParsedHost.getPort())
							&& Objects.equals(parsedHost.getService(), otherParsedHost.getService());
				}
				if(otherParsedHost.isAddressString()) {
					return false;
				}
				String thisHost = parsedHost.getHost();
				String otherHost = otherParsedHost.getHost();
				if(!thisHost.equals(otherHost)) {
					return false;
				}
				return Objects.equals(parsedHost.getEquivalentPrefixLength(), otherParsedHost.getEquivalentPrefixLength()) &&
						Objects.equals(parsedHost.getMask(), otherParsedHost.getMask()) &&
						Objects.equals(parsedHost.getPort(), otherParsedHost.getPort()) &&
						Objects.equals(parsedHost.getService(), otherParsedHost.getService());
			}
			return false;
		}
		return !host.isValid() && toString().equals(host.toString());
	}
	@Override
	public int compareTo(HostName other) {
		if(isValid()) {
			if(other.isValid()) {
				ParsedHost parsedHost = this.parsedHost;
				ParsedHost otherParsedHost = other.parsedHost;
				if(parsedHost.isAddressString()) {
					if(otherParsedHost.isAddressString()) {
						int result = parsedHost.asGenericAddressString().compareTo(otherParsedHost.asGenericAddressString());
						if(result != 0) {
							return result;
						}
						//fall through to compare ports
					} else {
						return -1;
					}
				} else if(otherParsedHost.isAddressString()) {
					return 1;
				} else {
					//both are non-address hosts
					String normalizedLabels[] = parsedHost.getNormalizedLabels();
					String otherNormalizedLabels[] = otherParsedHost.getNormalizedLabels();
					int oneLen = normalizedLabels.length;
					int twoLen = otherNormalizedLabels.length;
					for(int i = 1, minLen = Math.min(oneLen, twoLen); i <= minLen; i++) {
						String one = normalizedLabels[oneLen - i];
						String two = otherNormalizedLabels[twoLen - i];
						int result = one.compareTo(two);
						if(result != 0) {
							return result;
						}
					}
					if(oneLen != twoLen) {
						return oneLen - twoLen;
					}
					
					//keep in mind that hosts can has masks/prefixes or ports, but not both
					Integer networkPrefixLength = parsedHost.getEquivalentPrefixLength();
					Integer otherPrefixLength = otherParsedHost.getEquivalentPrefixLength();
					if(networkPrefixLength != null) {
						if(otherPrefixLength != null) {
							if(networkPrefixLength.intValue() != otherPrefixLength.intValue()) {
								return otherPrefixLength - networkPrefixLength;
							}
							//fall through to compare ports
						} else {
							return 1;
						}
					} else {
						if(otherPrefixLength != null) {
							return -1;
						}
						IPAddress mask = parsedHost.getMask();
						IPAddress otherMask = otherParsedHost.getMask();
						if(mask != null) {
							if(otherMask != null) {
								int ret = mask.compareTo(otherMask);
								if(ret != 0) {
									return ret;
								}
								//fall through to compare ports
							} else {
								return 1;
							}
						} else {
							if(otherMask != null) {
								return -1;
							}
							//fall through to compare ports
						}
					}//end non-address host compare
				}
				
				//two equivalent address strings or two equivalent hosts, now check port and service names
				Integer portOne = parsedHost.getPort();
				Integer portTwo = otherParsedHost.getPort();
				if(portOne != null) {
					if(portTwo != null) {
						int ret = portOne - portTwo;
						if(ret != 0) {
							return ret;
						}
					} else {
						return 1;
					}
				} else if(portTwo != null) {
					return -1;
				}
				String serviceOne = parsedHost.getService();
				String serviceTwo = otherParsedHost.getService();
				if(serviceOne != null) {
					if(serviceTwo != null) {
						int ret = serviceOne.compareTo(serviceTwo);
						if(ret != 0) {
							return ret;
						}
					} else {
						return 1;
					}
				} else if(serviceTwo != null) {
					return -1;
				}
				return 0;
			} else {
				return 1;
			}
		} else if(other.isValid()) {
			return -1;
		}
		return toString().compareTo(other.toString());
	}
	@Deprecated
	public boolean isAddress(IPVersion version) {
		return isValid() && parsedHost.isAddressString() && parsedHost.asAddress(version) != null;
	}
	/**
	 * Returns whether this host name is a string representing an valid specific IP address or subnet.
	 * 
	 * @return
	 */
	public boolean isAddress() {
		return isAddressString() && parsedHost.asAddress() != null; 
	}
	/**
	 * Returns whether this host name is a string representing an IP address or subnet.
	 * 
	 * @return
	 */
	public boolean isAddressString() {
		return isValid() && parsedHost.isAddressString();
	}
	/**
	 * Whether the address represents the set all all valid IP addresses (as opposed to an empty string, a specific address, a prefix length, or an invalid format).
	 * 
	 * @return whether the address represents the set all all valid IP addresses
	 */
	public boolean isAllAddresses() {
		return isAddressString() && parsedHost.getAddressProvider().isProvidingAllAddresses();
	}
	/**
	 * Whether the address represents a valid IP address network prefix (as opposed to an empty string, an address with or without a prefix, or an invalid format).
	 * 
	 * @return whether the address represents a valid IP address network prefix
	 */
	public boolean isPrefixOnly() {
		return isAddressString() && parsedHost.getAddressProvider().isProvidingPrefixOnly();
	}
	/**
	 * Returns true if the address is empty (zero-length).
	 * @return
	 */
	public boolean isEmpty() {
		return isAddressString() && parsedHost.getAddressProvider().isProvidingEmpty();
	}
	/**
	 * If a port was supplied, returns the port, otherwise returns null
	 * 
	 * @return
	 */
	public Integer getPort() {
		return isValid() ? parsedHost.getPort() : null;
	}
	/**
	 * If a service name was supplied, returns the service name, otherwise returns null
	 * 
	 * @return
	 */
	public String getService() {
		return isValid() ? parsedHost.getService() : null;
	}
	/**
	 * Returns the exception thrown for invalid ipv6 literal or invalid reverse DNS hosts.
	 * 
	 * This method will return non-null when this host is valid, so no HostException is thrown,
	 * but a secondary address within the host is not valid.
	 *  
	 * @return
	 */
	public AddressStringException getAddressStringException() {
		if(isValid()) {
			return parsedHost.getAddressStringException();
		}
		return null;
	}
	
	/**
	 * Returns whether this host name is an Uniform Naming Convention IPv6 literal host name.
	 * 
	 * @return
	 */
	public boolean isUNCIPv6Literal() {
		return isValid() && parsedHost.isUNCIPv6Literal();
	}
	
	/**
	 * Returns whether this host name is a reverse DNS string host name.
	 * 
	 * @return
	 */
	public boolean isReverseDNS() {
		return isValid() && parsedHost.isReverseDNS();
	}
	/**
	 * If this represents an ip address or represents any valid IPAddressString, returns the corresponding address string.
	 * Otherwise, returns null.  Note that translation includes prefix lengths and IPv6 zones.  
	 * This does not resolve addresses.  Call {@link #toAddress()} or {@link #getAddress()} to get the resolved address.
	 * @return
	 */
	public IPAddressString asAddressString() {
		if(isAddressString()) {
			return parsedHost.asGenericAddressString(); // this is for address string not convertible to address
		}
		return null;
	}
	/**
	 * If this represents an ip address, returns that address.  Otherwise, returns null.  
	 * Note that translation includes prefix lengths and IPv6 zones.
	 * <p>
	 * This does not resolve addresses or return resolved addresses.
	 * Call {@link #toAddress()} or {@link #getAddress()} to get the resolved address.
	 * <p>
	 * In cases such as IPv6 literals and reverse DNS hosts, you can check the relevant methods isIpv6Literal or isReverseDNS,
	 * in which case this method should return the associated address.  If this method returns null then an exception occurred
	 * when producing the associated address, and that exception is available from getAddressStringException.
	 * 
	 * @return
	 */
	public IPAddress asAddress() {
		if(isAddress()) {
			return parsedHost.asAddress();
		}
		return null;
	}
	
	/**
	 * If this represents an ip address, returns that address.
	 * Otherwise, returns null.  Call {@link #toAddress()} or {@link #getAddress()} to get the resolved address.
	 * 
	 * @return
	 */
	@Deprecated
	public IPAddress asAddress(IPVersion version) {
		if(isAddress(version)) {
			return parsedHost.asAddress(version);
		}
		return null;
	}
	/**
	 * If a prefix length was supplied, either as part of an address or as part of a domain (in which case the prefix applies to any resolved address), 
	 * then returns that prefix length.  Otherwise, returns null.
	 */
	public Integer getNetworkPrefixLength() {
		if(isAddress()) {
			return parsedHost.asAddress().getNetworkPrefixLength();
		} else if(isAddressString()) {
			return parsedHost.asGenericAddressString().getNetworkPrefixLength();
		}
		return isValid() ? parsedHost.getEquivalentPrefixLength() : null;
	}
	
	/**
	 * If a mask was provided with this host name, this returns the resulting mask value.
	 * 
	 * @return
	 */
	public IPAddress getMask() {
		if(isValid()) {
			if(parsedHost.isAddressString()) {
				return parsedHost.getAddressProvider().getProviderMask();
			}
			return parsedHost.getMask();
		}
		return null;
	}
	/**
	 * Similar to {@link #toInetAddress()} but does not throw, instead returns null whenever not a valid address.
	 * This method does not resolve hosts.  For that, call {@link #toAddress()} and then {@link IPAddress#toInetAddress()}
	 * 
	 * @return
	 */
	public InetAddress asInetAddress() {
		if(isValid() && isAddressString()) {
			IPAddress ipAddr = asAddress();
            if(ipAddr != null) {
            	return ipAddr.toInetAddress();
            }
		}
		return null;
	}
	
	/**
	 * Returns the InetSocketAddress for this host.  A host must have an associated port,
	 * or a service name string that is mapped to a port using the provided service mapper, 
	 * to have a corresponding InetSocketAddress.
	 * <p>
	 * If there is on associated port, then this returns null.
	 * <p>
	 * Note that host name strings are not resolved when using this method.
	 * 
	 * @param serviceMapper maps service name strings to ports.  
	 * 	Returns null when a service string has no mapping, otherwise returns the port for a given service.
	 * 	You can use a project like netdb to provide a service mapper lambda, https://github.com/jnr/jnr-netdb
	 * @return the socket address, or null if no such address.
	 */
	public InetSocketAddress asInetSocketAddress(Function<String, Integer> serviceMapper) {
		if(isValid()) {
			Integer port = getPort();
			if(port == null && serviceMapper != null) {
				String service = getService();
				if(service != null) {
					port = serviceMapper.apply(service);
				}
			}
			if(port != null) {
				IPAddress ipAddr;
				if(isAddressString() && (ipAddr = asAddress()) != null) {
					return new InetSocketAddress(ipAddr.toInetAddress(), port);
				} else {
					return new InetSocketAddress(getHost(), port);
				}
			}
		}
		return null;
	}
	
	/**
	 * Returns the InetSocketAddress for this host.  A host must have an associated port to have a corresponding InetSocketAddress.
	 * <p>
	 * If there is on associated port, then this returns null.
	 * <p>
	 * Note that host name strings are not resolved when using this method.
	 * 
	 * @return the socket address, or null if no such address.
	 */
	public InetSocketAddress asInetSocketAddress() {
		return asInetSocketAddress(null);
	}
	/**
	 * Similar to {@link #toAddress()}, however in the case where the host is resolved,
	 * this method returns all resolved addresses rather than the primary resolved address.
	 * In the cases where {@link #toAddress()} returns null, this returns an empty array,
	 * and in the cases where this host represents an IP address, this method returns an array of length 1 with that address.
	 * 
	 * @return
	 * @throws UnknownHostException
	 * @throws HostNameException
	 */
	public IPAddress[] toAllAddresses() throws UnknownHostException, HostNameException {
		return toAddresses();
	}
	
	/**
	 * If this represents an IP address, returns that address.
	 * If this represents a host, returns the resolved ip address of that host.
	 * Otherwise, returns null, but only for strings that are considered valid address strings but cannot be converted to address objects.
	 * 
	 * This method will throw exceptions for invalid formats and failures to resolve the address.  The equivalent method {@link #getAddress()} will simply return null rather than throw those exceptions.
	 * 
	 * If you wish to get the represented address and avoid DNS resolution, use {@link #asAddress()} or {@link #asAddressString()}
	 * 
	 * @return
	 */
	@Override
	public IPAddress toAddress() throws UnknownHostException, HostNameException {
		IPAddress addrs[] = toAddresses();
		return addrs.length == 0 ? null : addrs[0];
	}
	
	
	private IPAddress[] toAddresses() throws UnknownHostException, HostNameException {
		IPAddress addrs[] = resolvedAddresses;
		if(addrs == null) {
			//note that validation handles empty address resolution
			validate();
			synchronized(this) {
				addrs = resolvedAddresses;
				if(addrs == null) {
					if(parsedHost.isAddressString()) {
						addrs = new IPAddress[] {parsedHost.asAddress()};
						//note there is no need to apply prefix or mask here, it would have been applied to the address already
					} else {
						String strHost = parsedHost.getHost();
						if(strHost.length() == 0 && !validationOptions.emptyIsLoopback) {
							addrs = EMPTY_ADDRS;
						} else {
							//Note we do not set resolvedIsNull, so we will attempt to resolve again if the previous attempt threw an exception
							InetAddress inetAddresses[] = InetAddress.getAllByName(strHost);
							addrs = new IPAddress[inetAddresses.length];
							for(int j = 0; j < inetAddresses.length; j++) {
								InetAddress inetAddress = inetAddresses[j];
								byte bytes[] = inetAddress.getAddress();
								Integer networkPrefixLength = parsedHost.getNetworkPrefixLength();
								if(networkPrefixLength == null) {
									IPAddress mask = parsedHost.getMask();
									if(mask != null) {
										byte maskBytes[] = mask.getBytes();
										if(maskBytes.length == bytes.length) {
											for(int i = 0; i < bytes.length; i++) {
												bytes[i] &= maskBytes[i];
											}
											networkPrefixLength = mask.getBlockMaskPrefixLength(true);
										}
									}
								}
								IPAddressStringParameters addressParams = validationOptions.addressOptions;
								if(bytes.length == IPv6Address.BYTE_COUNT) {
									IPv6AddressCreator creator = addressParams.getIPv6Parameters().getNetwork().getAddressCreator();
									addrs[j] = creator.createAddressInternal(bytes, networkPrefixLength, null, this); /* address creation */
								} else {
									if(networkPrefixLength != null && networkPrefixLength > IPv4Address.BIT_COUNT) {
										networkPrefixLength = IPAddressSection.cacheBits(IPv4Address.BIT_COUNT);
									}
									IPv4AddressCreator creator = addressParams.getIPv4Parameters().getNetwork().getAddressCreator();
									addrs[j] = creator.createAddressInternal(bytes, networkPrefixLength, this); /* address creation */
								}
							}
							
						}
					}
					resolvedAddresses = addrs;
				}
			}
		}
		return addrs;
	}
	/**
	 * If this represents an ip address, returns that address.
	 * If this represents a host, returns the resolved ip address of that host.
	 * Otherwise, returns null.
	 * 
	 * If you wish to get the represented address and avoid DNS resolution, use {@link #asAddress()} or {@link #asAddressString()}
	 * 
	 * @return
	 */
	@Override
	public IPAddress getAddress() {
		try {
			return toAddress();
		} catch(HostNameException | UnknownHostException e) {
			//call toResolvedAddress if you wish to see this exception
			//HostNameException objects are cached in validate and can be seen by calling validate
		}
		return null;
	}
	
	/**
	 * Returns the string used to construct the object.
	 */
	@Override
	public String toString() {
		return host;
	}
}