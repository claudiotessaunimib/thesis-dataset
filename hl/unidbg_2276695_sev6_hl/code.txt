package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
class DetachCommand implements GdbStubCommand {
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        stub.makePacketAndSend("OK");
        stub.detachServer();
        return true;
    }
}package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.debugger.AbstractDebugServer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.Arm64Const;
import unicorn.ArmConst;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * GdbStub class
 * @author Humberto Silva Naves
 */
public final class GdbStub extends AbstractDebugServer {
    private static final Logger log = LoggerFactory.getLogger(GdbStub.class);
    static final String SIGTRAP = "05"; /* Trace trap (POSIX).  */
    final int[] registers;
    private String lastPacket;
    private final StringBuilder currentInputPacket;
    private int packetChecksum, packetFinished;
    public GdbStub(Emulator<?> emulator) {
        super(emulator);
        currentInputPacket = new StringBuilder();
        if (emulator.is32Bit()) { // arm32
            registers = new int[] {
                    ArmConst.UC_ARM_REG_R0,
                    ArmConst.UC_ARM_REG_R1,
                    ArmConst.UC_ARM_REG_R2,
                    ArmConst.UC_ARM_REG_R3,
                    ArmConst.UC_ARM_REG_R4,
                    ArmConst.UC_ARM_REG_R5,
                    ArmConst.UC_ARM_REG_R6,
                    ArmConst.UC_ARM_REG_R7,
                    ArmConst.UC_ARM_REG_R8,
                    ArmConst.UC_ARM_REG_R9,
                    ArmConst.UC_ARM_REG_R10,
                    ArmConst.UC_ARM_REG_R11,
                    ArmConst.UC_ARM_REG_R12,
                    ArmConst.UC_ARM_REG_SP,
                    ArmConst.UC_ARM_REG_LR,
                    ArmConst.UC_ARM_REG_PC,
                    ArmConst.UC_ARM_REG_CPSR
            };
        } else { // arm64
            registers = new int[34];
            for (int i = 0; i <= 28; i++) {
                registers[i] = Arm64Const.UC_ARM64_REG_X0 + i;
            }
            registers[29] = Arm64Const.UC_ARM64_REG_X29;
            registers[30] = Arm64Const.UC_ARM64_REG_X30;
            registers[31] = Arm64Const.UC_ARM64_REG_SP;
            registers[32] = Arm64Const.UC_ARM64_REG_PC;
            registers[33] = Arm64Const.UC_ARM64_REG_NZCV;
        }
    }
    @Override
    protected void onServerStart() {
        List<Module> loaded = new ArrayList<>(emulator.getMemory().getLoadedModules());
        loaded.sort((o1, o2) -> (int) (o1.base - o2.base));
        for (Module module : loaded) {
            System.err.println("[0x" + Long.toHexString(module.base) + "]" + module.name);
        }
    }
    void send(String packet) {
        sendData(packet.getBytes());
    }
    private void sendPacket(String packet) {
        lastPacket = packet;
        send(packet);
    }
    void makePacketAndSend(String data) {
        if (log.isDebugEnabled()) {
            log.debug("makePacketAndSend: {}", data);
        }
        int checksum = 0;
        data = escapePacketData(data);
        StringBuilder sb = new StringBuilder();
        sb.append("+");
        sb.append("$");
        for(int i = 0; i < data.length(); i++) {
            sb.append(data.charAt(i));
            checksum += (byte) data.charAt(i);
        }
        sb.append("#");
        sb.append(String.format("%02x", checksum & 0xff));
        sendPacket(sb.toString());
    }
    private String escapePacketData(String data) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < data.length(); i++) {
            char c = data.charAt(i);
            if (c == '$' || c == '#' || c == '}') {
                sb.append("}");
                sb.append(c ^ 0x20);
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }
    @Override
    protected void processInput(ByteBuffer input) {
        input.flip();
        while(input.hasRemaining()) {
            char c = (char) input.get();
            if (currentInputPacket.length() == 0) {
                switch (c) {
                    case '-':
                        reTransmitLastPacket();
                        break;
                    case '+': // Silently discard '+' packets
                        break;
                    case 0x3: // Ctrl-C requests
                        setSingleStep(1);
                        break;
                    case '$':
                        currentInputPacket.append(c);
                        packetChecksum = 0;
                        packetFinished = 0;
                        break;
                    default:
                        requestRetransmit();
                        break;
                }
            } else {
                currentInputPacket.append(c);
                if (packetFinished > 0) {
                    if (++packetFinished == 3) {
                        if (checkPacket()) {
                            processCommand(currentInputPacket.substring(1, currentInputPacket.length() - 3));
                        } else {
                            requestRetransmit();
                        }
                        currentInputPacket.setLength(0);
                    }
                } else if (c == '#') {
                    packetFinished = 1;
                } else {
                    packetChecksum += c;
                }
            }
        }
        input.clear();
    }
    private void requestRetransmit() {
        send("-");
    }
    private void reTransmitLastPacket() {
        send(lastPacket);
    }
    private boolean checkPacket() {
        try {
            int checksum = Integer.parseInt(currentInputPacket.substring(currentInputPacket.length() - 2), 16);
            return checksum == (packetChecksum & 0xff);
        } catch(NumberFormatException ex) {
            if (log.isDebugEnabled()) {
                log.debug("checkPacket currentInputPacket={}", currentInputPacket, ex);
            }
            return false;
        }
    }
    private void processCommand(String command) {
        for(String prefix : commands.keySet()) {
            if (command.startsWith(prefix)) {
                GdbStubCommand cmd = commands.get(prefix);
                if (log.isDebugEnabled()) {
                    log.debug("processCommand command={}, cmd={}", command, cmd);
                }
                if (cmd.processCommand(emulator, this, command)) {
                    return;
                }
            }
        }
        if (log.isDebugEnabled()) {
            log.warn("Unsupported command={}", command);
        }
        makePacketAndSend("");
    }
    @Override
    protected void onHitBreakPoint(Emulator<?> emulator, long address) {
        if (isDebuggerConnected()) {
            makePacketAndSend("S" + SIGTRAP);
        }
    }
    @Override
    protected boolean onDebuggerExit() {
        makePacketAndSend("W00");
        return true;
    }
    @Override
    protected void onDebuggerConnected() {
    }
    private static final Map<String, GdbStubCommand> commands;
    static {
        commands = new HashMap<>();
        GdbStubCommand commandContinue = new ContinueCommand();
        commands.put("c", commandContinue);
        GdbStubCommand commandStep = new StepCommand();
        commands.put("s", commandStep);
        GdbStubCommand commandBreakpoint = new BreakpointCommand();
        commands.put("z0", commandBreakpoint);
        commands.put("Z0", commandBreakpoint);
        GdbStubCommand commandMemory = new MemoryCommand();
        commands.put("m", commandMemory);
        commands.put("M", commandMemory);
        GdbStubCommand commandRegisters = new RegistersCommand();
        commands.put("g", commandRegisters);
        commands.put("G", commandRegisters);
        GdbStubCommand commandRegister = new RegisterCommand();
        commands.put("p", commandRegister);
        commands.put("P", commandRegister);
        GdbStubCommand commandKill = new KillCommand();
        commands.put("k", commandKill);
        GdbStubCommand commandEnableExtendedMode = new EnableExtendedModeCommand();
        commands.put("!", commandEnableExtendedMode);
        GdbStubCommand commandLastSignal = new LastSignalCommand();
        commands.put("?", commandLastSignal);
        GdbStubCommand commandDetach = new DetachCommand();
        commands.put("D", commandDetach);
        GdbStubCommand commandQuery = new QueryCommand();
        commands.put("q", commandQuery);
        GdbStubCommand commandSetThread = new SetThreadCommand();
        commands.put("H", commandSetThread);
        GdbStubCommand commandVCont = new ExtendedCommand();
        commands.put("vCont", commandVCont);
    }
    @Override
    public String toString() {
        return "gdb";
    }
}
package com.github.unidbg;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.debugger.DebuggerType;
import com.github.unidbg.file.FileSystem;
import com.github.unidbg.file.NewFileIO;
import com.github.unidbg.listener.TraceCodeListener;
import com.github.unidbg.listener.TraceReadListener;
import com.github.unidbg.listener.TraceSystemMemoryWriteListener;
import com.github.unidbg.listener.TraceWriteListener;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.serialize.Serializable;
import com.github.unidbg.spi.ArmDisassembler;
import com.github.unidbg.spi.Dlfcn;
import com.github.unidbg.spi.LibraryFile;
import com.github.unidbg.spi.SyscallHandler;
import com.github.unidbg.thread.ThreadDispatcher;
import com.github.unidbg.unwind.Unwinder;
import java.io.Closeable;
import java.io.File;
import java.net.URL;
/**
 * cpu emulator
 * Created by zhkl0228 on 2017/5/2.
 */
public interface Emulator<T extends NewFileIO> extends Closeable, ArmDisassembler, Serializable {
    int getPointerSize();
    boolean is64Bit();
    boolean is32Bit();
    int getPageAlign();
    /**
     * trace memory read
     */
    TraceHook traceRead();
    TraceHook traceRead(long begin, long end);
    TraceHook traceRead(long begin, long end, TraceReadListener listener);
    /**
     * trace memory write
     */
    TraceHook traceWrite();
    TraceHook traceWrite(long begin, long end);
    TraceHook traceWrite(long begin, long end, TraceWriteListener listener);
    void setTraceSystemMemoryWrite(long begin, long end, TraceSystemMemoryWriteListener listener);
    /**
     * trace instruction
     * note: low performance
     */
    TraceHook traceCode();
    TraceHook traceCode(long begin, long end);
    TraceHook traceCode(long begin, long end, TraceCodeListener listener);
    Number eFunc(long begin, Number... arguments);
    Number eEntry(long begin, long sp);
    /**
     * emulate signal handler
     * @param sig signal number
     * @return <code>true</code> means called handler function.
     */
    boolean emulateSignal(int sig);
    /**
     * 是否正在运行
     */
    boolean isRunning();
    /**
     * show all registers
     */
    void showRegs();
    /**
     * show registers
     */
    void showRegs(int... regs);
    Module loadLibrary(File libraryFile);
    Module loadLibrary(File libraryFile, boolean forceCallInit);
    Memory getMemory();
    Backend getBackend();
    int getPid();
    String getProcessName();
    Debugger attach();
    Debugger attach(DebuggerType type);
    FileSystem<T> getFileSystem();
    SvcMemory getSvcMemory();
    SyscallHandler<T> getSyscallHandler();
    Family getFamily();
    LibraryFile createURLibraryFile(URL url, String libName);
    Dlfcn getDlfcn();
    /**
     * @param timeout  Duration to emulate the code (in microseconds). When this value is 0, we will emulate the code in infinite time, until the code is finished.
     */
    void setTimeout(long timeout);
    <V extends RegisterContext> V getContext();
    Unwinder getUnwinder();
    void pushContext(int off);
    int popContext();
    ThreadDispatcher getThreadDispatcher();
    long getReturnAddress();
    void set(String key, Object value);
    <V> V get(String key);
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
interface GdbStubCommand {
    boolean processCommand(Emulator<?> emulator, GdbStub stub, String command);
}
package com.github.unidbg;
import com.alibaba.fastjson.util.IOUtils;
import com.github.unidbg.arm.ARMSvcMemory;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.backend.BackendFactory;
import com.github.unidbg.arm.backend.ReadHook;
import com.github.unidbg.arm.backend.WriteHook;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.debugger.DebugServer;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.debugger.DebuggerType;
import com.github.unidbg.debugger.gdb.GdbStub;
import com.github.unidbg.debugger.ida.AndroidServer;
import com.github.unidbg.file.FileSystem;
import com.github.unidbg.file.NewFileIO;
import com.github.unidbg.listener.TraceCodeListener;
import com.github.unidbg.listener.TraceReadListener;
import com.github.unidbg.listener.TraceSystemMemoryWriteListener;
import com.github.unidbg.listener.TraceWriteListener;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.MemoryWriteListener;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.spi.Dlfcn;
import com.github.unidbg.thread.MainTask;
import com.github.unidbg.thread.PopContextException;
import com.github.unidbg.thread.RunnableTask;
import com.github.unidbg.thread.ThreadContextSwitchException;
import com.github.unidbg.thread.ThreadDispatcher;
import com.github.unidbg.thread.UniThreadDispatcher;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.Arm64Const;
import unicorn.ArmConst;
import java.io.DataOutput;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.management.ManagementFactory;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Stack;
/**
 * abstract emulator
 * Created by zhkl0228 on 2017/5/2.
 */
public abstract class AbstractEmulator<T extends NewFileIO> implements Emulator<T>, MemoryWriteListener {
    private static final Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
    public static final long DEFAULT_TIMEOUT = 0;
    protected final Backend backend;
    private final int pid;
    protected long timeout = DEFAULT_TIMEOUT;
    private final RegisterContext registerContext;
    private final FileSystem<T> fileSystem;
    protected final SvcMemory svcMemory;
    private final Family family;
    protected final DateFormat dateFormat = new SimpleDateFormat("[HH:mm:ss SSS]");
    public AbstractEmulator(boolean is64Bit, String processName, long svcBase, int svcSize, File rootDir, Family family, Collection<BackendFactory> backendFactories) {
        super();
        this.family = family;
        File targetDir = new File("target");
        if (!targetDir.exists()) {
            targetDir = FileUtils.getTempDirectory();
        }
        if (rootDir == null) {
            rootDir = new File(targetDir, FileSystem.DEFAULT_ROOT_FS);
        }
        if (rootDir.isFile()) {
            throw new IllegalArgumentException("rootDir must be directory: " + rootDir);
        }
        if (!rootDir.exists() && !rootDir.mkdirs()) {
            throw new IllegalStateException("mkdirs failed: " + rootDir);
        }
        this.fileSystem = createFileSystem(rootDir);
        this.backend = BackendFactory.createBackend(this, is64Bit, backendFactories);
        this.processName = processName == null ? "unidbg" : processName;
        this.registerContext = createRegisterContext(backend);
        String name = ManagementFactory.getRuntimeMXBean().getName();
        String pid = name.split("@")[0];
        this.pid = Integer.parseInt(pid) & 0x7fff;
        this.svcMemory = new ARMSvcMemory(svcBase, svcSize, this);
        this.threadDispatcher = createThreadDispatcher();
        this.backend.onInitialize();
    }
    protected ThreadDispatcher createThreadDispatcher() {
        return new UniThreadDispatcher(this);
    }
    @Override
    public final int getPageAlign() {
        int pageSize = backend.getPageSize();
        if (pageSize == 0) {
            pageSize = getPageAlignInternal();
        }
        return pageSize;
    }
    protected abstract int getPageAlignInternal();
    @Override
    public Family getFamily() {
        return family;
    }
    public final SvcMemory getSvcMemory() {
        return svcMemory;
    }
    @Override
    public final FileSystem<T> getFileSystem() {
        return fileSystem;
    }
    protected abstract FileSystem<T> createFileSystem(File rootDir);
    @Override
    public boolean is64Bit() {
        return getPointerSize() == 8;
    }
    @Override
    public boolean is32Bit() {
        return getPointerSize() == 4;
    }
    protected abstract RegisterContext createRegisterContext(Backend backend);
    @SuppressWarnings("unchecked")
    @Override
    public <V extends RegisterContext> V getContext() {
        return (V) registerContext;
    }
    protected  abstract Memory createMemory(UnixSyscallHandler<T> syscallHandler, String[] envs);
    protected abstract Dlfcn createDyld(SvcMemory svcMemory);
    protected abstract UnixSyscallHandler<T> createSyscallHandler(SvcMemory svcMemory);
    protected abstract byte[] assemble(Iterable<String> assembly);
    private Debugger debugger;
    @Override
    public Debugger attach() {
        return attach(DebuggerType.CONSOLE);
    }
    @Override
    public Debugger attach(DebuggerType type) {
        if (debugger != null) {
            return debugger;
        }
        switch (type) {
            case GDB_SERVER:
                debugger = new GdbStub(this);
                break;
            case ANDROID_SERVER_V7:
                debugger = new AndroidServer(this, DebugServer.IDA_PROTOCOL_VERSION_V7);
                break;
            case CONSOLE:
            default:
                debugger = createConsoleDebugger();
                break;
        }
        if (debugger == null) {
            throw new UnsupportedOperationException();
        }
        this.backend.debugger_add(debugger, 1, 0, this);
        this.timeout = 0;
        return debugger;
    }
    protected abstract Debugger createConsoleDebugger();
    @Override
    public int getPid() {
        return pid;
    }
    @Override
    public final TraceHook traceRead(long begin, long end) {
        return traceRead(begin, end, null);
    }
    @Override
    public TraceHook traceRead(long begin, long end, TraceReadListener listener) {
        TraceMemoryHook hook = new TraceMemoryHook(true);
        if (listener != null) {
            hook.traceReadListener = listener;
        }
        backend.hook_add_new((ReadHook) hook, begin, end, this);
        return hook;
    }
    @Override
    public final TraceHook traceWrite(long begin, long end) {
        return traceWrite(begin, end, null);
    }
    private long traceSystemMemoryWriteBegin;
    private long traceSystemMemoryWriteEnd;
    private boolean traceSystemMemoryWrite;
    private TraceSystemMemoryWriteListener traceSystemMemoryWriteListener;
    @Override
    public void setTraceSystemMemoryWrite(long begin, long end, TraceSystemMemoryWriteListener listener) {
        traceSystemMemoryWrite = true;
        traceSystemMemoryWriteBegin = begin;
        traceSystemMemoryWriteEnd = end;
        traceSystemMemoryWriteListener = listener;
    }
    @Override
    public void onSystemWrite(long addr, byte[] data) {
        if (!traceSystemMemoryWrite) {
            return;
        }
        long max = Math.max(addr, traceSystemMemoryWriteBegin);
        long min = Math.min(addr + data.length, traceSystemMemoryWriteEnd);
        if (max < min) {
            byte[] buf = new byte[(int) (min - max)];
            System.arraycopy(data, (int) (max - addr), buf, 0, buf.length);
            if (traceSystemMemoryWriteListener != null) {
                traceSystemMemoryWriteListener.onWrite(this, addr, buf);
            } else {
                StringWriter writer = new StringWriter();
                writer.write("### System Memory WRITE at 0x" + Long.toHexString(max) + "\n");
                new Exception().printStackTrace(new PrintWriter(writer));
                Inspector.inspect(buf, writer.toString());
            }
        }
    }
    @Override
    public TraceHook traceWrite(long begin, long end, TraceWriteListener listener) {
        TraceMemoryHook hook = new TraceMemoryHook(false);
        if (listener != null) {
            hook.traceWriteListener = listener;
        }
        backend.hook_add_new((WriteHook) hook, begin, end, this);
        return hook;
    }
    @Override
    public final TraceHook traceRead() {
        return traceRead(1, 0);
    }
    @Override
    public final TraceHook traceWrite() {
        return traceWrite(1, 0);
    }
    @Override
    public final TraceHook traceCode() {
        return traceCode(1, 0);
    }
    @Override
    public final TraceHook traceCode(long begin, long end) {
        return traceCode(begin, end, null);
    }
    @Override
    public TraceHook traceCode(long begin, long end, TraceCodeListener listener) {
        AssemblyCodeDumper hook = new AssemblyCodeDumper(this, begin, end, listener);
        backend.hook_add_new(hook, begin, end, this);
        return hook;
    }
    @Override
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    private boolean running;
    @Override
    public boolean isRunning() {
        return running;
    }
    private final ThreadDispatcher threadDispatcher;
    @Override
    public ThreadDispatcher getThreadDispatcher() {
        return threadDispatcher;
    }
    @Override
    public boolean emulateSignal(int sig) {
        MainTask main = getSyscallHandler().createSignalHandlerTask(this, sig);
        if (main == null) {
            return false;
        } else {
            Memory memory = getMemory();
            long spBackup = memory.getStackPoint();
            try {
                threadDispatcher.runMainForResult(main);
            } finally {
                memory.setStackPoint(spBackup);
            }
            return true;
        }
    }
    protected final Number runMainForResult(MainTask task) {
        Memory memory = getMemory();
        long spBackup = memory.getStackPoint();
        try {
            return getThreadDispatcher().runMainForResult(task);
        } finally {
            memory.setStackPoint(spBackup);
        }
    }
    /**
     * @return <code>null</code>表示执行未完成，需要线程调度
     */
    public final Number emulate(long begin, long until) throws PopContextException {
        if (running) {
            backend.emu_stop();
            throw new IllegalStateException("running");
        }
        if (is32Bit()) {
            begin &= 0xffffffffL;
        }
        final Pointer pointer = UnidbgPointer.pointer(this, begin);
        long start = 0;
        Thread exitHook = null;
        try {
            if (log.isDebugEnabled()) {
                log.debug("emulate " + pointer + " started sp=" + getStackPointer());
            }
            start = System.currentTimeMillis();
            running = true;
            if (log.isDebugEnabled()) {
                exitHook = new Thread(() -> {
                    backend.emu_stop();
                    Debugger debugger = attach();
                    if (!debugger.isDebugging()) {
                        debugger.debug();
                    }
                });
                Runtime.getRuntime().addShutdownHook(exitHook);
            }
            backend.emu_start(begin, until, 0, 0);
            if (is64Bit()) {
                return backend.reg_read(Arm64Const.UC_ARM64_REG_X0);
            } else {
                Number r0 = backend.reg_read(ArmConst.UC_ARM_REG_R0);
                Number r1 = backend.reg_read(ArmConst.UC_ARM_REG_R1);
                return (r0.intValue() & 0xffffffffL) | ((r1.intValue() & 0xffffffffL) << 32);
            }
        } catch (ThreadContextSwitchException e) {
            e.syncReturnValue(this);
            if (log.isTraceEnabled()) {
                e.printStackTrace(System.out);
            }
            return null;
        } catch (PopContextException e) {
            throw e;
        } catch (RuntimeException e) {
            return handleEmuException(e, pointer, start);
        } finally {
            if (exitHook != null) {
                Runtime.getRuntime().removeShutdownHook(exitHook);
            }
            running = false;
            log.debug("emulate {} finished sp={}, offset={}ms", pointer, getStackPointer(), System.currentTimeMillis() - start);
        }
    }
    private int handleEmuException(RuntimeException e, Pointer pointer, long start) {
        boolean enterDebug = log.isDebugEnabled();
        if (enterDebug || !log.isWarnEnabled()) {
            e.printStackTrace(System.out);
            attach().debug();
        } else {
            String msg = e.getMessage();
            if (msg == null) {
                msg = e.getClass().getName();
            }
            RunnableTask runningTask = threadDispatcher.getRunningTask();
            log.warn("emulate {} exception sp={}, msg={}, offset={}ms{}", pointer, getStackPointer(), msg, System.currentTimeMillis() - start,
                    runningTask == null ? "" : (" @ " + runningTask));
        }
        return -1;
    }
    public abstract Pointer getStackPointer();
    private boolean closed;
    @Override
    public synchronized final void close() throws IOException {
        if (closed) {
            throw new IOException("Already closed.");
        }
        try {
            IOUtils.close(debugger);
            closeInternal();
            backend.destroy();
        } finally {
            closed = true;
        }
    }
    protected abstract void closeInternal();
    @Override
    public Backend getBackend() {
        return backend;
    }
    private final String processName;
    @Override
    public String getProcessName() {
        return processName == null ? "unidbg" : processName;
    }
    private final Map<String, Object> context = new HashMap<>();
    @Override
    public void set(String key, Object value) {
        context.put(key, value);
    }
    @SuppressWarnings("unchecked")
    @Override
    public <V> V get(String key) {
        return (V) context.get(key);
    }
    protected abstract boolean isPaddingArgument();
    protected void dumpClass(String className) {
        throw new UnsupportedOperationException("dumpClass className=" + className);
    }
    protected void searchClass(String keywords) {
        throw new UnsupportedOperationException("searchClass keywords=" + keywords);
    }
    protected void dumpGPBProtobufMsg(String className) {
        throw new UnsupportedOperationException("dumpGPBProtobufMsg className=" + className);
    }
    @Override
    public final void serialize(DataOutput out) throws IOException {
        out.writeUTF(getClass().getName());
        getMemory().serialize(out);
        getSvcMemory().serialize(out);
        getSyscallHandler().serialize(out);
        getDlfcn().serialize(out);
    }
    private static class Context {
        private final long ctx;
        private final int off;
        Context(long ctx, int off) {
            this.ctx = ctx;
            this.off = off;
        }
        void restoreAndFree(Backend backend) {
            backend.context_restore(ctx);
            backend.context_free(ctx);
        }
    }
    private final Stack<Context> contextStack = new Stack<>();
    @Override
    public void pushContext(int off) {
        long context = backend.context_alloc();
        backend.context_save(context);
        contextStack.push(new Context(context, off));
    }
    @Override
    public int popContext() {
        Context ctx = contextStack.pop();
        ctx.restoreAndFree(backend);
        return ctx.off;
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
class ExtendedCommand implements GdbStubCommand {
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        if ("vCont?".equals(command)) {
            stub.makePacketAndSend("vCont;c;s");
            return true;
        }
        if ("vCont;c".equals(command)) {
            stub.resumeRun();
            return true;
        }
        if ("vCont;s".equals(command)) {
            stub.singleStep();
            return true;
        }
        return false;
    }
}
package com.github.unidbg.arm;
import capstone.api.Instruction;
import capstone.api.RegsAccess;
import com.github.unidbg.AssemblyCodeDumper;
import com.github.unidbg.Emulator;
import com.github.unidbg.Family;
import com.github.unidbg.Module;
import com.github.unidbg.Symbol;
import com.github.unidbg.TraceMemoryHook;
import com.github.unidbg.Utils;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.backend.BlockHook;
import com.github.unidbg.arm.backend.ReadHook;
import com.github.unidbg.arm.backend.UnHook;
import com.github.unidbg.arm.backend.WriteHook;
import com.github.unidbg.debugger.BreakPoint;
import com.github.unidbg.debugger.BreakPointCallback;
import com.github.unidbg.debugger.DebugListener;
import com.github.unidbg.debugger.DebugRunnable;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.debugger.FunctionCallListener;
import com.github.unidbg.memory.MemRegion;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.MemoryMap;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.thread.Task;
import com.github.unidbg.unix.struct.StdString;
import com.github.unidbg.unwind.Unwinder;
import com.github.unidbg.utils.Inspector;
import com.github.zhkl0228.demumble.DemanglerFactory;
import com.github.zhkl0228.demumble.GccDemangler;
import com.sun.jna.Pointer;
import keystone.Keystone;
import keystone.KeystoneEncoded;
import keystone.exceptions.AssembleFailedKeystoneException;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.Arm64Const;
import unicorn.ArmConst;
import unicorn.UnicornConst;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public abstract class AbstractARMDebugger implements Debugger {
    private static final Logger log = LoggerFactory.getLogger(AbstractARMDebugger.class);
    private final Map<Long, BreakPoint> breakMap = new LinkedHashMap<>();
    protected final Emulator<?> emulator;
    protected AbstractARMDebugger(Emulator<?> emulator) {
        this.emulator = emulator;
    }
    private final List<UnHook> unHookList = new ArrayList<>();
    @Override
    public void onAttach(UnHook unHook) {
        unHookList.add(unHook);
    }
    @Override
    public void detach() {
        for (Iterator<UnHook> iterator = unHookList.iterator(); iterator.hasNext(); ) {
            iterator.next().unhook();
            iterator.remove();
        }
    }
    @Override
    public final BreakPoint addBreakPoint(Module module, String symbol) {
        Symbol sym = module.findSymbolByName(symbol, false);
        if (sym == null) {
            throw new IllegalStateException("find symbol failed: " + symbol);
        }
        return addBreakPoint(module, sym.getValue());
    }
    @Override
    public final BreakPoint addBreakPoint(Module module, String symbol, BreakPointCallback callback) {
        Symbol sym = module.findSymbolByName(symbol, false);
        if (sym == null) {
            throw new IllegalStateException("find symbol failed: " + symbol);
        }
        return addBreakPoint(module, sym.getValue(), callback);
    }
    @Override
    public final BreakPoint addBreakPoint(Module module, long offset) {
        long address = module == null ? offset : module.base + offset;
        return addBreakPoint(address);
    }
    @Override
    public final BreakPoint addBreakPoint(Module module, long offset, BreakPointCallback callback) {
        long address = module == null ? offset : module.base + offset;
        return addBreakPoint(address, callback);
    }
    @Override
    public BreakPoint addBreakPoint(long address) {
        return addBreakPoint(address, null);
    }
    @Override
    public BreakPoint addBreakPoint(long address, BreakPointCallback callback) {
        boolean thumb = (address & 1) != 0;
        address &= (~1);
        if (log.isDebugEnabled()) {
            log.debug("addBreakPoint address=0x{}", Long.toHexString(address));
        }
        BreakPoint breakPoint = emulator.getBackend().addBreakPoint(address, callback, thumb);
        breakMap.put(address, breakPoint);
        return breakPoint;
    }
    @Override
    public void traceFunctionCall(FunctionCallListener listener) {
        traceFunctionCall(null, listener);
    }
    @Override
    public void traceFunctionCall(Module module, FunctionCallListener listener) {
        throw new UnsupportedOperationException();
    }
    protected abstract Keystone createKeystone(boolean isThumb);
    public final boolean removeBreakPoint(long address) {
        address &= (~1);
        if (breakMap.containsKey(address)) {
            breakMap.remove(address);
            return emulator.getBackend().removeBreakPoint(address);
        } else {
            return false;
        }
    }
    private DebugListener listener;
    @Override
    public void setDebugListener(DebugListener listener) {
        this.listener = listener;
    }
    @Override
    public void onBreak(Backend backend, long address, int size, Object user) {
        BreakPoint breakPoint = breakMap.get(address);
        if (breakPoint != null && breakPoint.isTemporary()) {
            removeBreakPoint(address);
        }
        BreakPointCallback callback;
        if (breakPoint != null && (callback = breakPoint.getCallback()) != null && callback.onHit(emulator, address)) {
            return;
        }
        try {
            if (listener == null || listener.canDebug(emulator, new CodeHistory(address, size, ARM.isThumb(backend)))) {
                cancelTrace();
                debugging = true;
                loop(emulator, address, size, null);
            }
        } catch (Exception e) {
            log.warn("process loop failed", e);
        } finally {
            debugging = false;
        }
    }
    private void cancelTrace() {
        if (traceHook != null) {
            traceHook.detach();
            traceHook = null;
        }
        if (traceHookRedirectStream != null) {
            com.alibaba.fastjson.util.IOUtils.close(traceHookRedirectStream);
            traceHookRedirectStream = null;
        }
        if (traceRead != null) {
            traceRead.detach();
            traceRead = null;
        }
        if (traceReadRedirectStream != null) {
            com.alibaba.fastjson.util.IOUtils.close(traceReadRedirectStream);
            traceReadRedirectStream = null;
        }
        if (traceWrite != null) {
            traceWrite.detach();
            traceWrite = null;
        }
        if (traceWriteRedirectStream != null) {
            com.alibaba.fastjson.util.IOUtils.close(traceWriteRedirectStream);
            traceWriteRedirectStream = null;
        }
    }
    private boolean debugging;
    @Override
    public boolean isDebugging() {
        return debugging;
    }
    private boolean blockHooked;
    private boolean breakNextBlock;
    @Override
    public void hookBlock(Backend backend, long address, int size, Object user) {
        if (breakNextBlock) {
            onBreak(backend, address, size, user);
            breakNextBlock = false;
        }
    }
    @Override
    public final void hook(Backend backend, long address, int size, Object user) {
        Emulator<?> emulator = (Emulator<?>) user;
        try {
            if (breakMnemonic != null) {
                CodeHistory history = new CodeHistory(address, size, ARM.isThumb(backend));
                Instruction[] instructions = history.disassemble(emulator);
                if (instructions.length > 0 && breakMnemonic.equals(instructions[0].getMnemonic())) {
                    breakMnemonic = null;
                    backend.setFastDebug(true);
                    cancelTrace();
                    debugging = true;
                    loop(emulator, address, size, null);
                }
            }
        } catch (Exception e) {
            log.warn("process hook failed", e);
        } finally {
            debugging = false;
        }
    }
    @Override
    public void debug() {
        Backend backend = emulator.getBackend();
        long address;
        if (emulator.is32Bit()) {
            address = backend.reg_read(ArmConst.UC_ARM_REG_PC).intValue() & 0xffffffffL;
        } else {
            address = backend.reg_read(Arm64Const.UC_ARM64_REG_PC).longValue();
        }
        try {
            cancelTrace();
            debugging = true;
            loop(emulator, address, 4, null);
        } catch (Exception e) {
            log.warn("debug failed", e);
        } finally {
            debugging = false;
        }
    }
    protected final void setSingleStep(int singleStep) {
        emulator.getBackend().setSingleStep(singleStep);
    }
    private String breakMnemonic;
    protected abstract void loop(Emulator<?> emulator, long address, int size, DebugRunnable<?> runnable) throws Exception;
    protected boolean callbackRunning;
    @Override
    public <T> T run(DebugRunnable<T> runnable) throws Exception {
        if (runnable == null) {
            throw new NullPointerException();
        }
        T ret;
        try {
            callbackRunning = true;
            ret = runnable.runWithArgs(null);
        } finally {
            callbackRunning = false;
        }
        try {
            cancelTrace();
            debugging = true;
            loop(emulator, -1, 0, runnable);
        } finally {
            debugging = false;
        }
        return ret;
    }
    protected enum StringType {
        nullTerminated,
        std_string
    }
    final void dumpMemory(Pointer pointer, int _length, String label, StringType stringType) {
        if (stringType != null) {
            if (stringType == StringType.nullTerminated) {
                long addr = 0;
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                boolean foundTerminated = false;
                while (true) {
                    byte[] data = pointer.getByteArray(addr, 0x10);
                    int length = data.length;
                    for (int i = 0; i < data.length; i++) {
                        if (data[i] == 0) {
                            length = i;
                            break;
                        }
                    }
                    baos.write(data, 0, length);
                    addr += length;
                    if (length < data.length) { // reach zero
                        foundTerminated = true;
                        break;
                    }
                    if (baos.size() > 0x10000) { // 64k
                        break;
                    }
                }
                if (foundTerminated) {
                    Inspector.inspect(baos.toByteArray(), baos.size() >= 1024 ? (label + ", hex=" + Hex.encodeHexString(baos.toByteArray())) : (label + ", str=" + new String(baos.toByteArray(), StandardCharsets.UTF_8)));
                } else {
                    Inspector.inspect(pointer.getByteArray(0, _length), label + ", find NULL-terminated failed");
                }
            } else if (stringType == StringType.std_string) {
                StdString string = StdString.createStdString(emulator, pointer);
                long size = string.getDataSize();
                byte[] data = string.getData(emulator);
                Inspector.inspect(data, size >= 1024 ? (label + ", hex=" + Hex.encodeHexString(data) + ", std=" + new String(data, StandardCharsets.UTF_8)) : label);
            } else {
                throw new UnsupportedOperationException("stringType=" + stringType);
            }
        } else {
            StringBuilder sb = new StringBuilder(label);
            byte[] data = pointer.getByteArray(0, _length);
            if (_length == 4) {
                ByteBuffer buffer = ByteBuffer.wrap(data);
                buffer.order(ByteOrder.LITTLE_ENDIAN);
                int value = buffer.getInt();
                sb.append(", value=0x").append(Integer.toHexString(value));
            } else if (_length == 8) {
                ByteBuffer buffer = ByteBuffer.wrap(data);
                buffer.order(ByteOrder.LITTLE_ENDIAN);
                long value = buffer.getLong();
                sb.append(", value=0x").append(Long.toHexString(value));
            } else if (_length == 16) {
                byte[] tmp = Arrays.copyOf(data, 16);
                for (int i = 0; i < 8; i++) {
                    byte b = tmp[i];
                    tmp[i] = tmp[15 - i];
                    tmp[15 - i] = b;
                }
                byte[] bytes = new byte[tmp.length + 1];
                System.arraycopy(tmp, 0, bytes, 1, tmp.length); // makePositive
                sb.append(", value=0x").append(new BigInteger(bytes).toString(16));
            }
            if (data.length >= 1024) {
                sb.append(", hex=").append(Hex.encodeHexString(data));
            }
            Inspector.inspect(data, sb.toString());
        }
    }
    private void searchStack(byte[] data) {
        if (data == null || data.length < 1) {
            System.err.println("search stack failed as empty data");
            return;
        }
        UnidbgPointer stack = emulator.getContext().getStackPointer();
        Backend backend = emulator.getBackend();
        Collection<Pointer> pointers = searchMemory(backend, stack.peer, emulator.getMemory().getStackBase(), data);
        System.out.println("Search stack from " + stack + " matches " + pointers.size() + " count");
        for (Pointer pointer : pointers) {
            System.out.println("Stack matches: " + pointer);
        }
    }
    private void searchHeap(byte[] data, int prot) {
        if (data == null || data.length < 1) {
            System.err.println("search heap failed as empty data");
            return;
        }
        List<Pointer> list = new ArrayList<>();
        Backend backend = emulator.getBackend();
        for (MemoryMap map : emulator.getMemory().getMemoryMap()) {
            if ((map.prot & prot) != 0) {
                Collection<Pointer> pointers = searchMemory(backend, map.base, map.base + map.size, data);
                list.addAll(pointers);
            }
        }
        System.out.println("Search heap matches " + list.size() + " count");
        for (Pointer pointer : list) {
            System.out.println("Heap matches: " + pointer);
        }
    }
    private Collection<Pointer> searchMemory(Backend backend, long start, long end, byte[] data) {
        List<Pointer> pointers = new ArrayList<>();
        for (long i = start, m = end - data.length; i < m; i++) {
            byte[] oneByte = backend.mem_read(i, 1);
            if (data[0] != oneByte[0]) {
                continue;
            }
            if (Arrays.equals(data, backend.mem_read(i, data.length))) {
                pointers.add(UnidbgPointer.pointer(emulator, i));
                i += (data.length - 1);
            }
        }
        return pointers;
    }
    private AssemblyCodeDumper traceHook;
    private PrintStream traceHookRedirectStream;
    private TraceMemoryHook traceRead;
    private PrintStream traceReadRedirectStream;
    private TraceMemoryHook traceWrite;
    private PrintStream traceWriteRedirectStream;
    final boolean handleCommon(Backend backend, String line, long address, int size, long nextAddress, DebugRunnable<?> runnable) throws Exception {
        if ("exit".equals(line) || "quit".equals(line) || "q".equals(line)) { // continue
            return true;
        }
        if ("gc".equals(line)) {
            System.out.println("Run System.gc();");
            System.gc();
            return false;
        }
        if ("threads".equals(line)) {
            for (Task task : emulator.getThreadDispatcher().getTaskList()) {
                System.out.println(task.getId() + ": " + task);
            }
            return false;
        }
        if (runnable == null || callbackRunning) {
            if ("c".equals(line)) { // continue
                return true;
            }
        } else {
            if ("c".equals(line)) {
                try {
                    callbackRunning = true;
                    runnable.runWithArgs(null);
                    cancelTrace();
                    return false;
                } finally {
                    callbackRunning = false;
                }
            }
        }
        if ("n".equals(line)) {
            if (nextAddress == 0) {
                System.out.println("Next address failed.");
                return false;
            } else {
                addBreakPoint(nextAddress).setTemporary(true);
                return true;
            }
        }
        if (line.startsWith("st")) { // search stack
            int index = line.indexOf(' ');
            if (index != -1) {
                String hex = line.substring(index + 1).trim();
                byte[] data = Hex.decodeHex(hex.toCharArray());
                if (data.length > 0) {
                    searchStack(data);
                    return false;
                }
            }
        }
        if (line.startsWith("shw")) { // search writable heap
            int index = line.indexOf(' ');
            if (index != -1) {
                String hex = line.substring(index + 1).trim();
                byte[] data = Hex.decodeHex(hex.toCharArray());
                if (data.length > 0) {
                    searchHeap(data, UnicornConst.UC_PROT_WRITE);
                    return false;
                }
            }
        }
        if (line.startsWith("shr")) { // search readable heap
            int index = line.indexOf(' ');
            if (index != -1) {
                String hex = line.substring(index + 1).trim();
                byte[] data = Hex.decodeHex(hex.toCharArray());
                if (data.length > 0) {
                    searchHeap(data, UnicornConst.UC_PROT_READ);
                    return false;
                }
            }
        }
        if (line.startsWith("shx")) { // search executable heap
            int index = line.indexOf(' ');
            if (index != -1) {
                String hex = line.substring(index + 1).trim();
                byte[] data = Hex.decodeHex(hex.toCharArray());
                if (data.length > 0) {
                    searchHeap(data, UnicornConst.UC_PROT_EXEC);
                    return false;
                }
            }
        }
        if (emulator.getFamily() == Family.iOS && !emulator.isRunning() && line.startsWith("dump ")) {
            String className = line.substring(5).trim();
            if (!className.isEmpty()) {
                dumpClass(className);
                return false;
            }
        }
        if (emulator.getFamily() == Family.iOS && !emulator.isRunning() && line.startsWith("gpb ")) {
            String className = line.substring(4).trim();
            if (!className.isEmpty()) {
                dumpGPBProtobufMsg(className);
                return false;
            }
        }
        if (emulator.getFamily() == Family.iOS && !emulator.isRunning() && line.startsWith("search ")) {
            String keywords = line.substring(7).trim();
            if (!keywords.isEmpty()) {
                searchClass(keywords);
                return false;
            }
        }
        final int traceSize = 0x10000;
        if (line.startsWith("traceRead")) { // start trace memory read
            Pattern pattern = Pattern.compile("traceRead\\s+(\\w+)\\s+(\\w+)");
            Matcher matcher = pattern.matcher(line);
            if (traceRead != null) {
                traceRead.detach();
            }
            traceRead = new TraceMemoryHook(true);
            long begin, end;
            if (matcher.find()) {
                begin = Utils.parseNumber(matcher.group(1));
                end = Utils.parseNumber(matcher.group(2));
                if (begin > end && end > 0 && end <= traceSize) {
                    end += begin;
                }
                if (begin >= end) {
                    File traceFile = new File("target/traceRead.txt");
                    if (!traceFile.exists() && !traceFile.createNewFile()) {
                        throw new IllegalStateException("createNewFile: " + traceFile);
                    }
                    traceReadRedirectStream = new PrintStream(new BufferedOutputStream(Files.newOutputStream(traceFile.toPath())), true);
                    traceReadRedirectStream.printf("[%s]Start traceRead%n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
                    traceRead.setRedirect(traceReadRedirectStream);
                    System.out.printf("Set trace all memory read success with trace file: %s.%n", traceFile);
                } else {
                    boolean needTraceFile = end - begin > traceSize;
                    if (needTraceFile) {
                        File traceFile = new File(String.format("target/traceRead_0x%x-0x%x.txt", begin, end));
                        if (!traceFile.exists() && !traceFile.createNewFile()) {
                            throw new IllegalStateException("createNewFile: " + traceFile);
                        }
                        traceReadRedirectStream = new PrintStream(new BufferedOutputStream(Files.newOutputStream(traceFile.toPath())), true);
                        traceReadRedirectStream.printf("[%s]Start traceRead: 0x%x-0x%x%n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()), begin, end);
                        traceRead.setRedirect(traceReadRedirectStream);
                        System.out.printf("Set trace 0x%x->0x%x memory read success with trace file: %s.%n", begin, end, traceFile.getAbsolutePath());
                    } else {
                        System.out.printf("Set trace 0x%x->0x%x memory read success.%n", begin, end);
                    }
                }
            } else {
                begin = 1;
                end = 0;
                File traceFile = new File("target/traceRead.txt");
                if (!traceFile.exists() && !traceFile.createNewFile()) {
                    throw new IllegalStateException("createNewFile: " + traceFile);
                }
                traceReadRedirectStream = new PrintStream(new BufferedOutputStream(Files.newOutputStream(traceFile.toPath())), true);
                traceReadRedirectStream.printf("[%s]Start traceRead%n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
                traceRead.setRedirect(traceReadRedirectStream);
                System.out.printf("Set trace all memory read success with trace file: %s.%n", traceFile.getAbsolutePath());
            }
            backend.hook_add_new((ReadHook) traceRead, begin, end, emulator);
            return false;
        }
        if (line.startsWith("traceWrite")) { // start trace memory write
            Pattern pattern = Pattern.compile("traceWrite\\s+(\\w+)\\s+(\\w+)");
            Matcher matcher = pattern.matcher(line);
            if (traceWrite != null) {
                traceWrite.detach();
            }
            traceWrite = new TraceMemoryHook(false);
            long begin, end;
            if (matcher.find()) {
                begin = Utils.parseNumber(matcher.group(1));
                end = Utils.parseNumber(matcher.group(2));
                if (begin > end && end > 0 && end <= traceSize) {
                    end += begin;
                }
                if (begin >= end) {
                    File traceFile = new File("target/traceWrite.txt");
                    if (!traceFile.exists() && !traceFile.createNewFile()) {
                        throw new IllegalStateException("createNewFile: " + traceFile);
                    }
                    traceWriteRedirectStream = new PrintStream(new BufferedOutputStream(Files.newOutputStream(traceFile.toPath())), true);
                    traceWriteRedirectStream.printf("[%s]Start traceWrite%n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
                    traceWrite.setRedirect(traceWriteRedirectStream);
                    System.out.printf("Set trace all memory write success with trace file: %s.%n", traceFile);
                } else {
                    boolean needTraceFile = end - begin > traceSize;
                    if (needTraceFile) {
                        File traceFile = new File(String.format("target/traceWrite_0x%x-0x%x.txt", begin, end));
                        if (!traceFile.exists() && !traceFile.createNewFile()) {
                            throw new IllegalStateException("createNewFile: " + traceFile);
                        }
                        traceWriteRedirectStream = new PrintStream(new BufferedOutputStream(Files.newOutputStream(traceFile.toPath())), true);
                        traceWriteRedirectStream.printf("[%s]Start traceWrite: 0x%x-0x%x%n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()), begin, end);
                        traceWrite.setRedirect(traceWriteRedirectStream);
                        System.out.printf("Set trace 0x%x->0x%x memory write success with trace file: %s.%n", begin, end, traceFile.getAbsolutePath());
                    } else {
                        System.out.printf("Set trace 0x%x->0x%x memory write success.%n", begin, end);
                    }
                }
            } else {
                begin = 1;
                end = 0;
                File traceFile = new File("target/traceWrite.txt");
                if (!traceFile.exists() && !traceFile.createNewFile()) {
                    throw new IllegalStateException("createNewFile: " + traceFile);
                }
                traceWriteRedirectStream = new PrintStream(new BufferedOutputStream(Files.newOutputStream(traceFile.toPath())), true);
                traceWriteRedirectStream.printf("[%s]Start traceWrite%n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
                traceWrite.setRedirect(traceWriteRedirectStream);
                System.out.printf("Set trace all memory write success with trace file: %s.%n", traceFile.getAbsolutePath());
            }
            backend.hook_add_new((WriteHook) traceWrite, begin, end, emulator);
            return false;
        }
        if (line.startsWith("trace")) { // start trace instructions
            Memory memory = emulator.getMemory();
            Pattern pattern = Pattern.compile("trace\\s+(\\w+)\\s+(\\w+)");
            Matcher matcher = pattern.matcher(line);
            if (traceHook != null) {
                traceHook.detach();
            }
            traceHookRedirectStream = null;
            long begin, end;
            if (matcher.find()) {
                begin = Utils.parseNumber(matcher.group(1));
                end = Utils.parseNumber(matcher.group(2));
                if (begin > end && end > 0 && end < traceSize) {
                    end += begin;
                }
                if (begin >= end) {
                    File traceFile = new File("target/traceCode.txt");
                    if (!traceFile.exists() && (!traceFile.getParentFile().exists() || !traceFile.createNewFile())) {
                        throw new IllegalStateException("createNewFile: " + traceFile.getAbsolutePath());
                    }
                    traceHookRedirectStream = new PrintStream(new BufferedOutputStream(Files.newOutputStream(traceFile.toPath())), true);
                    traceHookRedirectStream.printf("[%s]Start traceCode%n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
                    System.out.printf("Set trace all instructions success with trace file: %s.%n", traceFile.getAbsolutePath());
                } else {
                    boolean needTraceFile = end - begin > traceSize;
                    if (needTraceFile) {
                        File traceFile = new File(String.format("target/traceCode_0x%x-0x%x.txt", begin, end));
                        if (!traceFile.exists() && !traceFile.createNewFile()) {
                            throw new IllegalStateException("createNewFile: " + traceFile);
                        }
                        traceHookRedirectStream = new PrintStream(new BufferedOutputStream(Files.newOutputStream(traceFile.toPath())), true);
                        traceHookRedirectStream.printf("[%s]Start traceCode: 0x%x-0x%x%n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()), begin, end);
                        System.out.printf("Set trace 0x%x->0x%x instructions success with trace file: %s.%n", begin, end, traceFile.getAbsolutePath());
                    } else {
                        System.out.printf("Set trace 0x%x->0x%x instructions success.%n", begin, end);
                    }
                }
            } else {
                String redirect = null;
                Module module = memory.findModuleByAddress(address);
                {
                    int index = line.indexOf(' ');
                    if (index != -1) {
                        redirect = line.substring(index + 1).trim();
                    }
                }
                File traceFile = null;
                if (redirect != null && !redirect.trim().isEmpty()) {
                    Module check = memory.findModule(redirect);
                    if (check != null) {
                        module = check;
                    } else {
                        File outFile = new File(redirect.trim());
                        try {
                            if (!outFile.exists() && !outFile.createNewFile()) {
                                throw new IllegalStateException("createNewFile: " + outFile);
                            }
                            traceHookRedirectStream = new PrintStream(new BufferedOutputStream(Files.newOutputStream(outFile.toPath())), true);
                            traceHookRedirectStream.printf("[%s]Start trace %s%n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()), module == null ? "all" : module);
                            traceFile = outFile;
                        } catch (IOException e) {
                            System.err.println("Set trace redirect out file failed: " + outFile);
                            return false;
                        }
                    }
                }
                begin = module == null ? 1 : module.base;
                end = module == null ? 0 : (module.base + module.size);
                System.out.println("Set trace " + (module == null ? "all" : module) + " instructions success" + (traceFile == null ? "." : (" with trace file: " + traceFile.getAbsolutePath())));
            }
            traceHook = new AssemblyCodeDumper(emulator, begin, end, null);
            if (traceHookRedirectStream != null) {
                traceHook.setRedirect(traceHookRedirectStream);
            }
            backend.hook_add_new(traceHook, begin, end, emulator);
            return false;
        }
        if (line.startsWith("vm")) {
            Memory memory = emulator.getMemory();
            String maxLengthSoName = memory.getMaxLengthLibraryName();
            StringBuilder sb = new StringBuilder();
            String filter = null;
            {
                int index = line.indexOf(' ');
                if (index != -1) {
                    filter = line.substring(index + 1).trim();
                }
            }
            int index = 0;
            long filterAddress = -1;
            if (filter != null && filter.startsWith("0x")) {
                filterAddress = Utils.parseNumber(filter);
            }
            for (Module module : memory.getLoadedModules()) {
                if (filter == null || module.getPath().toLowerCase().contains(filter.toLowerCase()) || (filterAddress >= module.base && filterAddress < module.base + module.size)) {
                    sb.append(String.format("[%3s][%" + maxLengthSoName.length() + "s] ", index++, FilenameUtils.getName(module.name)));
                    sb.append(String.format("[0x%0" + Long.toHexString(memory.getMaxSizeOfLibrary()).length() + "x-0x%x]", module.getBaseHeader(), module.base + module.size));
                    sb.append(module.getPath());
                    sb.append("\n");
                }
            }
            if (index == 0) {
                System.err.println("Find loaded library failed with filter: " + filter);
            } else {
                System.out.println(sb);
            }
            return false;
        }
        switch (line) {
            case "vbs":  // view breakpoints
                Memory memory = emulator.getMemory();
                StringBuilder sb = new StringBuilder("* means temporary bp:\n");
                String maxLengthSoName = memory.getMaxLengthLibraryName();
                for (Map.Entry<Long, BreakPoint> entry : breakMap.entrySet()) {
                    address = entry.getKey();
                    BreakPoint bp = entry.getValue();
                    Instruction ins = null;
                    try {
                        byte[] code = backend.mem_read(address, 4);
                        Instruction[] insns = emulator.disassemble(address, code, bp.isThumb(), 1);
                        if (insns != null && insns.length > 0) {
                            ins = insns[0];
                        }
                    } catch (Exception ignored) {
                    }
                    if (ins == null) {
                        sb.append(String.format("[%" + String.valueOf(maxLengthSoName).length() + "s]", "0x" + Long.toHexString(address)));
                        if (bp.isTemporary()) {
                            sb.append('*');
                        }
                    } else {
                        sb.append(ARM.assembleDetail(emulator, ins, address, bp.isThumb(), bp.isTemporary(), memory.getMaxLengthLibraryName().length()));
                    }
                    sb.append("\n");
                }
                System.out.println(sb);
                return false;
            case "stop":
                backend.emu_stop();
                return true;
            case "s":
            case "si":
                setSingleStep(1);
                return true;
            case "nb":
                if (!blockHooked) {
                    blockHooked = true;
                    emulator.getBackend().hook_add_new((BlockHook) this, 1, 0, emulator);
                }
                breakNextBlock = true;
                return true;
        }
        if (line.startsWith("s")) {
            try {
                setSingleStep(Integer.parseInt(line.substring(1)));
                return true;
            } catch (NumberFormatException e) {
                breakMnemonic = line.substring(1);
                backend.setFastDebug(false);
                return true;
            }
        }
        if (line.startsWith("p")) {
            long originalAddress = address;
            String assembly = line.substring(1).trim();
            boolean isThumb = ARM.isThumb(backend);
            try (Keystone keystone = createKeystone(isThumb)) {
                KeystoneEncoded encoded = keystone.assemble(assembly);
                byte[] code = encoded.getMachineCode();
                address &= (~1);
                if (code.length != (nextAddress & ~1) - address) {
                    System.err.println("patch code failed: nextAddress=0x" + Long.toHexString(nextAddress) + ", codeSize=" + code.length);
                    return false;
                }
                Pointer pointer = UnidbgPointer.pointer(emulator, address);
                assert pointer != null;
                pointer.write(0, code, 0, code.length);
                disassemble(emulator, originalAddress, size, isThumb);
                return false;
            } catch (AssembleFailedKeystoneException e) {
                System.err.println("Assemble failed: " + assembly);
                return false;
            }
        }
        Module module = emulator.getMemory().findModuleByAddress(address);
        if (module != null && line.startsWith("cc")) {
            int sizeBytes = (int) Utils.parseNumber(line.substring(2).trim()) & ~1;
            if (sizeBytes >= 2) {
                Instruction[] insns = emulator.disassemble(address & ~1, sizeBytes, Short.MAX_VALUE);
                StringBuilder sb = new StringBuilder();
                if (emulator.is32Bit()) {
                    sb.append("    \"").append("push {r7, lr}").append("\\n").append('"').append("\n\n");
                } else {
                    sb.append("    \"").append("sub sp, sp, #0x10").append("\\n").append('"').append('\n');
                    sb.append("    \"").append("stp x29, x30, [sp]").append("\\n").append('"').append("\n\n");
                }
                String lastRegWrite = null;
                for (Instruction insn : insns) {
                    RegsAccess regsAccess = insn.regsAccess();
                    short[] regsWrite;
                    if (regsAccess != null && (regsWrite = regsAccess.getRegsWrite()) != null && regsWrite.length == 1) {
                        lastRegWrite = insn.regName(regsWrite[0]);
                    }
                    String asm = "    \"" + insn + "\\n\"";
                    sb.append(String.format("%-50s", asm));
                    sb.append(" // 0x").append(Long.toHexString(insn.getAddress()));
                    sb.append(" offset 0x").append(Long.toHexString(insn.getAddress() - (address & ~1)));
                    sb.append("\n");
                }
                sb.append('\n');
                if (emulator.is32Bit()) {
                    if (lastRegWrite != null && !"r0".equals(lastRegWrite)) {
                        sb.append("    \"").append("mov r0, ").append(lastRegWrite).append("\\n").append('"').append('\n');
                    }
                    sb.append("    \"").append("pop {r7, pc}").append("\\n").append('"');
                } else {
                    if (lastRegWrite != null && !"x0".equals(lastRegWrite) && !"w0".equals(lastRegWrite)) {
                        sb.append("    \"").append("mov ").append(lastRegWrite.startsWith("x") ? "x0" : "w0").append(", ").append(lastRegWrite).append("\\n").append('"').append('\n');
                    }
                    sb.append("    \"").append("ldp x29, x30, [sp]").append("\\n").append('"').append('\n');
                    sb.append("    \"").append("add sp, sp, #0x10").append("\\n").append('"').append('\n');
                    sb.append("    \"").append("ret").append("\\n").append('"');
                }
                try(InputStream inputStream = Objects.requireNonNull(getClass().getResourceAsStream("/cc.c"))) {
                    String template = IOUtils.toString(inputStream, StandardCharsets.UTF_8);
                    if (emulator.is64Bit()) {
                        template = template.replace("$(ARCH_SPEC)", "-m64 -arch arm64");
                    } else {
                        template = template.replace("$(ARCH_SPEC)", "-m32 -arch armv7");
                    }
                    System.err.println(template.replace("$(REPLACE_ASM)", sb.toString()));
                }
            } else {
                System.err.println("Usage: cc (size bytes)");
            }
            return false;
        }
        showHelp(address);
        return false;
    }
    protected void dumpGPBProtobufMsg(String className) {
        throw new UnsupportedOperationException();
    }
    protected void searchClass(String keywords) {
    }
    protected void dumpClass(String className) {
    }
    void showHelp(long address) {}
    /**
     * @return next address
     */
    final long disassemble(Emulator<?> emulator, long address, int size, boolean thumb) {
        long next = 0;
        boolean on = false;
        int maxLength = emulator.getMemory().getMaxLengthLibraryName().length();
        StringBuilder sb = new StringBuilder();
        {
            Module module = findModuleByAddress(emulator, address);
            Symbol symbol = module == null ? null : module.findClosestSymbolByAddress(address, false);
            if (symbol != null && address - symbol.getAddress() <= Unwinder.SYMBOL_SIZE) {
                GccDemangler demangler = DemanglerFactory.createDemangler();
                sb.append(demangler.demangle(symbol.getName())).append(" + 0x").append(Long.toHexString(address - (symbol.getAddress() & ~1))).append("\n");
            }
        }
        long nextAddr = address - size;
        for (CodeHistory history : Arrays.asList(
                new CodeHistory(address - size, size, thumb),
                new CodeHistory(address, size, thumb))
        ) {
            Instruction[] instructions = history.disassemble(emulator);
            if (instructions != null) {
                for (Instruction ins : instructions) {
                    if (ins.getAddress() == address) {
                        sb.append("=> *");
                        on = true;
                    } else {
                        sb.append("    ");
                        if (on) {
                            next = ins.getAddress();
                            on = false;
                        }
                    }
                    sb.append(ARM.assembleDetail(emulator, ins, ins.getAddress(), history.thumb, on, maxLength)).append('\n');
                    nextAddr += ins.getBytes().length;
                }
            }
        }
        Instruction[] insns = emulator.disassemble(nextAddr, 4 * 15, 15);
        if (insns != null) {
            for (Instruction ins : insns) {
                if (nextAddr == address) {
                    sb.append("=> *");
                    on = true;
                } else {
                    sb.append("    ");
                    if (on) {
                        next = nextAddr;
                        on = false;
                    }
                }
                sb.append(ARM.assembleDetail(emulator, ins, nextAddr, thumb, on, maxLength)).append('\n');
                nextAddr += ins.getSize();
            }
        }
        System.out.println(sb);
        if (on) {
            next = nextAddr;
        }
        if (thumb) {
            next |= 1;
        }
        return next;
    }
    @Override
    public final void disassembleBlock(Emulator<?> emulator, long address, boolean thumb) {
        StringBuilder sb = new StringBuilder();
        {
            Module module = findModuleByAddress(emulator, address);
            Symbol symbol = module == null ? null : module.findClosestSymbolByAddress(address, false);
            if (symbol != null && address - symbol.getAddress() <= Unwinder.SYMBOL_SIZE) {
                GccDemangler demangler = DemanglerFactory.createDemangler();
                sb.append(demangler.demangle(symbol.getName())).append(" + 0x").append(Long.toHexString(address - (symbol.getAddress() & ~1))).append("\n");
            }
        }
        long nextAddr = address;
        UnidbgPointer pointer = UnidbgPointer.pointer(emulator, address);
        assert pointer != null;
        byte[] code = pointer.getByteArray(0, 4 * 10);
        Instruction[] insns = emulator.disassemble(nextAddr, code, thumb, 0);
        for (Instruction ins : insns) {
            sb.append("    ");
            sb.append(ARM.assembleDetail(emulator, ins, nextAddr, thumb, false, emulator.getMemory().getMaxLengthLibraryName().length())).append('\n');
            nextAddr += ins.getSize();
        }
        System.out.println(sb);
    }
    public static Module findModuleByAddress(Emulator<?> emulator, long address) {
        Memory memory = emulator.getMemory();
        Module module = memory.findModuleByAddress(address);
        if (module == null) {
            MemRegion region = emulator.getSvcMemory().findRegion(address);
            if (region != null) {
                String name = region.getName();
                int maxLength = memory.getMaxLengthLibraryName().length();
                if (name.length() > maxLength) {
                    name = name.substring(name.length() - maxLength);
                }
                module = new Module(name, region.begin, region.end - region.begin, Collections.emptyMap(), Collections.emptyList(), null) {
                    @Override
                    public Number callFunction(Emulator<?> emulator, long offset, Object... args) {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public Symbol findSymbolByName(String name, boolean withDependencies) {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public Symbol findClosestSymbolByAddress(long address, boolean fast) {
                        return null;
                    }
                    @Override
                    public int callEntry(Emulator<?> emulator, String... args) {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public String getPath() {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public void registerSymbol(String symbolName, long address) {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public int virtualMemoryAddressToFileOffset(long offset) {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        }
        return module;
    }
    @Override
    public final void brk(UnidbgPointer pc, int svcNumber) {
        if (pc != null) {
            removeBreakPoint(pc.peer);
        }
        debug();
    }
    @Override
    public void close() {
    }
}
package com.github.unidbg;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.memory.MemRegion;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.spi.InitFunctionListener;
import com.github.unidbg.spi.LibraryFile;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
public abstract class Module {
    public final String name;
    public final long base;
    public final long size;
    private final LibraryFile libraryFile;
    protected final Map<String, Module> neededLibraries;
    private final List<MemRegion> regions;
    public Module(String name, long base, long size, Map<String, Module> neededLibraries, List<MemRegion> regions, LibraryFile libraryFile) {
        this.name = name;
        this.base = base;
        this.size = size;
        this.neededLibraries = neededLibraries;
        this.regions = regions;
        this.libraryFile = libraryFile;
    }
    public long getFileSize() {
        return libraryFile == null ? 0 : libraryFile.getFileSize();
    }
    public long getBaseHeader() {
        return base;
    }
    public final List<MemRegion> getRegions() {
        return Collections.unmodifiableList(regions);
    }
    public abstract Number callFunction(Emulator<?> emulator, long offset, Object... args);
    public final Number callFunction(Emulator<?> emulator, String symbolName, Object... args) {
        Symbol symbol = findSymbolByName(symbolName, false);
        if (symbol == null) {
            throw new IllegalStateException("find symbol failed: " + symbolName);
        }
        if (symbol.isUndef()) {
            throw new IllegalStateException(symbolName + " is NOT defined");
        }
        return symbol.call(emulator, args);
    }
    public final Symbol findSymbolByName(String name) {
        return findSymbolByName(name, true);
    }
    public abstract Symbol findSymbolByName(String name, boolean withDependencies);
    public abstract Symbol findClosestSymbolByAddress(long address, boolean fast);
    protected final Symbol findDependencySymbolByName(String name) {
        for (Module module : neededLibraries.values()) {
            Symbol symbol = module.findSymbolByName(name, true);
            if (symbol != null) {
                return symbol;
            }
        }
        return null;
    }
    private int referenceCount;
    public void addReferenceCount() {
        referenceCount++;
    }
    public int decrementReferenceCount() {
        return --referenceCount;
    }
    private boolean forceCallInit;
    public boolean isForceCallInit() {
        return forceCallInit;
    }
    @SuppressWarnings("unused")
    public void setForceCallInit() {
        this.forceCallInit = true;
    }
    public final void unload(Backend backend) {
        for (MemRegion region : regions) {
            backend.mem_unmap(region.begin, region.end - region.begin);
        }
    }
    public Collection<Module> getNeededLibraries() {
        return neededLibraries.values();
    }
    public Module getDependencyModule(String name) {
        return neededLibraries.get(name);
    }
    protected long entryPoint;
    public void setEntryPoint(long entryPoint) {
        this.entryPoint = entryPoint;
    }
    public abstract int callEntry(Emulator<?> emulator, String... args);
    private UnidbgPointer pathPointer;
    public abstract String getPath();
    /**
     * 注册符号
     * @param symbolName 符号名称
     * @param address 符号的内存地址
     */
    public abstract void registerSymbol(String symbolName, long address);
    public final UnidbgPointer createPathMemory(SvcMemory svcMemory) {
        if (this.pathPointer == null) {
            byte[] bytes = getPath().getBytes(StandardCharsets.UTF_8);
            byte[] path = Arrays.copyOf(bytes, bytes.length + 1);
            this.pathPointer = svcMemory.allocate(path.length, "Module.path: " + getPath());
            this.pathPointer.write(0, path, 0, path.length);
        }
        return this.pathPointer;
    }
    public static Number emulateFunction(Emulator<?> emulator, long address, Object... args) {
        List<Number> list = new ArrayList<>(args.length);
        for (Object arg : args) {
            if (arg instanceof String) {
                list.add(new StringNumber((String) arg));
            } else if(arg instanceof byte[]) {
                list.add(new ByteArrayNumber((byte[]) arg));
            } else if (arg instanceof PointerArg) {
                PointerArg pointerArg = (PointerArg) arg;
                list.add(new PointerNumber((UnidbgPointer) pointerArg.getPointer()));
            } else if (arg instanceof Number) {
                list.add((Number) arg);
            } else if(arg == null) {
                list.add(new PointerNumber(null)); // null
            } else {
                throw new IllegalStateException("Unsupported arg: " + arg);
            }
        }
        return emulator.eFunc(address, list.toArray(new Number[0]));
    }
    public boolean isVirtual() {
        return false;
    }
    /**
     * 返回-1表示找不到对应文件的偏移
     * @param offset 内存偏移
     */
    public abstract int virtualMemoryAddressToFileOffset(long offset);
    protected InitFunctionListener initFunctionListener;
    public void setInitFunctionListener(InitFunctionListener initFunctionListener) {
        this.initFunctionListener = initFunctionListener;
    }
}
package com.github.unidbg.spi;
import com.github.unidbg.LibraryResolver;
import com.github.unidbg.Module;
import com.github.unidbg.ModuleListener;
import com.github.unidbg.Symbol;
import com.github.unidbg.hook.HookListener;
import com.github.unidbg.pointer.UnidbgPointer;
import java.io.File;
import java.util.Collection;
import java.util.Map;
@SuppressWarnings("unused")
public interface Loader {
    void setLibraryResolver(LibraryResolver libraryResolver);
    void disableCallInitFunction();
    void setCallInitFunction(boolean callInit);
    Module load(File elfFile);
    Module load(File elfFile, boolean forceCallInit);
    Module load(LibraryFile libraryFile);
    Module load(LibraryFile libraryFile, boolean forceCallInit);
    Module findModuleByAddress(long address);
    Module findModule(String name);
    Module dlopen(String filename);
    Module dlopen(String filename, boolean calInit);
    boolean dlclose(long handle);
    Symbol dlsym(long handle, String symbol);
    void addModuleListener(ModuleListener listener);
    void addHookListener(HookListener listener);
    Collection<Module> getLoadedModules();
    String getMaxLengthLibraryName();
    long getMaxSizeOfLibrary();
    /**
     * 加载虚拟模块
     */
    Module loadVirtualModule(String name, final Map<String, UnidbgPointer> symbols);
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
import com.github.unidbg.arm.backend.BackendException;
import com.github.unidbg.pointer.UnidbgPointer;
import com.sun.jna.Pointer;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;
class MemoryCommand implements GdbStubCommand {
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        try {
            int divider = command.indexOf(",");
            long address = Long.parseLong(command.substring(1, divider), 16);
            Pointer pointer = UnidbgPointer.pointer(emulator, address);
            if (pointer == null) {
                stub.makePacketAndSend("E01");
                return true;
            }
            if (command.startsWith("m")) {
                int len = Integer.parseInt(command.substring(divider + 1), 16);
                final String resp = Hex.encodeHexString(pointer.getByteArray(0, len)).toUpperCase();
                stub.makePacketAndSend(resp);
                return true;
            } else {
                int dividerForValue = command.indexOf(":");
                int len = Integer.parseInt(command.substring(divider + 1, dividerForValue), 16);
                byte[] val = Hex.decodeHex(command.substring(dividerForValue + 1).toCharArray());
                pointer.write(0, val, 0, len);
                stub.makePacketAndSend("OK");
                return true;
            }
        } catch (BackendException e) {
            stub.makePacketAndSend("E01");
            return true;
        } catch (DecoderException e) {
            throw new IllegalStateException("process memory command failed: " + command, e);
        }
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
class SetThreadCommand implements GdbStubCommand {
    private static final Logger log = LoggerFactory.getLogger(SetThreadCommand.class);
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        char type = command.charAt(1);
        int thread = Integer.parseInt(command.substring(2), 16);
        if (log.isDebugEnabled()) {
            log.debug("Set thread type={}, thread={}", type, thread);
        }
        switch (type) {
            case 'c':
            case 'g':
                stub.makePacketAndSend("OK");
                break;
            default:
                stub.makePacketAndSend("E22");
                break;
        }
        return true;
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
class ContinueCommand implements GdbStubCommand {
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        stub.resumeRun();
        stub.send("+");
        return true;
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
import com.github.unidbg.arm.backend.Backend;
import unicorn.ArmConst;
class RegisterCommand implements GdbStubCommand {
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        Backend backend = emulator.getBackend();
        int reg;
        if (command.startsWith("p")) {
            reg = Integer.parseInt(command.substring(1), 16);
            long val = readRegister(backend, stub, reg);
            if (emulator.is32Bit()) {
                stub.makePacketAndSend(String.format("%08x", Integer.reverseBytes((int) (val & 0xffffffffL))));
            } else {
                stub.makePacketAndSend(String.format("%016x", Long.reverseBytes(val)));
            }
        } else {
            reg = Integer.parseInt(command.substring(1, command.indexOf('=')), 16);
            long val = Long.parseLong(command.substring(command.indexOf('=') +  1), 16);
            writeRegister(emulator, stub, reg, val);
            stub.makePacketAndSend("OK");
        }
        return true;
    }
    private long readRegister(Backend backend, GdbStub stub, int reg) {
        final int index;
        if (reg >= 0 && reg < stub.registers.length) {
            index = stub.registers[reg];
        } else if(reg == 0x18) { // for arm32
            index = ArmConst.UC_ARM_REG_FP;
        } else if(reg == 0x19) { // for arm32
            index = ArmConst.UC_ARM_REG_CPSR;
        } else {
            index = -1;
        }
        if (index != -1) {
            return backend.reg_read(index).longValue();
        } else {
            return 0;
        }
    }
    private void writeRegister(Emulator<?> emulator, GdbStub stub, int reg, long val) {
        Backend backend = emulator.getBackend();
        if (reg >= 0 && reg < stub.registers.length) {
            if (emulator.is32Bit()) {
                backend.reg_write(stub.registers[reg], (int) (val & 0xffffffffL));
            } else {
                backend.reg_write(stub.registers[reg], val);
            }
        } else if (reg == 0x19) { // for arm32
            backend.reg_write(ArmConst.UC_ARM_REG_CPSR, Integer.reverseBytes((int) (val & 0xffffffffL)));
        }
    }
}
package com.github.unidbg.debugger;
import com.alibaba.fastjson.util.IOUtils;
import com.github.unidbg.Emulator;
import com.github.unidbg.arm.AbstractARMDebugger;
import com.github.unidbg.utils.Inspector;
import keystone.Keystone;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.Semaphore;
public abstract class AbstractDebugServer extends AbstractARMDebugger implements DebugServer {
    private static final Logger log = LoggerFactory.getLogger(AbstractDebugServer.class);
    private final List<ByteBuffer> pendingWrites;
    public AbstractDebugServer(Emulator<?> emulator) {
        super(emulator);
        pendingWrites = new LinkedList<>();
        input = ByteBuffer.allocate(PACKET_SIZE);
        setSingleStep(1); // break at attach
        Thread thread = new Thread(this, "dbgserver");
        thread.start();
    }
    private Selector selector;
    private ServerSocketChannel serverSocketChannel;
    private SocketChannel socketChannel;
    private final ByteBuffer input;
    private boolean serverShutdown, closeConnection;
    private boolean serverRunning;
    protected final boolean isDebuggerConnected() {
        return socketChannel != null;
    }
    @Override
    public final void run() {
        runServer();
    }
    private void runServer() {
        selector = null;
        serverSocketChannel = null;
        socketChannel = null;
        try {
            serverSocketChannel = ServerSocketChannel.open();
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.socket().bind(new InetSocketAddress(DEFAULT_PORT));
            selector = Selector.open();
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
        } catch(IOException ex) {
            throw new IllegalStateException(ex);
        }
        serverShutdown = false;
        serverRunning = true;
        System.err.println("Start " + this + " server on port: " + DEFAULT_PORT);
        onServerStart();
        while(serverRunning) {
            try {
                int count = selector.select(50);
                if (count <= 0) {
                    if (!isDebuggerConnected() && System.in.available() > 0) {
                        String line = new Scanner(System.in).nextLine();
                        if ("c".equals(line)) {
                            serverRunning = false;
                            break;
                        } else {
                            System.out.println("c: continue");
                        }
                    }
                    continue;
                }
                Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();
                while (selectedKeys.hasNext()) {
                    SelectionKey key = selectedKeys.next();
                    if (key.isValid()) {
                        if (key.isAcceptable()) {
                            onSelectAccept(key);
                        }
                        if (key.isReadable()) {
                            onSelectRead(key);
                        }
                        if (key.isWritable()) {
                            onSelectWrite(key);
                        }
                    }
                    selectedKeys.remove();
                }
                processInput(input);
            } catch(Throwable e) {
                if (log.isDebugEnabled()) {
                    log.debug("run server ex", e);
                }
            }
        }
        com.alibaba.fastjson.util.IOUtils.close(serverSocketChannel);
        serverSocketChannel = null;
        com.alibaba.fastjson.util.IOUtils.close(selector);
        selector = null;
        closeSocketChannel();
        resumeRun();
    }
    protected abstract void onServerStart();
    protected abstract void processInput(ByteBuffer input);
    private void enableNewConnections(boolean enable) {
        if (serverSocketChannel == null) {
            return;
        }
        SelectionKey key = serverSocketChannel.keyFor(selector);
        key.interestOps(enable ? SelectionKey.OP_ACCEPT : 0);
    }
    private void onSelectAccept(SelectionKey key) throws IOException {
        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();
        SocketChannel sc = ssc.accept();
        if (sc != null) {
            closeConnection = false;
            pendingWrites.clear();
            input.clear();
            sc.configureBlocking(false);
            sc.register(key.selector(), SelectionKey.OP_READ);
            socketChannel = sc;
            enableNewConnections(false);
            onDebuggerConnected();
        }
    }
    protected abstract void onDebuggerConnected();
    private void onSelectWrite(SelectionKey key) throws IOException {
        SocketChannel sc = (SocketChannel) key.channel();
        if (pendingWrites.isEmpty() && closeConnection) {
            closeSocketChannel();
            return;
        }
        while(!pendingWrites.isEmpty()) {
            ByteBuffer bb = pendingWrites.get(0);
            try {
                sc.write(bb);
            } catch(IOException ex) {
                closeSocketChannel();
                throw ex;
            }
            if (bb.remaining() > 0) {
                break;
            }
            pendingWrites.remove(0);
        }
        if (pendingWrites.isEmpty() && !closeConnection) {
            enableWrites(false);
        }
    }
    private void onSelectRead(SelectionKey key) {
        SocketChannel sc = (SocketChannel) key.channel();
        int numRead;
        try {
            numRead = sc.read(input);
        } catch(IOException ex) {
            numRead = -1;
        }
        if (numRead == -1) {
            closeSocketChannel();
        }
    }
    private void closeSocketChannel() {
        if (socketChannel == null) {
            return;
        }
        SelectionKey key = socketChannel.keyFor(selector);
        if (key != null) key.cancel();
        IOUtils.close(socketChannel);
        socketChannel = null;
        if (!serverShutdown) {
            enableNewConnections(true);
        } else {
            serverRunning = false;
        }
    }
    private void enableWrites(boolean enable) {
        if (socketChannel == null) {
            return;
        }
        SelectionKey key = socketChannel.keyFor(selector);
        key.interestOps(enable ? SelectionKey.OP_WRITE : SelectionKey.OP_READ);
    }
    protected final void sendData(byte[] data) {
        if (log.isDebugEnabled()) {
            log.debug(Inspector.inspectString(data, "sendData"));
        }
        ByteBuffer bb = ByteBuffer.wrap(data);
        pendingWrites.add(bb);
        enableWrites(true);
    }
    private Semaphore semaphore;
    @Override
    protected final void loop(Emulator<?> emulator, long address, int size, DebugRunnable<?> runnable) throws Exception {
        if (address <= 0) {
            return;
        }
        semaphore = new Semaphore(0);
        onHitBreakPoint(emulator, address);
        semaphore.acquire();
    }
    @Override
    public <T> T run(DebugRunnable<T> runnable) {
        throw new UnsupportedOperationException();
    }
    protected abstract void onHitBreakPoint(Emulator<?> emulator, long address);
    public final void resumeRun() {
        if (semaphore != null) {
            semaphore.release();
        }
    }
    public final void singleStep() {
        setSingleStep(1);
        resumeRun();
    }
    @Override
    public final void close() {
        super.close();
        if (onDebuggerExit()) {
            shutdownServer();
        }
    }
    protected abstract boolean onDebuggerExit();
    public final void shutdownServer() {
        serverShutdown = true;
        closeConnection = true;
        enableWrites(true);
    }
    public final void detachServer() {
        closeConnection = true;
        enableWrites(true);
    }
    @Override
    protected Keystone createKeystone(boolean isThumb) {
        throw new UnsupportedOperationException();
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
class StepCommand implements GdbStubCommand {
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        stub.singleStep();
        stub.makePacketAndSend("OK");
        return true;
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
class LastSignalCommand implements GdbStubCommand {
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        stub.makePacketAndSend("S" + GdbStub.SIGTRAP);
        return true;
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
class EnableExtendedModeCommand implements GdbStubCommand {
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        stub.makePacketAndSend("OK");
        return true;
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
import com.github.unidbg.arm.ARM;
import com.github.unidbg.arm.backend.Backend;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
class RegistersCommand implements GdbStubCommand {
    private static final Logger log = LoggerFactory.getLogger(RegistersCommand.class);
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        Backend backend = emulator.getBackend();
        if (log.isDebugEnabled()) {
            if (emulator.is32Bit()) {
                ARM.showRegs(emulator, null);
            } else {
                ARM.showRegs64(emulator, null);
            }
        }
        if (command.startsWith("g")) {
            StringBuilder sb = new StringBuilder();
            for(int i = 0; i < stub.registers.length; i++) {
                long value = backend.reg_read(stub.registers[i]).longValue();
                if (emulator.is32Bit()) {
                    String hex = String.format("%08x", Integer.reverseBytes((int) (value & 0xffffffffL)));
                    sb.append(hex);
                } else {
                    String hex = String.format("%016x", Long.reverseBytes(value));
                    sb.append(hex);
                }
            }
            stub.makePacketAndSend(sb.toString());
        } else {
            for (int i = 0; i < stub.registers.length; i++) {
                if (emulator.is32Bit()) {
                    long value = Long.parseLong(command.substring(1 + 8 * i, 9 + 8 * i), 16);
                    backend.reg_write(stub.registers[i], Integer.reverseBytes((int) (value & 0xffffffffL)));
                } else {
                    long value = Long.parseLong(command.substring(1 + 16 * i, 9 + 16 * i), 16);
                    backend.reg_write(stub.registers[i], Long.reverseBytes(value));
                }
            }
        }
        return true;
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
class KillCommand implements GdbStubCommand {
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        stub.send("+");
        stub.shutdownServer();
        System.exit(9);
        return true;
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
import com.github.unidbg.debugger.DebugServer;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.nio.charset.StandardCharsets;
class QueryCommand implements GdbStubCommand {
    private static final Logger log = LoggerFactory.getLogger(QueryCommand.class);
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        if (command.startsWith("qSupported")) {
            stub.makePacketAndSend("PacketSize=" + DebugServer.PACKET_SIZE + ";vContSupported+;multiprocess-;xmlRegisters=arm");
            return true;
        }
        if (command.startsWith("qAttached")) {
            stub.makePacketAndSend("1");
            return true;
        }
        if (command.startsWith("qC")) {
            stub.makePacketAndSend("QC1");
            return true;
        }
        if (command.startsWith("qfThreadInfo")) {
            stub.makePacketAndSend("m01");
            return true;
        }
        if (command.startsWith("qsThreadInfo")) {
            stub.makePacketAndSend("l");
            return true;
        }
        if (command.startsWith("qRcmd,")) {
            try {
                String cmd = new String(Hex.decodeHex(command.substring(6).toCharArray()), StandardCharsets.UTF_8);
                if (log.isDebugEnabled()) {
                    log.debug("qRcmd={}", cmd);
                }
                stub.makePacketAndSend("E01");
                return true;
            } catch (DecoderException e) {
                throw new IllegalStateException(e);
            }
        }
        return false;
    }
}
package com.github.unidbg.debugger.gdb;
import com.github.unidbg.Emulator;
class BreakpointCommand implements GdbStubCommand {
    @Override
    public boolean processCommand(Emulator<?> emulator, GdbStub stub, String command) {
        int divider = command.substring(3).indexOf(",");
        long address = Long.parseLong(command.substring(3, divider + 3), 16);
        /*
         * 2: 16-bit Thumb mode breakpoint.
         * 3: 32-bit Thumb mode (Thumb-2) breakpoint.
         * 4: 32-bit ARM mode breakpoint.
         */
        int type = Integer.parseInt(command.substring(divider + 4));
        boolean isThumb = type == 2 || type == 3;
        if (isThumb) {
            address |= 1;
        }
        if (command.startsWith("Z0")) {
            stub.addBreakPoint(address);
        } else {
            stub.removeBreakPoint(address);
        }
        stub.makePacketAndSend("OK");
        return true;
    }
}