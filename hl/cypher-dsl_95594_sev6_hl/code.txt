/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import org.apiguardian.api.API;
import org.apiguardian.api.API.Status;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.utils.Assertions;
import org.neo4j.cypherdsl.core.utils.LRUCache;
/**
 * A symbolic name to identify nodes, relationships and aliased items.
 * <p>
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/SchemaName.html">SchemaName</a>
 * <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/SymbolicName.html">SymbolicName</a>
 * <p>
 * While OpenCypher extends the <a href="https://unicode.org/reports/tr31/">UNICODE IDENTIFIER AND PATTERN SYNTAX</a>
 * with some characters, this DSL uses the same identifier Java itself uses for simplicity and until otherwise needed.
 *
 * @author Michael J. Simons
 * @author Andreas Berger
 * @since 1.0
 */
@API(status = Status.EXPERIMENTAL, since = "1.0")
public final class SymbolicName implements Expression, IdentifiableElement {
	private static final Map<String, SymbolicName> CACHE = Collections.synchronizedMap(new LRUCache<>(32));
	static SymbolicName of(String name) {
		Assertions.hasText(name, "Name must not be empty.");
		return CACHE.computeIfAbsent(name, SymbolicName::new);
	}
	static SymbolicName unsafe(String name) {
		Assertions.hasText(name, "Name must not be empty.");
		return new SymbolicName(name);
	}
	static SymbolicName unresolved() {
		return new SymbolicName(null);
	}
	private final String value;
	private SymbolicName(String value) {
		this.value = value;
	}
	/**
	 * @return The value of this symbolic name.
	 */
	@API(status = INTERNAL)
	public String getValue() {
		return value;
	}
	/**
	 * Creates a new symbolic name by concatenating {@code otherValue} to this names value.
	 * Returns {@literal this} if {@code otherValue} is empty.
	 *
	 * @param otherValue The value to concat.
	 * @return A new symbolic name
	 */
	@NotNull @Contract(pure = true)
	public SymbolicName concat(String otherValue) {
		Assertions.notNull(otherValue, "Value to concat must not be null.");
		if (otherValue.isEmpty()) {
			return this;
		}
		return SymbolicName.of(this.value + otherValue);
	}
	/**
	 * A list will never be a valid entry for a map projection, so this convenient method prevents trying to create one
	 * from a list of objects. It will delegate to {@link #project(Object...)} with the content of the list.
	 *
	 * @param entries A list of entries for the projection
	 * @return A map projection.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public MapProjection project(List<Object> entries) {
		return project(entries.toArray());
	}
	/**
	 * Creates a map projection based on this node. The node needs a symbolic name for this to work.
	 * <p>
	 * Entries of type {@code String} in {@code entries} followed by an {@link Expression} will be treated as map keys
	 * pointing to the expression in the projection, {@code String} entries alone will be treated as property lookups on the node.
	 *
	 * @param entries A list of entries for the projection
	 * @return A map projection.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public MapProjection project(Object... entries) {
		return MapProjection.create(this, entries);
	}
	@Override
	public String toString() {
		return value != null ? RendererBridge.render(this) : "Unresolved SymbolicName";
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		// Unresolved values are only equal to themselves
		if (value == null) {
			return false;
		}
		SymbolicName that = (SymbolicName) o;
		return value.equals(that.value);
	}
	@Override
	public int hashCode() {
		return value == null ? super.hashCode() : Objects.hash(value);
	}
	@NotNull
	@Override
	public Expression asExpression() {
		return this;
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * An expression can be used in many places, i.e. in return statements, pattern elements etc.
 *
 * @author Michael J. Simons
 * @author Aakash Sorathiya
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface Expression extends Visitable, PropertyAccessor {
	/**
	 * Creates a condition that checks whether this {@code expression} includes all elements of {@code rhs}.
	 *
	 * @param rhs The other collection to compare to, must evaluate into a list during runtime.
	 * @return A new condition
	 * @since 2022.7.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition includesAll(Expression rhs) {
		return Conditions.includesAll(this, rhs);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} includes any element of {@code rhs}.
	 *
	 * @param rhs The other collection to compare to, must evaluate into a list during runtime.
	 * @return A new condition
	 * @since 2022.7.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition includesAny(Expression rhs) {
		return Conditions.includesAny(this, rhs);
	}
	/**
	 * Creates an expression with an alias. This expression does not track which or how many aliases have been created.
	 *
	 * @param alias The alias to use
	 * @return An aliased expression.
	 */
	@NotNull @Contract(pure = true)
	default AliasedExpression as(String alias) {
		Assertions.hasText(alias, "The alias may not be null or empty.");
		return new AliasedExpression(this, alias);
	}
	/**
	 * This creates a {@literal size(e)} expression from this expression. The Cypher output will semantically only be valid
	 * when this refers to a list
	 * (see <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size">size(list)</a>)
	 * or when the expression is a string
	 * (see <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-string">size() applied to string</a>).
	 * <p>
	 * Any other expression will produce Cypher that is either deprecated in Neo4j &ge; 4.4 or not supported at all.
	 *
	 * @return The size of this expression (Either the number of items in a list or the number of characters in a string expression).
	 * @since 2022.1.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Expression size() {
		return Functions.size(this);
	}
	/**
	 * Takes the {@link #size()} expresssions and compares it for equality with the parameter {@code expectedSize}. The
	 * same restrictions as with {@link #size()} apply.
	 * @param expectedSize The expected size
	 * @return A condition
	 * @see #size()
	 * @since 2022.1.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition hasSize(Expression expectedSize) {
		return Functions.size(this).isEqualTo(expectedSize);
	}
	/**
	 * Reuse an existing symbolic name to alias this expression
	 *
	 * @param alias A symbolic name
	 * @return An aliased expression.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	default AliasedExpression as(SymbolicName alias) {
		Assertions.notNull(alias, "The alias may not be null.");
		return as(alias.getValue());
	}
	/**
	 * Transform this expression into a condition.
	 *
	 * @return this expression as a condition. Will return the same instance if it is already a condition.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	default Condition asCondition() {
		return this instanceof Condition condition ? condition : new ExpressionCondition(this);
	}
	/**
	 * Creates a {@code lhs = rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isEqualTo(Expression rhs) {
		return Conditions.isEqualTo(this, rhs);
	}
	/**
	 * An alias for {@link #isEqualTo(Expression)}.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	default Condition eq(Expression rhs) {
		return isEqualTo(rhs);
	}
	/**
	 * Creates a {@code lhs <> rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNotEqualTo(Expression rhs) {
		return Conditions.isNotEqualTo(this, rhs);
	}
	/**
	 * An alias for {@link #isNotEqualTo(Expression)}.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	default Condition ne(Expression rhs) {
		return isNotEqualTo(rhs);
	}
	/**
	 * Creates a {@code lhs < rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition lt(Expression rhs) {
		return Conditions.lt(this, rhs);
	}
	/**
	 * Creates a {@code lhs <= rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition lte(Expression rhs) {
		return Conditions.lte(this, rhs);
	}
	/**
	 * Creates a {@code lhs > rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition gt(Expression rhs) {
		return Conditions.gt(this, rhs);
	}
	/**
	 * Creates a {@code lhs >= rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition gte(Expression rhs) {
		return Conditions.gte(this, rhs);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} is {@literal true}.
	 *
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isTrue() {
		return Conditions.isEqualTo(this, Cypher.literalTrue());
	}
	/**
	 * Creates a condition that checks whether this {@code expression} is {@literal false}.
	 *
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isFalse() {
		return Conditions.isEqualTo(this, Cypher.literalFalse());
	}
	/**
	 * Creates a condition that checks whether this {@code expression} matches that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition matches(Expression expression) {
		return Conditions.matches(this, expression);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} matches the given {@code pattern}.
	 *
	 * @param pattern The pattern to match
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition matches(String pattern) {
		return Conditions.matches(this, Cypher.literalOf(pattern));
	}
	/**
	 * Creates a condition that checks whether this {@code expression} starts with that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition startsWith(Expression expression) {
		return Conditions.startsWith(this, expression);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} contains that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition contains(Expression expression) {
		return Conditions.contains(this, expression);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} ends with that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition endsWith(Expression expression) {
		return Conditions.endsWith(this, expression);
	}
	/**
	 * Creates an expression concatenating two string or list expressions.
	 *
	 * @param expression The expression to concat to this expression.
	 * @return A new expression.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation concat(Expression expression) {
		return Operations.concat(this, expression);
	}
	/**
	 * Creates a {@code +} operation of this (the augend) and the {@code addend}.
	 *
	 * @param addend The addend
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation add(Expression addend) {
		return Operations.add(this, addend);
	}
	/**
	 * Creates a {@code -} operation of this (the minuend) and the {@code subtrahend}.
	 *
	 * @param subtrahend The subtrahend
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation subtract(Expression subtrahend) {
		return Operations.subtract(this, subtrahend);
	}
	/**
	 * Creates a {@code *} operation of this (the multiplier) and the {@code multiplicand}.
	 *
	 * @param multiplicand The multiplicand
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation multiply(Expression multiplicand) {
		return Operations.multiply(this, multiplicand);
	}
	/**
	 * Creates a {@code /} operation of this (the divisor) and the {@code dividend}.
	 *
	 * @param dividend The dividend
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation divide(Expression dividend) {
		return Operations.divide(this, dividend);
	}
	/**
	 * Returns the remainder of this value and the {@code dividend}.
	 *
	 * @param dividend The dividend
	 * @return A new operation.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation remainder(Expression dividend) {
		return Operations.remainder(this, dividend);
	}
	/**
	 * Returns the power of n of this value.
	 *
	 * @param n power to raise this {@code Expression} to.
	 * @return A new operation.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation pow(Expression n) {
		return Operations.pow(this, n);
	}
	/**
	 * Creates a {@code IS NULL} operation for this {@code expression}.
	 * The expression does not track the condition created here.
	 *
	 * @return A condition based on this expression that evaluates to true when this expression is null.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNull() {
		return Conditions.isNull(this);
	}
	/**
	 * Creates a {@code IS NOT NULL} operation for this {@code expression}.
	 * The expression does not track the condition created here.
	 *
	 * @return A condition based on this expression that evaluates to true when this expression is not null.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNotNull() {
		return Conditions.isNotNull(this);
	}
	/**
	 * Creates a {@code IN} operation for this expression and that {@code expression}.
	 * The expression does not track the condition created here.
	 *
	 * @param haystack The expression to search for this expression
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	default Condition in(Expression haystack) {
		return Comparison.create(this, Operator.IN, haystack);
	}
	/**
	 * Creates a condition that evaluates to true if this expression is empty.
	 *
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isEmpty() {
		return Functions.size(this).isEqualTo(Cypher.literalOf(0L));
	}
	/**
	 * The property does not track the sort items created here.
	 *
	 * @return A sort item for this property in descending order
	 */
	@NotNull @Contract(pure = true)
	default SortItem descending() {
		return SortItem.create(this, SortItem.Direction.DESC);
	}
	/**
	 * The property does not track the sort items created here.
	 *
	 * @return A sort item for this property in ascending order
	 */
	@NotNull @Contract(pure = true)
	default SortItem ascending() {
		return SortItem.create(this, SortItem.Direction.ASC);
	}
	/**
	 * Creates a new sort item with the given direction.
	 *
	 * @param direction The direction to sort
	 * @return A new sort item.
	 * @since 2021.4.1
	 */
	@NotNull @Contract(pure = true)
	default SortItem sorted(SortItem.Direction direction) {
		return SortItem.create(this, direction);
	}
	@Override @NotNull
	default Property property(String... names) {
		return InternalPropertyImpl.create(this, names);
	}
	/**
	 * Creates a new {@link Property} associated with this property container. This property can be used as a lookup in
	 * other expressions. It does not add a value to the property.
	 * <p>
	 * The new {@link Property} object is a dynamic lookup, based on the {@code expression} passed to this method. The
	 * expression can be example another property, a function result or a Cypher parameter. A property defined in such a way will
	 * render as {@code p[expression]}.
	 * <p>
	 * Note: The property container does not track property creation and there is no possibility to enumerate all
	 * properties that have been created for this property container.
	 *
	 * @param lookup the expression that is evaluated to lookup this property.
	 * @return a new {@link Property} associated with this named container
	 * @since 2024.1.0
	 */
	@Override @NotNull
	default Property property(@NotNull Expression lookup) {
		return InternalPropertyImpl.create(this, lookup);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
/**
 * This interface represents an element that can be for example an identifiable part of the {@code WITH} clause.
 * It has been introduced to circumvent the absence of union types in Java
 * and to avoid an overload of {@link StatementBuilder#with(String...)} or other expressions with an {@code Object...}
 * parameter. This type here allows passing {@link Named named things}. {@link AliasedExpression aliased expression},
 * {@link SymbolicName symbolic names} into a pipeline.
 * <p>
 * There should be no need to implement this on your own.
 *
 * @author Michael J. Simons
 * @soundtrack Fatoni &amp; Edgar Wasser - Delirium
 * @since 2021.2.2
 */
public sealed interface IdentifiableElement permits AliasedExpression, Asterisk, Named, Property, SymbolicName {
	/**
	 * Transform this element into an expression
	 *
	 * @return this element as an expression. Will return the same instance if it is already an expression.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	Expression asExpression();
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * Represents a map projection as described <a href="https://medium.com/neo4j/loading-graph-data-for-an-object-graph-mapper-or-graphql-5103b1a8b66e">here</a>.
 *
 * @author Michael J. Simons
 */
@API(status = STABLE, since = "1.0")
public final class MapProjection implements Expression {
	private final SymbolicName name;
	private final MapExpression map;
	/**
	 * Create a new map projection with the given, mixed content
	 * @param name The symbolic name of this project
	 * @param content The projected content
	 * @return A new map projection
	 * @since 2021.2.3
	 */
	@API(status = INTERNAL, since = "2023.9.0")
	public static MapProjection create(SymbolicName name, Object... content) {
		return new MapProjection(name, MapExpression.withEntries(createNewContent(false, content)));
	}
	/**
	 * Create a new map projection with the given, mixed content
	 * @param name The symbolic name of this project
	 * @param content The projected content
	 * @return A new map projection
	 * @since 2024.1.1
	 */
	@API(status = INTERNAL, since = "2024.1.1")
	public static MapProjection sorted(SymbolicName name, Object... content) {
		return new MapProjection(name, MapExpression.withEntries(createNewContent(true, content)));
	}
	MapProjection(SymbolicName name, MapExpression map) {
		this.name = name;
		this.map = map;
	}
	/**
	 * Adds additional content. The current projection is left unchanged and a new one is returned.
	 *
	 * @param content The additional content for a new projection.
	 * @return A new map projection with additional content.
	 */
	@NotNull @Contract(pure = true)
	public MapProjection and(Object... content) {
		return new MapProjection(this.name, this.map.addEntries(createNewContent(false, content)));
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.name.accept(visitor);
		this.map.accept(visitor);
		visitor.leave(this);
	}
	@SuppressWarnings("deprecation")
	private static Object contentAt(Object[] content, int i) {
		Object currentObject = content[i];
		if (currentObject instanceof Expression expression) {
			return Expressions.nameOrExpression(expression);
		} else if (currentObject instanceof Named named) {
			return named.getSymbolicName().map(Object.class::cast).orElse(currentObject);
		}
		return currentObject;
	}
	private static List<Expression> createNewContent(boolean sort, Object... content) {
		final List<Expression> newContent = new ArrayList<>(content.length);
		final Set<String> knownKeys = new HashSet<>();
		String lastKey = null;
		Expression lastExpression = null;
		int i = 0;
		while (i < content.length) {
			Object next;
			if (i + 1 >= content.length) {
				next = null;
			} else {
				next = contentAt(content, i + 1);
			}
			Object current = contentAt(content, i);
			if (current instanceof String stringValue) {
				if (next instanceof Expression expression) {
					lastKey = stringValue;
					lastExpression = expression;
					i += 2;
				} else {
					lastExpression = PropertyLookup.forName((String) current);
					i += 1;
				}
			} else if (current instanceof Expression expression) {
				lastExpression = expression;
				i += 1;
			}
			if (lastExpression instanceof Asterisk) {
				lastExpression = PropertyLookup.wildcard();
			}
			if (lastKey != null) {
				Assertions.isTrue(!knownKeys.contains(lastKey), "Duplicate key '" + lastKey + "'");
				newContent.add(KeyValueMapEntry.create(lastKey, lastExpression));
				knownKeys.add(lastKey);
			} else if (lastExpression instanceof SymbolicName || lastExpression instanceof PropertyLookup) {
				newContent.add(lastExpression);
			} else if (lastExpression instanceof Property property) {
				List<PropertyLookup> names = property.getNames();
				if (names.size() > 1) {
					throw new IllegalArgumentException("Cannot project nested properties!");
				}
				newContent.addAll(names);
			} else if (lastExpression instanceof AliasedExpression aliasedExpression) {
				newContent.add(KeyValueMapEntry.create(aliasedExpression.getAlias(), aliasedExpression));
			} else if (lastExpression instanceof KeyValueMapEntry) {
				newContent.add(lastExpression);
			} else if (lastExpression == null) {
				throw new IllegalArgumentException("Could not determine an expression from the given content!");
			} else {
				throw new IllegalArgumentException(lastExpression + " of type " + lastExpression.getClass()
					+ " cannot be used with an implicit name as map entry.");
			}
			lastKey = null;
			lastExpression = null;
		}
		if (sort) {
			newContent.sort((o1, o2) -> {
				if (o1 instanceof KeyValueMapEntry kvm1 && o2 instanceof KeyValueMapEntry kvm2) {
					return kvm1.getKey().compareTo(kvm2.getKey());
				} else if (o1 instanceof PropertyLookup pl1 && o2 instanceof PropertyLookup pl2) {
					if (pl1 == PropertyLookup.wildcard()) {
						return -1;
					} else if (pl2 == PropertyLookup.wildcard()) {
						return 1;
					}
					return pl1.getPropertyKeyName().getValue().compareTo(pl2.getPropertyKeyName().getValue());
				} else if (o1 instanceof PropertyLookup) {
					return 1;
				}
				return -1;
			});
		}
		return newContent;
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * A dedicated map expression.<p>
 * Most of the comparison methods on this expression will not result in a sensible query fragment.
 * A {@link MapExpression} is be useful as a concrete parameter to functions or as properties on {@link Node nodes}
 * or {@link Relationship relationships}.
 *
 * @author Michael J. Simons
 * @soundtrack Rammstein - RAMMSTEIN
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class MapExpression extends TypedSubtree<Expression> implements Expression {
	static MapExpression create(Map<String, Object> map) {
		Object[] args = new Object[map.size() * 2];
		int i = 0;
		for (Map.Entry<String, Object> entry : map.entrySet()) {
			Object value = entry.getValue();
			args[i++] = entry.getKey();
			args[i++] = value instanceof Expression ? value : Cypher.literalOf(value);
		}
		return create(false, args);
	}
	static MapExpression create(boolean sort, Object... input) {
		Assertions.isTrue(input.length % 2 == 0, "Need an even number of input parameters");
		List<Expression> newContent = new ArrayList<>(input.length / 2);
		Set<String> knownKeys = new HashSet<>();
		for (int i = 0; i < input.length; i += 2) {
			Object keyCandidate = input[i];
			String key;
			if (keyCandidate instanceof String v) {
				key = v;
			} else if (keyCandidate instanceof Property property) {
				List<PropertyLookup> names = property.getNames();
				if (names.size() != 1) {
					throw new IllegalArgumentException("Nested properties are not supported in a map expression");
				}
				key = names.get(0).getPropertyKeyName().getValue();
			} else {
				throw new IllegalStateException("Key needs to be of type String or Property.");
			}
			Assertions.isInstanceOf(Expression.class, input[i + 1], "Value needs to be of type Expression.");
			Assertions.isTrue(!knownKeys.contains(input[i]), "Duplicate key '" + input[i] + "'");
			final KeyValueMapEntry entry = KeyValueMapEntry.create(key, (Expression) input[i + 1]);
			newContent.add(entry);
			knownKeys.add(entry.getKey());
		}
		if (sort) {
			newContent.sort(Comparator.comparing(o -> ((KeyValueMapEntry) o).getKey()));
		}
		return new MapExpression(newContent);
	}
	static MapExpression withEntries(List<Expression> entries) {
		return new MapExpression(entries);
	}
	private MapExpression(List<Expression> children) {
		super(children);
	}
	MapExpression addEntries(List<Expression> entries) {
		List<Expression> newContent = new ArrayList<>(super.children.size() + entries.size());
		newContent.addAll(super.children);
		newContent.addAll(entries);
		return new MapExpression(newContent);
	}
	@Override
	@SuppressWarnings("deprecation")
	protected Visitable prepareVisit(Expression child) {
		return Expressions.nameOrExpression(child);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.ast;
/**
 * Interface for implementations that accepts {@link Visitor visitors}.
 *
 * @author Michael Simons
 * @see Visitor
 * @since 1.0
 */
public interface Visitable {
	/**
	 * A helper method that presents the {@code visitor} to the {@code visitable} if the visitable is not null.
	 * Not meant to be overridden.
	 *
	 * @param visitable The visitable to visit if not null
	 * @param visitor   The visitor to use
	 */
	static void visitIfNotNull(Visitable visitable, Visitor visitor) {
		if (visitable != null) {
			visitable.accept(visitor);
		}
	}
	/**
	 * Accept a {@link Visitor} visiting this {@link Visitable} and its nested {@link Visitable}s if applicable.
	 *
	 * @param visitor the visitor to notify, must not be {@literal null}.
	 */
	default void accept(Visitor visitor) {
		visitor.enter(this);
		visitor.leave(this);
	}
	/**
	 * Most {@link Visitable visitables} will render themselves into a Cypher fragment preceded with the actual classname.
	 * The representation however is not cached - in contrast to the ones for full statements. Using {@code toString}
	 * is recommended for debugging purposes mainly, and not for production use.
	 * <p>
	 * The concrete classname has been prepended to help debugging and actually to discourage using fragments to build queries
	 * without explicitly rendering them, either as statement or going through the renderer on purpose.
	 *
	 * @return A string representation of this visitable formatted as {@literal Classname{cypher=value}}
	 */
	String toString();
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
/**
 * A property. A property might belong to a container such as a {@link Node} or {@link Relationship}, but it's not uncommon
 * to extract single properties from maps or from various datatypes such as a duration returned from stored procedures.
 * The container can be retrieved via {@link #getContainer()} in case the property belongs to a node or relationship.
 * <p>
 * A property has always a reference to the name of the object it was extracted from.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public non-sealed interface Property extends Expression, IdentifiableElement {
	/**
	 * Returns the concatenated names of the property or the external reference (See {@link #referencedAs(String)}) if set.
	 *
	 * @return A name to reference the property under in an external application
	 */
	@API(status = STABLE, since = "2021.1.0")
	@NotNull @Contract(pure = true)
	String getName();
	/**
	 * @return The actual property being looked up. The order matters, so this will return a list, not a collection.
	 */
	@NotNull @Contract(pure = true)
	List<PropertyLookup> getNames();
	/**
	 * @return The container "owning" this property.
	 */
	@Contract(pure = true)
	Named getContainer();
	/**
	 * @return A reference to the container owning this property
	 */
	@API(status = INTERNAL, since = "2023.1.0")
	@NotNull
	@Contract(pure = true)
	default Expression getContainerReference() {
		if (getContainer() == null) {
			throw new UnsupportedOperationException();
		}
		return getContainer().getRequiredSymbolicName();
	}
	/**
	 * Creates a new property with an external reference.
	 *
	 * @param newReference An arbitrary, external reference
	 * @return A new property
	 */
	@API(status = STABLE, since = "2021.1.0")
	@NotNull @Contract(pure = true)
	Property referencedAs(String newReference);
	/**
	 * Creates an {@link Operation} setting this property to a new value. The property does not track the operations
	 * created with this method.
	 *
	 * @param expression expression describing the new value
	 * @return A new operation.
	 */
	@NotNull @Contract(pure = true)
	Operation to(Expression expression);
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.Arrays;
import java.util.List;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.Statement.UnionQuery;
/**
 * Utility methods for dealing with expressions.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
final class Expressions {
	/**
	 * Creates a {@literal COUNT} sub-query expressions from at least one pattern.
	 *
	 * @param requiredPattern One pattern is required
	 * @param patternElement  Optional pattern
	 * @return The immutable {@link CountExpression}
	 * @since 2023.0.0
	 */
	@NotNull
	static CountExpression count(PatternElement requiredPattern, PatternElement... patternElement) {
		return CountExpression.count(Pattern.of(requiredPattern, patternElement));
	}
	/**
	 * Creates a {@literal COUNT} with an inner {@literal UNION} sub-query.
	 *
	 * @param union The union that will be the source of the {@literal COUNT} sub-query
	 * @return The immutable {@link CountExpression}
	 * @since 2023.0.0
	 */
	@NotNull
	static CountExpression count(UnionQuery union) {
		return CountExpression.count(union);
	}
	/**
	 * Creates a {@literal COUNT} from a full statement, including  its filters and conditions. The statement may or may
	 * not have a {@literal RETURN} clause. It must however not contain any updates. While it would render syntactically
	 * correct Cypher, Neo4j does not support updates inside counting sub-queries.
	 *
	 * @param statement The statement to be passed to {@code count{}}
	 * @param imports   Optional imports to be used in the statement (will be imported with {@literal WITH})
	 * @return A counting sub-query.
	 * @since 2023.1.0
	 */
	@NotNull
	static CountExpression count(Statement statement, IdentifiableElement... imports) {
		return CountExpression.count(statement, imports);
	}
	/**
	 * Creates a {@literal COUNT} expression based on a list of pattern
	 *
	 * @param pattern the list of patterns that shall be counted
	 * @param where   an optional where-clause
	 * @return a count expression.
	 * @since 2023.9.0
	 */
	static CountExpression count(List<PatternElement> pattern, @Nullable Where where) {
		return CountExpression.count(pattern, where);
	}
	/**
	 * Start building a new sub-query expression by importing variables into the scope with a {@literal WITH} clause.
	 *
	 * @param identifiableElements The identifiable elements to import
	 * @return A builder for creating the concrete sub-query
	 * @since 2023.0.0
	 */
	static SubqueryExpressionBuilder with(IdentifiableElement... identifiableElements) {
		var returnItems = new ExpressionList(
			Arrays.stream(identifiableElements).map(IdentifiableElement::asExpression).toList());
		var with = new With(false, returnItems, null, null, null, null);
		return new SubqueryExpressionBuilder() {
			@Override @NotNull
			public CountExpression count(PatternElement requiredPattern, PatternElement... patternElement) {
				return CountExpression.count(with, Pattern.of(requiredPattern, patternElement));
			}
			@Override @NotNull
			public CountExpression count(UnionQuery union) {
				return CountExpression.count(with, union);
			}
			@Override
			public CollectExpression collect(Statement statement) {
				return CollectExpression.collect(with, statement);
			}
		};
	}
	/**
	 * Creates a {@literal COLLECT} subquery from a statement, including  its filters and conditions. The statement must
	 * return exactly one column. It must however not contain any updates. While it would render syntactically
	 * correct Cypher, Neo4j does not support updates inside counting sub-queries.
	 *
	 * @param statement the statement to be passed to {@code COLLECT{}}
	 * @return a collecting sub-query.
	 * @since 2023.8.0
	 */
	@NotNull
	static Expression collect(Statement statement) {
		if (!statement.doesReturnOrYield()) {
			throw new IllegalArgumentException(
				"The final RETURN clause in a subquery used with COLLECT is mandatory and the RETURN clause must return exactly one column.");
		}
		return CollectExpression.collect(statement);
	}
	/**
	 * @param expression Possibly named with a non-empty symbolic name.
	 * @param <T>        The type being returned
	 * @return The name of the expression if the expression is named or the expression itself.
	 */
	static <T extends Expression> Expression nameOrExpression(T expression) {
		if (expression instanceof Named named) {
			return named.getSymbolicName().map(Expression.class::cast).orElse(expression);
		} else {
			return expression;
		}
	}
	static SymbolicName[] createSymbolicNames(String[] variables) {
		return Arrays.stream(variables).map(SymbolicName::of).toArray(SymbolicName[]::new);
	}
	static SymbolicName[] createSymbolicNames(Named[] variables) {
		return Arrays.stream(variables).map(Named::getRequiredSymbolicName)
			.toArray(SymbolicName[]::new);
	}
	static String format(Expression expression) {
		if (expression instanceof Named named) {
			return named.getRequiredSymbolicName().getValue();
		} else if (expression instanceof AliasedExpression aliasedExpression) {
			return aliasedExpression.getAlias();
		} else if (expression instanceof SymbolicName symbolicName) {
			return symbolicName.getValue();
		} else if (expression instanceof Property) {
			StringBuilder ref = new StringBuilder();
			expression.accept(segment -> {
				if (segment instanceof SymbolicName symbolicName) {
					if (!ref.isEmpty()) {
						ref.append(".");
					}
					ref.append(symbolicName.getValue());
				}
			});
			return ref.toString();
		}
		throw new IllegalArgumentException("Cannot format expression " + expression.toString());
	}
	private Expressions() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.lang.reflect.Array;
import java.net.URI;
import java.time.Duration;
import java.time.Period;
import java.time.temporal.TemporalAccessor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.ResourceBundle;
import java.util.TimeZone;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ListComprehension.OngoingDefinitionWithVariable;
import org.neo4j.cypherdsl.core.Literal.UnsupportedLiteralException;
import org.neo4j.cypherdsl.core.PatternComprehension.OngoingDefinitionWithPattern;
import org.neo4j.cypherdsl.core.Statement.SingleQuery;
import org.neo4j.cypherdsl.core.Statement.UnionQuery;
import org.neo4j.cypherdsl.core.Statement.UseStatement;
import org.neo4j.cypherdsl.core.StatementBuilder.OngoingStandaloneCallWithoutArguments;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * The main entry point into the Cypher DSL.
 * The Cypher Builder API is intended for framework usage to produce Cypher statements required for database operations.
 *
 * @author Michael J. Simons
 * @author Gerrit Meier
 * @author Andreas Berger
 * @author Ali Ince
 * @since 1.0
 */
@SuppressWarnings("unused") @API(status = STABLE, since = "1.0")
public final class Cypher {
	static final ResourceBundle MESSAGES = ResourceBundle.getBundle("org.neo4j.cypherdsl.core.messages");
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, String... additionalLabels) {
		return new InternalNodeImpl(primaryLabel, additionalLabels);
	}
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, List<String> additionalLabels) {
		return new InternalNodeImpl(primaryLabel, additionalLabels.toArray(new String[] {}));
	}
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional. This method also takes a map of properties. This allows the returned node object to be used in a
	 * {@code MATCH} or {@code MERGE} statement.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param properties       The properties expected to exist on the node.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, MapExpression properties, String... additionalLabels) {
		return new InternalNodeImpl(null, primaryLabel, properties, additionalLabels);
	}
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional. This method also takes a map of properties. This allows the returned node object to be used in a
	 * {@code MATCH} or {@code MERGE} statement.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param properties       The properties expected to exist on the node.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, MapExpression properties, Collection<String> additionalLabels) {
		return node(primaryLabel, properties, additionalLabels.toArray(new String[] {}));
	}
	/**
	 * @return A node matching any node.
	 */
	@NotNull @Contract(pure = true)
	public static Node anyNode() {
		return new InternalNodeImpl();
	}
	/**
	 * @param labelExpression required expression
	 * @return A node matching a label expression
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	public static Node node(LabelExpression labelExpression) {
		return new InternalNodeImpl(Objects.requireNonNull(labelExpression), null);
	}
	/**
	 * @return The {@code *} wildcard literal.
	 */
	@NotNull @Contract(pure = true)
	public static Asterisk asterisk() {
		return Asterisk.INSTANCE;
	}
	/**
	 * @param symbolicName The new symbolic name
	 * @return A node matching any node with the symbolic the given {@code symbolicName}.
	 */
	@NotNull @Contract(pure = true)
	public static Node anyNode(String symbolicName) {
		return new InternalNodeImpl().named(symbolicName);
	}
	/**
	 * @param symbolicName The new symbolic name
	 * @return A node matching any node with the symbolic the given {@code symbolicName}.
	 */
	@NotNull @Contract(pure = true)
	public static Node anyNode(SymbolicName symbolicName) {
		return new InternalNodeImpl().named(symbolicName);
	}
	/**
	 * Dereferences a property for a symbolic name, most likely pointing to a property container like a node or a relationship.
	 *
	 * @param containerName The symbolic name of a property container
	 * @param names         The names of the properties to dereference. More than one name does create a nested property
	 *                      like {@code containerName.name1.name2}.
	 * @return A new property
	 */
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, String... names) {
		return property(name(containerName), names);
	}
	/**
	 * Dereferences a property for a symbolic name, most likely pointing to a property container like a node or a relationship.
	 *
	 * @param containerName The symbolic name of a property container
	 * @param names         The names of the properties to dereference. More than one name does create a nested property
	 *                      like {@code containerName.name1.name2}.
	 * @return A new property
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, Collection<String> names) {
		return property(name(containerName), names.toArray(new String[] {}));
	}
	/**
	 * Dereferences a property on a arbitrary expression.
	 *
	 * @param expression The expression that describes some sort of accessible map
	 * @param names      The names of the properties to dereference. More than one name does create a nested property
	 *                   like {@code expression.name1.name2}.
	 * @return A new property.
	 */
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, String... names) {
		return InternalPropertyImpl.create(expression, names);
	}
	/**
	 * Dereferences a property on a arbitrary expression.
	 *
	 * @param expression The expression that describes some sort of accessible map
	 * @param names      The names of the properties to dereference. More than one name does create a nested property
	 *                   like {@code expression.name1.name2}.
	 * @return A new property.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, Collection<String> names) {
		return property(expression, names.toArray(new String[] {}));
	}
	/**
	 * Creates a dynamic lookup of a property for a symbolic name, most likely pointing to a property container like a
	 * node or a relationship. A dynamic property will be rendered as {@code p[expression]}.
	 *
	 * @param containerName The symbolic name of a property container
	 * @param lookup        An expression to use as a dynamic lookup for properties of the container with the given name
	 * @return A new property
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, Expression lookup) {
		return property(name(containerName), lookup);
	}
	/**
	 * Creates a dynamic lookup of a property on a arbitrary expression. A dynamic property will be rendered as
	 * {@code p[expression]}.
	 *
	 * @param expression The expression that describes some sort of accessible map
	 * @param lookup     An expression to use as a dynamic lookup for properties of the container the expression resolved to
	 * @return A new property.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, Expression lookup) {
		return InternalPropertyImpl.create(expression, lookup);
	}
	/**
	 * Starts defining a named path by indicating a name.
	 *
	 * @param name The name of the new path
	 * @return An ongoing definition of a named path
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingDefinitionWithName path(String name) {
		return NamedPath.named(name);
	}
	/**
	 * Starts defining a named path by indicating a name.
	 *
	 * @param name The name of the new path
	 * @return An ongoing definition of a named path
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingDefinitionWithName path(SymbolicName name) {
		return NamedPath.named(name);
	}
	/**
	 * Starts defining a named path defined by the {@code shortestPath} between a relationship by indicating a name.
	 *
	 * @param name The name of the new shortestPath path
	 * @return An ongoing definition of a named path
	 * @since 1.1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingShortestPathDefinitionWithName shortestPath(String name) {
		return NamedPath.named(name, BuiltInFunctions.Scalars.SHORTEST_PATH);
	}
	/**
	 * Starts defining a named path defined by the {@code shortestPath} between a relationship by indicating a name.
	 *
	 * @param name The name of the new shortestPath path
	 * @return An ongoing definition of a named path
	 * @since 1.1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingShortestPathDefinitionWithName shortestPath(SymbolicName name) {
		return NamedPath.named(name, BuiltInFunctions.Scalars.SHORTEST_PATH);
	}
	/**
	 * Creates a new symbolic name.
	 *
	 * @param value The value of the symbolic name
	 * @return A new symbolic name
	 */
	@NotNull @Contract(pure = true)
	public static SymbolicName name(String value) {
		return SymbolicName.of(value);
	}
	/**
	 * Creates a new parameter placeholder. Existing $-signs will be removed.
	 *
	 * @param name The name of the parameter, must not be null
	 * @return The new parameter
	 */
	@NotNull @Contract(pure = true)
	public static Parameter<Object> parameter(String name) {
		return Parameter.create(name);
	}
	/**
	 * Creates a new parameter with the given {@code name} and a value bound to it.
	 * The value can be retrieved from the final statement build.
	 *
	 * @param name  The name of the parameter, must not be null
	 * @param value The value of the parameter.
	 * @param <T>   Type of the new parameter
	 * @return The new parameter
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public static <T> Parameter<T> parameter(String name, T value) {
		return Parameter.create(name, value);
	}
	/**
	 * Creates a new anonymous parameter with a value bound to it. The value can be retrieved from the final statement build.
	 * The name will be available as soon as the statement has been rendered.
	 *
	 * @param value The value of the parameter.
	 * @param <T>   Type of the new parameter
	 * @return The new parameter
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static <T> Parameter<T> anonParameter(T value) {
		return Parameter.anon(value);
	}
	/**
	 * Prepares an optional match statement.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere optionalMatch(PatternElement... pattern) {
		return Statement.builder().optionalMatch(pattern);
	}
	/**
	 * Prepares an optional match statement.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere optionalMatch(
		Collection<? extends PatternElement> pattern) {
		return optionalMatch(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(PatternElement... pattern) {
		return Statement.builder().match(pattern);
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(Collection<? extends PatternElement> pattern) {
		return match(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param optional A flag whether the {@code MATCH} clause includes the {@code OPTIONAL} keyword.
	 * @param pattern  The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2020.1.3
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(boolean optional, PatternElement... pattern) {
		return Statement.builder().match(optional, pattern);
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param optional A flag whether the {@code MATCH} clause includes the {@code OPTIONAL} keyword.
	 * @param pattern  The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(boolean optional,
		Collection<? extends PatternElement> pattern) {
		return match(optional, pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement based on a {@code CREATE} clause.
	 *
	 * @param pattern The patterns to create
	 * @return An ongoing {@code CREATE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUpdate create(PatternElement... pattern) {
		return Statement.builder().create(pattern);
	}
	/**
	 * Starts building a statement based on a {@code CREATE} clause.
	 *
	 * @param pattern The patterns to create
	 * @return An ongoing {@code CREATE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUpdate create(Collection<? extends PatternElement> pattern) {
		return create(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts a statement with a leading {@code WITH}. Those are useful for passing on lists of various type that
	 * can be unwound later on etc. A leading {@code WITH} obviously cannot be used with patterns and needs its
	 * arguments to have an alias.
	 *
	 * @param variables One ore more variables.
	 * @return An ongoing with clause.
	 * @since 2020.1.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(String... variables) {
		return Statement.builder().with(variables);
	}
	/**
	 * Starts a statement with a leading {@code WITH}. Those are useful for passing on lists of various type that
	 * can be unwound later on etc. A leading {@code WITH} cannot be used with patterns obviously and needs its
	 * arguments to have an alias.
	 *
	 * @param elements One ore more variables.
	 * @return An ongoing with clause.
	 * @since 2020.1.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(IdentifiableElement... elements) {
		return Statement.builder().with(elements);
	}
	/**
	 * Start building a new sub-query expression by importing variables into the scope with a {@literal WITH} clause.
	 *
	 * @param identifiableElements The identifiable elements to import
	 * @return A builder for creating the concrete sub-query
	 * @since 2023.9.0
	 */
	public static SubqueryExpressionBuilder subqueryWith(String... identifiableElements) {
		return subqueryWith(Arrays.stream(identifiableElements).map(SymbolicName::of).toArray(SymbolicName[]::new));
	}
	/**
	 * Start building a new sub-query expression by importing variables into the scope with a {@literal WITH} clause.
	 *
	 * @param identifiableElements The identifiable elements to import
	 * @return A builder for creating the concrete sub-query
	 * @since 2023.9.0
	 */
	public static SubqueryExpressionBuilder subqueryWith(IdentifiableElement... identifiableElements) {
		return Expressions.with(identifiableElements);
	}
	/**
	 * Starts a statement with a leading {@code WITH}. Those are useful for passing on lists of various type that
	 * can be unwound later on etc. A leading {@code WITH} cannot be used with patterns obviously and needs its
	 * arguments to have an alias.
	 * <p>
	 * This method takes both aliased and non-aliased expression. The later will produce only valid Cypher when used in
	 * combination with a correlated subquery via {@link Cypher#call(Statement)}.
	 *
	 * @param elements One ore more expressions.
	 * @return An ongoing with clause.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(
		Collection<IdentifiableElement> elements) {
		return Statement.builder().with(elements);
	}
	/**
	 * Starts building a statement based on a {@code MERGE} clause.
	 *
	 * @param pattern The patterns to merge
	 * @return An ongoing {@code MERGE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingMerge merge(PatternElement... pattern) {
		return Statement.builder().merge(pattern);
	}
	/**
	 * Starts building a statement based on a {@code MERGE} clause.
	 *
	 * @param pattern The patterns to merge
	 * @return An ongoing {@code MERGE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingMerge merge(Collection<? extends PatternElement> pattern) {
		return merge(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement starting with an {@code UNWIND} clause. The expression needs to be an expression
	 * evaluating to a list, otherwise the query will fail.
	 *
	 * @param expression The expression to unwind
	 * @return An ongoing {@code UNWIND}.
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Expression expression) {
		return Statement.builder().unwind(expression);
	}
	/**
	 * Starts building a statement starting with an {@code UNWIND} clause. The expressions passed will be turned into a
	 * list expression
	 *
	 * @param expressions expressions to unwind
	 * @return a new instance of {@link StatementBuilder.OngoingUnwind}
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Expression... expressions) {
		return Statement.builder().unwind(Cypher.listOf(expressions));
	}
	/**
	 * Starts building a statement starting with an {@code UNWIND} clause. The expressions passed will be turned into a
	 * list expression
	 *
	 * @param expressions expressions to unwind
	 * @return a new instance of {@link StatementBuilder.OngoingUnwind}
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Collection<? extends Expression> expressions) {
		return unwind(expressions.toArray(new Expression[] {}));
	}
	/**
	 * Creates a new {@link SortItem} to be used as part of an {@link Order}.
	 *
	 * @param expression The expression by which things should be sorted
	 * @return A sort item, providing means to specify ascending or descending order
	 */
	@NotNull @Contract(pure = true)
	public static SortItem sort(Expression expression) {
		return SortItem.create(expression, null);
	}
	/**
	 * Creates a new {@link SortItem} to be used as part of an {@link Order}.
	 *
	 * @param expression The expression by which things should be sorted
	 * @param direction  The direction to sort by. Defaults to {@link SortItem.Direction#UNDEFINED}.
	 * @return A sort item
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static SortItem sort(Expression expression, SortItem.Direction direction) {
		return SortItem.create(expression, direction);
	}
	/**
	 * Creates a map of expression from a list of key/value pairs.
	 *
	 * @param keysAndValues A list of key and values. Must be an even number, with alternating {@link String} and {@link Expression}
	 * @return A new map expression.
	 */
	@NotNull @Contract(pure = true)
	public static MapExpression mapOf(Object... keysAndValues) {
		return MapExpression.create(false, keysAndValues);
	}
	/**
	 * Creates an alphabetically sorted map of expression from a list of key/value pairs.
	 *
	 * @param keysAndValues A list of key and values. Must be an even number, with alternating {@link String} and {@link Expression}
	 * @return A new map expression.
	 */
	@NotNull @Contract(pure = true)
	public static MapExpression sortedMapOf(Object... keysAndValues) {
		return MapExpression.create(true, keysAndValues);
	}
	/**
	 * Creates a map of expression from a Java Map.
	 *
	 * @param map A map to be turned into a MapExpression
	 * @return A new map expression.
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static MapExpression asExpression(Map<String, Object> map) {
		return MapExpression.create(map);
	}
	/**
	 * Creates a {@link ListExpression list-expression} from several expressions.
	 *
	 * @param expressions expressions to get combined into a list
	 * @return a new instance of {@link ListExpression}
	 */
	@NotNull @Contract(pure = true)
	public static ListExpression listOf(Expression... expressions) {
		return ListExpression.create(expressions);
	}
	/**
	 * Creates a {@link ListExpression list-expression} from several expressions.
	 *
	 * @param expressions expressions to get combined into a list
	 * @return a new instance of {@link ListExpression}
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static ListExpression listOf(Collection<? extends Expression> expressions) {
		return Cypher.listOf(expressions.toArray(new Expression[0]));
	}
	/**
	 * Creates a new {@link Literal Literal&lt;?&gt;} from the given {@code object}.
	 *
	 * @param object the object to represent.
	 * @param <T>    The type of the literal returned
	 * @return a new {@link Literal Literal&lt;?&gt;}.
	 * @throws UnsupportedLiteralException when the object cannot be represented as a literal
	 */
	@SuppressWarnings("unchecked")
	@NotNull @Contract(pure = true)
	public static <T> Literal<T> literalOf(Object object) {
		if (object == null) {
			return (Literal<T>) NullLiteral.INSTANCE;
		}
		if (object instanceof Literal<?>) {
			return (Literal<T>) object;
		}
		if (object instanceof CharSequence charSequence) {
			return (Literal<T>) new StringLiteral(charSequence);
		}
		if (object instanceof Character) {
			return (Literal<T>) new StringLiteral(String.valueOf(object));
		}
		if (object instanceof Number number) {
			return (Literal<T>) new NumberLiteral(number);
		}
		if (object instanceof TemporalAccessor temporalAccessor) {
			return (Literal<T>) new TemporalLiteral(temporalAccessor);
		}
		if (object instanceof Duration duration) {
			return (Literal<T>) DurationLiteral.of(duration);
		}
		if (object instanceof Period period) {
			return (Literal<T>) PeriodLiteral.of(period);
		}
		if (object instanceof Iterable || object.getClass().isArray()) {
			List<Literal<?>> elements = new ArrayList<>();
			Consumer<Object> handleElement = element -> {
				if (element instanceof Literal) {
					elements.add((Literal<?>) element);
				} else {
					try {
						elements.add(Cypher.literalOf(element));
					} catch (UnsupportedLiteralException e) {
						throw new UnsupportedLiteralException("Unsupported literal type in iterable.", element);
					}
				}
			};
			if (object.getClass().isArray()) {
				for (int i = 0; i < Array.getLength(object); i++) {
					handleElement.accept(Array.get(object, i));
				}
			} else {
				((Iterable<?>) object).forEach(handleElement);
			}
			ListLiteral listLiteral = new ListLiteral(elements);
			return (Literal<T>) listLiteral;
		}
		if (object instanceof Map) {
			Map<String, Literal<?>> map = new LinkedHashMap<>();
			BiConsumer<Object, Object> handleEntry = (key, value) -> {
				if (!(key instanceof CharSequence || key instanceof Character)) {
					throw new UnsupportedLiteralException(
						"Unsupported literal map key (not a string/char type).", key);
				}
				if (value instanceof Literal) {
					map.put(key.toString(), (Literal<?>) value);
				} else {
					try {
						map.put(key.toString(), Cypher.literalOf(value));
					} catch (UnsupportedLiteralException e) {
						throw new UnsupportedLiteralException("Unsupported literal type in map.", value);
					}
				}
			};
			((Map<?, ?>) object).forEach(handleEntry);
			MapLiteral mapLiteral = new MapLiteral(map);
			return (Literal<T>) mapLiteral;
		}
		if (object instanceof Boolean b) {
			return (Literal<T>) BooleanLiteral.of(b);
		}
		throw new UnsupportedLiteralException(object);
	}
	/**
	 * @return The {@literal true} literal.
	 */
	@NotNull @Contract(pure = true)
	public static Literal<Boolean> literalTrue() {
		return BooleanLiteral.TRUE;
	}
	/**
	 * @return The {@literal false} literal.
	 */
	@NotNull @Contract(pure = true)
	public static Literal<Boolean> literalFalse() {
		return BooleanLiteral.FALSE;
	}
	/**
	 * @return The {@literal null} literal.
	 */
	@NotNull @Contract(pure = true)
	public static Literal<Void> literalNull() {
		return NullLiteral.INSTANCE;
	}
	/**
	 * Creates a {@code UNION} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 */
	@NotNull @Contract(pure = true)
	public static UnionQuery union(Statement... statements) {
		return unionImpl(false, statements);
	}
	/**
	 * Creates a {@code UNION} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static UnionQuery union(Collection<Statement> statements) {
		return union(statements.toArray(new Statement[] {}));
	}
	/**
	 * Creates a {@code UNION ALL} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 */
	@NotNull @Contract(pure = true)
	public static Statement unionAll(Statement... statements) {
		return unionImpl(true, statements);
	}
	/**
	 * Creates a {@code UNION ALL} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Statement unionAll(Collection<Statement> statements) {
		return unionAll(statements.toArray(new Statement[] {}));
	}
	/**
	 * A {@literal RETURN} statement without a previous match.
	 *
	 * @param expressions The elements to return
	 * @return A buildable statement
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returning(Expression... expressions) {
		return Statement.builder().returning(expressions);
	}
	/**
	 * A {@literal RETURN} statement without a previous match.
	 *
	 * @param expressions The expressions to return
	 * @return A buildable statement
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returning(Collection<? extends Expression> expressions) {
		return Statement.builder().returning(expressions);
	}
	/**
	 * Creates a list comprehension starting with a {@link Relationship} or a {@link RelationshipChain chain of relationships}.
	 *
	 * @param relationshipPattern The relationship pattern on which the new list comprehension is based on.
	 * @return An ongoing definition.
	 * @since 2020.0.0
	 */
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithPattern listBasedOn(RelationshipPattern relationshipPattern) {
		return PatternComprehension.basedOn(relationshipPattern);
	}
	/**
	 * Creates a list comprehension starting with a {@link NamedPath named path}.
	 *
	 * @param namedPath The named path on which the new list comprehension is based on.
	 * @return An ongoing definition.
	 * @since 2020.1.1
	 */
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithPattern listBasedOn(NamedPath namedPath) {
		return PatternComprehension.basedOn(namedPath);
	}
	/**
	 * Starts defining a {@link ListComprehension list comprehension}.
	 *
	 * @param variable The variable to which each element of the list is assigned.
	 * @return An ongoing definition of a list comprehension
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithVariable listWith(SymbolicName variable) {
		return ListComprehension.with(variable);
	}
	/**
	 * Escapes and quotes the {@code unquotedString} for safe usage in Neo4j-Browser and Shell.
	 *
	 * @param unquotedString An unquoted string
	 * @return A quoted string with special chars escaped.
	 */
	@NotNull @Contract(pure = true)
	public static String quote(String unquotedString) {
		return literalOf(unquotedString).asString();
	}
	/**
	 * @return generic case expression start
	 */
	@NotNull @Contract(pure = true)
	public static Case caseExpression() {
		return Case.create(null);
	}
	/**
	 * @param expression initial expression for the simple case statement
	 * @return simple case expression start
	 */
	@NotNull @Contract(pure = true)
	public static Case caseExpression(@Nullable Expression expression) {
		return Case.create(expression);
	}
	/**
	 * Starts defining a procedure call of the procedure with the given {@literal procedureName}. That
	 * procedure name might be fully qualified - that is, including a namespace - or just a simple name.
	 *
	 * @param procedureName The procedure name of the procedure to call. Might be fully qualified.
	 * @return An ongoing definition of a call
	 */
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(String procedureName) {
		Assertions.hasText(procedureName, "The procedure name must not be null or empty.");
		return call(procedureName.split("\\."));
	}
	/**
	 * Starts defining a procedure call of the procedure with the given qualified name.
	 *
	 * @param namespaceAndProcedure The procedure name of the procedure to call.
	 * @return An ongoing definition of a call
	 */
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(String... namespaceAndProcedure) {
		return Statement.call(namespaceAndProcedure);
	}
	/**
	 * Starts defining a procedure call of the procedure with the given qualified name.
	 *
	 * @param namespaceAndProcedure The procedure name of the procedure to call.
	 * @return An ongoing definition of a call
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(Collection<String> namespaceAndProcedure) {
		return call(namespaceAndProcedure.toArray(new String[] {}));
	}
	/**
	 * Starts building a statement based on one subquery.
	 *
	 * @param subquery The statement representing the subquery
	 * @return A new ongoing read without any further conditions or returns.
	 * @neo4j.version 4.0.0
	 * @see ExposesSubqueryCall#call(Statement)
	 * @since 2020.1.2
	 */
	@Neo4jVersion(minimum = "4.0.0")
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere call(Statement subquery) {
		return Statement.builder().call(subquery);
	}
	/**
	 * Creates a closed range with given boundaries.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subList(Expression targetExpression, Integer start, Integer end) {
		return ListOperator.subList(targetExpression, Cypher.literalOf(start), Cypher.literalOf(end));
	}
	/**
	 * Creates a closed range with given boundaries.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subList(Expression targetExpression, Expression start, Expression end) {
		return ListOperator.subList(targetExpression, start, end);
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListFrom(Expression targetExpression, Integer start) {
		return ListOperator.subListFrom(targetExpression, Cypher.literalOf(start));
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListFrom(Expression targetExpression, Expression start) {
		return ListOperator.subListFrom(targetExpression, start);
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListUntil(Expression targetExpression, Integer end) {
		return ListOperator.subListUntil(targetExpression, Cypher.literalOf(end));
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListUntil(Expression targetExpression, Expression end) {
		return ListOperator.subListUntil(targetExpression, end);
	}
	/**
	 * Creates a single valued range at {@code index}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param index            The index of the range
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static ListOperator valueAt(Expression targetExpression, Integer index) {
		return valueAt(targetExpression, Cypher.literalOf(index));
	}
	/**
	 * Creates a single valued range at {@code index}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param index            The index of the range
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static ListOperator valueAt(Expression targetExpression, Expression index) {
		return ListOperator.valueAt(targetExpression, index);
	}
	/**
	 * Creates an expression from a raw string fragment. No validation is performed on it. If it is used as expression,
	 * you must make sure to define something that works as expression.
	 * <p>
	 * This method expects exactly one placeholder in the form of {@literal $E} for any argument passed with {@code mixedArgs}.
	 * <p>
	 * To use exactly the term {@literal $E} escape it like this: {@literal \$E}
	 *
	 * @param format    A raw Cypher string
	 * @param mixedArgs Args to the Cypher string
	 * @return An expression to reuse with the builder.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	public static Expression raw(String format, Object... mixedArgs) {
		return RawLiteral.create(format, mixedArgs);
	}
	/**
	 * Starts building a statement from a raw Cypher string that might also have arguments as supported through {@link Cypher#raw(String, Object...)}.
	 * Use this method as your own risk and be aware that no checks are done on the Cypher.
	 *
	 * @param rawCypher the raw Cypher statement to call
	 * @param args      optional args that replace placeholders in the {@code rawCypher}
	 * @return Ongoing sub-query definition based on the raw Cypher statement.
	 * @since 2024.2.0
	 */
	public static ExposesSubqueryCall.BuildableSubquery callRawCypher(String rawCypher, Object... args) {
		return Statement.builder().callRawCypher(rawCypher, args);
	}
	/**
	 * Creates a {@code RETURN} clause from a raw Cypher expression created via {@link Cypher#raw(String, Object...)}.
	 * The expression maybe aliased but it must resolve to a raw element
	 *
	 * @param rawExpression Must be a plain raw or an aliased raw expression. To eventually render as valid Cypher, it must
	 *                      contain the {@code RETURN} keyword.
	 * @return A match that can be build now
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returningRaw(Expression rawExpression) {
		return Statement.builder().returningRaw(rawExpression);
	}
	/**
	 * The foreign adapter factory. Can only be used when `com.querydsl:querydsl-core` is on the class path. The object
	 * won't be modified after initialisation.
	 */
	@SuppressWarnings("squid:S3077")
	private static volatile ForeignAdapterFactory foreignAdapterFactory;
	/**
	 * Provides access to the foreign DSL adapter. Please make sure you have the necessary runtime dependencies on the class path,
	 * otherwise you will see some kind of {@link ClassNotFoundException} along various classes related to the foreign DSL.
	 *
	 * @param expression The expression that should be adapted
	 * @param <FE>       The type of the expression
	 * @return A foreign adapter
	 * @throws IllegalArgumentException in case the object cannot be adapter
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static <FE> ForeignAdapter<FE> adapt(FE expression) {
		ForeignAdapterFactory initializedForeignAdapterFactory = foreignAdapterFactory;
		if (initializedForeignAdapterFactory == null) {
			synchronized (Cypher.class) {
				initializedForeignAdapterFactory = foreignAdapterFactory;
				if (initializedForeignAdapterFactory == null) {
					foreignAdapterFactory = new ForeignAdapterFactory();
					initializedForeignAdapterFactory = foreignAdapterFactory;
				}
			}
		}
		return initializedForeignAdapterFactory.getAdapterFor(expression);
	}
	/**
	 * Starts building a {@code LOAD CSV} clause by using a periodic commit. The default rate of the database will be used.
	 *
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	public static ExposesLoadCSV usingPeriodicCommit() {
		return usingPeriodicCommit(null);
	}
	/**
	 * Starts building a {@code LOAD CSV} clause by using a periodic commit.
	 *
	 * @param rate The rate to be used. No checks are done on the rate, the database will verify valid values.
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	public static ExposesLoadCSV usingPeriodicCommit(@Nullable Integer rate) {
		return LoadCSVStatementBuilder.usingPeriodicCommit(rate);
	}
	/**
	 * Starts building a {@code LOAD CSV}. No headers are assumed.
	 *
	 * @param from The {@link URI} to load data from. Any uri that is resolvable by the database itself is valid.
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 * @since 2021.2.1
	 */
	public static LoadCSVStatementBuilder.OngoingLoadCSV loadCSV(URI from) {
		return loadCSV(from, false);
	}
	/**
	 * Starts building a {@code LOAD CSV}.
	 *
	 * @param from        The {@link URI} to load data from. Any uri that is resolvable by the database itself is valid.
	 * @param withHeaders Set to {@literal true} if the csv file contains header
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 */
	public static LoadCSVStatementBuilder.OngoingLoadCSV loadCSV(URI from, boolean withHeaders) {
		return LoadCSVStatementBuilder.loadCSV(from, withHeaders);
	}
	private static UnionQuery unionImpl(boolean unionAll, Statement... statements) {
		Assertions.isTrue(statements != null && statements.length >= 2, "At least two statements are required!");
		int i = 0;
		UnionQueryImpl existingUnionQuery = null;
		@SuppressWarnings("squid:S2259") // Really, we asserted it 4 lines above this one. Thank you, sonar.
		boolean isUnionQuery = statements[0] instanceof UnionQueryImpl;
		if (isUnionQuery) {
			existingUnionQuery = (UnionQueryImpl) statements[0];
			Assertions.isTrue(existingUnionQuery.isAll() == unionAll, "Cannot mix union and union all!");
			i = 1;
		}
		List<Statement> listOfQueries = new ArrayList<>();
		do {
			Assertions.isTrue(statements[i] instanceof SingleQuery || statements[i] instanceof ClausesBasedStatement,
				"Can only union single queries!");
			listOfQueries.add(statements[i]);
		} while (++i < statements.length);
		if (existingUnionQuery == null) {
			return UnionQueryImpl.create(unionAll, listOfQueries);
		} else {
			return existingUnionQuery.addAdditionalQueries(listOfQueries);
		}
	}
	/**
	 * Tries to format this expression into something human-readable. Not all expressions are supported
	 *
	 * @param expression An expression to format
	 * @return A human-readable string
	 * @throws IllegalArgumentException When the expression cannot be formatted
	 * @since 2021.3.2
	 */
	@SuppressWarnings("deprecation")
	public static String format(Expression expression) {
		return Expressions.format(expression);
	}
	/**
	 * Decorates the given statement by prepending a static {@literal USE} clause.
	 *
	 * @param target    The target. This might be a single database or a constituent of a composite database. This value
	 *                  will be escaped if necessary. If it contains a {@literal .}, both the first and second part will
	 *                  be escaped individually.
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.0.0
	 */
	public static UseStatement use(String target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Decorates the given statement by prepending a dynamic {@literal USE} clause. A dynamic {@literal USE} clause will
	 * utilize {@code graph.byName} to resolve the target database.
	 *
	 * @param target    A parameter that must resolve to a Cypher string.
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.0.0
	 */
	public static UseStatement use(Parameter<?> target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Decorates the given statement by prepending a dynamic {@literal USE} clause. A dynamic {@literal USE} clause will
	 * utilize {@code graph.byName} to resolve the target database.
	 *
	 * @param target    A string expression
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.0.0
	 */
	public static UseStatement use(StringLiteral target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Decorates the given statement by prepending a dynamic {@literal USE} clause. A dynamic {@literal USE} clause will
	 * utilize {@code graph.byName} to resolve the target database unless {@link Cypher#graphByName(Expression)} has
	 * already been used.
	 *
	 * @param target    The name of a variable pointing to the graph or constituent
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.4.0
	 */
	public static UseStatement use(Expression target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} includes all elements present in {@code rhs}.
	 *
	 * @param lhs Argument that is tested whether it contains all values in {@code rhs} or not
	 * @param rhs The reference collection
	 * @return An "includesAll" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition includesAll(Expression lhs, Expression rhs) {
		return Conditions.includesAll(lhs, rhs);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} includes any element present in {@code rhs}.
	 *
	 * @param lhs Argument that is tested whether it contains any values in {@code rhs} or not
	 * @param rhs The reference collection
	 * @return A "not_includes" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition includesAny(Expression lhs, Expression rhs) {
		return Conditions.includesAny(lhs, rhs);
	}
	/**
	 * @param relationshipPattern The pattern being evaluated in a condition
	 * @return A new condition matching the given pattern
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition matching(RelationshipPattern relationshipPattern) {
		return Conditions.matching(relationshipPattern);
	}
	/**
	 * Creates a condition that matches if the right hand side is a regular expression that matches the the left hand side via
	 * {@code =~}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A "matches" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition matches(Expression lhs, Expression rhs) {
		return Conditions.matches(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if both expressions are equals according to {@code =}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "equals" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isEqualTo(Expression lhs, Expression rhs) {
		return Conditions.isEqualTo(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if both expressions are equals according to {@code <>}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "not equals" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isNotEqualTo(Expression lhs, Expression rhs) {
		return Conditions.isNotEqualTo(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is less than the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "less than" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition lt(Expression lhs, Expression rhs) {
		return Conditions.lt(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is less than or equal the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "less than or equal" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition lte(Expression lhs, Expression rhs) {
		return Conditions.lte(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is greater than or equal the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "greater than or equal" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition gte(Expression lhs, Expression rhs) {
		return Conditions.gte(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is greater than the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "greater than" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition gt(Expression lhs, Expression rhs) {
		return Conditions.gt(lhs, rhs);
	}
	/**
	 * Negates the given condition.
	 *
	 * @param condition The condition to negate. Must not be null.
	 * @return The negated condition.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition not(@NotNull Condition condition) {
		return Conditions.not(condition);
	}
	/**
	 * Negates the given pattern element: The pattern must not matched to be included in the result.
	 *
	 * @param pattern The pattern to negate. Must not be null.
	 * @return A condition that evaluates to true when the pattern does not match.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition not(@NotNull RelationshipPattern pattern) {
		return Conditions.not(pattern);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} starts with the {@code rhs}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition startsWith(Expression lhs, Expression rhs) {
		return Conditions.startsWith(lhs, rhs);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} contains with the {@code rhs}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition contains(Expression lhs, Expression rhs) {
		return Conditions.contains(lhs, rhs);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} ends with the {@code rhs}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition endsWith(Expression lhs, Expression rhs) {
		return Conditions.endsWith(lhs, rhs);
	}
	/**
	 * Creates a placeholder condition which is not rendered in the final statement but is useful while chaining
	 * conditions together.
	 *
	 * @return A placeholder condition.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition noCondition() {
		return Conditions.noCondition();
	}
	/**
	 * Creates a condition that checks whether the {@code expression} is {@literal null}.
	 *
	 * @param expression The expression to check for {@literal null}
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isNull(Expression expression) {
		return Conditions.isNull(expression);
	}
	/**
	 * Creates a condition that checks whether the {@code expression} is not {@literal null}.
	 *
	 * @param expression The expression to check for {@literal null}
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isNotNull(Expression expression) {
		return Conditions.isNotNull(expression);
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code isEmpty()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-isempty">isEmpty</a>.
	 * <p>
	 * The argument {@code e} must refer to an expression that evaluates to a list for {@code isEmpty()} to work
	 *
	 * @param expression An expression referring to a list
	 * @return A function call for {@code isEmpty()} for a list
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isEmpty(Expression expression) {
		return Predicates.isEmpty(expression);
	}
	/**
	 * @return a condition that is always true.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isTrue() {
		return Conditions.isTrue();
	}
	/**
	 * @return a condition that is always false.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isFalse() {
		return Conditions.isFalse();
	}
	/**
	 * @param symbolicName  Reference to the entity that should be checked for labels or types
	 * @param labelsOrTypes the list of labels or types to check for
	 * @return A condition that checks whether a node has a set of given labels or a relationship a set of given types.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition hasLabelsOrType(SymbolicName symbolicName, String... labelsOrTypes) {
		return Conditions.hasLabelsOrType(symbolicName, labelsOrTypes);
	}
	/**
	 * Creates a {@literal COUNT} sub-query expressions from at least one pattern.
	 *
	 * @param requiredPattern One pattern is required
	 * @param patternElement  Optional pattern
	 * @return The immutable {@link CountExpression}
	 * @since 2023.9.0
	 */
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(PatternElement requiredPattern, PatternElement... patternElement) {
		return Expressions.count(requiredPattern, patternElement);
	}
	/**
	 * Creates a {@literal COUNT} with an inner {@literal UNION} sub-query.
	 *
	 * @param union The union that will be the source of the {@literal COUNT} sub-query
	 * @return The immutable {@link CountExpression}
	 * @since 2023.9.0
	 */
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(UnionQuery union) {
		return Expressions.count(union);
	}
	/**
	 * Creates a {@literal COUNT} from a full statement, including  its filters and conditions. The statement may or may
	 * not have a {@literal RETURN} clause. It must however not contain any updates. While it would render syntactically
	 * correct Cypher, Neo4j does not support updates inside counting sub-queries.
	 *
	 * @param statement The statement to be passed to {@code count{}}
	 * @param imports   Optional imports to be used in the statement (will be imported with {@literal WITH})
	 * @return A counting sub-query.
	 * @since 2023.9.0
	 */
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(Statement statement, IdentifiableElement... imports) {
		return Expressions.count(statement, imports);
	}
	/**
	 * Creates a {@literal COUNT} expression based on a list of pattern
	 *
	 * @param pattern the list of patterns that shall be counted
	 * @param where   an optional where-clause
	 * @return a count expression.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static CountExpression count(List<PatternElement> pattern, @Nullable Where where) {
		return Expressions.count(pattern, where);
	}
	/**
	 * Creates a {@literal COLLECT} subquery from a statement, including  its filters and conditions. The statement must
	 * return exactly one column. It must however not contain any updates. While it would render syntactically
	 * correct Cypher, Neo4j does not support updates inside counting sub-queries.
	 *
	 * @param statement the statement to be passed to {@code COLLECT{}}
	 * @return a collecting sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	@NotNull public static Expression collect(Statement statement) {
		return Expressions.collect(statement);
	}
	/**
	 * @param expression Possibly named with a non-empty symbolic name.
	 * @return The name of the expression if the expression is named or the expression itself.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static <T extends Expression> Expression nameOrExpression(T expression) {
		return Expressions.nameOrExpression(expression);
	}
	@SuppressWarnings("deprecation")
	public static SymbolicName[] createSymbolicNames(String[] variables) {
		return Expressions.createSymbolicNames(variables);
	}
	@SuppressWarnings("deprecation")
	public static SymbolicName[] createSymbolicNames(Named[] variables) {
		return Expressions.createSymbolicNames(variables);
	}
	/**
	 * Creates a function invocation for {@code elementId{}}.
	 *
	 * @param node The node for which the element id should be retrieved
	 * @return A function call for {@code elementId()} on a node.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation elementId(
		@NotNull Node node) {
		return Functions.elementId(node);
	}
	/**
	 * Creates a function invocation for {@code elementId{}}.
	 *
	 * @param relationship The relationship for which the element id should be retrieved
	 * @return A function call for {@code elementId()} on a relationship.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation elementId(
		@NotNull Relationship relationship) {
		return Functions.elementId(relationship);
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param node The node which keys should be returned.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Node node) {
		return Functions.keys(node);
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param relationship The relationship which keys should be returned.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Relationship relationship) {
		return Functions.keys(relationship);
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param expression The expressions which keys should be returned. Must resolve to a node, relationship or map.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Expression expression) {
		return Functions.keys(expression);
	}
	/**
	 * Creates a function invocation for {@code labels{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-labels">labels</a>.
	 *
	 * @param node The node for which the labels should be retrieved
	 * @return A function call for {@code labels()} on a node.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation labels(@NotNull Node node) {
		return Functions.labels(node);
	}
	/**
	 * Creates a  function invocation for  {@code labels{}}.  The {@link SymbolicName  symbolic name} {@code  node} must
	 * point to a node. This can't be checked during compile time, so please make sure of that.
	 * <p>
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-labels">labels</a>.
	 *
	 * @param node The node for which the labels should be retrieved
	 * @return A function call for {@code labels()} on a node.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation labels(@NotNull SymbolicName node) {
		return Functions.labels(node);
	}
	/**
	 * Creates a function invocation for {@code type{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-type">type</a>.
	 *
	 * @param relationship The relationship for which the type should be retrieved
	 * @return A function call for {@code type()} on a relationship.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation type(@NotNull Relationship relationship) {
		return Functions.type(relationship);
	}
	/**
	 * Creates a  function invocation for  {@code type{}}. The {@link  SymbolicName symbolic name}  {@code relationship}
	 * must point to a relationship. This can't be checked during compile time, so please make sure of that.
	 * <p>
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-type">type</a>.
	 *
	 * @param relationship The relationship for which the type should be retrieved
	 * @return A function call for {@code type()} on a relationship.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation type(@NotNull SymbolicName relationship) {
		return Functions.type(relationship);
	}
	/**
	 * @param node The named node to be counted
	 * @return A function call for {@code count()} for one named node
	 * @see #count(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation count(@NotNull Node node) {
		return Functions.count(node);
	}
	/**
	 * Creates a function invocation for the {@code count()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count">count</a>.
	 *
	 * @param expression An expression describing the things to count.
	 * @return A function call for {@code count()} for an expression like {@link Cypher#asterisk()} etc.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation count(Expression expression) {
		return Functions.count(expression);
	}
	/**
	 * Creates a function invocation for a {@code count()} function with {@code DISTINCT} added.
	 *
	 * @param node The named node to be counted
	 * @return A function call for {@code count()} for one named node
	 * @see #countDistinct(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation countDistinct(@NotNull Node node) {
		return Functions.countDistinct(node);
	}
	/**
	 * Creates a function invocation for a {@code count()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count">count</a>.
	 *
	 * @param expression An expression describing the things to count.
	 * @return A function call for {@code count()} for an expression like {@link Cypher#asterisk()} etc.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation countDistinct(Expression expression) {
		return Functions.countDistinct(expression);
	}
	/**
	 * Creates a function invocation for {@code properties())} on nodes.
	 *
	 * @param node The node who's properties should be returned.
	 * @return A function call for {@code properties())}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(Node node) {
		return Functions.properties(node);
	}
	/**
	 * Creates a function invocation for {@code properties())} on relationships.
	 *
	 * @param relationship The relationship who's properties should be returned.
	 * @return A function call for {@code properties())}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(Relationship relationship) {
		return Functions.properties(relationship);
	}
	/**
	 * Creates a function invocation for {@code properties())} on maps.
	 *
	 * @param map The map who's properties should be returned.
	 * @return A function call for {@code properties())}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(MapExpression map) {
		return Functions.properties(map);
	}
	/**
	 * Creates a function invocation for the {@code coalesce()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-coalesce">coalesce</a>.
	 *
	 * @param expressions One or more expressions to be coalesced
	 * @return A function call for {@code coalesce}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation coalesce(Expression... expressions) {
		return Functions.coalesce(expressions);
	}
	/**
	 * Creates a function invocation for the {@code left()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-left">left</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @param length     desired length
	 * @return A function call for {@code left()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation left(Expression expression, Expression length) {
		return Functions.left(expression, length);
	}
	/**
	 * Creates a function invocation for the {@code ltrim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-ltrim">ltrim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code ltrim()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ltrim(@NotNull Expression expression) {
		return Functions.ltrim(expression);
	}
	/**
	 * Creates a function invocation for the {@code replace()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-ltrim">replace</a>.
	 *
	 * @param original An expression that returns a string
	 * @param search   An expression that specifies the string to be replaced in {@code original}.
	 * @param replace  An expression that specifies the replacement string.
	 * @return A function call for {@code replace()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation replace(Expression original, Expression search,
		Expression replace) {
		return Functions.replace(original, search, replace);
	}
	/**
	 * Creates a function invocation for the {@code reverse()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-reverse">reverse</a>.
	 *
	 * @param original An expression that returns a string
	 * @return A function call for {@code reverse()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation reverse(@NotNull Expression original) {
		return Functions.reverse(original);
	}
	/**
	 * Creates a function invocation for the {@code right()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-left">right</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @param length     desired length
	 * @return A function call for {@code right()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation right(Expression expression, Expression length) {
		return Functions.right(expression, length);
	}
	/**
	 * Creates a function invocation for the {@code rtrim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-rtrim">rtrim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code rtrim()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation rtrim(@NotNull Expression expression) {
		return Functions.rtrim(expression);
	}
	/**
	 * Creates a function invocation for the {@code substring()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-substring">rtrim</a>.
	 *
	 * @param original An expression resolving to a string
	 * @param start    An expression that returns a positive integer, denoting the position at which the substring will begin.
	 * @param length   An expression that returns a positive integer, denoting how many characters of original will be returned.
	 * @return A function call for {@code substring()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation substring(Expression original, Expression start,
		Expression length) {
		return Functions.substring(original, start, length);
	}
	/**
	 * Creates a function invocation for the {@code toLower()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toLower">toLower</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code toLower()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toLower(@NotNull Expression expression) {
		return Functions.toLower(expression);
	}
	/**
	 * Creates a function invocation for the {@code toUpper()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toUpper">toUpper</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code toLower()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toUpper(@NotNull Expression expression) {
		return Functions.toUpper(expression);
	}
	/**
	 * Creates a function invocation for the {@code trim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-trim">trim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code trim()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation trim(@NotNull Expression expression) {
		return Functions.trim(expression);
	}
	/**
	 * Creates a function invocation for the {@code split()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-split">split</a>.
	 *
	 * @param expression An expression resolving to a string that should be split
	 * @param delimiter  The delimiter on which to split
	 * @return A function call for {@code split()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation split(@NotNull Expression expression,
		@NotNull Expression delimiter) {
		return Functions.split(expression, delimiter);
	}
	/**
	 * Creates a function invocation for the {@code split()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-split">split</a>.
	 *
	 * @param expression An expression resolving to a string that should be split
	 * @param delimiter  The delimiter on which to split
	 * @return A function call for {@code split()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation split(@NotNull Expression expression,
		@NotNull String delimiter) {
		return Functions.split(expression, delimiter);
	}
	/**
	 * Creates a function invocation for the {@code size()} function. {@code size} can be applied to
	 * <ul>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size">a list</a></li>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-string">to a string</a></li>
	 * </ul>
	 *
	 * @param expression The expression who's size is to be returned
	 * @return A function call for {@code size()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation size(Expression expression) {
		return Functions.size(expression);
	}
	/**
	 * Creates a function invocation for the {@code size()} function. {@code size} can be applied to
	 * <ul>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-pattern-expression">to a pattern expression</a></li>
	 * </ul>
	 *
	 * @param pattern The pattern for which {@code size()} should be invoked.
	 * @return A function call for {@code size()} for a pattern
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation size(RelationshipPattern pattern) {
		return Functions.size(pattern);
	}
	/**
	 * Creates a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param expression The expression who's existence is to be evaluated
	 * @return A function call for {@code exists()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation exists(Expression expression) {
		return Functions.exists(expression);
	}
	/**
	 * Creates a function invocation for the {@code distance()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-distance">exists</a>.
	 * Both points need to be in the same coordinate system.
	 *
	 * @param point1 Point 1
	 * @param point2 Point 2
	 * @return A function call for {@code distance()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation distance(@NotNull Expression point1,
		@NotNull Expression point2) {
		return Functions.distance(point1, point2);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 *
	 * @param parameterMap The map of parameters for {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(MapExpression parameterMap) {
		return Functions.point(parameterMap);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 * <p>
	 * This generic expression variant is useful for referencing a point inside a parameter or another map.
	 *
	 * @param expression An expression resolving to a valid map of parameters for {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(Expression expression) {
		return Functions.point(expression);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 *
	 * @param parameter A parameter referencing a {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(Parameter<?> parameter) {
		return Functions.point(parameter);
	}
	/**
	 * Convenience method for creating a 2d cartesian point
	 *
	 * @param x The x coordinate
	 * @param y The y coordinate
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cartesian(double x, double y) {
		return Functions.cartesian(x, y);
	}
	/**
	 * Convenience method for creating a 2d coordinate in the WGS 84 coordinate system
	 *
	 * @param longitude The longitude
	 * @param latitude  The latitude
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation coordinate(double longitude, double latitude) {
		return Functions.coordinate(longitude, latitude);
	}
	/**
	 * Creates a function invocation for the {@code point.withinBBox} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-withinBBox">point.withinBBox</a>.
	 *
	 * @param point      The point to check
	 * @param lowerLeft  The lower left point of the bounding box (south-west coordinate)
	 * @param upperRight The upper right point of the bounding box (north-east coordinate)
	 * @return A function call for {@code point.withinBBox}
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static FunctionInvocation withinBBox(Expression point, Expression lowerLeft, Expression upperRight) {
		return Functions.withinBBox(point, lowerLeft, upperRight);
	}
	/**
	 * Creates a function invocation for the {@code avg()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg">avg</a>.
	 *
	 * @param expression The things to average
	 * @return A function call for {@code avg()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation avg(Expression expression) {
		return Functions.avg(expression);
	}
	/**
	 * Creates a function invocation for the {@code avg()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg">avg</a>.
	 *
	 * @param expression The things to average
	 * @return A function call for {@code avg()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation avgDistinct(Expression expression) {
		return Functions.avgDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function.
	 *
	 * @param variable The named thing to collect
	 * @return A function call for {@code collect()}
	 * @see #collect(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collect(@NotNull Named variable) {
		return Functions.collect(variable);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function with {@code DISTINCT} added.
	 *
	 * @param variable The named thing to collect
	 * @return A function call for {@code collect()}
	 * @see #collect(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collectDistinct(@NotNull Named variable) {
		return Functions.collectDistinct(variable);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect">collect</a>.
	 *
	 * @param expression The things to collect
	 * @return A function call for {@code collect()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collect(Expression expression) {
		return Functions.collect(expression);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect">collect</a>.
	 *
	 * @param expression The things to collect
	 * @return A function call for {@code collect()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collectDistinct(Expression expression) {
		return Functions.collectDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code max()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max">max</a>.
	 *
	 * @param expression A list from which the maximum element value is returned
	 * @return A function call for {@code max()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation max(Expression expression) {
		return Functions.max(expression);
	}
	/**
	 * Creates a function invocation for the {@code max()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max">max</a>.
	 *
	 * @param expression A list from which the maximum element value is returned
	 * @return A function call for {@code max()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation maxDistinct(Expression expression) {
		return Functions.maxDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code min()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min">min</a>.
	 *
	 * @param expression A list from which the minimum element value is returned
	 * @return A function call for {@code min()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation min(Expression expression) {
		return Functions.min(expression);
	}
	/**
	 * Creates a function invocation for the {@code min()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min">min</a>.
	 *
	 * @param expression A list from which the minimum element value is returned
	 * @return A function call for {@code min()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation minDistinct(Expression expression) {
		return Functions.minDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code percentileCont()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont">percentileCont</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileCont()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileCont(Expression expression,
		Number percentile) {
		return Functions.percentileCont(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code percentileCont()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont">percentileCont</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileCont()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileContDistinct(Expression expression,
		Number percentile) {
		return Functions.percentileContDistinct(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code percentileDisc()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc">percentileDisc</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileDisc()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileDisc(Expression expression,
		Number percentile) {
		return Functions.percentileDisc(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code percentileDisc()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc">percentileDisc</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileDisc()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileDiscDistinct(Expression expression,
		Number percentile) {
		return Functions.percentileDiscDistinct(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code stDev()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev">stDev</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDev()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDev(Expression expression) {
		return Functions.stDev(expression);
	}
	/**
	 * Creates a function invocation for the {@code stDev()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev">stDev</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDev()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevDistinct(Expression expression) {
		return Functions.stDevDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code stDevP()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp">stDevP</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDevP()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevP(Expression expression) {
		return Functions.stDevP(expression);
	}
	/**
	 * Creates a function invocation for the {@code stDevP()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp">stDevP</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDevP()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevPDistinct(Expression expression) {
		return Functions.stDevPDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code sum()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum">sum</a>.
	 *
	 * @param expression An expression returning a set of numeric values
	 * @return A function call for {@code sum()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sum(Expression expression) {
		return Functions.sum(expression);
	}
	/**
	 * Creates a function invocation for the {@code sum()} function  with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum">sum</a>.
	 *
	 * @param expression An expression returning a set of numeric values
	 * @return A function call for {@code sum()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sumDistinct(Expression expression) {
		return Functions.sumDistinct(expression);
	}
	/**
	 * @param start the range's start
	 * @param end   the range's end
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(Integer start, Integer end) {
		return Functions.range(start, end);
	}
	/**
	 * @param start the range's start
	 * @param end   the range's end
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression, Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Expression start,
		@NotNull Expression end) {
		return Functions.range(start, end);
	}
	/**
	 * Creates a function invocation for the {@code range()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range">range</a>.
	 *
	 * @param start the range's start
	 * @param end   the range's end
	 * @param step  the range's step
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression, Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Integer start, @NotNull Integer end,
		Integer step) {
		return Functions.range(start, end, step);
	}
	/**
	 * Creates a function invocation for the {@code range()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range">range</a>.
	 *
	 * @param start the range's start
	 * @param end   the range's end
	 * @param step  the range's step
	 * @return A function call for {@code range()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Expression start,
		@NotNull Expression end, Expression step) {
		return Functions.range(start, end, step);
	}
	/**
	 * Creates a function invocation for the {@code head()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-head">head</a>.
	 *
	 * @param expression A list from which the head element is returned
	 * @return A function call for {@code head()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation head(Expression expression) {
		return Functions.head(expression);
	}
	/**
	 * Creates a function invocation for the {@code last()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-last">last</a>.
	 *
	 * @param expression A list from which the last element is returned
	 * @return A function call for {@code last()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation last(Expression expression) {
		return Functions.last(expression);
	}
	/**
	 * Creates a function invocation for {@code nodes{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes">nodes</a>.
	 *
	 * @param path The path for which the number of nodes should be retrieved
	 * @return A function call for {@code nodes()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation nodes(@NotNull NamedPath path) {
		return Functions.nodes(path);
	}
	/**
	 * Creates a function invocation for {@code nodes{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes">nodes</a>.
	 *
	 * @param symbolicName The symbolic name of a path for which the number of nodes should be retrieved
	 * @return A function call for {@code nodes{}} on a path represented by a symbolic name.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation nodes(@NotNull SymbolicName symbolicName) {
		return Functions.nodes(symbolicName);
	}
	/**
	 * Creates a function invocation for {@code relationships{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-relationships">relationships</a>.
	 *
	 * @param path The path for which the relationships should be retrieved
	 * @return A function call for {@code relationships()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation relationships(@NotNull NamedPath path) {
		return Functions.relationships(path);
	}
	/**
	 * Creates a function invocation for {@code relationships{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-relationships">relationships</a>.
	 *
	 * @param symbolicName The symbolic name of a path for which the relationships should be retrieved
	 * @return A function call for {@code relationships()} on a path represented by a symbolic name.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation relationships(@NotNull SymbolicName symbolicName) {
		return Functions.relationships(symbolicName);
	}
	/**
	 * Creates a function invocation for {@code startNode{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-startnode">startNode</a>.
	 *
	 * @param relationship The relationship for which the start node be retrieved
	 * @return A function call for {@code startNode()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation startNode(@NotNull Relationship relationship) {
		return Functions.startNode(relationship);
	}
	/**
	 * Creates a function invocation for {@code endNode{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-endnode">endNode</a>.
	 *
	 * @param relationship The relationship for which the end node be retrieved
	 * @return A function call for {@code endNode()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation endNode(@NotNull Relationship relationship) {
		return Functions.endNode(relationship);
	}
	/**
	 * Creates a function invocation for {@code date()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This is the most simple form.
	 *
	 * @return A function call for {@code date()}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date() {
		return Functions.date();
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year  The year
	 * @param month The month
	 * @param day   The day
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation calendarDate(Integer year, Integer month,
		Integer day) {
		return Functions.calendarDate(year, month, day);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year      The year
	 * @param week      The optional week
	 * @param dayOfWeek The optional day of the week
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation weekDate(Integer year, Integer week,
		Integer dayOfWeek) {
		return Functions.weekDate(year, week, dayOfWeek);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year         The year
	 * @param quarter      The optional week
	 * @param dayOfQuarter The optional day of the week
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation quarterDate(Integer year, Integer quarter,
		Integer dayOfQuarter) {
		return Functions.quarterDate(year, quarter, dayOfQuarter);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year       The year
	 * @param ordinalDay The ordinal day of the year.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ordinalDate(Integer year, Integer ordinalDay) {
		return Functions.ordinalDate(year, ordinalDay);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code date({})}
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull MapExpression components) {
		return Functions.date(components);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This creates a date from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull String temporalValue) {
		return Functions.date(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This creates a date from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull Expression temporalValue) {
		return Functions.date(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 *
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime() {
		return Functions.datetime();
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull TimeZone timeZone) {
		return Functions.datetime(timeZone);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code datetime({})}
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull MapExpression components) {
		return Functions.datetime(components);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">datetime</a>.
	 * This creates a datetime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull String temporalValue) {
		return Functions.datetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">datetime</a>.
	 * This creates a datetime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull Expression temporalValue) {
		return Functions.datetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 *
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime() {
		return Functions.localdatetime();
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull TimeZone timeZone) {
		return Functions.localdatetime(timeZone);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code localdatetime({})}
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull MapExpression components) {
		return Functions.localdatetime(components);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This creates a localdatetime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull String temporalValue) {
		return Functions.localdatetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This creates a localdatetime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull Expression temporalValue) {
		return Functions.localdatetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localtime</a>.
	 *
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime() {
		return Functions.localtime();
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull TimeZone timeZone) {
		return Functions.localtime(timeZone);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localtime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code localtime({})}
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull MapExpression components) {
		return Functions.localtime(components);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 * This creates a localtime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull String temporalValue) {
		return Functions.localtime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 * This creates a localtime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull Expression temporalValue) {
		return Functions.localtime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 *
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time() {
		return Functions.time();
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull TimeZone timeZone) {
		return Functions.time(timeZone);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code time({})}
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull MapExpression components) {
		return Functions.time(components);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This creates a time from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull String temporalValue) {
		return Functions.time(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This creates a time from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull Expression temporalValue) {
		return Functions.time(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code duration({})}
	 * @return A function call for {@code duration({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull MapExpression components) {
		return Functions.duration(components);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This creates a duration from a string.
	 *
	 * @param temporalAmount A string representing a temporal amount.
	 * @return A function call for {@code duration({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull String temporalAmount) {
		return Functions.duration(temporalAmount);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This creates a duration from a string.
	 *
	 * @param temporalAmount An expression representing a temporal amount.
	 * @return A function call for {@code duration({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull Expression temporalAmount) {
		return Functions.duration(temporalAmount);
	}
	/**
	 * Creates a function invocation for {@code shortestPath({})}.
	 *
	 * @param relationship The relationship to be passed to {@code shortestPath}.
	 * @return A function call for {@code shortestPath({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation shortestPath(Relationship relationship) {
		return Functions.shortestPath(relationship);
	}
	/**
	 * Starts building a function invocation for {@code reduce({})}.
	 *
	 * @param variable The closure will have a variable introduced in its context. We decide here which variable to use.
	 * @return An ongoing definition for a function call to {@code reduce({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Reduction.OngoingDefinitionWithVariable reduce(
		@NotNull SymbolicName variable) {
		return Functions.reduce(variable);
	}
	/**
	 * Creates a function invocation for {@code abs({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-abs">abs</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code abs({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation abs(@NotNull Expression expression) {
		return Functions.abs(expression);
	}
	/**
	 * Creates a function invocation for {@code ceil({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-ceil">ceil</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code ceil({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ceil(@NotNull Expression expression) {
		return Functions.ceil(expression);
	}
	/**
	 * Creates a function invocation for {@code floor({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-floor">floor</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code floor({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation floor(@NotNull Expression expression) {
		return Functions.floor(expression);
	}
	/**
	 * Creates a function invocation for {@code rand({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-rand">rand</a>.
	 *
	 * @return A function call for {@code rand({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation rand() {
		return Functions.rand();
	}
	/**
	 * Creates a function invocation for {@code round({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-round">round</a>.
	 *
	 * @param value      The value to round
	 * @param expression Additional parameters, length must be 0, 1 or 2:
	 *                   First entry is the precision, second is the rounding mode
	 * @return A function call for {@code round({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation round(Expression value, Expression... expression) {
		return Functions.round(value, expression);
	}
	/**
	 * Creates a function invocation for {@code sign({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sign">sign</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sign({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sign(@NotNull Expression expression) {
		return Functions.sign(expression);
	}
	/**
	 * Creates a function invocation for {@code e({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-e">e</a>.
	 *
	 * @return A function call for {@code e({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation e() {
		return Functions.e();
	}
	/**
	 * Creates a function invocation for {@code exp({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-exp">exp</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code exp({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation exp(@NotNull Expression expression) {
		return Functions.exp(expression);
	}
	/**
	 * Creates a function invocation for {@code log({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-log">log</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code log({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation log(@NotNull Expression expression) {
		return Functions.log(expression);
	}
	/**
	 * Creates a function invocation for {@code log10({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-log10">log10</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code log10({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation log10(@NotNull Expression expression) {
		return Functions.log10(expression);
	}
	/**
	 * Creates a function invocation for {@code sqrt({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sqrt">sqrt</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sqrt({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sqrt(@NotNull Expression expression) {
		return Functions.sqrt(expression);
	}
	/**
	 * Creates a function invocation for {@code acos({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-acos">acos</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code acos({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation acos(@NotNull Expression expression) {
		return Functions.acos(expression);
	}
	/**
	 * Creates a function invocation for {@code asin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-asin">asin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code asin({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation asin(@NotNull Expression expression) {
		return Functions.asin(expression);
	}
	/**
	 * Creates a function invocation for {@code atan({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-atan">atan</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code atan({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation atan(@NotNull Expression expression) {
		return Functions.atan(expression);
	}
	/**
	 * Creates a function invocation for {@code atan2({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-atan2">atan2</a>.
	 *
	 * @param y the y value of a point
	 * @param x the x value of a point
	 * @return A function call for {@code atan2({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation atan2(@NotNull Expression y,
		@NotNull Expression x) {
		return Functions.atan2(y, x);
	}
	/**
	 * Creates a function invocation for {@code cos({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-cos">cos</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code cos({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cos(@NotNull Expression expression) {
		return Functions.cos(expression);
	}
	/**
	 * Creates a function invocation for {@code cot({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-cot">cot</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code cot({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cot(@NotNull Expression expression) {
		return Functions.cot(expression);
	}
	/**
	 * Creates a function invocation for {@code degrees({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-degrees">degrees</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code degrees({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation degrees(@NotNull Expression expression) {
		return Functions.degrees(expression);
	}
	/**
	 * Creates a function invocation for {@code haversin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-haversin">haversin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code haversin({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation haversin(@NotNull Expression expression) {
		return Functions.haversin(expression);
	}
	/**
	 * Creates a function invocation for {@code pi({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-pi">pi</a>.
	 *
	 * @return A function call for {@code pi({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation pi() {
		return Functions.pi();
	}
	/**
	 * Creates a function invocation for {@code radians({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-radians">radians</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code radians({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation radians(@NotNull Expression expression) {
		return Functions.radians(expression);
	}
	/**
	 * Creates a function invocation for {@code sin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sin">sin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sin({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sin(@NotNull Expression expression) {
		return Functions.sin(expression);
	}
	/**
	 * Creates a function invocation for {@code tan({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-tan">tan</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code tan({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation tan(@NotNull Expression expression) {
		return Functions.tan(expression);
	}
	/**
	 * Creates a function invocation for {@code toInteger({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tointeger">toInteger</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toInteger({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toInteger(@NotNull Expression expression) {
		return Functions.toInteger(expression);
	}
	/**
	 * Creates a function invocation for {@code toString({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-tostring">toString</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toString({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toString(@NotNull Expression expression) {
		return Functions.toString(expression);
	}
	/**
	 * Creates a function invocation for {@code toStringOrNull({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toStringOrNull">toStringOrNull</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toStringOrNull({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toStringOrNull(@NotNull Expression expression) {
		return Functions.toStringOrNull(expression);
	}
	/**
	 * Creates a function invocation for {@code toFloat({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tofloat">toFloat</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toFloat({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toFloat(@NotNull Expression expression) {
		return Functions.toFloat(expression);
	}
	/**
	 * Creates a function invocation for {@code toBoolean({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-toboolean">toBoolean</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toBoolean({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toBoolean(@NotNull Expression expression) {
		return Functions.toBoolean(expression);
	}
	/**
	 * Creates a function invocation for {@code linenumber({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code linenumber({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation linenumber() {
		return Functions.linenumber();
	}
	/**
	 * Creates a function invocation for {@code file({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code file({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation file() {
		return Functions.file();
	}
	/**
	 * Creates a function invocation for {@code randomUUID({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code randomUUID({})}.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static FunctionInvocation randomUUID() {
		return Functions.randomUUID();
	}
	/**
	 * Creates a function invocation for {@code length()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-length">length</a>.
	 *
	 * @param path The path for which the length should be retrieved
	 * @return A function call for {@code length()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation length(@NotNull NamedPath path) {
		return Functions.length(path);
	}
	/**
	 * Creates a function invocation for {@code graph.names()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-names">graph.names</a>.
	 *
	 * @return A function call for {@code graph.names()}.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphNames() {
		return Functions.graphNames();
	}
	/**
	 * Creates a function invocation for {@code graph.propertiesByName()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-propertiesByName">graph.propertiesByName</a>.
	 *
	 * @param name The name of the graph
	 * @return A function call for {@code graph.propertiesByName()}.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphPropertiesByName(Expression name) {
		return Functions.graphPropertiesByName(name);
	}
	/**
	 * Creates a function invocation for {@code graph.byName()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-byname">graph.byName</a>.
	 *
	 * @param name The name of the graph
	 * @return A function call for {@code graph.byName()}.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphByName(
		Expression name) {
		return Functions.graphByName(name);
	}
	/**
	 * Create a new map projection with the given, mixed content
	 *
	 * @param name    The symbolic name of this project
	 * @param content The projected content
	 * @return A new map projection
	 * @since 2023.9.0
	 */
	public static MapProjection createProjection(SymbolicName name, Object... content) {
		return MapProjection.create(name, content);
	}
	/**
	 * Creates an unary minus operation.
	 *
	 * @param e The expression to which the unary minus should be applied. We don't check if it's a numeric expression,
	 *          but in hindsight to generate semantically correct Cypher, it's recommended that is one.
	 * @return An unary minus operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation minus(Expression e) {
		return Operations.minus(e);
	}
	/**
	 * Creates an unary plus operation.
	 *
	 * @param e The expression to which the unary plus should be applied. We don't check if it's a numeric expression,
	 *          but in hindsight to generate semantically correct Cypher, it's recommended that is one.
	 * @return An unary plus operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Expression plus(Expression e) {
		return Operations.plus(e);
	}
	@SuppressWarnings("deprecation")
	public static Operation concat(Expression op1, Expression op2) {
		return Operations.concat(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation add(Expression op1, Expression op2) {
		return Operations.add(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation subtract(Expression op1, Expression op2) {
		return Operations.subtract(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation multiply(Expression op1, Expression op2) {
		return Operations.multiply(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation divide(Expression op1, Expression op2) {
		return Operations.divide(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation remainder(Expression op1, Expression op2) {
		return Operations.remainder(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation pow(Expression op1, Expression op2) {
		return Operations.pow(op1, op2);
	}
	/**
	 * Creates a {@code =} operation. The left hand side should resolve to a property or to something which has labels
	 * or types to modify and the right hand side should either be new properties or labels.
	 *
	 * @param target The target that should be modified
	 * @param value  The new value of the target
	 * @return A new operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation set(Expression target, Expression value) {
		return Operations.set(target, value);
	}
	/**
	 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
	 * of properties and the right hand side must be a map of new or updated properties
	 *
	 * @param target The target container that should be modified
	 * @param value  The new properties
	 * @return A new operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation mutate(Expression target, MapExpression value) {
		return Operations.mutate(target, value);
	}
	/**
	 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
	 * of properties and the right hand side must be a map of new or updated properties
	 *
	 * @param target The target container that should be modified
	 * @param value  The new properties
	 * @return A new operation.
	 * @since 2023.9.0
	 */
	public static Operation mutate(Expression target, Expression value) {
		return Operations.mutate(target, value);
	}
	/**
	 * Creates an operation adding one or more labels from a given {@link Node node}.
	 *
	 * @param target The target of the new labels
	 * @param label  The labels to be added
	 * @return A set operation
	 * @since 2023.9.0
	 */
	public static Operation setLabel(Node target, String... label) {
		return Operations.set(target, label);
	}
	/**
	 * Creates an operation removing one or more labels from a given {@link Node node}.
	 *
	 * @param target The target of the remove operation
	 * @param label  The labels to be removed
	 * @return A remove operation
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation removeLabel(Node target, String... label) {
		return Operations.remove(target, label);
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param property The property to be passed to {@code exists()}
	 * @return A function call for {@code exists()} for one property
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition exists(Property property) {
		return Predicates.exists(property);
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param pattern The pattern to be passed to {@code exists()}
	 * @return A function call for {@code exists()} for one pattern
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition exists(RelationshipPattern pattern) {
		return Predicates.exists(pattern);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a>. The statement may or  may not have  a {@literal  RETURN} clause. It  must however not  contain any
	 * updates. While it  would render syntactically correct  Cypher, Neo4j does not support  updates inside existential
	 * sub-queries.
	 *
	 * @param statement The statement to be passed to {@code exists{}}
	 * @param imports   Optional imports to be used in the statement (will be imported with {@literal WITH})
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(Statement statement, IdentifiableElement... imports) {
		return Predicates.exists(statement, imports);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns
	 *
	 * @param pattern the pattern that must exists
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(PatternElement pattern) {
		return Predicates.exists(pattern);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns
	 *
	 * @param pattern the list of patterns that must exists
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(List<PatternElement> pattern) {
		return Predicates.exists(pattern);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns and an optional {@link Where where-clause}.
	 *
	 * @param pattern the list of patterns that must exists
	 * @param where   an optional where-clause
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(List<PatternElement> pattern, @Nullable Where where) {
		return Predicates.exists(pattern, where);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code all()} predicate function
	 * @see #all(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction all(String variable) {
		return Predicates.all(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code all()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code all()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction all(
		SymbolicName variable) {
		return Predicates.all(variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code any()} predicate function
	 * @see #any(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction any(String variable) {
		return Predicates.any(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code any()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-any">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code any()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction any(
		SymbolicName variable) {
		return Predicates.any(variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code none()} predicate function
	 * @see #none(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction none(String variable) {
		return Predicates.none(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code none()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-none">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code none()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction none(
		SymbolicName variable) {
		return Predicates.none(variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code single()} predicate function
	 * @see #single(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction single(String variable) {
		return Predicates.single(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code single()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-single">single</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code single()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction single(
		SymbolicName variable) {
		return Predicates.single(variable);
	}
	/**
	 * Not to be instantiated.
	 */
	private Cypher() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * Roughly corresponding to <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/Match.html#Where">Where</a>.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class Where implements Visitable {
	private final Condition condition;
	/**
	 * Creates a new {@literal WHERE}
	 *
	 * @param optionalWhere An optional expression that must be usable {@link Expression#asCondition() "as condition"}.
	 * @return A {@literal WHERE} expression or null when {@code optionalWhere} has been {@literal NULL}
	 * @since 2022.0.0
	 */
	@Nullable
	public static Where from(@Nullable Expression optionalWhere) {
		return optionalWhere == null ? null : new Where(optionalWhere.asCondition());
	}
	Where(Condition condition) {
		this.condition = condition;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.condition.accept(visitor);
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.ast;
/**
 * @author Michael J. Simons
 * @since 1.0
 */
@FunctionalInterface
public interface Visitor {
	/**
	 * Enter a {@link Visitable}. Not all visitables will obey to the result
	 *
	 * @param segment the segment to visit.
	 */
	void enter(Visitable segment);
	/**
	 * A method that is used to pass control to some extent from the visitor to the {@link Visitable}. Not all visitables
	 * react to this, and we don't give any guarantees about which will. This method has been mainly introduced in parallel
	 * to {@link #enter(Visitable)} so that existing external implementations of {@link Visitor visitors} won't break.
	 *
	 * @param segment the segment to visit.
	 * @return A result indicating whether visitation of child elements should continue or not.
	 * @since 2022.3.0
	 */
	default EnterResult enterWithResult(Visitable segment) {
		enter(segment);
		return EnterResult.CONTINUE;
	}
	/**
	 * Leave a {@link Visitable}.
	 *
	 * @param segment the visited segment.
	 */
	default void leave(Visitable segment) {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Arrays;
import java.util.Collection;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere;
import org.neo4j.cypherdsl.core.annotations.CheckReturnValue;
/**
 * A step that exposes the {@code WITH} clause. This interface used to be part of the {@link StatementBuilder} and moved
 * out of it to unify the {@literal WITH} clause taking in {@link IdentifiableElement identifable elements}.
 *
 * @author Michael J. Simons
 * @since 2023.0.0
 */
@API(status = STABLE, since = "2023.0.0")
public interface ExposesWith {
	/**
	 * Starts a with clause by passing variables to it.
	 *
	 * @param variables The variables to pass on to the next part
	 * @return A match that can be build now
	 */
	@NotNull
	@CheckReturnValue
	@SuppressWarnings("deprecation")
	default OrderableOngoingReadingAndWithWithoutWhere with(String... variables) {
		return with(Expressions.createSymbolicNames(variables));
	}
	/**
	 * Create a match that returns one or more identifiable elements.
	 *
	 * @param elements The variables to pass on to the next part
	 * @return A match that can be build now
	 */
	@NotNull
	@CheckReturnValue
	default OrderableOngoingReadingAndWithWithoutWhere with(IdentifiableElement... elements) {
		return with(Arrays.asList(elements));
	}
	/**
	 * Create a match that returns one or more identifiable elements.
	 *
	 * @param elements The expressions to be returned. Must not be null and be at least one expression.
	 * @return A match that can be build now
	 */
	@NotNull
	@CheckReturnValue
	OrderableOngoingReadingAndWithWithoutWhere with(Collection<IdentifiableElement> elements);
	/**
	 * Create a match that returns the distinct set of one or more identifiable elements.
	 *
	 * @param variables The variables to pass on to the next part
	 * @return A match that can be build now
	 * @see #withDistinct(IdentifiableElement...)
	 */
	@NotNull
	@CheckReturnValue
	@SuppressWarnings("deprecation")
	default OrderableOngoingReadingAndWithWithoutWhere withDistinct(String... variables) {
		return withDistinct(Expressions.createSymbolicNames(variables));
	}
	/**
	 * Create a match that returns the distinct set of one or more identifiable elements.
	 *
	 * @param elements The variables to pass on to the next part
	 * @return A match that can be build now
	 * @see #withDistinct(IdentifiableElement...)
	 */
	@NotNull
	@CheckReturnValue
	default OrderableOngoingReadingAndWithWithoutWhere withDistinct(IdentifiableElement... elements) {
		return withDistinct(Arrays.asList(elements));
	}
	/**
	 * Create a match that returns the distinct set of one or more expressions.
	 *
	 * @param expressions The expressions to be returned. Must not be null and be at least one expression.
	 * @return A match that can be build now
	 */
	@NotNull
	@CheckReturnValue
	OrderableOngoingReadingAndWithWithoutWhere withDistinct(Collection<IdentifiableElement> expressions);
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.Optional;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.ProvidesAffixes;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
/**
 * Specialized list of expressions that represents the arguments of a procedure call.
 *
 * @author Michael J. Simons
 * @soundtrack Apocalyptica - Cell-0
 * @since 2020.0.1
 */
@API(status = INTERNAL, since = "2020.0.1")
final class Arguments extends TypedSubtree<Expression> implements ProvidesAffixes {
	Arguments(Expression... children) {
		super(children);
	}
	@Override
	@SuppressWarnings("deprecation")
	protected Visitable prepareVisit(Expression child) {
		return Expressions.nameOrExpression(child);
	}
	@Override
	public Optional<String> getPrefix() {
		return Optional.of("(");
	}
	@Override
	public Optional<String> getSuffix() {
		return Optional.of(")");
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Optional;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
/**
 * A named thing exposes {@link #getSymbolicName()}, making the thing identifiable.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public non-sealed interface Named extends IdentifiableElement {
	/**
	 * @return An optional symbolic name.
	 */
	@NotNull @Contract(pure = true)
	Optional<SymbolicName> getSymbolicName();
	/**
	 * @return A symbolic name
	 * @throws IllegalStateException If this has not been named yet.
	 */
	@NotNull @Contract(pure = true)
	default SymbolicName getRequiredSymbolicName() {
		return getSymbolicName().orElseThrow(() -> new IllegalStateException("No name present."));
	}
	@Override @NotNull
	default Expression asExpression() {
		return getRequiredSymbolicName();
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.RelationshipPatternCondition;
import org.neo4j.cypherdsl.core.utils.Assertions;
import org.neo4j.cypherdsl.core.annotations.CheckReturnValue;
/**
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/PatternComprehension.html">PatternComprehension</a>
 * and <a href="https://neo4j.com/docs/cypher-manual/current/syntax/lists/#cypher-pattern-comprehension">the corresponding cypher manual entry</a>.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class PatternComprehension implements Expression {
	static OngoingDefinitionWithPattern basedOn(RelationshipPattern pattern) {
		Assertions.notNull(pattern, "A pattern is required");
		return new Builder(pattern);
	}
	static OngoingDefinitionWithPattern basedOn(NamedPath pattern) {
		Assertions.notNull(pattern, "A pattern is required");
		return new Builder(pattern);
	}
	/**
	 * Provides the final step of defining a pattern comprehension.
	 */
	public interface OngoingDefinitionWithoutReturn {
		/**
		 * @param variables the elements to be returned from the pattern
		 * @return The final definition of the pattern comprehension
		 * @see #returning(Expression...)
		 */
		@NotNull @Contract(pure = true)
		@SuppressWarnings("deprecation")
		default PatternComprehension returning(Named... variables) {
			return returning(Expressions.createSymbolicNames(variables));
		}
		/**
		 * @param listDefinition Defines the elements to be returned from the pattern
		 * @return The final definition of the pattern comprehension
		 */
		@NotNull @Contract(pure = true)
		PatternComprehension returning(Expression... listDefinition);
	}
	/**
	 * Allows to add a where clause into the definition of the pattern.
	 */
	public interface OngoingDefinitionWithPattern extends OngoingDefinitionWithoutReturn {
		/**
		 * Adds a {@code WHERE} clause to the inner statement of the pattern comprehension
		 *
		 * @param condition An initial condition to be used with {@code WHERE}
		 * @return An ongoing definition of a pattern comprehension for furhter modification
		 */
		@NotNull @CheckReturnValue
		OngoingDefinitionWithPatternAndWhere where(Condition condition);
		/**
		 * Adds a where clause based on a path pattern to the ongoing definition
		 *
		 * @param pathPattern The path pattern to add to the where clause.
		 *                    This path pattern must not be {@literal null} and must
		 *                    not introduce new variables not available in the match.
		 * @return A match or a call restricted by a where clause with no return items yet.
		 * @since 2020.1.4
		 */
		@NotNull @CheckReturnValue
		default OngoingDefinitionWithPatternAndWhere where(RelationshipPattern pathPattern) {
			Assertions.notNull(pathPattern, "The path pattern must not be null.");
			return this.where(RelationshipPatternCondition.of(pathPattern));
		}
	}
	/**
	 * Intermediate step that allows expressing additional, logical operators.
	 */
	public interface OngoingDefinitionWithPatternAndWhere extends OngoingDefinitionWithoutReturn, ExposesLogicalOperators<OngoingDefinitionWithPatternAndWhere>  {
	}
	/**
	 * Ongoing definition of a pattern comprehension. Can be defined without a where-clause now.
	 */
	private static class Builder implements OngoingDefinitionWithPattern, OngoingDefinitionWithPatternAndWhere  {
		private final PatternElement pattern;
		private final DefaultStatementBuilder.ConditionBuilder conditionBuilder = new DefaultStatementBuilder.ConditionBuilder();
		private Builder(PatternElement pattern) {
			this.pattern = pattern;
		}
		@Override
		public OngoingDefinitionWithPatternAndWhere where(Condition condition) {
			conditionBuilder.where(condition);
			return this;
		}
		@Override
		public OngoingDefinitionWithPatternAndWhere and(Condition condition) {
			conditionBuilder.and(condition);
			return this;
		}
		@Override
		public OngoingDefinitionWithPatternAndWhere or(Condition condition) {
			conditionBuilder.or(condition);
			return this;
		}
		@Override
		public PatternComprehension returning(Expression... expressions) {
			Where where = conditionBuilder.buildCondition().map(Where::new).orElse(null);
			return new PatternComprehension(pattern, where, ListExpression.listOrSingleExpression(expressions));
		}
	}
	private final PatternElement pattern;
	private final Where where;
	private final Expression listDefinition;
	private PatternComprehension(PatternElement pattern, Where where, Expression listDefinition) {
		this.pattern = pattern;
		this.where = where;
		this.listDefinition = listDefinition;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.pattern.accept(visitor);
		Visitable.visitIfNotNull(this.where, visitor);
		Operator.PIPE.accept(visitor);
		this.listDefinition.accept(visitor);
		visitor.leave(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitable;
/**
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/PatternElement.html">PatternElement</a>.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface PatternElement extends Visitable {
	/**
	 * Creates a new {@link PatternElement} which including an additional filter. Returns {@code this} pattern.
	 * when {@code predicate} is literal {@code null}.
	 * <p>
	 * The pattern might be a {@link Node node pattern} or a {@link RelationshipPattern relationship pattern}.
	 * <p>
	 * A {@code WHERE} on a pattern is only supported from Neo4j 5.0 onwards.
	 *
	 * @param predicate the predicate to filter on
	 * @return a new pattern element or this instance if the predicate to this method was literal {@code null}
	 * @throws UnsupportedOperationException In cases the underlying element does not support a {@code WHERE} clause
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0")
	@NotNull @Contract(pure = true)
	default PatternElement where(@Nullable Expression predicate) {
		throw new UnsupportedOperationException();
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Optional;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.utils.Assertions;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * A sort item can be used in an {@code ORDER BY} clause and changes the order of the items being returned from a query.
 *
 * @author Gerrit Meier
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class SortItem implements Visitable {
	private final Expression expression;
	private final Direction direction;
	static SortItem create(Expression expression, Direction direction) {
		Assertions.notNull(expression, "Expression to sort must not be null.");
		return new SortItem(expression, Optional.ofNullable(direction).orElse(SortItem.Direction.UNDEFINED));
	}
	private SortItem(Expression expression, Direction direction) {
		this.expression = expression;
		this.direction = direction;
	}
	/**
	 * Creates a new sort item from {@literal this} instance, setting the sort direction to ascending.
	 * @return A new sort item.
	 */
	@NotNull @Contract(pure = true)
	public SortItem ascending() {
		return new SortItem(this.expression, Direction.ASC);
	}
	/**
	 * Creates a new sort item from {@literal this} instance, setting the sort direction to descending.
	 * @return A new sort item.
	 */
	@NotNull @Contract(pure = true)
	public SortItem descending() {
		return new SortItem(this.expression, Direction.DESC);
	}
	@Override
	@SuppressWarnings("deprecation")
	public void accept(Visitor visitor) {
		visitor.enter(this);
		Expressions.nameOrExpression(this.expression).accept(visitor);
		if (this.direction != Direction.UNDEFINED) {
			this.direction.accept(visitor);
		}
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
	/**
	 * Sort direction.
	 * @since 1.0
	 */
	@API(status = STABLE)
	public enum Direction implements Visitable {
		/** Undefined direction. */
		UNDEFINED(""),
		/** Ascending order. */
		ASC("ASC"),
		/** Descending order. */
		DESC("DESC");
		private final String symbol;
		Direction(String symbol) {
			this.symbol = symbol;
		}
		/**
		 * @return The database internal symbol for a direction.
		 */
		public String getSymbol() {
			return this.symbol;
		}
		@Override
		public String toString() {
			return RendererBridge.render(this);
		}
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * A binary operation.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class Operation implements Expression {
	/**
	 * A set of operators triggering operations on labels.
	 */
	private static final EnumSet<Operator> LABEL_OPERATORS = EnumSet.of(Operator.SET_LABEL, Operator.REMOVE_LABEL);
	private static final EnumSet<Operator.Type> NEEDS_GROUPING_BY_TYPE = EnumSet
		.complementOf(EnumSet.of(Operator.Type.PROPERTY, Operator.Type.LABEL));
	private static final EnumSet<Operator> DONT_GROUP = EnumSet.of(Operator.EXPONENTIATION, Operator.PIPE, Operator.UNARY_MINUS, Operator.UNARY_PLUS);
	static Operation create(@NotNull Operator operator, @NotNull Expression expression) {
		Assertions.notNull(operator, "Operator must not be null.");
		Assertions.isTrue(operator.isUnary(), "Operator must be unary.");
		Assertions.notNull(expression, "The expression must not be null.");
		return switch (operator.getType()) {
			case PREFIX -> new Operation(null, operator, expression);
			case POSTFIX -> new Operation(expression, operator, (Expression) null);
			default -> throw new IllegalArgumentException("Invalid operator type " + operator.getType());
		};
	}
	static Operation create(Expression op1, Operator operator, Expression op2) {
		Assertions.notNull(op1, "The first operand must not be null.");
		Assertions.notNull(operator, "Operator must not be null.");
		Assertions.notNull(op2, "The second operand must not be null.");
		return new Operation(op1, operator, op2);
	}
	static Operation create(Node op1, Operator operator, String... nodeLabels) {
		Assertions.notNull(op1, "The first operand must not be null.");
		Assertions.isTrue(op1.getSymbolicName().isPresent(), "The node must have a name.");
		Assertions.isTrue(LABEL_OPERATORS.contains(operator),
			String.format("Only operators %s can be used to modify labels", LABEL_OPERATORS));
		Assertions.notEmpty(nodeLabels, "The labels cannot be empty.");
		List<NodeLabel> listOfNodeLabels = Arrays.stream(nodeLabels).map(NodeLabel::new).toList();
		return new Operation(op1.getRequiredSymbolicName(), operator, new NodeLabels(listOfNodeLabels));
	}
	private final Expression left;
	private final Operator operator;
	private final Visitable right;
	Operation(Expression left, Operator operator, Expression right) {
		this.left = left;
		this.operator = operator;
		this.right = right;
	}
	Operation(Expression left, Operator operator, NodeLabels right) {
		this.left = left;
		this.operator = operator;
		this.right = right;
	}
	@Override
	@SuppressWarnings("deprecation")
	public void accept(Visitor visitor) {
		visitor.enter(this);
		if (left != null) {
			Expressions.nameOrExpression(left).accept(visitor);
		}
		operator.accept(visitor);
		Visitable.visitIfNotNull(right, visitor);
		visitor.leave(this);
	}
	/**
	 * Checks, whether this operation needs grouping.
	 *
	 * @return True, if this operation needs grouping.
	 */
	public boolean needsGrouping() {
		return NEEDS_GROUPING_BY_TYPE.contains(this.operator.getType()) && !DONT_GROUP.contains(this.operator);
	}
	@API(status = INTERNAL)
	Operator getOperator() {
		return operator;
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}

/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * An aliased expression, that deals with named expressions when accepting visitors.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class AliasedExpression implements Aliased, Expression, IdentifiableElement {
	private final Expression delegate;
	private final String alias;
	AliasedExpression(Expression delegate, String alias) {
		this.delegate = delegate;
		this.alias = alias;
	}
	@NotNull
	@Override
	public String getAlias() {
		return alias;
	}
	/**
	 * This takes the originally aliased expression and re-aliases it. Aliases are not nested.
	 *
	 * @param newAlias The new alias to use
	 * @return A new aliased, expression.
	 */
	@NotNull
	@Override
	public AliasedExpression as(String newAlias) {
		Assertions.hasText(newAlias, "The alias may not be null or empty.");
		return new AliasedExpression(this.delegate, newAlias);
	}
	@Override
	@SuppressWarnings("deprecation")
	public void accept(Visitor visitor) {
		visitor.enter(this);
		Expressions.nameOrExpression(this.delegate).accept(visitor);
		visitor.leave(this);
	}
	Expression getDelegate() {
		return delegate;
	}
	@NotNull
	@Override
	public Expression asExpression() {
		return this;
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
import org.neo4j.cypherdsl.core.annotations.CheckReturnValue;
/**
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/Atom.html#ListComprehension">ListComprehension</a>
 * and <a href="https://neo4j.com/docs/cypher-manual/current/syntax/lists/#cypher-list-comprehension">the corresponding cypher manual entry</a>.
 *
 * @author Michael J. Simons
 * @soundtrack Corrosion Of Conformity - America's Volume Dealer
 * @since 1.0.1
 */
@API(status = STABLE, since = "1.0.1")
public final class ListComprehension implements Expression {
	// Modelling from the FilterExpression: https://s3.amazonaws.com/artifacts.opencypher.org/M14/railroad/FilterExpression.html */
	/**
	 * The variable for the where part.
	 */
	private final SymbolicName variable;
	/**
	 * The list expression. No further assertions are taken to check beforehand if it is actually a Cypher List atm.
	 */
	private final Expression listExpression;
	/**
	 * Filtering on the list.
	 */
	private final Where where;
	/**
	 * The new list to be returned.
	 */
	private final Expression listDefinition;
	static OngoingDefinitionWithVariable with(SymbolicName variable) {
		Assertions.notNull(variable, "A variable is required");
		return new Builder(variable);
	}
	/**
	 * {@link #in(Expression)} must be used to define the source list.
	 */
	public interface OngoingDefinitionWithVariable {
		/**
		 * Create a list comprehension past on a literal list.
		 *
		 * @param list The source list.
		 * @return An ongoing definition
		 */
		@NotNull @CheckReturnValue
		OngoingDefinitionWithList in(Expression list);
	}
	/**
	 * Allows to add a where clause into the definition of the list.
	 */
	public interface OngoingDefinitionWithList extends OngoingDefinitionWithoutReturn {
		/**
		 * Adds a {@code WHERE} clause to this comprehension.
		 *
		 * @param condition the condition to start the {@code WHERE} clause with.
		 * @return An ongoing definition
		 */
		@NotNull @CheckReturnValue
		OngoingDefinitionWithoutReturn where(Condition condition);
	}
	/**
	 * Provides the final step of defining a list comprehension.
	 */
	public interface OngoingDefinitionWithoutReturn {
		/**
		 * @param variables the elements to be returned from the list
		 * @return The final definition of the list comprehension
		 * @see #returning(Expression...)
		 */
		@NotNull @Contract(pure = true)
		@SuppressWarnings("deprecation")
		default ListComprehension returning(Named... variables) {
			return returning(Expressions.createSymbolicNames(variables));
		}
		/**
		 * @param listDefinition Defines the elements to be returned from the pattern
		 * @return The final definition of the list comprehension
		 */
		@NotNull @Contract(pure = true)
		ListComprehension returning(Expression... listDefinition);
		/**
		 * @return Returns the list comprehension as is, without a {@literal WHERE} and returning each element of the
		 * original list
		 */
		@NotNull @Contract(pure = true)
		ListComprehension returning();
	}
	private static class Builder
		implements OngoingDefinitionWithVariable, OngoingDefinitionWithList {
		private final SymbolicName variable;
		private Expression listExpression;
		private Where where;
		private Builder(SymbolicName variable) {
			this.variable = variable;
		}
		@NotNull
		@Override
		public OngoingDefinitionWithList in(Expression list) {
			this.listExpression = list;
			return this;
		}
		@NotNull
		@Override
		public OngoingDefinitionWithoutReturn where(Condition condition) {
			this.where = new Where(condition);
			return this;
		}
		@NotNull
		@Override
		public ListComprehension returning() {
			return new ListComprehension(variable, listExpression, where, null);
		}
		@NotNull
		@Override
		public ListComprehension returning(Expression... expressions) {
			return new ListComprehension(variable, listExpression, where,
				ListExpression.listOrSingleExpression(expressions));
		}
	}
	private ListComprehension(SymbolicName variable, Expression listExpression,
		Where where, Expression listDefinition) {
		this.variable = variable;
		this.listExpression = listExpression;
		this.where = where;
		this.listDefinition = listDefinition;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.variable.accept(visitor);
		Operator.IN.accept(visitor);
		this.listExpression.accept(visitor);
		Visitable.visitIfNotNull(this.where, visitor);
		if (this.listDefinition != null) {
			Operator.PIPE.accept(visitor);
			this.listDefinition.accept(visitor);
		}
		visitor.leave(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Collection;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.annotations.CheckReturnValue;
import org.neo4j.cypherdsl.core.internal.RelationshipPatternCondition;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * @author Michael J. Simons
 * @author Gerrit Meier
 * @author Andreas Berger
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface StatementBuilder
	extends ExposesMatch, ExposesCreate, ExposesMerge, ExposesUnwind, ExposesReturning, ExposesFinish, ExposesSubqueryCall, ExposesWith {
	/**
	 * An ongoing update statement that can be used to chain more update statements or add a with or return clause.
	 *
	 * @since 1.0
	 */
	interface OngoingUpdate extends BuildableStatement<Statement>,
		ExposesCreate, ExposesMerge, ExposesDelete, ExposesReturning, ExposesFinish, ExposesWith, ExposesSet, ExposesForeach {
	}
	/**
	 * An ongoing update statement that can be used to chain more updating statements, define actions on a merge
	 * or add a with or return clause.
	 *
	 * @since 2021.0.0
	 */
	interface OngoingMerge extends OngoingUpdate, ExposesMergeAction, ExposesSetAndRemove {
	}
	/**
	 * A shared marker interface for things that can be turned into a subquery to be used inside the WHERE clause.
	 *
	 * @since 2020.1.2
	 */
	interface ExposesExistentialSubqueryCall {
		/**
		 * This can be used against a 4.x database to turn this ongoing match statement into a condition to be used
		 * in an existential subquery.
		 *
		 * @return An existential subquery.
		 * @neo4j.version 4.0.0
		 */
		@Neo4jVersion(minimum = "4.0.0")
		@NotNull @Contract(pure = true)
		Condition asCondition();
	}
	/**
	 * A match that exposes {@code returning} and {@code where} methods to add required information.
	 * While the where clause is optional, a returning clause needs to be specified before the
	 * statement can be built.
	 *
	 * @since 1.0
	 */
	interface OngoingReadingWithoutWhere
		extends OngoingReading, ExposesHints, ExposesWhere<StatementBuilder.OngoingReadingWithWhere>, ExposesMatch, ExposesExistentialSubqueryCall {
	}
	/**
	 * A match that has a non-empty {@code where}-part. THe returning clause is still open.
	 *
	 * @since 1.0
	 */
	interface OngoingReadingWithWhere extends OngoingReading, ExposesMatch,
		ExposesLogicalOperators<OngoingReadingWithWhere>, ExposesExistentialSubqueryCall {
	}
	/**
	 * A match that exposes {@code returning} and for which it is not decided whether the optional
	 * where part has been used or note.
	 *
	 * @since 1.0
	 */
	interface OngoingReading
		extends ExposesReturning, ExposesFinish, ExposesWith, ExposesUpdatingClause, ExposesUnwind, ExposesCreate, ExposesMatch,
		ExposesCall<OngoingInQueryCallWithoutArguments>, ExposesSubqueryCall {
	}
	/**
	 * Builder part for unwinding.
	 *
	 * @since 1.0
	 */
	interface OngoingUnwind {
		/**
		 * Adds an {@code AS} part that allows to define an alias for the iterable being unwound.
		 *
		 * @param variable The alias name
		 * @return A normal, ongoing read.
		 */
		@NotNull @CheckReturnValue
		OngoingReading as(@NotNull String variable);
		/**
		 * Reuse an existing symbolic name.
		 *
		 * @param variable A symbolic name
		 * @return A normal, ongoing read.
		 * @since 2021.0.2
		 */
		@NotNull @CheckReturnValue
		default OngoingReading as(SymbolicName variable) {
			return as(variable.getValue());
		}
	}
	/**
	 * A match that knows what to return and which is ready to be build.
	 *
	 * @since 1.0
	 */
	interface OngoingReadingAndReturn
		extends TerminalExposesOrderBy, TerminalExposesSkip, TerminalExposesLimit, BuildableStatement<ResultStatement> {
		/**
		 * @return The set of identifiable expressions in the {@literal RETURN} clause. The final statement might have a different set.
		 * @since 2021.3.2
		 */
		Collection<Expression> getIdentifiableExpressions();
	}
	/**
	 * A match that knows what to pipe to the next part of a multipart query.
	 *
	 * @since 1.0
	 */
	interface OrderableOngoingReadingAndWithWithoutWhere extends OrderableOngoingReadingAndWith {
		/**
		 * Adds a where clause to this match.
		 *
		 * @param condition The new condition, must not be {@literal null}
		 * @return A match restricted by a where clause with no return items yet.
		 */
		@NotNull @CheckReturnValue
		OrderableOngoingReadingAndWithWithWhere where(@NotNull Condition condition);
		/**
		 * Adds a where clause based on a path pattern to this match.
		 * See <a href="https://neo4j.com/docs/cypher-manual/4.0/clauses/where/#query-where-patterns">Using path patterns in WHERE</a>.
		 *
		 * @param pathPattern The path pattern to add to the where clause.
		 *                    This path pattern must not be {@literal null} and must
		 *                    not introduce new variables not available in the match.
		 * @return A match restricted by a where clause with no return items yet.
		 * @since 1.0.1
		 */
		@NotNull @CheckReturnValue
		default OrderableOngoingReadingAndWithWithWhere where(@NotNull RelationshipPattern pathPattern) {
			Assertions.notNull(pathPattern, "The path pattern must not be null.");
			return this.where(RelationshipPatternCondition.of(pathPattern));
		}
	}
	/**
	 * @see OrderableOngoingReadingAndWith
	 * @see ExposesLogicalOperators
	 * @since 1.0
	 */
	interface OrderableOngoingReadingAndWithWithWhere
		extends OrderableOngoingReadingAndWith, ExposesLogicalOperators<OrderableOngoingReadingAndWithWithWhere> {
	}
	/**
	 * Represents a reading statement ending in a with clause, potentially already having an order and not exposing
	 * order methods.
	 *
	 * @since 1.0
	 */
	interface OngoingReadingAndWith extends OngoingReading, ExposesMatch, ExposesLoadCSV {
	}
	/**
	 * @see OngoingReadingAndWith
	 * @since 1.0
	 */
	interface OrderableOngoingReadingAndWith
		extends ExposesOrderBy, ExposesSkip, ExposesLimit, OngoingReadingAndWith {
		/**
		 * @return The set of identifiable expressions in the {@literal WITH} clause. The final statement might have a different set.
		 * @since 2021.3.2
		 */
		Collection<Expression> getIdentifiableExpressions();
	}
	/**
	 * Combines the capabilities of skip, limit and adds additional expressions to the order-by items.
	 *
	 * @since 1.0
	 */
	interface OngoingMatchAndReturnWithOrder extends TerminalExposesSkip, TerminalExposesLimit, BuildableStatement<ResultStatement> {
		/**
		 * Adds another expression to the list of order items.
		 *
		 * @param expression The expression that is added with an {@literal AND}
		 * @return A new order specifying step.
		 */
		@NotNull @CheckReturnValue
		TerminalOngoingOrderDefinition and(@NotNull Expression expression);
	}
	/**
	 * An intermediate step while defining the order of a result set. This definitional will eventually return a
	 * buildable statement and thus is terminal.
	 *
	 * @since 1.0
	 */
	interface TerminalOngoingOrderDefinition extends TerminalExposesSkip, TerminalExposesLimit, BuildableStatement<ResultStatement> {
		/**
		 * Specifies descending order and jumps back to defining the match and return statement.
		 *
		 * @return The ongoing definition of a match
		 */
		@NotNull @CheckReturnValue
		OngoingMatchAndReturnWithOrder descending();
		/**
		 * Specifies ascending order and jumps back to defining the match and return statement.
		 *
		 * @return The ongoing definition of a match
		 */
		@NotNull @CheckReturnValue
		OngoingMatchAndReturnWithOrder ascending();
	}
	/**
	 * Combines the capabilities of skip, limit and adds additional expressions to the order-by items.
	 *
	 * @since 1.0
	 */
	interface OngoingReadingAndWithWithWhereAndOrder extends ExposesSkip, ExposesLimit,
		OngoingReadingAndWith {
		/**
		 * Adds another expression to the list of order items.
		 *
		 * @param expression The expression that is added with an {@literal AND}
		 * @return A new order specifying step.
		 */
		@NotNull @CheckReturnValue
		OngoingOrderDefinition and(@NotNull Expression expression);
	}
	/**
	 * An intermediate step while defining the order of a with clause.
	 *
	 * @since 1.0
	 */
	interface OngoingOrderDefinition extends ExposesSkip, ExposesLimit {
		/**
		 * Specifies descending order and jumps back to defining the match and return statement.
		 *
		 * @return The ongoing definition of a match
		 */
		@NotNull @CheckReturnValue
		OngoingReadingAndWithWithWhereAndOrder descending();
		/**
		 * Specifies ascending order and jumps back to defining the match and return statement.
		 *
		 * @return The ongoing definition of a match
		 */
		@NotNull @CheckReturnValue
		OngoingReadingAndWithWithWhereAndOrder ascending();
	}
	/**
	 * A statement that has all information required to be build and exposes a build method.
	 *
	 * @param <T> the type of the statement that is returned
	 * @since 1.0
	 */
	interface BuildableStatement<T extends Statement> {
		/**
		 * @return The statement ready to be used, i.e. in a renderer.
		 */
		@NotNull @Contract(pure = true)
		T build();
		/**
		 * @return Creates a statement that returns an explain plan for the original statement.
		 * @since 2020.1.2
		 */
		@NotNull @Contract(pure = true)
		default Statement explain() {
			return DecoratedQuery.explain(build());
		}
		/**
		 * @return Creates a profiled statement that includes both the result and the actually executed and profiled plan.
		 * @since 2020.1.2
		 */
		@NotNull @Contract(pure = true)
		default Statement profile() {
			return DecoratedQuery.profile(build());
		}
	}
	/**
	 * A step that exposes several methods to specify ordering. This is a terminal operation just before a statement
	 * is buildable.
	 *
	 * @since 1.0
	 */
	interface TerminalExposesOrderBy {
		/**
		 * Order the result set by one or more {@link SortItem sort items}. Those can be retrieved for
		 * all expression with {@link Cypher#sort(Expression)} or directly from properties.
		 *
		 * @param sortItem One or more sort items
		 * @return A build step that still offers methods for defining skip and limit
		 */
		@NotNull @CheckReturnValue
		OngoingMatchAndReturnWithOrder orderBy(SortItem... sortItem);
		/**
		 * Order the result set by one or more {@link SortItem sort items}. Those can be retrieved for
		 * all expression with {@link Cypher#sort(Expression)} or directly from properties.
		 *
		 * @param sortItem One or more sort items
		 * @return A build step that still offers methods for defining skip and limit
		 * @since 2021.2.2
		 */
		@NotNull @CheckReturnValue
		OngoingMatchAndReturnWithOrder orderBy(Collection<SortItem> sortItem);
		/**
		 * Order the result set by an expression.
		 *
		 * @param expression The expression to order by
		 * @return A step that allows for adding more expression or fine-tuning the sort direction of the last expression
		 */
		@NotNull @CheckReturnValue
		TerminalOngoingOrderDefinition orderBy(@NotNull Expression expression);
	}
	/**
	 * A step that exposes the {@link #skip(Number)} method.
	 *
	 * @since 1.0
	 */
	interface TerminalExposesSkip {
		/**
		 * Adds a skip clause, skipping the given number of records.
		 *
		 * @param number How many records to skip. If this is null, then no records are skipped.
		 * @return A step that only allows the limit of records to be specified.
		 */
		@NotNull @CheckReturnValue
		TerminalExposesLimit skip(Number number);
		/**
		 * Adds a skip clause.
		 *
		 * @param expression The expression to skip by
		 * @return A step that only allows the limit of records to be specified.
		 * @since 2021.0.0
		 */
		@NotNull @CheckReturnValue
		TerminalExposesLimit skip(Expression expression);
	}
	/**
	 * A step that exposes the {@link #limit(Number)} method.
	 *
	 * @since 1.0
	 */
	interface TerminalExposesLimit extends BuildableStatement<ResultStatement> {
		/**
		 * Limits the number of returned records.
		 *
		 * @param number How many records to return. If this is null, all the records are returned.
		 * @return A buildable match statement.
		 */
		@NotNull @CheckReturnValue
		BuildableStatement<ResultStatement> limit(Number number);
		/**
		 * Limits the number of returned records.
		 *
		 * @param expression How many records to return. If this is null, all the records are returned.
		 * @return A buildable match statement.
		 * @since 2021.0.0
		 */
		@NotNull @CheckReturnValue
		BuildableStatement<ResultStatement> limit(Expression expression);
	}
	/**
	 * Terminal operation that only allows access to {@link BuildableStatement}.
	 * A marker interface to clarify the intention instead of just exposing the {@code BuildableStatement}.
	 *
	 * @since 2024.3.0
	 */
	interface Terminal extends BuildableStatement<Statement> {
	}
	/**
	 * See {@link TerminalExposesOrderBy}, but on a with clause.
	 *
	 * @since 1.0
	 */
	interface ExposesOrderBy {
		/**
		 * Order the result set by one or more {@link SortItem sort items}. Those can be retrieved for
		 * all expression with {@link Cypher#sort(Expression)} or directly from properties.
		 *
		 * @param sortItem One or more sort items
		 * @return A build step that still offers methods for defining skip and limit
		 */
		@NotNull @CheckReturnValue
		OrderableOngoingReadingAndWithWithWhere orderBy(SortItem... sortItem);
		/**
		 * Order the result set by one or more {@link SortItem sort items}. Those can be retrieved for
		 * all expression with {@link Cypher#sort(Expression)} or directly from properties.
		 *
		 * @param sortItem One or more sort items
		 * @return A build step that still offers methods for defining skip and limit
		 * @since 2021.2.2
		 */
		@NotNull @CheckReturnValue
		OrderableOngoingReadingAndWithWithWhere orderBy(Collection<SortItem> sortItem);
		/**
		 * Order the result set by an expression.
		 *
		 * @param expression The expression to order by
		 * @return A step that allows for adding more expression or fine-tuning the sort direction of the last expression
		 */
		@NotNull @CheckReturnValue
		OngoingOrderDefinition orderBy(@NotNull Expression expression);
	}
	/**
	 * The union type of an ongoing reading with a WITH and a SKIP clause.
	 * @since 2021.0.0
	 */
	interface OngoingReadingAndWithWithSkip extends OngoingReadingAndWith, ExposesLimit {
	}
	/**
	 * A step that exposes the {@link #skip(Number)} method.
	 *
	 * @since 1.0
	 */
	interface ExposesSkip {
		/**
		 * Adds a skip clause, skipping the given number of records.
		 *
		 * @param number How many records to skip. If this is null, then no records are skipped.
		 * @return A step that only allows the limit of records to be specified.
		 */
		@NotNull @CheckReturnValue
		OngoingReadingAndWithWithSkip skip(Number number);
		/**
		 * Adds a skip clause.
		 *
		 * @param expression How many records to skip. If this is null, then no records are skipped.
		 * @return A step that only allows the limit of records to be specified.
		 * @since 2021.0.0
		 */
		@NotNull @CheckReturnValue
		OngoingReadingAndWithWithSkip skip(Expression expression);
	}
	/**
	 * A step that exposes the {@link #limit(Number)} method.
	 *
	 * @since 1.0
	 */
	interface ExposesLimit {
		/**
		 * Limits the number of returned records.
		 *
		 * @param number How many records to return. If this is null, all the records are returned.
		 * @return A buildable match statement.
		 */
		@NotNull @CheckReturnValue
		OngoingReadingAndWith limit(Number number);
		/**
		 * Limits the number of returned records.
		 *
		 * @param expression How many records to return. If this is null, all the records are returned.
		 * @return A buildable match statement.
		 * @since 2021.0.0
		 */
		@NotNull @CheckReturnValue
		OngoingReadingAndWith limit(Expression expression);
	}
	/**
	 * Steps for building a {@link Foreach} clause.
	 * @since 2023.4.0
	 */
	interface ExposesForeach {
		/**
		 * Starts defining a {@link Foreach} clause
		 *
		 * @param variable the variable to use in the iterator
		 * @return A step for selecting the source of iteration
		 * @since 2023.4.0
		 */
		@NotNull
		@Contract(pure = true)
		ForeachSourceStep foreach(SymbolicName variable);
	}
	/**
	 * Initial step of defining a {@link Foreach FOREACH-clause}.
	 *
	 * @since 2023.4.0
	 */
	sealed interface ForeachSourceStep permits DefaultStatementBuilder.ForeachBuilder {
		/**
		 * Defines the source to be iterated by {@code FOREACH}. Must evaluate to something iterable, for example something like
		 * {@link Cypher#nodes(NamedPath)} for
		 *
		 * @param list The expression to iterate on
		 * @return The next step.
		 */
		ForeachUpdateStep in(Expression list);
	}
	/**
	 * Second step of defining a {@link Foreach FOREACH-clause} in which the updating clause is defined.
	 *
	 * @since 2023.4.0
	 */
	sealed interface ForeachUpdateStep permits DefaultStatementBuilder.ForeachBuilder {
		/**
		 * Defines the updating clause that to will be applied to every item in the source expression.
		 *
		 * @param updatingClauses The updating clauses to apply
		 * @return The final {@link Foreach} clause
		 */
		OngoingUpdate apply(UpdatingClause... updatingClauses);
	}
	/**
	 * A step providing all the supported updating clauses (DELETE, SET)
	 *
	 * @since 1.0
	 */
	interface ExposesUpdatingClause extends ExposesDelete, ExposesMerge, ExposesSetAndRemove, ExposesForeach {
	}
	/**
	 * A step that exposes only the {@code DELETE} clause.
	 *
	 * @since 1.0
	 */
	interface ExposesDelete {
		/**
		 * Renders a {@code DELETE} clause targeting the given variables. NO checks are done whether they have been matched
		 * previously.
		 *
		 * @param variables Variables indicating the things to delete.
		 * @return A match with a {@literal DELETE} clause that can be build now
		 */
		@NotNull @CheckReturnValue
		@SuppressWarnings("deprecation")
		default OngoingUpdate delete(String... variables) {
			return delete(Expressions.createSymbolicNames(variables));
		}
		/**
		 * Renders a {@code DELETE} clause targeting the given variables. NO checks are done whether they have been matched
		 * previously.
		 *
		 * @param variables Variables indicating the things to delete.
		 * @return A match with a {@literal DELETE} clause that can be build now
		 */
		@NotNull @CheckReturnValue
		@SuppressWarnings("deprecation")
		default OngoingUpdate delete(Named... variables) {
			return delete(Expressions.createSymbolicNames(variables));
		}
		/**
		 * Creates a delete step with one or more expressions to be deleted.
		 *
		 * @param expressions The expressions to be deleted.
		 * @return A match with a {@literal DELETE} clause that can be build now
		 */
		@NotNull @CheckReturnValue
		OngoingUpdate delete(Expression... expressions);
		/**
		 * Creates a delete step with one or more expressions to be deleted.
		 *
		 * @param expressions The expressions to be deleted.
		 * @return A match with a {@literal DELETE} clause that can be build now
		 * @since 2021.2.2
		 */
		@NotNull @CheckReturnValue
		OngoingUpdate delete(Collection<? extends Expression> expressions);
		/**
		 * Renders a {@code DETACH DELETE} clause targeting the given variables. NO checks are done whether they have
		 * been matched previously.
		 *
		 * @param variables Variables indicating the things to delete.
		 * @return A match with a {@literal DETACH DELETE} clause that can be build now
		 */
		@NotNull @CheckReturnValue
		@SuppressWarnings("deprecation")
		default OngoingUpdate detachDelete(String... variables) {
			return detachDelete(Expressions.createSymbolicNames(variables));
		}
		/**
		 * Renders a {@code DETACH DELETE} clause targeting the given variables. NO checks are done whether they have
		 * been matched previously.
		 *
		 * @param variables Variables indicating the things to delete.
		 * @return A match with a {@literal DETACH DELETE} clause that can be build now
		 */
		@NotNull @CheckReturnValue
		@SuppressWarnings("deprecation")
		default OngoingUpdate detachDelete(Named... variables) {
			return detachDelete(Expressions.createSymbolicNames(variables));
		}
		/**
		 * Starts building a delete step that will use {@code DETACH} to remove relationships.
		 *
		 * @param expressions The expressions to be deleted.
		 * @return A match with {@literal DETACH DELETE} clause that can be build now
		 */
		@NotNull @CheckReturnValue
		OngoingUpdate detachDelete(Expression... expressions);
		/**
		 * Starts building a delete step that will use {@code DETACH} to remove relationships.
		 *
		 * @param expressions The expressions to be deleted.
		 * @return A match with {@literal DETACH DELETE} clause that can be build now
		 * @since 2021.2.2
		 */
		@NotNull @CheckReturnValue
		OngoingUpdate detachDelete(Collection<? extends Expression> expressions);
	}
	/**
	 * Set part of a statement.
	 *
	 * @since 1.0
	 */
	interface ExposesSet {
		/**
		 * Adds a {@code SET} clause to the statement. The list of expressions must be even, each pair will be turned into
		 * SET operation.
		 *
		 * @param expressions The list of expressions to use in a set clause.
		 * @return An ongoing match and update
		 */
		@NotNull @CheckReturnValue
		BuildableMatchAndUpdate set(Expression... expressions);
		/**
		 * Adds a {@code SET} clause to the statement. The list of expressions must be even, each pair will be turned into
		 * SET operation.
		 *
		 * @param expressions The list of expressions to use in a set clause.
		 * @return An ongoing match and update
		 * @since 2021.2.2
		 */
		@NotNull @CheckReturnValue
		BuildableMatchAndUpdate set(Collection<? extends Expression> expressions);
		/**
		 * Adds a {@code SET} clause to the statement, modifying the given named thing with an expression.
		 *
		 * @param variable   The named thing to modify
		 * @param expression The modifying expression
		 * @return An ongoing match and update
		 */
		@NotNull @CheckReturnValue
		default BuildableMatchAndUpdate set(Named variable, Expression expression) {
			return set(variable.getRequiredSymbolicName(), expression);
		}
		/**
		 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
		 * of properties and the right hand side must be a map of new or updated properties
		 *
		 * @param target The target container that should be modified
		 * @param properties  The new properties
		 * @return An ongoing match and update
		 * @since 2020.1.5
		 */
		@NotNull @CheckReturnValue
		BuildableMatchAndUpdate mutate(Expression target, Expression properties);
		/**
		 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
		 * of properties and the right hand side must be a map of new or updated properties
		 *
		 * @param variable  The named thing to modify
		 * @param properties  The new properties
		 * @return An ongoing match and update
		 * @since 2020.1.5
		 */
		@NotNull @CheckReturnValue
		default BuildableMatchAndUpdate mutate(Named variable, Expression properties) {
			return mutate(variable.getRequiredSymbolicName(), properties);
		}
	}
	/**
	 * Exposes node mutations.
	 *
	 * @param <R> The type of the next step
	 * @since 2023.5.0
	 */
	interface ExposesSetLabel<R> {
		/**
		 * Creates {@code SET} clause for setting the given labels to a node.
		 *
		 * @param node   The node whose labels are to be changed
		 * @param labels The labels to be set
		 * @return A match with a SET clause that can be build now
		 */
		@NotNull @CheckReturnValue
		R set(Node node, String... labels);
		/**
		 * Creates {@code SET} clause for setting the given labels to a node.
		 *
		 * @param node   The node whose labels are to be changed
		 * @param labels The labels to be set
		 * @return A match with a SET clause that can be build now
		 * @since 2021.2.2
		 */
		@NotNull @CheckReturnValue
		R set(Node node, Collection<String> labels);
	}
	/**
	 * A step that exposes the set clause.
	 *
	 * @since 1.0
	 */
	interface ExposesSetAndRemove extends ExposesSet, ExposesSetLabel<BuildableMatchAndUpdate> {
		/**
		 * Creates {@code SET} clause for removing the given labels from a node.
		 *
		 * @param node   The node whose labels are to be changed
		 * @param labels The labels to be removed
		 * @return A match with a REMOVE clause that can be build now
		 */
		@NotNull @CheckReturnValue
		BuildableMatchAndUpdate remove(Node node, String... labels);
		/**
		 * Creates {@code SET} clause for removing the given labels from a node.
		 *
		 * @param node   The node whose labels are to be changed
		 * @param labels The labels to be removed
		 * @return A match with a REMOVE clause that can be build now
		 * @since 2021.2.2
		 */
		@NotNull @CheckReturnValue
		BuildableMatchAndUpdate remove(Node node, Collection<String> labels);
		/**
		 * Creates {@code SET} clause for removing the enumerated properties
		 *
		 * @param properties The properties to be removed
		 * @return A match with a REMOVE clause that can be build now
		 */
		@NotNull @CheckReturnValue
		BuildableMatchAndUpdate remove(Property... properties);
		/**
		 * Creates {@code SET} clause for removing the enumerated properties
		 *
		 * @param properties The properties to be removed
		 * @return A match with a REMOVE clause that can be build now
		 * @since 2021.2.2
		 */
		@NotNull @CheckReturnValue
		BuildableMatchAndUpdate remove(Collection<Property> properties);
	}
	/**
	 * After a MATCH..UPDATE chain has been established, a RETURN can be added, a pipeline with WITH can be started
	 * or more mutating steps can be added.
	 *
	 * @since 1.0
	 */
	interface OngoingMatchAndUpdate extends ExposesReturning, ExposesFinish, ExposesWith, ExposesUpdatingClause, ExposesCreate {
	}
	/**
	 * A buildable ongoing MATCH and UPDATE.
	 *
	 * @since 2021.0.0
	 */
	interface BuildableMatchAndUpdate extends OngoingMatchAndUpdate, BuildableStatement<Statement> {
	}
	/**
	 * Provides a way to specify an action that happens after a {@code MERGE} clause.
	 *
	 * @since 2020.1.2
	 */
	interface ExposesMergeAction {
		/**
		 * This allows to specify the action that should happen when the merge clause lead to the creation of a new pattern.
		 *
		 * @return an ongoing definition of a merge action.
		 */
		@NotNull @CheckReturnValue
		OngoingMergeAction onCreate();
		/**
		 * This allows to specify the action that should happen when the pattern of the merge clause already existed and matched.
		 *
		 * @return an ongoing definition of a merge action.
		 */
		@NotNull @CheckReturnValue
		OngoingMergeAction onMatch();
	}
	/**
	 * An interface combining a buildable MATCH and UPDATE with the possibility to add actions after a MERGE clause.
	 * @since 2021.0.0
	 */
	interface BuildableOngoingMergeAction extends BuildableMatchAndUpdate, ExposesMergeAction {
	}
	/**
	 * A variant of {@link ExposesSet} that allows for further chaining of actions.
	 *
	 * @since 2020.1.2
	 */
	interface OngoingMergeAction extends ExposesSetLabel<BuildableOngoingMergeAction> {
		/**
		 * Adds a {@code SET} clause to the statement. The list of expressions must be even, each pair will be turned into
		 * SET operation.
		 *
		 * @param expressions The list of expressions to use in a set clause.
		 * @return An ongoing match and update
		 */
		@NotNull @CheckReturnValue
		BuildableOngoingMergeAction set(Expression... expressions);
		/**
		 * Adds a {@code SET} clause to the statement. The list of expressions must be even, each pair will be turned into
		 * SET operation.
		 *
		 * @param expressions The list of expressions to use in a set clause.
		 * @return An ongoing match and update
		 * @since 2021.2.2
		 */
		@NotNull @CheckReturnValue
		BuildableOngoingMergeAction set(Collection<? extends Expression> expressions);
		/**
		 * Adds a {@code SET} clause to the statement, modifying the given named thing with an expression.
		 *
		 * @param variable   The named thing to modify
		 * @param expression The modifying expression
		 * @return An ongoing match and update
		 */
		@NotNull @CheckReturnValue
		default BuildableOngoingMergeAction set(Named variable, Expression expression) {
			return set(variable.getRequiredSymbolicName(), expression);
		}
		/**
		 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
		 * of properties and the right hand side must be a map of new or updated properties
		 *
		 * @param target The target container that should be modified
		 * @param properties  The new properties
		 * @return An ongoing match and update
		 * @since 2020.1.5
		 */
		@NotNull @CheckReturnValue
		BuildableOngoingMergeAction mutate(Expression target, Expression properties);
		/**
		 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
		 * of properties and the right hand side must be a map of new or updated properties
		 *
		 * @param variable  The named thing to modify
		 * @param properties  The new properties
		 * @return An ongoing match and update
		 * @since 2020.1.5
		 */
		@NotNull @CheckReturnValue
		default BuildableOngoingMergeAction mutate(Named variable, Expression properties) {
			return mutate(variable.getRequiredSymbolicName(), properties);
		}
	}
	/**
	 * A trait for an ongoing standalone call to expose all of its results via an asterisk.
	 *
	 * @since 2022.8.3
	 */
	interface ExposesYieldStar {
		/**
		 * Mostly a helper method to indicate the overload as {@link org.neo4j.cypherdsl.core.ExposesCall.ExposesYield}
		 * uses vargs for all overloads, and that would not work nicely without arguments on this one here.
		 *
		 * Allows to use a {@literal *} in this standalone call.
		 * @param asterisk The actual * ;)
		 * @return The ongoing standalone call to be configured.
		 * @since 2022.8.0
		 */
		OngoingStandaloneCallWithReturnFields yield(Asterisk asterisk);
		/**
		 * Convenience method to yield all items of this standalone call.
		 * @return The ongoing standalone call to be configured.
		 * @since 2022.8.0
		 */
		default OngoingStandaloneCallWithReturnFields yieldStar() {
			return this.yield(Cypher.asterisk());
		}
	}
	/**
	 * The union of a buildable statement and call exposing new arguments and yields.
	 */
	interface OngoingStandaloneCallWithoutArguments extends
		StatementBuilder.BuildableStatement<Statement>, ExposesCall.ExposesWithArgs<OngoingStandaloneCallWithArguments>,
		ExposesCall.ExposesYield<OngoingStandaloneCallWithReturnFields>, ExposesCall.AsFunction, ExposesYieldStar {
		/**
		 * Turn this call into a void call to continue with querying
		 *
		 * @return the call, continue with a normal query from here.
		 * @since 2022.4.0
		 */
		VoidCall withoutResults();
	}
	/**
	 * The union of a buildable statement and call exposing yields.
	 */
	interface OngoingStandaloneCallWithArguments extends
		StatementBuilder.BuildableStatement<Statement>,
		ExposesCall.ExposesYield<OngoingStandaloneCallWithReturnFields>, ExposesCall.AsFunction, ExposesYieldStar {
		/**
		 * Turn this call into a void call to continue with querying
		 *
		 * @return the call, continue with a normal query from here.
		 * @since 2022.4.0
		 */
		VoidCall withoutResults();
	}
	/**
	 * A buildable statement exposing where and return clauses.
	 */
	sealed interface OngoingStandaloneCallWithReturnFields extends
		StatementBuilder.BuildableStatement<Statement>,
		ExposesMatch,
		ExposesWhere<StatementBuilder.OngoingReadingWithWhere>,
		ExposesReturning, ExposesFinish, ExposesWith, ExposesSubqueryCall,
		ExposesAndThen<OngoingStandaloneCallWithReturnFields, Statement>
		permits DefaultStatementBuilder.YieldingStandaloneCallBuilder {
	}
	/**
	 * The union of an in-query call exposing new arguments and yields.
	 */
	interface OngoingInQueryCallWithoutArguments extends
		ExposesCall.ExposesWithArgs<OngoingInQueryCallWithArguments>,
		ExposesCall.ExposesYield<OngoingInQueryCallWithReturnFields> {
		/**
		 * Turn this call into a void call to continue with querying
		 *
		 * @return the call, continue with a normal query from here.
		 * @since 2022.4.0
		 */
		VoidCall withoutResults();
	}
	/**
	 * The union of an in-query call exposing yields.
	 */
	interface OngoingInQueryCallWithArguments extends
		ExposesCall.ExposesYield<OngoingInQueryCallWithReturnFields> {
		/**
		 * Turn this call into a void call to continue with querying
		 *
		 * @return the call, continue with a normal query from here.
		 * @since 2022.4.0
		 */
		VoidCall withoutResults();
	}
	/**
	 * The result of a call to a stored procedure not having any results. It is possible to continue with "normal"
	 * querying after the execution of such a procedure.
	 *
	 * @since 2022.4.0
	 */
	interface VoidCall extends OngoingReading {
	}
	/**
	 * An in-query call exposing where and return clauses.
	 */
	interface OngoingInQueryCallWithReturnFields extends
		ExposesMatch, ExposesWhere<StatementBuilder.OngoingReadingWithWhere>, ExposesReturning, ExposesFinish, ExposesWith, ExposesSubqueryCall, ExposesForeach {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.annotations.CheckReturnValue;
import java.util.Arrays;
import java.util.Collection;
/**
 * Return part of a statement.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface ExposesReturning {
	/**
	 * Creates the {@code RETURN} clause. All variables passed via {@code variables} must be valid
	 * {@link SymbolicName symbolic names}. {@link Expression#property(String...)} must be used to return single properties.
	 *
	 * @param variables The named things to return
	 * @return A build step with a defined list of things to return.
	 */
	@NotNull @CheckReturnValue
	@SuppressWarnings("deprecation")
	default StatementBuilder.OngoingReadingAndReturn returning(String... variables) {
		return returning(Expressions.createSymbolicNames(variables));
	}
	/**
	 * Creates the {@code RETURN} clause.
	 *
	 * @param variables The named things to return
	 * @return A build step with a defined list of things to return.
	 */
	@NotNull @CheckReturnValue
	@SuppressWarnings("deprecation")
	default StatementBuilder.OngoingReadingAndReturn returning(Named... variables) {
		return returning(Expressions.createSymbolicNames(variables));
	}
	/**
	 * Create a match that returns one or more expressions.
	 *
	 * @param expressions The expressions to be returned. Must not be null and be at least one expression.
	 * @return A match that can be build now
	 */
	@NotNull @CheckReturnValue
	default StatementBuilder.OngoingReadingAndReturn returning(Expression... expressions) {
		return returning(expressions == null ? null : Arrays.asList(expressions));
	}
	/**
	 * Create a match that returns one or more expressions.
	 *
	 * @param expressions The expressions to be returned. Must not be null and be at least one expression.
	 * @return A match that can be build now
	 */
	@NotNull @CheckReturnValue
	StatementBuilder.OngoingReadingAndReturn returning(Collection<? extends Expression> expressions);
	/**
	 * Creates a {@code RETURN} clause containing the {@code DISTINCT} keyword. All variables passed via {@code variables}
	 * must be valid {@link SymbolicName symbolic names}. {@link Expression#property(String...)} must be used to return
	 * single properties.
	 *
	 * @param variables The variables to return
	 * @return A build step with a defined list of things to return.
	 */
	@NotNull @CheckReturnValue
	@SuppressWarnings("deprecation")
	default StatementBuilder.OngoingReadingAndReturn returningDistinct(String... variables) {
		return returningDistinct(Expressions.createSymbolicNames(variables));
	}
	/**
	 * Creates a {@code RETURN} clause containing the {@code DISTINCT} keyword.
	 *
	 * @param variables The named things to return
	 * @return A build step with a defined list of things to return.
	 */
	@NotNull @CheckReturnValue
	@SuppressWarnings("deprecation")
	default StatementBuilder.OngoingReadingAndReturn returningDistinct(Named... variables) {
		return returningDistinct(Expressions.createSymbolicNames(variables));
	}
	/**
	 * Creates a {@code RETURN} clause returning the distinct set of one or more expressions.
	 *
	 * @param expressions The expressions to be returned. Must not be null and be at least one expression.
	 * @return A match that can be build now
	 */
	@NotNull @CheckReturnValue
	default StatementBuilder.OngoingReadingAndReturn returningDistinct(Expression... expressions) {
		return returningDistinct(expressions == null ? null : Arrays.asList(expressions));
	}
	/**
	 * Creates a {@code RETURN} clause returning the distinct set of one or more expressions.
	 *
	 * @param expressions The expressions to be returned. Must not be null and be at least one expression.
	 * @return A match that can be build now
	 */
	@NotNull @CheckReturnValue
	StatementBuilder.OngoingReadingAndReturn returningDistinct(Collection<? extends Expression> expressions);
	/**
	 * Creates a {@code RETURN} clause from a raw Cypher expression created via {@link Cypher#raw(String, Object...)}.
	 * The expression maybe aliased but it must resolve to a raw element
	 *
	 * @param rawExpression Must be a plain raw or an aliased raw expression. To eventually render as valid Cypher, it must
	 *                      contain the {@code RETURN} keyword.
	 * @return A match that can be build now
	 * @since 2021.2.1
	 */
	@NotNull @CheckReturnValue
	StatementBuilder.OngoingReadingAndReturn returningRaw(Expression rawExpression);
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.StatementBuilder.OngoingStandaloneCallWithoutArguments;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.internal.LoadCSV;
import org.neo4j.cypherdsl.core.internal.ProcedureName;
import org.neo4j.cypherdsl.core.internal.UsingPeriodicCommit;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * Shall be the common interfaces for queries that we support.
 * <p>
 * For reference see: <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/Cypher.html">Cypher</a>.
 * We have skipped the intermediate "Query" structure so a statement in the context of this generator is either a
 * {@link RegularQuery} or a {@code StandaloneCall}.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface Statement extends Visitable {
	/**
	 * @return A new statement builder.
	 */
	@NotNull @Contract(pure = true)
	static StatementBuilder builder() {
		return new DefaultStatementBuilder();
	}
	/**
	 * Creates a statement based on a list of {@link Clause clauses}. It is your task to provide a sanity check of the
	 * clauses. The builder will use the clauses "as is", neither change their order nor their type.
	 *
	 * @param clauses A list of clauses, must not be null
	 * @return A statement
	 * @since 2021.3.0
	 */
	@NotNull
	static Statement of(@NotNull List<Clause> clauses) {
		Assertions.notNull(clauses, "Clauses must not be null.");
		return new ClausesBasedStatement(clauses, null);
	}
	/**
	 * Creates a statement based on a list of {@link Clause clauses} and prepends it with {@literal USING PERIODIC COMMIT}.
	 * It is your task to provide a sanity check of the clauses. The builder will use the clauses "as is",
	 * neither change their order nor their type.
	 * <p>
	 * The {@literal USING PERIODIC HINT} is only valid right before the {@literal LOAD CSV clause}.
	 *
	 * @param batchSize The batch size to pass to {@literal PERIODIC COMMIT}.
	 * @param clauses   A list of clauses, must not be null
	 * @return A statement
	 * @since 2021.3.0
	 */
	@API(status = STABLE, since = "2021.3.0")
	@NotNull
	static Statement usingPeriodic(Integer batchSize, @NotNull List<Clause> clauses) {
		Assertions.notNull(clauses, "Clauses must not be null.");
		Assertions.isTrue(!clauses.isEmpty(), "Clauses must not be empty.");
		Assertions.isInstanceOf(LoadCSV.class, clauses.get(0), "First clause must be a LOAD CSV clause.");
		return new ClausesBasedStatement(clauses, new UsingPeriodicCommit(batchSize));
	}
	/**
	 * @param namespaceAndProcedure The fully qualified name of a stored procedure. Each part can be given as a separate
	 *                              String, but a fully qualified String is ok as well.
	 * @return An entry point into a statement that starts with a call to stored procedure.
	 */
	@NotNull @Contract(pure = true)
	static OngoingStandaloneCallWithoutArguments call(String... namespaceAndProcedure) {
		return new DefaultStatementBuilder.StandaloneCallBuilder(ProcedureName.from(namespaceAndProcedure));
	}
	/**
	 * Analyzes the statement and provides access to the resolved properties, their (potential) owners and the context
	 * in which they have been resolved. Identifiable expressions may be retrieved via {@link StatementCatalog#getIdentifiableExpressions()}.
	 *
	 * @return An immutable object representing properties resolved in a statement together with their context and owner
	 * @since 2023.1.0
	 */
	@NotNull @Contract(pure = true)
	StatementCatalog getCatalog();
	/**
	 * This method uses the default renderer to create a String representation of this statement. The generated Cypher
	 * will use escaped literals and correct placeholders like {@code $param} for parameters. The placeholders for
	 * parameters can be retrieved via {@link StatementCatalog#getParameterNames}. Bounded values for parameters can be
	 * retrieved via {@link StatementCatalog#getParameters()}.
	 * <p>
	 * This method is thread safe.
	 *
	 * @return A valid Cypher statement
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	String getCypher();
	/**
	 * @return The context of this statement, allowing access to parameter names etc.
	 */
	@API(status = INTERNAL, since = "2021.0.0")
	@NotNull @Contract(pure = true)
	StatementContext getContext();
	/**
	 * Some constants may be rendered as parameters.
	 *
	 * @return True if literal parameters hav
	 */
	@Contract(pure = true)
	boolean isRenderConstantsAsParameters();
	/**
	 * Use this method to configure whether some constant values should be rendered as parameters or as literals before
	 * the first call to {@link StatementCatalog#getParameters()} or {@link Statement#getCypher()}.
	 * <p>
	 * Renderers are free to chose to ignore this.
	 *
	 * @param renderConstantsAsParameters Set to true to render constants as parameters (when using {@link #getCypher()}.
	 */
	void setRenderConstantsAsParameters(boolean renderConstantsAsParameters);
	/**
	 * Represents {@code RegularQuery}.
	 *
	 * @since 1.0
	 */
	interface RegularQuery extends Statement {
	}
	/**
	 * Represents a {@code SingleQuery}.
	 *
	 * @since 1.0
	 */
	interface SingleQuery extends RegularQuery {
	}
	/**
	 * Represents a {@code UnionQuery}.
	 *
	 * @since 2023.0.0
	 */
	sealed interface UnionQuery extends RegularQuery permits UnionQueryImpl {
	}
	/**
	 * Represents a {@code USE} statement, utilizing a composite graph call. A statement utilizing composite databases
	 * might use an {@code EXPLAIN} clause but cannot be profiled (as of Neo4j 5.3).
	 *
	 * @since 2023.0.0
	 */
	sealed interface UseStatement extends Statement permits DecoratedQuery {
		/**
		 * @return Creates a statement that returns an explain plan for the original statement.
		 */
		@NotNull @Contract(pure = true)
		default Statement explain() {
			return DecoratedQuery.explain(this);
		}
	}
	/**
	 * @return True if this statement can be assured to return something.
	 */
	default boolean doesReturnOrYield() {
		return this instanceof ResultStatement || this instanceof UnionQueryImpl;
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.EnterResult;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * A concrete condition representing a comparision between two expressions.
 *
 * @author Michael J. Simons
 * @author Gerrit Meier
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class Comparison implements Condition {
	static Comparison create(Operator operator, Expression expression) {
		Assertions.isTrue(operator.isUnary(), "Operator must be unary.");
		Assertions.notNull(expression, "Expression must not be null.");
		return switch (operator.getType()) {
			case PREFIX -> new Comparison(null, operator, expression);
			case POSTFIX -> new Comparison(expression, operator, null);
			default -> throw new IllegalArgumentException("Invalid operator type " + operator.getType());
		};
	}
	static Comparison create(Expression lhs, Operator operator, Expression rhs) {
		Assertions.notNull(lhs, "Left expression must not be null.");
		Assertions.notNull(operator, "Operator must not be empty.");
		Assertions.notNull(rhs, "Right expression must not be null.");
		return new Comparison(lhs, operator, rhs);
	}
	private static Expression nestedIfCondition(Expression expression) {
		return expression instanceof Condition ? new NestedExpression(expression) : expression;
	}
	private final Expression left;
	private final Operator comparator;
	private final Expression right;
	private Comparison(Expression left, Operator operator, Expression right) {
		this.left = nestedIfCondition(left);
		this.comparator = operator;
		this.right = nestedIfCondition(right);
	}
	@Override
	@SuppressWarnings("deprecation")
	public void accept(Visitor visitor) {
		EnterResult result = visitor.enterWithResult(this);
		if (result == EnterResult.CONTINUE) {
			if (left != null) {
				Expressions.nameOrExpression(left).accept(visitor);
			}
			comparator.accept(visitor);
			if (right != null) {
				Expressions.nameOrExpression(right).accept(visitor);
			}
		}
		visitor.leave(this);
	}
	@NotNull
	@Override
	public Condition not() {
		if (this.comparator == Operator.IS_NULL) {
			return new Comparison(left, Operator.IS_NOT_NULL, right);
		} else if (this.comparator == Operator.IS_NOT_NULL) {
			return new Comparison(left, Operator.IS_NULL, right);
		}
		return Condition.super.not();
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
/**
 * Something that can build counting sub-queries. Might be used in the future for existential sub-queries, too.
 *
 * @since 2023.9.0
 */
@API(status = STABLE, since = "2023.9.0")
public interface SubqueryExpressionBuilder {
	/**
	 * Creates a {@literal COUNT} sub-query expressions from at least one pattern.
	 *
	 * @param requiredPattern One pattern is required
	 * @param patternElement  Optional pattern
	 * @return The immutable {@link CountExpression}
	 * @since 2023.9.0
	 */
	@NotNull
	CountExpression count(PatternElement requiredPattern, PatternElement... patternElement);
	/**
	 * Creates a {@literal COUNT} with an inner {@literal UNION} sub-query.
	 *
	 * @param union The union that will be the source of the {@literal COUNT} sub-query
	 * @return The immutable {@link CountExpression}
	 * @since 2023.9.0
	 */
	@NotNull
	CountExpression count(Statement.UnionQuery union);
	/**
	 * Creates a {@literal COLLECT} subquery from a statement, including  its filters and conditions. The statement must
	 * return exactly one column. It must however not contain any updates. While it would render syntactically
	 * correct Cypher, Neo4j does not support updates inside counting sub-queries.
	 * <p>
	 * To avoid confusion, shadowing of imported variables is not allowed. An outside scope variable is shadowed when
	 * a newly introduced variable within the inner scope is defined with the same variable.
	 *
	 * @param statement the statement to be passed to {@code COLLECT{}}
	 * @return a collecting sub-query.
	 * @since 2023.9.0
	 */
	CollectExpression collect(Statement statement);
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * Implementing <a href="https://neo4j.com/docs/cypher-manual/current/subqueries/collect/">COLLECT subqueries</a>
 *
 * @author Michael J. Simons
 * @soundtrack The Cross - Blue Rock
 * @since 2023.8.0
 */
@API(status = STABLE, since = "2023.0.0")
@Neo4jVersion(minimum = "5.6")
public final class CollectExpression implements SubqueryExpression {
	private final ImportingWith optionalWith;
	private final Statement resultStatement;
	static CollectExpression collect(Statement statement, IdentifiableElement... imports) {
		return new CollectExpression(ImportingWith.of(imports), statement);
	}
	static CollectExpression collect(Statement resultStatement) {
		return new CollectExpression(new ImportingWith(), resultStatement);
	}
	static CollectExpression collect(@Nullable With optionalWith, Statement resultStatement) {
		return new CollectExpression(new ImportingWith(optionalWith, null), resultStatement);
	}
	private CollectExpression(ImportingWith optionalWith, Statement resultStatement) {
		this.optionalWith = optionalWith;
		this.resultStatement = resultStatement;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.optionalWith.accept(visitor);
		this.resultStatement.accept(visitor);
		visitor.leave(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * Added for supporting the Neo5j parser.
 *
 * @author Michael J. Simons
 * @soundtrack The Prodigy - Invaders Must Die
 * @since 2023.0.0
 */
@API(status = STABLE, since = "2023.0.0")
@Neo4jVersion(minimum = "5.0")
public final class CountExpression implements SubqueryExpression, ExposesWhere<Expression> {
	private final ImportingWith importingWith;
	private final List<Visitable> fragments;
	@Nullable
	private final Where innerWhere;
	static CountExpression count(Statement statement, IdentifiableElement... imports) {
		return new CountExpression(ImportingWith.of(imports), List.of(statement), null);
	}
	static CountExpression count(Visitable patternOrUnion) {
		return new CountExpression(new ImportingWith(), List.of(patternOrUnion), null);
	}
	static CountExpression count(@Nullable With optionalWith, Visitable patternOrUnion) {
		return new CountExpression(new ImportingWith(optionalWith, null), List.of(patternOrUnion), null);
	}
	static CountExpression count(List<PatternElement> patternElements, @Nullable Where innerWhere) {
		return new CountExpression(new ImportingWith(), patternElements, innerWhere);
	}
	private CountExpression(ImportingWith optionalWith, List<? extends Visitable> fragments, @Nullable Where innerWhere) {
		var patternOrUnion = fragments.size() == 1 ? fragments.get(0) : null;
		if (patternOrUnion instanceof Statement.UnionQuery && innerWhere != null) {
			throw new IllegalArgumentException("Cannot use a UNION with a WHERE clause inside a COUNT {} expression");
		}
		this.importingWith = optionalWith;
		var imports = optionalWith.imports();
		if (imports != null && patternOrUnion instanceof Pattern pattern) {
			this.fragments = List.of(new Match(false, pattern, innerWhere, null));
			this.innerWhere = null;
		} else if (imports != null && patternOrUnion instanceof Match match) {
			this.fragments = List.of(new Match(false, match.pattern, innerWhere, null));
			this.innerWhere = null;
		} else {
			this.fragments = List.copyOf(fragments);
			this.innerWhere = innerWhere;
		}
	}
	/**
	 * Creates a new {@link CountExpression count expression} with additional conditions
	 *
	 * @param condition the condition to apply in the count expression
	 * @return A new {@link CountExpression}
	 */
	@NotNull @Contract(pure = true)
	public CountExpression where(Condition condition) {
		if (fragments.size() == 1 && fragments.get(0) instanceof Statement) {
			throw new IllegalArgumentException(
				"This count expression is build upon a full statement, adding a condition to it is not supported.");
		}
		return new CountExpression(importingWith, fragments, new Where(condition));
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		importingWith.accept(visitor);
		fragments.forEach(v -> v.accept(visitor));
		Visitable.visitIfNotNull(innerWhere, visitor);
		visitor.leave(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
/**
 * A pattern is something that can be matched. It consists of one or more pattern elements. Those can be nodes or chains
 * of nodes and relationships.
 * <p>
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/Pattern.html">Pattern</a>.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = INTERNAL, since = "1.0")
final class Pattern extends TypedSubtree<PatternElement> {
	static Pattern of(PatternElement requiredPattern, PatternElement... patternElement) {
		List<PatternElement> elements;
		if (patternElement == null || patternElement.length == 0) {
			elements = List.of(requiredPattern);
		} else {
			elements = new ArrayList<>();
			elements.add(requiredPattern);
			elements.addAll(Arrays.asList(patternElement));
		}
		return Pattern.of(elements);
	}
	static Pattern of(Collection<? extends PatternElement> elements) {
		return new Pattern(elements.stream().map(PatternElement.class::cast).toList());
	}
	private Pattern(List<PatternElement> patternElements) {
		super(patternElements);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.List;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.EnterResult;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.Distinct;
/**
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/With.html">With</a>.
 *
 * @author Michael J. Simons
 * @soundtrack Ferris MC - Ferris MC's Audiobiographie
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class With implements Visitable, Clause {
	private final Distinct distinct;
	private final ReturnBody body;
	private final Where where;
	With(Return returnClause, Where where) {
		this.distinct = returnClause.getDistinct();
		this.body = returnClause.getBody();
		this.where = where;
	}
	With(boolean distinct, ExpressionList returnItems, Order order, Skip skip, Limit limit, Where where) {
		this.distinct = distinct ? Distinct.INSTANCE : null;
		this.body = new ReturnBody(returnItems, order, skip, limit);
		this.where = where;
	}
	@Override
	public void accept(Visitor visitor) {
		if (visitor.enterWithResult(this) == EnterResult.CONTINUE) {
			Visitable.visitIfNotNull(this.distinct, visitor);
			this.body.accept(visitor);
			Visitable.visitIfNotNull(where, visitor);
		}
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
	@API(status = INTERNAL)
	public List<Expression> getItems() {
		return body.getReturnItems();
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class NestedExpression implements Expression {
	private final Expression delegate;
	NestedExpression(Expression delegate) {
		this.delegate = delegate;
	}
	@Override
	@SuppressWarnings("deprecation")
	public void accept(Visitor visitor) {
		visitor.enter(this);
		Expressions.nameOrExpression(this.delegate).accept(visitor);
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.List;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
/**
 * Represents a list of expressions. When visited, the expressions are treated as named expression if they have declared
 * a symbolic name as variable or as unnamed expression when nameless.
 * <p>
 * Not to be mixed up with the actual {@link ListExpression}, which itself is an expression.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
class ExpressionList extends TypedSubtree<Expression> {
	ExpressionList(List<Expression> returnItems) {
		super(returnItems);
	}
	ExpressionList(Expression... children) {
		super(children);
	}
	@Override
	@SuppressWarnings("deprecation")
	protected Visitable prepareVisit(Expression child) {
		return Expressions.nameOrExpression(child);
	}
	boolean isEmpty() {
		return super.children.isEmpty();
	}
	@Override
	protected List<Expression> getChildren() {
		return super.getChildren();
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}