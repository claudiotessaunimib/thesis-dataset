package world.bentobox.bentobox.api.commands.island;
import java.io.IOException;
import java.util.List;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.events.island.IslandEvent.Reason;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.managers.island.NewIsland;
import world.bentobox.bentobox.panels.customizable.IslandCreationPanel;
import world.bentobox.bentobox.util.Util;
public class IslandCreateCommand extends CompositeCommand {
    public IslandCreateCommand(CompositeCommand islandCommand) {
        super(islandCommand, "create", "new");
    }
    @Override
    public void setup() {
        setPermission("island.create");
        setOnlyPlayer(true);
        setParametersHelp("commands.island.create.parameters");
        setDescription("commands.island.create.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args) {
        @Nullable
        Island island = getIslands().getPrimaryIsland(getWorld(), user.getUniqueId());
        if (island != null) {
            if (island.isReserved()) {
                return true;
            }
        }
        if (getIWM().getWorldSettings(getWorld()).isDisallowTeamMemberIslands()
                && getIslands().inTeam(getWorld(), user.getUniqueId()) && island != null
                && !user.getUniqueId().equals(island.getOwner())) {
            user.sendMessage("commands.island.create.you-cannot-make-team");
            return false;
        }
        int num = this.getIslands().getNumberOfConcurrentIslands(user.getUniqueId(), getWorld());
        int max = user.getPermissionValue(
                this.getIWM().getAddon(getWorld()).map(GameModeAddon::getPermissionPrefix).orElse("") + "island.number",
                this.getIWM().getWorldSettings(getWorld()).getConcurrentIslands());
        if (num >= max) {
            user.sendMessage("commands.island.create.you-cannot-make");
            return false;
        }
        if (getIWM().getMaxIslands(getWorld()) > 0
                && getIslands().getIslandCount(getWorld()) >= getIWM().getMaxIslands(getWorld())) {
            user.sendMessage("commands.island.create.too-many-islands");
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        if (!args.isEmpty()) {
            String name = getPlugin().getBlueprintsManager().validate(getAddon(), Util.sanitizeInput(args.get(0)));
            if (name == null) {
                user.sendMessage("commands.island.create.unknown-blueprint");
                return false;
            }
            if (!getPlugin().getBlueprintsManager().checkPerm(getAddon(), user, Util.sanitizeInput(args.get(0)))) {
                return false;
            }
            if (checkMaxUses(user, name)) {
                return false;
            }
            return makeIsland(user, name);
        } else {
            if (getPlugin().getSettings().getIslandNumber() > 1
                    && checkMaxUses(user, BlueprintsManager.DEFAULT_BUNDLE_NAME)) {
                return false;
            }
            if (getPlugin().getBlueprintsManager().getBlueprintBundles(getAddon()).size() > 1) {
                IslandCreationPanel.openPanel(this, user, label, false);
                return true;
            }
            return makeIsland(user, BlueprintsManager.DEFAULT_BUNDLE_NAME);
        }
    }
    private boolean checkMaxUses(User user, String name) {
        if (getPlugin().getBlueprintsManager().getBlueprintBundles(getAddon()).containsKey(name)) {
            int maxTimes = getPlugin().getBlueprintsManager().getBlueprintBundles(getAddon()).get(name).getTimes();
            if (maxTimes > 0 && getBundleUses(user, name) >= maxTimes) {
                user.sendMessage("commands.island.create.max-uses");
                return true;
            }
        }
        return false;
    }
    private long getBundleUses(User user, String name) {
        return getIslands().getIslands(getWorld(), user).stream()
                .filter(is -> is.getMetaData("bundle").map(mdv -> name.equalsIgnoreCase(mdv.asString())).orElse(false))
                .count();
    }
    private boolean makeIsland(User user, String name) {
        user.sendMessage("commands.island.create.creating-island");
        try {
            NewIsland.builder().player(user).addon(getAddon()).reason(Reason.CREATE).name(name).build();
        } catch (IOException e) {
            getPlugin().logError("Could not create island for player. " + e.getMessage());
            user.sendMessage(e.getMessage());
            return false;
        }
        if (getSettings().isResetCooldownOnCreate()) {
            getParent().getSubCommand("reset").ifPresent(
                    resetCommand -> resetCommand.setCooldown(user.getUniqueId(), getSettings().getResetCooldown()));
        }
        return true;
    }
}
package world.bentobox.bentobox.panels.customizable;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.bukkit.World;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.panels.PanelItem;
import world.bentobox.bentobox.api.panels.TemplatedPanel;
import world.bentobox.bentobox.api.panels.builders.PanelItemBuilder;
import world.bentobox.bentobox.api.panels.builders.TemplatedPanelBuilder;
import world.bentobox.bentobox.api.panels.reader.ItemTemplateRecord;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBundle;
import world.bentobox.bentobox.util.Util;
public class IslandCreationPanel extends AbstractPanel
{
    private static final String BUNDLES = "BUNDLE";
    private static final String ISLAND_CREATION_COMMANDS = "ISLAND_CREATION_COMMANDS";
    private static final String BUNDLE_BUTTON_REF = "panels.island_creation.buttons.bundle.";
    private final List<BlueprintBundle> elementList;
    private final World world;
    private final boolean reset;
    private IslandCreationPanel(@NonNull CompositeCommand command,
            @NonNull User user, @NonNull String label, boolean reset)
    {
        super(command, user);
        this.mainLabel = label;
        this.world = command.getWorld();
        this.reset = reset;
        this.elementList = this.plugin.getBlueprintsManager().getBlueprintBundles(command.getAddon()).values().stream().
                sorted(Comparator.comparingInt(BlueprintBundle::getSlot).thenComparing(BlueprintBundle::getUniqueId))
                .filter(bundle -> !bundle.isRequirePermission() || this.user
                        .hasPermission(command.getPermissionPrefix() + "island.create." + bundle.getUniqueId()))
                .toList();
    }
    @Override
    protected void build()
    {
        if (this.elementList.isEmpty())
        {
            this.plugin.logError("There are no available phases for selection!");
            this.user.sendMessage("no-phases",
                    TextVariables.GAMEMODE, this.plugin.getDescription().getName());
            return;
        }
        TemplatedPanelBuilder panelBuilder = new TemplatedPanelBuilder();
        if (this.doesCustomPanelExists(this.command.getAddon(), "island_creation_panel"))
        {
            panelBuilder.template("island_creation_panel", new File(this.command.getAddon().getDataFolder(), "panels"));
        }
        else
        {
            panelBuilder.template("island_creation_panel", new File(this.plugin.getDataFolder(), "panels"));
        }
        panelBuilder.user(this.user);
        panelBuilder.world(this.user.getWorld());
        panelBuilder.registerTypeBuilder(BUNDLES, this::createBundleButton);
        panelBuilder.registerTypeBuilder(NEXT, this::createNextButton);
        panelBuilder.registerTypeBuilder(PREVIOUS, this::createPreviousButton);
        panelBuilder.build();
    }
    @Override
    @Nullable
    protected PanelItem createNextButton(@NonNull ItemTemplateRecord template, TemplatedPanel.ItemSlot slot)
    {
        int size = this.elementList.size();
        if (size <= slot.amountMap().getOrDefault(BUNDLES, 1) ||
                1.0 * size / slot.amountMap().getOrDefault(BUNDLES, 1) <= this.pageIndex + 1)
        {
            return null;
        }
        int nextPageIndex = this.pageIndex + 2;
        PanelItemBuilder builder = new PanelItemBuilder();
        if (template.icon() != null)
        {
            ItemStack clone = template.icon().clone();
            if ((boolean) template.dataMap().getOrDefault(INDEXING, false))
            {
                clone.setAmount(nextPageIndex);
            }
            builder.icon(clone);
        }
        if (template.title() != null)
        {
            builder.name(this.user.getTranslation(this.command.getWorld(), template.title()));
        }
        if (template.description() != null)
        {
            builder.description(this.user.getTranslation(this.command.getWorld(), template.description(),
                    TextVariables.NUMBER, String.valueOf(nextPageIndex)));
        }
        builder.clickHandler((panel, user, clickType, i) ->
        {
            template.actions().forEach(action -> {
                if ((clickType == action.clickType() ||
                        action.clickType() == ClickType.UNKNOWN) && NEXT.equalsIgnoreCase(action.actionType()))
                {
                    this.pageIndex++;
                    this.build();
                }
            });
            return true;
        });
        List<String> tooltips = template.actions().stream().
                filter(action -> action.tooltip() != null)
                .map(action -> this.user.getTranslation(this.command.getWorld(), action.tooltip()))
                .filter(text -> !text.isBlank())
                .collect(Collectors.toCollection(() -> new ArrayList<>(template.actions().size())));
        if (!tooltips.isEmpty())
        {
            builder.description("");
            builder.description(tooltips);
        }
        return builder.build();
    }
    @Nullable
    @Override
    protected PanelItem createPreviousButton(@NonNull ItemTemplateRecord template, TemplatedPanel.ItemSlot slot)
    {
        if (this.pageIndex == 0)
        {
            return null;
        }
        int previousPageIndex = this.pageIndex;
        PanelItemBuilder builder = new PanelItemBuilder();
        if (template.icon() != null)
        {
            ItemStack clone = template.icon().clone();
            if ((boolean) template.dataMap().getOrDefault(INDEXING, false))
            {
                clone.setAmount(previousPageIndex);
            }
            builder.icon(clone);
        }
        if (template.title() != null)
        {
            builder.name(this.user.getTranslation(this.command.getWorld(), template.title()));
        }
        if (template.description() != null)
        {
            builder.description(this.user.getTranslation(this.command.getWorld(), template.description(),
                    TextVariables.NUMBER, String.valueOf(previousPageIndex)));
        }
        builder.clickHandler((panel, user, clickType, i) ->
        {
            template.actions().forEach(action -> {
                if ((clickType == action.clickType() ||
                        action.clickType() == ClickType.UNKNOWN) && PREVIOUS.equalsIgnoreCase(action.actionType()))
                {
                    this.pageIndex--;
                    this.build();
                }
            });
            return true;
        });
        List<String> tooltips = template.actions().stream().
                filter(action -> action.tooltip() != null)
                .map(action -> this.user.getTranslation(this.command.getWorld(), action.tooltip()))
                .filter(text -> !text.isBlank())
                .collect(Collectors.toCollection(() -> new ArrayList<>(template.actions().size())));
        if (!tooltips.isEmpty())
        {
            builder.description("");
            builder.description(tooltips);
        }
        return builder.build();
    }
    @Nullable
    private PanelItem createBundleButton(ItemTemplateRecord template, TemplatedPanel.ItemSlot slot)
    {
        if (this.elementList.isEmpty())
        {
            return null;
        }
        int index = this.pageIndex * slot.amountMap().getOrDefault(BUNDLES, 1) + slot.slot();
        BlueprintBundle blueprintBundle;
        if (index >= this.elementList.size())
        {
            blueprintBundle = null;
        }
        else
        {
            blueprintBundle = this.elementList.get(index);
        }
        if (template.dataMap().containsKey("unique_id"))
        {
            blueprintBundle = this.elementList.stream().
                    filter(bundle -> bundle.getUniqueId().equals(template.dataMap().get("unique_id"))).findFirst()
                    .orElse(blueprintBundle);
        }
        return this.createBundleButton(template, blueprintBundle);
    }
    private PanelItem createBundleButton(ItemTemplateRecord template, BlueprintBundle bundle)
    {
        if (bundle == null)
        {
            return null;
        }
        PanelItemBuilder builder = new PanelItemBuilder();
        if (template.icon() != null)
        {
            builder.icon(template.icon().clone());
        }
        else
        {
            builder.icon(bundle.getIcon());
        }
        if (template.title() != null)
        {
            builder.name(this.user.getTranslation(this.command.getWorld(), template.title(),
                    TextVariables.NAME, bundle.getDisplayName()));
        }
        else
        {
            builder.name(this.user.getTranslation(BUNDLE_BUTTON_REF + "name",
                    TextVariables.NAME, bundle.getDisplayName()));
        }
        if (template.description() != null)
        {
            builder.description(this.user.getTranslation(this.command.getWorld(), template.description(),
                    TextVariables.DESCRIPTION, String.join("\n", bundle.getDescription())));
        }
        else
        {
            builder.description(this.user.getTranslation(BUNDLE_BUTTON_REF + "description",
                    TextVariables.DESCRIPTION, String.join("\n", bundle.getDescription())));
        }
        boolean usedUp = false;
        if (plugin.getSettings().getIslandNumber() > 1) {
            int maxTimes = bundle.getTimes();
            if (maxTimes > 0) {
                long uses = plugin.getIslands().getIslands(world, user).stream()
                        .filter(is -> is.getMetaData("bundle")
                                .map(mdv -> bundle.getDisplayName().equalsIgnoreCase(mdv.asString())
                                        && !(reset && is.isPrimary(user.getUniqueId()))) 
                                .orElse(false))
                        .count();
                builder.description(this.user.getTranslation(BUNDLE_BUTTON_REF + "uses", TextVariables.NUMBER,
                        String.valueOf(uses), "[max]", String.valueOf(maxTimes)));
                if (uses >= maxTimes) {
                    usedUp = true;
                }
            } else {
                builder.description(this.user.getTranslation(BUNDLE_BUTTON_REF + "unlimited"));
            }
        }
        if (usedUp) {
            if (plugin.getSettings().isHideUsedBlueprints()) {
                return null;
            }
        } else {
            List<ItemTemplateRecord.ActionRecords> actions = template.actions().stream()
                    .filter(action -> SELECT_ACTION.equalsIgnoreCase(action.actionType())
                            || COMMANDS_ACTION.equalsIgnoreCase(action.actionType()))
                    .toList();
            builder.clickHandler((panel, user, clickType, i) -> {
                actions.forEach(action -> {
                    if (clickType == action.clickType() || action.clickType() == ClickType.UNKNOWN)
                    {
                        if (SELECT_ACTION.equalsIgnoreCase(action.actionType())) {
                            user.closeInventory();
                            this.command.execute(user, this.mainLabel,
                                    Collections.singletonList(bundle.getUniqueId()));
                        } else if (COMMANDS_ACTION.equalsIgnoreCase(action.actionType())) {
                            Util.runCommands(user,
                                    Arrays.stream(action.content()
                                            .replaceAll(Pattern.quote(TextVariables.LABEL),
                                                    this.command.getTopLabel())
                                            .split("\n")).toList(),
                                    ISLAND_CREATION_COMMANDS);
                        }
                    }
                });
                return true;
            });
            List<String> tooltips = actions.stream().filter(action -> action.tooltip() != null)
                    .map(action -> this.user.getTranslation(this.command.getWorld(), action.tooltip()))
                    .filter(text -> !text.isBlank())
                    .collect(Collectors.toCollection(() -> new ArrayList<>(actions.size())));
            if (!tooltips.isEmpty()) {
                builder.description("");
                builder.description(tooltips);
            }
        }
        return builder.build();
    }
    public static void openPanel(@NonNull CompositeCommand command, @NonNull User user, @NonNull String label,
            boolean reset) {
        new IslandCreationPanel(command, user, label, reset).build();
    }
}
package world.bentobox.bentobox.database.objects;
import java.io.IOException;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;
import org.bukkit.Bukkit;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.World.Environment;
import org.bukkit.entity.Player;
import org.bukkit.util.BoundingBox;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSet.Builder;
import com.google.gson.annotations.Expose;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.configuration.WorldSettings;
import world.bentobox.bentobox.api.flags.Flag;
import world.bentobox.bentobox.api.logs.LogEntry;
import world.bentobox.bentobox.api.logs.LogEntry.LogType;
import world.bentobox.bentobox.api.metadata.MetaDataAble;
import world.bentobox.bentobox.api.metadata.MetaDataValue;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.database.objects.adapters.Adapter;
import world.bentobox.bentobox.database.objects.adapters.LogEntryListAdapter;
import world.bentobox.bentobox.lists.Flags;
import world.bentobox.bentobox.managers.IslandsManager;
import world.bentobox.bentobox.managers.RanksManager;
import world.bentobox.bentobox.util.Pair;
import world.bentobox.bentobox.util.Util;
@Table(name = "Islands")
public class Island implements DataObject, MetaDataAble {
    @Expose
    private Set<UUID> primaries = new HashSet<>();
    private boolean changed;
    @Expose
    private boolean deleted = false;
    @Expose
    @NonNull
    private String uniqueId = UUID.randomUUID().toString();
    @Expose
    private Location center;
    @Expose
    @Nullable
    private Location location;
    @Expose
    private int range;
    @Expose
    private int protectionRange;
    @Expose
    private List<BonusRangeRecord> bonusRanges = new ArrayList<>();
    @Expose
    private int maxEverProtectionRange;
    @Expose
    private World world;
    @Expose
    private String gameMode;
    @Expose
    @Nullable
    private String name;
    @Expose
    private long createdDate;
    @Expose
    private long updatedDate;
    @Expose
    @Nullable
    private UUID owner;
    @Expose
    private Map<UUID, Integer> members = new HashMap<>();
    @Expose
    private Map<Integer, Integer> maxMembers;
    @Expose
    private boolean spawn = false;
    @Expose
    private boolean purgeProtected = false;
    @Expose
    private Map<String, Integer> flags = new HashMap<>();
    @Adapter(LogEntryListAdapter.class)
    @Expose
    private List<LogEntry> history = new LinkedList<>();
    @Expose
    private Map<Environment, Location> spawnPoint = new EnumMap<>(Environment.class);
    @Expose
    private boolean doNotLoad;
    @Expose
    private Map<String, Long> cooldowns = new HashMap<>();
    @Expose
    private Map<String, Integer> commandRanks;
    @Expose
    @Nullable
    private Boolean reserved = null;
    @Expose
    private Map<String, MetaDataValue> metaData;
    @Expose
    private Map<String, Location> homes;
    @Expose
    private Integer maxHomes;
    public Island() {
    }
    public Island(@NonNull Location location, UUID owner, int protectionRange) {
        setOwner(owner);
        createdDate = System.currentTimeMillis();
        updatedDate = System.currentTimeMillis();
        world = location.getWorld();
        center = new Location(location.getWorld(), location.getX(), location.getY(), location.getZ());
        range = BentoBox.getInstance().getIWM().getIslandDistance(world);
        this.protectionRange = protectionRange;
        this.maxEverProtectionRange = protectionRange;
    }
    public Island(Island island) {
        this.center = island.getCenter().clone();
        this.createdDate = island.getCreatedDate();
        Optional.ofNullable(island.getCommandRanks()).ifPresent(cr -> {
            this.commandRanks = new HashMap<>();
            this.commandRanks.putAll(cr);
        });
        Optional.ofNullable(island.getCooldowns()).ifPresent(c -> {
            this.cooldowns = new HashMap<>();
            this.cooldowns.putAll(c);
        });
        this.createdDate = island.getCreatedDate();
        this.deleted = island.isDeleted();
        this.doNotLoad = island.isDoNotLoad();
        this.flags.putAll(island.getFlags());
        this.gameMode = island.getGameMode();
        this.homes = new HashMap<>(island.getHomes());
        this.history.addAll(island.getHistory());
        this.location = island.getProtectionCenter();
        this.maxEverProtectionRange = island.getMaxEverProtectionRange();
        this.maxHomes = island.getMaxHomes();
        this.maxMembers = new HashMap<>(island.getMaxMembers());
        this.members.putAll(island.getMembers());
        island.getMetaData().ifPresent(m -> {
            this.metaData = new HashMap<>();
            this.metaData.putAll(m);
        });
        this.name = island.getName();
        this.owner = island.getOwner();
        this.protectionRange = island.getProtectionRange();
        this.purgeProtected = island.getPurgeProtected();
        this.range = island.getRange();
        this.reserved = island.isReserved();
        this.spawn = island.isSpawn();
        island.getSpawnPoint().forEach((k, v) -> island.spawnPoint.put(k, v.clone()));
        this.uniqueId = island.getUniqueId();
        this.updatedDate = island.getUpdatedDate();
        this.world = island.getWorld();
        this.bonusRanges.addAll(island.getBonusRanges());
        this.primaries.addAll(island.getPrimaries());
        this.setChanged();
    }
    public void addMember(@NonNull UUID playerUUID) {
        if (getRank(playerUUID) != RanksManager.MEMBER_RANK) {
            setRank(playerUUID, RanksManager.MEMBER_RANK);
            setChanged();
        }
    }
    public boolean ban(@NonNull UUID issuer, @NonNull UUID target) {
        if (getRank(target) != RanksManager.BANNED_RANK) {
            setRank(target, RanksManager.BANNED_RANK);
            log(new LogEntry.Builder(LogType.BAN).data("player", target.toString()).data("issuer", issuer.toString())
                    .build());
            setChanged();
        }
        return true;
    }
    public Set<UUID> getBanned() {
        Set<UUID> result = new HashSet<>();
        for (Entry<UUID, Integer> member : members.entrySet()) {
            if (member.getValue() <= RanksManager.BANNED_RANK) {
                result.add(member.getKey());
            }
        }
        return result;
    }
    public boolean unban(@NonNull UUID issuer, @NonNull UUID target) {
        if (members.remove(target) != null) {
            log(new LogEntry.Builder(LogType.UNBAN).data("player", target.toString()).data("issuer", issuer.toString())
                    .build());
            return true;
        }
        return false;
    }
    @NonNull
    public Location getCenter() {
        return Objects.requireNonNull(center, "Island getCenter requires a non-null center").clone();
    }
    public long getCreatedDate() {
        return createdDate;
    }
    public int getFlag(@NonNull Flag flag) {
        return flags.computeIfAbsent(flag.getID(), k -> flag.getDefaultRank());
    }
    public Map<String, Integer> getFlags() {
        return flags;
    }
    public Map<UUID, Integer> getMembers() {
        return members;
    }
    public ImmutableSet<UUID> getMemberSet() {
        return getMemberSet(RanksManager.MEMBER_RANK);
    }
    public @NonNull ImmutableSet<UUID> getMemberSet(int minimumRank) {
        Builder<UUID> result = new ImmutableSet.Builder<>();
        members.entrySet().stream().filter(e -> e.getValue() >= minimumRank).map(Map.Entry::getKey)
                .forEach(result::add);
        return result.build();
    }
    public @NonNull ImmutableSet<UUID> getMemberSet(int rank, boolean includeAboveRanks) {
        if (includeAboveRanks) {
            return getMemberSet(rank);
        }
        Builder<UUID> result = new ImmutableSet.Builder<>();
        members.entrySet().stream().filter(e -> e.getValue() == rank).map(Map.Entry::getKey).forEach(result::add);
        return result.build();
    }
    public int getMinProtectedX() {
        return Math.max(getMinX(), getProtectionCenter().getBlockX() - this.getProtectionRange());
    }
    public int getMaxProtectedX() {
        return Math.min(getMaxX(), getProtectionCenter().getBlockX() + this.getProtectionRange());
    }
    public int getMinProtectedZ() {
        return Math.max(getMinZ(), getProtectionCenter().getBlockZ() - this.getProtectionRange());
    }
    public int getMaxProtectedZ() {
        return Math.min(getMaxZ(), getProtectionCenter().getBlockZ() + this.getProtectionRange());
    }
    public int getMinX() {
        return center.getBlockX() - range;
    }
    public int getMaxX() {
        return center.getBlockX() + range;
    }
    public int getMinZ() {
        return center.getBlockZ() - range;
    }
    public int getMaxZ() {
        return center.getBlockZ() + range;
    }
    @Nullable
    public String getName() {
        return name;
    }
    @Nullable
    public UUID getOwner() {
        return owner;
    }
    public boolean isOwned() {
        return owner != null;
    }
    public boolean isUnowned() {
        return owner == null;
    }
    public int getProtectionRange() {
        return Math.min(this.getRange(),
                getRawProtectionRange() + this.getBonusRanges().stream().mapToInt(BonusRangeRecord::getRange).sum());
    }
    public int getRawProtectionRange() {
        return protectionRange;
    }
    public int getMaxEverProtectionRange() {
        if (maxEverProtectionRange > this.getRange()) {
            maxEverProtectionRange = this.getRange();
            setChanged();
        }
        return Math.max(this.getProtectionRange(), maxEverProtectionRange);
    }
    public void setMaxEverProtectionRange(int maxEverProtectionRange) {
        if (maxEverProtectionRange > this.maxEverProtectionRange) {
            this.maxEverProtectionRange = maxEverProtectionRange;
        }
        if (maxEverProtectionRange > this.range) {
            this.maxEverProtectionRange = this.range;
        }
        setChanged();
    }
    public boolean getPurgeProtected() {
        return purgeProtected;
    }
    public int getRange() {
        return range;
    }
    public int getRank(User user) {
        return members.getOrDefault(user.getUniqueId(), RanksManager.VISITOR_RANK);
    }
    public int getRank(UUID userUUID) {
        return members.getOrDefault(userUUID, RanksManager.VISITOR_RANK);
    }
    @Override
    public @NonNull String getUniqueId() {
        return uniqueId;
    }
    public long getUpdatedDate() {
        return updatedDate;
    }
    public World getWorld() {
        return world;
    }
    @Nullable
    public World getNetherWorld() {
        return this.getWorld(Environment.NETHER);
    }
    @Nullable
    public World getEndWorld() {
        return this.getWorld(Environment.THE_END);
    }
    @Nullable
    public World getWorld(Environment environment) {
        if (Environment.NORMAL.equals(environment)) {
            return this.world;
        } else if (Environment.THE_END.equals(environment) && this.isEndIslandEnabled()) {
            return this.getPlugin().getIWM().getEndWorld(this.world);
        } else if (Environment.NETHER.equals(environment) && this.isNetherIslandEnabled()) {
            return this.getPlugin().getIWM().getNetherWorld(this.world);
        } else {
            return null;
        }
    }
    public int getX() {
        return center.getBlockX();
    }
    public int getY() {
        return center.getBlockY();
    }
    public int getZ() {
        return center.getBlockZ();
    }
    public boolean inIslandSpace(int x, int z) {
        return x >= getMinX() && x < getMinX() + range * 2 && z >= getMinZ() && z < getMinZ() + range * 2;
    }
    public boolean inIslandSpace(Location location) {
        return Util.sameWorld(this.world, location.getWorld())
                && (location.getWorld().getEnvironment().equals(Environment.NORMAL)
                        || this.getPlugin().getIWM().isIslandNether(location.getWorld())
                        || this.getPlugin().getIWM().isIslandEnd(location.getWorld()))
                && this.inIslandSpace(location.getBlockX(), location.getBlockZ());
    }
    public boolean inIslandSpace(Pair<Integer, Integer> blockCoordinates) {
        return inIslandSpace(blockCoordinates.x, blockCoordinates.z);
    }
    @NonNull
    public BoundingBox getBoundingBox() {
        return this.getBoundingBox(Environment.NORMAL);
    }
    @Nullable
    public BoundingBox getBoundingBox(Environment environment) {
        BoundingBox boundingBox;
        if (Environment.NORMAL.equals(environment)) {
            boundingBox = new BoundingBox(this.getMinX(), this.world.getMinHeight(), this.getMinZ(), this.getMaxX(),
                    this.world.getMaxHeight(), this.getMaxZ());
        } else if (Environment.THE_END.equals(environment) && this.isEndIslandEnabled()) {
            boundingBox = new BoundingBox(this.getMinX(), this.getEndWorld().getMinHeight(), this.getMinZ(),
                    this.getMaxX(), this.getEndWorld().getMaxHeight(), this.getMaxZ());
        } else if (Environment.NETHER.equals(environment) && this.isNetherIslandEnabled()) {
            boundingBox = new BoundingBox(this.getMinX(), this.getNetherWorld().getMinHeight(), this.getMinZ(),
                    this.getMaxX(), this.getNetherWorld().getMaxHeight(), this.getMaxZ());
        } else {
            boundingBox = null;
        }
        return boundingBox;
    }
    private boolean playerIsVisitor(Player player) {
        if (player.getGameMode() == GameMode.SPECTATOR) {
            return false;
        }
        return onIsland(player.getLocation()) && getRank(User.getInstance(player)) == RanksManager.VISITOR_RANK;
    }
    @NonNull
    public List<Player> getVisitors() {
        return Bukkit.getOnlinePlayers().stream().filter(this::playerIsVisitor).collect(Collectors.toList());
    }
    public boolean hasVisitors() {
        return Bukkit.getOnlinePlayers().stream().anyMatch(this::playerIsVisitor);
    }
    @NonNull
    public List<Player> getPlayersOnIsland() {
        return Bukkit.getOnlinePlayers().stream().filter(player -> onIsland(player.getLocation()))
                .collect(Collectors.toList());
    }
    public boolean hasPlayersOnIsland() {
        return Bukkit.getOnlinePlayers().stream().anyMatch(player -> onIsland(player.getLocation()));
    }
    public boolean isAllowed(Flag flag) {
        return getFlag(flag) >= 0;
    }
    public boolean isAllowed(User user, Flag flag) {
        return getRank(user) >= getFlag(flag);
    }
    public boolean isBanned(UUID targetUUID) {
        return members.containsKey(targetUUID) && members.get(targetUUID).equals(RanksManager.BANNED_RANK);
    }
    public boolean isSpawn() {
        return spawn;
    }
    public boolean onIsland(@NonNull Location target) {
        return Util.sameWorld(this.world, target.getWorld())
                && (target.getWorld().getEnvironment().equals(Environment.NORMAL)
                        || this.getPlugin().getIWM().isIslandNether(target.getWorld())
                        || this.getPlugin().getIWM().isIslandEnd(target.getWorld()))
                && target.getBlockX() >= this.getMinProtectedX()
                && target.getBlockX() < (this.getMinProtectedX() + this.getProtectionRange() * 2)
                && target.getBlockZ() >= this.getMinProtectedZ()
                && target.getBlockZ() < (this.getMinProtectedZ() + this.getProtectionRange() * 2);
    }
    @NonNull
    public BoundingBox getProtectionBoundingBox() {
        return this.getProtectionBoundingBox(Environment.NORMAL);
    }
    @Nullable
    public BoundingBox getProtectionBoundingBox(Environment environment) {
        BoundingBox boundingBox;
        if (Environment.NORMAL.equals(environment)) {
            boundingBox = new BoundingBox(this.getMinProtectedX(), this.world.getMinHeight(), this.getMinProtectedZ(),
                    this.getMaxProtectedX(), this.world.getMaxHeight(), this.getMaxProtectedZ());
        } else if (Environment.THE_END.equals(environment) && this.isEndIslandEnabled()) {
            boundingBox = new BoundingBox(this.getMinProtectedX(), this.getEndWorld().getMinHeight(),
                    this.getMinProtectedZ(), this.getMaxProtectedX(), this.getEndWorld().getMaxHeight(),
                    this.getMaxProtectedZ());
        } else if (Environment.NETHER.equals(environment) && this.isNetherIslandEnabled()) {
            boundingBox = new BoundingBox(this.getMinProtectedX(), this.getNetherWorld().getMinHeight(),
                    this.getMinProtectedZ(), this.getMaxProtectedX(), this.getNetherWorld().getMaxHeight(),
                    this.getMaxProtectedZ());
        } else {
            boundingBox = null;
        }
        return boundingBox;
    }
    public void removeMember(UUID playerUUID) {
        if (members.remove(playerUUID) != null) {
            setChanged();
        }
    }
    public void setCenter(@NonNull Location center) {
        if (this.center == null || !center.getWorld().equals(this.center.getWorld()) || !center.equals(this.center)) {
            this.world = center.getWorld();
            this.center = center;
            setChanged();
        }
    }
    public void setCreatedDate(long createdDate) {
        if (this.createdDate != createdDate) {
            this.createdDate = createdDate;
            setChanged();
        }
    }
    public Island setFlag(Flag flag, int value) {
        setFlag(flag, value, true);
        return this;
    }
    public void setFlag(Flag flag, int value, boolean doSubflags) {
        if (flags.containsKey(flag.getID()) && flags.get(flag.getID()) != value) {
            flags.put(flag.getID(), value);
            setChanged();
        }
        if (doSubflags && flag.hasSubflags()) {
            flag.getSubflags().forEach(subflag -> setFlag(subflag, value, true));
        }
    }
    public void setFlags(Map<String, Integer> flags) {
        this.flags = flags;
        setChanged();
    }
    public Island setFlagsDefaults() {
        BentoBox plugin = BentoBox.getInstance();
        Map<String, Integer> result = new HashMap<>();
        plugin.getFlagsManager().getFlags().stream().filter(f -> f.getType().equals(Flag.Type.PROTECTION))
                .forEach(f -> result.put(f.getID(),
                        plugin.getIWM().getDefaultIslandFlags(world).getOrDefault(f, f.getDefaultRank())));
        plugin.getFlagsManager().getFlags().stream().filter(f -> f.getType().equals(Flag.Type.SETTING))
                .forEach(f -> result.put(f.getID(),
                        plugin.getIWM().getDefaultIslandSettings(world).getOrDefault(f, f.getDefaultRank())));
        setFlags(result);
        return this;
    }
    public void setMembers(Map<UUID, Integer> members) {
        this.members = members;
        setChanged();
    }
    public void setName(String name) {
        if (name == null || !name.equals(this.name)) {
            this.name = (name != null && !name.equals("")) ? name : null;
            setChanged();
        }
    }
    public void setOwner(@Nullable UUID owner) {
        if (this.owner == owner) {
            return; 
        }
        this.owner = owner;
        if (owner == null) {
            log(new LogEntry.Builder(LogType.UNOWNED).build());
            return;
        }
        for (Entry<UUID, Integer> en : members.entrySet()) {
            if (en.getValue().equals(RanksManager.OWNER_RANK)) {
                setRank(en.getKey(), RanksManager.MEMBER_RANK);
            }
        }
        setRank(owner, RanksManager.OWNER_RANK);
        setChanged();
    }
    public void setProtectionRange(int protectionRange) {
        if (this.protectionRange != protectionRange) {
            this.protectionRange = protectionRange;
            this.updateMaxEverProtectionRange();
            setChanged();
        }
    }
    public void updateMaxEverProtectionRange() {
        int diffMinX = Math.abs(Objects.requireNonNull(getCenter()).getBlockX() - this.getMinProtectedX());
        int diffMaxX = Math.abs(getCenter().getBlockX() - this.getMaxProtectedX());
        int diffMinZ = Math.abs(getCenter().getBlockZ() - this.getMinProtectedZ());
        int diffMaxZ = Math.abs(getCenter().getBlockZ() - this.getMaxProtectedZ());
        if (diffMinX > this.maxEverProtectionRange) {
            this.maxEverProtectionRange = diffMinX;
        }
        if (diffMaxX > this.maxEverProtectionRange) {
            this.maxEverProtectionRange = diffMaxX;
        }
        if (diffMinZ > this.maxEverProtectionRange) {
            this.maxEverProtectionRange = diffMinZ;
        }
        if (diffMaxZ > this.maxEverProtectionRange) {
            this.maxEverProtectionRange = diffMaxZ;
        }
    }
    public void setPurgeProtected(boolean purgeProtected) {
        if (this.purgeProtected != purgeProtected) {
            this.purgeProtected = purgeProtected;
            setChanged();
        }
    }
    public void setRange(int range) {
        if (this.range != range) {
            this.range = range;
            setChanged();
        }
    }
    public void setRank(User user, int rank) {
        setRank(user.getUniqueId(), rank);
    }
    public void setRank(@Nullable UUID uuid, int newRank) {
        if (uuid == null) {
            return;
        }
        AtomicBoolean isRankChanged = new AtomicBoolean(false);
        members.compute(uuid, (key, existingRank) -> {
            if (existingRank == null || existingRank != newRank) {
                isRankChanged.set(true);
                return newRank; 
            }
            return existingRank;
        });
        if (isRankChanged.get()) {
            setChanged(); 
        }
    }
    public void setRanks(Map<UUID, Integer> ranks) {
        members = ranks;
        setChanged();
    }
    public void setSpawn(boolean isSpawn) {
        if (spawn == isSpawn) {
            return; 
        }
        spawn = isSpawn;
        if (isSpawn) {
            setOwner(null);
            members.clear();
            setFlagsDefaults();
            setFlag(Flags.LOCK, RanksManager.VISITOR_RANK);
        }
        log(new LogEntry.Builder(LogType.SPAWN).data("value", String.valueOf(isSpawn)).build());
        setChanged();
    }
    public Map<Environment, Location> getSpawnPoint() {
        return spawnPoint;
    }
    public void setSpawnPoint(Map<Environment, Location> spawnPoint) {
        this.spawnPoint = spawnPoint;
        setChanged();
    }
    @Override
    public void setUniqueId(String uniqueId) {
        this.uniqueId = uniqueId;
    }
    public void setUpdatedDate(long updatedDate) {
        this.updatedDate = updatedDate;
    }
    public void setWorld(World world) {
        this.world = world;
        setChanged();
    }
    public void toggleFlag(Flag flag) {
        toggleFlag(flag, true);
    }
    public void toggleFlag(Flag flag, boolean doSubflags) {
        boolean newToggleValue = !isAllowed(flag); 
        if (flag.getType().equals(Flag.Type.SETTING) || flag.getType().equals(Flag.Type.WORLD_SETTING)) {
            setSettingsFlag(flag, newToggleValue, doSubflags);
        }
        setChanged();
    }
    public void setSettingsFlag(Flag flag, boolean state) {
        setSettingsFlag(flag, state, true);
    }
    public void setSettingsFlag(Flag flag, boolean state, boolean doSubflags) {
        int newState = state ? 1 : -1;
        if (flag.getType().equals(Flag.Type.SETTING) || flag.getType().equals(Flag.Type.WORLD_SETTING)) {
            flags.put(flag.getID(), newState);
            if (doSubflags && flag.hasSubflags()) {
                flag.getSubflags().forEach(subflag -> setSettingsFlag(subflag, state, true));
            }
        }
        setChanged();
    }
    public void setSpawnPoint(Environment islandType, Location l) {
        spawnPoint.compute(islandType, (key, value) -> {
            if (value == null || !value.equals(l)) {
                setChanged(); 
                return l;
            }
            return value;
        });
    }
    @Nullable
    public Location getSpawnPoint(Environment islandType) {
        return spawnPoint.get(islandType);
    }
    public void removeRank(Integer rank) {
        if (members.values().removeIf(rank::equals)) {
            setChanged();
        }
    }
    public List<LogEntry> getHistory() {
        return history;
    }
    public void log(LogEntry logEntry) {
        history.add(logEntry);
        setChanged();
    }
    public void setHistory(List<LogEntry> history) {
        this.history = history;
        setChanged();
    }
    public boolean isDoNotLoad() {
        return doNotLoad;
    }
    public void setDoNotLoad(boolean doNotLoad) {
        this.doNotLoad = doNotLoad;
        setChanged();
    }
    public boolean isDeleted() {
        return deleted;
    }
    public void setDeleted(boolean deleted) {
        this.deleted = deleted;
        setChanged();
    }
    public String getGameMode() {
        return gameMode;
    }
    public void setGameMode(String gameMode) {
        this.gameMode = gameMode;
    }
    public boolean hasNetherIsland() {
        World nether = BentoBox.getInstance().getIWM().getNetherWorld(getWorld());
        return nether != null && (getCenter().toVector().toLocation(nether).getBlock().getType() != Material.AIR);
    }
    public boolean isNetherIslandEnabled() {
        return this.getPlugin().getIWM().isNetherGenerate(this.world)
                && this.getPlugin().getIWM().isNetherIslands(this.world);
    }
    public boolean hasEndIsland() {
        World end = BentoBox.getInstance().getIWM().getEndWorld(getWorld());
        return end != null && (getCenter().toVector().toLocation(end).getBlock().getType() != Material.AIR);
    }
    public boolean isEndIslandEnabled() {
        return this.getPlugin().getIWM().isEndGenerate(this.world)
                && this.getPlugin().getIWM().isEndIslands(this.world);
    }
    public boolean isCooldown(Flag flag) {
        if (cooldowns.containsKey(flag.getID()) && cooldowns.get(flag.getID()) > System.currentTimeMillis()) {
            return true;
        }
        if (cooldowns.remove(flag.getID()) != null) {
            setChanged();
        }
        return false;
    }
    public void setCooldown(Flag flag) {
        cooldowns.put(flag.getID(), flag.getCooldown() * 1000L + System.currentTimeMillis());
        setChanged();
    }
    public Map<String, Long> getCooldowns() {
        return cooldowns;
    }
    public void setCooldowns(Map<String, Long> cooldowns) {
        this.cooldowns = cooldowns;
        setChanged();
    }
    public Map<String, Integer> getCommandRanks() {
        return commandRanks;
    }
    public void setCommandRanks(Map<String, Integer> commandRanks) {
        this.commandRanks = commandRanks;
        setChanged();
    }
    public int getRankCommand(String command) {
        if (this.commandRanks == null) {
            this.commandRanks = new HashMap<>();
        }
        return this.commandRanks.computeIfAbsent(command, key -> {
            String[] labels = key.replaceFirst("/", "").split(" ");
            CompositeCommand compositeCommand = this.getPlugin().getCommandsManager().getCommand(labels[0]);
            for (int i = 1; i < labels.length && compositeCommand != null; i++) {
                compositeCommand = compositeCommand.getSubCommand(labels[i]).orElse(null);
            }
            return compositeCommand == null ? RanksManager.OWNER_RANK : compositeCommand.getDefaultCommandRank();
        });
    }
    public void setRankCommand(String command, int rank) {
        if (this.commandRanks == null)
            this.commandRanks = new HashMap<>();
        commandRanks.compute(command, (key, value) -> {
            if (value == null || !value.equals(rank)) {
                setChanged(); 
                return rank;
            }
            return value;
        });
    }
    public boolean isReserved() {
        return reserved != null && reserved;
    }
    public void setReserved(boolean reserved) {
        if (this.reserved != reserved) {
            this.reserved = reserved;
            setChanged();
        }
    }
    @Override
    public Optional<Map<String, MetaDataValue>> getMetaData() {
        if (metaData == null) {
            metaData = new HashMap<>();
        }
        return Optional.of(metaData);
    }
    @Override
    public void setMetaData(Map<String, MetaDataValue> metaData) {
        this.metaData = metaData;
        setChanged();
    }
    public boolean isChanged() {
        return changed;
    }
    public void setChanged() {
        this.setUpdatedDate(System.currentTimeMillis());
        this.changed = true;
        IslandsManager.updateIsland(this);
    }
    public void clearChanged() {
        this.changed = false;
    }
    @NonNull
    public Location getProtectionCenter() {
        return location == null ? getCenter() : location.clone();
    }
    public void setProtectionCenter(Location location) throws IOException {
        if (this.getProtectionCenter().equals(location)) {
            return; 
        }
        if (!this.inIslandSpace(location)) {
            throw new IOException("Location must be in island space");
        }
        this.location = location;
        this.updateMaxEverProtectionRange();
        setChanged();
    }
    @NonNull
    public Map<String, Location> getHomes() {
        if (homes == null) {
            homes = new HashMap<>();
        }
        return homes;
    }
    @NonNull
    public Location getHome(final String nameToLookFor) {
        return getHomes().entrySet().stream().filter(en -> en.getKey().equalsIgnoreCase(nameToLookFor))
                .map(Entry::getValue)
                .findFirst().orElse(getProtectionCenter().clone().add(new Vector(0.5D, 0D, 0.5D)));
    }
    public void setHomes(Map<String, Location> homes) {
        this.homes = homes;
        setChanged();
    }
    public void addHome(String name, Location location) {
        if (getHomes().containsKey(name) && getHomes().get(name).equals(location)) {
            return; 
        }
        if (location != null) {
            Vector v = location.toVector();
            if (!this.getBoundingBox().contains(v)) {
                BentoBox.getInstance().logWarning("Tried to set a home location " + location
                        + " outside of the island. This generally should not happen.");
                BentoBox.getInstance().logWarning(
                        "Island is at " + this.getCenter() + ". The island file may need editing to remove this home.");
                BentoBox.getInstance().logWarning("Please report this issue and logs around this item to BentoBox");
            }
        }
        getHomes().put(name.toLowerCase(), location);
        setChanged();
    }
    public boolean removeHome(String name) {
        if (getHomes().remove(name.toLowerCase()) != null) {
            setChanged();
            return true;
        }
        return false;
    }
    public boolean removeHomes() {
        if (getHomes().keySet().removeIf(k -> !k.isEmpty())) {
            setChanged();
            return true;
        }
        return false;
    }
    public boolean renameHome(String oldName, String newName) {
        if (getHomes().containsKey(oldName.toLowerCase()) && !getHomes().containsKey(newName.toLowerCase())) {
            this.addHome(newName, this.getHome(oldName));
            this.removeHome(oldName);
            return true;
        }
        return false;
    }
    @Nullable
    public Integer getMaxHomes() {
        return maxHomes;
    }
    public void setMaxHomes(@Nullable Integer maxHomes) {
        if (this.maxHomes != maxHomes) {
            this.maxHomes = maxHomes;
            setChanged();
        }
    }
    public Map<Integer, Integer> getMaxMembers() {
        if (maxMembers == null) {
            maxMembers = new HashMap<>();
        }
        return maxMembers;
    }
    public void setMaxMembers(Map<Integer, Integer> maxMembers) {
        if (this.maxMembers != maxMembers) {
            this.maxMembers = maxMembers;
            setChanged();
        }
    }
    @Nullable
    public Integer getMaxMembers(int rank) {
        return getMaxMembers().get(rank);
    }
    public void setMaxMembers(int rank, Integer maxMembers) {
        getMaxMembers().compute(rank, (key, value) -> {
            if (value == null || !value.equals(maxMembers)) {
                setChanged(); 
                return maxMembers;
            }
            return value;
        });
    }
    public List<BonusRangeRecord> getBonusRanges() {
        if (bonusRanges == null) {
            this.setBonusRanges(new ArrayList<>());
        }
        return bonusRanges;
    }
    public void setBonusRanges(List<BonusRangeRecord> bonusRanges) {
        this.bonusRanges = bonusRanges;
        setChanged();
    }
    public int getBonusRange(String id) {
        return this.getBonusRanges().stream().filter(r -> r.getUniqueId().equals(id))
                .mapToInt(BonusRangeRecord::getRange).sum();
    }
    public Optional<BonusRangeRecord> getBonusRangeRecord(String uniqueId) {
        return this.getBonusRanges().stream().filter(r -> r.getUniqueId().equals(uniqueId)).findFirst();
    }
    public void addBonusRange(String id, int range, String message) {
        this.getBonusRanges().add(new BonusRangeRecord(id, range, message));
        setMaxEverProtectionRange(this.getProtectionRange());
        setChanged();
    }
    public void clearBonusRange(String id) {
        if (this.getBonusRanges().removeIf(r -> r.getUniqueId().equals(id))) {
            setChanged();
        }
    }
    public void clearAllBonusRanges() {
        this.getBonusRanges().clear();
        setChanged();
    }
    public boolean isPrimary(UUID userID) {
        return getPrimaries().contains(userID);
    }
    public void setPrimary(UUID userID) {
        if (getPrimaries().add(userID)) {
            setChanged();
        }
    }
    public void removePrimary(UUID userID) {
        if (getPrimaries().remove(userID)) {
            setChanged();
        }
    }
    public boolean inTeam(UUID playerUUID) {
        return this.getMemberSet().contains(playerUUID);
    }
    public boolean hasTeam() {
        return this.getMemberSet().size() > 1;
    }
    @Override
    public String toString() {
        return "Island [changed=" + changed + ", deleted=" + deleted + ", uniqueId=" + uniqueId + ", center=" + center
                + ", location=" + location + ", range=" + range + ", protectionRange=" + protectionRange
                + ", maxEverProtectionRange=" + maxEverProtectionRange + ", world=" + world + ", gameMode=" + gameMode
                + ", name=" + name + ", createdDate=" + createdDate + ", updatedDate=" + updatedDate + ", owner="
                + owner + ", members=" + members + ", maxMembers=" + maxMembers + ", spawn=" + spawn
                + ", purgeProtected=" + purgeProtected + ", flags=" + flags + ", history=" + history + ", spawnPoint="
                + spawnPoint + ", doNotLoad=" + doNotLoad + ", cooldowns=" + cooldowns + ", commandRanks="
                + commandRanks + ", reserved=" + reserved + ", metaData=" + metaData + ", homes=" + homes
                + ", maxHomes=" + maxHomes + "]";
    }
    public Set<UUID> getPrimaries() {
        if (primaries == null) {
            primaries = new HashSet<>();
        }
        return primaries;
    }
    public void setPrimaries(Set<UUID> primaries) {
        this.primaries = primaries;
        setChanged();
    }
    @Override
    public int hashCode() {
        return Objects.hash(uniqueId);
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Island other = (Island) obj;
        return Objects.equals(uniqueId, other.uniqueId);
    }
}
package world.bentobox.bentobox.api.user;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang.math.NumberUtils;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Color;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.OfflinePlayer;
import org.bukkit.Particle;
import org.bukkit.Particle.DustTransition;
import org.bukkit.Vibration;
import org.bukkit.World;
import org.bukkit.block.data.BlockData;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.permissions.PermissionAttachment;
import org.bukkit.permissions.PermissionAttachmentInfo;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.google.common.base.Enums;
import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.HoverEvent;
import net.md_5.bungee.api.chat.TextComponent;
import net.md_5.bungee.api.chat.hover.content.Text;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.Addon;
import world.bentobox.bentobox.api.events.OfflineMessageEvent;
import world.bentobox.bentobox.api.metadata.MetaDataAble;
import world.bentobox.bentobox.api.metadata.MetaDataValue;
import world.bentobox.bentobox.database.objects.Players;
import world.bentobox.bentobox.util.Util;
public class User implements MetaDataAble {
    private static final Map<UUID, User> users = new HashMap<>();
    private static final Map<Particle, Class<?>> VALIDATION_CHECK;
    static {
        Map<Particle, Class<?>> v = new EnumMap<>(Particle.class);
        v.put(Enums.getIfPresent(Particle.class, "DUST")
                .or(Enums.getIfPresent(Particle.class, "REDSTONE").or(Particle.FLAME)), Particle.DustOptions.class);
        if (Enums.getIfPresent(Particle.class, "ITEM").isPresent()) {
            v.put(Particle.ITEM, ItemStack.class);
            v.put(Particle.ITEM_COBWEB, ItemStack.class);
            v.put(Particle.BLOCK, BlockData.class);
            v.put(Particle.DUST_PILLAR, BlockData.class);
            v.put(Particle.ENTITY_EFFECT, Color.class);
        }
        v.put(Particle.FALLING_DUST, BlockData.class);
        v.put(Particle.BLOCK_MARKER, BlockData.class);
        v.put(Particle.DUST_COLOR_TRANSITION, DustTransition.class);
        v.put(Particle.VIBRATION, Vibration.class);
        v.put(Particle.SCULK_CHARGE, Float.class);
        v.put(Particle.SHRIEK, Integer.class);
        VALIDATION_CHECK = Collections.unmodifiableMap(v);
    }
    public static void clearUsers() {
        users.clear();
    }
    @NonNull
    public static User getInstance(@NonNull CommandSender sender) {
        if (sender instanceof Player p) {
            return getInstance(p);
        }
        return new User(sender);
    }
    @NonNull
    public static User getInstance(@NonNull Player player) {
        if (users.containsKey(player.getUniqueId())) {
            return users.get(player.getUniqueId());
        }
        return new User(player);
    }
    @NonNull
    public static User getInstance(@NonNull UUID uuid) {
        if (users.containsKey(uuid)) {
            return users.get(uuid);
        }
        return new User(uuid);
    }
    @NonNull
    public static User getInstance(@NonNull OfflinePlayer offlinePlayer) {
        if (users.containsKey(offlinePlayer.getUniqueId())) {
            return users.get(offlinePlayer.getUniqueId());
        }
        return new User(offlinePlayer);
    }
    public static void removePlayer(Player player) {
        if (player != null) {
            users.remove(player.getUniqueId());
        }
    }
    private static BentoBox plugin = BentoBox.getInstance();
    @Nullable
    private final Player player;
    private OfflinePlayer offlinePlayer;
    private final UUID playerUUID;
    @Nullable
    private final CommandSender sender;
    private Addon addon;
    private User(@Nullable CommandSender sender) {
        player = null;
        playerUUID = null;
        this.sender = sender;
    }
    private User(@NonNull Player player) {
        this.player = player;
        offlinePlayer = player;
        sender = player;
        playerUUID = player.getUniqueId();
        users.put(playerUUID, this);
    }
    private User(@NonNull OfflinePlayer offlinePlayer) {
        this.player = offlinePlayer.isOnline() ? offlinePlayer.getPlayer() : null;
        this.playerUUID = offlinePlayer.getUniqueId();
        this.sender = offlinePlayer.isOnline() ? offlinePlayer.getPlayer() : null;
        this.offlinePlayer = offlinePlayer;
    }
    private User(UUID playerUUID) {
        player = Bukkit.getPlayer(playerUUID);
        this.playerUUID = playerUUID;
        sender = player;
        offlinePlayer = Bukkit.getOfflinePlayer(playerUUID);
    }
    public static void setPlugin(BentoBox p) {
        plugin = p;
    }
    public Set<PermissionAttachmentInfo> getEffectivePermissions() {
        return sender.getEffectivePermissions();
    }
    @NonNull
    public PlayerInventory getInventory() {
        return Objects.requireNonNull(player, "getInventory can only be called for online players!").getInventory();
    }
    @NonNull
    public Location getLocation() {
        return Objects.requireNonNull(player, "getLocation can only be called for online players!").getLocation();
    }
    @NonNull
    public String getName() {
        return player != null ? player.getName() : plugin.getPlayers().getName(playerUUID);
    }
    @NonNull
    public String getDisplayName() {
        return player != null ? player.getDisplayName() : plugin.getPlayers().getName(playerUUID);
    }
    @NonNull
    public Player getPlayer() {
        return Objects.requireNonNull(player, "User is not a player!");
    }
    public boolean isPlayer() {
        return player != null;
    }
    @NonNull
    public OfflinePlayer getOfflinePlayer() {
        return Objects.requireNonNull(offlinePlayer, "User is not an OfflinePlayer!");
    }
    public boolean isOfflinePlayer() {
        return offlinePlayer != null;
    }
    @Nullable
    public CommandSender getSender() {
        return sender;
    }
    public UUID getUniqueId() {
        return playerUUID;
    }
    public boolean hasPermission(@Nullable String permission) {
        return permission == null || permission.isEmpty() || isOp() || sender.hasPermission(permission);
    }
    public boolean removePerm(String name) {
        for (PermissionAttachmentInfo p : player.getEffectivePermissions()) {
            if (p.getPermission().equals(name) && p.getAttachment() != null) {
                player.removeAttachment(p.getAttachment());
                break;
            }
        }
        player.recalculatePermissions();
        return !player.hasPermission(name);
    }
    public PermissionAttachment addPerm(String name) {
        return player.addAttachment(plugin, name, true);
    }
    public boolean isOnline() {
        return player != null && player.isOnline();
    }
    public boolean isOp() {
        if (sender != null) {
            return sender.isOp();
        }
        if (playerUUID != null && offlinePlayer != null) {
            return offlinePlayer.isOp();
        }
        return false;
    }
    public int getPermissionValue(String permissionPrefix, int defaultValue) {
        if (!isPlayer())
            return defaultValue;
        if (permissionPrefix.endsWith(".")) {
            permissionPrefix = permissionPrefix.substring(0, permissionPrefix.length() - 1);
        }
        final String permPrefix = permissionPrefix + ".";
        List<String> permissions = player.getEffectivePermissions().stream().filter(PermissionAttachmentInfo::getValue) 
                .map(PermissionAttachmentInfo::getPermission).filter(permission -> permission.startsWith(permPrefix))
                .toList();
        if (permissions.isEmpty())
            return defaultValue;
        return iteratePerms(permissions, permPrefix, defaultValue);
    }
    private int iteratePerms(List<String> permissions, String permPrefix, int defaultValue) {
        int value = 0;
        for (String permission : permissions) {
            if (permission.contains(permPrefix + "*")) {
                return defaultValue;
            } else {
                String[] spl = permission.split(permPrefix);
                if (spl.length > 1) {
                    if (!NumberUtils.isNumber(spl[1])) {
                        plugin.logError("Player " + player.getName() + " has permission: '" + permission
                                + "' <-- the last part MUST be a number! Ignoring...");
                    } else {
                        int v = Integer.parseInt(spl[1]);
                        if (v < 0) {
                            return v;
                        }
                        value = Math.max(value, v);
                    }
                }
            }
        }
        return value;
    }
    public String getTranslation(World world, String reference, String... variables) {
        String addonPrefix = plugin.getIWM().getAddon(world)
                .map(a -> a.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".").orElse("");
        return Util.translateColorCodes(translate(addonPrefix, reference, variables));
    }
    public String getTranslation(String reference, String... variables) {
        String addonPrefix = addon == null ? "" : addon.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".";
        return Util.translateColorCodes(translate(addonPrefix, reference, variables));
    }
    public String getTranslationNoColor(String reference, String... variables) {
        String addonPrefix = addon == null ? "" : addon.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".";
        return translate(addonPrefix, reference, variables);
    }
    private String translate(String addonPrefix, String reference, String[] variables) {
        String translation = plugin.getLocalesManager().get(this, addonPrefix + reference);
        if (translation == null) {
            translation = plugin.getLocalesManager().get(this, reference);
            if (translation == null) {
                return replaceVars(reference, variables);
            }
        }
        if (!reference.startsWith("prefixes.")) {
            return replacePrefixes(translation, variables);
        }
        return translation;
    }
    private String replacePrefixes(String translation, String[] variables) {
        for (String prefix : plugin.getLocalesManager().getAvailablePrefixes(this)) {
            String prefixTranslation = getTranslation("prefixes." + prefix);
            translation = translation.replace("[prefix_" + prefix + "]", prefixTranslation);
        }
        if (variables.length > 1) {
            for (int i = 0; i < variables.length; i += 2) {
                if (variables[i + 1] != null) {
                    translation = translation.replace(variables[i], variables[i + 1]);
                }
            }
        }
        if (player != null) {
            translation = plugin.getPlaceholdersManager().replacePlaceholders(player, translation);
        }
        if (addon != null && addon.getDescription() != null) {
            translation = translation.replace("[gamemode]", addon.getDescription().getName());
        }
        if (player != null && player.getWorld() != null) {
            translation = translation.replace("[friendly_name]",
                    isPlayer() ? plugin.getIWM().getFriendlyName(getWorld()) : "[friendly_name]");
        }
        return translation;
    }
    private String replaceVars(String reference, String[] variables) {
        if (variables.length > 1) {
            for (int i = 0; i < variables.length; i += 2) {
                reference = reference.replace(variables[i], variables[i + 1]);
            }
        }
        if (player != null) {
            reference = plugin.getPlaceholdersManager().replacePlaceholders(player, reference);
        }
        return reference;
    }
    public String getTranslationOrNothing(String reference, String... variables) {
        String translation = getTranslation(reference, variables);
        return translation.equals(reference) ? "" : translation;
    }
    public void sendMessage(String reference, String... variables) {
        String message = getTranslation(reference, variables);
        if (!ChatColor.stripColor(message).trim().isEmpty()) {
            sendRawMessage(message);
        }
    }
    public void sendRawMessage(String message) {
        TextComponent baseComponent = new TextComponent();
        Pattern pattern = Pattern.compile("\\[(\\w+): ([^\\]]+)]|\\[\\[(.*?)\\]]");
        Matcher matcher = pattern.matcher(message);
        int lastMatchEnd = 0;
        ClickEvent clickEvent = null;
        HoverEvent hoverEvent = null;
        while (matcher.find()) {
            if (matcher.start() > lastMatchEnd) {
                String beforeMatch = message.substring(lastMatchEnd, matcher.start());
                baseComponent.addExtra(TextComponent.fromLegacy(beforeMatch));
            }
            if (matcher.group(1) != null && matcher.group(2) != null) {
                String actionType = matcher.group(1).toUpperCase(Locale.ENGLISH); 
                String actionValue = matcher.group(2); 
                switch (actionType) {
                    case "RUN_COMMAND":
                    case "SUGGEST_COMMAND":
                    case "COPY_TO_CLIPBOARD":
                    case "OPEN_URL":
                        if (clickEvent == null) {
                            clickEvent = new ClickEvent(ClickEvent.Action.valueOf(actionType), actionValue);
                        }
                        break;
                    case "HOVER":
                        if (hoverEvent == null) {
                            hoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, new Text(actionValue));
                        }
                        break;
                    default:
                        baseComponent.addExtra(TextComponent.fromLegacy(matcher.group(0)));
                }
            } else if (matcher.group(3) != null) {
                baseComponent.addExtra(TextComponent.fromLegacy("[[" + matcher.group(3) + "]]"));
            }
            lastMatchEnd = matcher.end();
        }
        if (lastMatchEnd < message.length()) {
            String remainingText = message.substring(lastMatchEnd);
            baseComponent.addExtra(TextComponent.fromLegacy(remainingText));
        }
        if (clickEvent != null) {
            baseComponent.setClickEvent(clickEvent);
        }
        if (hoverEvent != null) {
            baseComponent.setHoverEvent(hoverEvent);
        }
        if (sender != null) {
            sender.spigot().sendMessage(baseComponent);
        } else {
            Bukkit.getPluginManager().callEvent(new OfflineMessageEvent(this.playerUUID, message));
        }
    }
    public void notify(String reference, String... variables) {
        String message = getTranslation(reference, variables);
        if (!ChatColor.stripColor(message).trim().isEmpty() && sender != null) {
            plugin.getNotifier().notify(this, message);
        }
    }
    public void notify(World world, String reference, String... variables) {
        String message = getTranslation(world, reference, variables);
        if (!ChatColor.stripColor(message).trim().isEmpty() && sender != null) {
            plugin.getNotifier().notify(this, message);
        }
    }
    public void setGameMode(GameMode mode) {
        player.setGameMode(mode);
    }
    public void teleport(Location location) {
        player.teleport(location);
    }
    @NonNull
    public World getWorld() {
        Objects.requireNonNull(player, "Cannot be called on a non-player User!");
        return Objects.requireNonNull(player.getWorld(), "Player's world cannot be null!");
    }
    public void closeInventory() {
        player.closeInventory();
    }
    public Locale getLocale() {
        if (sender instanceof Player && !plugin.getPlayers().getLocale(playerUUID).isEmpty()) {
            return Locale.forLanguageTag(plugin.getPlayers().getLocale(playerUUID));
        }
        return Locale.forLanguageTag(plugin.getSettings().getDefaultLanguage());
    }
    public void updateInventory() {
        player.updateInventory();
    }
    public boolean performCommand(String command) {
        PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(getPlayer(), command);
        Bukkit.getPluginManager().callEvent(event);
        if (!event.isCancelled()) {
            return getPlayer().performCommand(
                    event.getMessage().startsWith("/") ? event.getMessage().substring(1) : event.getMessage());
        }
        return true;
    }
    public boolean inWorld() {
        return plugin.getIWM().inWorld(getLocation());
    }
    public void spawnParticle(Particle particle, @Nullable Object dustOptions, double x, double y, double z) {
        Class<?> expectedClass = VALIDATION_CHECK.get(particle);
        if (expectedClass == null)
            throw new IllegalArgumentException("Unexpected value: " + particle);
        if (!(expectedClass.isInstance(dustOptions))) {
            throw new IllegalArgumentException("A non-null " + expectedClass.getSimpleName()
                    + " must be provided when using Particle." + particle + " as particle.");
        }
        if (this.player != null && this.player.getLocation().toVector().distanceSquared(new Vector(x, y,
                z)) < (Bukkit.getServer().getViewDistance() * 256 * Bukkit.getServer().getViewDistance())) {
            if (particle.equals(Enums.getIfPresent(Particle.class, "DUST")
                    .or(Enums.getIfPresent(Particle.class, "REDSTONE").or(Particle.FLAME)))) {
                player.spawnParticle(particle, x, y, z, 1, 0, 0, 0, 1, dustOptions);
            } else if (dustOptions != null) {
                player.spawnParticle(particle, x, y, z, 1, dustOptions);
            } else {
                player.spawnParticle(particle, x, y, z, 1);
            }
        }
    }
    public void spawnParticle(Particle particle, Particle.DustOptions dustOptions, double x, double y, double z) {
        this.spawnParticle(particle, (Object) dustOptions, x, y, z);
    }
    public void spawnParticle(Particle particle, Particle.DustOptions dustOptions, int x, int y, int z) {
        this.spawnParticle(particle, dustOptions, (double) x, (double) y, (double) z);
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((playerUUID == null) ? 0 : playerUUID.hashCode());
        return result;
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof User other)) {
            return false;
        }
        if (playerUUID == null) {
            return other.playerUUID == null;
        } else
            return playerUUID.equals(other.playerUUID);
    }
    public void setAddon(Addon addon) {
        this.addon = addon;
    }
    @Override
    public Optional<Map<String, MetaDataValue>> getMetaData() {
        Players p = plugin.getPlayers().getPlayer(playerUUID);
        return Objects.requireNonNull(p, "Unknown player for " + playerUUID).getMetaData();
    }
    @Override
    public void setMetaData(Map<String, MetaDataValue> metaData) {
        Players p = plugin.getPlayers().getPlayer(playerUUID);
        Objects.requireNonNull(p, "Unknown player for " + playerUUID).setMetaData(metaData);
    }
}
package world.bentobox.bentobox;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Optional;
import org.apache.commons.lang.exception.ExceptionUtils;
import org.bukkit.Bukkit;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.server.ServerCommandEvent;
import org.bukkit.generator.ChunkGenerator;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitTask;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.api.configuration.Config;
import world.bentobox.bentobox.api.events.BentoBoxReadyEvent;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.Notifier;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.commands.BentoBoxCommand;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.hooks.FancyNpcsHook;
import world.bentobox.bentobox.hooks.ItemsAdderHook;
import world.bentobox.bentobox.hooks.MultipaperHook;
import world.bentobox.bentobox.hooks.MultiverseCoreHook;
import world.bentobox.bentobox.hooks.MyWorldsHook;
import world.bentobox.bentobox.hooks.MythicMobsHook;
import world.bentobox.bentobox.hooks.SlimefunHook;
import world.bentobox.bentobox.hooks.VaultHook;
import world.bentobox.bentobox.hooks.ZNPCsPlusHook;
import world.bentobox.bentobox.hooks.placeholders.PlaceholderAPIHook;
import world.bentobox.bentobox.listeners.BannedCommands;
import world.bentobox.bentobox.listeners.BlockEndDragon;
import world.bentobox.bentobox.listeners.DeathListener;
import world.bentobox.bentobox.listeners.JoinLeaveListener;
import world.bentobox.bentobox.listeners.PanelListenerManager;
import world.bentobox.bentobox.listeners.PrimaryIslandListener;
import world.bentobox.bentobox.listeners.SeedWorldMakerListener;
import world.bentobox.bentobox.listeners.StandardSpawnProtectionListener;
import world.bentobox.bentobox.listeners.teleports.EntityTeleportListener;
import world.bentobox.bentobox.listeners.teleports.PlayerTeleportListener;
import world.bentobox.bentobox.managers.AddonsManager;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.managers.CommandsManager;
import world.bentobox.bentobox.managers.FlagsManager;
import world.bentobox.bentobox.managers.HooksManager;
import world.bentobox.bentobox.managers.IslandDeletionManager;
import world.bentobox.bentobox.managers.IslandWorldManager;
import world.bentobox.bentobox.managers.IslandsManager;
import world.bentobox.bentobox.managers.LocalesManager;
import world.bentobox.bentobox.managers.PlaceholdersManager;
import world.bentobox.bentobox.managers.PlayersManager;
import world.bentobox.bentobox.managers.RanksManager;
import world.bentobox.bentobox.managers.WebManager;
import world.bentobox.bentobox.util.heads.HeadGetter;
import world.bentobox.bentobox.versions.ServerCompatibility;
public class BentoBox extends JavaPlugin implements Listener {
    private static BentoBox instance;
    private PlayersManager playersManager;
    private IslandsManager islandsManager;
    private CommandsManager commandsManager;
    private LocalesManager localesManager;
    private AddonsManager addonsManager;
    private FlagsManager flagsManager;
    private IslandWorldManager islandWorldManager;
    private BlueprintsManager blueprintsManager;
    private HooksManager hooksManager;
    private PlaceholdersManager placeholdersManager;
    private IslandDeletionManager islandDeletionManager;
    private WebManager webManager;
    private Settings settings;
    private Notifier notifier;
    private HeadGetter headGetter;
    private boolean isLoaded;
    @Nullable
    private BStats metrics;
    private Config<Settings> configObject;
    private BukkitTask blueprintLoadingTask;
    private boolean shutdown;
    @Override
    public void onEnable(){
        setInstance(this);
        if (!ServerCompatibility.getInstance().checkCompatibility().isCanLaunch()) {
            logWarning("************ Disclaimer **************");
            logWarning("BentoBox may not be compatible with this server!");
            logWarning("BentoBox is tested only on the following Spigot versions:");
            List<String> versions = ServerCompatibility.ServerVersion.getVersions(ServerCompatibility.Compatibility.COMPATIBLE, ServerCompatibility.Compatibility.SUPPORTED)
                    .stream().map(ServerCompatibility.ServerVersion::toString).toList();
            logWarning(String.join(", ", versions));
            logWarning("**************************************");
        }
        isLoaded = false;
        final long loadStart = System.currentTimeMillis();
        saveDefaultConfig();
        flagsManager = new FlagsManager(this);
        if (!loadSettings()) {
            return;
        }
        saveConfig();
        playersManager = new PlayersManager(this);
        if (!this.isEnabled()) {
            return;
        }
        islandsManager = new IslandsManager(this);
        headGetter = new HeadGetter(this);
        notifier = new Notifier();
        commandsManager = new CommandsManager();
        new BentoBoxCommand();
        islandWorldManager = new IslandWorldManager(this);
        blueprintsManager = new BlueprintsManager(this);
        localesManager = new LocalesManager(this);
        hooksManager = new HooksManager(this);
        addonsManager = new AddonsManager(this);
        addonsManager.loadAddons();
        final long loadTime = System.currentTimeMillis() - loadStart;
        Bukkit.getScheduler().runTask(instance, () -> {
            try {
                completeSetup(loadTime);
            } catch (Exception e) {
                fireCriticalError(e.getMessage(), "");
                e.printStackTrace();
            }
        });
    }
    private void completeSetup(long loadTime) {
        final long enableStart = System.currentTimeMillis();
        hooksManager.registerHook(new MultipaperHook());
        hooksManager.registerHook(new VaultHook());
        hooksManager.registerHook(new FancyNpcsHook());
        hooksManager.registerHook(new ZNPCsPlusHook());
        hooksManager.registerHook(new MythicMobsHook());
        hooksManager.registerHook(new PlaceholderAPIHook());
        placeholdersManager = new PlaceholdersManager(this);
        addonsManager.enableAddons();
        addonsManager.getGameModeAddons().forEach(placeholdersManager::registerDefaultPlaceholders);
        registerListeners();
        log("Loading islands from database...");
        try {
            islandsManager.load();
        } catch (Exception e) {
            fireCriticalError(e.getMessage(), "Could not load islands!");
            return;
        }
        flagsManager.registerListeners();
        metrics = new BStats(this);
        metrics.registerMetrics();
        hooksManager.registerHook(new MultiverseCoreHook());
        hooksManager.registerHook(new MyWorldsHook());
        islandWorldManager.registerWorldsToMultiverse(true);
        hooksManager.registerHook(new SlimefunHook());
        hooksManager.registerHook(new ItemsAdderHook(this));
        webManager = new WebManager(this);
        final long enableTime = System.currentTimeMillis() - enableStart;
        User.getInstance(Bukkit.getConsoleSender()).sendMessage("successfully-loaded",
                TextVariables.VERSION, instance.getDescription().getVersion(),
                "[time]", String.valueOf(loadTime + enableTime));
        blueprintLoadingTask = Bukkit.getScheduler().runTaskTimer(instance, () -> {
            if (getBlueprintsManager().isBlueprintsLoaded()) {
                blueprintLoadingTask.cancel();
                isLoaded = true;
                this.addonsManager.allLoaded();
                settings.getReadyCommands().forEach(cmd -> Bukkit.getServer().dispatchCommand(getServer().getConsoleSender(), cmd));
                Bukkit.getPluginManager().callEvent(new BentoBoxReadyEvent());
                instance.log("All blueprints loaded.");
            }
        }, 0L, 1L);
        if (getSettings().getDatabaseType().equals(DatabaseSetup.DatabaseType.YAML)) {
            logWarning("*** You're still using YAML database ! ***");
            logWarning("This database type is being deprecated from BentoBox as some official addons encountered difficulties supporting it correctly.");
            logWarning("You should switch ASAP to an alternative database type. Please refer to the comments in BentoBox's config.yml.");
            logWarning("There is NO guarantee YAML database will remain properly supported in the following updates, and its usage should as such be considered a non-viable situation.");
            logWarning("*** *** *** *** *** *** *** *** *** *** ***");
        }
    }
    private void fireCriticalError(String message, String error) {
        logError("*****************CRITICAL ERROR!******************");
        logError(message);
        logError(error + " Disabling BentoBox...");
        logError("*************************************************");
        if (addonsManager != null) {
            addonsManager.disableAddons();
        }
        shutdown = true;
        instance.setEnabled(false);
    }
    private void registerListeners() {
        PluginManager manager = getServer().getPluginManager();
        manager.registerEvents(new JoinLeaveListener(this), this);
        manager.registerEvents(new PanelListenerManager(), this);
        manager.registerEvents(new StandardSpawnProtectionListener(this), this);
        manager.registerEvents(new PlayerTeleportListener(this), this);
        manager.registerEvents(new EntityTeleportListener(this), this);
        manager.registerEvents(new BlockEndDragon(this), this);
        manager.registerEvents(new BannedCommands(this), this);
        manager.registerEvents(new DeathListener(this), this);
        manager.registerEvents(this, this);
        islandDeletionManager = new IslandDeletionManager(this);
        manager.registerEvents(islandDeletionManager, this);
        manager.registerEvents(new PrimaryIslandListener(this), this);
        manager.registerEvents(new SeedWorldMakerListener(this), this);
    }
    @Override
    public void onDisable() {
        shutdown = true;
        HeadGetter.shutdown();
        if (addonsManager != null) {
            addonsManager.disableAddons();
        }
        if (playersManager != null) {
            playersManager.shutdown();
        }
        if (islandsManager != null) {
            islandsManager.shutdown();
        }
    }
    @EventHandler
    public void onServerStop(ServerCommandEvent e) {
    }
    public PlayersManager getPlayers() {
        return playersManager;
    }
    public PlayersManager getPlayersManager() {
        return getPlayers();
    }
    public IslandsManager getIslands() {
        return islandsManager;
    }
    public IslandsManager getIslandsManager() {
        return getIslands();
    }
    private static void setInstance(BentoBox plugin) {
        BentoBox.instance = plugin;
    }
    public static BentoBox getInstance() {
        return instance;
    }
    public CommandsManager getCommandsManager() {
        return commandsManager;
    }
    public LocalesManager getLocalesManager() {
        return localesManager;
    }
    public AddonsManager getAddonsManager() {
        return addonsManager;
    }
    public FlagsManager getFlagsManager() {
        return flagsManager;
    }
    @Deprecated(since = "2.0.0", forRemoval = true)
    public RanksManager getRanksManager() {
        return RanksManager.getInstance();
    }
    public IslandWorldManager getIWM() {
        return islandWorldManager;
    }
    public Settings getSettings() {
        return settings;
    }
    public boolean loadSettings() {
        log("Loading Settings from config.yml...");
        if (configObject == null) configObject = new Config<>(this, Settings.class);
        settings = configObject.loadConfigObject();
        if (settings == null) {
            logError("Settings did not load correctly - disabling plugin - please check config.yml");
            getPluginLoader().disablePlugin(this);
            return false;
        }
        log("Saving default panels...");
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "island_creation_panel.yml"))) {
            log("Saving default island_creation_panel...");
            this.saveResource("panels/island_creation_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "language_panel.yml"))) {
            log("Saving default language_panel...");
            this.saveResource("panels/language_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "island_homes_panel.yml"))) {
            log("Saving default island_homes_panel...");
            this.saveResource("panels/island_homes_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "team_invite_panel.yml"))) {
            log("Saving default team_invite_panel...");
            this.saveResource("panels/team_invite_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "team_panel.yml"))) {
            log("Saving default team_panel...");
            this.saveResource("panels/team_panel.yml", false);
        }
        return true;
    }
    @Override
    public void saveConfig() {
        if (settings != null) configObject.saveConfigObject(settings);
    }
    public Notifier getNotifier() {
        return notifier;
    }
    public HeadGetter getHeadGetter() {
        return headGetter;
    }
    public void log(String string) {
        getLogger().info(() -> string);
    }
    public void logDebug(Object object) {
        getLogger().info(() -> "DEBUG: " + object);
    }
    public void logError(String error) {
        getLogger().severe(() -> error);
    }
    public void logStacktrace(@NonNull Throwable throwable) {
        logError(ExceptionUtils.getStackTrace(throwable));
    }
    public void logWarning(String warning) {
        getLogger().warning(() -> warning);
    }
    public BlueprintsManager getBlueprintsManager() {
        return blueprintsManager;
    }
    public boolean isLoaded() {
        return isLoaded;
    }
    public HooksManager getHooks() {
        return hooksManager;
    }
    public Optional<VaultHook> getVault() {
        return Optional.ofNullable((VaultHook) hooksManager.getHook("Vault").orElse(null));
    }
    public PlaceholdersManager getPlaceholdersManager() {
        return placeholdersManager;
    }
    public IslandDeletionManager getIslandDeletionManager() {
        return islandDeletionManager;
    }
    @NonNull
    public Optional<BStats> getMetrics() {
        return Optional.ofNullable(metrics);
    }
    public WebManager getWebManager() {
        return webManager;
    }
    @Override
    public ChunkGenerator getDefaultWorldGenerator(@NonNull String worldName, String id) {
        return addonsManager.getDefaultWorldGenerator(worldName, id);
    }
    @Override
    public void reloadConfig() {
        loadSettings();
    }
    public boolean isShutdown() {
        return shutdown;
    }
}
package world.bentobox.bentobox.panels;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import org.bukkit.Material;
import org.bukkit.Sound;
import org.bukkit.World;
import org.bukkit.World.Environment;
import org.bukkit.conversations.Conversable;
import org.bukkit.conversations.ConversationFactory;
import org.bukkit.event.inventory.ClickType;
import org.eclipse.jdt.annotation.NonNull;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.panels.PanelItem;
import world.bentobox.bentobox.api.panels.builders.PanelBuilder;
import world.bentobox.bentobox.api.panels.builders.PanelItemBuilder;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.blueprints.conversation.DescriptionPrompt;
import world.bentobox.bentobox.blueprints.conversation.NameConversationPrefix;
import world.bentobox.bentobox.blueprints.conversation.NamePrompt;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBundle;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
public class BlueprintManagementPanel {
    private final BentoBox plugin;
    private final Blueprint normalBlueprint;
    private final Blueprint netherBlueprint;
    private final Blueprint endBlueprint;
    private final Map<Integer, World.Environment> slotToEnvironment;
    private final Map<World.Environment, Blueprint> environmentToBlueprint;
    private static final int MAX_WORLD_SLOT = 9;
    private static final int MIN_WORLD_SLOT = 0;
    public static final int MAX_BP_SLOT = 35;
    private static final String INSTRUCTION = "instruction";
    private Entry<Integer, Blueprint> selected;
    private final Map<Integer, Blueprint> blueprints = new HashMap<>();
    private final User user;
    private final GameModeAddon addon;
    public BlueprintManagementPanel(@NonNull BentoBox plugin, @NonNull User user, @NonNull GameModeAddon addon) {
        this.plugin = plugin;
        this.user = user;
        this.addon = addon;
        normalBlueprint = new Blueprint().setIcon(Material.GREEN_STAINED_GLASS_PANE)
                .setName(user.getTranslation("general.worlds.overworld"))
                .setDescription(t(INSTRUCTION));
        netherBlueprint = new Blueprint().setIcon(Material.RED_STAINED_GLASS_PANE)
                .setName(user.getTranslation("general.worlds.nether"))
                .setDescription(t(INSTRUCTION));
        endBlueprint = new Blueprint().setIcon(Material.YELLOW_STAINED_GLASS_PANE)
                .setName(user.getTranslation("general.worlds.the-end"))
                .setDescription(t(INSTRUCTION));
        slotToEnvironment = Map.of(3, World.Environment.NORMAL, 5, World.Environment.NETHER, 7, World.Environment.THE_END);
        environmentToBlueprint = Map.of(World.Environment.NORMAL, normalBlueprint, World.Environment.NETHER, netherBlueprint, World.Environment.THE_END, endBlueprint);
    }
    private String t(String t) {
        return user.getTranslation("commands.admin.blueprint.management." + t);
    }
    private String t(String t, String... vars) {
        return user.getTranslation("commands.admin.blueprint.management." + t, vars);
    }
    public void openPanel() {
        PanelBuilder pb = new PanelBuilder().name(t("title")).user(user).size(45);
        pb.item(36, getNewBundle(addon));
        Comparator<BlueprintBundle> sortByDisplayName = (p, o) -> p.getDisplayName().compareToIgnoreCase(o.getDisplayName());
        plugin.getBlueprintsManager().getBlueprintBundles(addon).values().stream().limit(36)
        .sorted(sortByDisplayName)
        .forEach(bb -> {
            PanelItem item = new PanelItemBuilder()
                    .name(bb.getDisplayName())
                    .description(t("edit"), t("rename"))
                    .icon(bb.getIcon())
                    .clickHandler((panel, u, clickType, slot) -> {
                        u.closeInventory();
                        if (clickType.equals(ClickType.RIGHT)) {
                            askForName(u.getPlayer(), addon, bb);
                        } else {
                            openBB(bb);
                        }
                        return true;
                    })
                    .build();
            if (bb.getSlot() < 0 || bb.getSlot() > MAX_BP_SLOT) {
                bb.setSlot(0);
            }
            if (pb.slotOccupied(bb.getSlot())) {
                int slot = getFirstAvailableSlot(pb);
                if (slot == -1) {
                    plugin.logError("Too many blueprint bundles to show!");
                    pb.item(item);
                } else {
                    pb.item(slot, item);
                }
            } else {
                pb.item(bb.getSlot(), item);
            }
        });
        pb.build();
    }
    private static int getFirstAvailableSlot(PanelBuilder pb) {
        for (int i = 0; i < BlueprintManagementPanel.MAX_BP_SLOT; i++) {
            if (!pb.slotOccupied(i)) {
                return i;
            }
        }
        return -1;
    }
    public void openBB(BlueprintBundle bb) {
        int index = 18;
        for (Blueprint bp : plugin.getBlueprintsManager().getBlueprints(addon).values()) {
            blueprints.put(index++, bp);
        }
        PanelBuilder pb = new PanelBuilder().name(bb.getDisplayName()).user(user).size(45).listener(new IconChanger(plugin, addon, this, bb));
        pb.item(0, getBundleIcon(bb));
        slotToEnvironment.forEach((k, v) -> {
            String bpName = bb.getBlueprint(v);
            pb.item(k-1, getWorldInstrTile(v));
            pb.item(k, getBlueprintItem(addon, k, bb, plugin.getBlueprintsManager().getBlueprints(addon).getOrDefault(bpName, environmentToBlueprint.get(v))));
        });
        for (int i = 9; i < 18; i++) {
            pb.item(i, new PanelItemBuilder().icon(Material.BLACK_STAINED_GLASS_PANE).name(" ").build());
        }
        blueprints.entrySet().stream().limit(18).forEach(b -> pb.item(getBlueprintItem(addon, b.getKey(), bb, b.getValue())));
        if (bb.getUniqueId().equals(BlueprintsManager.DEFAULT_BUNDLE_NAME)) {
            pb.item(36, getNoTrashIcon());
            pb.item(39, getNoPermissionIcon());
        } else {
            pb.item(36, getTrashIcon(addon, bb));
            pb.item(39, getPermissionIcon(addon, bb));
        }
        if (plugin.getSettings().getIslandNumber() > 1) {
            pb.item(42, getTimesIcon(bb));
        }
        pb.item(40, getSlotIcon(addon, bb));
        pb.item(44, new PanelItemBuilder().icon(Material.OAK_DOOR).name(t("back")).clickHandler((panel, u, clickType, slot) -> {
            openPanel();
            return true;
        }).build());
        pb.build();
    }
    private PanelItem getTimesIcon(BlueprintBundle bb) {
        return new PanelItemBuilder().icon(Material.CLOCK).name(t("times"))
                .description(bb.getTimes() == 0 ? t("unlimited-times")
                        : t("maximum-times", TextVariables.NUMBER, String.valueOf(bb.getTimes())))
                .clickHandler((panel, u, clickType, slot) -> {
                    u.getPlayer().playSound(u.getLocation(), Sound.UI_BUTTON_CLICK, 1F, 1F);
                    if (clickType == ClickType.LEFT) {
                        bb.setTimes(bb.getTimes() + 1);
                    } else if (clickType == ClickType.RIGHT && bb.getTimes() > 0) {
                        bb.setTimes(bb.getTimes() - 1);
                    }
                    plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                    panel.getInventory().setItem(42, getTimesIcon(bb).getItem());
                    return true;
                }).build();
    }
    private PanelItem getSlotIcon(GameModeAddon addon, BlueprintBundle bb) {
        return new PanelItemBuilder()
                .name(t("slot", TextVariables.NUMBER, String.valueOf(bb.getSlot())))
                .description(t("slot-instructions"))
                .icon(Material.IRON_TRAPDOOR)
                .clickHandler((panel, u, clickType, slot) -> {
                    if (clickType.isLeftClick()) {
                        bb.setSlot(bb.getSlot() + 1);
                        if (bb.getSlot() > MAX_BP_SLOT) {
                            bb.setSlot(0);
                        }
                    } else if (clickType.isRightClick()) {
                        bb.setSlot(bb.getSlot() - 1);
                        if (bb.getSlot() < 0) {
                            bb.setSlot(MAX_BP_SLOT);
                        }
                    }
                    u.getPlayer().playSound(u.getLocation(), Sound.UI_BUTTON_CLICK, 1F, 1F);
                    plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                    panel.getInventory().setItem(40, getSlotIcon(addon, bb).getItem());
                    return true;
                })
                .build();
    }
    protected PanelItem getBundleIcon(BlueprintBundle bb) {
        return new PanelItemBuilder()
                .name(t("edit-description"))
                .description(bb.getDescription().stream().map(Util::translateColorCodes).toList())
                .icon(bb.getIcon())
                .clickHandler((panel, u, clickType, slot) -> {
                    u.closeInventory();
                    askForDescription(u.getPlayer(), addon, bb);
                    return true;
                })
                .build();
    }
    private PanelItem getWorldInstrTile(Environment env) {
        Material icon;
        String worldName;
        switch (env) {
        case NORMAL -> {
            icon = Material.GRASS_BLOCK;
            worldName = normalBlueprint.getName();
        }
        case NETHER -> {
            icon = Material.NETHERRACK;
            worldName = netherBlueprint.getName();
        }
        case THE_END -> {
            icon = Material.END_STONE;
            worldName = endBlueprint.getName();
        }
        default -> {
            icon = Material.STONE;
            worldName = Util.prettifyText(env.name());
        }
        }
        return new PanelItemBuilder()
                .name(t("world-name-syntax", TextVariables.NAME, worldName))
                .description(t("world-instructions"))
                .glow(true)
                .icon(icon)
                .build();
    }
    private PanelItem getTrashIcon(@NonNull GameModeAddon addon, BlueprintBundle bb) {
        return new PanelItemBuilder()
                .name(t("trash"))
                .description(t("trash-instructions"))
                .icon(Material.TNT)
                .clickHandler((panel, u, clickType, slot) -> {
                    if (clickType.equals(ClickType.RIGHT)) {
                        u.getPlayer().playSound(u.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);
                        plugin.getBlueprintsManager().deleteBlueprintBundle(addon, bb);
                        openPanel();
                    }
                    return true;
                })
                .build();
    }
    private PanelItem getNoTrashIcon() {
        return new PanelItemBuilder()
                .name(t("no-trash"))
                .description(t("no-trash-instructions"))
                .icon(Material.TNT)
                .build();
    }
    private PanelItem getPermissionIcon(@NonNull GameModeAddon addon, BlueprintBundle bb) {
        return new PanelItemBuilder().icon(Material.PAINTING).name(t("permission"))
                .description(bb.isRequirePermission() ? t("perm-required") : t("perm-not-required"))
                .description(bb.isRequirePermission() ? t("perm-format") + addon.getPermissionPrefix() + "island.create."  + bb.getUniqueId() : "")
                .clickHandler((panel, u, clickType, slot) -> {
                    u.getPlayer().playSound(u.getLocation(), Sound.UI_BUTTON_CLICK, 1F, 1F);
                    bb.setRequirePermission(!bb.isRequirePermission());
                    plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                    panel.getInventory().setItem(39, getPermissionIcon(addon, bb).getItem());
                    return true;
                }).build();
    }
    private PanelItem getNoPermissionIcon() {
        return new PanelItemBuilder().icon(Material.PAINTING).name(t("no-permission"))
                .description(t("no-perm-required"))
                .build();
    }
    protected PanelItem getBlueprintItem(GameModeAddon addon, int pos, BlueprintBundle bb, Blueprint blueprint) {
        List<String> desc = blueprint.getDescription() == null ? new ArrayList<>() : blueprint.getDescription();
        desc = desc.stream().map(Util::translateColorCodes).collect(Collectors.toList()); 
        if ((!blueprint.equals(endBlueprint) && !blueprint.equals(normalBlueprint) && !blueprint.equals(netherBlueprint))) {
            if ((pos > MIN_WORLD_SLOT && pos < MAX_WORLD_SLOT)) {
                desc.add(t("remove"));
            } else {
                desc.add(t("blueprint-instruction"));
            }
        }
        return new PanelItemBuilder()
                .name(blueprint.getDisplayName() == null ? blueprint.getName() : blueprint.getDisplayName())
                .description(desc)
                .icon(blueprint.getIcon())
                .glow(selected != null && pos == selected.getKey())
                .clickHandler((panel, u, clickType, slot) -> {
                    if (slot > MIN_WORLD_SLOT && slot < MAX_WORLD_SLOT) {
                        if (clickType.equals(ClickType.RIGHT)) {
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_GLASS_BREAK, 1F, 1F);
                            bb.clearBlueprint(slotToEnvironment.get(slot));
                            plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                            openBB(bb);
                        } else if (selected == null) {
                            u.sendMessage("commands.admin.blueprint.management.select-first");
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_ANVIL_HIT, 1F, 1F);
                        } else {
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_METAL_HIT, 1F, 1F);
                            Blueprint bp = selected.getValue();
                            bb.setBlueprint(slotToEnvironment.get(slot), bp);
                            plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                            openBB(bb);
                        }
                    } else {
                        if (blueprints.containsKey(slot)) {
                            if (clickType.equals(ClickType.RIGHT)) {
                                u.closeInventory();
                                this.askForBlueprintName(u.getPlayer(), addon, blueprint, bb);
                                return true;
                            }
                            if (selected != null && slot == selected.getKey()){
                                selected = null;
                            } else {
                                selected = new AbstractMap.SimpleEntry<>(slot, blueprints.get(slot));
                            }
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_METAL_HIT, 1F, 2F);
                            openBB(bb);
                        }
                    }
                    return true;
                })
                .build();
    }
    private PanelItem getNewBundle(@NonNull GameModeAddon addon) {
        return new PanelItemBuilder()
                .name(t("new-bundle"))
                .description(t("new-bundle-instructions"))
                .icon(Material.GREEN_BANNER)
                .clickHandler((panel, u, clickType, slot) -> {
                    u.closeInventory();
                    askForName(u.getPlayer(), addon, null);
                    return true;
                })
                .build();
    }
    public void askForName(Conversable whom, GameModeAddon addon, BlueprintBundle bb) {
        new ConversationFactory(BentoBox.getInstance())
        .withModality(true)
        .withLocalEcho(false)
        .withPrefix(new NameConversationPrefix())
        .withTimeout(90)
        .withFirstPrompt(new NamePrompt(addon, bb))
        .withEscapeSequence(t("name.quit"))
        .buildConversation(whom).begin();
    }
    public void askForBlueprintName(Conversable whom, GameModeAddon addon, Blueprint bp, BlueprintBundle bb) {
        new ConversationFactory(BentoBox.getInstance())
        .withModality(true)
        .withLocalEcho(false)
        .withPrefix(new NameConversationPrefix())
        .withTimeout(90)
        .withFirstPrompt(new NamePrompt(addon, bp, bb))
        .withEscapeSequence(t("name.quit"))
        .buildConversation(whom).begin();
    }
    public void askForDescription(Conversable whom, GameModeAddon addon, BlueprintBundle bb) {
        new ConversationFactory(BentoBox.getInstance())
        .withModality(true)
        .withLocalEcho(false)
        .withPrefix(new NameConversationPrefix())
        .withTimeout(90)
        .withFirstPrompt(new DescriptionPrompt(addon, bb))
        .buildConversation(whom).begin();
    }
    public Entry<Integer, Blueprint> getSelected() {
        return selected;
    }
}
package world.bentobox.bentobox.managers.island;
import java.io.IOException;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.World.Environment;
import org.bukkit.util.Vector;
import world.bentobox.bentobox.BStats;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.events.IslandBaseEvent;
import world.bentobox.bentobox.api.events.island.IslandCreateEvent;
import world.bentobox.bentobox.api.events.island.IslandEvent;
import world.bentobox.bentobox.api.events.island.IslandEvent.Reason;
import world.bentobox.bentobox.api.events.island.IslandResetEvent;
import world.bentobox.bentobox.api.logs.LogEntry;
import world.bentobox.bentobox.api.logs.LogEntry.LogType;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.managers.IslandsManager;
public class NewIsland {
    private final BentoBox plugin;
    private Island island;
    private final User user;
    private final Reason reason;
    private final World world;
    private String name;
    private final boolean noPaste;
    private final GameModeAddon addon;
    private NewIslandLocationStrategy locationStrategy;
    public NewIsland(Builder builder) throws IOException {
        plugin = BentoBox.getInstance();
        this.user = builder.user2;
        this.reason = builder.reason2;
        this.world = builder.world2;
        this.name = builder.name2;
        this.noPaste = builder.noPaste2;
        this.addon = builder.addon2;
        this.locationStrategy = builder.locationStrategy2;
        if (this.locationStrategy == null) {
            this.locationStrategy = new DefaultNewIslandLocationStrategy();
        }
        IslandBaseEvent event = IslandEvent.builder().involvedPlayer(user.getUniqueId()).reason(Reason.PRECREATE)
                .build();
        if (event.getNewEvent().map(IslandBaseEvent::isCancelled).orElse(event.isCancelled())) {
            return;
        }
        newIsland(builder.oldIsland2);
    }
    public Island getIsland() {
        return island;
    }
    public static Builder builder() {
        return new Builder();
    }
    public static class Builder {
        private Island oldIsland2;
        private User user2;
        private Reason reason2;
        private World world2;
        private String name2 = BlueprintsManager.DEFAULT_BUNDLE_NAME;
        private boolean noPaste2;
        private GameModeAddon addon2;
        private NewIslandLocationStrategy locationStrategy2;
        public Builder oldIsland(Island oldIsland) {
            this.oldIsland2 = oldIsland;
            this.world2 = oldIsland.getWorld();
            return this;
        }
        public Builder player(User player) {
            this.user2 = player;
            return this;
        }
        public Builder reason(Reason reason) {
            if (!reason.equals(Reason.CREATE) && !reason.equals(Reason.RESET)) {
                throw new IllegalArgumentException("Reason must be CREATE or RESET.");
            }
            this.reason2 = reason;
            return this;
        }
        public Builder addon(GameModeAddon addon) {
            this.addon2 = addon;
            this.world2 = addon.getOverWorld();
            return this;
        }
        public Builder noPaste() {
            this.noPaste2 = true;
            return this;
        }
        public Builder name(String name) {
            this.name2 = name;
            return this;
        }
        public Builder locationStrategy(NewIslandLocationStrategy strategy) {
            this.locationStrategy2 = strategy;
            return this;
        }
        public Island build() throws IOException {
            if (user2 != null) {
                NewIsland newIsland = new NewIsland(this);
                return newIsland.getIsland();
            }
            throw new IOException("Insufficient parameters. Must have a user!");
        }
    }
    public void newIsland(Island oldIsland) throws IOException {
        Location next = checkReservedIsland();
        if (next == null) {
            next = this.makeNextIsland();
        }
        cleanUpUser(next);
        IslandBaseEvent event = IslandEvent.builder().involvedPlayer(user.getUniqueId()).reason(reason).island(island)
                .location(island.getCenter())
                .blueprintBundle(plugin.getBlueprintsManager().getBlueprintBundles(addon).get(name))
                .oldIsland(oldIsland).build();
        if (event.getNewEvent().map(IslandBaseEvent::isCancelled).orElse(event.isCancelled())) {
            return;
        }
        event = event.getNewEvent().orElse(event);
        switch (reason) {
        case CREATE -> name = ((IslandCreateEvent) event).getBlueprintBundle().getUniqueId();
        case RESET -> name = ((IslandResetEvent) event).getBlueprintBundle().getUniqueId();
        default -> {
        }
        }
        plugin.getIslands().setPrimaryIsland(user.getUniqueId(), island);
        if (noPaste) {
            Bukkit.getScheduler().runTask(plugin, () -> postCreationTask(oldIsland));
        } else {
            boolean useNMS = !user.getWorld().equals(island.getWorld())
                    || (user.getLocation().distance(island.getCenter()) >= Bukkit.getViewDistance() * 16D);
            plugin.getBlueprintsManager().paste(addon, island, name, () -> postCreationTask(oldIsland), useNMS);
        }
        island.setFlagsDefaults();
        plugin.getMetrics().ifPresent(BStats::increaseIslandsCreatedCount);
        island.log(new LogEntry.Builder(LogType.JOINED).data(user.getUniqueId().toString(), "owner").build());
        IslandsManager.updateIsland(island);
    }
    private void postCreationTask(Island oldIsland) {
        if (island.getSpawnPoint(Environment.NORMAL) != null) {
            plugin.getIslands().setHomeLocation(user, island.getSpawnPoint(Environment.NORMAL));
        }
        if (user.isOnline()) {
            if (reason.equals(Reason.RESET) || (reason.equals(Reason.CREATE)
                    && plugin.getIWM().isTeleportPlayerToIslandUponIslandCreation(world))) {
                user.getPlayer().setVelocity(new Vector(0, 0, 0));
                user.getPlayer().setFallDistance(0F);
                plugin.getIslands().homeTeleportAsync(world, user.getPlayer(), true).thenRun(() -> tidyUp(oldIsland));
                return;
            } else {
                user.sendMessage("commands.island.create.you-can-teleport-to-your-island");
            }
        } else {
            User.removePlayer(user.getPlayer());
        }
        tidyUp(oldIsland);
    }
    private void cleanUpUser(Location loc) {
        if (plugin.getIWM().isDeathsResetOnNewIsland(world)) {
            plugin.getPlayers().setDeaths(world, user.getUniqueId(), 0);
        }
        island.setProtectionRange(user.getPermissionValue(
                plugin.getIWM().getAddon(island.getWorld()).map(GameModeAddon::getPermissionPrefix).orElse("")
                        + "island.range",
                island.getProtectionRange()));
    }
    private Location makeNextIsland() throws IOException {
        Location next = this.locationStrategy.getNextLocation(world);
        if (next == null) {
            plugin.logError("Failed to make island - no unoccupied spot found.");
            plugin.logError("If the world was imported, try multiple times until all unowned islands are known.");
            throw new IOException("commands.island.create.cannot-create-island");
        }
        island = plugin.getIslands().createIsland(next, user.getUniqueId());
        if (island == null) {
            plugin.logError("Failed to make island! Island could not be added to the grid.");
            throw new IOException("commands.island.create.unable-create-island");
        }
        return next;
    }
    private Location checkReservedIsland() {
        if (plugin.getIslands().hasIsland(world, user)) {
            island = plugin.getIslands().getIsland(world, user);
            if (island != null && island.isReserved()) {
                Location l = island.getCenter();
                island.setReserved(false);
                return l;
            }
        }
        return null;
    }
    private void tidyUp(Island oldIsland) {
        if (oldIsland != null) {
            plugin.getIslands().deleteIsland(oldIsland, true, user.getUniqueId());
        }
        IslandEvent.builder().involvedPlayer(user.getUniqueId())
                .reason(reason == Reason.RESET ? Reason.RESETTED : Reason.CREATED).island(island)
                .location(island.getCenter()).oldIsland(oldIsland).build();
    }
}
package world.bentobox.bentobox.managers;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.InputMismatchException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.jar.JarFile;
import java.util.stream.Collectors;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.InstanceCreator;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.Addon;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.metadata.MetaDataValue;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.blueprints.BlueprintPaster;
import world.bentobox.bentobox.blueprints.DisplayListener;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBlock;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBundle;
import world.bentobox.bentobox.database.json.BentoboxTypeAdapterFactory;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.util.Util;
public class BlueprintsManager {
    private static final String BLUEPRINT_BUNDLE_SUFFIX = ".json";
    public static final String BLUEPRINT_SUFFIX = ".blu";
    public static final String DEFAULT_BUNDLE_NAME = "default";
    @NonNull
    public static final String FOLDER_NAME = "blueprints";
    private static final String FOR = "' for ";
    @NonNull
    private final Map<GameModeAddon, List<BlueprintBundle>> blueprintBundles;
    @NonNull
    private final Map<GameModeAddon, List<Blueprint>> blueprints;
    private final Gson gson;
    private final @NonNull BentoBox plugin;
    @NonNull
    private final Set<GameModeAddon> blueprintsLoaded;
    public BlueprintsManager(@NonNull BentoBox plugin) {
        this.plugin = plugin;
        this.blueprintBundles = new ConcurrentHashMap<>();
        this.blueprints = new ConcurrentHashMap<>();
        @SuppressWarnings({"rawtypes", "unchecked"})
        GsonBuilder builder = new GsonBuilder()
        .excludeFieldsWithoutExposeAnnotation()
        .enableComplexMapKeySerialization()
        .setPrettyPrinting()
        .registerTypeAdapter(EnumMap.class, (InstanceCreator<EnumMap>) type -> {
            Type[] types = (((ParameterizedType) type).getActualTypeArguments());
            return new EnumMap((Class<?>) types[0]);
        });
        builder.disableHtmlEscaping();
        builder.registerTypeAdapterFactory(new BentoboxTypeAdapterFactory(plugin));
        gson = builder.create();
        blueprintsLoaded = new HashSet<>();
        Bukkit.getPluginManager().registerEvents(new DisplayListener(), plugin);
    }
    public void extractDefaultBlueprints(@NonNull GameModeAddon addon) {
        File folder = getBlueprintsFolder(addon);
        if (folder.exists()) {
            return;
        }
        if (!folder.exists() && !folder.mkdirs()) {
            plugin.logError("Could not create the '" + FOLDER_NAME + "' folder!");
            plugin.logError("This might be due to incorrectly set-up write permissions on the operating system.");
            return;
        }
        try (JarFile jar = new JarFile(addon.getFile())) {
            Util.listJarFiles(jar, FOLDER_NAME, BLUEPRINT_BUNDLE_SUFFIX).forEach(name -> addon.saveResource(name, false));
            Util.listJarFiles(jar, FOLDER_NAME, BLUEPRINT_SUFFIX).forEach(name -> addon.saveResource(name, false));
        } catch (IOException e) {
            plugin.logError("Could not load blueprint files from addon jar " + e.getMessage());
        }
    }
    @NonNull
    public Map<String, BlueprintBundle> getBlueprintBundles(@NonNull GameModeAddon addon) {
        if (!blueprintBundles.containsKey(addon)) {
            return new HashMap<>();
        }
        return blueprintBundles.get(addon).stream().collect(Collectors.toMap(BlueprintBundle::getUniqueId, b -> b));
    }
    @Nullable
    public BlueprintBundle getDefaultBlueprintBundle(@NonNull GameModeAddon addon) {
        if (blueprintBundles.containsKey(addon)) {
            return blueprintBundles.get(addon).stream().filter(bb -> bb.getUniqueId().equals(DEFAULT_BUNDLE_NAME)).findFirst().orElse(null);
        }
        return null;
    }
    @NonNull
    private File getBlueprintsFolder(@NonNull GameModeAddon addon) {
        return new File(addon.getDataFolder(), FOLDER_NAME);
    }
    public void loadBlueprintBundles(@NonNull GameModeAddon addon) {
        blueprintsLoaded.add(addon);
        Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
            blueprintBundles.put(addon, new ArrayList<>());
            if (!loadBundles(addon)) {
                makeDefaults(addon);
                loadBundles(addon);
            }
            loadBlueprints(addon);
            blueprintsLoaded.remove(addon);
        });
    }
    public boolean isBlueprintsLoaded() {
        return blueprintsLoaded.isEmpty();
    }
    private boolean loadBundles(@NonNull GameModeAddon addon) {
        File bpf = getBlueprintsFolder(addon);
        if (!bpf.exists()) {
            plugin.logError("There is no blueprint folder for addon " + addon.getDescription().getName());
            bpf.mkdirs();
        }
        boolean loaded = false;
        File[] bundles = bpf.listFiles((dir, name) -> name.endsWith(BLUEPRINT_BUNDLE_SUFFIX));
        if (bundles == null || bundles.length == 0) {
            return false;
        }
        for (File file : bundles) {
            try (FileReader fileReader = new FileReader(file, StandardCharsets.UTF_8))
            {
                if (!file.getName().equals(Util.sanitizeInput(file.getName())))
                {
                    throw new InputMismatchException(file.getName());
                }
                BlueprintBundle bb = gson.fromJson(fileReader, BlueprintBundle.class);
                if (bb != null) {
                    if (blueprintBundles.get(addon).stream().noneMatch(bundle ->  bundle.getUniqueId().equals(bb.getUniqueId()))) {
                        blueprintBundles.get(addon).add(bb);
                        plugin.log("Loaded Blueprint Bundle '" + bb.getUniqueId() + FOR + addon.getDescription().getName() + ".");
                        loaded = true;
                    } else {
                        plugin.logWarning("Could not load blueprint bundle '" + file.getName() + FOR + addon.getDescription().getName() + ".");
                        plugin.logWarning("The uniqueId '" + bb.getUniqueId() + "' is already used by another Blueprint Bundle.");
                        plugin.logWarning("This can occur if the Blueprint Bundles' files were manually edited.");
                        plugin.logWarning("Please review your Blueprint Bundles' files and make sure their uniqueIds are not in duplicate.");
                    }
                }
            } catch (Exception e) {
                plugin.logError("Could not load blueprint bundle '" + file.getName() + "'. Cause: " + e.getMessage() + ".");
                plugin.logStacktrace(e);
            }
        }
        return loaded;
    }
    private BlueprintBundle getDefaultBlueprintBundle() {
        BlueprintBundle bb = new BlueprintBundle();
        bb.setIcon(Material.PAPER);
        bb.setUniqueId(DEFAULT_BUNDLE_NAME);
        bb.setDisplayName("Default bundle");
        bb.setDescription(Collections.singletonList(ChatColor.AQUA + "Default bundle of blueprints"));
        return bb;
    }
    private Blueprint getDefaultBlueprint() {
        Blueprint defaultBp = new Blueprint();
        defaultBp.setName("bedrock");
        defaultBp.setDescription(Collections.singletonList(ChatColor.AQUA + "A bedrock block"));
        defaultBp.setBedrock(new Vector(0, 0, 0));
        Map<Vector, BlueprintBlock> map = new HashMap<>();
        map.put(new Vector(0, 0, 0), new BlueprintBlock("minecraft:bedrock"));
        defaultBp.setBlocks(map);
        return defaultBp;
    }
    private void makeDefaults(@NonNull GameModeAddon addon) {
        plugin.logError("No blueprint bundles found! Creating a default one.");
        BlueprintBundle bb = getDefaultBlueprintBundle();
        Blueprint defaultBp = getDefaultBlueprint();
        new BlueprintClipboardManager(plugin, getBlueprintsFolder(addon)).saveBlueprint(defaultBp);
        bb.setBlueprint(World.Environment.NORMAL, defaultBp);
        bb.setBlueprint(World.Environment.NETHER, defaultBp);
        bb.setBlueprint(World.Environment.THE_END, defaultBp);
        bb.setUniqueId(DEFAULT_BUNDLE_NAME);
        blueprintBundles.get(addon).add(bb);
        this.saveBlueprintBundles();
    }
    public void loadBlueprints(@NonNull GameModeAddon addon) {
        blueprints.put(addon, new ArrayList<>());
        File bpf = getBlueprintsFolder(addon);
        if (!bpf.exists()) {
            plugin.logError("There is no blueprint folder for addon " + addon.getDescription().getName());
            bpf.mkdirs();
        }
        File[] bps = bpf.listFiles((dir, name) -> name.endsWith(BLUEPRINT_SUFFIX));
        if (bps == null || bps.length == 0) {
            plugin.logError("No blueprints found for " + addon.getDescription().getName());
            return;
        }
        for (File file : bps) {
            String fileName = Util.sanitizeInput(file.getName().substring(0, file.getName().length() - BLUEPRINT_SUFFIX.length()));
            try {
                Blueprint bp = new BlueprintClipboardManager(plugin, bpf).loadBlueprint(fileName);
                bp.setName(fileName);
                blueprints.get(addon).add(bp);
                plugin.log("Loaded blueprint '" + bp.getName() + FOR + addon.getDescription().getName());
            } catch (Exception e) {
                plugin.logError("Could not load blueprint " + fileName + " " + e.getMessage());
                plugin.logStacktrace(e);
            }
        }
    }
    public void addBlueprint(@NonNull GameModeAddon addon, @NonNull Blueprint bp) {
        blueprints.putIfAbsent(addon, new ArrayList<>());
        blueprints.get(addon).removeIf(b -> b.getName().equals(bp.getName()));
        blueprints.get(addon).add(bp);
        plugin.log("Added blueprint '" + bp.getName() + FOR + addon.getDescription().getName());
    }
    public boolean saveBlueprint(@NonNull GameModeAddon addon, @NonNull Blueprint bp) {
        return new BlueprintClipboardManager(plugin, getBlueprintsFolder(addon)).saveBlueprint(bp);
    }
    public void saveBlueprintBundle(GameModeAddon addon, BlueprintBundle bb) {
        Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
            File bpf = getBlueprintsFolder(addon);
            if (!bpf.exists()) {
                bpf.mkdirs();
            }
            File fileName = new File(bpf, bb.getUniqueId() + BLUEPRINT_BUNDLE_SUFFIX);
            String toStore = gson.toJson(bb, BlueprintBundle.class);
            try (FileWriter fileWriter = new FileWriter(fileName, StandardCharsets.UTF_8)) {
                fileWriter.write(toStore);
            } catch (IOException e) {
                plugin.logError("Could not save blueprint bundle file: " + e.getMessage());
            }
        });
    }
    public void saveBlueprintBundles() {
        blueprintBundles.forEach((k, v) -> v.forEach(m -> saveBlueprintBundle(k, m)));
    }
    public Map<String, Blueprint> getBlueprints(GameModeAddon addon) {
        if (!blueprints.containsKey(addon)) {
            return new HashMap<>();
        }
        return blueprints.get(addon).stream().collect(Collectors.toMap(Blueprint::getName, b -> b));
    }
    public void deleteBlueprint(GameModeAddon addon, String name)
    {
        List<Blueprint> addonBlueprints = this.blueprints.get(addon);
        Iterator<Blueprint> it = addonBlueprints.iterator();
        while (it.hasNext())
        {
            Blueprint b = it.next();
            if (b.getName().equalsIgnoreCase(name))
            {
                it.remove();
                File file = new File(this.getBlueprintsFolder(addon), b.getName() + BLUEPRINT_SUFFIX);
                try
                {
                    Files.deleteIfExists(file.toPath());
                }
                catch (IOException e)
                {
                    this.plugin.logError("Could not delete Blueprint " + e.getLocalizedMessage());
                }
            }
        }
    }
    public void paste(GameModeAddon addon, Island island, String name) {
        paste(addon, island, name, null, true);
    }
    public boolean paste(GameModeAddon addon, Island island, String name, Runnable task, boolean useNMS) {
        if (validate(addon, name) == null) {
            plugin.logError("Tried to paste '" + name + "' but the bundle is not loaded!");
            return false;
        }
        BlueprintBundle bb = getBlueprintBundles(addon).get(name.toLowerCase());
        if (!blueprints.containsKey(addon) || blueprints.get(addon).isEmpty()) {
            plugin.logError("No blueprints loaded for bundle '" + name + "'!");
            return false;
        }
        Blueprint bp = getBlueprints(addon).get(bb.getBlueprint(World.Environment.NORMAL));
        if (bp == null) {
            bp = getBlueprints(addon).get("island");
            plugin.logError("Blueprint bundle has no normal world blueprint, using default");
            if (bp == null) {
                plugin.logError("NO DEFAULT BLUEPRINT FOUND! Make sure 'island.blu' exists!");
            }
        }
        if (bp != null) {
            new BlueprintPaster(plugin, bp, addon.getOverWorld(), island).paste(useNMS)
                    .thenAccept(b -> pasteNether(addon, bb, island).thenAccept(
                            b2 ->
            pasteEnd(addon, bb, island).thenAccept(message -> sendMessage(island)).thenAccept(b3 -> Bukkit.getScheduler().runTask(plugin, task))));
        }
        island.putMetaData("bundle", new MetaDataValue(name));
        return true;
    }
    private CompletableFuture<Boolean> pasteNether(GameModeAddon addon, BlueprintBundle bb, Island island) {
        if (bb.getBlueprint(World.Environment.NETHER) != null
                && addon.getWorldSettings().isNetherGenerate()
                && addon.getWorldSettings().isNetherIslands()
                && addon.getNetherWorld() != null) {
            Blueprint bp = getBlueprints(addon).get(bb.getBlueprint(World.Environment.NETHER));
            if (bp != null) {
                return new BlueprintPaster(plugin, bp, addon.getNetherWorld(), island).paste();
            }
        }
        return CompletableFuture.completedFuture(false);
    }
    private CompletableFuture<Boolean> pasteEnd(GameModeAddon addon, BlueprintBundle bb, Island island) {
        if (bb.getBlueprint(World.Environment.THE_END) != null
                && addon.getWorldSettings().isEndGenerate()
                && addon.getWorldSettings().isEndIslands()
                && addon.getEndWorld() != null) {
            Blueprint bp = getBlueprints(addon).get(bb.getBlueprint(World.Environment.THE_END));
            if (bp != null) {
                return new BlueprintPaster(plugin, bp, addon.getEndWorld(), island).paste();
            }
        }
        return CompletableFuture.completedFuture(false);
    }
    private void sendMessage(Island island) {
        if (island != null && island.getOwner() != null) {
            final Optional<User> owner = Optional.of(island).map(i -> User.getInstance(i.getOwner()));
            owner.ifPresent(user -> user.sendMessage("commands.island.create.pasting.done"));
        }
    }
    public @Nullable String validate(GameModeAddon addon, String name) {
        if (name == null) {
            return null;
        }
        if (blueprintBundles.containsKey(addon) && getBlueprintBundles(addon).containsKey(name)) {
            return name;
        }
        return null;
    }
    public void addBlueprintBundle(GameModeAddon addon, BlueprintBundle bb) {
        if (blueprintBundles.containsKey(addon)) {
            blueprintBundles.get(addon).removeIf(b -> b.getUniqueId().equals(bb.getUniqueId()));
        }
        blueprintBundles.computeIfAbsent(addon, k -> new ArrayList<>()).add(bb);
    }
    public boolean checkPerm(@NonNull Addon addon, @NonNull User user, @NonNull String name) {
        String permission = addon.getPermissionPrefix() + "island.create." + name;
        BlueprintBundle bb = getBlueprintBundles((GameModeAddon) addon).get(name.toLowerCase());
        if (bb == null || (bb.isRequirePermission() && !name.equals(DEFAULT_BUNDLE_NAME) && !user.hasPermission(permission))) {
            user.sendMessage("general.errors.no-permission", TextVariables.PERMISSION, permission);
            return false;
        }
        return true;
    }
    public void deleteBlueprintBundle(@NonNull GameModeAddon addon, BlueprintBundle bb) {
        if (blueprintBundles.containsKey(addon)) {
            blueprintBundles.get(addon).removeIf(k -> k.getUniqueId().equals(bb.getUniqueId()));
        }
        File bpf = getBlueprintsFolder(addon);
        File fileName = new File(bpf, bb.getUniqueId() + BLUEPRINT_BUNDLE_SUFFIX);
        try {
            Files.deleteIfExists(fileName.toPath());
        } catch (IOException e) {
            plugin.logError("Could not delete Blueprint Bundle " + e.getLocalizedMessage());
        }
    }
    public void renameBlueprint(GameModeAddon addon, Blueprint bp, String name, String displayName)
    {
        if (bp.getName().equalsIgnoreCase(name))
        {
            return;
        }
        File bpf = this.getBlueprintsFolder(addon);
        File fileName = new File(bpf, bp.getName() + BLUEPRINT_SUFFIX);
        try
        {
            Files.deleteIfExists(fileName.toPath());
        }
        catch (IOException e)
        {
            this.plugin.logError("Could not delete old Blueprint " + e.getLocalizedMessage());
        }
        this.blueprints.get(addon).remove(bp);
        bp.setName(name);
        bp.setDisplayName(displayName);
        this.saveBlueprint(addon, bp);
        this.addBlueprint(addon, bp);
    }
}
package world.bentobox.bentobox.blueprints.dataobjects;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import org.bukkit.Material;
import org.bukkit.World;
import com.google.gson.annotations.Expose;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.database.objects.DataObject;
public class BlueprintBundle implements DataObject {
    @Expose
    private String uniqueId;
    @Expose
    private Material icon = Material.PAPER;
    @Expose
    private String displayName = "";
    @Expose
    private List<String> description = new ArrayList<>();
    @Expose
    private boolean requirePermission;
    @Expose
    private Map<World.Environment, String> blueprints = new EnumMap<>(World.Environment.class);
    @Expose
    private int slot = 0;
    @Expose
    private int times = 0;
    @Override
    public String getUniqueId() {
        return uniqueId;
    }
    @Override
    public void setUniqueId(String uniqueId) {
        this.uniqueId = uniqueId;
    }
    public Material getIcon() {
        return icon;
    }
    public void setIcon(Material icon) {
        this.icon = icon;
    }
    public String getDisplayName() {
        return displayName;
    }
    public void setDisplayName(String displayName) {
        this.displayName = displayName;
    }
    public List<String> getDescription() {
        return description;
    }
    public void setDescription(List<String> description) {
        this.description = description;
    }
    public Map<World.Environment, String> getBlueprints() {
        return blueprints;
    }
    public void setBlueprints(Map<World.Environment, String> blueprints) {
        this.blueprints = blueprints;
    }
    public void setBlueprint(World.Environment env, Blueprint bp) {
        this.blueprints.put(env, bp.getName());
    }
    public void clearBlueprint(World.Environment env) {
        this.blueprints.remove(env);
    }
    public String getBlueprint(World.Environment env) {
        return this.blueprints.get(env);
    }
    public void setDescription(String string) {
        if (description == null)
            description = new ArrayList<>();
        this.description.add(string);
    }
    public boolean isRequirePermission() {
        return requirePermission;
    }
    public void setRequirePermission(boolean requirePermission) {
        this.requirePermission = requirePermission;
    }
    public int getSlot() {
        return slot;
    }
    public void setSlot(int slot) {
        this.slot = slot;
    }
    public int getTimes() {
        return times;
    }
    public void setTimes(int times) {
        this.times = times;
    }
}
package world.bentobox.bentobox.blueprints.conversation;
import org.bukkit.conversations.ConversationContext;
import org.bukkit.conversations.Prompt;
import org.bukkit.conversations.StringPrompt;
import org.bukkit.entity.Player;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import net.md_5.bungee.api.ChatColor;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBundle;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
public class NamePrompt extends StringPrompt
{
    private final GameModeAddon addon;
    @Nullable
    private final BlueprintBundle bb;
    @Nullable
    private Blueprint bp;
    public NamePrompt(@NonNull GameModeAddon addon, @Nullable BlueprintBundle bb)
    {
        this.addon = addon;
        this.bb = bb;
    }
    public NamePrompt(@NonNull GameModeAddon addon, @Nullable Blueprint bp, @Nullable BlueprintBundle bb)
    {
        this.addon = addon;
        this.bp = bp;
        this.bb = bb;
    }
    @Override
    public @NonNull String getPromptText(ConversationContext context)
    {
        User user = User.getInstance((Player) context.getForWhom());
        return user.getTranslation("commands.admin.blueprint.management.name.prompt");
    }
    @Override
    public Prompt acceptInput(ConversationContext context, String input)
    {
        User user = User.getInstance((Player) context.getForWhom());
        String uniqueId = Util.sanitizeInput(input);
        if (ChatColor.stripColor(Util.translateColorCodes(input)).length() > 32)
        {
            context.getForWhom().sendRawMessage(
                user.getTranslation("commands.admin.blueprint.management.name.too-long"));
            return this;
        }
        if (this.bb == null || !this.bb.getUniqueId().equals(BlueprintsManager.DEFAULT_BUNDLE_NAME))
        {
            if (this.addon.getPlugin().getBlueprintsManager().getBlueprintBundles(this.addon).containsKey(uniqueId))
            {
                context.getForWhom().sendRawMessage(
                    user.getTranslation("commands.admin.blueprint.management.name.pick-a-unique-name"));
                return this;
            }
            context.setSessionData("uniqueId", uniqueId);
        }
        else
        {
            context.setSessionData("uniqueId", this.bb.getUniqueId());
        }
        context.setSessionData("name", input);
        return new NameSuccessPrompt(this.addon, this.bb, this.bp);
    }
}
package world.bentobox.bentobox.api.addons;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import org.bukkit.Bukkit;
import org.bukkit.Server;
import org.bukkit.configuration.InvalidConfigurationException;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.event.Listener;
import com.github.puregero.multilib.MultiLib;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.request.AddonRequestHandler;
import world.bentobox.bentobox.api.flags.Flag;
import world.bentobox.bentobox.managers.IslandsManager;
import world.bentobox.bentobox.managers.PlayersManager;
import world.bentobox.bentobox.util.Util;
public abstract class Addon {
    private static final String ADDON_CONFIG_FILENAME = "config.yml";
    private State state;
    private AddonDescription description;
    private FileConfiguration config;
    private File dataFolder;
    private File file;
    private final Map<String, AddonRequestHandler> requestHandlers = new HashMap<>();
    protected Addon() {
        state = State.DISABLED;
        if (!Util.inTest()) {
            MultiLib.onString(getPlugin(), "bentobox-config-update", v -> this.reloadConfig());
        }
    }
    public abstract void onEnable();
    public abstract void onDisable();
    public void onLoad() {}
    public void onReload() {}
    public BentoBox getPlugin() {
        return BentoBox.getInstance();
    }
    public enum State {
        LOADED,
        ENABLED,
        DISABLED,
        INCOMPATIBLE,
        MISSING_DEPENDENCY,
        ERROR
    }
    public FileConfiguration getConfig() {
        if (config == null) {
            config = loadYamlFile();
        }
        return config;
    }
    public File getDataFolder() {
        return dataFolder;
    }
    public AddonDescription getDescription() {
        return description;
    }
    public File getFile() {
        return file;
    }
    public Logger getLogger() {
        return getPlugin().getLogger();
    }
    public Server getServer() {
        return Bukkit.getServer();
    }
    public boolean isEnabled() {
        return state == State.ENABLED;
    }
    public State getState() {
        return state;
    }
    private FileConfiguration loadYamlFile() {
        File yamlFile = new File(dataFolder, ADDON_CONFIG_FILENAME);
        YamlConfiguration yamlConfig = null;
        if (yamlFile.exists()) {
            try {
                yamlConfig = new YamlConfiguration();
                yamlConfig.load(yamlFile);
            } catch (Exception e) {
                Bukkit.getLogger().severe(() -> "Could not load config.yml: " + e.getMessage());
            }
        }
        return yamlConfig;
    }
    public void registerListener(Listener listener) {
        BentoBox.getInstance().getAddonsManager().registerListener(this, listener);
    }
    public void saveConfig() {
        try {
            getConfig().save(new File(dataFolder, ADDON_CONFIG_FILENAME));
        } catch (IOException e) {
            Bukkit.getLogger().severe("Could not save config! " + this.getDescription().getName() + " " + e.getMessage());
        }
    }
    public void reloadConfig() {
        config = loadYamlFile();
    }
    public void saveDefaultConfig() {
        saveResource(ADDON_CONFIG_FILENAME, false);
        config = loadYamlFile();
    }
    public void saveResource(String resourcePath, boolean replace) {
        saveResource(resourcePath, dataFolder, replace, false);
    }
    public File saveResource(String jarResource, File destinationFolder, boolean replace, boolean noPath) {
        if (jarResource == null || jarResource.equals("")) {
            throw new IllegalArgumentException("ResourcePath cannot be null or empty");
        }
        jarResource = jarResource.replace('\\', '/');
        try (JarFile jar = new JarFile(file)) {
            JarEntry jarConfig = jar.getJarEntry(jarResource);
            if (jarConfig != null) {
                try (InputStream in = jar.getInputStream(jarConfig)) {
                    if (in == null) {
                        throw new IllegalArgumentException(
                                "The embedded resource '" + jarResource + "' cannot be found in " + jar.getName());
                    }
                    File outFile = new File(destinationFolder,
                            jarResource.replaceAll("/", Matcher.quoteReplacement(File.separator)));
                    if (noPath) {
                        outFile = new File(destinationFolder, outFile.getName());
                    }
                    outFile.getParentFile().mkdirs();
                    if (!outFile.exists() || replace) {
                        java.nio.file.Files.copy(in, outFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
                    }
                    return outFile;
                }
            } else {
                throw new IllegalArgumentException(
                        "The embedded resource '" + jarResource + "' cannot be found in " + jar.getName());
            }
        } catch (IOException e) {
            BentoBox.getInstance().logError(
                    "Could not save from jar file. From " + jarResource + " to " + destinationFolder.getAbsolutePath());
        }
        return null;
    }
    public YamlConfiguration getYamlFromJar(String jarResource) throws IOException, InvalidConfigurationException {
        if (jarResource == null || jarResource.equals("")) {
            throw new IllegalArgumentException("jarResource cannot be null or empty");
        }
        YamlConfiguration result = new YamlConfiguration();
        jarResource = jarResource.replace('\\', '/');
        try (JarFile jar = new JarFile(file)) {
            JarEntry jarConfig = jar.getJarEntry(jarResource);
            if (jarConfig != null) {
                try (InputStreamReader in = new InputStreamReader(jar.getInputStream(jarConfig))) {
                    result.load(in);
                }
            }
        }
        return result;
    }
    public InputStream getResource(String jarResource) {
        if (jarResource == null || jarResource.equals("")) {
            throw new IllegalArgumentException("ResourcePath cannot be null or empty");
        }
        jarResource = jarResource.replace('\\', '/');
        try (JarFile jar = new JarFile(file)) {
            JarEntry jarConfig = jar.getJarEntry(jarResource);
            if (jarConfig != null) {
                try (InputStream in = jar.getInputStream(jarConfig)) {
                    return in;
                }
            }
        } catch (IOException e) {
            Bukkit.getLogger().severe("Could not open from jar file. " + jarResource);
        }
        return null;
    }
    public void setFile(File f) {
        file = f;
    }
    public void setDataFolder(File file) {
        dataFolder = file;
    }
    public void setDescription(AddonDescription description) {
        this.description = description;
    }
    public void setState(State state) {
        this.state = state;
    }
    public PlayersManager getPlayers() {
        return getPlugin().getPlayers();
    }
    public IslandsManager getIslands() {
        return getPlugin().getIslands();
    }
    public IslandsManager getIslandsManager() {
        return getPlugin().getIslandsManager();
    }
    public Optional<Addon> getAddonByName(String name) {
        return getPlugin().getAddonsManager().getAddonByName(name);
    }
    public void log(String string) {
        getPlugin().log(getDescription() != null ? "[" + getDescription().getName() + "] " + string : string);
    }
    public void logWarning(String string) {
        getPlugin().logWarning(getDescription() != null ? "[" + getDescription().getName() + "] " + string : string);
    }
    public void logError(String string) {
        getPlugin().logError(getDescription() != null ? "[" + getDescription().getName() + "] " + string : string);
    }
    public String getPermissionPrefix() {
        return this.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".";
    }
    public void registerRequestHandler(AddonRequestHandler handler) {
        requestHandlers.put(handler.getLabel(), handler);
    }
    public Object request(String label, Map<String, Object> metaData) {
        label = label.toLowerCase(Locale.ENGLISH);
        AddonRequestHandler handler = requestHandlers.get(label);
        if(handler != null) {
            return handler.handle(metaData);
        } else {
            return null;
        }
    }
    public boolean registerFlag(Flag flag) {
        return getPlugin().getFlagsManager().registerFlag(this, flag);
    }
    public void allLoaded() {}
}
package world.bentobox.bentobox.util;
import java.io.IOException;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Enumeration;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.Nonnull;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.Server;
import org.bukkit.World;
import org.bukkit.World.Environment;
import org.bukkit.attribute.Attribute;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.Allay;
import org.bukkit.entity.Animals;
import org.bukkit.entity.Bat;
import org.bukkit.entity.EnderDragon;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Flying;
import org.bukkit.entity.IronGolem;
import org.bukkit.entity.Monster;
import org.bukkit.entity.Player;
import org.bukkit.entity.PufferFish;
import org.bukkit.entity.Shulker;
import org.bukkit.entity.Slime;
import org.bukkit.entity.Snowman;
import org.bukkit.entity.Tameable;
import org.bukkit.entity.WaterMob;
import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.google.common.base.Enums;
import com.google.common.base.Optional;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.nms.PasteHandler;
import world.bentobox.bentobox.nms.WorldRegenerator;
public class Util {
    private static final Pattern HEX_PATTERN = Pattern.compile("&#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})");
    private static final String NETHER = "_nether";
    private static final String THE_END = "_the_end";
    private static String serverVersion = null;
    private static BentoBox plugin = BentoBox.getInstance();
    private static PasteHandler pasteHandler = null;
    private static WorldRegenerator regenerator = null;
    private Util() {}
    public static void setPlugin(BentoBox p) {
        plugin = p;
    }
    public static String getServerVersion() {
        if (serverVersion == null) {
            String serverPackageName = Bukkit.getServer().getClass().getPackage().getName();
            serverVersion = serverPackageName.substring(serverPackageName.lastIndexOf('.') + 1);
        }
        return serverVersion;
    }
    public static Location getClosestIsland(Location location) {
        int dist = plugin.getIWM().getIslandDistance(location.getWorld()) * 2;
        long x = Math.round((double) location.getBlockX() / dist) * dist + plugin.getIWM().getIslandXOffset(location.getWorld());
        long z = Math.round((double) location.getBlockZ() / dist) * dist + plugin.getIWM().getIslandZOffset(location.getWorld());
        int y = plugin.getIWM().getIslandHeight(location.getWorld());
        return new Location(location.getWorld(), x, y, z);
    }
    public static Location getLocationString(final String s) {
        if (s == null || s.trim().equals("")) {
            return null;
        }
        final String[] parts = s.split(":");
        if (parts.length == 6) {
            final World w = Bukkit.getWorld(parts[0]);
            if (w == null) {
                return null;
            }
            int x = (int) Double.parseDouble(parts[1]);
            int y = (int) Double.parseDouble(parts[2]);
            int z = (int) Double.parseDouble(parts[3]);
            final float yaw = Float.intBitsToFloat(Integer.parseInt(parts[4]));
            final float pitch = Float.intBitsToFloat(Integer.parseInt(parts[5]));
            return new Location(w, x + 0.5D, y, z + 0.5D, yaw, pitch);
        }
        return null;
    }
    public static String getStringLocation(final Location l) {
        if (l == null || l.getWorld() == null) {
            return "";
        }
        return l.getWorld().getName() + ":" + l.getBlockX() + ":" + l.getBlockY() + ":" + l.getBlockZ() + ":" + Float.floatToIntBits(l.getYaw()) + ":" + Float.floatToIntBits(l.getPitch());
    }
    public static String prettifyText(String ugly) {
        StringBuilder fin = new StringBuilder();
        ugly = ugly.toLowerCase(java.util.Locale.ENGLISH);
        if (ugly.contains("_")) {
            String[] splt = ugly.split("_");
            int i = 0;
            for (String s : splt) {
                i += 1;
                fin.append(Character.toUpperCase(s.charAt(0))).append(s.substring(1));
                if (i < splt.length) {
                    fin.append(" ");
                }
            }
        } else {
            fin.append(Character.toUpperCase(ugly.charAt(0))).append(ugly.substring(1));
        }
        return fin.toString();
    }
    public static List<String> getOnlinePlayerList(User user) {
        if (user == null || !user.isPlayer()) {
            return Bukkit.getOnlinePlayers().stream().map(Player::getName).toList();
        }
        return Bukkit.getOnlinePlayers().stream().filter(p -> user.getPlayer().canSee(p)).map(Player::getName).toList();
    }
    public static List<String> tabLimit(final List<String> list, final String start) {
        final List<String> returned = new ArrayList<>();
        for (String s : list) {
            if (s == null) {
                continue;
            }
            if (s.toLowerCase(java.util.Locale.ENGLISH).startsWith(start.toLowerCase(java.util.Locale.ENGLISH))) {
                returned.add(s);
            }
        }
        return returned;
    }
    public static String xyz(Vector location) {
        return location.getBlockX() + "," + location.getBlockY() + "," + location.getBlockZ();
    }
    public static boolean sameWorld(World world, World world2) {
        return stripName(world).equals(stripName(world2));
    }
    private static String stripName(World world) {
        if (world.getName().endsWith(NETHER)) {
            return world.getName().substring(0, world.getName().length() - NETHER.length());
        }
        if (world.getName().endsWith(THE_END)) {
            return world.getName().substring(0, world.getName().length() - THE_END.length());
        }
        return world.getName();
    }
    @Nullable
    public static World getWorld(@Nullable World world) {
        if (world == null) {
            return null;
        }
        return world.getEnvironment().equals(Environment.NORMAL) ? world : Bukkit.getWorld(world.getName().replace(NETHER, "").replace(THE_END, ""));
    }
    public static List<String> listJarFiles(JarFile jar, String folderPath, String suffix) {
        List<String> result = new ArrayList<>();
        Enumeration<JarEntry> entries = jar.entries();
        while (entries.hasMoreElements()) {
            JarEntry entry = entries.nextElement();
            String path = entry.getName();
            if (!path.startsWith(folderPath)) {
                continue;
            }
            if (entry.getName().endsWith(suffix)) {
                result.add(entry.getName());
            }
        }
        return result;
    }
    public static float blockFaceToFloat(BlockFace face) {
        return switch (face) {
        case EAST -> 90F;
        case EAST_NORTH_EAST -> 67.5F;
        case NORTH_EAST -> 45F;
        case NORTH_NORTH_EAST -> 22.5F;
        case NORTH_NORTH_WEST -> 337.5F;
        case NORTH_WEST -> 315F;
        case SOUTH -> 180F;
        case SOUTH_EAST -> 135F;
        case SOUTH_SOUTH_EAST -> 157.5F;
        case SOUTH_SOUTH_WEST -> 202.5F;
        case SOUTH_WEST -> 225F;
        case WEST -> 270F;
        case WEST_NORTH_WEST -> 292.5F;
        case WEST_SOUTH_WEST -> 247.5F;
        default -> 0F;
        };
    }
    @Nullable
    public static Date parseGitHubDate(@NonNull String gitHubDate) {
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        try {
            return format.parse(gitHubDate.replace('T', ' ').replace("Z", ""));
        } catch (ParseException e) {
            return null;
        }
    }
    public static boolean isHostileEntity(Entity entity) {
        return entity instanceof Monster || entity instanceof Flying || entity instanceof Slime ||
                entity instanceof Shulker || entity instanceof EnderDragon || entity instanceof PufferFish;
    }
    public static boolean isPassiveEntity(Entity entity) {
        return entity instanceof Animals || entity instanceof IronGolem || entity instanceof Snowman ||
                entity instanceof WaterMob && !(entity instanceof PufferFish) || entity instanceof Bat ||
                entity instanceof Allay;
    }
    public static boolean isTamableEntity(Entity entity) {
        return entity instanceof Tameable && ((Tameable) entity).isTamed();
    }
    @NonNull
    public static CompletableFuture<Boolean> teleportAsync(@Nonnull Entity entity, @Nonnull Location location) {
        return teleportAsync(entity, location, TeleportCause.UNKNOWN);
    }
    @SuppressWarnings("unchecked")
    @NonNull
    public static CompletableFuture<Boolean> teleportAsync(@Nonnull Entity entity, @Nonnull Location location,
            TeleportCause cause) {
        try {
            Method method = Entity.class.getMethod("teleportAsync", Location.class, TeleportCause.class);
            if (method != null) {
                return (CompletableFuture<Boolean>) method.invoke(entity, location, cause);
            }
        } catch (NoSuchMethodException e) {
        } catch (Exception e) {
            plugin.logStacktrace(e); 
        }
        entity.teleport(location, cause);
        return CompletableFuture.completedFuture(true);
    }
    @NonNull
    public static CompletableFuture<Chunk> getChunkAtAsync(@NonNull Location loc) {
        return getChunkAtAsync(Objects.requireNonNull(loc.getWorld()), loc.getBlockX() >> 4, loc.getBlockZ() >> 4,
                true);
    }
    @NonNull
    public static CompletableFuture<Chunk> getChunkAtAsync(@NonNull Location loc, boolean gen) {
        return getChunkAtAsync(Objects.requireNonNull(loc.getWorld()), loc.getBlockX() >> 4, loc.getBlockZ() >> 4, gen);
    }
    @NonNull
    public static CompletableFuture<Chunk> getChunkAtAsync(@Nonnull World world, int x, int z) {
        return getChunkAtAsync(world, x, z, true);
    }
    @SuppressWarnings("unchecked")
    @NonNull
    public static CompletableFuture<Chunk> getChunkAtAsync(@Nonnull World world, int x, int z, boolean gen) {
        try {
            Method method = World.class.getMethod("getChunkAtAsync", int.class, int.class, boolean.class);
            if (method != null) {
                return (CompletableFuture<Chunk>) method.invoke(world, x, z, gen);
            }
        } catch (NoSuchMethodException e) {
        } catch (Exception e) {
            e.printStackTrace(); 
        }
        return CompletableFuture.completedFuture(world.getChunkAt(x, z, gen));
    }
    public static boolean isChunkGenerated(@NonNull Location loc) {
        return isChunkGenerated(Objects.requireNonNull(loc.getWorld()), loc.getBlockX() >> 4, loc.getBlockZ() >> 4);
    }
    public static boolean isChunkGenerated(@Nonnull World world, int x, int z) {
        return world.isChunkGenerated(x, z);
    }
    public static boolean isVersionCompatible(String version, String requiredVersion) {
        String[] versionParts = version.replace("-SNAPSHOT", "").split("\\.");
        String[] requiredVersionParts = requiredVersion.replace("-SNAPSHOT", "").split("\\.");
        for (int i = 0; i < Math.max(versionParts.length, requiredVersionParts.length); i++) {
            int vPart = i < versionParts.length ? Integer.parseInt(versionParts[i]) : 0;
            int rPart = i < requiredVersionParts.length ? Integer.parseInt(requiredVersionParts[i]) : 0;
            if (vPart > rPart) {
                return true;
            } else if (vPart < rPart) {
                return false;
            }
        }
        boolean isVersionSnapshot = version.contains("-SNAPSHOT");
        boolean isRequiredSnapshot = requiredVersion.contains("-SNAPSHOT");
        return !(!isRequiredSnapshot && isVersionSnapshot);
    }
    public static boolean isPaper() {
        try {
            Class.forName("com.destroystokyo.paper.PaperConfig");
            return true; 
        } catch (ClassNotFoundException e) {
            return false; 
        }
    }
    @SuppressWarnings("deprecation")
    @NonNull
    public static String translateColorCodes(@NonNull String textToColor) {
        Matcher matcher = HEX_PATTERN.matcher(textToColor);
        StringBuilder buffer = new StringBuilder(textToColor.length() + 32);
        while (matcher.find()) {
            String group = matcher.group(1);
            if (group.length() == 6) {
                matcher.appendReplacement(buffer, ChatColor.COLOR_CHAR + "x"
                        + ChatColor.COLOR_CHAR + group.charAt(0) + ChatColor.COLOR_CHAR + group.charAt(1)
                        + ChatColor.COLOR_CHAR + group.charAt(2) + ChatColor.COLOR_CHAR + group.charAt(3)
                        + ChatColor.COLOR_CHAR + group.charAt(4) + ChatColor.COLOR_CHAR + group.charAt(5));
            } else {
                matcher.appendReplacement(buffer, ChatColor.COLOR_CHAR + "x"
                        + ChatColor.COLOR_CHAR + group.charAt(0) + ChatColor.COLOR_CHAR + group.charAt(0)
                        + ChatColor.COLOR_CHAR + group.charAt(1) + ChatColor.COLOR_CHAR + group.charAt(1)
                        + ChatColor.COLOR_CHAR + group.charAt(2) + ChatColor.COLOR_CHAR + group.charAt(2));
            }
        }
        return Util.stripSpaceAfterColorCodes(
                ChatColor.translateAlternateColorCodes('&', matcher.appendTail(buffer).toString()));
    }
    @NonNull
    public static String stripSpaceAfterColorCodes(@NonNull String textToStrip) {
        if (textToStrip == null) return "";
        textToStrip = textToStrip.replaceAll("(" + ChatColor.COLOR_CHAR + ".)[\\s]", "$1");
        return textToStrip;
    }
    public static boolean isInteger(@NonNull String nbr, boolean parse) {
        int length = nbr.length();
        if (length == 0) {
            return false;
        }
        int i = 0;
        if (nbr.charAt(0) == '-' || nbr.charAt(0) == '+') {
            if (length == 1) {
                return false;
            }
            i = 1;
        }
        boolean trailingDot = false;
        for (; i < length; i++) {
            char c = nbr.charAt(i);
            if (trailingDot && c != '0') {
                return false;
            }
            if (c == '.') {
                if (i == length - 1) {
                    return true;
                } else {
                    trailingDot = true;
                }
            } else if (!trailingDot && (c < '0' || c > '9')) {
                return false;
            }
        }
        if (parse) {
            try {
                Integer.parseInt(nbr); 
                return true;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return true;
    }
    @Nullable
    public static UUID getUUID(@NonNull String nameOrUUID) {
        UUID targetUUID = plugin.getPlayers().getUUID(nameOrUUID);
        if (targetUUID != null) return targetUUID;
        try {
            return UUID.fromString(nameOrUUID);
        } catch (Exception e) {
        }
        return null;
    }
    public static void runCommands(User user, @NonNull List<String> commands, String commandType) {
        runCommands(user, user.getName(), commands, commandType);
    }
    public static void runCommands(User user, String ownerName, @NonNull List<String> commands, String commandType) {
        commands.forEach(command -> {
            command = command.replace("[player]", user.getName());
            command = command.replace("[owner]", ownerName);
            if (command.startsWith("[SUDO]")) {
                if (!user.isOnline() || !user.performCommand(command.substring(6))) {
                    plugin.logError("Could not execute " + commandType + " command for " + user.getName() + ": " + command.substring(6));
                }
            } else {
                if (!Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command)) {
                    plugin.logError("Could not execute " + commandType + " command as console: " + command);
                }
            }
        });
    }
    public static void resetHealth(Player player) {
        try {
            double maxHealth = player.getAttribute(Attribute.MAX_HEALTH).getBaseValue();
            player.setHealth(maxHealth);
        } catch (Exception e) {
            player.setHealth(20D);
        }
    }
    public static void setRegenerator(WorldRegenerator regenerator) {
        Util.regenerator = regenerator;
    }
    public static WorldRegenerator getRegenerator() {
        if (regenerator == null) {
            final String bukkitVersion = "v" + Bukkit.getBukkitVersion().replace('.', '_').replace('-', '_');
            final String pluginPackageName = plugin.getClass().getPackage().getName();
            WorldRegenerator handler;
            try {
                Class<?> clazz = Class.forName(pluginPackageName + ".nms." + bukkitVersion + ".WorldRegeneratorImpl");
                if (WorldRegenerator.class.isAssignableFrom(clazz)) {
                    handler = (WorldRegenerator) clazz.getConstructor().newInstance();
                } else {
                    throw new IllegalStateException("Class " + clazz.getName() + " does not implement WorldRegenerator");
                }
            } catch (Exception e) {
                plugin.logWarning("No Regenerator found for " + bukkitVersion + ", falling back to Bukkit API.");
                handler = new world.bentobox.bentobox.nms.fallback.WorldRegeneratorImpl();
            }
            setRegenerator(handler);
        }
        return regenerator;
    }
    public static PasteHandler getPasteHandler() {
        if (pasteHandler == null) {
            String bukkitVersion = "v" + Bukkit.getServer().getBukkitVersion().replace('.', '_').replace('-', '_');
            String pluginPackageName = plugin.getClass().getPackage().getName();
            BentoBox.getInstance().log("Optimizing for " + bukkitVersion);
            PasteHandler handler;
            try {
                Class<?> clazz = Class.forName(pluginPackageName + ".nms." + bukkitVersion + ".PasteHandlerImpl");
                if (PasteHandler.class.isAssignableFrom(clazz)) {
                    handler = (PasteHandler) clazz.getConstructor().newInstance();
                } else {
                    throw new IllegalStateException("Class " + clazz.getName() + " does not implement PasteHandler");
                }
            } catch (Exception e) {
                plugin.logWarning("No PasteHandler found for " + bukkitVersion + ", falling back to Bukkit API.");
                handler = new world.bentobox.bentobox.nms.fallback.PasteHandlerImpl();
            }
            setPasteHandler(handler);
        }
        return pasteHandler;
    }
    public static void setPasteHandler(PasteHandler pasteHandler) {
        Util.pasteHandler = pasteHandler;
    }
    public static int broadcast(String localeKey, String... variables) {
        int count = 0;
        for (Player p : Bukkit.getOnlinePlayers()) {
            if (p.hasPermission(Server.BROADCAST_CHANNEL_USERS)) {
                User.getInstance(p).sendMessage(localeKey, variables);
                count++;
            }
        }
        return count;
    }
    @SuppressWarnings("deprecation")
    public static String sanitizeInput(String input)
    {
        return ChatColor.stripColor(
                Util.translateColorCodes(input.replaceAll("[\\\\/:*?\"<>|\s]", "_"))).
                toLowerCase();
    }
    public static <T extends Enum<T>> T findFirstMatchingEnum(Class<T> enumClass, String... values) {
        if (enumClass == null || values == null) {
            return null;
        }
        for (String value : values) {
            Optional<T> enumConstant = Enums.getIfPresent(enumClass, value.toUpperCase());
            if (enumConstant.isPresent()) {
                return enumConstant.get();
            }
        }
        return null; 
    }
    public static boolean inTest() {
        return Arrays.stream(Thread.currentThread().getStackTrace()).anyMatch(e -> e.getClassName().endsWith("Test"));
    }
}
package world.bentobox.bentobox.api.addons;
import java.util.Optional;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.generator.ChunkGenerator;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.github.puregero.multilib.MultiLib;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.configuration.WorldSettings;
import world.bentobox.bentobox.util.Util;
public abstract class GameModeAddon extends Addon {
    protected World islandWorld;
    @Nullable
    protected World netherWorld;
    @Nullable
    protected World endWorld;
    @Nullable
    protected CompositeCommand playerCommand;
    @Nullable
    protected CompositeCommand adminCommand;
    public abstract void createWorlds();
    public abstract WorldSettings getWorldSettings();
    public boolean inWorld(Location loc) {
        return Util.sameWorld(loc.getWorld(), islandWorld);
    }
    public boolean inWorld(World world) {
        if (world == null) {
            return false;
        }
        return Util.sameWorld(world, islandWorld);
    }
    public World getOverWorld() {
        return islandWorld;
    }
    @Nullable
    public World getNetherWorld() {
        return netherWorld;
    }
    @Nullable
    public World getEndWorld() {
        return endWorld;
    }
    @NonNull
    public Optional<CompositeCommand> getPlayerCommand() {
        return Optional.ofNullable(playerCommand);
    }
    @NonNull
    public Optional<CompositeCommand> getAdminCommand() {
        return Optional.ofNullable(adminCommand);
    }
    @Nullable
    public abstract ChunkGenerator getDefaultWorldGenerator(String worldName, String id);
    public void saveWorldSettings() {
        MultiLib.notify("bentobox-config-update", "");
    }
    public boolean isUsesNewChunkGeneration() {
        return false;
    }
}
package world.bentobox.bentobox.api.commands.island;
import java.io.IOException;
import java.util.List;
import org.eclipse.jdt.annotation.NonNull;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.events.island.IslandEvent;
import world.bentobox.bentobox.api.events.island.IslandEvent.Reason;
import world.bentobox.bentobox.api.events.team.TeamEvent;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.managers.island.NewIsland;
import world.bentobox.bentobox.managers.island.NewIsland.Builder;
import world.bentobox.bentobox.panels.customizable.IslandCreationPanel;
import world.bentobox.bentobox.util.Util;
public class IslandResetCommand extends ConfirmableCommand {
    private boolean noPaste;
    public IslandResetCommand(CompositeCommand islandCommand) {
        super(islandCommand, "reset", "restart");
    }
    public IslandResetCommand(CompositeCommand islandCommand, boolean noPaste) {
        super(islandCommand, "reset", "restart");
        this.noPaste = noPaste;
    }
    @Override
    public void setup() {
        setPermission("island.reset");
        setOnlyPlayer(true);
        setParametersHelp("commands.island.reset.parameters");
        setDescription("commands.island.reset.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args) {
        if (getSettings().getResetCooldown() > 0 && checkCooldown(user)) {
            return false;
        }
        if (!getIslands().hasIsland(getWorld(), user.getUniqueId())) {
            user.sendMessage("general.errors.no-island");
            return false;
        }
        int resetsLeft = getPlayers().getResetsLeft(getWorld(), user.getUniqueId());
        if (resetsLeft != -1) {
            if (resetsLeft == 0) {
                user.sendMessage("commands.island.reset.none-left");
                return false;
            } else {
                user.sendMessage("commands.island.reset.resets-left", TextVariables.NUMBER, String.valueOf(resetsLeft));
            }
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        if (!args.isEmpty()) {
            String name = getPlugin().getBlueprintsManager().validate(getAddon(), Util.sanitizeInput(args.get(0)));
            if (name == null || name.isEmpty()) {
                user.sendMessage("commands.island.create.unknown-blueprint");
                return false;
            }
            if (!getPlugin().getBlueprintsManager().checkPerm(getAddon(), user, Util.sanitizeInput(args.get(0)))) {
                return false;
            }
            return resetIsland(user, name);
        } else {
            if (getPlugin().getSettings().isResetConfirmation()) {
                this.askConfirmation(user, user.getTranslation("commands.island.reset.confirmation"),
                        () -> selectBundle(user, label));
            } else {
                selectBundle(user, label);
            }
            return true;
        }
    }
    private void selectBundle(@NonNull User user, @NonNull String label) {
        if (getPlugin().getBlueprintsManager().getBlueprintBundles(getAddon()).size() > 1) {
            IslandCreationPanel.openPanel(this, user, label, true);
        } else {
            resetIsland(user, BlueprintsManager.DEFAULT_BUNDLE_NAME);
        }
    }
    private boolean resetIsland(User user, String name) {
        Island oldIsland = getIslands().getIsland(getWorld(), user);
        deleteOldIsland(user, oldIsland);
        user.sendMessage("commands.island.create.creating-island");
        try {
            Builder builder = NewIsland.builder().player(user).reason(Reason.RESET).addon(getAddon())
                    .oldIsland(oldIsland).name(name);
            if (noPaste)
                builder.noPaste();
            builder.build();
        } catch (IOException e) {
            getPlugin().logError("Could not create island for player. " + e.getMessage());
            user.sendMessage(e.getMessage());
            return false;
        }
        setCooldown(user.getUniqueId(), getSettings().getResetCooldown());
        return true;
    }
    private void deleteOldIsland(User user, Island oldIsland) {
        IslandEvent.builder().involvedPlayer(user.getUniqueId()).reason(Reason.PRECLEAR).island(oldIsland)
                .oldIsland(oldIsland).location(oldIsland.getCenter()).build();
        kickMembers(oldIsland);
        getPlayers().addReset(getWorld(), user.getUniqueId());
    }
    private void kickMembers(Island island) {
        island.getMemberSet().forEach(memberUUID -> {
            User member = User.getInstance(memberUUID);
            if (!memberUUID.equals(island.getOwner())) {
                member.sendMessage("commands.island.reset.kicked-from-island", TextVariables.GAMEMODE,
                        getAddon().getDescription().getName());
            }
            getIslands().removePlayer(island, memberUUID);
            getPlayers().cleanLeavingPlayer(getWorld(), member, false, island);
            TeamEvent.builder().island(island).reason(TeamEvent.Reason.DELETE).involvedPlayer(memberUUID).build();
        });
    }
}
package world.bentobox.bentobox.blueprints;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.bukkit.Material;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import com.google.gson.annotations.Expose;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBlock;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintEntity;
public class Blueprint {
    @Expose
    private @NonNull String name = "";
    @Expose
    private String displayName;
    @Expose
    private @NonNull Material icon = Material.PAPER;
    @Expose
    private List<String> description;
    @Expose
    private Map<Vector, BlueprintBlock> attached;
    @Expose
    private Map<Vector, List<BlueprintEntity>> entities;
    @Expose
    private Map<Vector, BlueprintBlock> blocks;
    @Expose
    private int xSize;
    @Expose
    private int ySize;
    @Expose
    private int zSize;
    @Expose
    private Vector bedrock;
    @NonNull
    public String getName() {
        if (name == null) name = "unnamed";
        return name;
    }
    public Blueprint setName(@NonNull String name) {
        this.name = name;
        return this;
    }
    public String getDisplayName() {
        return displayName;
    }
    public Blueprint setDisplayName(String displayName) {
        this.displayName = displayName;
        return this;
    }
    public @NonNull Material getIcon() {
        return icon;
    }
    public Blueprint setIcon(Material icon) {
        this.icon = icon;
        return this;
    }
    public List<String> getDescription() {
        return description;
    }
    public Blueprint setDescription(List<String> description) {
        this.description = description;
        return this;
    }
    public Blueprint setDescription(String description) {
        if (this.description == null) this.description = new ArrayList<>();
        this.description.add(description);
        return this;
    }
    public Map<Vector, BlueprintBlock> getAttached() {
        return attached;
    }
    public void setAttached(Map<Vector, BlueprintBlock> attached) {
        this.attached = attached;
    }
    public Map<Vector, List<BlueprintEntity>> getEntities() {
        return entities;
    }
    public void setEntities(Map<Vector, List<BlueprintEntity>> entities) {
        if (this.entities == null) {
            this.entities = entities;
        } else {
            this.entities.putAll(entities);
        }
    }
    public Map<Vector, BlueprintBlock> getBlocks() {
        return blocks;
    }
    public void setBlocks(Map<Vector, BlueprintBlock> blocks) {
        this.blocks = blocks;
    }
    public int getxSize() {
        return xSize;
    }
    public void setxSize(int xSize) {
        this.xSize = xSize;
    }
    public int getySize() {
        return ySize;
    }
    public void setySize(int ySize) {
        this.ySize = ySize;
    }
    public int getzSize() {
        return zSize;
    }
    public void setzSize(int zSize) {
        this.zSize = zSize;
    }
    public Vector getBedrock() {
        return bedrock;
    }
    public void setBedrock(Vector bedrock) {
        this.bedrock = bedrock;
    }
}
package world.bentobox.bentobox.api.configuration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import org.bukkit.Difficulty;
import org.bukkit.GameMode;
import org.bukkit.entity.EntityType;
import org.eclipse.jdt.annotation.NonNull;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.flags.Flag;
import world.bentobox.bentobox.lists.Flags;
public interface WorldSettings extends ConfigObject {
    GameMode getDefaultGameMode();
    @Deprecated(since="1.21.0", forRemoval=true)
    Map<Flag, Integer> getDefaultIslandFlags();
    default Map<String, Integer> getDefaultIslandFlagNames()
    {
        Map<String, Integer> flags = new HashMap<>();
        this.getDefaultIslandFlags().forEach((key, value) -> flags.put(key.getID(), value));
        return flags;
    }
    @Deprecated(since="1.21.0", forRemoval=true)
    Map<Flag, Integer> getDefaultIslandSettings();
    default Map<String, Integer> getDefaultIslandSettingNames()
    {
        Map<String, Integer> flags = new HashMap<>();
        this.getDefaultIslandSettings().forEach((key, value) -> flags.put(key.getID(), value));
        return flags;
    }
    Difficulty getDifficulty();
    void setDifficulty(Difficulty difficulty);
    String getFriendlyName();
    int getIslandDistance();
    int getIslandHeight();
    int getIslandProtectionRange();
    int getIslandStartX();
    int getIslandStartZ();
    int getIslandXOffset();
    int getIslandZOffset();
    List<String> getIvSettings();
    int getMaxHomes();
    int getMaxIslands();
    int getMaxTeamSize();
    default int getMaxCoopSize() {
        return 4;
    }
    default int getMaxTrustSize() {
        return 4;
    }
    int getNetherSpawnRadius();
    String getPermissionPrefix();
    Set<EntityType> getRemoveMobsWhitelist();
    int getSeaHeight();
    List<String> getHiddenFlags();
    List<String> getVisitorBannedCommands();
    default List<String> getFallingBannedCommands() {
        return Collections.emptyList();
    }
    Map<String, Boolean> getWorldFlags();
    String getWorldName();
    boolean isDragonSpawn();
    boolean isEndGenerate();
    boolean isEndIslands();
    boolean isNetherGenerate();
    boolean isNetherIslands();
    boolean isOnJoinResetEnderChest();
    boolean isOnJoinResetInventory();
    boolean isOnJoinResetMoney();
    boolean isOnJoinResetHealth();
    boolean isOnJoinResetHunger();
    boolean isOnJoinResetXP();
    @NonNull
    List<String> getOnJoinCommands();
    boolean isOnLeaveResetEnderChest();
    boolean isOnLeaveResetInventory();
    boolean isOnLeaveResetMoney();
    boolean isOnLeaveResetHealth();
    boolean isOnLeaveResetHunger();
    boolean isOnLeaveResetXP();
    @NonNull
    List<String> getOnLeaveCommands();
    @NonNull
    default List<String> getOnRespawnCommands() {
        return Collections.emptyList();
    }
    boolean isUseOwnGenerator();
    boolean isWaterUnsafe();
    List<String> getGeoLimitSettings();
    default List<String> getMobLimitSettings() {
        return new ArrayList<>();
    }
    int getResetLimit();
    long getResetEpoch();
    void setResetEpoch(long timestamp);
    boolean isTeamJoinDeathReset();
    int getDeathsMax();
    boolean isDeathsCounted();
    boolean isDeathsResetOnNewIsland();
    boolean isAllowSetHomeInNether();
    boolean isAllowSetHomeInTheEnd();
    boolean isRequireConfirmationToSetHomeInNether();
    boolean isRequireConfirmationToSetHomeInTheEnd();
    int getBanLimit();
    boolean isLeaversLoseReset();
    boolean isKickedKeepInventory();
    boolean isCreateIslandOnFirstLoginEnabled();
    int getCreateIslandOnFirstLoginDelay();
    boolean isCreateIslandOnFirstLoginAbortOnLogout();
    default boolean isPasteMissingIslands() {
        return true;
    }
    default boolean isTeleportPlayerToIslandUponIslandCreation() {
        return true;
    }
    default String getAdminCommandAliases()
    {
        return this.getFriendlyName().toLowerCase(Locale.ENGLISH) + "admin";
    }
    default String getPlayerCommandAliases()
    {
        return this.getFriendlyName().toLowerCase(Locale.ENGLISH);
    }
    default String getDefaultPlayerAction()
    {
        return "go";
    }
    default String getDefaultNewPlayerAction()
    {
        return "create";
    }
    default boolean isMakeNetherPortals() {
        return false;
    }
    default boolean isMakeEndPortals() {
        return false;
    }
    default boolean isCheckForBlocks() {
        return true;
    }
    default int getConcurrentIslands() {
        return BentoBox.getInstance().getSettings().getIslandNumber();
    }
    default boolean isDisallowTeamMemberIslands() {
        return true;
    }
}
package world.bentobox.bentobox.blueprints;
import java.util.UUID;
import org.bukkit.NamespacedKey;
import org.bukkit.Sound;
import org.bukkit.World;
import org.bukkit.entity.ArmorStand;
import org.bukkit.entity.Display;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerInteractAtEntityEvent;
import org.bukkit.persistence.PersistentDataType;
import world.bentobox.bentobox.BentoBox;
public class DisplayListener implements Listener {
    @EventHandler
    public void onPlayerInteractEntity(PlayerInteractAtEntityEvent event) {
        if (event.getRightClicked() instanceof ArmorStand) {
            ArmorStand armorStand = (ArmorStand) event.getRightClicked();
            NamespacedKey key = new NamespacedKey(BentoBox.getInstance(), "associatedDisplayEntity");
            if (armorStand.getPersistentDataContainer().has(key, PersistentDataType.STRING)) {
                String displayEntityUUID = armorStand.getPersistentDataContainer().get(key, PersistentDataType.STRING);
                World world = armorStand.getWorld();
                world.getEntitiesByClass(Display.class).stream()
                        .filter(e -> e.getUniqueId().equals(UUID.fromString(displayEntityUUID))).findFirst()
                        .ifPresent(e -> {
                            event.getPlayer().playSound(event.getPlayer().getLocation(), Sound.BLOCK_GLASS_BREAK, 1F,
                                    1F);
                            e.remove();
                        });
            }
        }
    }
}
package world.bentobox.bentobox.blueprints;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.scheduler.BukkitTask;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBlock;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintEntity;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.nms.PasteHandler;
import world.bentobox.bentobox.util.Util;
public class BlueprintPaster {
    enum PasteState {
        CHUNK_LOAD,
        CHUNK_LOADING,
        BLOCKS,
        ATTACHMENTS,
        ENTITIES,
        DONE,
        CANCEL
    }
    private static long chunkLoadTime = 0;
    private final BentoBox plugin;
    private final PasteHandler paster = Util.getPasteHandler();
    private final PasteHandler fallback = new world.bentobox.bentobox.nms.fallback.PasteHandlerImpl();
    private final World world;
    private Location pos1;
    private Location pos2;
    private PasteState pasteState;
    private BukkitTask pastingTask;
    private BlueprintClipboard clipboard;
    private CompletableFuture<Void> currentTask = CompletableFuture.completedFuture(null);
    @NonNull
    private final Blueprint blueprint;
    @NonNull
    private final Location location;
    @Nullable
    private final Island island;
    public BlueprintPaster(@NonNull BentoBox plugin, @NonNull BlueprintClipboard clipboard, @NonNull Location location) {
        this.plugin = plugin;
        this.clipboard = clipboard;
        this.blueprint = Objects.requireNonNull(clipboard.getBlueprint(), "Clipboard cannot have a null Blueprint");
        this.location = location;
        this.world = location.getWorld();
        this.island = null;
    }
    public BlueprintPaster(@NonNull BentoBox plugin, @NonNull Blueprint bp, World world, @NonNull Island island) {
        this.plugin = plugin;
        this.blueprint = bp;
        this.island = island;
        this.world = world;
        Vector off = bp.getBedrock() != null ? bp.getBedrock() : new Vector(0,0,0);
        this.location = island.getProtectionCenter().toVector().subtract(off).toLocation(world);
        int y = Math.min(world.getMaxHeight() - 1, Math.max(world.getMinHeight(), location.getBlockY()));
        location.setY(y);
    }
    private record Bits(
            Map<Vector, BlueprintBlock> blocks,
            Map<Vector, BlueprintBlock> attached,
            Map<Vector, List<BlueprintEntity>> entities,
            Iterator<Entry<Vector, BlueprintBlock>> it,
            Iterator<Entry<Vector, BlueprintBlock>> it2,
            Iterator<Entry<Vector, List<BlueprintEntity>>> it3,
            int pasteSpeed) {}
    public CompletableFuture<Boolean> paste() {
        return this.paste(true);
    }
    public CompletableFuture<Boolean> paste(boolean useNMS) {
        CompletableFuture<Boolean> result = new CompletableFuture<>();
        final Map<Vector, BlueprintBlock> blocks = blueprint.getBlocks() == null ? Collections.emptyMap() : blueprint.getBlocks();
        final Map<Vector, BlueprintBlock> attached = blueprint.getAttached() == null ? Collections.emptyMap() : blueprint.getAttached();
        final Map<Vector, List<BlueprintEntity>> entities = blueprint.getEntities() == null ? Collections.emptyMap() : blueprint.getEntities();
        pasteState = PasteState.CHUNK_LOAD;
        final Optional<User> owner = Optional.ofNullable(island).map(i -> User.getInstance(i.getOwner()));
        owner.ifPresent(user -> tellOwner(user, blocks.size(), attached.size(), entities.size(), plugin.getSettings().getPasteSpeed()));
        Bits bits = new Bits(blocks, attached, entities,
                blocks.entrySet().iterator(), attached.entrySet().iterator(), entities.entrySet().iterator(),
                plugin.getSettings().getPasteSpeed());
        pastingTask = Bukkit.getScheduler().runTaskTimer(plugin, () -> pasterTask(result, owner, bits, useNMS), 0L, 1L);
        return result;
    }
    private void pasterTask(CompletableFuture<Boolean> result, Optional<User> owner, Bits bits, boolean useNMS) {
        if (!currentTask.isDone()) return;
        final int pasteSpeed = plugin.getSettings().getPasteSpeed();
        int count = 0;
        if (pasteState.equals(PasteState.CHUNK_LOAD)) {
            loadChunk();
        }
        else if (pasteState.equals(PasteState.BLOCKS) || pasteState.equals(PasteState.ATTACHMENTS)) {
            pasteBlocks(bits, count, owner, pasteSpeed, useNMS);
        }
        else if (pasteState.equals(PasteState.ENTITIES)) {
            pasteEntities(bits, count, owner, pasteSpeed, useNMS);
        }
        else if (pasteState.equals(PasteState.DONE)) {
            cancelTask(result);
        } else if (pasteState.equals(PasteState.CANCEL)) {
            pastingTask.cancel();
            result.complete(true);
        }
    }
    private void cancelTask(CompletableFuture<Boolean> result) {
        if (island == null && clipboard != null) {
            clipboard.setPos1(pos1);
            clipboard.setPos2(pos2);
        }
        pasteState = PasteState.CANCEL;
        result.complete(true);      
    }
    private void pasteEntities(Bits bits, int count, Optional<User> owner, int pasteSpeed, boolean useNMS) {
        if (bits.it3().hasNext()) {
            Map<Location, List<BlueprintEntity>> entityMap = new HashMap<>();
            while (count < pasteSpeed) {
                if (!bits.it3().hasNext()) {
                    break;
                }
                Entry<Vector, List<BlueprintEntity>> entry = bits.it3().next();
                int x = location.getBlockX() + entry.getKey().getBlockX();
                int y = location.getBlockY() + entry.getKey().getBlockY();
                int z = location.getBlockZ() + entry.getKey().getBlockZ();
                Location center = new Location(world, x, y, z).add(new Vector(0.5, 0D, 0.5));
                List<BlueprintEntity> entities = entry.getValue();
                entityMap.put(center, entities);
                count++;
            }
            if (!entityMap.isEmpty()) {
                currentTask = useNMS ? paster.pasteEntities(island, world, entityMap)
                        : fallback.pasteEntities(island, world, entityMap);
            }
        } else {
            pasteState = PasteState.DONE;
            String dimensionType = switch (location.getWorld().getEnvironment()) {
            case NETHER -> owner.map(user -> user.getTranslation("general.worlds.nether")).orElse("");
            case THE_END -> owner.map(user -> user.getTranslation("general.worlds.the-end")).orElse("");
            default -> owner.map(user -> user.getTranslation("general.worlds.overworld")).orElse("");
            };
            owner.ifPresent(user -> user.sendMessage("commands.island.create.pasting.dimension-done", "[world]", dimensionType));
        }
    }
    private void pasteBlocks(Bits bits, int count, Optional<User> owner, int pasteSpeed, boolean useNMS) {
        Iterator<Entry<Vector, BlueprintBlock>> it = pasteState.equals(PasteState.BLOCKS) ? bits.it : bits.it2;
        if (it.hasNext()) {
            pasteBlocksNow(it, count, pasteSpeed, useNMS);
        } else {
            if (pasteState.equals(PasteState.BLOCKS)) {
                pasteState = PasteState.ATTACHMENTS;
            } else {
                pasteState = PasteState.ENTITIES;
                if (bits.entities.size() != 0) {
                    owner.ifPresent(user -> user.sendMessage("commands.island.create.pasting.entities", TextVariables.NUMBER, String.valueOf(bits.entities.size())));
                }
            }
        }
    }
    private void pasteBlocksNow(Iterator<Entry<Vector, BlueprintBlock>> it, int count, int pasteSpeed, boolean useNMS) {
        Map<Location, BlueprintBlock> blockMap = new HashMap<>();
        while (count < pasteSpeed) {
            if (!it.hasNext()) {
                break;
            }
            Entry<Vector, BlueprintBlock> entry = it.next();
            Location pasteTo = location.clone().add(entry.getKey());
            updatePos(pasteTo);
            BlueprintBlock block = entry.getValue();
            blockMap.put(pasteTo, block);
            count++;
        }
        if (!blockMap.isEmpty()) {
            currentTask = useNMS ? paster.pasteBlocks(island, world, blockMap)
                    : fallback.pasteBlocks(island, world, blockMap);
        }
    }
    private void loadChunk() {
        long timer = System.currentTimeMillis();
        pasteState = PasteState.CHUNK_LOADING;
        currentTask = Util.getChunkAtAsync(location).thenRun(() -> {
            pasteState = PasteState.BLOCKS;
            long duration = System.currentTimeMillis() - timer;
            if (duration > chunkLoadTime) {
                chunkLoadTime = duration;
            }
        });
    }
    private void tellOwner(User user, int blocksSize, int attachedSize, int entitiesSize, int pasteSpeed) {
        double total = (double) blocksSize + attachedSize + entitiesSize;
        BigDecimal time = BigDecimal.valueOf(total / (pasteSpeed * 20.0D) + (chunkLoadTime / 1000.0D)).setScale(1, RoundingMode.UP);
        user.sendMessage("commands.island.create.pasting.estimated-time", TextVariables.NUMBER, String.valueOf(time.doubleValue()));
        user.sendMessage("commands.island.create.pasting.blocks", TextVariables.NUMBER, String.valueOf(blocksSize + attachedSize));
    }
    private void updatePos(Location l) {
        if (pos1 == null) {
            pos1 = l.clone();
        }
        if (pos2 == null) {
            pos2 = l.clone();
        }
        if (l.getBlockX() < pos1.getBlockX()) {
            pos1.setX(l.getBlockX());
        }
        if (l.getBlockX() > pos2.getBlockX()) {
            pos2.setX(l.getBlockX());
        }
        if (l.getBlockY() < pos1.getBlockY()) {
            pos1.setY(l.getBlockY());
        }
        if (l.getBlockY() > pos2.getBlockY()) {
            pos2.setY(l.getBlockY());
        }
        if (l.getBlockZ() < pos1.getBlockZ()) {
            pos1.setZ(l.getBlockZ());
        }
        if (l.getBlockZ() > pos2.getBlockZ()) {
            pos2.setZ(l.getBlockZ());
        }
    }
}
package world.bentobox.bentobox.blueprints.dataobjects;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.block.Biome;
import org.bukkit.block.banner.Pattern;
import org.bukkit.block.sign.Side;
import org.bukkit.inventory.ItemStack;
import com.google.gson.annotations.Expose;
public class BlueprintBlock {
    @Expose
    private String blockData;
    @Expose
    private List<String> signLines;
    @Expose
    private List<String> signLines2;
    @Expose
    private Map<Integer, ItemStack> inventory;
    @Expose
    private BlueprintCreatureSpawner creatureSpawner;
    @Expose
    private BlueprintTrialSpawner trialSpawner;
    @Expose
    private Biome biome;
    @Expose
    private List<Pattern> bannerPatterns;
    @Expose
    private boolean glowingText;
    @Expose
    private boolean glowingText2;
    public BlueprintBlock(String blockData) {
        this.blockData = blockData;
    }
    public String getBlockData() {
        return blockData;
    }
    public void setBlockData(String blockData) {
        this.blockData = blockData;
    }
    @Deprecated
    public List<String> getSignLines() {
        return signLines;
    }
    @Deprecated
    public void setSignLines(List<String> signLines) {
        this.signLines = signLines;
    }
    public Map<Integer, ItemStack> getInventory() {
        return inventory == null ? new HashMap<>() : inventory;
    }
    public void setInventory(Map<Integer, ItemStack> inventory) {
        this.inventory = inventory;
    }
    public BlueprintCreatureSpawner getCreatureSpawner() {
        return creatureSpawner;
    }
    public void setCreatureSpawner(BlueprintCreatureSpawner creatureSpawner) {
        this.creatureSpawner = creatureSpawner;
    }
    public List<Pattern> getBannerPatterns() {
        return bannerPatterns;
    }
    public void setBannerPatterns(List<Pattern> bannerPatterns) {
        this.bannerPatterns = bannerPatterns;
    }
    public Biome getBiome() {
        return biome;
    }
    public void setBiome(Biome biome) {
        this.biome = biome;
    }
    @Deprecated
    public boolean isGlowingText() {
        return glowingText;
    }
    @Deprecated
    public void setGlowingText(boolean glowingText) {
        this.glowingText = glowingText;
    }
    public void setGlowingText(Side side, boolean glowingText) {
        if (side == Side.FRONT) {
            this.glowingText = glowingText;
        } else {
            this.glowingText2 = glowingText;
        }
    }
    public boolean isGlowingText(Side side) {
        if (side == Side.FRONT) return glowingText;
        return glowingText2;
    }
    public List<String> getSignLines(Side side) {
        if (side == Side.FRONT) return signLines;
        return signLines2;
    }
    public void setSignLines(Side side, List<String> signLines) {
        if (side == Side.FRONT) {
            this.signLines = signLines;
        } else {
            this.signLines2 = signLines;
        }
    }
    public BlueprintTrialSpawner getTrialSpawner() {
        return trialSpawner;
    }
    public void setTrialSpawner(BlueprintTrialSpawner trialSpawner) {
        this.trialSpawner = trialSpawner;
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.util.List;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
public class AdminBlueprintRenameCommand extends ConfirmableCommand
{
    public AdminBlueprintRenameCommand(AdminBlueprintCommand parent)
    {
        super(parent, "rename");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.rename");
        this.setParametersHelp("commands.admin.blueprint.rename.parameters");
        this.setDescription("commands.admin.blueprint.rename.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (args.size() != 2)
        {
            this.showHelp(this, user);
            return false;
        }
        String from = Util.sanitizeInput(args.get(0));
        String to = Util.sanitizeInput(args.get(1));
        if (from.equals(to))
        {
            user.sendMessage("commands.admin.blueprint.rename.pick-different-name");
            return false;
        }
        AdminBlueprintCommand parent = (AdminBlueprintCommand) this.getParent();
        File fromFile = new File(parent.getBlueprintsFolder(), from + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (!fromFile.exists())
        {
            user.sendMessage("commands.admin.blueprint.no-such-file");
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        String from = Util.sanitizeInput(args.get(0));
        String to = Util.sanitizeInput(args.get(1));
        File toFile = new File(parent.getBlueprintsFolder(), to + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (toFile.exists())
        {
            this.askConfirmation(user,
                    user.getTranslation("commands.admin.blueprint.file-exists"),
                    () -> this.rename(user, from, to, args.get(1)));
        }
        else
        {
            this.askConfirmation(user, () -> this.rename(user, from, to, args.get(1)));
        }
        return true;
    }
    private void rename(User user, String blueprintName, String fileName, String displayName)
    {
        Blueprint blueprint = this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).get(blueprintName);
        this.getPlugin().getBlueprintsManager().renameBlueprint(this.getAddon(), blueprint, fileName, displayName);
        user.sendMessage("commands.admin.blueprint.rename.success",
                "[old]",
                blueprintName,
                TextVariables.NAME,
                blueprint.getName(),
                "[display]",
                blueprint.getDisplayName());
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.util.List;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
public class AdminBlueprintRenameCommand extends ConfirmableCommand
{
    public AdminBlueprintRenameCommand(AdminBlueprintCommand parent)
    {
        super(parent, "rename");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.rename");
        this.setParametersHelp("commands.admin.blueprint.rename.parameters");
        this.setDescription("commands.admin.blueprint.rename.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (args.size() != 2)
        {
            this.showHelp(this, user);
            return false;
        }
        String from = Util.sanitizeInput(args.get(0));
        String to = Util.sanitizeInput(args.get(1));
        if (from.equals(to))
        {
            user.sendMessage("commands.admin.blueprint.rename.pick-different-name");
            return false;
        }
        AdminBlueprintCommand parent = (AdminBlueprintCommand) this.getParent();
        File fromFile = new File(parent.getBlueprintsFolder(), from + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (!fromFile.exists())
        {
            user.sendMessage("commands.admin.blueprint.no-such-file");
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        String from = Util.sanitizeInput(args.get(0));
        String to = Util.sanitizeInput(args.get(1));
        File toFile = new File(parent.getBlueprintsFolder(), to + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (toFile.exists())
        {
            this.askConfirmation(user,
                    user.getTranslation("commands.admin.blueprint.file-exists"),
                    () -> this.rename(user, from, to, args.get(1)));
        }
        else
        {
            this.askConfirmation(user, () -> this.rename(user, from, to, args.get(1)));
        }
        return true;
    }
    private void rename(User user, String blueprintName, String fileName, String displayName)
    {
        Blueprint blueprint = this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).get(blueprintName);
        this.getPlugin().getBlueprintsManager().renameBlueprint(this.getAddon(), blueprint, fileName, displayName);
        user.sendMessage("commands.admin.blueprint.rename.success",
                "[old]",
                blueprintName,
                TextVariables.NAME,
                blueprint.getName(),
                "[display]",
                blueprint.getDisplayName());
    }
}
package world.bentobox.bentobox.database.json;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.Map;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Biome;
import org.bukkit.configuration.serialization.ConfigurationSerializable;
import org.bukkit.entity.Villager;
import org.bukkit.entity.Villager.Profession;
import org.bukkit.inventory.ItemStack;
import org.bukkit.potion.PotionEffectType;
import org.bukkit.util.Vector;
import com.google.gson.Gson;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.flags.Flag;
import world.bentobox.bentobox.database.json.adapters.BiomeTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.BukkitObjectTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.EnumTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.FlagTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.ItemStackTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.LocationTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.MaterialTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.PairTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.PotionEffectTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.ProfessionTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.VectorTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.VillagerTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.WorldTypeAdapter;
import world.bentobox.bentobox.util.Pair;
public class BentoboxTypeAdapterFactory implements TypeAdapterFactory {
    final BentoBox plugin;
    public BentoboxTypeAdapterFactory(BentoBox plugin) {
        this.plugin = plugin;
    }
    @SuppressWarnings({ "unchecked", "rawtypes" })
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
        Class<?> rawType = type.getRawType();
        if (Location.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new LocationTypeAdapter();
        } else if (Material.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new MaterialTypeAdapter();
        } else if (Biome.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new BiomeTypeAdapter();
        } else if (Enum.class.isAssignableFrom(rawType)) {
            return new EnumTypeAdapter(rawType);
        } else if (ItemStack.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new ItemStackTypeAdapter();
        } else if (Flag.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new FlagTypeAdapter(plugin);
        } else if (PotionEffectType.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new PotionEffectTypeAdapter();
        } else if (World.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new WorldTypeAdapter();
        } else if (Vector.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new VectorTypeAdapter();
        } else if (Profession.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new ProfessionTypeAdapter();
        } else if (Villager.Type.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new VillagerTypeAdapter();
        } else if (Pair.class.isAssignableFrom(rawType)) {
            Type pairType = type.getType();
            ParameterizedType parameterizedType = (ParameterizedType) pairType;
            Type xType = parameterizedType.getActualTypeArguments()[0];
            Type zType = parameterizedType.getActualTypeArguments()[1];
            return (TypeAdapter<T>) new PairTypeAdapter<>(xType, zType);
        } else if (ConfigurationSerializable.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new BukkitObjectTypeAdapter(gson.getAdapter(Map.class));
        }
        return null;
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.util.List;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
import world.bentobox.bentobox.managers.BlueprintClipboardManager;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
public class AdminBlueprintSaveCommand extends ConfirmableCommand
{
    public AdminBlueprintSaveCommand(AdminBlueprintCommand parent)
    {
        super(parent, "save");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.save");
        this.setParametersHelp("commands.admin.blueprint.save.parameters");
        this.setDescription("commands.admin.blueprint.save.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (args.size() != 1)
        {
            this.showHelp(this, user);
            return false;
        }
        BlueprintClipboard clipboard = ((AdminBlueprintCommand) this.getParent()).getClipboards().
                computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        if (!clipboard.isFull())
        {
            user.sendMessage("commands.admin.blueprint.copy-first");
            return false;
        }
        if (clipboard.getBlueprint() != null && clipboard.getBlueprint().getBedrock() == null)
        {
            user.sendMessage("commands.admin.blueprint.bedrock-required");
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) this.getParent();
        BlueprintClipboard clipboard = parent.getClipboards().
                computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        String fileName = Util.sanitizeInput(args.get(0));
        File newFile = new File(parent.getBlueprintsFolder(), fileName + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (newFile.exists())
        {
            this.askConfirmation(user,
                    user.getTranslation("commands.admin.blueprint.file-exists"),
                    () -> this.hideAndSave(user, parent, clipboard, fileName, args.get(0)));
            return false;
        }
        return this.hideAndSave(user, parent, clipboard, fileName, args.get(0));
    }
    private boolean hideAndSave(User user,
            AdminBlueprintCommand parent,
            BlueprintClipboard clipboard,
            String name,
            String displayName)
    {
        parent.hideClipboard(user);
        boolean result = new BlueprintClipboardManager(this.getPlugin(),
                parent.getBlueprintsFolder(), clipboard).
                save(user, name, displayName);
        if (result && clipboard.isFull())
        {
            this.getPlugin().getBlueprintsManager().addBlueprint(this.getAddon(), clipboard.getBlueprint());
        }
        return result;
    }
}
package world.bentobox.bentobox.managers;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;
import org.bukkit.Material;
import org.bukkit.util.Vector;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBlock;
import world.bentobox.bentobox.database.json.BentoboxTypeAdapterFactory;
public class BlueprintClipboardManager {
    private static final String LOAD_ERROR = "Could not load blueprint file - does not exist : ";
    private final File blueprintFolder;
    private BlueprintClipboard clipboard;
    private Gson gson;
    private final BentoBox plugin;
    public BlueprintClipboardManager(BentoBox plugin, File blueprintFolder) {
        this(plugin, blueprintFolder, null);
    }
    public BlueprintClipboardManager(BentoBox plugin, File blueprintFolder, BlueprintClipboard clipboard) {
        super();
        this.plugin = plugin;
        if (!blueprintFolder.exists()) {
            blueprintFolder.mkdirs();
        }
        this.blueprintFolder = blueprintFolder;
        this.clipboard = clipboard;
        getGson();
    }
    public BlueprintClipboard getClipboard() {
        return clipboard;
    }
    private void getGson() {
        GsonBuilder builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().enableComplexMapKeySerialization();
        builder.disableHtmlEscaping();
        builder.registerTypeAdapterFactory(new BentoboxTypeAdapterFactory(plugin));
        gson = builder.create();
    }
    public void load(String fileName) throws IOException {
        clipboard = new BlueprintClipboard(loadBlueprint(fileName));
    }
    public Blueprint loadBlueprint(String fileName) throws IOException {
        File zipFile = new File(blueprintFolder, fileName + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (!zipFile.exists()) {
            plugin.logError(LOAD_ERROR + zipFile.getName());
            throw new IOException(LOAD_ERROR + zipFile.getName());
        }
        unzip(zipFile.getCanonicalPath());
        File file = new File(blueprintFolder, fileName);
        if (!file.exists()) {
            plugin.logError(LOAD_ERROR + file.getName());
            throw new IOException(LOAD_ERROR + file.getName() + " temp file");
        }
        Blueprint bp;
        try (FileReader fr = new FileReader(file, StandardCharsets.UTF_8)) {
            bp = gson.fromJson(fr, Blueprint.class);
        } catch (Exception e) {
            plugin.logError("Blueprint has JSON error: " + zipFile.getName());
            plugin.logStacktrace(e);
            throw new IOException("Blueprint has JSON error: " + zipFile.getName());
        }
        Files.delete(file.toPath());
        if (bp.getBedrock() == null) {
            bp.setBedrock(new Vector(bp.getxSize() / 2, bp.getySize() / 2, bp.getzSize() / 2));
            bp.getBlocks().put(bp.getBedrock(), new BlueprintBlock(Material.BEDROCK.createBlockData().getAsString()));
            plugin.logWarning("Blueprint " + fileName + BlueprintsManager.BLUEPRINT_SUFFIX + " had no bedrock block in it so one was added automatically in the center. You should check it.");
        }
        return bp;
    }
    public boolean load(User user, String fileName) {
        try {
            load(fileName);
        } catch (IOException e1) {
            user.sendMessage("commands.admin.blueprint.could-not-load");
            plugin.logError("Could not load blueprint file: " + fileName + BlueprintsManager.BLUEPRINT_SUFFIX + " " + e1.getMessage());
            return false;
        }
        user.sendMessage("general.success");
        return true;
    }
    public boolean save(User user, String newName, String displayName)
    {
        if (this.clipboard.isFull())
        {
            this.clipboard.getBlueprint().setName(newName);
            this.clipboard.getBlueprint().setDisplayName(displayName);
            if (this.saveBlueprint(this.clipboard.getBlueprint()))
            {
                user.sendMessage("general.success");
                return true;
            }
        }
        user.sendMessage("commands.admin.blueprint.could-not-save", "[message]", "Could not save temp blueprint file.");
        return false;
    }
    public boolean saveBlueprint(Blueprint blueprint) {
        if (blueprint.getName().isEmpty()) {
            plugin.logError("Blueprint name was empty - could not save it");
            return false;
        }
        File file = new File(blueprintFolder, blueprint.getName());
        String toStore = gson.toJson(blueprint, Blueprint.class);
        try (FileWriter fileWriter = new FileWriter(file, StandardCharsets.UTF_8)) {
            fileWriter.write(toStore);
        } catch (IOException e) {
            plugin.logError("Could not save temporary blueprint file: " + file.getName());
            return false;
        }
        try {
            zip(file);
        } catch (IOException e) {
            plugin.logError("Could not zip temporary blueprint file: " + file.getName());
            return false;
        }
        return true;
    }
    private void unzip(final String zipFilePath) throws IOException {
        Path path = Paths.get(zipFilePath);
        if (!(path.toFile().exists())) {
            throw new IOException("No file exists!");
        }
        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(zipFilePath))) {
            ZipEntry entry = zipInputStream.getNextEntry();
            while (entry != null) {
                Path filePath = Paths.get(path.getParent().toString(), entry.getName());
                if (!entry.isDirectory()) {
                    unzipFiles(zipInputStream, filePath);
                } else {
                    if (!filePath.startsWith(blueprintFolder.getCanonicalPath())) {
                        throw new IOException("Entry is outside of the target directory");
                    }
                    Files.createDirectories(filePath);
                }
                zipInputStream.closeEntry();
                entry = zipInputStream.getNextEntry();
            }
        }
    }
    private void unzipFiles(final ZipInputStream zipInputStream, final Path unzipFilePath) throws IOException {
        if (!unzipFilePath.startsWith(blueprintFolder.getCanonicalFile().toPath().normalize())) {
            throw new IOException(
                    "Blueprint file is trying to write outside of the target directory! Blocked attempt to write to "
                            + unzipFilePath.toString());
        }
        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(unzipFilePath.toFile().getCanonicalPath()))) {
            byte[] bytesIn = new byte[1024];
            int read;
            while ((read = zipInputStream.read(bytesIn)) != -1) {
                bos.write(bytesIn, 0, read);
            }
        }
    }
    private void zip(File targetFile) throws IOException {
        try (ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(targetFile.getCanonicalPath() + BlueprintsManager.BLUEPRINT_SUFFIX))) {
            zipOutputStream.putNextEntry(new ZipEntry(targetFile.getName()));
            try (FileInputStream inputStream = new FileInputStream(targetFile)) {
                final byte[] buffer = new byte[1024];
                int length;
                while((length = inputStream.read(buffer)) >= 0) {
                    zipOutputStream.write(buffer, 0, length);
                }
            }
            try {
                Files.delete(targetFile.toPath());
            } catch (Exception e) {
                plugin.logError(e.getMessage());
            }
        }
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.util.Util;
public class AdminBlueprintDeleteCommand extends ConfirmableCommand
{
    public AdminBlueprintDeleteCommand(AdminBlueprintCommand parent)
    {
        super(parent, "delete", "remove");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.delete");
        this.setParametersHelp("commands.admin.blueprint.delete.parameters");
        this.setDescription("commands.admin.blueprint.delete.description");
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        if (args.size() != 1)
        {
            this.showHelp(this, user);
            return false;
        }
        String blueprintName = Util.sanitizeInput(args.get(0));
        if (this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).containsKey(blueprintName))
        {
            this.askConfirmation(user, user.getTranslation("commands.admin.blueprint.delete.confirmation"),
                    () -> {
                        this.getPlugin().getBlueprintsManager().deleteBlueprint(this.getAddon(), blueprintName);
                        user.sendMessage("commands.admin.blueprint.delete.success", TextVariables.NAME, blueprintName);
                    });
            return true;
        }
        else
        {
            user.sendMessage("commands.admin.blueprint.delete.no-blueprint", TextVariables.NAME, blueprintName);
            return false;
        }
    }
    @Override
    public Optional<List<String>> tabComplete(User user, String alias, List<String> args)
    {
        return Optional.of(new LinkedList<>(this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).keySet()));
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.io.FilenameFilter;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.managers.BlueprintsManager;
public class AdminBlueprintListCommand extends CompositeCommand
{
    public AdminBlueprintListCommand(AdminBlueprintCommand parent)
    {
        super(parent, "list");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.list");
        this.setDescription("commands.admin.blueprint.list.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (!args.isEmpty())
        {
            this.showHelp(this, user);
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        File blueprints = new File(this.getAddon().getDataFolder(), BlueprintsManager.FOLDER_NAME);
        if (!blueprints.exists())
        {
            user.sendMessage("commands.admin.blueprint.list.no-blueprints");
            return false;
        }
        FilenameFilter blueprintFilter = (File dir, String name) -> name.endsWith(BlueprintsManager.BLUEPRINT_SUFFIX);
        List<String> blueprintList = Arrays.stream(Objects.requireNonNull(blueprints.list(blueprintFilter))).
                map(name -> name.substring(0, name.length() - BlueprintsManager.BLUEPRINT_SUFFIX.length())).
                toList();
        if (blueprintList.isEmpty())
        {
            user.sendMessage("commands.admin.blueprint.list.no-blueprints");
            return false;
        }
        user.sendMessage("commands.admin.blueprint.list.available-blueprints");
        blueprintList.forEach(user::sendRawMessage);
        return true;
    }
}