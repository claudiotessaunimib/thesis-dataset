package world.bentobox.bentobox.api.commands.island;
import java.io.IOException;
import java.util.List;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.events.island.IslandEvent.Reason;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.managers.island.NewIsland;
import world.bentobox.bentobox.panels.customizable.IslandCreationPanel;
import world.bentobox.bentobox.util.Util;
/**
 * /island create - Create an island.
 *
 * @author tastybento
 */
public class IslandCreateCommand extends CompositeCommand {
    /**
     * Command to create an island
     * 
     * @param islandCommand - parent command
     */
    public IslandCreateCommand(CompositeCommand islandCommand) {
        super(islandCommand, "create", "new");
    }
    @Override
    public void setup() {
        setPermission("island.create");
        setOnlyPlayer(true);
        setParametersHelp("commands.island.create.parameters");
        setDescription("commands.island.create.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args) {
        // Check if the island is reserved
        @Nullable
        Island island = getIslands().getPrimaryIsland(getWorld(), user.getUniqueId());
        if (island != null) {
            // Reserved islands can be made
            if (island.isReserved()) {
                return true;
            }
        }
        // Check if this player is on a team in this world
        if (getIWM().getWorldSettings(getWorld()).isDisallowTeamMemberIslands()
                && getIslands().inTeam(getWorld(), user.getUniqueId()) && island != null
                && !user.getUniqueId().equals(island.getOwner())) {
            // Team members who are not owners cannot make additional islands
            user.sendMessage("commands.island.create.you-cannot-make-team");
            return false;
        }
        // Get how many islands this player has
        int num = this.getIslands().getNumberOfConcurrentIslands(user.getUniqueId(), getWorld());
        int max = user.getPermissionValue(
                this.getIWM().getAddon(getWorld()).map(GameModeAddon::getPermissionPrefix).orElse("") + "island.number",
                this.getIWM().getWorldSettings(getWorld()).getConcurrentIslands());
        if (num >= max) {
            // You cannot make an island
            user.sendMessage("commands.island.create.you-cannot-make");
            return false;
        }
        if (getIWM().getMaxIslands(getWorld()) > 0
                && getIslands().getIslandCount(getWorld()) >= getIWM().getMaxIslands(getWorld())) {
            // There is too many islands in the world :(
            user.sendMessage("commands.island.create.too-many-islands");
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        // Permission check if the name is not the default one
        if (!args.isEmpty()) {
            String name = getPlugin().getBlueprintsManager().validate(getAddon(), Util.sanitizeInput(args.get(0)));
            if (name == null) {
                // The blueprint name is not valid.
                user.sendMessage("commands.island.create.unknown-blueprint");
                return false;
            }
            // Check perm
            if (!getPlugin().getBlueprintsManager().checkPerm(getAddon(), user, Util.sanitizeInput(args.get(0)))) {
                return false;
            }
            // Check maximum uses
            if (checkMaxUses(user, name)) {
                return false;
            }
            // Make island
            return makeIsland(user, name);
        } else {
            if (getPlugin().getSettings().getIslandNumber() > 1
                    && checkMaxUses(user, BlueprintsManager.DEFAULT_BUNDLE_NAME)) {
                return false;
            }
            // Show panel only if there are multiple bundles available
            if (getPlugin().getBlueprintsManager().getBlueprintBundles(getAddon()).size() > 1) {
                // Show panel
                IslandCreationPanel.openPanel(this, user, label, false);
                return true;
            }
            return makeIsland(user, BlueprintsManager.DEFAULT_BUNDLE_NAME);
        }
    }
    private boolean checkMaxUses(User user, String name) {
        if (getPlugin().getBlueprintsManager().getBlueprintBundles(getAddon()).containsKey(name)) {
            int maxTimes = getPlugin().getBlueprintsManager().getBlueprintBundles(getAddon()).get(name).getTimes();
            // Check how many times this player has used this bundle
            if (maxTimes > 0 && getBundleUses(user, name) >= maxTimes) {
                user.sendMessage("commands.island.create.max-uses");
                return true;
            }
        }
        return false;
    }
    private long getBundleUses(User user, String name) {
        return getIslands().getIslands(getWorld(), user).stream()
                .filter(is -> is.getMetaData("bundle").map(mdv -> name.equalsIgnoreCase(mdv.asString())).orElse(false))
                .count();
    }
    private boolean makeIsland(User user, String name) {
        user.sendMessage("commands.island.create.creating-island");
        try {
            NewIsland.builder().player(user).addon(getAddon()).reason(Reason.CREATE).name(name).build();
        } catch (IOException e) {
            getPlugin().logError("Could not create island for player. " + e.getMessage());
            user.sendMessage(e.getMessage());
            return false;
        }
        if (getSettings().isResetCooldownOnCreate()) {
            getParent().getSubCommand("reset").ifPresent(
                    resetCommand -> resetCommand.setCooldown(user.getUniqueId(), getSettings().getResetCooldown()));
        }
        return true;
    }
}
//
// Created by BONNe
// Copyright - 2023
//
package world.bentobox.bentobox.panels.customizable;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.bukkit.World;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.inventory.ItemStack;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.panels.PanelItem;
import world.bentobox.bentobox.api.panels.TemplatedPanel;
import world.bentobox.bentobox.api.panels.builders.PanelItemBuilder;
import world.bentobox.bentobox.api.panels.builders.TemplatedPanelBuilder;
import world.bentobox.bentobox.api.panels.reader.ItemTemplateRecord;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBundle;
import world.bentobox.bentobox.util.Util;
/**
 * This class generates Island Creation Panel based on user specified file with name: "island_creation_panel.yml".
 * If file with such name is located at gamemode panels directory, then that file will be used.
 * Otherwise, file in BentoBox/panels is used.
 */
public class IslandCreationPanel extends AbstractPanel
{
    // ---------------------------------------------------------------------
    // Section: Constants
    // ---------------------------------------------------------------------
    /**
     * This constant is used for button to indicate that it is Blueprint Bundle type.
     */
    private static final String BUNDLES = "BUNDLE";
    /**
     * This constant stores value for ERROR message that will be displayed upon failing to run creation commands.
     */
    private static final String ISLAND_CREATION_COMMANDS = "ISLAND_CREATION_COMMANDS";
    /**
     * Button reference
     */
    private static final String BUNDLE_BUTTON_REF = "panels.island_creation.buttons.bundle.";
    // ---------------------------------------------------------------------
    // Section: Variables
    // ---------------------------------------------------------------------
    /**
     * This variable stores filtered elements.
     */
    private final List<BlueprintBundle> elementList;
    /**
     * The world that this command applies to
     */
    private final World world;
    /**
     * true if this panel has been called by a reset command. Changes how the count of used islands is done.
     */
    private final boolean reset;
    // ---------------------------------------------------------------------
    // Section: Constructor
    // ---------------------------------------------------------------------
    /**
     * This is internal constructor. It is used internally in current class to avoid creating objects everywhere.
     *
     * @param command CompositeCommand object
     * @param label The main command label
     * @param user User who opens panel
     * @param reset 
     */
    private IslandCreationPanel(@NonNull CompositeCommand command,
            @NonNull User user, @NonNull String label, boolean reset)
    {
        super(command, user);
        this.mainLabel = label;
        this.world = command.getWorld();
        this.reset = reset;
        this.elementList = this.plugin.getBlueprintsManager().getBlueprintBundles(command.getAddon()).values().stream().
                sorted(Comparator.comparingInt(BlueprintBundle::getSlot).thenComparing(BlueprintBundle::getUniqueId))
                .filter(bundle -> !bundle.isRequirePermission() || this.user
                        .hasPermission(command.getPermissionPrefix() + "island.create." + bundle.getUniqueId()))
                .toList();
    }
    // ---------------------------------------------------------------------
    // Section: Methods
    // ---------------------------------------------------------------------
    /**
     * Build method manages current panel opening. It uses BentoBox PanelAPI that is easy to use and users can get nice
     * panels.
     */
    @Override
    protected void build()
    {
        // Do not open gui if there is no magic sticks.
        if (this.elementList.isEmpty())
        {
            this.plugin.logError("There are no available phases for selection!");
            this.user.sendMessage("no-phases",
                    TextVariables.GAMEMODE, this.plugin.getDescription().getName());
            return;
        }
        // Start building panel.
        TemplatedPanelBuilder panelBuilder = new TemplatedPanelBuilder();
        // Set main template.
        if (this.doesCustomPanelExists(this.command.getAddon(), "island_creation_panel"))
        {
            // Addon has its own island creation panel. Use it.
            panelBuilder.template("island_creation_panel", new File(this.command.getAddon().getDataFolder(), "panels"));
        }
        else
        {
            // Use default island creation panel.
            panelBuilder.template("island_creation_panel", new File(this.plugin.getDataFolder(), "panels"));
        }
        panelBuilder.user(this.user);
        panelBuilder.world(this.user.getWorld());
        // Register button builders
        panelBuilder.registerTypeBuilder(BUNDLES, this::createBundleButton);
        // Register next and previous builders
        panelBuilder.registerTypeBuilder(NEXT, this::createNextButton);
        panelBuilder.registerTypeBuilder(PREVIOUS, this::createPreviousButton);
        // Register unknown type builder.
        panelBuilder.build();
    }
    // ---------------------------------------------------------------------
    // Section: Buttons
    // ---------------------------------------------------------------------
    /**
     * Create next button panel item.
     *
     * @param template the template
     * @param slot the slot
     * @return the panel item
     */
    @Override
    @Nullable
    protected PanelItem createNextButton(@NonNull ItemTemplateRecord template, TemplatedPanel.ItemSlot slot)
    {
        int size = this.elementList.size();
        if (size <= slot.amountMap().getOrDefault(BUNDLES, 1) ||
                1.0 * size / slot.amountMap().getOrDefault(BUNDLES, 1) <= this.pageIndex + 1)
        {
            // There are no next elements
            return null;
        }
        int nextPageIndex = this.pageIndex + 2;
        PanelItemBuilder builder = new PanelItemBuilder();
        if (template.icon() != null)
        {
            ItemStack clone = template.icon().clone();
            if ((boolean) template.dataMap().getOrDefault(INDEXING, false))
            {
                clone.setAmount(nextPageIndex);
            }
            builder.icon(clone);
        }
        if (template.title() != null)
        {
            builder.name(this.user.getTranslation(this.command.getWorld(), template.title()));
        }
        if (template.description() != null)
        {
            builder.description(this.user.getTranslation(this.command.getWorld(), template.description(),
                    TextVariables.NUMBER, String.valueOf(nextPageIndex)));
        }
        // Add ClickHandler
        builder.clickHandler((panel, user, clickType, i) ->
        {
            template.actions().forEach(action -> {
                if ((clickType == action.clickType() ||
                        action.clickType() == ClickType.UNKNOWN) && NEXT.equalsIgnoreCase(action.actionType()))
                {
                    // Next button ignores click type currently.
                    this.pageIndex++;
                    this.build();
                }
            });
            // Always return true.
            return true;
        });
        // Collect tooltips.
        List<String> tooltips = template.actions().stream().
                filter(action -> action.tooltip() != null)
                .map(action -> this.user.getTranslation(this.command.getWorld(), action.tooltip()))
                .filter(text -> !text.isBlank())
                .collect(Collectors.toCollection(() -> new ArrayList<>(template.actions().size())));
        // Add tooltips.
        if (!tooltips.isEmpty())
        {
            // Empty line and tooltips.
            builder.description("");
            builder.description(tooltips);
        }
        return builder.build();
    }
    /**
     * Create previous button panel item.
     *
     * @param template the template
     * @param slot the slot
     * @return the panel item
     */
    @Nullable
    @Override
    protected PanelItem createPreviousButton(@NonNull ItemTemplateRecord template, TemplatedPanel.ItemSlot slot)
    {
        if (this.pageIndex == 0)
        {
            // There are no next elements
            return null;
        }
        int previousPageIndex = this.pageIndex;
        PanelItemBuilder builder = new PanelItemBuilder();
        if (template.icon() != null)
        {
            ItemStack clone = template.icon().clone();
            if ((boolean) template.dataMap().getOrDefault(INDEXING, false))
            {
                clone.setAmount(previousPageIndex);
            }
            builder.icon(clone);
        }
        if (template.title() != null)
        {
            builder.name(this.user.getTranslation(this.command.getWorld(), template.title()));
        }
        if (template.description() != null)
        {
            builder.description(this.user.getTranslation(this.command.getWorld(), template.description(),
                    TextVariables.NUMBER, String.valueOf(previousPageIndex)));
        }
        // Add ClickHandler
        builder.clickHandler((panel, user, clickType, i) ->
        {
            template.actions().forEach(action -> {
                if ((clickType == action.clickType() ||
                        action.clickType() == ClickType.UNKNOWN) && PREVIOUS.equalsIgnoreCase(action.actionType()))
                {
                    // Next button ignores click type currently.
                    this.pageIndex--;
                    this.build();
                }
            });
            // Always return true.
            return true;
        });
        // Collect tooltips.
        List<String> tooltips = template.actions().stream().
                filter(action -> action.tooltip() != null)
                .map(action -> this.user.getTranslation(this.command.getWorld(), action.tooltip()))
                .filter(text -> !text.isBlank())
                .collect(Collectors.toCollection(() -> new ArrayList<>(template.actions().size())));
        // Add tooltips.
        if (!tooltips.isEmpty())
        {
            // Empty line and tooltips.
            builder.description("");
            builder.description(tooltips);
        }
        return builder.build();
    }
    /**
     * This method creates and returns bundle button.
     *
     * @return PanelItem that represents bundle button.
     */
    @Nullable
    private PanelItem createBundleButton(ItemTemplateRecord template, TemplatedPanel.ItemSlot slot)
    {
        if (this.elementList.isEmpty())
        {
            // Does not contain any blueprints.
            return null;
        }
        int index = this.pageIndex * slot.amountMap().getOrDefault(BUNDLES, 1) + slot.slot();
        BlueprintBundle blueprintBundle;
        if (index >= this.elementList.size())
        {
            // Out of index.
            blueprintBundle = null;
        }
        else
        {
            blueprintBundle = this.elementList.get(index);
        }
        if (template.dataMap().containsKey("unique_id"))
        {
            // Try to find bundle with requested ID. if not found, use already collected bundle.
            blueprintBundle = this.elementList.stream().
                    filter(bundle -> bundle.getUniqueId().equals(template.dataMap().get("unique_id"))).findFirst()
                    .orElse(blueprintBundle);
        }
        return this.createBundleButton(template, blueprintBundle);
    }
    // ---------------------------------------------------------------------
    // Section: Other methods
    // ---------------------------------------------------------------------
    /**
     * This method creates bundle button.
     *
     * @return PanelItem that allows to select bundle button
     */
    private PanelItem createBundleButton(ItemTemplateRecord template, BlueprintBundle bundle)
    {
        if (bundle == null)
        {
            // return as bundle is null. Empty button will be created.
            return null;
        }
        // Get settings for island.
        PanelItemBuilder builder = new PanelItemBuilder();
        if (template.icon() != null)
        {
            builder.icon(template.icon().clone());
        }
        else
        {
            builder.icon(bundle.getIcon());
        }
        if (template.title() != null)
        {
            builder.name(this.user.getTranslation(this.command.getWorld(), template.title(),
                    TextVariables.NAME, bundle.getDisplayName()));
        }
        else
        {
            builder.name(this.user.getTranslation(BUNDLE_BUTTON_REF + "name",
                    TextVariables.NAME, bundle.getDisplayName()));
        }
        if (template.description() != null)
        {
            builder.description(this.user.getTranslation(this.command.getWorld(), template.description(),
                    TextVariables.DESCRIPTION, String.join("\n", bundle.getDescription())));
        }
        else
        {
            builder.description(this.user.getTranslation(BUNDLE_BUTTON_REF + "description",
                    TextVariables.DESCRIPTION, String.join("\n", bundle.getDescription())));
        }
        boolean usedUp = false;
        if (plugin.getSettings().getIslandNumber() > 1) {
            // Show how many times this bundle can be used
            int maxTimes = bundle.getTimes();
            if (maxTimes > 0) {
                long uses = plugin.getIslands().getIslands(world, user).stream()
                        .filter(is -> is.getMetaData("bundle")
                                .map(mdv -> bundle.getDisplayName().equalsIgnoreCase(mdv.asString())
                                        && !(reset && is.isPrimary(user.getUniqueId()))) // If this is a reset, then ignore the use of the island being reset
                                .orElse(false))
                        .count();
                builder.description(this.user.getTranslation(BUNDLE_BUTTON_REF + "uses", TextVariables.NUMBER,
                        String.valueOf(uses), "[max]", String.valueOf(maxTimes)));
                if (uses >= maxTimes) {
                    usedUp = true;
                }
            } else {
                builder.description(this.user.getTranslation(BUNDLE_BUTTON_REF + "unlimited"));
            }
        }
        if (usedUp) {
            if (plugin.getSettings().isHideUsedBlueprints()) {
                // Do not show used up blueprints
                return null;
            }
        } else {
            List<ItemTemplateRecord.ActionRecords> actions = template.actions().stream()
                    .filter(action -> SELECT_ACTION.equalsIgnoreCase(action.actionType())
                            || COMMANDS_ACTION.equalsIgnoreCase(action.actionType()))
                    .toList();
            // Add ClickHandler
            builder.clickHandler((panel, user, clickType, i) -> {
                actions.forEach(action -> {
                    if (clickType == action.clickType() || action.clickType() == ClickType.UNKNOWN)
                    {
                        if (SELECT_ACTION.equalsIgnoreCase(action.actionType())) {
                            user.closeInventory();
                            this.command.execute(user, this.mainLabel,
                                    Collections.singletonList(bundle.getUniqueId()));
                        } else if (COMMANDS_ACTION.equalsIgnoreCase(action.actionType())) {
                            Util.runCommands(user,
                                    Arrays.stream(action.content()
                                            .replaceAll(Pattern.quote(TextVariables.LABEL),
                                                    this.command.getTopLabel())
                                            .split("\n")).toList(),
                                    ISLAND_CREATION_COMMANDS);
                        }
                    }
                });
                // Always return true.
                return true;
            });
            // Collect tooltips.
            List<String> tooltips = actions.stream().filter(action -> action.tooltip() != null)
                    .map(action -> this.user.getTranslation(this.command.getWorld(), action.tooltip()))
                    .filter(text -> !text.isBlank())
                    .collect(Collectors.toCollection(() -> new ArrayList<>(actions.size())));
            // Add tooltips.
            if (!tooltips.isEmpty()) {
                // Empty line and tooltips.
                builder.description("");
                builder.description(tooltips);
            }
        }
        return builder.build();
    }
    // ---------------------------------------------------------------------
    // Section: Static methods
    // ---------------------------------------------------------------------
    /**
     * This method is used to open Panel outside this class. It will be much easier to open panel with single method
     * call then initializing new object.
     *
     * @param command CompositeCommand object
     * @param label The main command label
     * @param user User who opens panel
     * @param reset true if this is an island reset
     */
    public static void openPanel(@NonNull CompositeCommand command, @NonNull User user, @NonNull String label,
            boolean reset) {
        new IslandCreationPanel(command, user, label, reset).build();
    }
}
package world.bentobox.bentobox.database.objects;
import java.io.IOException;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;
import org.bukkit.Bukkit;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.World.Environment;
import org.bukkit.entity.Player;
import org.bukkit.util.BoundingBox;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSet.Builder;
import com.google.gson.annotations.Expose;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.configuration.WorldSettings;
import world.bentobox.bentobox.api.flags.Flag;
import world.bentobox.bentobox.api.logs.LogEntry;
import world.bentobox.bentobox.api.logs.LogEntry.LogType;
import world.bentobox.bentobox.api.metadata.MetaDataAble;
import world.bentobox.bentobox.api.metadata.MetaDataValue;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.database.objects.adapters.Adapter;
import world.bentobox.bentobox.database.objects.adapters.LogEntryListAdapter;
import world.bentobox.bentobox.lists.Flags;
import world.bentobox.bentobox.managers.IslandsManager;
import world.bentobox.bentobox.managers.RanksManager;
import world.bentobox.bentobox.util.Pair;
import world.bentobox.bentobox.util.Util;
/**
 * Stores all the info about an island Managed by IslandsManager Responsible for
 * team information as well.
 *
 * @author tastybento
 * @author Poslovitch
 */
@Table(name = "Islands")
public class Island implements DataObject, MetaDataAble {
    @Expose
    private Set<UUID> primaries = new HashSet<>();
    /**
     * Set to true if this data object has been changed since being loaded from the
     * database
     */
    private boolean changed;
    // True if this island is deleted and pending deletion from the database
    @Expose
    private boolean deleted = false;
    @Expose
    @NonNull
    private String uniqueId = UUID.randomUUID().toString();
    //// Island ////
    // The center of the island space
    @Expose
    private Location center;
    /**
     * The center location of the protection area
     */
    @Expose
    @Nullable
    private Location location;
    // Island range
    @Expose
    private int range;
    // Protection size
    @Expose
    private int protectionRange;
    /**
     * Bonuses to protection range
     * 
     * @since 1.20.0
     */
    @Expose
    private List<BonusRangeRecord> bonusRanges = new ArrayList<>();
    // Maximum ever protection range - used in island deletion
    @Expose
    private int maxEverProtectionRange;
    // World the island started in. This may be different from the island location
    @Expose
    private World world;
    /**
     * Name of the {@link world.bentobox.bentobox.api.addons.GameModeAddon
     * GameModeAddon} this island is handled by.
     * 
     * @since 1.5.0
     */
    @Expose
    private String gameMode;
    // Display name
    @Expose
    @Nullable
    private String name;
    // Time parameters
    @Expose
    private long createdDate;
    @Expose
    private long updatedDate;
    //// Team ////
    /**
     * Owner of the island. There can only be one per island. If it is {@code null},
     * then the island is considered as unowned.
     */
    @Expose
    @Nullable
    private UUID owner;
    /**
     * Members of the island. It contains any player which has one of the following
     * rank on this island: {@link RanksManager#COOP_RANK COOP},
     * {@link RanksManager#TRUSTED_RANK TRUSTED}, {@link RanksManager#MEMBER_RANK
     * MEMBER}, {@link RanksManager#SUB_OWNER_RANK SUB_OWNER},
     * {@link RanksManager#OWNER_RANK OWNER}.
     */
    @Expose
    private Map<UUID, Integer> members = new HashMap<>();
    /**
     * Maximum number of members allowed in this island. Key is rank, value is
     * number
     * 
     * @since 1.16.0
     */
    @Expose
    private Map<Integer, Integer> maxMembers;
    //// State ////
    @Expose
    private boolean spawn = false;
    @Expose
    private boolean purgeProtected = false;
    //// Protection flags ////
    @Expose
    private Map<String, Integer> flags = new HashMap<>();
    //// Island History ////
    @Adapter(LogEntryListAdapter.class)
    @Expose
    private List<LogEntry> history = new LinkedList<>();
    @Expose
    private Map<Environment, Location> spawnPoint = new EnumMap<>(Environment.class);
    /**
     * This flag is used to quarantine islands that cannot be loaded and should be
     * purged at some point
     */
    @Expose
    private boolean doNotLoad;
    /**
     * Used to store flag cooldowns for this island
     */
    @Expose
    private Map<String, Long> cooldowns = new HashMap<>();
    /**
     * Commands and the rank required to use them for this island
     */
    @Expose
    private Map<String, Integer> commandRanks;
    /**
     * If true then this space is reserved for the owner and when they teleport
     * there they will be asked to make an island
     * 
     * @since 1.6.0
     */
    @Expose
    @Nullable
    private Boolean reserved = null;
    /**
     * A place to store metadata for this island.
     * 
     * @since 1.15.4
     */
    @Expose
    private Map<String, MetaDataValue> metaData;
    /**
     * Island homes. Replaces player homes
     * 
     * @since 1.16.0
     */
    @Expose
    private Map<String, Location> homes;
    /**
     * The maximum number of homes allowed on this island. If null, then the world
     * default is used.
     */
    @Expose
    private Integer maxHomes;
    /*
     * *************************** Constructors ******************************
     */
    public Island() {
    }
    public Island(@NonNull Location location, UUID owner, int protectionRange) {
        setOwner(owner);
        createdDate = System.currentTimeMillis();
        updatedDate = System.currentTimeMillis();
        world = location.getWorld();
        // Make a copy of the location
        center = new Location(location.getWorld(), location.getX(), location.getY(), location.getZ());
        range = BentoBox.getInstance().getIWM().getIslandDistance(world);
        this.protectionRange = protectionRange;
        this.maxEverProtectionRange = protectionRange;
    }
    /**
     * Clones an island object
     * 
     * @param island - island to clone
     */
    public Island(Island island) {
        this.center = island.getCenter().clone();
        this.createdDate = island.getCreatedDate();
        Optional.ofNullable(island.getCommandRanks()).ifPresent(cr -> {
            this.commandRanks = new HashMap<>();
            this.commandRanks.putAll(cr);
        });
        Optional.ofNullable(island.getCooldowns()).ifPresent(c -> {
            this.cooldowns = new HashMap<>();
            this.cooldowns.putAll(c);
        });
        this.createdDate = island.getCreatedDate();
        this.deleted = island.isDeleted();
        this.doNotLoad = island.isDoNotLoad();
        this.flags.putAll(island.getFlags());
        this.gameMode = island.getGameMode();
        this.homes = new HashMap<>(island.getHomes());
        this.history.addAll(island.getHistory());
        this.location = island.getProtectionCenter();
        this.maxEverProtectionRange = island.getMaxEverProtectionRange();
        this.maxHomes = island.getMaxHomes();
        this.maxMembers = new HashMap<>(island.getMaxMembers());
        this.members.putAll(island.getMembers());
        island.getMetaData().ifPresent(m -> {
            this.metaData = new HashMap<>();
            this.metaData.putAll(m);
        });
        this.name = island.getName();
        this.owner = island.getOwner();
        this.protectionRange = island.getProtectionRange();
        this.purgeProtected = island.getPurgeProtected();
        this.range = island.getRange();
        this.reserved = island.isReserved();
        this.spawn = island.isSpawn();
        island.getSpawnPoint().forEach((k, v) -> island.spawnPoint.put(k, v.clone()));
        this.uniqueId = island.getUniqueId();
        this.updatedDate = island.getUpdatedDate();
        this.world = island.getWorld();
        this.bonusRanges.addAll(island.getBonusRanges());
        this.primaries.addAll(island.getPrimaries());
        this.setChanged();
    }
    /*
     * *************************** Methods ******************************
     */
    /**
     * Adds a team member. If player is on banned list, they will be removed from
     * it.
     * 
     * @param playerUUID - the player's UUID
     */
    public void addMember(@NonNull UUID playerUUID) {
        if (getRank(playerUUID) != RanksManager.MEMBER_RANK) {
            setRank(playerUUID, RanksManager.MEMBER_RANK);
            setChanged();
        }
    }
    /**
     * Bans the target player from this Island. If the player is a member, coop or
     * trustee, they will be removed from those lists. <br/>
     * Calling this method won't call the
     * {@link world.bentobox.bentobox.api.events.island.IslandBanEvent}.
     * 
     * @param issuer UUID of the issuer, may be null. Whenever possible, one should
     *               be provided.
     * @param target UUID of the target, must be provided.
     * @return {@code true}
     */
    public boolean ban(@NonNull UUID issuer, @NonNull UUID target) {
        if (getRank(target) != RanksManager.BANNED_RANK) {
            setRank(target, RanksManager.BANNED_RANK);
            log(new LogEntry.Builder(LogType.BAN).data("player", target.toString()).data("issuer", issuer.toString())
                    .build());
            setChanged();
        }
        return true;
    }
    /**
     * @return the banned
     */
    public Set<UUID> getBanned() {
        Set<UUID> result = new HashSet<>();
        for (Entry<UUID, Integer> member : members.entrySet()) {
            if (member.getValue() <= RanksManager.BANNED_RANK) {
                result.add(member.getKey());
            }
        }
        return result;
    }
    /**
     * Unbans the target player from this Island. <br/>
     * Calling this method won't call the
     * {@link world.bentobox.bentobox.api.events.island.IslandUnbanEvent}.
     * 
     * @param issuer UUID of the issuer, may be null. Whenever possible, one should
     *               be provided.
     * @param target UUID of the target, must be provided.
     * @return {@code true} if the target is successfully unbanned, {@code false}
     *         otherwise.
     */
    public boolean unban(@NonNull UUID issuer, @NonNull UUID target) {
        if (members.remove(target) != null) {
            log(new LogEntry.Builder(LogType.UNBAN).data("player", target.toString()).data("issuer", issuer.toString())
                    .build());
            return true;
        }
        return false;
    }
    /**
     * Returns a clone of the location of the center of this island.
     * 
     * @return clone of the center Location
     */
    @NonNull
    public Location getCenter() {
        return Objects.requireNonNull(center, "Island getCenter requires a non-null center").clone();
    }
    /**
     * @return the date when the island was created
     */
    public long getCreatedDate() {
        return createdDate;
    }
    /**
     * Gets the Island Guard flag's setting. If this is a protection flag, then this
     * will be the rank needed to bypass this flag. If it is a Settings flag, any
     * non-zero value means the setting is allowed.
     * 
     * @param flag - flag
     * @return flag value
     */
    public int getFlag(@NonNull Flag flag) {
        return flags.computeIfAbsent(flag.getID(), k -> flag.getDefaultRank());
    }
    /**
     * @return the flags
     */
    public Map<String, Integer> getFlags() {
        return flags;
    }
    /**
     * Returns the members of this island. It contains all players that have any
     * rank on this island, including {@link RanksManager#BANNED_RANK BANNED},
     * {@link RanksManager#TRUSTED_RANK TRUSTED}, {@link RanksManager#MEMBER_RANK
     * MEMBER}, {@link RanksManager#SUB_OWNER_RANK SUB_OWNER},
     * {@link RanksManager#OWNER_RANK OWNER}, etc.
     *
     * @return the members - key is the UUID, value is the RanksManager enum, e.g.
     *         {@link RanksManager#MEMBER_RANK}.
     * @see #getMemberSet()
     */
    public Map<UUID, Integer> getMembers() {
        return members;
    }
    /**
     * Returns an immutable set containing the UUIDs of players that are truly
     * members of this island. This includes any player which has one of the
     * following rank on this island: {@link RanksManager#MEMBER_RANK MEMBER},
     * {@link RanksManager#SUB_OWNER_RANK SUB_OWNER}, {@link RanksManager#OWNER_RANK
     * OWNER}.
     * 
     * @return the members of the island (owner included)
     * @see #getMembers()
     */
    public ImmutableSet<UUID> getMemberSet() {
        return getMemberSet(RanksManager.MEMBER_RANK);
    }
    /**
     * Returns an immutable set containing the UUIDs of players with rank above that
     * requested rank inclusive
     * 
     * @param minimumRank minimum rank (inclusive) of members
     * @return immutable set of UUIDs
     * @see #getMembers()
     * @since 1.5.0
     */
    public @NonNull ImmutableSet<UUID> getMemberSet(int minimumRank) {
        Builder<UUID> result = new ImmutableSet.Builder<>();
        members.entrySet().stream().filter(e -> e.getValue() >= minimumRank).map(Map.Entry::getKey)
                .forEach(result::add);
        return result.build();
    }
    /**
     * Returns an immutable set containing the UUIDs of players with rank equal or
     * above that requested rank (inclusive).
     * 
     * @param rank              rank to request
     * @param includeAboveRanks whether including players with rank above the
     *                          requested rank or not
     * @return immutable set of UUIDs
     * @see #getMemberSet(int)
     * @see #getMembers()
     * @since 1.5.0
     */
    public @NonNull ImmutableSet<UUID> getMemberSet(int rank, boolean includeAboveRanks) {
        if (includeAboveRanks) {
            return getMemberSet(rank);
        }
        Builder<UUID> result = new ImmutableSet.Builder<>();
        members.entrySet().stream().filter(e -> e.getValue() == rank).map(Map.Entry::getKey).forEach(result::add);
        return result.build();
    }
    /**
     * Get the minimum protected X block coordinate based on the island location. It
     * will never be less than {@link #getMinX()}
     * 
     * @return the minProtectedX
     */
    public int getMinProtectedX() {
        return Math.max(getMinX(), getProtectionCenter().getBlockX() - this.getProtectionRange());
    }
    /**
     * Get the maximum protected X block coordinate based on the island location. It
     * will never be more than {@link #getMaxX()}
     * 
     * @return the maxProtectedX
     * @since 1.5.2
     */
    public int getMaxProtectedX() {
        return Math.min(getMaxX(), getProtectionCenter().getBlockX() + this.getProtectionRange());
    }
    /**
     * Get the minimum protected Z block coordinate based on the island location. It
     * will never be less than {@link #getMinZ()}
     * 
     * @return the minProtectedZ
     */
    public int getMinProtectedZ() {
        return Math.max(getMinZ(), getProtectionCenter().getBlockZ() - this.getProtectionRange());
    }
    /**
     * Get the maximum protected Z block coordinate based on the island location. It
     * will never be more than {@link #getMaxZ()}
     * 
     * @return the maxProtectedZ
     * @since 1.5.2
     */
    public int getMaxProtectedZ() {
        return Math.min(getMaxZ(), getProtectionCenter().getBlockZ() + this.getProtectionRange());
    }
    /**
     * @return the minX
     */
    public int getMinX() {
        return center.getBlockX() - range;
    }
    /**
     * @return the maxX
     * @since 1.5.2
     */
    public int getMaxX() {
        return center.getBlockX() + range;
    }
    /**
     * @return the minZ
     */
    public int getMinZ() {
        return center.getBlockZ() - range;
    }
    /**
     * @return the maxZ
     * @since 1.5.2
     */
    public int getMaxZ() {
        return center.getBlockZ() + range;
    }
    /**
     * @return the island display name. Might be {@code null} if none is set.
     */
    @Nullable
    public String getName() {
        return name;
    }
    /**
     * Returns the owner of this island.
     * 
     * @return the owner, may be null.
     * @see #isOwned()
     * @see #isUnowned()
     */
    @Nullable
    public UUID getOwner() {
        return owner;
    }
    /**
     * Returns whether this island is owned or not.
     * 
     * @return {@code true} if this island has an owner, {@code false} otherwise.
     * @since 1.9.1
     * @see #getOwner()
     * @see #isUnowned()
     */
    public boolean isOwned() {
        return owner != null;
    }
    /**
     * Returns whether this island does not have an owner.
     * 
     * @return {@code true} if this island does not have an owner, {@code false}
     *         otherwise.
     * @since 1.9.1
     * @see #getOwner()
     * @see #isOwned()
     */
    public boolean isUnowned() {
        return owner == null;
    }
    /**
     * Returns the protection range of this Island plus any bonuses. Will not be
     * greater than getRange(). This represents half of the length of the side of a
     * theoretical square around the island center inside which flags are enforced.
     * 
     * @return the protection range of this island, strictly positive integer.
     * @see #getRange()
     */
    public int getProtectionRange() {
        return Math.min(this.getRange(),
                getRawProtectionRange() + this.getBonusRanges().stream().mapToInt(BonusRangeRecord::getRange).sum());
    }
    /**
     * Returns the protection range of this Island without any bonuses This
     * represents half of the length of the side of a theoretical square around the
     * island center inside which flags are enforced.
     * 
     * @return the protection range of this island, strictly positive integer.
     * @since 1.20.0
     */
    public int getRawProtectionRange() {
        return protectionRange;
    }
    /**
     * @return the maxEverProtectionRange or the protection range, whichever is
     *         larger
     */
    public int getMaxEverProtectionRange() {
        if (maxEverProtectionRange > this.getRange()) {
            maxEverProtectionRange = this.getRange();
            setChanged();
        }
        return Math.max(this.getProtectionRange(), maxEverProtectionRange);
    }
    /**
     * Sets the maximum protection range. This can be used to optimize island
     * deletion. Setting this values to a lower value than the current value will
     * have no effect.
     * 
     * @param maxEverProtectionRange the maxEverProtectionRange to set
     */
    public void setMaxEverProtectionRange(int maxEverProtectionRange) {
        if (maxEverProtectionRange > this.maxEverProtectionRange) {
            this.maxEverProtectionRange = maxEverProtectionRange;
        }
        if (maxEverProtectionRange > this.range) {
            this.maxEverProtectionRange = this.range;
        }
        setChanged();
    }
    /**
     * @return true if the island is protected from the Purge, otherwise false
     */
    public boolean getPurgeProtected() {
        return purgeProtected;
    }
    /**
     * Returns the island range. It is a convenience method that returns the exact
     * same value than island range, although it has been saved into the Island
     * object for easier access.
     * 
     * @return the island range
     * @see #getProtectionRange()
     */
    public int getRange() {
        return range;
    }
    /**
     * Get the rank of user for this island
     * 
     * @param user - the User
     * @return rank integer
     */
    public int getRank(User user) {
        return members.getOrDefault(user.getUniqueId(), RanksManager.VISITOR_RANK);
    }
    /**
     * Get the rank of user for this island
     * 
     * @param userUUID - the User's UUID
     * @return rank integer
     * @since 1.14.0
     */
    public int getRank(UUID userUUID) {
        return members.getOrDefault(userUUID, RanksManager.VISITOR_RANK);
    }
    @Override
    public @NonNull String getUniqueId() {
        return uniqueId;
    }
    /**
     * @return the date when the island was updated (team member connection, etc...)
     */
    public long getUpdatedDate() {
        return updatedDate;
    }
    /**
     * @return the world
     */
    public World getWorld() {
        return world;
    }
    /**
     * @return the nether world
     */
    @Nullable
    public World getNetherWorld() {
        return this.getWorld(Environment.NETHER);
    }
    /**
     * @return the end world
     */
    @Nullable
    public World getEndWorld() {
        return this.getWorld(Environment.THE_END);
    }
    /**
     * This method returns this island world in given environment. This method can
     * return {@code null} if dimension is disabled.
     * 
     * @param environment The environment of the island world.
     * @return the world in given environment.
     */
    @Nullable
    public World getWorld(Environment environment) {
        if (Environment.NORMAL.equals(environment)) {
            return this.world;
        } else if (Environment.THE_END.equals(environment) && this.isEndIslandEnabled()) {
            return this.getPlugin().getIWM().getEndWorld(this.world);
        } else if (Environment.NETHER.equals(environment) && this.isNetherIslandEnabled()) {
            return this.getPlugin().getIWM().getNetherWorld(this.world);
        } else {
            return null;
        }
    }
    /**
     * @return the x coordinate of the island center
     */
    public int getX() {
        return center.getBlockX();
    }
    /**
     * @return the y coordinate of the island center
     */
    public int getY() {
        return center.getBlockY();
    }
    /**
     * @return the z coordinate of the island center
     */
    public int getZ() {
        return center.getBlockZ();
    }
    /**
     * Checks if coords are in the island space
     * 
     * @param x - x coordinate
     * @param z - z coordinate
     * @return true if in the island space
     */
    public boolean inIslandSpace(int x, int z) {
        return x >= getMinX() && x < getMinX() + range * 2 && z >= getMinZ() && z < getMinZ() + range * 2;
    }
    /**
     * Checks if location is in full island space, not just protected space
     * 
     * @param location - location
     * @return true if in island space
     */
    public boolean inIslandSpace(Location location) {
        return Util.sameWorld(this.world, location.getWorld())
                && (location.getWorld().getEnvironment().equals(Environment.NORMAL)
                        || this.getPlugin().getIWM().isIslandNether(location.getWorld())
                        || this.getPlugin().getIWM().isIslandEnd(location.getWorld()))
                && this.inIslandSpace(location.getBlockX(), location.getBlockZ());
    }
    /**
     * Checks if the coordinates are in full island space, not just protected space
     * 
     * @param blockCoordinates - Pair(x,z) coordinates of block
     * @return true or false
     */
    public boolean inIslandSpace(Pair<Integer, Integer> blockCoordinates) {
        return inIslandSpace(blockCoordinates.x, blockCoordinates.z);
    }
    /**
     * Returns a {@link BoundingBox} of the full island space for overworld.
     * 
     * @return a {@link BoundingBox} of the full island space.
     * @since 1.5.2
     */
    @NonNull
    public BoundingBox getBoundingBox() {
        return this.getBoundingBox(Environment.NORMAL);
    }
    /**
     * Returns a {@link BoundingBox} of this island's space area in requested
     * dimension.
     * 
     * @param environment the requested dimension.
     * @return a {@link BoundingBox} of this island's space area or {@code null} if
     *         island is not created in requested dimension.
     * @since 1.21.0
     */
    @Nullable
    public BoundingBox getBoundingBox(Environment environment) {
        BoundingBox boundingBox;
        if (Environment.NORMAL.equals(environment)) {
            // Return normal world bounding box.
            boundingBox = new BoundingBox(this.getMinX(), this.world.getMinHeight(), this.getMinZ(), this.getMaxX(),
                    this.world.getMaxHeight(), this.getMaxZ());
        } else if (Environment.THE_END.equals(environment) && this.isEndIslandEnabled()) {
            // If end world is generated, return end island bounding box.
            boundingBox = new BoundingBox(this.getMinX(), this.getEndWorld().getMinHeight(), this.getMinZ(),
                    this.getMaxX(), this.getEndWorld().getMaxHeight(), this.getMaxZ());
        } else if (Environment.NETHER.equals(environment) && this.isNetherIslandEnabled()) {
            // If nether world is generated, return nether island bounding box.
            boundingBox = new BoundingBox(this.getMinX(), this.getNetherWorld().getMinHeight(), this.getMinZ(),
                    this.getMaxX(), this.getNetherWorld().getMaxHeight(), this.getMaxZ());
        } else {
            boundingBox = null;
        }
        return boundingBox;
    }
    /**
     * Using this method in the filtering for getVisitors and hasVisitors
     * 
     * @param player The player that must be checked.
     * @return true if player is a visitor
     */
    private boolean playerIsVisitor(Player player) {
        if (player.getGameMode() == GameMode.SPECTATOR) {
            return false;
        }
        return onIsland(player.getLocation()) && getRank(User.getInstance(player)) == RanksManager.VISITOR_RANK;
    }
    /**
     * Returns a list of players that are physically inside the island's protection
     * range and that are visitors.
     * 
     * @return list of visitors
     * @since 1.3.0
     */
    @NonNull
    public List<Player> getVisitors() {
        return Bukkit.getOnlinePlayers().stream().filter(this::playerIsVisitor).collect(Collectors.toList());
    }
    /**
     * Returns whether this Island has visitors inside its protection range. Note
     * this is equivalent to {@code !island.getVisitors().isEmpty()}.
     * 
     * @return {@code true} if there are visitors inside this Island's protection
     *         range, {@code false} otherwise.
     *
     * @since 1.3.0
     * @see #getVisitors()
     */
    public boolean hasVisitors() {
        return Bukkit.getOnlinePlayers().stream().anyMatch(this::playerIsVisitor);
    }
    /**
     * Returns a list of players that are physically inside the island's protection
     * range
     * 
     * @return list of players
     * @since 1.6.0
     */
    @NonNull
    public List<Player> getPlayersOnIsland() {
        return Bukkit.getOnlinePlayers().stream().filter(player -> onIsland(player.getLocation()))
                .collect(Collectors.toList());
    }
    /**
     * Returns whether this Island has players inside its protection range. Note
     * this is equivalent to {@code !island.getPlayersOnIsland().isEmpty()}.
     * 
     * @return {@code true} if there are players inside this Island's protection
     *         range, {@code false} otherwise.
     *
     * @since 1.6.0
     * @see #getPlayersOnIsland()
     */
    public boolean hasPlayersOnIsland() {
        return Bukkit.getOnlinePlayers().stream().anyMatch(player -> onIsland(player.getLocation()));
    }
    /**
     * Check if the flag is allowed or not For flags that are for the island in
     * general and not related to rank.
     * 
     * @param flag - flag
     * @return true if allowed, false if not
     */
    public boolean isAllowed(Flag flag) {
        // A negative value means not allowed
        return getFlag(flag) >= 0;
    }
    /**
     * Check if a user is allowed to bypass the flag or not
     * 
     * @param user - the User - user
     * @param flag - flag
     * @return true if allowed, false if not
     */
    public boolean isAllowed(User user, Flag flag) {
        return getRank(user) >= getFlag(flag);
    }
    /**
     * Check if banned
     * 
     * @param targetUUID - the target's UUID
     * @return Returns true if target is banned on this island
     */
    public boolean isBanned(UUID targetUUID) {
        return members.containsKey(targetUUID) && members.get(targetUUID).equals(RanksManager.BANNED_RANK);
    }
    /**
     * Returns whether the island is a spawn or not.
     * 
     * @return {@code true} if the island is a spawn, {@code false} otherwise.
     */
    public boolean isSpawn() {
        return spawn;
    }
    /**
     * Checks if a location is within this island's protected area.
     *
     * @param target location to check, not null
     * @return {@code true} if this location is within this island's protected area,
     *         {@code false} otherwise.
     */
    public boolean onIsland(@NonNull Location target) {
        return Util.sameWorld(this.world, target.getWorld())
                && (target.getWorld().getEnvironment().equals(Environment.NORMAL)
                        || this.getPlugin().getIWM().isIslandNether(target.getWorld())
                        || this.getPlugin().getIWM().isIslandEnd(target.getWorld()))
                && target.getBlockX() >= this.getMinProtectedX()
                && target.getBlockX() < (this.getMinProtectedX() + this.getProtectionRange() * 2)
                && target.getBlockZ() >= this.getMinProtectedZ()
                && target.getBlockZ() < (this.getMinProtectedZ() + this.getProtectionRange() * 2);
    }
    /**
     * Returns a {@link BoundingBox} of this island's protected area for overworld.
     * 
     * @return a {@link BoundingBox} of this island's protected area.
     * @since 1.5.2
     */
    @NonNull
    public BoundingBox getProtectionBoundingBox() {
        return this.getProtectionBoundingBox(Environment.NORMAL);
    }
    /**
     * Returns a {@link BoundingBox} of this island's protected area.
     * 
     * @param environment an environment of bounding box area.
     * @return a {@link BoundingBox} of this island's protected area or {@code null}
     *         if island is not created in required dimension. in required
     *         dimension.
     * @since 1.21.0
     */
    @Nullable
    public BoundingBox getProtectionBoundingBox(Environment environment) {
        BoundingBox boundingBox;
        if (Environment.NORMAL.equals(environment)) {
            // Return normal world bounding box.
            boundingBox = new BoundingBox(this.getMinProtectedX(), this.world.getMinHeight(), this.getMinProtectedZ(),
                    this.getMaxProtectedX(), this.world.getMaxHeight(), this.getMaxProtectedZ());
        } else if (Environment.THE_END.equals(environment) && this.isEndIslandEnabled()) {
            // If end world is generated, return end island bounding box.
            boundingBox = new BoundingBox(this.getMinProtectedX(), this.getEndWorld().getMinHeight(),
                    this.getMinProtectedZ(), this.getMaxProtectedX(), this.getEndWorld().getMaxHeight(),
                    this.getMaxProtectedZ());
        } else if (Environment.NETHER.equals(environment) && this.isNetherIslandEnabled()) {
            // If nether world is generated, return nether island bounding box.
            boundingBox = new BoundingBox(this.getMinProtectedX(), this.getNetherWorld().getMinHeight(),
                    this.getMinProtectedZ(), this.getMaxProtectedX(), this.getNetherWorld().getMaxHeight(),
                    this.getMaxProtectedZ());
        } else {
            boundingBox = null;
        }
        return boundingBox;
    }
    /**
     * Removes a player from the team member map. Generally, you should use
     * {@link world.bentobox.bentobox.managers.IslandsManager#removePlayer(World, UUID)}
     * 
     * @param playerUUID - uuid of player
     */
    public void removeMember(UUID playerUUID) {
        if (members.remove(playerUUID) != null) {
            setChanged();
        }
    }
    /**
     * @param center the center to set
     */
    public void setCenter(@NonNull Location center) {
        if (this.center == null || !center.getWorld().equals(this.center.getWorld()) || !center.equals(this.center)) {
            this.world = center.getWorld();
            this.center = center;
            setChanged();
        }
    }
    /**
     * @param createdDate - the createdDate to sets
     */
    public void setCreatedDate(long createdDate) {
        if (this.createdDate != createdDate) {
            this.createdDate = createdDate;
            setChanged();
        }
    }
    /**
     * Set the Island Guard flag rank This method affects subflags (if the given
     * flag is a parent flag)
     * 
     * @param flag  - flag
     * @param value - Use RanksManager settings, e.g. RanksManager.MEMBER
     * @return this island
     */
    public Island setFlag(Flag flag, int value) {
        setFlag(flag, value, true);
        return this;
    }
    /**
     * Set the Island Guard flag rank and set any  subflags
     * 
     * @param flag       - flag
     * @param value      - Use RanksManager settings, e.g. RanksManager.MEMBER
     * @param doSubflags - whether to set subflags
     */
    public void setFlag(Flag flag, int value, boolean doSubflags) {
        if (flags.containsKey(flag.getID()) && flags.get(flag.getID()) != value) {
            flags.put(flag.getID(), value);
            setChanged();
        }
        // Subflag support
        if (doSubflags && flag.hasSubflags()) {
            // Ensure that a subflag isn't a subflag of itself or else we're in trouble!
            flag.getSubflags().forEach(subflag -> setFlag(subflag, value, true));
        }
    }
    /**
     * @param flags the flags to set
     */
    public void setFlags(Map<String, Integer> flags) {
        this.flags = flags;
        setChanged();
    }
    /**
     * Resets the flags to their default as set in config.yml for this island. If
     * flags are missing from the config, the default hard-coded value is used and
     * set.
     * @return this island
     */
    public Island setFlagsDefaults() {
        BentoBox plugin = BentoBox.getInstance();
        Map<String, Integer> result = new HashMap<>();
        plugin.getFlagsManager().getFlags().stream().filter(f -> f.getType().equals(Flag.Type.PROTECTION))
                .forEach(f -> result.put(f.getID(),
                        plugin.getIWM().getDefaultIslandFlags(world).getOrDefault(f, f.getDefaultRank())));
        plugin.getFlagsManager().getFlags().stream().filter(f -> f.getType().equals(Flag.Type.SETTING))
                .forEach(f -> result.put(f.getID(),
                        plugin.getIWM().getDefaultIslandSettings(world).getOrDefault(f, f.getDefaultRank())));
        setFlags(result);
        return this;
    }
    /**
     * @param members the members to set
     */
    public void setMembers(Map<UUID, Integer> members) {
        this.members = members;
        setChanged();
    }
    /**
     * Sets the display name of this Island. <br/>
     * <br/>
     * An empty String or {@code null} will remove the display name.
     * 
     * @param name The display name to set.
     */
    public void setName(String name) {
        if (name == null || !name.equals(this.name)) {
            this.name = (name != null && !name.equals("")) ? name : null;
            setChanged();
        }
    }
    /**
     * Sets the owner of the island.
     * 
     * @param owner the island owner - the owner to set
     */
    public void setOwner(@Nullable UUID owner) {
        if (this.owner == owner) {
            return; // No need to update anything
        }
        this.owner = owner;
        if (owner == null) {
            log(new LogEntry.Builder(LogType.UNOWNED).build());
            return;
        }
        // Defensive code: demote any previous owner
        for (Entry<UUID, Integer> en : members.entrySet()) {
            if (en.getValue().equals(RanksManager.OWNER_RANK)) {
                setRank(en.getKey(), RanksManager.MEMBER_RANK);
            }
        }
        setRank(owner, RanksManager.OWNER_RANK);
        setChanged();
    }
    /**
     * @param protectionRange the protectionRange to set
     */
    public void setProtectionRange(int protectionRange) {
        if (this.protectionRange != protectionRange) {
            this.protectionRange = protectionRange;
            this.updateMaxEverProtectionRange();
            setChanged();
        }
    }
    /**
     * Updates the maxEverProtectionRange based on the current protectionRange
     */
    public void updateMaxEverProtectionRange() {
        // Ratchet up the maximum protection range
        // Distance from maxes
        int diffMinX = Math.abs(Objects.requireNonNull(getCenter()).getBlockX() - this.getMinProtectedX());
        int diffMaxX = Math.abs(getCenter().getBlockX() - this.getMaxProtectedX());
        int diffMinZ = Math.abs(getCenter().getBlockZ() - this.getMinProtectedZ());
        int diffMaxZ = Math.abs(getCenter().getBlockZ() - this.getMaxProtectedZ());
        if (diffMinX > this.maxEverProtectionRange) {
            this.maxEverProtectionRange = diffMinX;
        }
        if (diffMaxX > this.maxEverProtectionRange) {
            this.maxEverProtectionRange = diffMaxX;
        }
        if (diffMinZ > this.maxEverProtectionRange) {
            this.maxEverProtectionRange = diffMinZ;
        }
        if (diffMaxZ > this.maxEverProtectionRange) {
            this.maxEverProtectionRange = diffMaxZ;
        }
    }
    /**
     * @param purgeProtected - if the island is protected from the Purge
     */
    public void setPurgeProtected(boolean purgeProtected) {
        if (this.purgeProtected != purgeProtected) {
            this.purgeProtected = purgeProtected;
            setChanged();
        }
    }
    /**
     * Sets the island range. This method should <u><strong>NEVER</strong></u> be
     * used except for testing purposes. <br>
     * The range value is a copy of {@link WorldSettings#getIslandDistance()} made
     * when the Island got created in order to allow easier access to this value and
     * must therefore remain <u><strong>AS IS</strong></u>.
     * 
     * @param range the range to set
     * @see #setProtectionRange(int)
     */
    public void setRange(int range) {
        if (this.range != range) {
            this.range = range;
            setChanged();
        }
    }
    /**
     * Set user's rank to an arbitrary rank value
     * 
     * @param user the User
     * @param rank rank value
     */
    public void setRank(User user, int rank) {
        setRank(user.getUniqueId(), rank);
    }
    /**
     * Sets player's rank to an arbitrary rank value. Calling this method won't call
     * the {@link world.bentobox.bentobox.api.events.island.IslandRankChangeEvent}.
     * 
     * @param uuid UUID of the player
     * @param newRank rank value
     * @since 1.1
     */
    public void setRank(@Nullable UUID uuid, int newRank) {
        // Early return if the UUID is null, to avoid unnecessary processing.
        if (uuid == null) {
            return;
        }
        // Use an AtomicBoolean to track if the member's rank has been changed.
        AtomicBoolean isRankChanged = new AtomicBoolean(false);
        // Attempt to update the member's rank, if necessary.
        members.compute(uuid, (key, existingRank) -> {
            // If the member does not exist or their rank is different, update the rank.
            if (existingRank == null || existingRank != newRank) {
                isRankChanged.set(true);
                return newRank; // Update the rank.
            }
            // No change needed; return the existing rank.
            return existingRank;
        });
        // If the rank was changed, notify the change and log the update.
        if (isRankChanged.get()) {
            setChanged(); // Notify that a change has occurred.
        }
    }
    /**
     * @param ranks the ranks to set
     */
    public void setRanks(Map<UUID, Integer> ranks) {
        members = ranks;
        setChanged();
    }
    /**
     * Sets whether this island is a spawn or not. <br/>
     * If {@code true}, the members and the owner will be removed from this island.
     * The flags will also be reset to default values.
     * 
     * @param isSpawn {@code true} if the island is a spawn, {@code false}
     *                otherwise.
     */
    public void setSpawn(boolean isSpawn) {
        if (spawn == isSpawn) {
            return; // No need to update anything
        }
        spawn = isSpawn;
        if (isSpawn) {
            setOwner(null);
            members.clear();
            setFlagsDefaults();
            setFlag(Flags.LOCK, RanksManager.VISITOR_RANK);
        }
        log(new LogEntry.Builder(LogType.SPAWN).data("value", String.valueOf(isSpawn)).build());
        setChanged();
    }
    /**
     * Get the default spawn location for this island. Note that this may only be
     * valid after the initial pasting because the player can change the island
     * after that point
     * 
     * @return the spawnPoint
     */
    public Map<Environment, Location> getSpawnPoint() {
        return spawnPoint;
    }
    /**
     * Set when island is pasted
     * 
     * @param spawnPoint the spawnPoint to set
     */
    public void setSpawnPoint(Map<Environment, Location> spawnPoint) {
        this.spawnPoint = spawnPoint;
        setChanged();
    }
    @Override
    public void setUniqueId(String uniqueId) {
        this.uniqueId = uniqueId;
    }
    /**
     * @param updatedDate - the updatedDate to sets
     */
    public void setUpdatedDate(long updatedDate) {
        this.updatedDate = updatedDate;
    }
    /**
     * @param world the world to set
     */
    public void setWorld(World world) {
        this.world = world;
        setChanged();
    }
    /**
     * Toggles a settings flag This method affects subflags (if the given flag is a
     * parent flag)
     * 
     * @param flag - flag
     */
    public void toggleFlag(Flag flag) {
        toggleFlag(flag, true);
    }
    /**
     * Toggles a settings flag Also specify whether subflags are affected by this
     * method call
     * 
     * @param flag - flag
     */
    public void toggleFlag(Flag flag, boolean doSubflags) {
        boolean newToggleValue = !isAllowed(flag); // Use for subflags
        if (flag.getType().equals(Flag.Type.SETTING) || flag.getType().equals(Flag.Type.WORLD_SETTING)) {
            setSettingsFlag(flag, newToggleValue, doSubflags);
        }
        setChanged();
    }
    /**
     * Sets the state of a settings flag This method affects subflags (if the given
     * flag is a parent flag)
     * 
     * @param flag  - flag
     * @param state - true or false
     */
    public void setSettingsFlag(Flag flag, boolean state) {
        setSettingsFlag(flag, state, true);
    }
    /**
     * Sets the state of a settings flag Also specify whether subflags are affected
     * by this method call
     * 
     * @param flag  - flag
     * @param state - true or false
     */
    public void setSettingsFlag(Flag flag, boolean state, boolean doSubflags) {
        int newState = state ? 1 : -1;
        if (flag.getType().equals(Flag.Type.SETTING) || flag.getType().equals(Flag.Type.WORLD_SETTING)) {
            flags.put(flag.getID(), newState);
            if (doSubflags && flag.hasSubflags()) {
                // If we have circular subflags or a flag is a subflag of itself we are in
                // trouble!
                flag.getSubflags().forEach(subflag -> setSettingsFlag(subflag, state, true));
            }
        }
        setChanged();
    }
    /**
     * Set the spawn location for this island type
     * 
     * @param islandType - island type
     * @param l          - location
     */
    public void setSpawnPoint(Environment islandType, Location l) {
        spawnPoint.compute(islandType, (key, value) -> {
            if (value == null || !value.equals(l)) {
                setChanged(); // Call setChanged only if the value is updated.
                return l;
            }
            return value;
        });
    }
    /**
     * Get the spawn point for this island type
     * 
     * @param islandType - island type
     * @return - location or null if one does not exist
     */
    @Nullable
    public Location getSpawnPoint(Environment islandType) {
        return spawnPoint.get(islandType);
    }
    /**
     * Removes all of a specified rank from the member list
     * 
     * @param rank rank value
     */
    public void removeRank(Integer rank) {
        if (members.values().removeIf(rank::equals)) {
            setChanged();
        }
    }
    /**
     * Gets the history of the island.
     * 
     * @return the list of {@link LogEntry} for this island.
     */
    public List<LogEntry> getHistory() {
        return history;
    }
    /**
     * Adds a {@link LogEntry} to the history of this island.
     * 
     * @param logEntry the LogEntry to add.
     */
    public void log(LogEntry logEntry) {
        history.add(logEntry);
        setChanged();
    }
    /**
     * Sets the history of the island.
     * 
     * @param history the list of {@link LogEntry} to set for this island.
     */
    public void setHistory(List<LogEntry> history) {
        this.history = history;
        setChanged();
    }
    /**
     * @return the doNotLoad
     */
    public boolean isDoNotLoad() {
        return doNotLoad;
    }
    /**
     * @param doNotLoad the doNotLoad to set
     */
    public void setDoNotLoad(boolean doNotLoad) {
        this.doNotLoad = doNotLoad;
        setChanged();
    }
    /**
     * @return the deleted
     */
    public boolean isDeleted() {
        return deleted;
    }
    /**
     * @param deleted the deleted to set
     */
    public void setDeleted(boolean deleted) {
        this.deleted = deleted;
        setChanged();
    }
    /**
     * Returns the name of the
     * {@link world.bentobox.bentobox.api.addons.GameModeAddon GameModeAddon} this
     * island is handled by.
     * 
     * @return the name of the
     *         {@link world.bentobox.bentobox.api.addons.GameModeAddon
     *         GameModeAddon} this island is handled by.
     * @since 1.5.0
     */
    public String getGameMode() {
        return gameMode;
    }
    /**
     * Sets the name of the {@link world.bentobox.bentobox.api.addons.GameModeAddon
     * GameModeAddon} this island is handled by. Note this has no effect over the
     * actual location of the island, however this may cause issues with addons
     * using this data.
     * 
     * @since 1.5.0
     */
    public void setGameMode(String gameMode) {
        this.gameMode = gameMode;
    }
    /**
     * Checks whether this island has its nether island generated or not.
     * 
     * @return {@code true} if this island has its nether island generated,
     *         {@code false} otherwise.
     * @since 1.5.0
     */
    public boolean hasNetherIsland() {
        World nether = BentoBox.getInstance().getIWM().getNetherWorld(getWorld());
        return nether != null && (getCenter().toVector().toLocation(nether).getBlock().getType() != Material.AIR);
    }
    /**
     * Checks whether this island has its nether island mode enabled or not.
     * 
     * @return {@code true} if this island has its nether island enabled,
     *         {@code false} otherwise.
     * @since 1.21.0
     */
    public boolean isNetherIslandEnabled() {
        return this.getPlugin().getIWM().isNetherGenerate(this.world)
                && this.getPlugin().getIWM().isNetherIslands(this.world);
    }
    /**
     * Checks whether this island has its end island generated or not.
     * 
     * @return {@code true} if this island has its end island generated,
     *         {@code false} otherwise.
     * @since 1.5.0
     */
    public boolean hasEndIsland() {
        World end = BentoBox.getInstance().getIWM().getEndWorld(getWorld());
        return end != null && (getCenter().toVector().toLocation(end).getBlock().getType() != Material.AIR);
    }
    /**
     * Checks whether this island has its end island mode enabled or not.
     * 
     * @return {@code true} if this island has its end island enabled, {@code false}
     *         otherwise.
     * @since 1.21.0
     */
    public boolean isEndIslandEnabled() {
        return this.getPlugin().getIWM().isEndGenerate(this.world)
                && this.getPlugin().getIWM().isEndIslands(this.world);
    }
    /**
     * Checks if a flag is on cooldown. Only stored in memory so a server restart
     * will reset the cooldown.
     * 
     * @param flag - flag
     * @return true if on cooldown, false if not
     * @since 1.6.0
     */
    public boolean isCooldown(Flag flag) {
        if (cooldowns.containsKey(flag.getID()) && cooldowns.get(flag.getID()) > System.currentTimeMillis()) {
            return true;
        }
        if (cooldowns.remove(flag.getID()) != null) {
            setChanged();
        }
        return false;
    }
    /**
     * Sets a cooldown for this flag on this island.
     * 
     * @param flag - Flag to cooldown
     */
    public void setCooldown(Flag flag) {
        cooldowns.put(flag.getID(), flag.getCooldown() * 1000L + System.currentTimeMillis());
        setChanged();
    }
    /**
     * @return the cooldowns
     */
    public Map<String, Long> getCooldowns() {
        return cooldowns;
    }
    /**
     * @param cooldowns the cooldowns to set
     */
    public void setCooldowns(Map<String, Long> cooldowns) {
        this.cooldowns = cooldowns;
        setChanged();
    }
    /**
     * @return the commandRanks
     */
    public Map<String, Integer> getCommandRanks() {
        return commandRanks;
    }
    /**
     * @param commandRanks the commandRanks to set
     */
    public void setCommandRanks(Map<String, Integer> commandRanks) {
        this.commandRanks = commandRanks;
        setChanged();
    }
    /**
     * Get the rank required to run command on this island. The command must have
     * been registered with a rank.
     * 
     * @param command - the string given by {@link CompositeCommand#getUsage()}
     * @return Rank value required, or if command is not set
     *         {@link CompositeCommand#getDefaultCommandRank()}
     */
    public int getRankCommand(String command) {
        if (this.commandRanks == null) {
            this.commandRanks = new HashMap<>();
        }
        // Return or calculate default rank for a command.
        return this.commandRanks.computeIfAbsent(command, key -> {
            // Need to find default value for the command.
            String[] labels = key.replaceFirst("/", "").split(" ");
            // Get first command label.
            CompositeCommand compositeCommand = this.getPlugin().getCommandsManager().getCommand(labels[0]);
            for (int i = 1; i < labels.length && compositeCommand != null; i++) {
                compositeCommand = compositeCommand.getSubCommand(labels[i]).orElse(null);
            }
            // Return default command rank or owner rank, if command does not exist.
            return compositeCommand == null ? RanksManager.OWNER_RANK : compositeCommand.getDefaultCommandRank();
        });
    }
    /**
     *
     * @param command - the string given by {@link CompositeCommand#getUsage()}
     * @param rank    value as used by {@link RanksManager}
     */
    public void setRankCommand(String command, int rank) {
        if (this.commandRanks == null)
            this.commandRanks = new HashMap<>();
        commandRanks.compute(command, (key, value) -> {
            if (value == null || !value.equals(rank)) {
                setChanged(); // Call setChanged only if the value is updated.
                return rank;
            }
            return value;
        });
    }
    /**
     * Returns whether this Island is currently reserved or not. If {@code true},
     * this means no blocks, except a bedrock one at the center of the island,
     * exist.
     * 
     * @return {@code true} if this Island is reserved, {@code false} otherwise.
     * @since 1.6.0
     */
    public boolean isReserved() {
        return reserved != null && reserved;
    }
    /**
     * @param reserved the reserved to set
     * @since 1.6.0
     */
    public void setReserved(boolean reserved) {
        if (this.reserved != reserved) {
            this.reserved = reserved;
            setChanged();
        }
    }
    /**
     * @return the metaData
     * @since 1.15.5
     */
    @Override
    public Optional<Map<String, MetaDataValue>> getMetaData() {
        if (metaData == null) {
            metaData = new HashMap<>();
        }
        return Optional.of(metaData);
    }
    /**
     * @param metaData the metaData to set
     * @since 1.15.4
     */
    @Override
    public void setMetaData(Map<String, MetaDataValue> metaData) {
        this.metaData = metaData;
        setChanged();
    }
    /**
     * @return changed state
     */
    public boolean isChanged() {
        return changed;
    }
    /**
     * Indicates the fields have been changed. Used to optimize saving on shutdown and notify other servers
     */
    public void setChanged() {
        this.setUpdatedDate(System.currentTimeMillis());
        this.changed = true;
        IslandsManager.updateIsland(this);
    }
    /**
     * Resets the changed if the island has been saved
     */
    public void clearChanged() {
        this.changed = false;
    }
    /**
     * Get the center location of the protection zone. This can be anywhere within
     * the island space and can move. Unless explicitly set, it will return the same
     * as {@link #getCenter()}.
     * 
     * @return a clone of the protection center location
     * @since 1.16.0
     */
    @NonNull
    public Location getProtectionCenter() {
        return location == null ? getCenter() : location.clone();
    }
    /**
     * Sets the protection center location of the island within the island space.
     * 
     * @param location the location to set
     * @throws IOException if the location is not in island space
     * @since 1.16.0
     */
    public void setProtectionCenter(Location location) throws IOException {
        if (this.getProtectionCenter().equals(location)) {
            return; // nothing to do
        }
        if (!this.inIslandSpace(location)) {
            throw new IOException("Location must be in island space");
        }
        this.location = location;
        this.updateMaxEverProtectionRange();
        setChanged();
    }
    /**
     * @return the homes
     * @since 1.16.0
     */
    @NonNull
    public Map<String, Location> getHomes() {
        if (homes == null) {
            homes = new HashMap<>();
        }
        return homes;
    }
    /**
     * Get the location of a named home
     * 
     * @param nameToLookFor home name case insensitive (name is forced to lower case)
     * @return the home location or if none found the protection center of the
     *         island is returned.
     * @since 1.16.0
     */
    @NonNull
    public Location getHome(final String nameToLookFor) {
        return getHomes().entrySet().stream().filter(en -> en.getKey().equalsIgnoreCase(nameToLookFor))
                .map(Entry::getValue)
                .findFirst().orElse(getProtectionCenter().clone().add(new Vector(0.5D, 0D, 0.5D)));
    }
    /**
     * @param homes the homes to set
     * @since 1.16.0
     */
    public void setHomes(Map<String, Location> homes) {
        this.homes = homes;
        setChanged();
    }
    /**
     * @param name the name of the home
     * @since 1.16.0
     */
    public void addHome(String name, Location location) {
        if (getHomes().containsKey(name) && getHomes().get(name).equals(location)) {
            return; // nothing to do
        }
        if (location != null) {
            Vector v = location.toVector();
            if (!this.getBoundingBox().contains(v)) {
                BentoBox.getInstance().logWarning("Tried to set a home location " + location
                        + " outside of the island. This generally should not happen.");
                BentoBox.getInstance().logWarning(
                        "Island is at " + this.getCenter() + ". The island file may need editing to remove this home.");
                BentoBox.getInstance().logWarning("Please report this issue and logs around this item to BentoBox");
            }
        }
        getHomes().put(name.toLowerCase(), location);
        setChanged();
    }
    /**
     * Remove a named home from this island
     * 
     * @param name - home name to remove
     * @return true if home removed successfully
     * @since 1.16.0
     */
    public boolean removeHome(String name) {
        if (getHomes().remove(name.toLowerCase()) != null) {
            setChanged();
            return true;
        }
        return false;
    }
    /**
     * Remove all homes from this island except the default home
     * 
     * @return true if any non-default homes removed
     * @since 1.20.0
     */
    public boolean removeHomes() {
        if (getHomes().keySet().removeIf(k -> !k.isEmpty())) {
            setChanged();
            return true;
        }
        return false;
    }
    /**
     * Rename a home
     * 
     * @param oldName - old name of home
     * @param newName - new name of home
     * @return true if successful, false if oldName does not exist, already exists
     * @since 1.16.0
     */
    public boolean renameHome(String oldName, String newName) {
        if (getHomes().containsKey(oldName.toLowerCase()) && !getHomes().containsKey(newName.toLowerCase())) {
            this.addHome(newName, this.getHome(oldName));
            this.removeHome(oldName);
            return true;
        }
        return false;
    }
    /**
     * Get the max homes. You shouldn't access this directly. Use
     * {@link world.bentobox.bentobox.managers.IslandsManager#getMaxHomes(Island)}
     * 
     * @return the maxHomes. If null, then the world default should be used.
     * @since 1.16.0
     */
    @Nullable
    public Integer getMaxHomes() {
        return maxHomes;
    }
    /**
     * @param maxHomes the maxHomes to set. If null then the world default will be
     *                 used. You shouldn't access this directly. Use
     *                 {@link world.bentobox.bentobox.managers.IslandsManager#setMaxHomes(Island, Integer)}
     * @since 1.16.0
     */
    public void setMaxHomes(@Nullable Integer maxHomes) {
        if (this.maxHomes != maxHomes) {
            this.maxHomes = maxHomes;
            setChanged();
        }
    }
    /**
     * @return the maxMembers
     * @since 1.16.0
     */
    public Map<Integer, Integer> getMaxMembers() {
        if (maxMembers == null) {
            maxMembers = new HashMap<>();
        }
        return maxMembers;
    }
    /**
     * @param maxMembers the maxMembers to set
     * @since 1.16.0
     */
    public void setMaxMembers(Map<Integer, Integer> maxMembers) {
        if (this.maxMembers != maxMembers) {
            this.maxMembers = maxMembers;
            setChanged();
        }
    }
    /**
     * Get the maximum number of island members
     * 
     * @param rank island rank value from {@link RanksManager}
     * @return the maxMembers for the rank given - if null then the world default
     *         should be used. Negative values = unlimited.
     * @since 1.16.0
     */
    @Nullable
    public Integer getMaxMembers(int rank) {
        return getMaxMembers().get(rank);
    }
    /**
     * Set the maximum number of island members
     * 
     * @param rank       island rank value from {@link RanksManager}
     * @param maxMembers the maxMembers to set. If null then the world default
     *                   applies. Negative values = unlimited.
     * @since 1.16.0
     */
    public void setMaxMembers(int rank, Integer maxMembers) {
        getMaxMembers().compute(rank, (key, value) -> {
            if (value == null || !value.equals(maxMembers)) {
                setChanged(); // Call setChanged only if the value is updated.
                return maxMembers;
            }
            return value;
        });
    }
    /**
     * @return the bonusRanges
     */
    public List<BonusRangeRecord> getBonusRanges() {
        if (bonusRanges == null) {
            this.setBonusRanges(new ArrayList<>());
        }
        return bonusRanges;
    }
    /**
     * @param bonusRanges the bonusRanges to set
     */
    public void setBonusRanges(List<BonusRangeRecord> bonusRanges) {
        this.bonusRanges = bonusRanges;
        setChanged();
    }
    /**
     * Get the bonus range provided by all settings of the range giver
     * 
     * @param id an id to identify this bonus
     * @return bonus range, or 0 if unknown
     */
    public int getBonusRange(String id) {
        return this.getBonusRanges().stream().filter(r -> r.getUniqueId().equals(id))
                .mapToInt(BonusRangeRecord::getRange).sum();
    }
    /**
     * Get the BonusRangeRecord for uniqueId
     * 
     * @param uniqueId a unique id to identify this bonus
     * @return optional BonusRangeRecord
     */
    public Optional<BonusRangeRecord> getBonusRangeRecord(String uniqueId) {
        return this.getBonusRanges().stream().filter(r -> r.getUniqueId().equals(uniqueId)).findFirst();
    }
    /**
     * Add a bonus range amount to the island for this addon or plugin. Note, this
     * will not replace any range set already with the same id
     * 
     * @param id      an id to identify this bonus
     * @param range   range to add to the island protected range
     * @param message the reference key to a locale message related to this bonus.
     *                May be blank.
     */
    public void addBonusRange(String id, int range, String message) {
        this.getBonusRanges().add(new BonusRangeRecord(id, range, message));
        setMaxEverProtectionRange(this.getProtectionRange());
        setChanged();
    }
    /**
     * Clear the bonus ranges for a unique ID
     * 
     * @param id id to identify this bonus
     */
    public void clearBonusRange(String id) {
        if (this.getBonusRanges().removeIf(r -> r.getUniqueId().equals(id))) {
            setChanged();
        }
    }
    /**
     * Clear all bonus ranges for this island
     */
    public void clearAllBonusRanges() {
        this.getBonusRanges().clear();
        setChanged();
    }
    /**
     * @param userID user UUID
     * @return the primary
     */
    public boolean isPrimary(UUID userID) {
        return getPrimaries().contains(userID);
    }
    /**
     * Set this island to be the primary for this user
     * @param userID user UUID
     */
    public void setPrimary(UUID userID) {
        if (getPrimaries().add(userID)) {
            setChanged();
        }
    }
    /**
     * Remove the primary island
     * @param userID user UUID
     */
    public void removePrimary(UUID userID) {
        if (getPrimaries().remove(userID)) {
            setChanged();
        }
    }
    /**
     * Check if a player is in this island's team
     * @param playerUUID player's UUID
     * @return true if in team
     * @since 2.3.0
     */
    public boolean inTeam(UUID playerUUID) {
        return this.getMemberSet().contains(playerUUID);
    }
    /**
     * Check if this island has a team
     * @return true if this island has a team
     * @since 2.3.0
     */
    public boolean hasTeam() {
        return this.getMemberSet().size() > 1;
    }
    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        return "Island [changed=" + changed + ", deleted=" + deleted + ", uniqueId=" + uniqueId + ", center=" + center
                + ", location=" + location + ", range=" + range + ", protectionRange=" + protectionRange
                + ", maxEverProtectionRange=" + maxEverProtectionRange + ", world=" + world + ", gameMode=" + gameMode
                + ", name=" + name + ", createdDate=" + createdDate + ", updatedDate=" + updatedDate + ", owner="
                + owner + ", members=" + members + ", maxMembers=" + maxMembers + ", spawn=" + spawn
                + ", purgeProtected=" + purgeProtected + ", flags=" + flags + ", history=" + history + ", spawnPoint="
                + spawnPoint + ", doNotLoad=" + doNotLoad + ", cooldowns=" + cooldowns + ", commandRanks="
                + commandRanks + ", reserved=" + reserved + ", metaData=" + metaData + ", homes=" + homes
                + ", maxHomes=" + maxHomes + "]";
    }
    /**
     * @return the primaries
     */
    public Set<UUID> getPrimaries() {
        if (primaries == null) {
            primaries = new HashSet<>();
        }
        return primaries;
    }
    /**
     * @param primaries the primaries to set
     */
    public void setPrimaries(Set<UUID> primaries) {
        this.primaries = primaries;
        setChanged();
    }
    @Override
    public int hashCode() {
        return Objects.hash(uniqueId);
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Island other = (Island) obj;
        return Objects.equals(uniqueId, other.uniqueId);
    }
}
package world.bentobox.bentobox.api.user;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang.math.NumberUtils;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Color;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.OfflinePlayer;
import org.bukkit.Particle;
import org.bukkit.Particle.DustTransition;
import org.bukkit.Vibration;
import org.bukkit.World;
import org.bukkit.block.data.BlockData;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.permissions.PermissionAttachment;
import org.bukkit.permissions.PermissionAttachmentInfo;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.google.common.base.Enums;
import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.HoverEvent;
import net.md_5.bungee.api.chat.TextComponent;
import net.md_5.bungee.api.chat.hover.content.Text;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.Addon;
import world.bentobox.bentobox.api.events.OfflineMessageEvent;
import world.bentobox.bentobox.api.metadata.MetaDataAble;
import world.bentobox.bentobox.api.metadata.MetaDataValue;
import world.bentobox.bentobox.database.objects.Players;
import world.bentobox.bentobox.util.Util;
/**
 * Combines {@link Player}, {@link OfflinePlayer} and {@link CommandSender} to
 * provide convenience methods related to localization and generic interactions.
 * <br/>
 * Therefore, a User could usually be a Player, an OfflinePlayer or the server's
 * console. Preliminary checks should be performed before trying to run methods
 * that relies on a specific implementation. <br/>
 * <br/>
 * It is good practice to use the User instance whenever possible instead of
 * Player or CommandSender.
 *
 * @author tastybento
 */
public class User implements MetaDataAble {
    private static final Map<UUID, User> users = new HashMap<>();
    // Used for particle validation
    private static final Map<Particle, Class<?>> VALIDATION_CHECK;
    static {
        Map<Particle, Class<?>> v = new EnumMap<>(Particle.class);
        v.put(Enums.getIfPresent(Particle.class, "DUST")
                .or(Enums.getIfPresent(Particle.class, "REDSTONE").or(Particle.FLAME)), Particle.DustOptions.class);
        if (Enums.getIfPresent(Particle.class, "ITEM").isPresent()) {
            // 1.20.6 Particles
            v.put(Particle.ITEM, ItemStack.class);
            v.put(Particle.ITEM_COBWEB, ItemStack.class);
            v.put(Particle.BLOCK, BlockData.class);
            v.put(Particle.DUST_PILLAR, BlockData.class);
            v.put(Particle.ENTITY_EFFECT, Color.class);
        }
        v.put(Particle.FALLING_DUST, BlockData.class);
        v.put(Particle.BLOCK_MARKER, BlockData.class);
        v.put(Particle.DUST_COLOR_TRANSITION, DustTransition.class);
        v.put(Particle.VIBRATION, Vibration.class);
        v.put(Particle.SCULK_CHARGE, Float.class);
        v.put(Particle.SHRIEK, Integer.class);
        VALIDATION_CHECK = Collections.unmodifiableMap(v);
    }
    /**
     * Clears all users from the user list
     */
    public static void clearUsers() {
        users.clear();
    }
    /**
     * Gets an instance of User from a CommandSender
     * 
     * @param sender - command sender, e.g. console
     * @return user - user
     */
    @NonNull
    public static User getInstance(@NonNull CommandSender sender) {
        if (sender instanceof Player p) {
            return getInstance(p);
        }
        // Console
        return new User(sender);
    }
    /**
     * Gets an instance of User from a Player object.
     * 
     * @param player - the player
     * @return user - user
     */
    @NonNull
    public static User getInstance(@NonNull Player player) {
        if (users.containsKey(player.getUniqueId())) {
            return users.get(player.getUniqueId());
        }
        return new User(player);
    }
    /**
     * Gets an instance of User from a UUID. This will always return a user object.
     * If the player is offline then the getPlayer value will be null.
     * 
     * @param uuid - UUID
     * @return user - user
     */
    @NonNull
    public static User getInstance(@NonNull UUID uuid) {
        if (users.containsKey(uuid)) {
            return users.get(uuid);
        }
        // Return a user instance
        return new User(uuid);
    }
    /**
     * Gets an instance of User from an OfflinePlayer
     * 
     * @param offlinePlayer offline Player
     * @return user
     * @since 1.3.0
     */
    @NonNull
    public static User getInstance(@NonNull OfflinePlayer offlinePlayer) {
        if (users.containsKey(offlinePlayer.getUniqueId())) {
            return users.get(offlinePlayer.getUniqueId());
        }
        return new User(offlinePlayer);
    }
    /**
     * Removes this player from the User cache and player manager cache
     * 
     * @param player the player
     */
    public static void removePlayer(Player player) {
        if (player != null) {
            users.remove(player.getUniqueId());
        }
    }
    // ----------------------------------------------------
    private static BentoBox plugin = BentoBox.getInstance();
    @Nullable
    private final Player player;
    private OfflinePlayer offlinePlayer;
    private final UUID playerUUID;
    @Nullable
    private final CommandSender sender;
    private Addon addon;
    private User(@Nullable CommandSender sender) {
        player = null;
        playerUUID = null;
        this.sender = sender;
    }
    private User(@NonNull Player player) {
        this.player = player;
        offlinePlayer = player;
        sender = player;
        playerUUID = player.getUniqueId();
        users.put(playerUUID, this);
    }
    private User(@NonNull OfflinePlayer offlinePlayer) {
        this.player = offlinePlayer.isOnline() ? offlinePlayer.getPlayer() : null;
        this.playerUUID = offlinePlayer.getUniqueId();
        this.sender = offlinePlayer.isOnline() ? offlinePlayer.getPlayer() : null;
        this.offlinePlayer = offlinePlayer;
    }
    private User(UUID playerUUID) {
        player = Bukkit.getPlayer(playerUUID);
        this.playerUUID = playerUUID;
        sender = player;
        offlinePlayer = Bukkit.getOfflinePlayer(playerUUID);
    }
    /**
     * Used for testing
     * 
     * @param p - plugin
     */
    public static void setPlugin(BentoBox p) {
        plugin = p;
    }
    public Set<PermissionAttachmentInfo> getEffectivePermissions() {
        return sender.getEffectivePermissions();
    }
    /**
     * Get the user's inventory
     * 
     * @return player's inventory
     */
    @NonNull
    public PlayerInventory getInventory() {
        return Objects.requireNonNull(player, "getInventory can only be called for online players!").getInventory();
    }
    /**
     * Get the user's location
     * 
     * @return location
     */
    @NonNull
    public Location getLocation() {
        return Objects.requireNonNull(player, "getLocation can only be called for online players!").getLocation();
    }
    /**
     * Get the user's name
     * 
     * @return player's name
     */
    @NonNull
    public String getName() {
        return player != null ? player.getName() : plugin.getPlayers().getName(playerUUID);
    }
    /**
     * Get the user's display name
     * 
     * @return player's display name if the player is online otherwise just their
     *         name
     * @since 1.22.1
     */
    @NonNull
    public String getDisplayName() {
        return player != null ? player.getDisplayName() : plugin.getPlayers().getName(playerUUID);
    }
    /**
     * Check if the User is a player before calling this method. {@link #isPlayer()}
     * 
     * @return the player
     */
    @NonNull
    public Player getPlayer() {
        return Objects.requireNonNull(player, "User is not a player!");
    }
    /**
     * @return true if this user is a player, false if not, e.g., console
     */
    public boolean isPlayer() {
        return player != null;
    }
    /**
     * Use {@link #isOfflinePlayer()} before calling this method
     * 
     * @return the offline player
     * @since 1.3.0
     */
    @NonNull
    public OfflinePlayer getOfflinePlayer() {
        return Objects.requireNonNull(offlinePlayer, "User is not an OfflinePlayer!");
    }
    /**
     * @return true if this user is an OfflinePlayer, false if not, e.g., console
     * @since 1.3.0
     */
    public boolean isOfflinePlayer() {
        return offlinePlayer != null;
    }
    @Nullable
    public CommandSender getSender() {
        return sender;
    }
    public UUID getUniqueId() {
        return playerUUID;
    }
    /**
     * @param permission permission string
     * @return true if permission is empty or null or if the player has that
     *         permission or if the player is op.
     */
    public boolean hasPermission(@Nullable String permission) {
        return permission == null || permission.isEmpty() || isOp() || sender.hasPermission(permission);
    }
    /**
     * Removes permission from user
     * 
     * @param name - Name of the permission to remove
     * @return true if successful
     * @since 1.5.0
     */
    public boolean removePerm(String name) {
        for (PermissionAttachmentInfo p : player.getEffectivePermissions()) {
            if (p.getPermission().equals(name) && p.getAttachment() != null) {
                player.removeAttachment(p.getAttachment());
                break;
            }
        }
        player.recalculatePermissions();
        return !player.hasPermission(name);
    }
    /**
     * Add a permission to user
     * 
     * @param name - Name of the permission to attach
     * @return The PermissionAttachment that was just created
     * @since 1.5.0
     */
    public PermissionAttachment addPerm(String name) {
        return player.addAttachment(plugin, name, true);
    }
    public boolean isOnline() {
        return player != null && player.isOnline();
    }
    /**
     * Checks if user is Op
     * 
     * @return true if user is Op
     */
    public boolean isOp() {
        if (sender != null) {
            return sender.isOp();
        }
        if (playerUUID != null && offlinePlayer != null) {
            return offlinePlayer.isOp();
        }
        return false;
    }
    /**
     * Get the maximum value of a numerical permission setting. If a player is given
     * an explicit negative number then this is treated as "unlimited" and returned
     * immediately.
     * 
     * @param permissionPrefix the start of the perm, e.g.,
     *                         {@code plugin.mypermission}
     * @param defaultValue     the default value; the result may be higher or lower
     *                         than this
     * @return max value
     */
    public int getPermissionValue(String permissionPrefix, int defaultValue) {
        // If requester is console, then return the default value
        if (!isPlayer())
            return defaultValue;
        // If there is a dot at the end of the permissionPrefix, remove it
        if (permissionPrefix.endsWith(".")) {
            permissionPrefix = permissionPrefix.substring(0, permissionPrefix.length() - 1);
        }
        final String permPrefix = permissionPrefix + ".";
        List<String> permissions = player.getEffectivePermissions().stream().filter(PermissionAttachmentInfo::getValue) // Must
                // be
                // a
                // positive
                // permission,
                // not
                // a
                // negative
                // one
                .map(PermissionAttachmentInfo::getPermission).filter(permission -> permission.startsWith(permPrefix))
                .toList();
        if (permissions.isEmpty())
            return defaultValue;
        return iteratePerms(permissions, permPrefix, defaultValue);
    }
    private int iteratePerms(List<String> permissions, String permPrefix, int defaultValue) {
        int value = 0;
        for (String permission : permissions) {
            if (permission.contains(permPrefix + "*")) {
                // 'Star' permission
                return defaultValue;
            } else {
                String[] spl = permission.split(permPrefix);
                if (spl.length > 1) {
                    if (!NumberUtils.isNumber(spl[1])) {
                        plugin.logError("Player " + player.getName() + " has permission: '" + permission
                                + "' <-- the last part MUST be a number! Ignoring...");
                    } else {
                        int v = Integer.parseInt(spl[1]);
                        if (v < 0) {
                            return v;
                        }
                        value = Math.max(value, v);
                    }
                }
            }
        }
        return value;
    }
    /**
     * Gets a translation for a specific world
     * 
     * @param world     - world of translation
     * @param reference - reference found in a locale file
     * @param variables - variables to insert into translated string. Variables go
     *                  in pairs, for example "[name]", "tastybento"
     * @return Translated string with colors converted, or the reference if nothing
     *         has been found
     * @since 1.3.0
     */
    public String getTranslation(World world, String reference, String... variables) {
        // Get translation.
        String addonPrefix = plugin.getIWM().getAddon(world)
                .map(a -> a.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".").orElse("");
        return Util.translateColorCodes(translate(addonPrefix, reference, variables));
    }
    /**
     * Gets a translation of this reference for this user with colors converted.
     * Translations may be overridden by Addons by using the same reference prefixed
     * by the addon name (from the Addon Description) in lower case.
     * 
     * @param reference - reference found in a locale file
     * @param variables - variables to insert into translated string. Variables go
     *                  in pairs, for example "[name]", "tastybento"
     * @return Translated string with colors converted, or the reference if nothing
     *         has been found
     */
    public String getTranslation(String reference, String... variables) {
        // Get addonPrefix
        String addonPrefix = addon == null ? "" : addon.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".";
        return Util.translateColorCodes(translate(addonPrefix, reference, variables));
    }
    /**
     * Gets a translation of this reference for this user without colors translated.
     * Translations may be overridden by Addons by using the same reference prefixed
     * by the addon name (from the Addon Description) in lower case.
     * 
     * @param reference - reference found in a locale file
     * @param variables - variables to insert into translated string. Variables go
     *                  in pairs, for example "[name]", "tastybento"
     * @return Translated string or the reference if nothing has been found
     * @since 1.17.4
     */
    public String getTranslationNoColor(String reference, String... variables) {
        // Get addonPrefix
        String addonPrefix = addon == null ? "" : addon.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".";
        return translate(addonPrefix, reference, variables);
    }
    private String translate(String addonPrefix, String reference, String[] variables) {
        // Try to get the translation for this specific addon
        String translation = plugin.getLocalesManager().get(this, addonPrefix + reference);
        if (translation == null) {
            // No luck, try to get the generic translation
            translation = plugin.getLocalesManager().get(this, reference);
            if (translation == null) {
                // Nothing found. Replace vars (probably will do nothing) and return
                return replaceVars(reference, variables);
            }
        }
        // If this is a prefix, just gather and return the translation
        if (!reference.startsWith("prefixes.")) {
            // Replace the prefixes
            return replacePrefixes(translation, variables);
        }
        return translation;
    }
    private String replacePrefixes(String translation, String[] variables) {
        for (String prefix : plugin.getLocalesManager().getAvailablePrefixes(this)) {
            String prefixTranslation = getTranslation("prefixes." + prefix);
            // Replace the prefix in the actual message
            translation = translation.replace("[prefix_" + prefix + "]", prefixTranslation);
        }
        // Then replace variables
        if (variables.length > 1) {
            for (int i = 0; i < variables.length; i += 2) {
                // Prevent a NPE if the substituting variable is null
                if (variables[i + 1] != null) {
                    translation = translation.replace(variables[i], variables[i + 1]);
                }
            }
        }
        // Then replace Placeholders, this will only work if this is a player
        if (player != null) {
            translation = plugin.getPlaceholdersManager().replacePlaceholders(player, translation);
        }
        // Replace game mode and friendly name in general
        // Replace the [gamemode] text variable
        if (addon != null && addon.getDescription() != null) {
            translation = translation.replace("[gamemode]", addon.getDescription().getName());
        }
        if (player != null && player.getWorld() != null) {
            // Replace the [friendly_name] text variable
            translation = translation.replace("[friendly_name]",
                    isPlayer() ? plugin.getIWM().getFriendlyName(getWorld()) : "[friendly_name]");
        }
        return translation;
    }
    private String replaceVars(String reference, String[] variables) {
        // Then replace variables
        if (variables.length > 1) {
            for (int i = 0; i < variables.length; i += 2) {
                reference = reference.replace(variables[i], variables[i + 1]);
            }
        }
        // Then replace Placeholders, this will only work if this is a player
        if (player != null) {
            reference = plugin.getPlaceholdersManager().replacePlaceholders(player, reference);
        }
        // If no translation has been found, return the reference for debug purposes.
        return reference;
    }
    /**
     * Gets a translation of this reference for this user.
     * 
     * @param reference - reference found in a locale file
     * @param variables - variables to insert into translated string. Variables go
     *                  in pairs, for example "[name]", "tastybento"
     * @return Translated string with colors converted, or a blank String if nothing
     *         has been found
     */
    public String getTranslationOrNothing(String reference, String... variables) {
        String translation = getTranslation(reference, variables);
        return translation.equals(reference) ? "" : translation;
    }
    /**
     * Send a message to sender if message is not empty.
     * 
     * @param reference - language file reference
     * @param variables - CharSequence target, replacement pairs
     */
    public void sendMessage(String reference, String... variables) {
        String message = getTranslation(reference, variables);
        if (!ChatColor.stripColor(message).trim().isEmpty()) {
            sendRawMessage(message);
        }
    }
    /**
     * Sends a raw message to the sender, parsing inline commands embedded within square brackets.
     * <p>
     * The method supports embedding clickable and hoverable actions into the message text using inline commands.
     * Recognized commands are:
     * <ul>
     *   <li><code>[run_command: &lt;command&gt;]</code> - Runs the specified command when the message is clicked.</li>
     *   <li><code>[suggest_command: &lt;command&gt;]</code> - Suggests the specified command in the chat input.</li>
     *   <li><code>[copy_to_clipboard: &lt;text&gt;]</code> - Copies the specified text to the player's clipboard.</li>
     *   <li><code>[open_url: &lt;url&gt;]</code> - Opens the specified URL when the message is clicked.</li>
     *   <li><code>[hover: &lt;text&gt;]</code> - Shows the specified text when the message is hovered over.</li>
     * </ul>
     * <p>
     * The commands can be placed anywhere in the message and will apply to the entire message component.
     * If multiple commands of the same type are provided, only the first one encountered will be applied.
     * Unrecognized or invalid commands enclosed in square brackets will be preserved in the output text.
     * <p>
     * Example usage:
     * <pre>
     * sendRawMessage("Hello [not-a-command: hello][run_command: /help] World [hover: This is a hover text]");
     * </pre>
     * The above message will display "Hello [not-a-command: hello] World" where clicking the message runs the "/help" command,
     * and hovering over the message shows "This is a hover text".
     *
     * @param message The message to send, containing inline commands in square brackets.
     */
    public void sendRawMessage(String message) {
        // Create a base TextComponent for the message
        TextComponent baseComponent = new TextComponent();
        // Regex to find inline commands like [run_command: /help] and [hover: click for help!], or unrecognized commands
        Pattern pattern = Pattern.compile("\\[(\\w+): ([^\\]]+)]|\\[\\[(.*?)\\]]");
        Matcher matcher = pattern.matcher(message);
        // Keep track of the current position in the message
        int lastMatchEnd = 0;
        ClickEvent clickEvent = null;
        HoverEvent hoverEvent = null;
        while (matcher.find()) {
            // Add any text before the current match
            if (matcher.start() > lastMatchEnd) {
                String beforeMatch = message.substring(lastMatchEnd, matcher.start());
                baseComponent.addExtra(TextComponent.fromLegacy(beforeMatch));
            }
            // Check if it's a recognized command or an unknown bracketed text
            if (matcher.group(1) != null && matcher.group(2) != null) {
                // Parse the inline command (action) and value
                String actionType = matcher.group(1).toUpperCase(Locale.ENGLISH); // e.g., RUN_COMMAND, HOVER
                String actionValue = matcher.group(2); // The command or text to display
                // Apply the first valid click event or hover event encountered
                switch (actionType) {
                    case "RUN_COMMAND":
                    case "SUGGEST_COMMAND":
                    case "COPY_TO_CLIPBOARD":
                    case "OPEN_URL":
                        if (clickEvent == null) {
                            clickEvent = new ClickEvent(ClickEvent.Action.valueOf(actionType), actionValue);
                        }
                        break;
                    case "HOVER":
                        if (hoverEvent == null) {
                            hoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, new Text(actionValue));
                        }
                        break;
                    default:
                        // Unrecognized command; preserve it in the output text
                        baseComponent.addExtra(TextComponent.fromLegacy(matcher.group(0)));
                }
            } else if (matcher.group(3) != null) {
                // Unrecognized bracketed text; preserve it in the output
                baseComponent.addExtra(TextComponent.fromLegacy("[[" + matcher.group(3) + "]]"));
            }
            // Update the last match end position
            lastMatchEnd = matcher.end();
        }
        // Add any remaining text after the last match
        if (lastMatchEnd < message.length()) {
            String remainingText = message.substring(lastMatchEnd);
            baseComponent.addExtra(TextComponent.fromLegacy(remainingText));
        }
        // Apply the first encountered ClickEvent and HoverEvent to the entire message
        if (clickEvent != null) {
            baseComponent.setClickEvent(clickEvent);
        }
        if (hoverEvent != null) {
            baseComponent.setHoverEvent(hoverEvent);
        }
        // Send the final component to the sender
        if (sender != null) {
            sender.spigot().sendMessage(baseComponent);
        } else {
            // Handle offline player messaging or alternative actions
            Bukkit.getPluginManager().callEvent(new OfflineMessageEvent(this.playerUUID, message));
        }
    }
    /**
     * Sends a message to sender if message is not empty and if the same wasn't sent
     * within the previous Notifier.NOTIFICATION_DELAY seconds.
     * 
     * @param reference - language file reference
     * @param variables - CharSequence target, replacement pairs
     *
     * @see Notifier
     */
    public void notify(String reference, String... variables) {
        String message = getTranslation(reference, variables);
        if (!ChatColor.stripColor(message).trim().isEmpty() && sender != null) {
            plugin.getNotifier().notify(this, message);
        }
    }
    /**
     * Sends a message to sender if message is not empty and if the same wasn't sent
     * within the previous Notifier.NOTIFICATION_DELAY seconds.
     * 
     * @param world     - the world the translation should come from
     * @param reference - language file reference
     * @param variables - CharSequence target, replacement pairs
     *
     * @see Notifier
     * @since 1.3.0
     */
    public void notify(World world, String reference, String... variables) {
        String message = getTranslation(world, reference, variables);
        if (!ChatColor.stripColor(message).trim().isEmpty() && sender != null) {
            plugin.getNotifier().notify(this, message);
        }
    }
    /**
     * Sets the user's game mode
     * 
     * @param mode - GameMode
     */
    public void setGameMode(GameMode mode) {
        player.setGameMode(mode);
    }
    /**
     * Teleports user to this location. If the user is in a vehicle, they will exit
     * first.
     * 
     * @param location - the location
     */
    public void teleport(Location location) {
        player.teleport(location);
    }
    /**
     * Gets the current world this entity resides in
     * 
     * @return World - world
     */
    @NonNull
    public World getWorld() {
        Objects.requireNonNull(player, "Cannot be called on a non-player User!");
        return Objects.requireNonNull(player.getWorld(), "Player's world cannot be null!");
    }
    /**
     * Closes the user's inventory
     */
    public void closeInventory() {
        player.closeInventory();
    }
    /**
     * Get the user's locale
     * 
     * @return Locale
     */
    public Locale getLocale() {
        if (sender instanceof Player && !plugin.getPlayers().getLocale(playerUUID).isEmpty()) {
            return Locale.forLanguageTag(plugin.getPlayers().getLocale(playerUUID));
        }
        return Locale.forLanguageTag(plugin.getSettings().getDefaultLanguage());
    }
    /**
     * Forces an update of the user's complete inventory. Deprecated, but there is
     * no current alternative.
     */
    public void updateInventory() {
        player.updateInventory();
    }
    /**
     * Performs a command as the player
     * 
     * @param command - command to execute
     * @return true if the command was successful, otherwise false
     */
    public boolean performCommand(String command) {
        PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(getPlayer(), command);
        Bukkit.getPluginManager().callEvent(event);
        // only perform the command, if the event wasn't cancelled by an other plugin:
        if (!event.isCancelled()) {
            return getPlayer().performCommand(
                    event.getMessage().startsWith("/") ? event.getMessage().substring(1) : event.getMessage());
        }
        // Cancelled, but it was recognized, so return true
        return true;
    }
    /**
     * Checks if a user is in one of the game worlds
     * 
     * @return true if user is, false if not
     */
    public boolean inWorld() {
        return plugin.getIWM().inWorld(getLocation());
    }
    /**
     * Spawn particles to the player. They are only displayed if they are within the
     * server's view distance.
     * 
     * @param particle    Particle to display.
     * @param dustOptions Particle.DustOptions for the particle to display.
     * @param x           X coordinate of the particle to display.
     * @param y           Y coordinate of the particle to display.
     * @param z           Z coordinate of the particle to display.
     */
    public void spawnParticle(Particle particle, @Nullable Object dustOptions, double x, double y, double z) {
        Class<?> expectedClass = VALIDATION_CHECK.get(particle);
        if (expectedClass == null)
            throw new IllegalArgumentException("Unexpected value: " + particle);
        if (!(expectedClass.isInstance(dustOptions))) {
            throw new IllegalArgumentException("A non-null " + expectedClass.getSimpleName()
                    + " must be provided when using Particle." + particle + " as particle.");
        }
        // Check if this particle is beyond the viewing distance of the server
        if (this.player != null && this.player.getLocation().toVector().distanceSquared(new Vector(x, y,
                z)) < (Bukkit.getServer().getViewDistance() * 256 * Bukkit.getServer().getViewDistance())) {
            if (particle.equals(Enums.getIfPresent(Particle.class, "DUST")
                    .or(Enums.getIfPresent(Particle.class, "REDSTONE").or(Particle.FLAME)))) {
                player.spawnParticle(particle, x, y, z, 1, 0, 0, 0, 1, dustOptions);
            } else if (dustOptions != null) {
                player.spawnParticle(particle, x, y, z, 1, dustOptions);
            } else {
                // This will never be called unless the value in VALIDATION_CHECK is null in the
                // future
                player.spawnParticle(particle, x, y, z, 1);
            }
        }
    }
    /**
     * Spawn particles to the player. They are only displayed if they are within the
     * server's view distance. Compatibility method for older usages.
     * 
     * @param particle    Particle to display.
     * @param dustOptions Particle.DustOptions for the particle to display.
     * @param x           X coordinate of the particle to display.
     * @param y           Y coordinate of the particle to display.
     * @param z           Z coordinate of the particle to display.
     */
    public void spawnParticle(Particle particle, Particle.DustOptions dustOptions, double x, double y, double z) {
        this.spawnParticle(particle, (Object) dustOptions, x, y, z);
    }
    /**
     * Spawn particles to the player. They are only displayed if they are within the
     * server's view distance.
     * 
     * @param particle    Particle to display.
     * @param dustOptions Particle.DustOptions for the particle to display.
     * @param x           X coordinate of the particle to display.
     * @param y           Y coordinate of the particle to display.
     * @param z           Z coordinate of the particle to display.
     */
    public void spawnParticle(Particle particle, Particle.DustOptions dustOptions, int x, int y, int z) {
        this.spawnParticle(particle, dustOptions, (double) x, (double) y, (double) z);
    }
    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((playerUUID == null) ? 0 : playerUUID.hashCode());
        return result;
    }
    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof User other)) {
            return false;
        }
        if (playerUUID == null) {
            return other.playerUUID == null;
        } else
            return playerUUID.equals(other.playerUUID);
    }
    /**
     * Set the addon context when a command is executed
     * 
     * @param addon - the addon executing the command
     */
    public void setAddon(Addon addon) {
        this.addon = addon;
    }
    /**
     * Get all the meta data for this user
     * 
     * @return the metaData
     * @since 1.15.4
     */
    @Override
    public Optional<Map<String, MetaDataValue>> getMetaData() {
        Players p = plugin.getPlayers().getPlayer(playerUUID);
        return Objects.requireNonNull(p, "Unknown player for " + playerUUID).getMetaData();
    }
    /**
     * @param metaData the metaData to set
     * @since 1.15.4
     */
    @Override
    public void setMetaData(Map<String, MetaDataValue> metaData) {
        Players p = plugin.getPlayers().getPlayer(playerUUID);
        Objects.requireNonNull(p, "Unknown player for " + playerUUID).setMetaData(metaData);
    }
}
package world.bentobox.bentobox;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Optional;
import org.apache.commons.lang.exception.ExceptionUtils;
import org.bukkit.Bukkit;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.server.ServerCommandEvent;
import org.bukkit.generator.ChunkGenerator;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitTask;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.api.configuration.Config;
import world.bentobox.bentobox.api.events.BentoBoxReadyEvent;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.Notifier;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.commands.BentoBoxCommand;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.hooks.FancyNpcsHook;
import world.bentobox.bentobox.hooks.ItemsAdderHook;
import world.bentobox.bentobox.hooks.MultipaperHook;
import world.bentobox.bentobox.hooks.MultiverseCoreHook;
import world.bentobox.bentobox.hooks.MyWorldsHook;
import world.bentobox.bentobox.hooks.MythicMobsHook;
import world.bentobox.bentobox.hooks.SlimefunHook;
import world.bentobox.bentobox.hooks.VaultHook;
import world.bentobox.bentobox.hooks.ZNPCsPlusHook;
import world.bentobox.bentobox.hooks.placeholders.PlaceholderAPIHook;
import world.bentobox.bentobox.listeners.BannedCommands;
import world.bentobox.bentobox.listeners.BlockEndDragon;
import world.bentobox.bentobox.listeners.DeathListener;
import world.bentobox.bentobox.listeners.JoinLeaveListener;
import world.bentobox.bentobox.listeners.PanelListenerManager;
import world.bentobox.bentobox.listeners.PrimaryIslandListener;
import world.bentobox.bentobox.listeners.SeedWorldMakerListener;
import world.bentobox.bentobox.listeners.StandardSpawnProtectionListener;
import world.bentobox.bentobox.listeners.teleports.EntityTeleportListener;
import world.bentobox.bentobox.listeners.teleports.PlayerTeleportListener;
import world.bentobox.bentobox.managers.AddonsManager;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.managers.CommandsManager;
import world.bentobox.bentobox.managers.FlagsManager;
import world.bentobox.bentobox.managers.HooksManager;
import world.bentobox.bentobox.managers.IslandDeletionManager;
import world.bentobox.bentobox.managers.IslandWorldManager;
import world.bentobox.bentobox.managers.IslandsManager;
import world.bentobox.bentobox.managers.LocalesManager;
import world.bentobox.bentobox.managers.PlaceholdersManager;
import world.bentobox.bentobox.managers.PlayersManager;
import world.bentobox.bentobox.managers.RanksManager;
import world.bentobox.bentobox.managers.WebManager;
import world.bentobox.bentobox.util.heads.HeadGetter;
import world.bentobox.bentobox.versions.ServerCompatibility;
/**
 * Main BentoBox class
 * @author tastybento, Poslovitch
 */
public class BentoBox extends JavaPlugin implements Listener {
    private static BentoBox instance;
    // Databases
    private PlayersManager playersManager;
    private IslandsManager islandsManager;
    // Managers
    private CommandsManager commandsManager;
    private LocalesManager localesManager;
    private AddonsManager addonsManager;
    private FlagsManager flagsManager;
    private IslandWorldManager islandWorldManager;
    private BlueprintsManager blueprintsManager;
    private HooksManager hooksManager;
    private PlaceholdersManager placeholdersManager;
    private IslandDeletionManager islandDeletionManager;
    private WebManager webManager;
    // Settings
    private Settings settings;
    // Notifier
    private Notifier notifier;
    private HeadGetter headGetter;
    private boolean isLoaded;
    // Metrics
    @Nullable
    private BStats metrics;
    private Config<Settings> configObject;
    private BukkitTask blueprintLoadingTask;
    private boolean shutdown;
    @Override
    public void onEnable(){
        setInstance(this);
        if (!ServerCompatibility.getInstance().checkCompatibility().isCanLaunch()) {
            // The server's most likely incompatible.
            // Show a warning
            logWarning("************ Disclaimer **************");
            logWarning("BentoBox may not be compatible with this server!");
            logWarning("BentoBox is tested only on the following Spigot versions:");
            List<String> versions = ServerCompatibility.ServerVersion.getVersions(ServerCompatibility.Compatibility.COMPATIBLE, ServerCompatibility.Compatibility.SUPPORTED)
                    .stream().map(ServerCompatibility.ServerVersion::toString).toList();
            logWarning(String.join(", ", versions));
            logWarning("**************************************");
        }
        // Not loaded
        isLoaded = false;
        // Store the current millis time so we can tell how many ms it took for BSB to fully load.
        final long loadStart = System.currentTimeMillis();
        // Save the default config from config.yml
        saveDefaultConfig();
        // Load Flags
        flagsManager = new FlagsManager(this);
        if (!loadSettings()) {
            // We're aborting the load.
            return;
        }
        // Saving the config now.
        saveConfig();
        // Start Database managers
        playersManager = new PlayersManager(this);
        // Check if this plugin is now disabled (due to bad database handling)
        if (!this.isEnabled()) {
            return;
        }
        islandsManager = new IslandsManager(this);
        // Start head getter
        headGetter = new HeadGetter(this);
        // Load Notifier
        notifier = new Notifier();
        // Set up command manager
        commandsManager = new CommandsManager();
        // Load BentoBox commands
        new BentoBoxCommand();
        // Start Island Worlds Manager
        islandWorldManager = new IslandWorldManager(this);
        // Load blueprints manager
        blueprintsManager = new BlueprintsManager(this);
        // Locales manager must be loaded before addons
        localesManager = new LocalesManager(this);
        // Load hooks
        hooksManager = new HooksManager(this);
        // Load addons. Addons may load worlds, so they must go before islands are loaded.
        addonsManager = new AddonsManager(this);
        addonsManager.loadAddons();
        final long loadTime = System.currentTimeMillis() - loadStart;
        Bukkit.getScheduler().runTask(instance, () -> {
            try {
                completeSetup(loadTime);
            } catch (Exception e) {
                fireCriticalError(e.getMessage(), "");
                e.printStackTrace();
            }
        });
    }
    private void completeSetup(long loadTime) {
        final long enableStart = System.currentTimeMillis();
        hooksManager.registerHook(new MultipaperHook());
        hooksManager.registerHook(new VaultHook());
        // FancyNpcs
        hooksManager.registerHook(new FancyNpcsHook());
        // ZNPCsPlus
        hooksManager.registerHook(new ZNPCsPlusHook());
        // MythicMobs
        hooksManager.registerHook(new MythicMobsHook());
        hooksManager.registerHook(new PlaceholderAPIHook());
        // Setup the Placeholders manager
        placeholdersManager = new PlaceholdersManager(this);
        // Enable addons
        addonsManager.enableAddons();
        // Register default gamemode placeholders
        addonsManager.getGameModeAddons().forEach(placeholdersManager::registerDefaultPlaceholders);
        // Register Listeners
        registerListeners();
        // Load islands from database - need to wait until all the worlds are loaded
        log("Loading islands from database...");
        try {
            islandsManager.load();
        } catch (Exception e) {
            fireCriticalError(e.getMessage(), "Could not load islands!");
            return;
        }
        // Make sure all flag listeners are registered.
        flagsManager.registerListeners();
        // Load metrics
        metrics = new BStats(this);
        metrics.registerMetrics();
        // Register Multiverse hook - MV loads AFTER BentoBox
        // Make sure all worlds are already registered to Multiverse.
        hooksManager.registerHook(new MultiverseCoreHook());
        hooksManager.registerHook(new MyWorldsHook());
        islandWorldManager.registerWorldsToMultiverse(true);
        // Register Slimefun
        hooksManager.registerHook(new SlimefunHook());
        // Register ItemsAdder
        hooksManager.registerHook(new ItemsAdderHook(this));
        // TODO: re-enable after implementation
        //hooksManager.registerHook(new DynmapHook());
        // TODO: re-enable after rework
        //hooksManager.registerHook(new LangUtilsHook());
        webManager = new WebManager(this);
        final long enableTime = System.currentTimeMillis() - enableStart;
        // Show banner
        User.getInstance(Bukkit.getConsoleSender()).sendMessage("successfully-loaded",
                TextVariables.VERSION, instance.getDescription().getVersion(),
                "[time]", String.valueOf(loadTime + enableTime));
        // Poll for blueprints loading to be finished - async so could be a completely variable time
        blueprintLoadingTask = Bukkit.getScheduler().runTaskTimer(instance, () -> {
            if (getBlueprintsManager().isBlueprintsLoaded()) {
                blueprintLoadingTask.cancel();
                // Tell all addons that everything is loaded
                isLoaded = true;
                this.addonsManager.allLoaded();
                // Run ready commands
                settings.getReadyCommands().forEach(cmd -> Bukkit.getServer().dispatchCommand(getServer().getConsoleSender(), cmd));
                // Fire plugin ready event - this should go last after everything else
                Bukkit.getPluginManager().callEvent(new BentoBoxReadyEvent());
                instance.log("All blueprints loaded.");
            }
        }, 0L, 1L);
        if (getSettings().getDatabaseType().equals(DatabaseSetup.DatabaseType.YAML)) {
            logWarning("*** You're still using YAML database ! ***");
            logWarning("This database type is being deprecated from BentoBox as some official addons encountered difficulties supporting it correctly.");
            logWarning("You should switch ASAP to an alternative database type. Please refer to the comments in BentoBox's config.yml.");
            logWarning("There is NO guarantee YAML database will remain properly supported in the following updates, and its usage should as such be considered a non-viable situation.");
            logWarning("*** *** *** *** *** *** *** *** *** *** ***");
        }
    }
    private void fireCriticalError(String message, String error) {
        logError("*****************CRITICAL ERROR!******************");
        logError(message);
        logError(error + " Disabling BentoBox...");
        logError("*************************************************");
        // Stop all addons
        if (addonsManager != null) {
            addonsManager.disableAddons();
        }
        // Do not save players or islands, just shutdown
        shutdown = true;
        instance.setEnabled(false);
    }
    /**
     * Registers listeners.
     */
    private void registerListeners() {
        PluginManager manager = getServer().getPluginManager();
        // Player join events
        manager.registerEvents(new JoinLeaveListener(this), this);
        // Panel listener manager
        manager.registerEvents(new PanelListenerManager(), this);
        // Standard Nether/End spawns protection
        manager.registerEvents(new StandardSpawnProtectionListener(this), this);
        // Player portals
        manager.registerEvents(new PlayerTeleportListener(this), this);
        // Entity portals
        manager.registerEvents(new EntityTeleportListener(this), this);
        // End dragon blocking
        manager.registerEvents(new BlockEndDragon(this), this);
        // Banned visitor commands
        manager.registerEvents(new BannedCommands(this), this);
        // Death counter
        manager.registerEvents(new DeathListener(this), this);
        // MV unregister
        manager.registerEvents(this, this);
        // Island Delete Manager
        islandDeletionManager = new IslandDeletionManager(this);
        manager.registerEvents(islandDeletionManager, this);
        // Primary Island Listener
        manager.registerEvents(new PrimaryIslandListener(this), this);
        // Seed world chunk generator
        manager.registerEvents(new SeedWorldMakerListener(this), this);
    }
    @Override
    public void onDisable() {
        // Stop all async database tasks
        shutdown = true;
        HeadGetter.shutdown();
        if (addonsManager != null) {
            addonsManager.disableAddons();
        }
        // Save data
        if (playersManager != null) {
            playersManager.shutdown();
        }
        if (islandsManager != null) {
            islandsManager.shutdown();
        }
    }
    @EventHandler
    public void onServerStop(ServerCommandEvent e) {
        /* This is no longer needed as with https://github.com/Multiverse/Multiverse-Core/releases/tag/4.3.12 (or maybe earlier) the issue
         * is fixed where the generator was not remembered across reboots.
         */
        /*
        if (islandWorldManager != null && (e.getCommand().equalsIgnoreCase("stop") || e.getCommand().equalsIgnoreCase("restart"))) {
            // Unregister any MV worlds            if () {
            //islandWorldManager.registerWorldsToMultiverse(false);
        }*/
    }
    /**
     * Returns the player manager
     * @return the player manager
     * @see #getPlayersManager()
     */
    public PlayersManager getPlayers() {
        return playersManager;
    }
    /**
     * Returns the player manager
     * @return the player manager
     * @see #getPlayers()
     * @since 1.16.0
     */
    public PlayersManager getPlayersManager() {
        return getPlayers();
    }
    /**
     * Returns the island manager
     * @return the island manager
     * @see #getIslandsManager()
     */
    public IslandsManager getIslands() {
        return islandsManager;
    }
    /**
     * Returns the island manager
     * @return the island manager
     * @see #getIslands()
     * @since 1.16.0
     */
    public IslandsManager getIslandsManager() {
        return getIslands();
    }
    private static void setInstance(BentoBox plugin) {
        BentoBox.instance = plugin;
    }
    public static BentoBox getInstance() {
        return instance;
    }
    /**
     * @return the Commands manager
     */
    public CommandsManager getCommandsManager() {
        return commandsManager;
    }
    /**
     * @return the Locales manager
     */
    public LocalesManager getLocalesManager() {
        return localesManager;
    }
    /**
     * @return the Addons manager
     */
    public AddonsManager getAddonsManager() {
        return addonsManager;
    }
    /**
     * @return the Flags manager
     */
    public FlagsManager getFlagsManager() {
        return flagsManager;
    }
    /**
     * @return the ranksManager
     * @deprecated Just use {@code RanksManager.getInstance()}
     */
    @Deprecated(since = "2.0.0", forRemoval = true)
    public RanksManager getRanksManager() {
        return RanksManager.getInstance();
    }
    /**
     * @return the Island World Manager
     */
    public IslandWorldManager getIWM() {
        return islandWorldManager;
    }
    /**
     * @return the settings
     */
    public Settings getSettings() {
        return settings;
    }
    /**
     * Loads the settings from the config file.
     * If it fails, it can shut the plugin down.
     * @return {@code true} if it loaded successfully.
     * @since 1.3.0
     */
    public boolean loadSettings() {
        log("Loading Settings from config.yml...");
        // Load settings from config.yml. This will check if there are any issues with it too.
        if (configObject == null) configObject = new Config<>(this, Settings.class);
        settings = configObject.loadConfigObject();
        if (settings == null) {
            // Settings did not load correctly. Disable plugin.
            logError("Settings did not load correctly - disabling plugin - please check config.yml");
            getPluginLoader().disablePlugin(this);
            return false;
        }
        log("Saving default panels...");
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "island_creation_panel.yml"))) {
            log("Saving default island_creation_panel...");
            this.saveResource("panels/island_creation_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "language_panel.yml"))) {
            log("Saving default language_panel...");
            this.saveResource("panels/language_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "island_homes_panel.yml"))) {
            log("Saving default island_homes_panel...");
            this.saveResource("panels/island_homes_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "team_invite_panel.yml"))) {
            log("Saving default team_invite_panel...");
            this.saveResource("panels/team_invite_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "team_panel.yml"))) {
            log("Saving default team_panel...");
            this.saveResource("panels/team_panel.yml", false);
        }
        return true;
    }
    @Override
    public void saveConfig() {
        if (settings != null) configObject.saveConfigObject(settings);
    }
    /**
     * @return the notifier
     */
    public Notifier getNotifier() {
        return notifier;
    }
    /**
     * @return the headGetter
     */
    public HeadGetter getHeadGetter() {
        return headGetter;
    }
    public void log(String string) {
        getLogger().info(() -> string);
    }
    public void logDebug(Object object) {
        getLogger().info(() -> "DEBUG: " + object);
    }
    public void logError(String error) {
        getLogger().severe(() -> error);
    }
    /**
     * Logs the stacktrace of a Throwable that was thrown by an error.
     * It should be used preferably instead of {@link Throwable#printStackTrace()} as it does not risk exposing sensitive information.
     * @param throwable the Throwable that was thrown by an error.
     * @since 1.3.0
     */
    public void logStacktrace(@NonNull Throwable throwable) {
        logError(ExceptionUtils.getStackTrace(throwable));
    }
    public void logWarning(String warning) {
        getLogger().warning(() -> warning);
    }
    /**
     * Returns the instance of the {@link BlueprintsManager}.
     * @return the {@link BlueprintsManager}.
     * @since 1.5.0
     */
    public BlueprintsManager getBlueprintsManager() {
        return blueprintsManager;
    }
    /**
     * Returns whether BentoBox is fully loaded or not.
     * This basically means that all managers are instantiated and can therefore be safely accessed.
     * @return whether BentoBox is fully loaded or not.
     */
    public boolean isLoaded() {
        return isLoaded;
    }
    /**
     * @return the HooksManager
     */
    public HooksManager getHooks() {
        return hooksManager;
    }
    /**
     * Convenience method to get the VaultHook.
     * @return the Vault hook
     */
    public Optional<VaultHook> getVault() {
        return Optional.ofNullable((VaultHook) hooksManager.getHook("Vault").orElse(null));
    }
    /**
     * @return the PlaceholdersManager.
     */
    public PlaceholdersManager getPlaceholdersManager() {
        return placeholdersManager;
    }
    /**
     * @return the islandDeletionManager
     * @since 1.1
     */
    public IslandDeletionManager getIslandDeletionManager() {
        return islandDeletionManager;
    }
    /**
     * @return an optional of the Bstats instance
     * @since 1.1
     */
    @NonNull
    public Optional<BStats> getMetrics() {
        return Optional.ofNullable(metrics);
    }
    /**
     * @return the {@link WebManager}.
     * @since 1.5.0
     */
    public WebManager getWebManager() {
        return webManager;
    }
    // Overriding default JavaPlugin methods
    /* (non-Javadoc)
     * @see org.bukkit.plugin.java.JavaPlugin#getDefaultWorldGenerator(java.lang.String, java.lang.String)
     */
    @Override
    public ChunkGenerator getDefaultWorldGenerator(@NonNull String worldName, String id) {
        return addonsManager.getDefaultWorldGenerator(worldName, id);
    }
    /* (non-Javadoc)
     * @see org.bukkit.plugin.java.JavaPlugin#reloadConfig()
     */
    @Override
    public void reloadConfig() {
        loadSettings();
    }
    /**
     * Check if plug has shutdown. Used to close databases that are running async.
     * @return true if plugin has shutdown
     * @since 1.13.0
     */
    public boolean isShutdown() {
        return shutdown;
    }
}
package world.bentobox.bentobox.panels;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import org.bukkit.Material;
import org.bukkit.Sound;
import org.bukkit.World;
import org.bukkit.World.Environment;
import org.bukkit.conversations.Conversable;
import org.bukkit.conversations.ConversationFactory;
import org.bukkit.event.inventory.ClickType;
import org.eclipse.jdt.annotation.NonNull;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.panels.PanelItem;
import world.bentobox.bentobox.api.panels.builders.PanelBuilder;
import world.bentobox.bentobox.api.panels.builders.PanelItemBuilder;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.blueprints.conversation.DescriptionPrompt;
import world.bentobox.bentobox.blueprints.conversation.NameConversationPrefix;
import world.bentobox.bentobox.blueprints.conversation.NamePrompt;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBundle;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
/**
 * @author tastybento
 * @since 1.5.0
 */
public class BlueprintManagementPanel {
    private final BentoBox plugin;
    private final Blueprint normalBlueprint;
    private final Blueprint netherBlueprint;
    private final Blueprint endBlueprint;
    private final Map<Integer, World.Environment> slotToEnvironment;
    private final Map<World.Environment, Blueprint> environmentToBlueprint;
    private static final int MAX_WORLD_SLOT = 9;
    private static final int MIN_WORLD_SLOT = 0;
    public static final int MAX_BP_SLOT = 35;
    private static final String INSTRUCTION = "instruction";
    private Entry<Integer, Blueprint> selected;
    private final Map<Integer, Blueprint> blueprints = new HashMap<>();
    private final User user;
    private final GameModeAddon addon;
    /**
     * Class to display the Blueprint Management Panel
     * @param plugin - BentoBox
     * @param user - user to see the panel
     * @param addon - game mode addon requesting the panel
     */
    public BlueprintManagementPanel(@NonNull BentoBox plugin, @NonNull User user, @NonNull GameModeAddon addon) {
        this.plugin = plugin;
        this.user = user;
        this.addon = addon;
        normalBlueprint = new Blueprint().setIcon(Material.GREEN_STAINED_GLASS_PANE)
                .setName(user.getTranslation("general.worlds.overworld"))
                .setDescription(t(INSTRUCTION));
        netherBlueprint = new Blueprint().setIcon(Material.RED_STAINED_GLASS_PANE)
                .setName(user.getTranslation("general.worlds.nether"))
                .setDescription(t(INSTRUCTION));
        endBlueprint = new Blueprint().setIcon(Material.YELLOW_STAINED_GLASS_PANE)
                .setName(user.getTranslation("general.worlds.the-end"))
                .setDescription(t(INSTRUCTION));
        slotToEnvironment = Map.of(3, World.Environment.NORMAL, 5, World.Environment.NETHER, 7, World.Environment.THE_END);
        environmentToBlueprint = Map.of(World.Environment.NORMAL, normalBlueprint, World.Environment.NETHER, netherBlueprint, World.Environment.THE_END, endBlueprint);
    }
    /**
     * Translate "commands.admin.blueprint.management." + t reference
     * @param t - end of reference
     * @return translation
     */
    private String t(String t) {
        return user.getTranslation("commands.admin.blueprint.management." + t);
    }
    /**
     * Translate "commands.admin.blueprint.management." + t + vars reference
     * @param t end of reference
     * @param vars any other parameters
     * @return transmation
     */
    private String t(String t, String... vars) {
        return user.getTranslation("commands.admin.blueprint.management." + t, vars);
    }
    /**
     * Opens the management panel
     */
    public void openPanel() {
        // Show panel of blueprint bundles
        // Clicking on a bundle opens up the bundle edit panel
        // Create the panel
        PanelBuilder pb = new PanelBuilder().name(t("title")).user(user).size(45);
        // Panel has New Blueprint Bundle button - clicking in creates a new bundle
        pb.item(36, getNewBundle(addon));
        // Get the bundles
        Comparator<BlueprintBundle> sortByDisplayName = (p, o) -> p.getDisplayName().compareToIgnoreCase(o.getDisplayName());
        plugin.getBlueprintsManager().getBlueprintBundles(addon).values().stream().limit(36)
        .sorted(sortByDisplayName)
        .forEach(bb -> {
            // Make item
            PanelItem item = new PanelItemBuilder()
                    .name(bb.getDisplayName())
                    .description(t("edit"), t("rename"))
                    .icon(bb.getIcon())
                    .clickHandler((panel, u, clickType, slot) -> {
                        u.closeInventory();
                        if (clickType.equals(ClickType.RIGHT)) {
                            // Rename
                            askForName(u.getPlayer(), addon, bb);
                        } else {
                            openBB(bb);
                        }
                        return true;
                    })
                    .build();
            // Determine slot
            if (bb.getSlot() < 0 || bb.getSlot() > MAX_BP_SLOT) {
                bb.setSlot(0);
            }
            if (pb.slotOccupied(bb.getSlot())) {
                int slot = getFirstAvailableSlot(pb);
                if (slot == -1) {
                    // TODO add paging
                    plugin.logError("Too many blueprint bundles to show!");
                    pb.item(item);
                } else {
                    pb.item(slot, item);
                }
            } else {
                pb.item(bb.getSlot(), item);
            }
        });
        pb.build();
    }
    /**
     * @param pb - panel builder
     * @return first available slot, or -1 if none
     */
    private static int getFirstAvailableSlot(PanelBuilder pb) {
        for (int i = 0; i < BlueprintManagementPanel.MAX_BP_SLOT; i++) {
            if (!pb.slotOccupied(i)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Open the Blueprint Bundle panel
     * @param bb - blueprint bundle
     */
    public void openBB(BlueprintBundle bb) {
        int index = 18;
        for (Blueprint bp : plugin.getBlueprintsManager().getBlueprints(addon).values()) {
            blueprints.put(index++, bp);
        }
        // Create the panel
        PanelBuilder pb = new PanelBuilder().name(bb.getDisplayName()).user(user).size(45).listener(new IconChanger(plugin, addon, this, bb));
        // Display bundle icon
        pb.item(0, getBundleIcon(bb));
        slotToEnvironment.forEach((k, v) -> {
            String bpName = bb.getBlueprint(v);
            pb.item(k-1, getWorldInstrTile(v));
            pb.item(k, getBlueprintItem(addon, k, bb, plugin.getBlueprintsManager().getBlueprints(addon).getOrDefault(bpName, environmentToBlueprint.get(v))));
        });
        for (int i = 9; i < 18; i++) {
            pb.item(i, new PanelItemBuilder().icon(Material.BLACK_STAINED_GLASS_PANE).name(" ").build());
        }
        blueprints.entrySet().stream().limit(18).forEach(b -> pb.item(getBlueprintItem(addon, b.getKey(), bb, b.getValue())));
        // Buttons for non-default bundle
        if (bb.getUniqueId().equals(BlueprintsManager.DEFAULT_BUNDLE_NAME)) {
            // Panel has a No Trash icon. If right clicked it is discarded
            pb.item(36, getNoTrashIcon());
            // Toggle permission - default is always allowed
            pb.item(39, getNoPermissionIcon());
        } else {
            // Panel has a Trash icon. If right clicked it is discarded
            pb.item(36, getTrashIcon(addon, bb));
            // Toggle permission - default is always allowed
            pb.item(39, getPermissionIcon(addon, bb));
        }
        if (plugin.getSettings().getIslandNumber() > 1) {
            // Number of times allowed
            pb.item(42, getTimesIcon(bb));
        }
        // Preferred slot
        pb.item(40, getSlotIcon(addon, bb));
        // Panel has a Back icon.
        pb.item(44, new PanelItemBuilder().icon(Material.OAK_DOOR).name(t("back")).clickHandler((panel, u, clickType, slot) -> {
            openPanel();
            return true;
        }).build());
        pb.build();
    }
    private PanelItem getTimesIcon(BlueprintBundle bb) {
        return new PanelItemBuilder().icon(Material.CLOCK).name(t("times"))
                .description(bb.getTimes() == 0 ? t("unlimited-times")
                        : t("maximum-times", TextVariables.NUMBER, String.valueOf(bb.getTimes())))
                .clickHandler((panel, u, clickType, slot) -> {
                    // Left click up, right click down
                    u.getPlayer().playSound(u.getLocation(), Sound.UI_BUTTON_CLICK, 1F, 1F);
                    if (clickType == ClickType.LEFT) {
                        bb.setTimes(bb.getTimes() + 1);
                    } else if (clickType == ClickType.RIGHT && bb.getTimes() > 0) {
                        bb.setTimes(bb.getTimes() - 1);
                    }
                    // Save
                    plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                    panel.getInventory().setItem(42, getTimesIcon(bb).getItem());
                    return true;
                }).build();
    }
    /**
     * Gets the preferred slot icon
     * @param addon - addon
     * @param bb - blueprint bundle
     * @return slot panel item
     */
    private PanelItem getSlotIcon(GameModeAddon addon, BlueprintBundle bb) {
        return new PanelItemBuilder()
                .name(t("slot", TextVariables.NUMBER, String.valueOf(bb.getSlot())))
                .description(t("slot-instructions"))
                .icon(Material.IRON_TRAPDOOR)
                .clickHandler((panel, u, clickType, slot) -> {
                    // Increment or decrement slot
                    if (clickType.isLeftClick()) {
                        bb.setSlot(bb.getSlot() + 1);
                        if (bb.getSlot() > MAX_BP_SLOT) {
                            bb.setSlot(0);
                        }
                    } else if (clickType.isRightClick()) {
                        bb.setSlot(bb.getSlot() - 1);
                        if (bb.getSlot() < 0) {
                            bb.setSlot(MAX_BP_SLOT);
                        }
                    }
                    u.getPlayer().playSound(u.getLocation(), Sound.UI_BUTTON_CLICK, 1F, 1F);
                    // Save
                    plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                    panel.getInventory().setItem(40, getSlotIcon(addon, bb).getItem());
                    return true;
                })
                .build();
    }
    /**
     * Gets the panel item for Blueprint Bundle
     * @param bb - blueprint bundle
     * @return - panel item
     */
    protected PanelItem getBundleIcon(BlueprintBundle bb) {
        return new PanelItemBuilder()
                .name(t("edit-description"))
                .description(bb.getDescription().stream().map(Util::translateColorCodes).toList())
                .icon(bb.getIcon())
                .clickHandler((panel, u, clickType, slot) -> {
                    u.closeInventory();
                    // Description conversation
                    askForDescription(u.getPlayer(), addon, bb);
                    return true;
                })
                .build();
    }
    private PanelItem getWorldInstrTile(Environment env) {
        Material icon;
        String worldName;
        switch (env) {
        case NORMAL -> {
            icon = Material.GRASS_BLOCK;
            worldName = normalBlueprint.getName();
        }
        case NETHER -> {
            icon = Material.NETHERRACK;
            worldName = netherBlueprint.getName();
        }
        case THE_END -> {
            icon = Material.END_STONE;
            worldName = endBlueprint.getName();
        }
        default -> {
            icon = Material.STONE;
            worldName = Util.prettifyText(env.name());
        }
        }
        return new PanelItemBuilder()
                .name(t("world-name-syntax", TextVariables.NAME, worldName))
                .description(t("world-instructions"))
                .glow(true)
                .icon(icon)
                .build();
    }
    private PanelItem getTrashIcon(@NonNull GameModeAddon addon, BlueprintBundle bb) {
        return new PanelItemBuilder()
                .name(t("trash"))
                .description(t("trash-instructions"))
                .icon(Material.TNT)
                .clickHandler((panel, u, clickType, slot) -> {
                    if (clickType.equals(ClickType.RIGHT)) {
                        u.getPlayer().playSound(u.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);
                        plugin.getBlueprintsManager().deleteBlueprintBundle(addon, bb);
                        openPanel();
                    }
                    return true;
                })
                .build();
    }
    private PanelItem getNoTrashIcon() {
        return new PanelItemBuilder()
                .name(t("no-trash"))
                .description(t("no-trash-instructions"))
                .icon(Material.TNT)
                .build();
    }
    private PanelItem getPermissionIcon(@NonNull GameModeAddon addon, BlueprintBundle bb) {
        return new PanelItemBuilder().icon(Material.PAINTING).name(t("permission"))
                .description(bb.isRequirePermission() ? t("perm-required") : t("perm-not-required"))
                .description(bb.isRequirePermission() ? t("perm-format") + addon.getPermissionPrefix() + "island.create."  + bb.getUniqueId() : "")
                .clickHandler((panel, u, clickType, slot) -> {
                    // Toggle permission
                    u.getPlayer().playSound(u.getLocation(), Sound.UI_BUTTON_CLICK, 1F, 1F);
                    bb.setRequirePermission(!bb.isRequirePermission());
                    // Save
                    plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                    panel.getInventory().setItem(39, getPermissionIcon(addon, bb).getItem());
                    return true;
                }).build();
    }
    private PanelItem getNoPermissionIcon() {
        return new PanelItemBuilder().icon(Material.PAINTING).name(t("no-permission"))
                .description(t("no-perm-required"))
                .build();
    }
    /**
     * Gets a panel item that fully represents a blueprint in a bundle for an addon
     * @param addon - the GameMode Addon
     * @param pos - the position where this icon will be placed - the description changes
     * @param bb - the blueprint bundle this blueprint is in, if any
     * @param blueprint - blueprint itself
     * @return a panel item
     */
    protected PanelItem getBlueprintItem(GameModeAddon addon, int pos, BlueprintBundle bb, Blueprint blueprint) {
        // Create description
        List<String> desc = blueprint.getDescription() == null ? new ArrayList<>() : blueprint.getDescription();
        desc = desc.stream().map(Util::translateColorCodes).collect(Collectors.toList()); // Must be mutable
        if ((!blueprint.equals(endBlueprint) && !blueprint.equals(normalBlueprint) && !blueprint.equals(netherBlueprint))) {
            if ((pos > MIN_WORLD_SLOT && pos < MAX_WORLD_SLOT)) {
                desc.add(t("remove"));
            } else {
                desc.add(t("blueprint-instruction"));
            }
        }
        return new PanelItemBuilder()
                .name(blueprint.getDisplayName() == null ? blueprint.getName() : blueprint.getDisplayName())
                .description(desc)
                .icon(blueprint.getIcon())
                .glow(selected != null && pos == selected.getKey())
                .clickHandler((panel, u, clickType, slot) -> {
                    // Handle the world squares
                    if (slot > MIN_WORLD_SLOT && slot < MAX_WORLD_SLOT) {
                        if (clickType.equals(ClickType.RIGHT)) {
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_GLASS_BREAK, 1F, 1F);
                            // Remove the item and replace with the blank
                            bb.clearBlueprint(slotToEnvironment.get(slot));
                            // Save
                            plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                            openBB(bb);
                        } else if (selected == null) {
                            u.sendMessage("commands.admin.blueprint.management.select-first");
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_ANVIL_HIT, 1F, 1F);
                        } else {
                            // Add
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_METAL_HIT, 1F, 1F);
                            Blueprint bp = selected.getValue();
                            // make slot the chosen one
                            bb.setBlueprint(slotToEnvironment.get(slot), bp);
                            // Save
                            plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                            openBB(bb);
                        }
                    } else {
                        // Select blueprint
                        if (blueprints.containsKey(slot)) {
                            // Renaming blueprint
                            if (clickType.equals(ClickType.RIGHT)) {
                                u.closeInventory();
                                this.askForBlueprintName(u.getPlayer(), addon, blueprint, bb);
                                return true;
                            }
                            if (selected != null && slot == selected.getKey()){
                                // Clicked on same item - deselect
                                selected = null;
                            } else {
                                // Set selected
                                selected = new AbstractMap.SimpleEntry<>(slot, blueprints.get(slot));
                            }
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_METAL_HIT, 1F, 2F);
                            openBB(bb);
                        }
                    }
                    return true;
                })
                .build();
    }
    private PanelItem getNewBundle(@NonNull GameModeAddon addon) {
        return new PanelItemBuilder()
                .name(t("new-bundle"))
                .description(t("new-bundle-instructions"))
                .icon(Material.GREEN_BANNER)
                .clickHandler((panel, u, clickType, slot) -> {
                    u.closeInventory();
                    askForName(u.getPlayer(), addon, null);
                    return true;
                })
                .build();
    }
    public void askForName(Conversable whom, GameModeAddon addon, BlueprintBundle bb) {
        new ConversationFactory(BentoBox.getInstance())
        .withModality(true)
        .withLocalEcho(false)
        .withPrefix(new NameConversationPrefix())
        .withTimeout(90)
        .withFirstPrompt(new NamePrompt(addon, bb))
        .withEscapeSequence(t("name.quit"))
        .buildConversation(whom).begin();
    }
    public void askForBlueprintName(Conversable whom, GameModeAddon addon, Blueprint bp, BlueprintBundle bb) {
        new ConversationFactory(BentoBox.getInstance())
        .withModality(true)
        .withLocalEcho(false)
        .withPrefix(new NameConversationPrefix())
        .withTimeout(90)
        .withFirstPrompt(new NamePrompt(addon, bp, bb))
        .withEscapeSequence(t("name.quit"))
        .buildConversation(whom).begin();
    }
    public void askForDescription(Conversable whom, GameModeAddon addon, BlueprintBundle bb) {
        new ConversationFactory(BentoBox.getInstance())
        .withModality(true)
        .withLocalEcho(false)
        .withPrefix(new NameConversationPrefix())
        .withTimeout(90)
        .withFirstPrompt(new DescriptionPrompt(addon, bb))
        .buildConversation(whom).begin();
    }
    /**
     * @return the selected
     */
    public Entry<Integer, Blueprint> getSelected() {
        return selected;
    }
}
package world.bentobox.bentobox.managers.island;
import java.io.IOException;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.World.Environment;
import org.bukkit.util.Vector;
import world.bentobox.bentobox.BStats;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.events.IslandBaseEvent;
import world.bentobox.bentobox.api.events.island.IslandCreateEvent;
import world.bentobox.bentobox.api.events.island.IslandEvent;
import world.bentobox.bentobox.api.events.island.IslandEvent.Reason;
import world.bentobox.bentobox.api.events.island.IslandResetEvent;
import world.bentobox.bentobox.api.logs.LogEntry;
import world.bentobox.bentobox.api.logs.LogEntry.LogType;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.managers.IslandsManager;
/**
 * Create and paste a new island
 * 
 * @author tastybento
 *
 */
public class NewIsland {
    private final BentoBox plugin;
    private Island island;
    private final User user;
    private final Reason reason;
    private final World world;
    private String name;
    private final boolean noPaste;
    private final GameModeAddon addon;
    private NewIslandLocationStrategy locationStrategy;
    public NewIsland(Builder builder) throws IOException {
        plugin = BentoBox.getInstance();
        this.user = builder.user2;
        this.reason = builder.reason2;
        this.world = builder.world2;
        this.name = builder.name2;
        this.noPaste = builder.noPaste2;
        this.addon = builder.addon2;
        this.locationStrategy = builder.locationStrategy2;
        if (this.locationStrategy == null) {
            this.locationStrategy = new DefaultNewIslandLocationStrategy();
        }
        // Fire pre-create event
        IslandBaseEvent event = IslandEvent.builder().involvedPlayer(user.getUniqueId()).reason(Reason.PRECREATE)
                .build();
        if (event.getNewEvent().map(IslandBaseEvent::isCancelled).orElse(event.isCancelled())) {
            // Do nothing
            return;
        }
        newIsland(builder.oldIsland2);
    }
    /**
     * @return the island that was created
     */
    public Island getIsland() {
        return island;
    }
    /**
     * Start building a new island
     * 
     * @return New island builder object
     */
    public static Builder builder() {
        return new Builder();
    }
    /**
     * Build a new island for a player
     * 
     * @author tastybento
     */
    public static class Builder {
        private Island oldIsland2;
        private User user2;
        private Reason reason2;
        private World world2;
        private String name2 = BlueprintsManager.DEFAULT_BUNDLE_NAME;
        private boolean noPaste2;
        private GameModeAddon addon2;
        private NewIslandLocationStrategy locationStrategy2;
        public Builder oldIsland(Island oldIsland) {
            this.oldIsland2 = oldIsland;
            this.world2 = oldIsland.getWorld();
            return this;
        }
        public Builder player(User player) {
            this.user2 = player;
            return this;
        }
        /**
         * Sets the reason
         * 
         * @param reason reason, can only be {@link Reason#CREATE} or
         *               {@link Reason#RESET}.
         */
        public Builder reason(Reason reason) {
            if (!reason.equals(Reason.CREATE) && !reason.equals(Reason.RESET)) {
                throw new IllegalArgumentException("Reason must be CREATE or RESET.");
            }
            this.reason2 = reason;
            return this;
        }
        /**
         * Set the addon
         * 
         * @param addon a game mode addon
         */
        public Builder addon(GameModeAddon addon) {
            this.addon2 = addon;
            this.world2 = addon.getOverWorld();
            return this;
        }
        /**
         * No blocks will be pasted
         */
        public Builder noPaste() {
            this.noPaste2 = true;
            return this;
        }
        /**
         * @param name - name of Blueprint bundle
         */
        public Builder name(String name) {
            this.name2 = name;
            return this;
        }
        /**
         * @param strategy - the location strategy to use
         * @since 1.8.0
         */
        public Builder locationStrategy(NewIslandLocationStrategy strategy) {
            this.locationStrategy2 = strategy;
            return this;
        }
        /**
         * @return Island
         * @throws IOException - if there are insufficient parameters, i.e., no user
         */
        public Island build() throws IOException {
            if (user2 != null) {
                NewIsland newIsland = new NewIsland(this);
                return newIsland.getIsland();
            }
            throw new IOException("Insufficient parameters. Must have a user!");
        }
    }
    /**
     * Makes an island.
     * 
     * @param oldIsland old island that is being replaced, if any
     * @throws IOException - if an island cannot be made. Message is the tag to show
     *                     the user.
     */
    public void newIsland(Island oldIsland) throws IOException {
        // Find the new island location
        Location next = checkReservedIsland();
        if (next == null) {
            next = this.makeNextIsland();
        }
        // Clean up the user
        cleanUpUser(next);
        // Fire event
        IslandBaseEvent event = IslandEvent.builder().involvedPlayer(user.getUniqueId()).reason(reason).island(island)
                .location(island.getCenter())
                .blueprintBundle(plugin.getBlueprintsManager().getBlueprintBundles(addon).get(name))
                .oldIsland(oldIsland).build();
        if (event.getNewEvent().map(IslandBaseEvent::isCancelled).orElse(event.isCancelled())) {
            // Do nothing
            return;
        }
        event = event.getNewEvent().orElse(event);
        // Get the new BlueprintBundle if it was changed
        switch (reason) {
        case CREATE -> name = ((IslandCreateEvent) event).getBlueprintBundle().getUniqueId();
        case RESET -> name = ((IslandResetEvent) event).getBlueprintBundle().getUniqueId();
        default -> {
            // Do nothing of other cases
        }
        }
        // Set the player's primary island
        plugin.getIslands().setPrimaryIsland(user.getUniqueId(), island);
        // Run task to run after creating the island in one tick if island is not being
        // pasted
        if (noPaste) {
            Bukkit.getScheduler().runTask(plugin, () -> postCreationTask(oldIsland));
        } else {
            // Find out how far away the player is from the new island
            boolean useNMS = !user.getWorld().equals(island.getWorld())
                    || (user.getLocation().distance(island.getCenter()) >= Bukkit.getViewDistance() * 16D);
            // Create islands, then run task
            plugin.getBlueprintsManager().paste(addon, island, name, () -> postCreationTask(oldIsland), useNMS);
        }
        // Set default settings
        island.setFlagsDefaults();
        // Register metrics
        plugin.getMetrics().ifPresent(BStats::increaseIslandsCreatedCount);
        // Add historu record
        island.log(new LogEntry.Builder(LogType.JOINED).data(user.getUniqueId().toString(), "owner").build());
        // Save island
        IslandsManager.updateIsland(island);
    }
    /**
     * Tasks to run after the new island has been created
     * 
     * @param oldIsland - old island that will be deleted
     */
    private void postCreationTask(Island oldIsland) {
        // Set initial spawn point if one exists
        if (island.getSpawnPoint(Environment.NORMAL) != null) {
            plugin.getIslands().setHomeLocation(user, island.getSpawnPoint(Environment.NORMAL));
        }
        // Stop the player from falling or moving if they are
        if (user.isOnline()) {
            if (reason.equals(Reason.RESET) || (reason.equals(Reason.CREATE)
                    && plugin.getIWM().isTeleportPlayerToIslandUponIslandCreation(world))) {
                user.getPlayer().setVelocity(new Vector(0, 0, 0));
                user.getPlayer().setFallDistance(0F);
                // Teleport player after this island is built
                plugin.getIslands().homeTeleportAsync(world, user.getPlayer(), true).thenRun(() -> tidyUp(oldIsland));
                return;
            } else {
                // let's send him a message so that he knows he can teleport to his island!
                user.sendMessage("commands.island.create.you-can-teleport-to-your-island");
            }
        } else {
            // Remove the player again to completely clear the data
            User.removePlayer(user.getPlayer());
        }
        tidyUp(oldIsland);
    }
    /**
     * Cleans up a user before moving them to a new island. Resets deaths. Checks
     * range permissions and saves the player to the database.
     * 
     * @param loc - the new island location
     */
    private void cleanUpUser(Location loc) {
        // Reset deaths
        if (plugin.getIWM().isDeathsResetOnNewIsland(world)) {
            plugin.getPlayers().setDeaths(world, user.getUniqueId(), 0);
        }
        // Check if owner has a different range permission than the island size
        island.setProtectionRange(user.getPermissionValue(
                plugin.getIWM().getAddon(island.getWorld()).map(GameModeAddon::getPermissionPrefix).orElse("")
                        + "island.range",
                island.getProtectionRange()));
    }
    /**
     * Get the next island location and add it to the island grid
     * 
     * @return location of new island
     * @throws IOException - if there are no unoccupied spots or the island could
     *                     not be added to the grid
     */
    private Location makeNextIsland() throws IOException {
        // If the reservation fails, then we need to make a new island anyway
        Location next = this.locationStrategy.getNextLocation(world);
        if (next == null) {
            plugin.logError("Failed to make island - no unoccupied spot found.");
            plugin.logError("If the world was imported, try multiple times until all unowned islands are known.");
            throw new IOException("commands.island.create.cannot-create-island");
        }
        // Add to the grid
        island = plugin.getIslands().createIsland(next, user.getUniqueId());
        if (island == null) {
            plugin.logError("Failed to make island! Island could not be added to the grid.");
            throw new IOException("commands.island.create.unable-create-island");
        }
        return next;
    }
    /**
     * Get the reserved island location
     * 
     * @return reserved island location, or null if none found
     */
    private Location checkReservedIsland() {
        if (plugin.getIslands().hasIsland(world, user)) {
            // Island exists, it just needs pasting
            island = plugin.getIslands().getIsland(world, user);
            if (island != null && island.isReserved()) {
                Location l = island.getCenter();
                // Clear the reservation
                island.setReserved(false);
                return l;
            }
        }
        return null;
    }
    private void tidyUp(Island oldIsland) {
        // Delete old island
        if (oldIsland != null) {
            // Delete the old island
            plugin.getIslands().deleteIsland(oldIsland, true, user.getUniqueId());
        }
        // Fire exit event
        IslandEvent.builder().involvedPlayer(user.getUniqueId())
                .reason(reason == Reason.RESET ? Reason.RESETTED : Reason.CREATED).island(island)
                .location(island.getCenter()).oldIsland(oldIsland).build();
    }
}
package world.bentobox.bentobox.managers;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.InputMismatchException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.jar.JarFile;
import java.util.stream.Collectors;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.InstanceCreator;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.Addon;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.metadata.MetaDataValue;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.blueprints.BlueprintPaster;
import world.bentobox.bentobox.blueprints.DisplayListener;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBlock;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBundle;
import world.bentobox.bentobox.database.json.BentoboxTypeAdapterFactory;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.util.Util;
/**
 * Handles Blueprints
 *
 * @author Poslovitch, tastybento
 * @since 1.5.0
 */
public class BlueprintsManager {
    private static final String BLUEPRINT_BUNDLE_SUFFIX = ".json";
    public static final String BLUEPRINT_SUFFIX = ".blu";
    public static final String DEFAULT_BUNDLE_NAME = "default";
    @NonNull
    public static final String FOLDER_NAME = "blueprints";
    private static final String FOR = "' for ";
    /**
     * Map of blueprint bundles to game mode addon.
     * Inner map's key is the uniqueId of the blueprint bundle so it's
     * easy to get from a UI
     */
    @NonNull
    private final Map<GameModeAddon, List<BlueprintBundle>> blueprintBundles;
    /**
     * Map of blueprints. There can be many blueprints per game mode addon
     * Inner map's key is the blueprint's name so it's easy to get from a UI
     */
    @NonNull
    private final Map<GameModeAddon, List<Blueprint>> blueprints;
    /**
     * Gson used for serializing/deserializing the bundle class
     */
    private final Gson gson;
    private final @NonNull BentoBox plugin;
    @NonNull
    private final Set<GameModeAddon> blueprintsLoaded;
    public BlueprintsManager(@NonNull BentoBox plugin) {
        this.plugin = plugin;
        // Must use ConcurrentHashMap because the maps are loaded async and they need to be thread safe
        this.blueprintBundles = new ConcurrentHashMap<>();
        this.blueprints = new ConcurrentHashMap<>();
        @SuppressWarnings({"rawtypes", "unchecked"})
        GsonBuilder builder = new GsonBuilder()
        .excludeFieldsWithoutExposeAnnotation()
        .enableComplexMapKeySerialization()
        .setPrettyPrinting()
        // This enables gson to deserialize enum maps
        .registerTypeAdapter(EnumMap.class, (InstanceCreator<EnumMap>) type -> {
            Type[] types = (((ParameterizedType) type).getActualTypeArguments());
            return new EnumMap((Class<?>) types[0]);
        });
        // Disable <>'s escaping etc.
        builder.disableHtmlEscaping();
        // Register adapter factory
        builder.registerTypeAdapterFactory(new BentoboxTypeAdapterFactory(plugin));
        gson = builder.create();
        // Loaded tracker
        blueprintsLoaded = new HashSet<>();
        // Register Display listeners
        Bukkit.getPluginManager().registerEvents(new DisplayListener(), plugin);
    }
    /**
     * Extracts the blueprints and bundles provided by this {@link GameModeAddon} in its .jar file.
     * This will do nothing if the blueprints folder already exists for this GameModeAddon.
     *
     * @param addon the {@link GameModeAddon} to extract the blueprints from.
     */
    public void extractDefaultBlueprints(@NonNull GameModeAddon addon) {
        File folder = getBlueprintsFolder(addon);
        if (folder.exists()) {
            // If the folder exists, do not copy anything from the jar
            return;
        }
        if (!folder.exists() && !folder.mkdirs()) {
            plugin.logError("Could not create the '" + FOLDER_NAME + "' folder!");
            plugin.logError("This might be due to incorrectly set-up write permissions on the operating system.");
            return;
        }
        // Get any blueprints or bundles from the jar and save them.
        try (JarFile jar = new JarFile(addon.getFile())) {
            Util.listJarFiles(jar, FOLDER_NAME, BLUEPRINT_BUNDLE_SUFFIX).forEach(name -> addon.saveResource(name, false));
            Util.listJarFiles(jar, FOLDER_NAME, BLUEPRINT_SUFFIX).forEach(name -> addon.saveResource(name, false));
        } catch (IOException e) {
            plugin.logError("Could not load blueprint files from addon jar " + e.getMessage());
        }
    }
    /**
     * Get the blueprint bundles of this addon.
     *
     * @param addon the {@link GameModeAddon} to get the blueprint bundles.
     */
    @NonNull
    public Map<String, BlueprintBundle> getBlueprintBundles(@NonNull GameModeAddon addon) {
        if (!blueprintBundles.containsKey(addon)) {
            return new HashMap<>();
        }
        return blueprintBundles.get(addon).stream().collect(Collectors.toMap(BlueprintBundle::getUniqueId, b -> b));
    }
    /**
     * Get the default blueprint bundle for game mode
     * @param addon - game mode addon
     * @return the default blueprint bundle or null if none
     * @since 1.8.0
     */
    @Nullable
    public BlueprintBundle getDefaultBlueprintBundle(@NonNull GameModeAddon addon) {
        if (blueprintBundles.containsKey(addon)) {
            return blueprintBundles.get(addon).stream().filter(bb -> bb.getUniqueId().equals(DEFAULT_BUNDLE_NAME)).findFirst().orElse(null);
        }
        return null;
    }
    /**
     * Returns a {@link File} instance of the blueprints folder of this {@link GameModeAddon}.
     *
     * @param addon the {@link GameModeAddon}
     * @return a {@link File} instance of the blueprints folder of this GameModeAddon.
     */
    @NonNull
    private File getBlueprintsFolder(@NonNull GameModeAddon addon) {
        return new File(addon.getDataFolder(), FOLDER_NAME);
    }
    /**
     * Loads the blueprint bundles of this addon from its blueprints folder.
     *
     * @param addon the {@link GameModeAddon} to load the blueprints of.
     */
    public void loadBlueprintBundles(@NonNull GameModeAddon addon) {
        // Set loading flag
        blueprintsLoaded.add(addon);
        Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
            // Load bundles
            blueprintBundles.put(addon, new ArrayList<>());
            if (!loadBundles(addon)) {
                makeDefaults(addon);
                loadBundles(addon);
            }
            // Load blueprints
            loadBlueprints(addon);
            // Clear loading flag
            blueprintsLoaded.remove(addon);
        });
    }
    /**
     * Check if all blueprints are loaded. Only query after all GameModes have been loaded.
     * @return true if all blueprints are loaded
     */
    public boolean isBlueprintsLoaded() {
        return blueprintsLoaded.isEmpty();
    }
    private boolean loadBundles(@NonNull GameModeAddon addon) {
        File bpf = getBlueprintsFolder(addon);
        if (!bpf.exists()) {
            plugin.logError("There is no blueprint folder for addon " + addon.getDescription().getName());
            bpf.mkdirs();
        }
        boolean loaded = false;
        File[] bundles = bpf.listFiles((dir, name) -> name.endsWith(BLUEPRINT_BUNDLE_SUFFIX));
        if (bundles == null || bundles.length == 0) {
            return false;
        }
        for (File file : bundles) {
            try (FileReader fileReader = new FileReader(file, StandardCharsets.UTF_8))
            {
                if (!file.getName().equals(Util.sanitizeInput(file.getName())))
                {
                    // fail on all blueprints with incorrect names.
                    throw new InputMismatchException(file.getName());
                }
                BlueprintBundle bb = gson.fromJson(fileReader, BlueprintBundle.class);
                if (bb != null) {
                    // Make sure there is no existing bundle with the same uniqueId
                    if (blueprintBundles.get(addon).stream().noneMatch(bundle ->  bundle.getUniqueId().equals(bb.getUniqueId()))) {
                        blueprintBundles.get(addon).add(bb);
                        plugin.log("Loaded Blueprint Bundle '" + bb.getUniqueId() + FOR + addon.getDescription().getName() + ".");
                        loaded = true;
                    } else {
                        // There is a bundle that already uses this uniqueId.
                        // In that case, we log that and do not load the new bundle.
                        plugin.logWarning("Could not load blueprint bundle '" + file.getName() + FOR + addon.getDescription().getName() + ".");
                        plugin.logWarning("The uniqueId '" + bb.getUniqueId() + "' is already used by another Blueprint Bundle.");
                        plugin.logWarning("This can occur if the Blueprint Bundles' files were manually edited.");
                        plugin.logWarning("Please review your Blueprint Bundles' files and make sure their uniqueIds are not in duplicate.");
                    }
                }
            } catch (Exception e) {
                plugin.logError("Could not load blueprint bundle '" + file.getName() + "'. Cause: " + e.getMessage() + ".");
                plugin.logStacktrace(e);
            }
        }
        return loaded;
    }
    private BlueprintBundle getDefaultBlueprintBundle() {
        BlueprintBundle bb = new BlueprintBundle();
        bb.setIcon(Material.PAPER);
        bb.setUniqueId(DEFAULT_BUNDLE_NAME);
        bb.setDisplayName("Default bundle");
        bb.setDescription(Collections.singletonList(ChatColor.AQUA + "Default bundle of blueprints"));
        return bb;
    }
    private Blueprint getDefaultBlueprint() {
        Blueprint defaultBp = new Blueprint();
        defaultBp.setName("bedrock");
        defaultBp.setDescription(Collections.singletonList(ChatColor.AQUA + "A bedrock block"));
        defaultBp.setBedrock(new Vector(0, 0, 0));
        Map<Vector, BlueprintBlock> map = new HashMap<>();
        map.put(new Vector(0, 0, 0), new BlueprintBlock("minecraft:bedrock"));
        defaultBp.setBlocks(map);
        return defaultBp;
    }
    /**
     * This should never be needed and is just a boot strap
     *
     * @param addon addon
     */
    private void makeDefaults(@NonNull GameModeAddon addon) {
        plugin.logError("No blueprint bundles found! Creating a default one.");
        BlueprintBundle bb = getDefaultBlueprintBundle();
        // Default blueprints
        Blueprint defaultBp = getDefaultBlueprint();
        // Save a default "bedrock" blueprint
        new BlueprintClipboardManager(plugin, getBlueprintsFolder(addon)).saveBlueprint(defaultBp);
        // This blueprint is used for all environments
        bb.setBlueprint(World.Environment.NORMAL, defaultBp);
        bb.setBlueprint(World.Environment.NETHER, defaultBp);
        bb.setBlueprint(World.Environment.THE_END, defaultBp);
        bb.setUniqueId(DEFAULT_BUNDLE_NAME);
        blueprintBundles.get(addon).add(bb);
        this.saveBlueprintBundles();
    }
    /**
     * Loads all the blueprints of this addon from its blueprints folder.
     *
     * @param addon the {@link GameModeAddon} to load the blueprints of.
     */
    public void loadBlueprints(@NonNull GameModeAddon addon) {
        blueprints.put(addon, new ArrayList<>());
        File bpf = getBlueprintsFolder(addon);
        if (!bpf.exists()) {
            plugin.logError("There is no blueprint folder for addon " + addon.getDescription().getName());
            bpf.mkdirs();
        }
        File[] bps = bpf.listFiles((dir, name) -> name.endsWith(BLUEPRINT_SUFFIX));
        if (bps == null || bps.length == 0) {
            plugin.logError("No blueprints found for " + addon.getDescription().getName());
            return;
        }
        for (File file : bps) {
            // Input sanitization is required for weirdos that edit files manually.
            String fileName = Util.sanitizeInput(file.getName().substring(0, file.getName().length() - BLUEPRINT_SUFFIX.length()));
            try {
                Blueprint bp = new BlueprintClipboardManager(plugin, bpf).loadBlueprint(fileName);
                bp.setName(fileName);
                blueprints.get(addon).add(bp);
                plugin.log("Loaded blueprint '" + bp.getName() + FOR + addon.getDescription().getName());
            } catch (Exception e) {
                plugin.logError("Could not load blueprint " + fileName + " " + e.getMessage());
                plugin.logStacktrace(e);
            }
        }
    }
    /**
     * Adds a blueprint to addon's list of blueprints. If the list already contains a blueprint with the same name
     * it is replaced.
     *
     * @param addon - the {@link GameModeAddon}
     * @param bp    - blueprint
     */
    public void addBlueprint(@NonNull GameModeAddon addon, @NonNull Blueprint bp) {
        blueprints.putIfAbsent(addon, new ArrayList<>());
        blueprints.get(addon).removeIf(b -> b.getName().equals(bp.getName()));
        blueprints.get(addon).add(bp);
        plugin.log("Added blueprint '" + bp.getName() + FOR + addon.getDescription().getName());
    }
    /**
     * Saves a blueprint into addon's blueprint folder
     *
     * @param addon - the {@link GameModeAddon}
     * @param bp    - blueprint to save
     */
    public boolean saveBlueprint(@NonNull GameModeAddon addon, @NonNull Blueprint bp) {
        return new BlueprintClipboardManager(plugin, getBlueprintsFolder(addon)).saveBlueprint(bp);
    }
    /**
     * Save blueprint bundle for game mode
     *
     * @param addon - gamemode addon
     * @param bb    blueprint bundle to save
     */
    public void saveBlueprintBundle(GameModeAddon addon, BlueprintBundle bb) {
        Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
            File bpf = getBlueprintsFolder(addon);
            if (!bpf.exists()) {
                bpf.mkdirs();
            }
            File fileName = new File(bpf, bb.getUniqueId() + BLUEPRINT_BUNDLE_SUFFIX);
            String toStore = gson.toJson(bb, BlueprintBundle.class);
            try (FileWriter fileWriter = new FileWriter(fileName, StandardCharsets.UTF_8)) {
                fileWriter.write(toStore);
            } catch (IOException e) {
                plugin.logError("Could not save blueprint bundle file: " + e.getMessage());
            }
        });
    }
    /**
     * Saves all the blueprint bundles
     */
    public void saveBlueprintBundles() {
        blueprintBundles.forEach((k, v) -> v.forEach(m -> saveBlueprintBundle(k, m)));
    }
    /**
     * Get blueprints for this game mode
     *
     * @param addon - game mode addon
     * @return Map of name and blueprint or empty map
     */
    public Map<String, Blueprint> getBlueprints(GameModeAddon addon) {
        if (!blueprints.containsKey(addon)) {
            return new HashMap<>();
        }
        return blueprints.get(addon).stream().collect(Collectors.toMap(Blueprint::getName, b -> b));
    }
    /**
     * Unregisters the Blueprint from the manager and deletes the file.
     * @param addon game mode addon
     * @param name name of the Blueprint to delete
     * @since 1.9.0
     */
    public void deleteBlueprint(GameModeAddon addon, String name)
    {
        List<Blueprint> addonBlueprints = this.blueprints.get(addon);
        Iterator<Blueprint> it = addonBlueprints.iterator();
        while (it.hasNext())
        {
            Blueprint b = it.next();
            if (b.getName().equalsIgnoreCase(name))
            {
                it.remove();
                File file = new File(this.getBlueprintsFolder(addon), b.getName() + BLUEPRINT_SUFFIX);
                // Delete the file
                try
                {
                    Files.deleteIfExists(file.toPath());
                }
                catch (IOException e)
                {
                    this.plugin.logError("Could not delete Blueprint " + e.getLocalizedMessage());
                }
            }
        }
    }
    /**
     * Paste the islands to world
     *
     * @param addon  - GameModeAddon
     * @param island - island
     * @param name   - bundle name
     */
    public void paste(GameModeAddon addon, Island island, String name) {
        paste(addon, island, name, null, true);
    }
    /**
     * Paste islands to the world and run task afterwards
     *
     * @param addon  - the game mode addon
     * @param island - the island
     * @param name   - name of bundle to paste
     * @param task   - task to run after pasting is completed
     * @param useNMS - true to use NMS pasting
     * @return true if okay, false is there is a problem
     */
    public boolean paste(GameModeAddon addon, Island island, String name, Runnable task, boolean useNMS) {
        if (validate(addon, name) == null) {
            plugin.logError("Tried to paste '" + name + "' but the bundle is not loaded!");
            return false;
        }
        BlueprintBundle bb = getBlueprintBundles(addon).get(name.toLowerCase());
        if (!blueprints.containsKey(addon) || blueprints.get(addon).isEmpty()) {
            plugin.logError("No blueprints loaded for bundle '" + name + "'!");
            return false;
        }
        Blueprint bp = getBlueprints(addon).get(bb.getBlueprint(World.Environment.NORMAL));
        if (bp == null) {
            // Oops, no overworld
            bp = getBlueprints(addon).get("island");
            plugin.logError("Blueprint bundle has no normal world blueprint, using default");
            if (bp == null) {
                plugin.logError("NO DEFAULT BLUEPRINT FOUND! Make sure 'island.blu' exists!");
            }
        }
        // Paste
        if (bp != null) {
            new BlueprintPaster(plugin, bp, addon.getOverWorld(), island).paste(useNMS)
                    .thenAccept(b -> pasteNether(addon, bb, island).thenAccept(
                            b2 ->
            pasteEnd(addon, bb, island).thenAccept(message -> sendMessage(island)).thenAccept(b3 -> Bukkit.getScheduler().runTask(plugin, task))));
        }
        // Set the bundle name
        island.putMetaData("bundle", new MetaDataValue(name));
        return true;
    }
    private CompletableFuture<Boolean> pasteNether(GameModeAddon addon, BlueprintBundle bb, Island island) {
        if (bb.getBlueprint(World.Environment.NETHER) != null
                && addon.getWorldSettings().isNetherGenerate()
                && addon.getWorldSettings().isNetherIslands()
                && addon.getNetherWorld() != null) {
            Blueprint bp = getBlueprints(addon).get(bb.getBlueprint(World.Environment.NETHER));
            if (bp != null) {
                return new BlueprintPaster(plugin, bp, addon.getNetherWorld(), island).paste();
            }
        }
        return CompletableFuture.completedFuture(false);
    }
    private CompletableFuture<Boolean> pasteEnd(GameModeAddon addon, BlueprintBundle bb, Island island) {
        // Make end island
        if (bb.getBlueprint(World.Environment.THE_END) != null
                && addon.getWorldSettings().isEndGenerate()
                && addon.getWorldSettings().isEndIslands()
                && addon.getEndWorld() != null) {
            Blueprint bp = getBlueprints(addon).get(bb.getBlueprint(World.Environment.THE_END));
            if (bp != null) {
                return new BlueprintPaster(plugin, bp, addon.getEndWorld(), island).paste();
            }
        }
        return CompletableFuture.completedFuture(false);
    }
    /**
     * This method just sends a message to the island owner that island creating is completed.
     * @param island Island which owner must receive a message.
     */
    private void sendMessage(Island island) {
        if (island != null && island.getOwner() != null) {
            final Optional<User> owner = Optional.of(island).map(i -> User.getInstance(i.getOwner()));
            owner.ifPresent(user -> user.sendMessage("commands.island.create.pasting.done"));
        }
    }
    /**
     * Validate if the bundle name is valid or not
     *
     * @param addon - game mode addon
     * @param name  - bundle name
     * @return bundle name or null if it's invalid
     */
    public @Nullable String validate(GameModeAddon addon, String name) {
        if (name == null) {
            return null;
        }
        if (blueprintBundles.containsKey(addon) && getBlueprintBundles(addon).containsKey(name)) {
            return name;
        }
        return null;
    }
    /**
     * Adds a blueprint bundle. If a bundle with the same uniqueId exists, it will be replaced
     *
     * @param addon - the game mode addon
     * @param bb    - the blueprint bundle
     */
    public void addBlueprintBundle(GameModeAddon addon, BlueprintBundle bb) {
        if (blueprintBundles.containsKey(addon)) {
            // Remove any bundles with the same name
            blueprintBundles.get(addon).removeIf(b -> b.getUniqueId().equals(bb.getUniqueId()));
        }
        blueprintBundles.computeIfAbsent(addon, k -> new ArrayList<>()).add(bb);
    }
    /**
     * Checks if a player has permission to see or use this blueprint bundle.
     *
     * @param addon - addon making the request
     * @param user  - user making the request
     * @param name  - name of the blueprint bundle
     * @return <tt>true</tt> if allowed, <tt>false</tt> if not or bundle does not exist
     */
    public boolean checkPerm(@NonNull Addon addon, @NonNull User user, @NonNull String name) {
        // Permission
        String permission = addon.getPermissionPrefix() + "island.create." + name;
        // Get Blueprint bundle
        BlueprintBundle bb = getBlueprintBundles((GameModeAddon) addon).get(name.toLowerCase());
        if (bb == null || (bb.isRequirePermission() && !name.equals(DEFAULT_BUNDLE_NAME) && !user.hasPermission(permission))) {
            user.sendMessage("general.errors.no-permission", TextVariables.PERMISSION, permission);
            return false;
        }
        return true;
    }
    /**
     * Removes a blueprint bundle
     *
     * @param addon - Game Mode Addon
     * @param bb    - Blueprint Bundle to delete
     */
    public void deleteBlueprintBundle(@NonNull GameModeAddon addon, BlueprintBundle bb) {
        if (blueprintBundles.containsKey(addon)) {
            blueprintBundles.get(addon).removeIf(k -> k.getUniqueId().equals(bb.getUniqueId()));
        }
        File bpf = getBlueprintsFolder(addon);
        File fileName = new File(bpf, bb.getUniqueId() + BLUEPRINT_BUNDLE_SUFFIX);
        try {
            Files.deleteIfExists(fileName.toPath());
        } catch (IOException e) {
            plugin.logError("Could not delete Blueprint Bundle " + e.getLocalizedMessage());
        }
    }
    /**
     * Rename a blueprint
     *
     * @param addon - Game Mode Addon
     * @param bp    - blueprint
     * @param name  - new name
     * @param displayName - display name for blueprint
     */
    public void renameBlueprint(GameModeAddon addon, Blueprint bp, String name, String displayName)
    {
        if (bp.getName().equalsIgnoreCase(name))
        {
            // If the name is the same, do not do anything
            return;
        }
        File bpf = this.getBlueprintsFolder(addon);
        // Get the filename
        File fileName = new File(bpf, bp.getName() + BLUEPRINT_SUFFIX);
        // Delete the old file
        try
        {
            Files.deleteIfExists(fileName.toPath());
        }
        catch (IOException e)
        {
            this.plugin.logError("Could not delete old Blueprint " + e.getLocalizedMessage());
        }
        // Remove blueprint from the blueprints.
        this.blueprints.get(addon).remove(bp);
        // Set new name
        bp.setName(name);
        bp.setDisplayName(displayName);
        // Save it
        this.saveBlueprint(addon, bp);
        this.addBlueprint(addon, bp);
    }
}
package world.bentobox.bentobox.blueprints.dataobjects;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import org.bukkit.Material;
import org.bukkit.World;
import com.google.gson.annotations.Expose;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.database.objects.DataObject;
/**
 * Represents a bundle of three {@link Blueprint}s.
 * This is what the player will choose when creating his island.
 * @since 1.5.0
 * @author Poslovitch, tastybento
 */
public class BlueprintBundle implements DataObject {
    /**
     * The unique id of this bundle
     */
    @Expose
    private String uniqueId;
    /**
     * Icon of the bundle
     */
    @Expose
    private Material icon = Material.PAPER;
    /**
     * Name on the icon
     */
    @Expose
    private String displayName = "";
    /**
     * Description to show players
     */
    @Expose
    private List<String> description = new ArrayList<>();
    /**
     * If true, then the player needs to have a permission to view or use this bundle
     * The permission is GameModeAddon.island.create.uniqueId of blueprint bundle.
     * e.g. bskyblock.island.create.vip
     */
    @Expose
    private boolean requirePermission;
    /**
     * Reference to the blueprint
     */
    @Expose
    private Map<World.Environment, String> blueprints = new EnumMap<>(World.Environment.class);
    /**
     * Preferred slot in GUI.
     */
    @Expose
    private int slot = 0;
    /**
     * Number of times this bundle can be used by a single player. 0 = unlimited
     */
    @Expose
    private int times = 0;
    /**
     * @return the uniqueId
     */
    @Override
    public String getUniqueId() {
        return uniqueId;
    }
    /**
     * @param uniqueId the uniqueId to set
     */
    @Override
    public void setUniqueId(String uniqueId) {
        this.uniqueId = uniqueId;
    }
    /**
     * @return the icon
     */
    public Material getIcon() {
        return icon;
    }
    /**
     * @param icon the icon to set
     */
    public void setIcon(Material icon) {
        this.icon = icon;
    }
    /**
     * @return the displayName
     */
    public String getDisplayName() {
        return displayName;
    }
    /**
     * @param displayName the displayName to set
     */
    public void setDisplayName(String displayName) {
        this.displayName = displayName;
    }
    /**
     * @return the description
     */
    public List<String> getDescription() {
        return description;
    }
    /**
     * @param description the description to set
     */
    public void setDescription(List<String> description) {
        this.description = description;
    }
    /**
     * @return the blueprints
     */
    public Map<World.Environment, String> getBlueprints() {
        return blueprints;
    }
    /**
     * @param blueprints the blueprints to set
     */
    public void setBlueprints(Map<World.Environment, String> blueprints) {
        this.blueprints = blueprints;
    }
    /**
     * Adds a blueprint to the blueprint bundle. It will replace any blueprint that already exists of the same Environment type.
     * @param env - the Environment
     * @param bp - blueprint
     */
    public void setBlueprint(World.Environment env, Blueprint bp) {
        this.blueprints.put(env, bp.getName());
    }
    /**
     * Removes a blueprint from this environment slot
     * @param env - the world environment
     */
    public void clearBlueprint(World.Environment env) {
        this.blueprints.remove(env);
    }
    /**
     * Get the blueprint for the environment type
     * @param env - Environment type
     * @return Blueprint or null if one does not exist
     */
    public String getBlueprint(World.Environment env) {
        return this.blueprints.get(env);
    }
    /**
     * Adds a line to the description
     *
     * @param string description
     */
    public void setDescription(String string) {
        if (description == null)
            description = new ArrayList<>();
        this.description.add(string);
    }
    /**
     * @return the requirePermission
     */
    public boolean isRequirePermission() {
        return requirePermission;
    }
    /**
     * @param requirePermission the requirePermission to set
     */
    public void setRequirePermission(boolean requirePermission) {
        this.requirePermission = requirePermission;
    }
    /**
     * @return the slot
     */
    public int getSlot() {
        return slot;
    }
    /**
     * @param slot the slot to set
     */
    public void setSlot(int slot) {
        this.slot = slot;
    }
    /**
     * @return the times
     */
    public int getTimes() {
        return times;
    }
    /**
     * @param times the times to set
     */
    public void setTimes(int times) {
        this.times = times;
    }
}
package world.bentobox.bentobox.blueprints.conversation;
import org.bukkit.conversations.ConversationContext;
import org.bukkit.conversations.Prompt;
import org.bukkit.conversations.StringPrompt;
import org.bukkit.entity.Player;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import net.md_5.bungee.api.ChatColor;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBundle;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
public class NamePrompt extends StringPrompt
{
    private final GameModeAddon addon;
    @Nullable
    private final BlueprintBundle bb;
    @Nullable
    private Blueprint bp;
    public NamePrompt(@NonNull GameModeAddon addon, @Nullable BlueprintBundle bb)
    {
        this.addon = addon;
        this.bb = bb;
    }
    public NamePrompt(@NonNull GameModeAddon addon, @Nullable Blueprint bp, @Nullable BlueprintBundle bb)
    {
        this.addon = addon;
        this.bp = bp;
        this.bb = bb;
    }
    @Override
    public @NonNull String getPromptText(ConversationContext context)
    {
        User user = User.getInstance((Player) context.getForWhom());
        return user.getTranslation("commands.admin.blueprint.management.name.prompt");
    }
    @Override
    public Prompt acceptInput(ConversationContext context, String input)
    {
        User user = User.getInstance((Player) context.getForWhom());
        String uniqueId = Util.sanitizeInput(input);
        // Convert color codes
        if (ChatColor.stripColor(Util.translateColorCodes(input)).length() > 32)
        {
            context.getForWhom().sendRawMessage(
                user.getTranslation("commands.admin.blueprint.management.name.too-long"));
            return this;
        }
        if (this.bb == null || !this.bb.getUniqueId().equals(BlueprintsManager.DEFAULT_BUNDLE_NAME))
        {
            // Check if this name is unique
            if (this.addon.getPlugin().getBlueprintsManager().getBlueprintBundles(this.addon).containsKey(uniqueId))
            {
                context.getForWhom().sendRawMessage(
                    user.getTranslation("commands.admin.blueprint.management.name.pick-a-unique-name"));
                return this;
            }
            context.setSessionData("uniqueId", uniqueId);
        }
        else
        {
            // Default stays as default
            context.setSessionData("uniqueId", this.bb.getUniqueId());
        }
        context.setSessionData("name", input);
        return new NameSuccessPrompt(this.addon, this.bb, this.bp);
    }
}
package world.bentobox.bentobox.api.addons;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import org.bukkit.Bukkit;
import org.bukkit.Server;
import org.bukkit.configuration.InvalidConfigurationException;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.event.Listener;
import com.github.puregero.multilib.MultiLib;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.request.AddonRequestHandler;
import world.bentobox.bentobox.api.flags.Flag;
import world.bentobox.bentobox.managers.IslandsManager;
import world.bentobox.bentobox.managers.PlayersManager;
import world.bentobox.bentobox.util.Util;
/**
 * Add-on class for BentoBox. Extend this to create an add-on. The operation
 * and methods are very similar to Bukkit's JavaPlugin.
 *
 * @author tastybento, ComminQ_Q
 */
public abstract class Addon {
    private static final String ADDON_CONFIG_FILENAME = "config.yml";
    private State state;
    private AddonDescription description;
    private FileConfiguration config;
    private File dataFolder;
    private File file;
    private final Map<String, AddonRequestHandler> requestHandlers = new HashMap<>();
    protected Addon() {
        state = State.DISABLED;
        if (!Util.inTest()) {
            // If the config is updated, update the config.
            MultiLib.onString(getPlugin(), "bentobox-config-update", v -> this.reloadConfig());
        }
    }
    /**
     * Executes code when enabling the addon.
     * This is called after {@link #onLoad()}.
     * <br/>
     * Note that commands and worlds registration <b>must</b> be done in {@link #onLoad()}, if need be.
     * Failure to do so <b>will</b> result in issues such as tab-completion not working for commands.
     */
    public abstract void onEnable();
    /**
     * Executes code when disabling the addon.
     */
    public abstract void onDisable();
    /**
     * Executes code when loading the addon.
     * This is called before {@link #onEnable()}.
     * This <b>must</b> be used to setup configuration, worlds and commands.
     */
    public void onLoad() {}
    /**
     * Executes code when reloading the addon.
     */
    public void onReload() {}
    public BentoBox getPlugin() {
        return BentoBox.getInstance();
    }
    /**
     * Represents the current run-time state of a {@link Addon}.
     *
     * @author Poslovitch
     */
    public enum State {
        /**
         * The addon has been correctly loaded.
         * @since 1.1
         */
        LOADED,
        /**
         * The addon has been correctly enabled and is now fully working.
         */
        ENABLED,
        /**
         * The addon is fully disabled.
         */
        DISABLED,
        /**
         * The addon has not been loaded because it requires a different version of BentoBox or of the server software.
         */
        INCOMPATIBLE,
        /**
         * The addon has not been enabled because a dependency is missing.
         */
        MISSING_DEPENDENCY,
        /**
         * The addon loading or enabling process has been interrupted by an unhandled error.
         */
        ERROR
    }
    /**
     * @return the addon's default config file
     */
    public FileConfiguration getConfig() {
        if (config == null) {
            config = loadYamlFile();
        }
        return config;
    }
    /**
     * @return Addon's data folder
     */
    public File getDataFolder() {
        return dataFolder;
    }
    /**
     * @return Addon's description
     */
    public AddonDescription getDescription() {
        return description;
    }
    /**
     * @return the file
     */
    public File getFile() {
        return file;
    }
    /**
     * @return Logger
     */
    public Logger getLogger() {
        return getPlugin().getLogger();
    }
    /**
     * Convenience method to obtain the server
     *
     * @return the server object
     */
    public Server getServer() {
        return Bukkit.getServer();
    }
    public boolean isEnabled() {
        return state == State.ENABLED;
    }
    /**
     * Gets the current {@link State} of this Addon.
     * @return the current State of this Addon.
     * @since 1.1
     */
    public State getState() {
        return state;
    }
    /**
     * Load YAML config file
     *
     * @return Yaml File configuration
     */
    private FileConfiguration loadYamlFile() {
        File yamlFile = new File(dataFolder, ADDON_CONFIG_FILENAME);
        YamlConfiguration yamlConfig = null;
        if (yamlFile.exists()) {
            try {
                yamlConfig = new YamlConfiguration();
                yamlConfig.load(yamlFile);
            } catch (Exception e) {
                Bukkit.getLogger().severe(() -> "Could not load config.yml: " + e.getMessage());
            }
        }
        return yamlConfig;
    }
    /**
     * Register a listener for this addon. This MUST be used in order for the addon to be reloadable
     *
     * @param listener - listener
     */
    public void registerListener(Listener listener) {
        BentoBox.getInstance().getAddonsManager().registerListener(this, listener);
    }
    /**
     * Saves the FileConfiguration retrievable by getConfig().
     */
    public void saveConfig() {
        try {
            getConfig().save(new File(dataFolder, ADDON_CONFIG_FILENAME));
        } catch (IOException e) {
            Bukkit.getLogger().severe("Could not save config! " + this.getDescription().getName() + " " + e.getMessage());
        }
    }
    /**
     * Discards any data in getConfig() and reloads from disk.
     * @since 1.13.0
     */
    public void reloadConfig() {
        config = loadYamlFile();
    }
    /**
     * Saves the addon's config.yml file to the addon's data folder and loads it. If
     * the file exists already, it will not be replaced.
     */
    public void saveDefaultConfig() {
        saveResource(ADDON_CONFIG_FILENAME, false);
        config = loadYamlFile();
    }
    /**
     * Saves a resource contained in this add-on's jar file to the addon's data
     * folder.
     *
     * @param resourcePath
     *            in jar file
     * @param replace
     *            - if true, will overwrite previous file
     */
    public void saveResource(String resourcePath, boolean replace) {
        saveResource(resourcePath, dataFolder, replace, false);
    }
    /**
     * Saves a resource contained in this add-on's jar file to the destination
     * folder.
     *
     * @param jarResource
     *            in jar file
     * @param destinationFolder
     *            on file system
     * @param replace
     *            - if true, will overwrite previous file
     * @param noPath
     *            - if true, the resource's path will be ignored when saving
     * @return file written, or null if none
     */
    public File saveResource(String jarResource, File destinationFolder, boolean replace, boolean noPath) {
        if (jarResource == null || jarResource.equals("")) {
            throw new IllegalArgumentException("ResourcePath cannot be null or empty");
        }
        jarResource = jarResource.replace('\\', '/');
        try (JarFile jar = new JarFile(file)) {
            JarEntry jarConfig = jar.getJarEntry(jarResource);
            if (jarConfig != null) {
                try (InputStream in = jar.getInputStream(jarConfig)) {
                    if (in == null) {
                        throw new IllegalArgumentException(
                                "The embedded resource '" + jarResource + "' cannot be found in " + jar.getName());
                    }
                    // There are two options, use the path of the resource or not
                    File outFile = new File(destinationFolder,
                            jarResource.replaceAll("/", Matcher.quoteReplacement(File.separator)));
                    if (noPath) {
                        outFile = new File(destinationFolder, outFile.getName());
                    }
                    // Make any dirs that need to be made
                    outFile.getParentFile().mkdirs();
                    if (!outFile.exists() || replace) {
                        java.nio.file.Files.copy(in, outFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
                    }
                    return outFile;
                }
            } else {
                // No file in the jar
                throw new IllegalArgumentException(
                        "The embedded resource '" + jarResource + "' cannot be found in " + jar.getName());
            }
        } catch (IOException e) {
            BentoBox.getInstance().logError(
                    "Could not save from jar file. From " + jarResource + " to " + destinationFolder.getAbsolutePath());
        }
        return null;
    }
    /**
     * Tries to load a YAML file from the Jar
     * @param jarResource - YAML file in jar
     * @return YamlConfiguration - may be empty
     * @throws IOException - if the file cannot be found or loaded from the Jar
     * @throws InvalidConfigurationException - if the yaml is malformed
     */
    public YamlConfiguration getYamlFromJar(String jarResource) throws IOException, InvalidConfigurationException {
        if (jarResource == null || jarResource.equals("")) {
            throw new IllegalArgumentException("jarResource cannot be null or empty");
        }
        YamlConfiguration result = new YamlConfiguration();
        jarResource = jarResource.replace('\\', '/');
        try (JarFile jar = new JarFile(file)) {
            JarEntry jarConfig = jar.getJarEntry(jarResource);
            if (jarConfig != null) {
                try (InputStreamReader in = new InputStreamReader(jar.getInputStream(jarConfig))) {
                    result.load(in);
                }
            }
        }
        return result;
    }
    /**
     * Get the resource from Jar file
     * @param jarResource - jar resource filename
     * @return resource or null if there is a problem
     */
    public InputStream getResource(String jarResource) {
        if (jarResource == null || jarResource.equals("")) {
            throw new IllegalArgumentException("ResourcePath cannot be null or empty");
        }
        jarResource = jarResource.replace('\\', '/');
        try (JarFile jar = new JarFile(file)) {
            JarEntry jarConfig = jar.getJarEntry(jarResource);
            if (jarConfig != null) {
                try (InputStream in = jar.getInputStream(jarConfig)) {
                    return in;
                }
            }
        } catch (IOException e) {
            Bukkit.getLogger().severe("Could not open from jar file. " + jarResource);
        }
        return null;
    }
    /**
     * Set the file that contains this addon
     *
     * @param f the file to set
     */
    public void setFile(File f) {
        file = f;
    }
    /**
     * Set this addon's data folder
     *
     * @param file - data folder
     */
    public void setDataFolder(File file) {
        dataFolder = file;
    }
    /**
     * Set this addons description
     *
     * @param description - description
     */
    public void setDescription(AddonDescription description) {
        this.description = description;
    }
    /**
     * Sets the addon's state.
     * @param state the state to set
     */
    public void setState(State state) {
        this.state = state;
    }
    /**
     * Get Players Manager
     * @return Players manager
     */
    public PlayersManager getPlayers() {
        return getPlugin().getPlayers();
    }
    /**
     * Get Islands Manager
     * @return Islands manager
     */
    public IslandsManager getIslands() {
        return getPlugin().getIslands();
    }
    /**
     * Get Islands Manager
     * @return Islands manager
     * @see #getIslands()
     * @since 1.17.1
     */
    public IslandsManager getIslandsManager() {
        return getPlugin().getIslandsManager();
    }
    /**
     * Get the Addon By Name
     * @return Optional Addon
     */
    public Optional<Addon> getAddonByName(String name) {
        return getPlugin().getAddonsManager().getAddonByName(name);
    }
    public void log(String string) {
        getPlugin().log(getDescription() != null ? "[" + getDescription().getName() + "] " + string : string);
    }
    public void logWarning(String string) {
        getPlugin().logWarning(getDescription() != null ? "[" + getDescription().getName() + "] " + string : string);
    }
    public void logError(String string) {
        getPlugin().logError(getDescription() != null ? "[" + getDescription().getName() + "] " + string : string);
    }
    /**
     * Returns the permission prefix corresponding to this addon.
     * It contains the addon's name plus a trailing dot.
     * @return Permission prefix string
     */
    public String getPermissionPrefix() {
        return this.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".";
    }
    /**
     * Register request handler to answer requests from plugins.
     * @param handler request handler
     */
    public void registerRequestHandler(AddonRequestHandler handler) {
        requestHandlers.put(handler.getLabel(), handler);
    }
    /**
     * Send request to addon.
     * @param label label
     * @param metaData meta data
     * @return request response, null if no response.
     */
    public Object request(String label, Map<String, Object> metaData) {
        label = label.toLowerCase(Locale.ENGLISH);
        AddonRequestHandler handler = requestHandlers.get(label);
        if(handler != null) {
            return handler.handle(metaData);
        } else {
            return null;
        }
    }
    /**
     * Register a flag for this addon.
     * @param flag the flag to register.
     * @return {@code true} if the flag was registered successfully, {@code false} otherwise.
     * @since 1.5.0
     */
    public boolean registerFlag(Flag flag) {
        return getPlugin().getFlagsManager().registerFlag(this, flag);
    }
    /**
     * Called when all addons have been loaded by BentoBox
     * @since 1.8.0
     */
    public void allLoaded() {}
}
package world.bentobox.bentobox.util;
import java.io.IOException;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Enumeration;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.Nonnull;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.Server;
import org.bukkit.World;
import org.bukkit.World.Environment;
import org.bukkit.attribute.Attribute;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.Allay;
import org.bukkit.entity.Animals;
import org.bukkit.entity.Bat;
import org.bukkit.entity.EnderDragon;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Flying;
import org.bukkit.entity.IronGolem;
import org.bukkit.entity.Monster;
import org.bukkit.entity.Player;
import org.bukkit.entity.PufferFish;
import org.bukkit.entity.Shulker;
import org.bukkit.entity.Slime;
import org.bukkit.entity.Snowman;
import org.bukkit.entity.Tameable;
import org.bukkit.entity.WaterMob;
import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.google.common.base.Enums;
import com.google.common.base.Optional;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.nms.PasteHandler;
import world.bentobox.bentobox.nms.WorldRegenerator;
/**
 * A set of utility methods
 *
 * @author tastybento
 * @author Poslovitch
 */
public class Util {
    /**
     * Use standard color code definition: {@code &<hex>}.
     */
    private static final Pattern HEX_PATTERN = Pattern.compile("&#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})");
    private static final String NETHER = "_nether";
    private static final String THE_END = "_the_end";
    private static String serverVersion = null;
    private static BentoBox plugin = BentoBox.getInstance();
    private static PasteHandler pasteHandler = null;
    private static WorldRegenerator regenerator = null;
    private Util() {}
    /**
     * Used for testing only
     */
    public static void setPlugin(BentoBox p) {
        plugin = p;
    }
    /**
     * Returns the server version
     * @return server version
     */
    public static String getServerVersion() {
        if (serverVersion == null) {
            String serverPackageName = Bukkit.getServer().getClass().getPackage().getName();
            serverVersion = serverPackageName.substring(serverPackageName.lastIndexOf('.') + 1);
        }
        return serverVersion;
    }
    /**
     * This returns the coordinate of where an island should be on the grid.
     *
     * @param location - the location location to query
     * @return Location of closest island
     */
    public static Location getClosestIsland(Location location) {
        int dist = plugin.getIWM().getIslandDistance(location.getWorld()) * 2;
        long x = Math.round((double) location.getBlockX() / dist) * dist + plugin.getIWM().getIslandXOffset(location.getWorld());
        long z = Math.round((double) location.getBlockZ() / dist) * dist + plugin.getIWM().getIslandZOffset(location.getWorld());
        int y = plugin.getIWM().getIslandHeight(location.getWorld());
        return new Location(location.getWorld(), x, y, z);
    }
    /**
     * Converts a serialized location to a Location. Returns null if string is
     * empty
     *
     * @param s - serialized location in format "world:x:y:z:y:p"
     * @return Location
     */
    public static Location getLocationString(final String s) {
        if (s == null || s.trim().equals("")) {
            return null;
        }
        final String[] parts = s.split(":");
        if (parts.length == 6) {
            final World w = Bukkit.getWorld(parts[0]);
            if (w == null) {
                return null;
            }
            // Parse string as double just in case
            int x = (int) Double.parseDouble(parts[1]);
            int y = (int) Double.parseDouble(parts[2]);
            int z = (int) Double.parseDouble(parts[3]);
            final float yaw = Float.intBitsToFloat(Integer.parseInt(parts[4]));
            final float pitch = Float.intBitsToFloat(Integer.parseInt(parts[5]));
            return new Location(w, x + 0.5D, y, z + 0.5D, yaw, pitch);
        }
        return null;
    }
    /**
     * Converts a location to a simple string representation
     * If location is null, returns empty string
     * Only stores block ints. Inverse function returns block centers
     *
     * @param l - the location
     * @return String of location in format "world:x:y:z:y:p"
     */
    public static String getStringLocation(final Location l) {
        if (l == null || l.getWorld() == null) {
            return "";
        }
        return l.getWorld().getName() + ":" + l.getBlockX() + ":" + l.getBlockY() + ":" + l.getBlockZ() + ":" + Float.floatToIntBits(l.getYaw()) + ":" + Float.floatToIntBits(l.getPitch());
    }
    /**
     * Converts a name like IRON_INGOT into Iron Ingot to improve readability
     *
     * @param ugly
     *            The string such as IRON_INGOT
     * @return A nicer version, such as Iron Ingot
     *
     *         Credits to mikenon on GitHub!
     */
    public static String prettifyText(String ugly) {
        StringBuilder fin = new StringBuilder();
        ugly = ugly.toLowerCase(java.util.Locale.ENGLISH);
        if (ugly.contains("_")) {
            String[] splt = ugly.split("_");
            int i = 0;
            for (String s : splt) {
                i += 1;
                fin.append(Character.toUpperCase(s.charAt(0))).append(s.substring(1));
                if (i < splt.length) {
                    fin.append(" ");
                }
            }
        } else {
            fin.append(Character.toUpperCase(ugly.charAt(0))).append(ugly.substring(1));
        }
        return fin.toString();
    }
    /**
     * Return an immutable list of online players this player can see, i.e. are not invisible
     * @param user - the User - if null, all player names on the server are shown
     * @return a list of online players this player can see
     */
    public static List<String> getOnlinePlayerList(User user) {
        if (user == null || !user.isPlayer()) {
            // Console and null get to see every player
            return Bukkit.getOnlinePlayers().stream().map(Player::getName).toList();
        }
        // Otherwise prevent invisible players from seeing
        return Bukkit.getOnlinePlayers().stream().filter(p -> user.getPlayer().canSee(p)).map(Player::getName).toList();
    }
    /**
     * Returns all of the items that begin with the given start,
     * ignoring case.  Intended for tabcompletion.
     *
     * @param list - string list
     * @param start - first few chars of a string
     * @return List of items that start with the letters
     */
    public static List<String> tabLimit(final List<String> list, final String start) {
        final List<String> returned = new ArrayList<>();
        for (String s : list) {
            if (s == null) {
                continue;
            }
            if (s.toLowerCase(java.util.Locale.ENGLISH).startsWith(start.toLowerCase(java.util.Locale.ENGLISH))) {
                returned.add(s);
            }
        }
        return returned;
    }
    public static String xyz(Vector location) {
        return location.getBlockX() + "," + location.getBlockY() + "," + location.getBlockZ();
    }
    /**
     * Checks is world = world2 irrespective of the world type. Only strips _nether and _the_end from world name.
     * @param world - world
     * @param world2 - world
     * @return true if the same
     */
    public static boolean sameWorld(World world, World world2) {
        return stripName(world).equals(stripName(world2));
    }
    private static String stripName(World world) {
        if (world.getName().endsWith(NETHER)) {
            return world.getName().substring(0, world.getName().length() - NETHER.length());
        }
        if (world.getName().endsWith(THE_END)) {
            return world.getName().substring(0, world.getName().length() - THE_END.length());
        }
        return world.getName();
    }
    /**
     * Convert world to an overworld
     * @param world - world
     * @return over world or null if world is null or a world cannot be found
     */
    @Nullable
    public static World getWorld(@Nullable World world) {
        if (world == null) {
            return null;
        }
        return world.getEnvironment().equals(Environment.NORMAL) ? world : Bukkit.getWorld(world.getName().replace(NETHER, "").replace(THE_END, ""));
    }
    /**
     * Lists files found in the jar in the folderPath with the suffix given
     * @param jar - the jar file
     * @param folderPath - the path within the jar
     * @param suffix - the suffix required
     * @return a list of files
     */
    public static List<String> listJarFiles(JarFile jar, String folderPath, String suffix) {
        List<String> result = new ArrayList<>();
        Enumeration<JarEntry> entries = jar.entries();
        while (entries.hasMoreElements()) {
            JarEntry entry = entries.nextElement();
            String path = entry.getName();
            if (!path.startsWith(folderPath)) {
                continue;
            }
            if (entry.getName().endsWith(suffix)) {
                result.add(entry.getName());
            }
        }
        return result;
    }
    /**
     * Converts block face direction to radial degrees. Returns 0 if block face
     * is not radial.
     *
     * @param face - blockface
     * @return degrees
     */
    public static float blockFaceToFloat(BlockFace face) {
        return switch (face) {
        case EAST -> 90F;
        case EAST_NORTH_EAST -> 67.5F;
        case NORTH_EAST -> 45F;
        case NORTH_NORTH_EAST -> 22.5F;
        case NORTH_NORTH_WEST -> 337.5F;
        case NORTH_WEST -> 315F;
        case SOUTH -> 180F;
        case SOUTH_EAST -> 135F;
        case SOUTH_SOUTH_EAST -> 157.5F;
        case SOUTH_SOUTH_WEST -> 202.5F;
        case SOUTH_WEST -> 225F;
        case WEST -> 270F;
        case WEST_NORTH_WEST -> 292.5F;
        case WEST_SOUTH_WEST -> 247.5F;
        default -> 0F;
        };
    }
    /**
     * Returns a Date instance corresponding to the input, or null if the input could not be parsed.
     * @param gitHubDate the input to parse
     * @return the Date instance following a {@code yyyy-MM-dd HH:mm:ss} format, or {@code null}.
     * @since 1.3.0
     */
    @Nullable
    public static Date parseGitHubDate(@NonNull String gitHubDate) {
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        try {
            return format.parse(gitHubDate.replace('T', ' ').replace("Z", ""));
        } catch (ParseException e) {
            return null;
        }
    }
    /**
     * Returns whether this entity is naturally hostile towards the player or not.
     * @param entity the entity to check.
     * @return {@code true} if this entity is hostile, {@code false} otherwise.
     * @since 1.4.0
     */
    public static boolean isHostileEntity(Entity entity) {
        // MagmaCube extends Slime
        // Slime extends Mob
        // Ghast and Phantom extends Flying
        // Flying extends Mob
        // Shulker is Golem, but other Golems cannot be added here.
        // EnderDragon extends LivingEntity
        // Most of hostile mobs extends Monster.
        // PufferFish is a unique fix.
        return entity instanceof Monster || entity instanceof Flying || entity instanceof Slime ||
                entity instanceof Shulker || entity instanceof EnderDragon || entity instanceof PufferFish;
    }
    /**
     * Returns whether this entity is naturally passive towards the player or not.
     * This means that this entity normally won't hurt the player.
     * @param entity the entity to check.
     * @return {@code true} if this entity is passive, {@code false} otherwise.
     * @since 1.4.0
     */
    public static boolean isPassiveEntity(Entity entity) {
        // IronGolem and Snowman extends Golem, but Shulker also extends Golem
        // Fishes, Dolphin and Squid extends WaterMob | Excludes PufferFish
        // Bat extends Mob
        // Most of passive mobs extends Animals
        return entity instanceof Animals || entity instanceof IronGolem || entity instanceof Snowman ||
                entity instanceof WaterMob && !(entity instanceof PufferFish) || entity instanceof Bat ||
                entity instanceof Allay;
    }
    public static boolean isTamableEntity(Entity entity) {
        return entity instanceof Tameable && ((Tameable) entity).isTamed();
    }
    /*
     * PaperLib methods for addons to call
     */
    /**
     * Teleports an Entity to the target location, loading the chunk asynchronously first if needed.
     * @param entity The Entity to teleport
     * @param location The Location to Teleport to
     * @return Future that completes with the result of the teleport
     */
    @NonNull
    public static CompletableFuture<Boolean> teleportAsync(@Nonnull Entity entity, @Nonnull Location location) {
        return teleportAsync(entity, location, TeleportCause.UNKNOWN);
    }
    /**
     * Teleports an Entity to the target location, loading the chunk asynchronously first if needed.
     * @param entity The Entity to teleport
     * @param location The Location to Teleport to
     * @param cause The cause for the teleportation
     * @return Future that completes with the result of the teleport
     */
    @SuppressWarnings("unchecked")
    @NonNull
    public static CompletableFuture<Boolean> teleportAsync(@Nonnull Entity entity, @Nonnull Location location,
            TeleportCause cause) {
        try {
            // Use reflection to check if the method exists
            Method method = Entity.class.getMethod("teleportAsync", Location.class, TeleportCause.class);
            if (method != null) {
                // Invoke the method using reflection on the entity instance
                return (CompletableFuture<Boolean>) method.invoke(entity, location, cause);
            }
        } catch (NoSuchMethodException e) {
            // Method does not exist, fallback to Spigot behavior
        } catch (Exception e) {
            plugin.logStacktrace(e); // Report other exceptions
        }
        // Fallback for Spigot servers
        entity.teleport(location, cause);
        return CompletableFuture.completedFuture(true);
    }
    /**
     * Gets the chunk at the target location, loading it asynchronously if needed.
     * @param loc Location to get chunk for
     * @return Future that completes with the chunk
     */
    @NonNull
    public static CompletableFuture<Chunk> getChunkAtAsync(@NonNull Location loc) {
        return getChunkAtAsync(Objects.requireNonNull(loc.getWorld()), loc.getBlockX() >> 4, loc.getBlockZ() >> 4,
                true);
    }
    /**
     * Gets the chunk at the target location, loading it asynchronously if needed.
     * @param loc Location to get chunk for
     * @param gen Should the chunk generate or not. Only respected on some MC versions, 1.13 for CB, 1.12 for Paper
     * @return Future that completes with the chunk, or null if the chunk did not exists and generation was not requested.
     */
    @NonNull
    public static CompletableFuture<Chunk> getChunkAtAsync(@NonNull Location loc, boolean gen) {
        return getChunkAtAsync(Objects.requireNonNull(loc.getWorld()), loc.getBlockX() >> 4, loc.getBlockZ() >> 4, gen);
    }
    /**
     * Gets the chunk at the target location, loading it asynchronously if needed.
     * @param world World to load chunk for
     * @param x X coordinate of the chunk to load
     * @param z Z coordinate of the chunk to load
     * @return Future that completes with the chunk
     */
    @NonNull
    public static CompletableFuture<Chunk> getChunkAtAsync(@Nonnull World world, int x, int z) {
        return getChunkAtAsync(world, x, z, true);
    }
    /**
     * Gets the chunk at the target location, loading it asynchronously if needed.
     * @param world World to load chunk for
     * @param x X coordinate of the chunk to load
     * @param z Z coordinate of the chunk to load
     * @param gen Should the chunk generate or not. Only respected on some MC versions, 1.13 for CB, 1.12 for Paper
     * @return Future that completes with the chunk, or null if the chunk did not exists and generation was not requested.
     */
    @SuppressWarnings("unchecked")
    @NonNull
    public static CompletableFuture<Chunk> getChunkAtAsync(@Nonnull World world, int x, int z, boolean gen) {
        try {
            // Use reflection to check if the method exists
            Method method = World.class.getMethod("getChunkAtAsync", int.class, int.class, boolean.class);
            if (method != null) {
                // Invoke the method using reflection
                return (CompletableFuture<Chunk>) method.invoke(world, x, z, gen);
            }
        } catch (NoSuchMethodException e) {
            // Method does not exist, fallback to Spigot behavior
        } catch (Exception e) {
            e.printStackTrace(); // Handle other exceptions (optional)
        }
        // Fallback for Spigot servers
        return CompletableFuture.completedFuture(world.getChunkAt(x, z, gen));
    }
    /**
     * Checks if the chunk has been generated or not. Only works on Paper 1.12+ or any 1.13.1+ version
     * @param loc Location to check if the chunk is generated
     * @return If the chunk is generated or not
     */
    public static boolean isChunkGenerated(@NonNull Location loc) {
        return isChunkGenerated(Objects.requireNonNull(loc.getWorld()), loc.getBlockX() >> 4, loc.getBlockZ() >> 4);
    }
    /**
     * Checks if the chunk has been generated or not. Only works on Paper 1.12+ or any 1.13.1+ version
     * @param world World to check for
     * @param x X coordinate of the chunk to check
     * @param z Z coordinate of the chunk to checl
     * @return If the chunk is generated or not
     */
    public static boolean isChunkGenerated(@Nonnull World world, int x, int z) {
        return world.isChunkGenerated(x, z);
    }
    /**
     * Checks if the given version is compatible with the required version.
     * 
     * <p>
     * A version is considered compatible if:
     * <ul>
     *   <li>The major, minor, and patch components of the given version are greater than or equal to those of the required version.</li>
     *   <li>If the numeric components are equal, the absence of "-SNAPSHOT" in the given version takes precedence (i.e., release versions are considered more compatible than SNAPSHOT versions).</li>
     * </ul>
     * </p>
     * 
     * @param version          the version to check, in the format "major.minor.patch[-SNAPSHOT]".
     * @param requiredVersion  the required version, in the format "major.minor.patch[-SNAPSHOT]".
     * @return {@code true} if the given version is compatible with the required version; {@code false} otherwise.
     * 
     * <p>
     * Examples:
     * <ul>
     *   <li>{@code isVersionCompatible("2.1.0", "2.0.0-SNAPSHOT")} returns {@code true}</li>
     *   <li>{@code isVersionCompatible("2.0.0", "2.0.0-SNAPSHOT")} returns {@code true}</li>
     *   <li>{@code isVersionCompatible("2.0.0-SNAPSHOT", "2.0.0")} returns {@code false}</li>
     *   <li>{@code isVersionCompatible("1.9.9", "2.0.0-SNAPSHOT")} returns {@code false}</li>
     * </ul>
     * </p>
     */
    public static boolean isVersionCompatible(String version, String requiredVersion) {
        String[] versionParts = version.replace("-SNAPSHOT", "").split("\\.");
        String[] requiredVersionParts = requiredVersion.replace("-SNAPSHOT", "").split("\\.");
        for (int i = 0; i < Math.max(versionParts.length, requiredVersionParts.length); i++) {
            int vPart = i < versionParts.length ? Integer.parseInt(versionParts[i]) : 0;
            int rPart = i < requiredVersionParts.length ? Integer.parseInt(requiredVersionParts[i]) : 0;
            if (vPart > rPart) {
                return true;
            } else if (vPart < rPart) {
                return false;
            }
        }
        // If numeric parts are equal, prioritize SNAPSHOT as lower precedence
        boolean isVersionSnapshot = version.contains("-SNAPSHOT");
        boolean isRequiredSnapshot = requiredVersion.contains("-SNAPSHOT");
        // If required version is a full release but current version is SNAPSHOT, it's incompatible
        return !(!isRequiredSnapshot && isVersionSnapshot);
    }
    /**
     * Check if the server has access to the Paper API
     * @return True for Paper environments
     */
    public static boolean isPaper() {
        try {
            Class.forName("com.destroystokyo.paper.PaperConfig");
            return true; // Paper-specific class exists
        } catch (ClassNotFoundException e) {
            return false; // Not a Paper server
        }
    }
    /**
     * This method translates color codes in given string and strips whitespace after them.
     * This code parses both: hex and old color codes.
     * @param textToColor Text which color codes must be parsed.
     * @return String text with parsed colors and stripped whitespaces after them.
     */
    @SuppressWarnings("deprecation")
    @NonNull
    public static String translateColorCodes(@NonNull String textToColor) {
        // Use matcher to find hex patterns in given text.
        Matcher matcher = HEX_PATTERN.matcher(textToColor);
        // Increase buffer size by 32 like it is in bungee cord api. Use buffer because it is sync.
        StringBuilder buffer = new StringBuilder(textToColor.length() + 32);
        while (matcher.find()) {
            String group = matcher.group(1);
            if (group.length() == 6) {
                // Parses #ffffff to a color text.
                matcher.appendReplacement(buffer, ChatColor.COLOR_CHAR + "x"
                        + ChatColor.COLOR_CHAR + group.charAt(0) + ChatColor.COLOR_CHAR + group.charAt(1)
                        + ChatColor.COLOR_CHAR + group.charAt(2) + ChatColor.COLOR_CHAR + group.charAt(3)
                        + ChatColor.COLOR_CHAR + group.charAt(4) + ChatColor.COLOR_CHAR + group.charAt(5));
            } else {
                // Parses #fff to a color text.
                matcher.appendReplacement(buffer, ChatColor.COLOR_CHAR + "x"
                        + ChatColor.COLOR_CHAR + group.charAt(0) + ChatColor.COLOR_CHAR + group.charAt(0)
                        + ChatColor.COLOR_CHAR + group.charAt(1) + ChatColor.COLOR_CHAR + group.charAt(1)
                        + ChatColor.COLOR_CHAR + group.charAt(2) + ChatColor.COLOR_CHAR + group.charAt(2));
            }
        }
        // transform normal codes and strip spaces after color code.
        return Util.stripSpaceAfterColorCodes(
                ChatColor.translateAlternateColorCodes('&', matcher.appendTail(buffer).toString()));
    }
    /**
     * Strips spaces immediately after color codes. Used by {@link User#getTranslation(String, String...)}.
     * @param textToStrip - text to strip
     * @return text with spaces after color codes removed
     * @since 1.9.0
     */
    @NonNull
    public static String stripSpaceAfterColorCodes(@NonNull String textToStrip) {
        if (textToStrip == null) return "";
        textToStrip = textToStrip.replaceAll("(" + ChatColor.COLOR_CHAR + ".)[\\s]", "$1");
        return textToStrip;
    }
    /**
     * Returns whether the input is an integer or not.
     * @param nbr the input.
     * @param parse whether the input should be checked to ensure it can be parsed as an Integer without throwing an exception.
     * @return {@code true} if the input is an integer, {@code false} otherwise.
     * @since 1.10.0
     */
    public static boolean isInteger(@NonNull String nbr, boolean parse) {
        // Original code from Jonas Klemming on StackOverflow (https://stackoverflow.com/q/237159).
        // I slightly refined it to catch more edge cases.
        // It is a faster alternative to catch malformed strings than the NumberFormatException.
        int length = nbr.length();
        if (length == 0) {
            return false;
        }
        int i = 0;
        if (nbr.charAt(0) == '-' || nbr.charAt(0) == '+') {
            if (length == 1) {
                return false;
            }
            i = 1;
        }
        boolean trailingDot = false;
        for (; i < length; i++) {
            char c = nbr.charAt(i);
            if (trailingDot && c != '0') {
                // We only accept 0's after a trailing dot.
                return false;
            }
            if (c == '.') {
                if (i == length - 1) {
                    // We're at the end of the integer, so it's okay
                    return true;
                } else {
                    // we will need to make sure there is nothing else but 0's after the dot.
                    trailingDot = true;
                }
            } else if (!trailingDot && (c < '0' || c > '9')) {
                return false;
            }
        }
        // these tests above should have caught most likely issues
        // We now need to make sure parsing the input as an Integer won't cause issues
        if (parse) {
            try {
                Integer.parseInt(nbr); // NOSONAR we don't care about the result of this operation
                return true;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        // Everything's green!
        return true;
    }
    /**
     * Get a UUID from a string. The string can be a known player's name or a UUID
     * @param nameOrUUID - name or UUID
     * @return UUID or null if unknown
     * @since 1.13.0
     */
    @Nullable
    public static UUID getUUID(@NonNull String nameOrUUID) {
        UUID targetUUID = plugin.getPlayers().getUUID(nameOrUUID);
        if (targetUUID != null) return targetUUID;
        // Check if UUID is being used
        try {
            return UUID.fromString(nameOrUUID);
        } catch (Exception e) {
            // Do nothing
        }
        return null;
    }
    /**
     * Run a list of commands for a user
     * @param user - user affected by the commands
     * @param commands - a list of commands
     * @param commandType - the type of command being run - used in the console error message
     */
    public static void runCommands(User user, @NonNull List<String> commands, String commandType) {
        runCommands(user, user.getName(), commands, commandType);
    }
    /**
     * Run a list of commands for a user
     * @param user - user affected by the commands
     * @param ownerName - name of the island owner, or the user's name if it is the user's island
     * @param commands - a list of commands
     * @param commandType - the type of command being run - used in the console error message
     * @since 1.22.0
     */
    public static void runCommands(User user, String ownerName, @NonNull List<String> commands, String commandType) {
        commands.forEach(command -> {
            command = command.replace("[player]", user.getName());
            command = command.replace("[owner]", ownerName);
            if (command.startsWith("[SUDO]")) {
                // Execute the command by the player
                if (!user.isOnline() || !user.performCommand(command.substring(6))) {
                    plugin.logError("Could not execute " + commandType + " command for " + user.getName() + ": " + command.substring(6));
                }
            } else {
                // Otherwise execute as the server console
                if (!Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command)) {
                    plugin.logError("Could not execute " + commandType + " command as console: " + command);
                }
            }
        });
    }
    /**
     * Resets the player's heath to maximum
     * @param player - player
     */
    public static void resetHealth(Player player) {
        try {
            // Paper
            double maxHealth = player.getAttribute(Attribute.MAX_HEALTH).getBaseValue();
            player.setHealth(maxHealth);
        } catch (Exception e) {
            // Spigot
            player.setHealth(20D);
        }
    }
    /**
     * Set the regenerator the plugin will use
     * @param regenerator the regenerator
     */
    public static void setRegenerator(WorldRegenerator regenerator) {
        Util.regenerator = regenerator;
    }
    /**
     * Get the regenerator the plugin will use
     * @return an accelerated regenerator class for this server
     */
    public static WorldRegenerator getRegenerator() {
        if (regenerator == null) {
            // Bukkit method that was added in 2011
            // Example value: 1.20.4-R0.1-SNAPSHOT
            final String bukkitVersion = "v" + Bukkit.getBukkitVersion().replace('.', '_').replace('-', '_');
            final String pluginPackageName = plugin.getClass().getPackage().getName();
            WorldRegenerator handler;
            try {
                Class<?> clazz = Class.forName(pluginPackageName + ".nms." + bukkitVersion + ".WorldRegeneratorImpl");
                if (WorldRegenerator.class.isAssignableFrom(clazz)) {
                    handler = (WorldRegenerator) clazz.getConstructor().newInstance();
                } else {
                    throw new IllegalStateException("Class " + clazz.getName() + " does not implement WorldRegenerator");
                }
            } catch (Exception e) {
                plugin.logWarning("No Regenerator found for " + bukkitVersion + ", falling back to Bukkit API.");
                handler = new world.bentobox.bentobox.nms.fallback.WorldRegeneratorImpl();
            }
            setRegenerator(handler);
        }
        return regenerator;
    }
    /**
     * Checks what version the server is running and picks the appropriate NMS handler, or fallback
     * @return PasteHandler
     */
    public static PasteHandler getPasteHandler() {
        if (pasteHandler == null) {
            // Bukkit method that was added in 2011
            // Example value: 1.20.4-R0.1-SNAPSHOT
            String bukkitVersion = "v" + Bukkit.getServer().getBukkitVersion().replace('.', '_').replace('-', '_');
            String pluginPackageName = plugin.getClass().getPackage().getName();
            BentoBox.getInstance().log("Optimizing for " + bukkitVersion);
            PasteHandler handler;
            try {
                Class<?> clazz = Class.forName(pluginPackageName + ".nms." + bukkitVersion + ".PasteHandlerImpl");
                if (PasteHandler.class.isAssignableFrom(clazz)) {
                    handler = (PasteHandler) clazz.getConstructor().newInstance();
                } else {
                    throw new IllegalStateException("Class " + clazz.getName() + " does not implement PasteHandler");
                }
            } catch (Exception e) {
                plugin.logWarning("No PasteHandler found for " + bukkitVersion + ", falling back to Bukkit API.");
                handler = new world.bentobox.bentobox.nms.fallback.PasteHandlerImpl();
            }
            setPasteHandler(handler);
        }
        return pasteHandler;
    }
    /**
     * Set the paste handler the plugin will use
     * @param pasteHandler the NMS paster
     */
    public static void setPasteHandler(PasteHandler pasteHandler) {
        Util.pasteHandler = pasteHandler;
    }
    /**
     * Broadcast a localized message to all players with the permission {@link Server#BROADCAST_CHANNEL_USERS}
     *
     * @param localeKey locale key for the message to broadcast
     * @param variables any variables for the message
     * @return number of message recipients
     */
    public static int broadcast(String localeKey, String... variables) {
        int count = 0;
        for (Player p : Bukkit.getOnlinePlayers()) {
            if (p.hasPermission(Server.BROADCAST_CHANNEL_USERS)) {
                User.getInstance(p).sendMessage(localeKey, variables);
                count++;
            }
        }
        return count;
    }
    /**
     * This method removes all special characters that are not allowed in filenames (windows).
     * It also includes any white-spaces, as for some reason, I do like it more without them.
     * Also, all cases are lower cased for easier blueprint mapping.
     * @param input Input that need to be sanitized.
     * @return A sanitized input without illegal characters in names.
     */
    @SuppressWarnings("deprecation")
    public static String sanitizeInput(String input)
    {
        return ChatColor.stripColor(
                Util.translateColorCodes(input.replaceAll("[\\\\/:*?\"<>|\s]", "_"))).
                toLowerCase();
    }
    /**
     * Attempts to find the first matching enum constant from an array of possible string representations.
     * This method sequentially checks each string against the enum constants of the specified enum class
     * by normalizing the string values to uppercase before comparison, enhancing the likelihood of a match
     * if the enum constants are defined in uppercase.
     *
     * @param enumClass the Class object of the enum type to be checked against
     * @param values an array of string values which are potential matches for the enum constants
     * @param <T> the type parameter of the enum
     * @return the first matching enum constant if a match is found; otherwise, returns null
     * @throws IOException 
     * @throws NullPointerException if either {@code enumClass} or {@code values} are null
     */
    public static <T extends Enum<T>> T findFirstMatchingEnum(Class<T> enumClass, String... values) {
        if (enumClass == null || values == null) {
            return null;
        }
        for (String value : values) {
            Optional<T> enumConstant = Enums.getIfPresent(enumClass, value.toUpperCase());
            if (enumConstant.isPresent()) {
                return enumConstant.get();
            }
        }
        return null; // Return null if no match is found
    }
    /**
     * This checks the stack trace for @Test to determine if a test is calling the code and skips.
     * @return true if it's a test.
     */
    public static boolean inTest() {
        return Arrays.stream(Thread.currentThread().getStackTrace()).anyMatch(e -> e.getClassName().endsWith("Test"));
    }
}
package world.bentobox.bentobox.api.addons;
import java.util.Optional;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.generator.ChunkGenerator;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.github.puregero.multilib.MultiLib;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.configuration.WorldSettings;
import world.bentobox.bentobox.util.Util;
/**
 * Defines the addon as a game mode.
 * A game mode creates worlds, registers world settings and has blueprints in a jar folder.
 * @author tastybento, Poslovitch
 */
public abstract class GameModeAddon extends Addon {
    protected World islandWorld;
    @Nullable
    protected World netherWorld;
    @Nullable
    protected World endWorld;
    /**
     * Main player command. Addons can use this hook to into this command.
     * @since 1.1
     */
    @Nullable
    protected CompositeCommand playerCommand;
    /**
     * Main admin command. Addons can use this hook to into this command.
     * @since 1.1
     */
    @Nullable
    protected CompositeCommand adminCommand;
    /**
     * Make the worlds for this GameMode in this method. BentoBox will call it
     * after onLoad() and before onEnable(). Do not register flags in this method.
     * They ,ust be registered afterwards in onEnable()
     * {@link #islandWorld} must be created and assigned,
     * {@link #netherWorld} and {@link #endWorld} are optional and may be null.
     */
    public abstract void createWorlds();
    /**
     * @return WorldSettings for this GameMode
     */
    public abstract WorldSettings getWorldSettings();
    /**
     * Checks if location is governed by this game mode
     * @param loc - location to check
     * @return true if location in covered by this addon or false if not
     */
    public boolean inWorld(Location loc) {
        return Util.sameWorld(loc.getWorld(), islandWorld);
    }
    /**
     * Checks if world is governed by this game mode
     * @param world - world to check
     * @return true if world in covered by this addon or false if not
     * @since 1.2.0
     */
    public boolean inWorld(World world) {
        if (world == null) {
            return false;
        }
        return Util.sameWorld(world, islandWorld);
    }
    /**
     * @return over world
     */
    public World getOverWorld() {
        return islandWorld;
    }
    /**
     * @return nether world, or null if it does not exist
     */
    @Nullable
    public World getNetherWorld() {
        return netherWorld;
    }
    /**
     * @return end world, or null if it does not exist
     */
    @Nullable
    public World getEndWorld() {
        return endWorld;
    }
    /**
     * @return the main player command for this Game Mode Addon
     * @since 1.1
     */
    @NonNull
    public Optional<CompositeCommand> getPlayerCommand() {
        return Optional.ofNullable(playerCommand);
    }
    /**
     * @return the main admin command for this Game Mode Addon
     * @since 1.1
     */
    @NonNull
    public Optional<CompositeCommand> getAdminCommand() {
        return Optional.ofNullable(adminCommand);
    }
    /**
     * Defines the world generator for this game mode
     * @param worldName - name of world that this applies to
     * @param id - id if any. "delete" is used when this request is for island deletion purposes
     * @return Chunk generator or null if one does not exist, e.g. the use own generator setting is true
     * @since 1.2.0
     */
    @Nullable
    public abstract ChunkGenerator getDefaultWorldGenerator(String worldName, String id);
    /**
     * Tells the Game Mode Addon to save its settings. Used when world settings are changed
     * in-game and need to be saved.
     * @since 1.4.0
     */
    public void saveWorldSettings() {
        // Inform other servers
        MultiLib.notify("bentobox-config-update", "");
    }
    
    /**
     * Defines if the game mode uses the latest {@link ChunkGenerator} API or 
     * deprecated {@link ChunkGenerator#generateChunkData(World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)} approach.
     * @return true if this game mode is a void world and should just be deleted as such
     */
    public boolean isUsesNewChunkGeneration() {
        return false;
    }
}
package world.bentobox.bentobox.api.commands.island;
import java.io.IOException;
import java.util.List;
import org.eclipse.jdt.annotation.NonNull;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.events.island.IslandEvent;
import world.bentobox.bentobox.api.events.island.IslandEvent.Reason;
import world.bentobox.bentobox.api.events.team.TeamEvent;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.managers.island.NewIsland;
import world.bentobox.bentobox.managers.island.NewIsland.Builder;
import world.bentobox.bentobox.panels.customizable.IslandCreationPanel;
import world.bentobox.bentobox.util.Util;
/**
 * @author tastybento
 */
public class IslandResetCommand extends ConfirmableCommand {
    private boolean noPaste;
    public IslandResetCommand(CompositeCommand islandCommand) {
        super(islandCommand, "reset", "restart");
    }
    /**
     * Creates the island reset command
     * 
     * @param islandCommand - parent command
     * @param noPaste       - true if resetting should not paste a new island
     */
    public IslandResetCommand(CompositeCommand islandCommand, boolean noPaste) {
        super(islandCommand, "reset", "restart");
        this.noPaste = noPaste;
    }
    @Override
    public void setup() {
        setPermission("island.reset");
        setOnlyPlayer(true);
        setParametersHelp("commands.island.reset.parameters");
        setDescription("commands.island.reset.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args) {
        // Check cooldown
        if (getSettings().getResetCooldown() > 0 && checkCooldown(user)) {
            return false;
        }
        if (!getIslands().hasIsland(getWorld(), user.getUniqueId())) {
            user.sendMessage("general.errors.no-island");
            return false;
        }
        int resetsLeft = getPlayers().getResetsLeft(getWorld(), user.getUniqueId());
        if (resetsLeft != -1) {
            // Resets are not unlimited here
            if (resetsLeft == 0) {
                // No resets allowed
                user.sendMessage("commands.island.reset.none-left");
                return false;
            } else {
                // Still some resets left
                // Notify how many resets are left
                user.sendMessage("commands.island.reset.resets-left", TextVariables.NUMBER, String.valueOf(resetsLeft));
            }
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        // Permission check if the name is not the default one
        if (!args.isEmpty()) {
            String name = getPlugin().getBlueprintsManager().validate(getAddon(), Util.sanitizeInput(args.get(0)));
            if (name == null || name.isEmpty()) {
                // The blueprint name is not valid.
                user.sendMessage("commands.island.create.unknown-blueprint");
                return false;
            }
            if (!getPlugin().getBlueprintsManager().checkPerm(getAddon(), user, Util.sanitizeInput(args.get(0)))) {
                return false;
            }
            return resetIsland(user, name);
        } else {
            // Show panel after confirmation
            if (getPlugin().getSettings().isResetConfirmation()) {
                this.askConfirmation(user, user.getTranslation("commands.island.reset.confirmation"),
                        () -> selectBundle(user, label));
            } else {
                selectBundle(user, label);
            }
            return true;
        }
    }
    /**
     * Either selects the bundle to use or asks the user to choose.
     * 
     * @since 1.5.1
     */
    private void selectBundle(@NonNull User user, @NonNull String label) {
        // Show panel only if there are multiple bundles available
        if (getPlugin().getBlueprintsManager().getBlueprintBundles(getAddon()).size() > 1) {
            // Show panel - once the player selected a bundle, this will re-run this command
            IslandCreationPanel.openPanel(this, user, label, true);
        } else {
            resetIsland(user, BlueprintsManager.DEFAULT_BUNDLE_NAME);
        }
    }
    /**
     * Reset island
     * 
     * @param user user
     * @param name name of Blueprint Bundle
     * @return true if successful
     */
    private boolean resetIsland(User user, String name) {
        // Get the player's old island
        Island oldIsland = getIslands().getIsland(getWorld(), user);
        deleteOldIsland(user, oldIsland);
        user.sendMessage("commands.island.create.creating-island");
        // Create new island and then delete the old one
        try {
            Builder builder = NewIsland.builder().player(user).reason(Reason.RESET).addon(getAddon())
                    .oldIsland(oldIsland).name(name);
            if (noPaste)
                builder.noPaste();
            builder.build();
        } catch (IOException e) {
            getPlugin().logError("Could not create island for player. " + e.getMessage());
            user.sendMessage(e.getMessage());
            return false;
        }
        setCooldown(user.getUniqueId(), getSettings().getResetCooldown());
        return true;
    }
    private void deleteOldIsland(User user, Island oldIsland) {
        // Fire island preclear event
        IslandEvent.builder().involvedPlayer(user.getUniqueId()).reason(Reason.PRECLEAR).island(oldIsland)
                .oldIsland(oldIsland).location(oldIsland.getCenter()).build();
        // Reset the island
        // Kick all island members (including the owner)
        kickMembers(oldIsland);
        // Add a reset
        getPlayers().addReset(getWorld(), user.getUniqueId());
    }
    /**
     * Kicks the members (incl. owner) of the island.
     * 
     * @since 1.7.0
     */
    private void kickMembers(Island island) {
        /*
         * We cannot assume the island owner can run /[cmd] team kick (it might be
         * disabled, or there could be permission restrictions...) Therefore, we need to
         * do it manually. Plus, a more specific team event (TeamDeleteEvent) is called
         * by this method.
         */
        island.getMemberSet().forEach(memberUUID -> {
            User member = User.getInstance(memberUUID);
            // Send a "you're kicked" message if the member is not the island owner (send
            // before removing!)
            if (!memberUUID.equals(island.getOwner())) {
                member.sendMessage("commands.island.reset.kicked-from-island", TextVariables.GAMEMODE,
                        getAddon().getDescription().getName());
            }
            // Remove player
            getIslands().removePlayer(island, memberUUID);
            // Clean player
            getPlayers().cleanLeavingPlayer(getWorld(), member, false, island);
            // Fire event
            TeamEvent.builder().island(island).reason(TeamEvent.Reason.DELETE).involvedPlayer(memberUUID).build();
        });
    }
}
package world.bentobox.bentobox.blueprints;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.bukkit.Material;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import com.google.gson.annotations.Expose;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBlock;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintEntity;
/**
 * Stores all details of a blueprint
 * @author tastybento
 *
 */
public class Blueprint {
    /**
     * Unique name for this blueprint. The filename will be this plus the blueprint suffix
     */
    @Expose
    private @NonNull String name = "";
    @Expose
    private String displayName;
    @Expose
    private @NonNull Material icon = Material.PAPER;
    @Expose
    private List<String> description;
    @Expose
    private Map<Vector, BlueprintBlock> attached;
    @Expose
    private Map<Vector, List<BlueprintEntity>> entities;
    @Expose
    private Map<Vector, BlueprintBlock> blocks;
    @Expose
    private int xSize;
    @Expose
    private int ySize;
    @Expose
    private int zSize;
    @Expose
    private Vector bedrock;
    /**
     * @return the name
     */
    @NonNull
    public String getName() {
        if (name == null) name = "unnamed";
        // Force lower case
        return name;
    }
    /**
     * @param name the name to set
     */
    public Blueprint setName(@NonNull String name) {
        // Force lowercase
        this.name = name;
        return this;
    }
    /**
     * @return the displayName
     */
    public String getDisplayName() {
        return displayName;
    }
    /**
     * @param displayName the displayName to set
     */
    public Blueprint setDisplayName(String displayName) {
        this.displayName = displayName;
        return this;
    }
    /**
     * @return the icon
     */
    public @NonNull Material getIcon() {
        return icon;
    }
    /**
     * @param icon the icon to set
     * @return blueprint
     */
    public Blueprint setIcon(Material icon) {
        this.icon = icon;
        return this;
    }
    /**
     * @return the description
     */
    public List<String> getDescription() {
        return description;
    }
    /**
     * @param description the description to set
     */
    public Blueprint setDescription(List<String> description) {
        this.description = description;
        return this;
    }
    /**
     * @param description the description to set
     */
    public Blueprint setDescription(String description) {
        if (this.description == null) this.description = new ArrayList<>();
        this.description.add(description);
        return this;
    }
    /**
     * @return the attached
     */
    public Map<Vector, BlueprintBlock> getAttached() {
        return attached;
    }
    /**
     * @param attached the attached to set
     */
    public void setAttached(Map<Vector, BlueprintBlock> attached) {
        this.attached = attached;
    }
    /**
     * @return the entities
     */
    public Map<Vector, List<BlueprintEntity>> getEntities() {
        return entities;
    }
    /**
     * @param entities the entities to set
     */
    public void setEntities(Map<Vector, List<BlueprintEntity>> entities) {
        if (this.entities == null) {
            this.entities = entities;
        } else {
            this.entities.putAll(entities);
        }
    }
    /**
     * @return the blocks
     */
    public Map<Vector, BlueprintBlock> getBlocks() {
        return blocks;
    }
    /**
     * @param blocks the blocks to set
     */
    public void setBlocks(Map<Vector, BlueprintBlock> blocks) {
        this.blocks = blocks;
    }
    /**
     * @return the xSize
     */
    public int getxSize() {
        return xSize;
    }
    /**
     * @param xSize the xSize to set
     */
    public void setxSize(int xSize) {
        this.xSize = xSize;
    }
    /**
     * @return the ySize
     */
    public int getySize() {
        return ySize;
    }
    /**
     * @param ySize the ySize to set
     */
    public void setySize(int ySize) {
        this.ySize = ySize;
    }
    /**
     * @return the zSize
     */
    public int getzSize() {
        return zSize;
    }
    /**
     * @param zSize the zSize to set
     */
    public void setzSize(int zSize) {
        this.zSize = zSize;
    }
    /**
     * @return the bedrock
     */
    public Vector getBedrock() {
        return bedrock;
    }
    /**
     * @param bedrock the bedrock to set
     */
    public void setBedrock(Vector bedrock) {
        this.bedrock = bedrock;
    }
}
package world.bentobox.bentobox.api.configuration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import org.bukkit.Difficulty;
import org.bukkit.GameMode;
import org.bukkit.entity.EntityType;
import org.eclipse.jdt.annotation.NonNull;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.flags.Flag;
import world.bentobox.bentobox.lists.Flags;
/**
 * Contains world-specific settings that must be provided by the {@link world.bentobox.bentobox.api.addons.GameModeAddon} in order to register its Worlds.
 * <br/>
 * Depending on your implementation, you may need to add setters.
 * @author tastybento
 */
public interface WorldSettings extends ConfigObject {
    /**
     * Get the default game mode for this game world, e.g. SURVIVAL
     * @return game mode
     */
    GameMode getDefaultGameMode();
    /**
     * @return default rank settings for new islands
     * @deprecated Map of Flag, Integer does not allow to load other plugin/addon flags.
     *             It cannot be replaced with Map of String, Integer due to compatibility issues.
     * @see WorldSettings#getDefaultIslandFlagNames()
     * @since 1.21.0
     */
    @Deprecated(since="1.21.0", forRemoval=true)
    Map<Flag, Integer> getDefaultIslandFlags();
    /**
     * Return map of flags ID's linked to default rank for new island.
     * This is necessary so users could specify any flag names in settings file from other plugins and addons.
     * Otherwise, Flag reader would mark flag as invalid and remove it.
     * Default implementation is compatibility layer so GameModes that are not upgraded still works.
     * @since 1.21
     * @return default rank settings for new islands.
     */
    default Map<String, Integer> getDefaultIslandFlagNames()
    {
        Map<String, Integer> flags = new HashMap<>();
        this.getDefaultIslandFlags().forEach((key, value) -> flags.put(key.getID(), value));
        return flags;
    }
    /**
     * @return default settings for new
     * @deprecated Map of Flag, Integer does not allow to load other plugin/addon flags.
     *             It cannot be replaced with Map of String, Integer due to compatibility issues.
     * @see WorldSettings#getDefaultIslandSettingNames()
     * @since 1.21.0
     */
    @Deprecated(since="1.21.0", forRemoval=true)
    Map<Flag, Integer> getDefaultIslandSettings();
    /**
     * Return map of flags ID's linked to default settings for new island.
     * This is necessary so users could specify any flag names in settings file from other plugins and addons.
     * Otherwise, Flag reader would mark flag as invalid and remove it.
     * Default implementation is compatibility layer so GameModes that are not upgraded still works.
     * @since 1.21.0
     * @return default settings for new islands.
     */
    default Map<String, Integer> getDefaultIslandSettingNames()
    {
        Map<String, Integer> flags = new HashMap<>();
        this.getDefaultIslandSettings().forEach((key, value) -> flags.put(key.getID(), value));
        return flags;
    }
    /**
     * Get the world difficulty
     * @return difficulty
     */
    Difficulty getDifficulty();
    /**
     * Set the world difficulty
     * @param difficulty - difficulty
     */
    void setDifficulty(Difficulty difficulty);
    /**
     * @return the friendly name of the world. Used in player commands
     */
    String getFriendlyName();
    /**
     * @return the islandDistance
     */
    int getIslandDistance();
    /**
     * @return the islandHeight
     */
    int getIslandHeight();
    /**
     * @return the islandProtectionRange
     */
    int getIslandProtectionRange();
    /**
     * @return the islandStartX
     */
    int getIslandStartX();
    /**
     * @return the islandStartZ
     */
    int getIslandStartZ();
    /**
     * @return the islandXOffset
     */
    int getIslandXOffset();
    /**
     * @return the islandZOffset
     */
    int getIslandZOffset();
    /**
     * @return Invincible Visitor setting list
     */
    List<String> getIvSettings();
    /**
     * @return the max homes
     */
    int getMaxHomes();
    /**
     * 0 or -1 is unlimited. It will block island creation if the island count for the world is higher than this.
     * @return the maxIslands
     */
    int getMaxIslands();
    /**
     * @return the max team size for this world
     */
    int getMaxTeamSize();
    /**
     * @return the max coop size for this world
     * @since 1.13.0
     */
    default int getMaxCoopSize() {
        return 4;
    }
    /**
     * @return the max trust size for this world
     * @since 1.13.0
     */
    default int getMaxTrustSize() {
        return 4;
    }
    /**
     * @return the netherSpawnRadius
     */
    int getNetherSpawnRadius();
    /**
     * @return the permission prefix
     */
    String getPermissionPrefix();
    /**
     * Get the set of entity types that should not be removed in this world when a player teleports to their island
     * @return set of entity types
     */
    Set<EntityType> getRemoveMobsWhitelist();
    /**
     * @return the seaHeight
     */
    int getSeaHeight();
    /**
     * @return hidden flag list
     */
    List<String> getHiddenFlags();
    /**
     * @return the visitorBannedCommands
     */
    List<String> getVisitorBannedCommands();
    /**
     * Optional list of commands that are banned when falling. Not applicable to all game modes so defaults to empty.
     * @return the fallingBannedCommands
     * @since 1.8.0
     */
    default List<String> getFallingBannedCommands() {
        return Collections.emptyList();
    }
    /**
     * Get world flags
     * @return Map of world flags
     */
    Map<String, Boolean> getWorldFlags();
    /**
     * @return the worldName
     */
    String getWorldName();
    /**
     * @return the dragonSpawn
     */
    boolean isDragonSpawn();
    /**
     * @return the endGenerate
     */
    boolean isEndGenerate();
    /**
     * @return the endIslands
     */
    boolean isEndIslands();
    /**
     * @return the netherGenerate
     */
    boolean isNetherGenerate();
    /**
     * @return the netherIslands
     */
    boolean isNetherIslands();
    /**
     * @return the onJoinResetEnderChest
     */
    boolean isOnJoinResetEnderChest();
    /**
     * @return the onJoinResetInventory
     */
    boolean isOnJoinResetInventory();
    /**
     * @return the onJoinResetMoney
     */
    boolean isOnJoinResetMoney();
    /**
     * Whether the player's health should be reset upon him joining an island or creating it.
     * @return the onJoinResetHealth
     * @since 1.8.0
     */
    boolean isOnJoinResetHealth();
    /**
     * Whether the player's hunger should be reset upon him joining an island or creating it.
     * @return the onJoinResetHunger
     * @since 1.8.0
     */
    boolean isOnJoinResetHunger();
    /**
     * Whether the player's XP should be reset upon him joining an island or creating it.
     * @return the onJoinResetXP
     * @since 1.8.0
     */
    boolean isOnJoinResetXP();
    /**
     * Returns a list of commands that should be executed when the player joins an island or creates one.<br/>
     * These commands are executed by the console, unless otherwise stated using the {@code [SUDO]} prefix, in which case they are executed by the player.<br/>
     * <br/>
     * Available placeholders for the commands are the following:
     * <ul>
     *     <li>{@code [player]}: name of the player</li>
     *     <li>{@code [owner]}: name of the owner of the island. When joining a team, this will be the team leader's name. When
     *     creating an island, it is the name of the player</li>
     * </ul>
     * <br/>
     * Here are some examples of valid commands to execute:
     * <ul>
     *     <li>{@code "[SUDO] bbox version"}</li>
     *     <li>{@code "bsbadmin deaths set [player] 0"}</li>
     * </ul>
     * @return a list of commands.
     * @since 1.8.0
     * @see #getOnLeaveCommands()
     */
    @NonNull
    List<String> getOnJoinCommands();
    /**
     * @return the onLeaveResetEnderChest
     */
    boolean isOnLeaveResetEnderChest();
    /**
     * @return the onLeaveResetInventory
     */
    boolean isOnLeaveResetInventory();
    /**
     * @return the onLeaveResetMoney
     */
    boolean isOnLeaveResetMoney();
    /**
     * Whether the player's health should be reset upon him leaving his island or resetting it.
     * @return the onLeaveResetHealth
     * @since 1.8.0
     */
    boolean isOnLeaveResetHealth();
    /**
     * Whether the player's hunger should be reset upon him leaving his island or resetting it.
     * @return the onLeaveResetHunger
     * @since 1.8.0
     */
    boolean isOnLeaveResetHunger();
    /**
     * Whether the player's XP should be reset upon him leaving his island or resetting it.
     * @return the onLeaveResetXP
     * @since 1.8.0
     */
    boolean isOnLeaveResetXP();
    /**
     * Returns a list of commands that should be executed when the player leaves an island, resets his island or gets kicked from it.<br/>
     * These commands are executed by the console, unless otherwise stated using the {@code [SUDO]} prefix, in which case they are executed by the player.<br/>
     * <br/>
     * Available placeholders for the commands are the following:
     * <ul>
     *     <li>{@code [player]}: name of the player</li>
     *     <li>{@code [owner]}: name of the owner of the island. When joining a team, this will be the team leader's name. When
     *     creating an island, it is the name of the player</li>
     * </ul>
     * <br/>
     * Here are some examples of valid commands to execute:
     * <ul>
     *     <li>{@code "[SUDO] bbox version"}</li>
     *     <li>{@code "bsbadmin deaths set [player] 0"}</li>
     * </ul>
     * <br/>
     * Note that player-executed commands might not work, as these commands can be run with said player being offline.
     * @return a list of commands.
     * @since 1.8.0
     * @see #getOnJoinCommands()
     */
    @NonNull
    List<String> getOnLeaveCommands();
    /**
     * Returns a list of commands that should be executed when the player respawns after death if {@link Flags#ISLAND_RESPAWN} is true.<br/>
     * These commands are executed by the console, unless otherwise stated using the {@code [SUDO]} prefix, in which case they are executed by the player.<br/>
     * <br/>
     * Available placeholders for the commands are the following:
     * <ul>
     *     <li>{@code [player]}: name of the player</li>
     *     <li>{@code [owner]}: name of the owner of the island. When joining a team, this will be the team leader's name. When
     *     creating an island, it is the name of the player</li>
     * </ul>
     * <br/>
     * Here are some examples of valid commands to execute:
     * <ul>
     *     <li>{@code "[SUDO] bbox version"}</li>
     *     <li>{@code "bsbadmin deaths set [player] 0"}</li>
     * </ul>
     * <br/>
     * Note that player-executed commands might not work, as these commands can be run with said player being offline.
     * @return a list of commands.
     * @since 1.14.0
     * @see #getOnJoinCommands()
     */
    @NonNull
    default List<String> getOnRespawnCommands() {
        return Collections.emptyList();
    }
    /**
     * @return true if the default world generator should not operate in this world
     */
    boolean isUseOwnGenerator();
    /**
     * @return true if water is not safe in this world, e.g, should not be a home location
     */
    boolean isWaterUnsafe();
    /**
     * @return list of entity types that should not exit the island limits
     */
    List<String> getGeoLimitSettings();
    /**
     * Get list of entities that should not spawn in this game mode
     * @return list of entities that should NOT spawn
     * @since 1.12.0
     */
    default List<String> getMobLimitSettings() {
        return new ArrayList<>();
    }
    /**
     * @return reset limit for world
     */
    int getResetLimit();
    /**
     * Get the island reset time stamp. Any player who last logged in before this time will have resets zeroed
     */
    long getResetEpoch();
    /**
     * Set the island reset time stamp. Any player who last logged in before this time will have resets zeroed
     */
    void setResetEpoch(long timestamp);
    /**
     * @return true if the death count should be reset when joining a team in this world
     */
    boolean isTeamJoinDeathReset();
    /**
     * @return max number of deaths for this world
     */
    int getDeathsMax();
    /**
     * @return whether deaths should be counted.
     */
    boolean isDeathsCounted();
    /**
     * @return true if deaths in the world are reset when the player has a new island
     * @since 1.6.0
     */
    boolean isDeathsResetOnNewIsland();
    /**
     * @return whether a player can set their home in the Nether or not.
     */
    boolean isAllowSetHomeInNether();
    /**
     * @return whether a player can set their home in the End or not.
     */
    boolean isAllowSetHomeInTheEnd();
    /**
     * @return whether a confirmation is required when a player tries to set their home in the Nether.
     */
    boolean isRequireConfirmationToSetHomeInNether();
    /**
     * @return whether a confirmation is required when a player tries to set their home in the End.
     */
    boolean isRequireConfirmationToSetHomeInTheEnd();
    /**
     * Gets ban limit for this world.
     * Once exceeded, island members won't be able to ban any more players from their island.
     * Set it to -1 for unlimited.
     * <br/>
     * Permission to increase the limit: {@code (permissionprefix).ban.maxlimit.(value)}
     * @return the ban limit for this world.
     */
    int getBanLimit();
    /**
     * @return whether leavers should lose a reset or not
     * @since 1.5.0
     */
    boolean isLeaversLoseReset();
    /**
     * @return whether players keep their inventory when they are kicked
     * @since 1.5.0
     */
    boolean isKickedKeepInventory();
    /* Create island on first login */
    /**
     *
     * @return true if island should be created on first login
     * @since 1.9.0
     */
    boolean isCreateIslandOnFirstLoginEnabled();
    /**
     *
     * @return the island creation delay after login
     * @since 1.9.0
     */
    int getCreateIslandOnFirstLoginDelay();
    /**
     *
     * @return if island creation should abort on logout
     * @since 1.9.0
     */
    boolean isCreateIslandOnFirstLoginAbortOnLogout();
    /**
     * Check if nether or end islands should be pasted on teleporting
     * @return true if missing nether or end islands should be pasted
     * @since 1.10.0
     */
    default boolean isPasteMissingIslands() {
        // Note that glitches can enable bedrock to be removed in ways that will not generate events.
        return true;
    }
    /**
     * Toggles whether the player should be teleported on his island after it got created.
     * <br/>
     * If set to {@code true}, the player will be teleported right away.
     * <br/>
     * If set to {@code false}, the player will remain where he is and a message will be sent inviting him to teleport to his island.
     * <br/><br/>
     * This does not apply to any other occurrences such as island reset, or island join.
     * <br/><br/>
     * Default value: {@code true} (to retain backward compatibility).
     * @return {@code true} if the player should be teleported to his island, {@code false} otherwise.
     * @since 1.10.0
     */
    default boolean isTeleportPlayerToIslandUponIslandCreation() {
        return true;
    }
    /**
     * Returns all aliases for main admin command.
     * It is assumed that all aliases are split with whitespace between them.
     * String cannot be empty.
     * The first command listed is the "label" in the API, and after that are the aliases
     * Default value: {@code getFriendlyName() + "admin"} (to retain backward compatibility).
     * @return String value
     * @since 1.13.0
     */
    default String getAdminCommandAliases()
    {
        return this.getFriendlyName().toLowerCase(Locale.ENGLISH) + "admin";
    }
    /**
     * Returns all aliases for main player command.
     * It is assumed that all aliases are split with whitespace between them.
     * String cannot be empty.
     * The first command listed is the "label" in the API, and after that are the aliases
     * Default value: {@code getFriendlyName()} (to retain backward compatibility).
     * @return String value
     * @since 1.13.0
     */
    default String getPlayerCommandAliases()
    {
        return this.getFriendlyName().toLowerCase(Locale.ENGLISH);
    }
    /**
     * Returns sub-command for users when they execute main user command and they have an
     * island.
     * If defined sub-command does not exist in accessible user command list, then it will
     * still call "go" sub-command.
     * Default value: {@code "go"} (to retain backward compatibility)
     * @return name of default sub-command for main command if user does have an island.
     * @since 1.13.0
     */
    default String getDefaultPlayerAction()
    {
        return "go";
    }
    /**
     * Returns default sub-command for users when they execute main user command and they
     * do not have an island.
     * If defined sub-command does not exist in accessible user command list, then it will
     * still call "create" sub-command.
     * Default value: {@code "create"} (to retain backward compatibility)
     * @return name of default sub-command for main command if user does not have an island.
     * @since 1.13.0
     */
    default String getDefaultNewPlayerAction()
    {
        return "create";
    }
    /**
     * Make a nether portal when teleporting to the nether through an overworld portal
     * @return true if a portal should be made
     * @since 1.16.0
     */
    default boolean isMakeNetherPortals() {
        return false;
    }
    /**
     * Make an end portal when teleporting to the end through an end portal
     * @return true if a portal should be made
     * @since 1.16.0
     */
    default boolean isMakeEndPortals() {
        return false;
    }
    /**
     * Check for blocks when searching for a new island. This is a safety net check that does a look
     * around the new island location (3x3x3 block check). If any non-air or non-water blocks are found
     * then the island is marked as being used. It is mainly for migration handling from worlds that
     * do not register island properly. It is incompatible with CaveBlock or other gamemodes that will
     * have blocks there.
     * @return true if a check for blocks should happen
     * @since 1.16.0
     */
    default boolean isCheckForBlocks() {
        return true;
    }
    /**
     * Get the number of concurrent islands a player can have in the world
     * @return 1 by default
     * @since 2.0.0
     */
    default int getConcurrentIslands() {
        return BentoBox.getInstance().getSettings().getIslandNumber();
    }
    /**
     * Remove islands when players join a team and not allow players to have other islands if they are in a team.
     * @return true or false
     * @since 2.3.0
     */
    default boolean isDisallowTeamMemberIslands() {
        return true;
    }
}
package world.bentobox.bentobox.blueprints;
import java.util.UUID;
import org.bukkit.NamespacedKey;
import org.bukkit.Sound;
import org.bukkit.World;
import org.bukkit.entity.ArmorStand;
import org.bukkit.entity.Display;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerInteractAtEntityEvent;
import org.bukkit.persistence.PersistentDataType;
import world.bentobox.bentobox.BentoBox;
/**
 * Provides a listener for the Display Objects pasted when a hologram is interacted with
 * https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/event/player/PlayerInteractAtEntityEvent.html
 */
public class DisplayListener implements Listener {
    @EventHandler
    public void onPlayerInteractEntity(PlayerInteractAtEntityEvent event) {
        if (event.getRightClicked() instanceof ArmorStand) {
            ArmorStand armorStand = (ArmorStand) event.getRightClicked();
            NamespacedKey key = new NamespacedKey(BentoBox.getInstance(), "associatedDisplayEntity");
            if (armorStand.getPersistentDataContainer().has(key, PersistentDataType.STRING)) {
                String displayEntityUUID = armorStand.getPersistentDataContainer().get(key, PersistentDataType.STRING);
                // Fetch the associated DisplayEntity by UUID
                World world = armorStand.getWorld();
                world.getEntitiesByClass(Display.class).stream()
                        .filter(e -> e.getUniqueId().equals(UUID.fromString(displayEntityUUID))).findFirst()
                        .ifPresent(e -> {
                            event.getPlayer().playSound(event.getPlayer().getLocation(), Sound.BLOCK_GLASS_BREAK, 1F,
                                    1F);
                            e.remove();
                        });
            }
        }
    }
}
package world.bentobox.bentobox.blueprints;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.scheduler.BukkitTask;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBlock;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintEntity;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.nms.PasteHandler;
import world.bentobox.bentobox.util.Util;
/**
 * This class pastes the clipboard it is given
 * @author tastybento
 *
 */
public class BlueprintPaster {
    /**
     * This tracks the stages of pasting from loading the chunk, pasting blocks, attachments, entities and then finishing.
     */
    enum PasteState {
        CHUNK_LOAD,
        CHUNK_LOADING,
        BLOCKS,
        ATTACHMENTS,
        ENTITIES,
        DONE,
        CANCEL
    }
    /**
     * Longest chunk loading time experienced when pasting an island.
     * It is used to fine-tune the estimated pasting time.
     * @since 1.11.1
     */
    private static long chunkLoadTime = 0;
    private final BentoBox plugin;
    private final PasteHandler paster = Util.getPasteHandler();
    private final PasteHandler fallback = new world.bentobox.bentobox.nms.fallback.PasteHandlerImpl();
    private final World world;
    // The minimum block position (x,y,z)
    private Location pos1;
    // The maximum block position (x,y,z)
    private Location pos2;
    private PasteState pasteState;
    private BukkitTask pastingTask;
    private BlueprintClipboard clipboard;
    private CompletableFuture<Void> currentTask = CompletableFuture.completedFuture(null);
    /**
     * The Blueprint to paste.
     */
    @NonNull
    private final Blueprint blueprint;
    /**
     * The Location to paste to.
     */
    @NonNull
    private final Location location;
    /**
     * Island related to this paste, may be null.
     */
    @Nullable
    private final Island island;
    /**
     * Paste a clipboard to a location. Run {@link #paste()} to paste
     * @param plugin - BentoBox
     * @param clipboard - clipboard to paste
     * @param location - location to which to paste
     */
    public BlueprintPaster(@NonNull BentoBox plugin, @NonNull BlueprintClipboard clipboard, @NonNull Location location) {
        this.plugin = plugin;
        this.clipboard = clipboard;
        // Calculate location for pasting
        this.blueprint = Objects.requireNonNull(clipboard.getBlueprint(), "Clipboard cannot have a null Blueprint");
        this.location = location;
        this.world = location.getWorld();
        this.island = null;
    }
    /**
     * Pastes a blueprint to an island
     * @param plugin - BentoBox
     * @param bp - blueprint to paste
     * @param world - world to paste to
     * @param island - island related to this paste
     */
    public BlueprintPaster(@NonNull BentoBox plugin, @NonNull Blueprint bp, World world, @NonNull Island island) {
        this.plugin = plugin;
        this.blueprint = bp;
        this.island = island;
        this.world = world;
        // Offset due to bedrock
        Vector off = bp.getBedrock() != null ? bp.getBedrock() : new Vector(0,0,0);
        // Calculate location for pasting
        this.location = island.getProtectionCenter().toVector().subtract(off).toLocation(world);
        // Ensure the y coordinate is within the world limits
        int y = Math.min(world.getMaxHeight() - 1, Math.max(world.getMinHeight(), location.getBlockY()));
        location.setY(y);
    }
    /**
     * A record of all the "bits" of the blueprint that need to be pasted
     * Consists of blocks, attached blocks, entities, iterators for the blocks and a speed
     */
    private record Bits(
            /**
             * Basic blocks to the pasted (not attached blocks)
             */
            Map<Vector, BlueprintBlock> blocks,
            /**
             * Attached blocks
             */
            Map<Vector, BlueprintBlock> attached,
            /**
             * Entities to be pasted
             */
            Map<Vector, List<BlueprintEntity>> entities,
            /**
             * Basic block pasting iterator
             */
            Iterator<Entry<Vector, BlueprintBlock>> it,
            /**
             * Attached block pasting iterator
             */
            Iterator<Entry<Vector, BlueprintBlock>> it2,
            /**
             * Entity pasting iterator
             */
            Iterator<Entry<Vector, List<BlueprintEntity>>> it3,
            /**
             * Paste speed
             */
            int pasteSpeed) {}
    /**
     * The main pasting method
     */
    public CompletableFuture<Boolean> paste() {
        return this.paste(true);
    }
    /**
     * Paste the clipboard
     * @param useNMS if true, NMS pasting will be used, otherwise Bukkit API
     * @return Future boolean where true is success
     */
    public CompletableFuture<Boolean> paste(boolean useNMS) {
        CompletableFuture<Boolean> result = new CompletableFuture<>();
        // Iterators for the various maps to paste
        final Map<Vector, BlueprintBlock> blocks = blueprint.getBlocks() == null ? Collections.emptyMap() : blueprint.getBlocks();
        final Map<Vector, BlueprintBlock> attached = blueprint.getAttached() == null ? Collections.emptyMap() : blueprint.getAttached();
        final Map<Vector, List<BlueprintEntity>> entities = blueprint.getEntities() == null ? Collections.emptyMap() : blueprint.getEntities();
        // Initial state & speed
        pasteState = PasteState.CHUNK_LOAD;
        // If this is an island OVERWORLD paste, get the island owner.
        final Optional<User> owner = Optional.ofNullable(island).map(i -> User.getInstance(i.getOwner()));
        // Tell the owner we're pasting blocks and how much time it might take
        owner.ifPresent(user -> tellOwner(user, blocks.size(), attached.size(), entities.size(), plugin.getSettings().getPasteSpeed()));
        Bits bits = new Bits(blocks, attached, entities,
                blocks.entrySet().iterator(), attached.entrySet().iterator(), entities.entrySet().iterator(),
                plugin.getSettings().getPasteSpeed());
        pastingTask = Bukkit.getScheduler().runTaskTimer(plugin, () -> pasterTask(result, owner, bits, useNMS), 0L, 1L);
        return result;
    }
    private void pasterTask(CompletableFuture<Boolean> result, Optional<User> owner, Bits bits, boolean useNMS) {
        if (!currentTask.isDone()) return;
        final int pasteSpeed = plugin.getSettings().getPasteSpeed();
        int count = 0;
        if (pasteState.equals(PasteState.CHUNK_LOAD)) {
            loadChunk();
        }
        else if (pasteState.equals(PasteState.BLOCKS) || pasteState.equals(PasteState.ATTACHMENTS)) {
            pasteBlocks(bits, count, owner, pasteSpeed, useNMS);
        }
        else if (pasteState.equals(PasteState.ENTITIES)) {
            pasteEntities(bits, count, owner, pasteSpeed, useNMS);
        }
        else if (pasteState.equals(PasteState.DONE)) {
            // All done. Cancel task
            cancelTask(result);
        } else if (pasteState.equals(PasteState.CANCEL)) {
            // This state makes sure the follow-on task only ever runs once
            pastingTask.cancel();
            result.complete(true);
        }
    }
    private void cancelTask(CompletableFuture<Boolean> result) {
        // Set pos1 and 2 if this was a clipboard paste
        if (island == null && clipboard != null) {
            clipboard.setPos1(pos1);
            clipboard.setPos2(pos2);
        }
        pasteState = PasteState.CANCEL;
        result.complete(true);      
    }
    private void pasteEntities(Bits bits, int count, Optional<User> owner, int pasteSpeed, boolean useNMS) {
        if (bits.it3().hasNext()) {
            Map<Location, List<BlueprintEntity>> entityMap = new HashMap<>();
            // Paste entities
            while (count < pasteSpeed) {
                if (!bits.it3().hasNext()) {
                    break;
                }
                Entry<Vector, List<BlueprintEntity>> entry = bits.it3().next();
                int x = location.getBlockX() + entry.getKey().getBlockX();
                int y = location.getBlockY() + entry.getKey().getBlockY();
                int z = location.getBlockZ() + entry.getKey().getBlockZ();
                Location center = new Location(world, x, y, z).add(new Vector(0.5, 0D, 0.5));
                List<BlueprintEntity> entities = entry.getValue();
                entityMap.put(center, entities);
                count++;
            }
            if (!entityMap.isEmpty()) {
                currentTask = useNMS ? paster.pasteEntities(island, world, entityMap)
                        : fallback.pasteEntities(island, world, entityMap);
            }
        } else {
            pasteState = PasteState.DONE;
            String dimensionType = switch (location.getWorld().getEnvironment()) {
            case NETHER -> owner.map(user -> user.getTranslation("general.worlds.nether")).orElse("");
            case THE_END -> owner.map(user -> user.getTranslation("general.worlds.the-end")).orElse("");
            default -> owner.map(user -> user.getTranslation("general.worlds.overworld")).orElse("");
            };
            owner.ifPresent(user -> user.sendMessage("commands.island.create.pasting.dimension-done", "[world]", dimensionType));
        }
    }
    private void pasteBlocks(Bits bits, int count, Optional<User> owner, int pasteSpeed, boolean useNMS) {
        Iterator<Entry<Vector, BlueprintBlock>> it = pasteState.equals(PasteState.BLOCKS) ? bits.it : bits.it2;
        if (it.hasNext()) {
            pasteBlocksNow(it, count, pasteSpeed, useNMS);
        } else {
            if (pasteState.equals(PasteState.BLOCKS)) {
                // Blocks done
                // Next paste attachments
                pasteState = PasteState.ATTACHMENTS;
            } else {
                // Attachments done. Next paste entities
                pasteState = PasteState.ENTITIES;
                if (bits.entities.size() != 0) {
                    owner.ifPresent(user -> user.sendMessage("commands.island.create.pasting.entities", TextVariables.NUMBER, String.valueOf(bits.entities.size())));
                }
            }
        }
    }
    private void pasteBlocksNow(Iterator<Entry<Vector, BlueprintBlock>> it, int count, int pasteSpeed, boolean useNMS) {
        Map<Location, BlueprintBlock> blockMap = new HashMap<>();
        // Paste blocks
        while (count < pasteSpeed) {
            if (!it.hasNext()) {
                break;
            }
            Entry<Vector, BlueprintBlock> entry = it.next();
            Location pasteTo = location.clone().add(entry.getKey());
            // pos1 and pos2 update
            updatePos(pasteTo);
            BlueprintBlock block = entry.getValue();
            blockMap.put(pasteTo, block);
            count++;
        }
        if (!blockMap.isEmpty()) {
            currentTask = useNMS ? paster.pasteBlocks(island, world, blockMap)
                    : fallback.pasteBlocks(island, world, blockMap);
        }
    }
    private void loadChunk() {
        long timer = System.currentTimeMillis();
        pasteState = PasteState.CHUNK_LOADING;
        // Load chunk
        currentTask = Util.getChunkAtAsync(location).thenRun(() -> {
            pasteState = PasteState.BLOCKS;
            long duration = System.currentTimeMillis() - timer;
            if (duration > chunkLoadTime) {
                chunkLoadTime = duration;
            }
        });
    }
    private void tellOwner(User user, int blocksSize, int attachedSize, int entitiesSize, int pasteSpeed) {
        // Estimated time:
        double total = (double) blocksSize + attachedSize + entitiesSize;
        BigDecimal time = BigDecimal.valueOf(total / (pasteSpeed * 20.0D) + (chunkLoadTime / 1000.0D)).setScale(1, RoundingMode.UP);
        user.sendMessage("commands.island.create.pasting.estimated-time", TextVariables.NUMBER, String.valueOf(time.doubleValue()));
        // We're pasting blocks!
        user.sendMessage("commands.island.create.pasting.blocks", TextVariables.NUMBER, String.valueOf(blocksSize + attachedSize));
    }
    /**
     * Tracks the minimum and maximum block positions
     * @param l - location of block pasted
     */
    private void updatePos(Location l) {
        if (pos1 == null) {
            pos1 = l.clone();
        }
        if (pos2 == null) {
            pos2 = l.clone();
        }
        if (l.getBlockX() < pos1.getBlockX()) {
            pos1.setX(l.getBlockX());
        }
        if (l.getBlockX() > pos2.getBlockX()) {
            pos2.setX(l.getBlockX());
        }
        if (l.getBlockY() < pos1.getBlockY()) {
            pos1.setY(l.getBlockY());
        }
        if (l.getBlockY() > pos2.getBlockY()) {
            pos2.setY(l.getBlockY());
        }
        if (l.getBlockZ() < pos1.getBlockZ()) {
            pos1.setZ(l.getBlockZ());
        }
        if (l.getBlockZ() > pos2.getBlockZ()) {
            pos2.setZ(l.getBlockZ());
        }
    }
}
package world.bentobox.bentobox.blueprints.dataobjects;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.block.Biome;
import org.bukkit.block.banner.Pattern;
import org.bukkit.block.sign.Side;
import org.bukkit.inventory.ItemStack;
import com.google.gson.annotations.Expose;
/**
 * Represents a block to be pasted
 * @author tastybento
 * @since 1.5.0
 */
public class BlueprintBlock {
    @Expose
    private String blockData;
    /**
     * Front of sign
     */
    @Expose
    private List<String> signLines;
    /**
     * Back of sign
     */
    @Expose
    private List<String> signLines2;
    @Expose
    private Map<Integer, ItemStack> inventory;
    @Expose
    private BlueprintCreatureSpawner creatureSpawner;
    /**
     * @since 3.4.2
     */
    @Expose
    private BlueprintTrialSpawner trialSpawner;
    /**
     * Since 1.15.2
     */
    @Expose
    private Biome biome;
    /**
     * @since 1.8.0
     */
    @Expose
    private List<Pattern> bannerPatterns;
    /**
     * Front of sign
     */
    @Expose
    private boolean glowingText;
    /**
     * Back of sign
     */
    @Expose
    private boolean glowingText2;
    public BlueprintBlock(String blockData) {
        this.blockData = blockData;
    }
    /**
     * @return the blockData
     */
    public String getBlockData() {
        return blockData;
    }
    /**
     * @param blockData the blockData to set
     */
    public void setBlockData(String blockData) {
        this.blockData = blockData;
    }
    /**
     * @return the signLines
     * @deprecated signs now have two sides
     * @since 1.24.0
     */
    @Deprecated
    public List<String> getSignLines() {
        return signLines;
    }
    /**
     * @param signLines the signLines to set
     * @deprecated signs now have two sides
     * @since 1.24.0
     */
    @Deprecated
    public void setSignLines(List<String> signLines) {
        this.signLines = signLines;
    }
    /**
     * @return the inventory
     */
    public Map<Integer, ItemStack> getInventory() {
        return inventory == null ? new HashMap<>() : inventory;
    }
    /**
     * @param inventory the inventory to set
     */
    public void setInventory(Map<Integer, ItemStack> inventory) {
        this.inventory = inventory;
    }
    /**
     * @return the creatureSpawner
     */
    public BlueprintCreatureSpawner getCreatureSpawner() {
        return creatureSpawner;
    }
    /**
     * @param creatureSpawner the creatureSpawner to set
     */
    public void setCreatureSpawner(BlueprintCreatureSpawner creatureSpawner) {
        this.creatureSpawner = creatureSpawner;
    }
    /**
     * @return list of the banner patterns
     * @since 1.8.0
     */
    public List<Pattern> getBannerPatterns() {
        return bannerPatterns;
    }
    /**
     * @param bannerPatterns the banner Patterns to set
     * @since 1.8.0
     */
    public void setBannerPatterns(List<Pattern> bannerPatterns) {
        this.bannerPatterns = bannerPatterns;
    }
    /**
     * @return the biome
     */
    public Biome getBiome() {
        return biome;
    }
    /**
     * @param biome the biome to set
     */
    public void setBiome(Biome biome) {
        this.biome = biome;
    }
    /**
     * @return the glowingText
     * @deprecated signs now have two sides
     * @since 1.24.0
     */
    @Deprecated
    public boolean isGlowingText() {
        return glowingText;
    }
    /**
     * @param glowingText the glowingText to set
     * @deprecated signs now have two sides
     * @since 1.24.0
     */
    @Deprecated
    public void setGlowingText(boolean glowingText) {
        this.glowingText = glowingText;
    }
    /**
     * @param side side of sign
     * @param glowingText the glowingText to set
     * @since 1.24.0
     */
    public void setGlowingText(Side side, boolean glowingText) {
        if (side == Side.FRONT) {
            this.glowingText = glowingText;
        } else {
            this.glowingText2 = glowingText;
        }
    }
    /**
     * @param side side of sign
     * @return the glowingText
     * @since 1.24.0
     */
    public boolean isGlowingText(Side side) {
        if (side == Side.FRONT) return glowingText;
        return glowingText2;
    }
    /**
     * @param side side of sign
     * @return the signLines
     * @since 1.24.0
     */
    public List<String> getSignLines(Side side) {
        if (side == Side.FRONT) return signLines;
        return signLines2;
    }
    /**
     * @param side side of sign
     * @param signLines the signLines to set
     * @since 1.24.0
     */
    public void setSignLines(Side side, List<String> signLines) {
        if (side == Side.FRONT) {
            this.signLines = signLines;
        } else {
            this.signLines2 = signLines;
        }
    }
    /**
     * @return the trialSpawner
     */
    public BlueprintTrialSpawner getTrialSpawner() {
        return trialSpawner;
    }
    /**
     * @param trialSpawner the trialSpawner to set
     */
    public void setTrialSpawner(BlueprintTrialSpawner trialSpawner) {
        this.trialSpawner = trialSpawner;
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.util.List;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
/**
 * Renames an existing blueprint.
 * @author Poslovitch
 * @since 1.10.0
 */
public class AdminBlueprintRenameCommand extends ConfirmableCommand
{
    public AdminBlueprintRenameCommand(AdminBlueprintCommand parent)
    {
        super(parent, "rename");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.rename");
        this.setParametersHelp("commands.admin.blueprint.rename.parameters");
        this.setDescription("commands.admin.blueprint.rename.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (args.size() != 2)
        {
            // Blueprint must have a name.
            this.showHelp(this, user);
            return false;
        }
        String from = Util.sanitizeInput(args.get(0));
        String to = Util.sanitizeInput(args.get(1));
        // Check if name is changed.
        if (from.equals(to))
        {
            user.sendMessage("commands.admin.blueprint.rename.pick-different-name");
            return false;
        }
        // Check if the 'from' file exists
        AdminBlueprintCommand parent = (AdminBlueprintCommand) this.getParent();
        File fromFile = new File(parent.getBlueprintsFolder(), from + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (!fromFile.exists())
        {
            user.sendMessage("commands.admin.blueprint.no-such-file");
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        // Check if the names are the same
        String from = Util.sanitizeInput(args.get(0));
        String to = Util.sanitizeInput(args.get(1));
        // Check if the 'to' file exists
        File toFile = new File(parent.getBlueprintsFolder(), to + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (toFile.exists())
        {
            // Ask for confirmation to overwrite
            this.askConfirmation(user,
                    user.getTranslation("commands.admin.blueprint.file-exists"),
                    () -> this.rename(user, from, to, args.get(1)));
        }
        else
        {
            this.askConfirmation(user, () -> this.rename(user, from, to, args.get(1)));
        }
        return true;
    }
    private void rename(User user, String blueprintName, String fileName, String displayName)
    {
        Blueprint blueprint = this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).get(blueprintName);
        this.getPlugin().getBlueprintsManager().renameBlueprint(this.getAddon(), blueprint, fileName, displayName);
        user.sendMessage("commands.admin.blueprint.rename.success",
                "[old]",
                blueprintName,
                TextVariables.NAME,
                blueprint.getName(),
                "[display]",
                blueprint.getDisplayName());
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.util.List;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
/**
 * Renames an existing blueprint.
 * @author Poslovitch
 * @since 1.10.0
 */
public class AdminBlueprintRenameCommand extends ConfirmableCommand
{
    public AdminBlueprintRenameCommand(AdminBlueprintCommand parent)
    {
        super(parent, "rename");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.rename");
        this.setParametersHelp("commands.admin.blueprint.rename.parameters");
        this.setDescription("commands.admin.blueprint.rename.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (args.size() != 2)
        {
            // Blueprint must have a name.
            this.showHelp(this, user);
            return false;
        }
        String from = Util.sanitizeInput(args.get(0));
        String to = Util.sanitizeInput(args.get(1));
        // Check if name is changed.
        if (from.equals(to))
        {
            user.sendMessage("commands.admin.blueprint.rename.pick-different-name");
            return false;
        }
        // Check if the 'from' file exists
        AdminBlueprintCommand parent = (AdminBlueprintCommand) this.getParent();
        File fromFile = new File(parent.getBlueprintsFolder(), from + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (!fromFile.exists())
        {
            user.sendMessage("commands.admin.blueprint.no-such-file");
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        // Check if the names are the same
        String from = Util.sanitizeInput(args.get(0));
        String to = Util.sanitizeInput(args.get(1));
        // Check if the 'to' file exists
        File toFile = new File(parent.getBlueprintsFolder(), to + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (toFile.exists())
        {
            // Ask for confirmation to overwrite
            this.askConfirmation(user,
                    user.getTranslation("commands.admin.blueprint.file-exists"),
                    () -> this.rename(user, from, to, args.get(1)));
        }
        else
        {
            this.askConfirmation(user, () -> this.rename(user, from, to, args.get(1)));
        }
        return true;
    }
    private void rename(User user, String blueprintName, String fileName, String displayName)
    {
        Blueprint blueprint = this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).get(blueprintName);
        this.getPlugin().getBlueprintsManager().renameBlueprint(this.getAddon(), blueprint, fileName, displayName);
        user.sendMessage("commands.admin.blueprint.rename.success",
                "[old]",
                blueprintName,
                TextVariables.NAME,
                blueprint.getName(),
                "[display]",
                blueprint.getDisplayName());
    }
}
package world.bentobox.bentobox.database.json;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.Map;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Biome;
import org.bukkit.configuration.serialization.ConfigurationSerializable;
import org.bukkit.entity.Villager;
import org.bukkit.entity.Villager.Profession;
import org.bukkit.inventory.ItemStack;
import org.bukkit.potion.PotionEffectType;
import org.bukkit.util.Vector;
import com.google.gson.Gson;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.flags.Flag;
import world.bentobox.bentobox.database.json.adapters.BiomeTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.BukkitObjectTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.EnumTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.FlagTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.ItemStackTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.LocationTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.MaterialTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.PairTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.PotionEffectTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.ProfessionTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.VectorTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.VillagerTypeAdapter;
import world.bentobox.bentobox.database.json.adapters.WorldTypeAdapter;
import world.bentobox.bentobox.util.Pair;
/**
 * Allocates type adapters based on class type.
 *
 * @author tastybento
 *
 */
public class BentoboxTypeAdapterFactory implements TypeAdapterFactory {
    final BentoBox plugin;
    /**
     * @param plugin plugin
     */
    public BentoboxTypeAdapterFactory(BentoBox plugin) {
        this.plugin = plugin;
    }
    /* (non-Javadoc)
     * @see com.google.gson.TypeAdapterFactory#create(com.google.gson.Gson, com.google.gson.reflect.TypeToken)
     */
    @SuppressWarnings({ "unchecked", "rawtypes" })
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
        Class<?> rawType = type.getRawType();
        if (Location.class.isAssignableFrom(rawType)) {
            // Use our current location adapter for backward compatibility
            return (TypeAdapter<T>) new LocationTypeAdapter();
        } else if (Material.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new MaterialTypeAdapter();
        } else if (Biome.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new BiomeTypeAdapter();
        } else if (Enum.class.isAssignableFrom(rawType)) {
            return new EnumTypeAdapter(rawType);
        } else if (ItemStack.class.isAssignableFrom(rawType)) {
            // Use our current location adapter for backward compatibility
            return (TypeAdapter<T>) new ItemStackTypeAdapter();
        } else if (Flag.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new FlagTypeAdapter(plugin);
        } else if (PotionEffectType.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new PotionEffectTypeAdapter();
        } else if (World.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new WorldTypeAdapter();
        } else if (Vector.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new VectorTypeAdapter();
        } else if (Profession.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new ProfessionTypeAdapter();
        } else if (Villager.Type.class.isAssignableFrom(rawType)) {
            return (TypeAdapter<T>) new VillagerTypeAdapter();
        } else if (Pair.class.isAssignableFrom(rawType)) {
            // Add Pair handling here with type safety
            Type pairType = type.getType();
            ParameterizedType parameterizedType = (ParameterizedType) pairType;
            Type xType = parameterizedType.getActualTypeArguments()[0];
            Type zType = parameterizedType.getActualTypeArguments()[1];
            return (TypeAdapter<T>) new PairTypeAdapter<>(xType, zType);
        } else if (ConfigurationSerializable.class.isAssignableFrom(rawType)) {
            // This covers a lot of Bukkit objects
            return (TypeAdapter<T>) new BukkitObjectTypeAdapter(gson.getAdapter(Map.class));
        }
        return null;
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.util.List;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
import world.bentobox.bentobox.managers.BlueprintClipboardManager;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
/**
 * This method allows to save blueprint from the clipboard.
 */
public class AdminBlueprintSaveCommand extends ConfirmableCommand
{
    public AdminBlueprintSaveCommand(AdminBlueprintCommand parent)
    {
        super(parent, "save");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.save");
        this.setParametersHelp("commands.admin.blueprint.save.parameters");
        this.setDescription("commands.admin.blueprint.save.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (args.size() != 1)
        {
            // Blueprint must have a name.
            this.showHelp(this, user);
            return false;
        }
        BlueprintClipboard clipboard = ((AdminBlueprintCommand) this.getParent()).getClipboards().
                computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        if (!clipboard.isFull())
        {
            // Clipboard is not set up.
            user.sendMessage("commands.admin.blueprint.copy-first");
            return false;
        }
        if (clipboard.getBlueprint() != null && clipboard.getBlueprint().getBedrock() == null)
        {
            // Bedrock is required for all blueprints.
            user.sendMessage("commands.admin.blueprint.bedrock-required");
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) this.getParent();
        BlueprintClipboard clipboard = parent.getClipboards().
                computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        String fileName = Util.sanitizeInput(args.get(0));
        // Check if file exists
        File newFile = new File(parent.getBlueprintsFolder(), fileName + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (newFile.exists())
        {
            this.askConfirmation(user,
                    user.getTranslation("commands.admin.blueprint.file-exists"),
                    () -> this.hideAndSave(user, parent, clipboard, fileName, args.get(0)));
            return false;
        }
        return this.hideAndSave(user, parent, clipboard, fileName, args.get(0));
    }
    /**
     * This method saves given blueprint.
     * @param user User that triggers blueprint save.
     * @param parent Parent command that contains clipboard.
     * @param clipboard Active clipboard.
     * @param name Filename for the blueprint
     * @param displayName Display name for the blueprint.
     * @return {@code true} if blueprint is saved, {@code false} otherwise.
     */
    private boolean hideAndSave(User user,
            AdminBlueprintCommand parent,
            BlueprintClipboard clipboard,
            String name,
            String displayName)
    {
        parent.hideClipboard(user);
        boolean result = new BlueprintClipboardManager(this.getPlugin(),
                parent.getBlueprintsFolder(), clipboard).
                save(user, name, displayName);
        if (result && clipboard.isFull())
        {
            this.getPlugin().getBlueprintsManager().addBlueprint(this.getAddon(), clipboard.getBlueprint());
        }
        return result;
    }
}
package world.bentobox.bentobox.managers;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;
import org.bukkit.Material;
import org.bukkit.util.Vector;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBlock;
import world.bentobox.bentobox.database.json.BentoboxTypeAdapterFactory;
/**
 * @author tastybento
 * @since 1.5.0
 */
public class BlueprintClipboardManager {
    private static final String LOAD_ERROR = "Could not load blueprint file - does not exist : ";
    private final File blueprintFolder;
    private BlueprintClipboard clipboard;
    private Gson gson;
    private final BentoBox plugin;
    public BlueprintClipboardManager(BentoBox plugin, File blueprintFolder) {
        this(plugin, blueprintFolder, null);
    }
    public BlueprintClipboardManager(BentoBox plugin, File blueprintFolder, BlueprintClipboard clipboard) {
        super();
        this.plugin = plugin;
        if (!blueprintFolder.exists()) {
            blueprintFolder.mkdirs();
        }
        this.blueprintFolder = blueprintFolder;
        this.clipboard = clipboard;
        getGson();
    }
    /**
     * @return the clipboard
     */
    public BlueprintClipboard getClipboard() {
        return clipboard;
    }
    private void getGson() {
        GsonBuilder builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().enableComplexMapKeySerialization();
        // Disable <>'s escaping etc.
        builder.disableHtmlEscaping();
        // Register adapter factory
        builder.registerTypeAdapterFactory(new BentoboxTypeAdapterFactory(plugin));
        gson = builder.create();
    }
    /**
     * Load a file to clipboard
     * @param fileName - filename in blueprints folder
     * @throws IOException - if there's a load error with unzipping or name
     */
    public void load(String fileName) throws IOException {
        clipboard = new BlueprintClipboard(loadBlueprint(fileName));
    }
    /**
     * Loads a blueprint
     * @param fileName - the sanitized filename without the suffix
     * @return the blueprint
     * @throws IOException exception if there's an issue loading or unzipping
     */
    public Blueprint loadBlueprint(String fileName) throws IOException {
        File zipFile = new File(blueprintFolder, fileName + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (!zipFile.exists()) {
            plugin.logError(LOAD_ERROR + zipFile.getName());
            throw new IOException(LOAD_ERROR + zipFile.getName());
        }
        unzip(zipFile.getCanonicalPath());
        File file = new File(blueprintFolder, fileName);
        if (!file.exists()) {
            plugin.logError(LOAD_ERROR + file.getName());
            throw new IOException(LOAD_ERROR + file.getName() + " temp file");
        }
        Blueprint bp;
        try (FileReader fr = new FileReader(file, StandardCharsets.UTF_8)) {
            bp = gson.fromJson(fr, Blueprint.class);
        } catch (Exception e) {
            plugin.logError("Blueprint has JSON error: " + zipFile.getName());
            plugin.logStacktrace(e);
            throw new IOException("Blueprint has JSON error: " + zipFile.getName());
            
        }
        Files.delete(file.toPath());
        // Bedrock check and set
        if (bp.getBedrock() == null) {
            bp.setBedrock(new Vector(bp.getxSize() / 2, bp.getySize() / 2, bp.getzSize() / 2));
            bp.getBlocks().put(bp.getBedrock(), new BlueprintBlock(Material.BEDROCK.createBlockData().getAsString()));
            plugin.logWarning("Blueprint " + fileName + BlueprintsManager.BLUEPRINT_SUFFIX + " had no bedrock block in it so one was added automatically in the center. You should check it.");
        }
        return bp;
    }
    /**
     * Load a blueprint to the clipboard for a user
     * @param user - user trying to load
     * @param fileName - filename
     * @return - <tt>true</tt> if load is successful, <tt>false</tt> if not
     */
    public boolean load(User user, String fileName) {
        try {
            load(fileName);
        } catch (IOException e1) {
            user.sendMessage("commands.admin.blueprint.could-not-load");
            plugin.logError("Could not load blueprint file: " + fileName + BlueprintsManager.BLUEPRINT_SUFFIX + " " + e1.getMessage());
            return false;
        }
        user.sendMessage("general.success");
        return true;
    }
    /**
     * Save the clipboard to a file
     * @param user - user who is copying
     * @param newName - new name of this blueprint
     * @return - true if successful, false if error
     */
    public boolean save(User user, String newName, String displayName)
    {
        if (this.clipboard.isFull())
        {
            this.clipboard.getBlueprint().setName(newName);
            this.clipboard.getBlueprint().setDisplayName(displayName);
            if (this.saveBlueprint(this.clipboard.getBlueprint()))
            {
                user.sendMessage("general.success");
                return true;
            }
        }
        user.sendMessage("commands.admin.blueprint.could-not-save", "[message]", "Could not save temp blueprint file.");
        return false;
    }
    /**
     * Save a blueprint
     * @param blueprint - blueprint
     * @return true if successful, false if not
     */
    public boolean saveBlueprint(Blueprint blueprint) {
        if (blueprint.getName().isEmpty()) {
            plugin.logError("Blueprint name was empty - could not save it");
            return false;
        }
        File file = new File(blueprintFolder, blueprint.getName());
        String toStore = gson.toJson(blueprint, Blueprint.class);
        try (FileWriter fileWriter = new FileWriter(file, StandardCharsets.UTF_8)) {
            fileWriter.write(toStore);
        } catch (IOException e) {
            plugin.logError("Could not save temporary blueprint file: " + file.getName());
            return false;
        }
        try {
            zip(file);
        } catch (IOException e) {
            plugin.logError("Could not zip temporary blueprint file: " + file.getName());
            return false;
        }
        return true;
    }
    private void unzip(final String zipFilePath) throws IOException {
        Path path = Paths.get(zipFilePath);
        if (!(path.toFile().exists())) {
            throw new IOException("No file exists!");
        }
        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(zipFilePath))) {
            ZipEntry entry = zipInputStream.getNextEntry();
            while (entry != null) {
                Path filePath = Paths.get(path.getParent().toString(), entry.getName());
                if (!entry.isDirectory()) {
                    unzipFiles(zipInputStream, filePath);
                } else {
                    if (!filePath.startsWith(blueprintFolder.getCanonicalPath())) {
                        throw new IOException("Entry is outside of the target directory");
                    }
                    Files.createDirectories(filePath);
                }
                zipInputStream.closeEntry();
                entry = zipInputStream.getNextEntry();
            }
        }
    }
    private void unzipFiles(final ZipInputStream zipInputStream, final Path unzipFilePath) throws IOException {
        // Prevent directory traversal attacks by normalizing the path
        if (!unzipFilePath.startsWith(blueprintFolder.getCanonicalFile().toPath().normalize())) {
            throw new IOException(
                    "Blueprint file is trying to write outside of the target directory! Blocked attempt to write to "
                            + unzipFilePath.toString());
        }
        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(unzipFilePath.toFile().getCanonicalPath()))) {
            byte[] bytesIn = new byte[1024];
            int read;
            while ((read = zipInputStream.read(bytesIn)) != -1) {
                bos.write(bytesIn, 0, read);
            }
        }
    }
    private void zip(File targetFile) throws IOException {
        try (ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(targetFile.getCanonicalPath() + BlueprintsManager.BLUEPRINT_SUFFIX))) {
            zipOutputStream.putNextEntry(new ZipEntry(targetFile.getName()));
            try (FileInputStream inputStream = new FileInputStream(targetFile)) {
                final byte[] buffer = new byte[1024];
                int length;
                while((length = inputStream.read(buffer)) >= 0) {
                    zipOutputStream.write(buffer, 0, length);
                }
            }
            try {
                Files.delete(targetFile.toPath());
            } catch (Exception e) {
                plugin.logError(e.getMessage());
            }
        }
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.util.Util;
/**
 * Command that deletes a Blueprint.
 * @author Poslovitch
 * @since 1.9.0
 */
public class AdminBlueprintDeleteCommand extends ConfirmableCommand
{
    public AdminBlueprintDeleteCommand(AdminBlueprintCommand parent)
    {
        super(parent, "delete", "remove");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.delete");
        this.setParametersHelp("commands.admin.blueprint.delete.parameters");
        this.setDescription("commands.admin.blueprint.delete.description");
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        if (args.size() != 1)
        {
            this.showHelp(this, user);
            return false;
        }
        String blueprintName = Util.sanitizeInput(args.get(0));
        // Check if blueprint exist
        if (this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).containsKey(blueprintName))
        {
            this.askConfirmation(user, user.getTranslation("commands.admin.blueprint.delete.confirmation"),
                    () -> {
                        this.getPlugin().getBlueprintsManager().deleteBlueprint(this.getAddon(), blueprintName);
                        user.sendMessage("commands.admin.blueprint.delete.success", TextVariables.NAME, blueprintName);
                    });
            return true;
        }
        else
        {
            user.sendMessage("commands.admin.blueprint.delete.no-blueprint", TextVariables.NAME, blueprintName);
            return false;
        }
    }
    @Override
    public Optional<List<String>> tabComplete(User user, String alias, List<String> args)
    {
        return Optional.of(new LinkedList<>(this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).keySet()));
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.io.FilenameFilter;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.managers.BlueprintsManager;
public class AdminBlueprintListCommand extends CompositeCommand
{
    public AdminBlueprintListCommand(AdminBlueprintCommand parent)
    {
        super(parent, "list");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.list");
        this.setDescription("commands.admin.blueprint.list.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (!args.isEmpty())
        {
            this.showHelp(this, user);
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        File blueprints = new File(this.getAddon().getDataFolder(), BlueprintsManager.FOLDER_NAME);
        if (!blueprints.exists())
        {
            user.sendMessage("commands.admin.blueprint.list.no-blueprints");
            return false;
        }
        FilenameFilter blueprintFilter = (File dir, String name) -> name.endsWith(BlueprintsManager.BLUEPRINT_SUFFIX);
        List<String> blueprintList = Arrays.stream(Objects.requireNonNull(blueprints.list(blueprintFilter))).
                map(name -> name.substring(0, name.length() - BlueprintsManager.BLUEPRINT_SUFFIX.length())).
                toList();
        if (blueprintList.isEmpty())
        {
            user.sendMessage("commands.admin.blueprint.list.no-blueprints");
            return false;
        }
        user.sendMessage("commands.admin.blueprint.list.available-blueprints");
        blueprintList.forEach(user::sendRawMessage);
        return true;
    }
}