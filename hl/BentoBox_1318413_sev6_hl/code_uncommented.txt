package world.bentobox.bentobox.database;
import java.util.Arrays;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.mongodb.MongoDBDatabase;
import world.bentobox.bentobox.database.sql.mariadb.MariaDBDatabase;
import world.bentobox.bentobox.database.sql.mysql.MySQLDatabase;
import world.bentobox.bentobox.database.sql.postgresql.PostgreSQLDatabase;
import world.bentobox.bentobox.database.sql.sqlite.SQLiteDatabase;
import world.bentobox.bentobox.database.transition.Json2MariaDBDatabase;
import world.bentobox.bentobox.database.transition.Json2MongoDBDatabase;
import world.bentobox.bentobox.database.transition.Json2MySQLDatabase;
import world.bentobox.bentobox.database.transition.Json2PostgreSQLDatabase;
import world.bentobox.bentobox.database.transition.Json2SQLiteDatabase;
import world.bentobox.bentobox.database.transition.MariaDB2JsonDatabase;
import world.bentobox.bentobox.database.transition.MongoDB2JsonDatabase;
import world.bentobox.bentobox.database.transition.MySQL2JsonDatabase;
import world.bentobox.bentobox.database.transition.PostgreSQL2JsonDatabase;
import world.bentobox.bentobox.database.transition.SQLite2JsonDatabase;
import world.bentobox.bentobox.database.transition.Yaml2JsonDatabase;
import world.bentobox.bentobox.database.transition.Yaml2MariaDBDatabase;
import world.bentobox.bentobox.database.transition.Yaml2MongoDBDatabase;
import world.bentobox.bentobox.database.transition.Yaml2MySQLDatabase;
import world.bentobox.bentobox.database.transition.Yaml2SQLiteDatabase;
import world.bentobox.bentobox.database.yaml.YamlDatabase;
public interface DatabaseSetup {
    static DatabaseSetup getDatabase() {
        BentoBox plugin = BentoBox.getInstance();
        return Arrays.stream(DatabaseType.values())
                .filter(plugin.getSettings().getDatabaseType()::equals)
                .findFirst()
                .map(t -> t.database)
                .orElseGet(() -> DatabaseType.JSON.database);
    }
    enum DatabaseType {
        YAML(new YamlDatabase()),
        YAML2JSON(new Yaml2JsonDatabase()),
        YAML2MYSQL(new Yaml2MySQLDatabase()),
        YAML2MARIADB(new Yaml2MariaDBDatabase()),
        YAML2MONGODB(new Yaml2MongoDBDatabase()),
        YAML2SQLITE(new Yaml2SQLiteDatabase()),
        JSON(new JSONDatabase()),
        JSON2MYSQL(new Json2MySQLDatabase()),
        JSON2MARIADB(new Json2MariaDBDatabase()),
        JSON2MONGODB(new Json2MongoDBDatabase()),
        JSON2SQLITE(new Json2SQLiteDatabase()),
        JSON2POSTGRESQL(new Json2PostgreSQLDatabase()),
        MYSQL(new MySQLDatabase()),
        MYSQL2JSON(new MySQL2JsonDatabase()),
        MARIADB(new MariaDBDatabase()),
        MARIADB2JSON(new MariaDB2JsonDatabase()),
        MONGODB(new MongoDBDatabase()),
        MONGODB2JSON(new MongoDB2JsonDatabase()),
        SQLITE(new SQLiteDatabase()),
        SQLITE2JSON(new SQLite2JsonDatabase()),
        POSTGRESQL(new PostgreSQLDatabase()),
        POSTGRESQL2JSON(new PostgreSQL2JsonDatabase());
        DatabaseSetup database;
        DatabaseType(DatabaseSetup database){
            this.database = database;
        }
    }
    <T> AbstractDatabaseHandler<T> getHandler(Class<T> dataObjectClass);
}
package world.bentobox.bentobox.database.json;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
public class JSONDatabase implements DatabaseSetup {
    private final JSONDatabaseConnector connector = new JSONDatabaseConnector(BentoBox.getInstance());
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> dataObjectClass) {
        return new JSONDatabaseHandler<>(BentoBox.getInstance(), dataObjectClass, connector);
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.sql.sqlite.SQLiteDatabase;
public class Json2SQLiteDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new JSONDatabase().getHandler(type), new SQLiteDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.sql.sqlite;
import java.io.File;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
public class SQLiteDatabase implements DatabaseSetup
{
    private static final String DATABASE_FOLDER_NAME = "database";
    private SQLiteDatabaseConnector connector;
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> dataObjectClass)
    {
        if (this.connector == null)
        {
            BentoBox plugin = BentoBox.getInstance();
            File dataFolder = new File(plugin.getDataFolder(), DATABASE_FOLDER_NAME);
            if (!dataFolder.exists() && !dataFolder.mkdirs())
            {
                plugin.logError("Could not create database folder!");
                plugin.onDisable();
                return null;
            }
            this.connector = new SQLiteDatabaseConnector("jdbc:sqlite:" + dataFolder.getAbsolutePath() + File.separator + "database.db");
        }
        return new SQLiteDatabaseHandler<>(BentoBox.getInstance(), dataObjectClass, this.connector);
    }
}
package world.bentobox.bentobox.database;
import java.beans.IntrospectionException;
import java.lang.reflect.InvocationTargetException;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;
import org.bukkit.Bukkit;
import org.bukkit.scheduler.BukkitTask;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.Addon;
public abstract class AbstractDatabaseHandler<T> {
    protected Queue<Runnable> processQueue;
    private BukkitTask asyncSaveTask;
    private boolean inSave;
    protected boolean shutdown;
    protected static final String DATABASE_FOLDER_NAME = "database";
    protected Class<T> dataObject;
    protected DatabaseConnector databaseConnector;
    protected BentoBox plugin;
    @Nullable
    private Addon addon;
    @Nullable
    public Addon getAddon() {
        return addon;
    }
    public void setAddon(@Nullable Addon addon) {
        this.addon = addon;
    }
    protected AbstractDatabaseHandler(BentoBox plugin, Class<T> type, DatabaseConnector databaseConnector) {
        this.plugin = plugin;
        this.databaseConnector = databaseConnector;
        this.dataObject = type;
        if (!plugin.isEnabled()) return;
        processQueue = new ConcurrentLinkedQueue<>();
        asyncSaveTask = Bukkit.getScheduler().runTaskTimerAsynchronously(plugin, () -> {
            if(shutdown || plugin.isShutdown()) {
                databaseConnector.closeConnection(dataObject);
                asyncSaveTask.cancel();
            } else if (!inSave && !processQueue.isEmpty()) {
                inSave = true;
                while(!processQueue.isEmpty()) {
                    processQueue.poll().run();
                }
                inSave = false;
            }
        }, 0L, 1L);
    }
    protected AbstractDatabaseHandler() {}
    public abstract List<T> loadObjects() throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException, IntrospectionException, NoSuchMethodException;
    @Nullable
    public abstract T loadObject(@NonNull String uniqueId) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException, IntrospectionException, NoSuchMethodException;
    public CompletableFuture<List<T>> loadObjectsASync() {
        CompletableFuture<List<T>> completableFuture = new CompletableFuture<>();
        Bukkit.getScheduler().runTaskAsynchronously(BentoBox.getInstance(), () -> {
            try {
                completableFuture.complete(loadObjects()); 
            } catch (Exception e) {
                completableFuture.completeExceptionally(e); 
                plugin.logError("Failed to load objects asynchronously: " + e.getMessage());
            }
        });
        return completableFuture;
    }
    public abstract CompletableFuture<Boolean> saveObject(T instance) throws IllegalAccessException, InvocationTargetException, IntrospectionException ;
    public abstract void deleteObject(T instance) throws IllegalAccessException, InvocationTargetException, IntrospectionException ;
    public abstract boolean objectExists(String uniqueId);
    public abstract void close();
    public abstract void deleteID(String uniqueId);
}
package world.bentobox.bentobox.database.sql.postgresql;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseConnectionSettingsImpl;
import world.bentobox.bentobox.database.DatabaseSetup;
public class PostgreSQLDatabase implements DatabaseSetup
{
    PostgreSQLDatabaseConnector connector;
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> dataObjectClass)
    {
        BentoBox plugin = BentoBox.getInstance();
        if (this.connector == null)
        {
            this.connector = new PostgreSQLDatabaseConnector(new DatabaseConnectionSettingsImpl(
                    plugin.getSettings().getDatabaseHost(),
                    plugin.getSettings().getDatabasePort(),
                    plugin.getSettings().getDatabaseName(),
                    plugin.getSettings().getDatabaseUsername(),
                    plugin.getSettings().getDatabasePassword(),
                    plugin.getSettings().isUseSSL(),
                    plugin.getSettings().getMaximumPoolSize()));
        }
        return new PostgreSQLDatabaseHandler<>(plugin, dataObjectClass, this.connector);
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.mongodb.MongoDBDatabase;
public class Json2MongoDBDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new JSONDatabase().getHandler(type), new MongoDBDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.mongodb;
import org.bukkit.Bukkit;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseConnectionSettingsImpl;
import world.bentobox.bentobox.database.DatabaseSetup;
public class MongoDBDatabase implements DatabaseSetup {
    private MongoDBDatabaseConnector connector;
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        BentoBox plugin = BentoBox.getInstance();
        if (Bukkit.getPluginManager().getPlugin("BsbMongo") == null) {
            plugin.logError("You must install BsbMongo plugin for MongoDB support!");
            plugin.logError("See: https:
            Bukkit.getPluginManager().disablePlugin(plugin);
            return null;
        }
        if (connector == null) {
            connector = new MongoDBDatabaseConnector(new DatabaseConnectionSettingsImpl(
                    plugin.getSettings().getDatabaseHost(),
                    plugin.getSettings().getDatabasePort(),
                    plugin.getSettings().getDatabaseName(),
                    plugin.getSettings().getDatabaseUsername(),
                    plugin.getSettings().getDatabasePassword(),
                    plugin.getSettings().isUseSSL()
            ), plugin.getSettings().getMongodbConnectionUri());
        }
        return new MongoDBDatabaseHandler<>(plugin, type, connector);
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.sql.mysql.MySQLDatabase;
public class Json2MySQLDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new JSONDatabase().getHandler(type), new MySQLDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.sql.postgresql.PostgreSQLDatabase;
public class PostgreSQL2JsonDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> dataObjectClass) {
        return new TransitionDatabaseHandler<>(dataObjectClass, new PostgreSQLDatabase().getHandler(dataObjectClass), new JSONDatabase().getHandler(dataObjectClass));
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.mongodb.MongoDBDatabase;
public class MongoDB2JsonDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new MongoDBDatabase().getHandler(type), new JSONDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.sql.mariadb.MariaDBDatabase;
import world.bentobox.bentobox.database.yaml.YamlDatabase;
public class Yaml2MariaDBDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new YamlDatabase().getHandler(type), new MariaDBDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.sql.mysql.MySQLDatabase;
import world.bentobox.bentobox.database.yaml.YamlDatabase;
public class Yaml2MySQLDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new YamlDatabase().getHandler(type), new MySQLDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.sql.mysql.MySQLDatabase;
public class MySQL2JsonDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new MySQLDatabase().getHandler(type), new JSONDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.sql.mysql;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseConnectionSettingsImpl;
import world.bentobox.bentobox.database.DatabaseSetup;
public class MySQLDatabase implements DatabaseSetup
{
    private MySQLDatabaseConnector connector;
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type)
    {
        BentoBox plugin = BentoBox.getInstance();
        if (this.connector == null)
        {
            this.connector = new MySQLDatabaseConnector(new DatabaseConnectionSettingsImpl(
                    plugin.getSettings().getDatabaseHost(),
                    plugin.getSettings().getDatabasePort(),
                    plugin.getSettings().getDatabaseName(),
                    plugin.getSettings().getDatabaseUsername(),
                    plugin.getSettings().getDatabasePassword(),
                    plugin.getSettings().isUseSSL(),
                    plugin.getSettings().getMaximumPoolSize()));
        }
        return new MySQLDatabaseHandler<>(plugin, type, this.connector);
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.sql.mariadb.MariaDBDatabase;
public class MariaDB2JsonDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new MariaDBDatabase().getHandler(type), new JSONDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.sql.mariadb;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseConnectionSettingsImpl;
import world.bentobox.bentobox.database.DatabaseSetup;
public class MariaDBDatabase implements DatabaseSetup
{
    private MariaDBDatabaseConnector connector;
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type)
    {
        BentoBox plugin = BentoBox.getInstance();
        if (this.connector == null)
        {
            this.connector = new MariaDBDatabaseConnector(new DatabaseConnectionSettingsImpl(
                    plugin.getSettings().getDatabaseHost(),
                    plugin.getSettings().getDatabasePort(),
                    plugin.getSettings().getDatabaseName(),
                    plugin.getSettings().getDatabaseUsername(),
                    plugin.getSettings().getDatabasePassword(),
                    plugin.getSettings().isUseSSL(),
                    plugin.getSettings().getMaximumPoolSize()));
        }
        return new MariaDBDatabaseHandler<>(plugin, type, this.connector);
    }
}
package world.bentobox.bentobox;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Optional;
import org.apache.commons.lang.exception.ExceptionUtils;
import org.bukkit.Bukkit;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.server.ServerCommandEvent;
import org.bukkit.generator.ChunkGenerator;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitTask;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.api.configuration.Config;
import world.bentobox.bentobox.api.events.BentoBoxReadyEvent;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.Notifier;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.commands.BentoBoxCommand;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.hooks.FancyNpcsHook;
import world.bentobox.bentobox.hooks.ItemsAdderHook;
import world.bentobox.bentobox.hooks.MultipaperHook;
import world.bentobox.bentobox.hooks.MultiverseCoreHook;
import world.bentobox.bentobox.hooks.MyWorldsHook;
import world.bentobox.bentobox.hooks.MythicMobsHook;
import world.bentobox.bentobox.hooks.SlimefunHook;
import world.bentobox.bentobox.hooks.VaultHook;
import world.bentobox.bentobox.hooks.ZNPCsPlusHook;
import world.bentobox.bentobox.hooks.placeholders.PlaceholderAPIHook;
import world.bentobox.bentobox.listeners.BannedCommands;
import world.bentobox.bentobox.listeners.BlockEndDragon;
import world.bentobox.bentobox.listeners.DeathListener;
import world.bentobox.bentobox.listeners.JoinLeaveListener;
import world.bentobox.bentobox.listeners.PanelListenerManager;
import world.bentobox.bentobox.listeners.PrimaryIslandListener;
import world.bentobox.bentobox.listeners.SeedWorldMakerListener;
import world.bentobox.bentobox.listeners.StandardSpawnProtectionListener;
import world.bentobox.bentobox.listeners.teleports.EntityTeleportListener;
import world.bentobox.bentobox.listeners.teleports.PlayerTeleportListener;
import world.bentobox.bentobox.managers.AddonsManager;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.managers.CommandsManager;
import world.bentobox.bentobox.managers.FlagsManager;
import world.bentobox.bentobox.managers.HooksManager;
import world.bentobox.bentobox.managers.IslandDeletionManager;
import world.bentobox.bentobox.managers.IslandWorldManager;
import world.bentobox.bentobox.managers.IslandsManager;
import world.bentobox.bentobox.managers.LocalesManager;
import world.bentobox.bentobox.managers.PlaceholdersManager;
import world.bentobox.bentobox.managers.PlayersManager;
import world.bentobox.bentobox.managers.RanksManager;
import world.bentobox.bentobox.managers.WebManager;
import world.bentobox.bentobox.util.heads.HeadGetter;
import world.bentobox.bentobox.versions.ServerCompatibility;
public class BentoBox extends JavaPlugin implements Listener {
    private static BentoBox instance;
    private PlayersManager playersManager;
    private IslandsManager islandsManager;
    private CommandsManager commandsManager;
    private LocalesManager localesManager;
    private AddonsManager addonsManager;
    private FlagsManager flagsManager;
    private IslandWorldManager islandWorldManager;
    private BlueprintsManager blueprintsManager;
    private HooksManager hooksManager;
    private PlaceholdersManager placeholdersManager;
    private IslandDeletionManager islandDeletionManager;
    private WebManager webManager;
    private Settings settings;
    private Notifier notifier;
    private HeadGetter headGetter;
    private boolean isLoaded;
    @Nullable
    private BStats metrics;
    private Config<Settings> configObject;
    private BukkitTask blueprintLoadingTask;
    private boolean shutdown;
    @Override
    public void onEnable(){
        setInstance(this);
        if (!ServerCompatibility.getInstance().checkCompatibility().isCanLaunch()) {
            logWarning("************ Disclaimer **************");
            logWarning("BentoBox may not be compatible with this server!");
            logWarning("BentoBox is tested only on the following Spigot versions:");
            List<String> versions = ServerCompatibility.ServerVersion.getVersions(ServerCompatibility.Compatibility.COMPATIBLE, ServerCompatibility.Compatibility.SUPPORTED)
                    .stream().map(ServerCompatibility.ServerVersion::toString).toList();
            logWarning(String.join(", ", versions));
            logWarning("**************************************");
        }
        isLoaded = false;
        final long loadStart = System.currentTimeMillis();
        saveDefaultConfig();
        flagsManager = new FlagsManager(this);
        if (!loadSettings()) {
            return;
        }
        saveConfig();
        playersManager = new PlayersManager(this);
        if (!this.isEnabled()) {
            return;
        }
        islandsManager = new IslandsManager(this);
        headGetter = new HeadGetter(this);
        notifier = new Notifier();
        commandsManager = new CommandsManager();
        new BentoBoxCommand();
        islandWorldManager = new IslandWorldManager(this);
        blueprintsManager = new BlueprintsManager(this);
        localesManager = new LocalesManager(this);
        hooksManager = new HooksManager(this);
        addonsManager = new AddonsManager(this);
        addonsManager.loadAddons();
        final long loadTime = System.currentTimeMillis() - loadStart;
        Bukkit.getScheduler().runTask(instance, () -> {
            try {
                completeSetup(loadTime);
            } catch (Exception e) {
                fireCriticalError(e.getMessage(), "");
                e.printStackTrace();
            }
        });
    }
    private void completeSetup(long loadTime) {
        final long enableStart = System.currentTimeMillis();
        hooksManager.registerHook(new MultipaperHook());
        hooksManager.registerHook(new VaultHook());
        hooksManager.registerHook(new FancyNpcsHook());
        hooksManager.registerHook(new ZNPCsPlusHook());
        hooksManager.registerHook(new MythicMobsHook());
        hooksManager.registerHook(new PlaceholderAPIHook());
        placeholdersManager = new PlaceholdersManager(this);
        addonsManager.enableAddons();
        addonsManager.getGameModeAddons().forEach(placeholdersManager::registerDefaultPlaceholders);
        registerListeners();
        log("Loading islands from database...");
        try {
            islandsManager.load();
        } catch (Exception e) {
            fireCriticalError(e.getMessage(), "Could not load islands!");
            return;
        }
        flagsManager.registerListeners();
        metrics = new BStats(this);
        metrics.registerMetrics();
        hooksManager.registerHook(new MultiverseCoreHook());
        hooksManager.registerHook(new MyWorldsHook());
        islandWorldManager.registerWorldsToMultiverse(true);
        hooksManager.registerHook(new SlimefunHook());
        hooksManager.registerHook(new ItemsAdderHook(this));
        webManager = new WebManager(this);
        final long enableTime = System.currentTimeMillis() - enableStart;
        User.getInstance(Bukkit.getConsoleSender()).sendMessage("successfully-loaded",
                TextVariables.VERSION, instance.getDescription().getVersion(),
                "[time]", String.valueOf(loadTime + enableTime));
        blueprintLoadingTask = Bukkit.getScheduler().runTaskTimer(instance, () -> {
            if (getBlueprintsManager().isBlueprintsLoaded()) {
                blueprintLoadingTask.cancel();
                isLoaded = true;
                this.addonsManager.allLoaded();
                settings.getReadyCommands().forEach(cmd -> Bukkit.getServer().dispatchCommand(getServer().getConsoleSender(), cmd));
                Bukkit.getPluginManager().callEvent(new BentoBoxReadyEvent());
                instance.log("All blueprints loaded.");
            }
        }, 0L, 1L);
        if (getSettings().getDatabaseType().equals(DatabaseSetup.DatabaseType.YAML)) {
            logWarning("*** You're still using YAML database ! ***");
            logWarning("This database type is being deprecated from BentoBox as some official addons encountered difficulties supporting it correctly.");
            logWarning("You should switch ASAP to an alternative database type. Please refer to the comments in BentoBox's config.yml.");
            logWarning("There is NO guarantee YAML database will remain properly supported in the following updates, and its usage should as such be considered a non-viable situation.");
            logWarning("*** *** *** *** *** *** *** *** *** *** ***");
        }
    }
    private void fireCriticalError(String message, String error) {
        logError("*****************CRITICAL ERROR!******************");
        logError(message);
        logError(error + " Disabling BentoBox...");
        logError("*************************************************");
        if (addonsManager != null) {
            addonsManager.disableAddons();
        }
        shutdown = true;
        instance.setEnabled(false);
    }
    private void registerListeners() {
        PluginManager manager = getServer().getPluginManager();
        manager.registerEvents(new JoinLeaveListener(this), this);
        manager.registerEvents(new PanelListenerManager(), this);
        manager.registerEvents(new StandardSpawnProtectionListener(this), this);
        manager.registerEvents(new PlayerTeleportListener(this), this);
        manager.registerEvents(new EntityTeleportListener(this), this);
        manager.registerEvents(new BlockEndDragon(this), this);
        manager.registerEvents(new BannedCommands(this), this);
        manager.registerEvents(new DeathListener(this), this);
        manager.registerEvents(this, this);
        islandDeletionManager = new IslandDeletionManager(this);
        manager.registerEvents(islandDeletionManager, this);
        manager.registerEvents(new PrimaryIslandListener(this), this);
        manager.registerEvents(new SeedWorldMakerListener(this), this);
    }
    @Override
    public void onDisable() {
        shutdown = true;
        HeadGetter.shutdown();
        if (addonsManager != null) {
            addonsManager.disableAddons();
        }
        if (playersManager != null) {
            playersManager.shutdown();
        }
        if (islandsManager != null) {
            islandsManager.shutdown();
        }
    }
    @EventHandler
    public void onServerStop(ServerCommandEvent e) {
    }
    public PlayersManager getPlayers() {
        return playersManager;
    }
    public PlayersManager getPlayersManager() {
        return getPlayers();
    }
    public IslandsManager getIslands() {
        return islandsManager;
    }
    public IslandsManager getIslandsManager() {
        return getIslands();
    }
    private static void setInstance(BentoBox plugin) {
        BentoBox.instance = plugin;
    }
    public static BentoBox getInstance() {
        return instance;
    }
    public CommandsManager getCommandsManager() {
        return commandsManager;
    }
    public LocalesManager getLocalesManager() {
        return localesManager;
    }
    public AddonsManager getAddonsManager() {
        return addonsManager;
    }
    public FlagsManager getFlagsManager() {
        return flagsManager;
    }
    @Deprecated(since = "2.0.0", forRemoval = true)
    public RanksManager getRanksManager() {
        return RanksManager.getInstance();
    }
    public IslandWorldManager getIWM() {
        return islandWorldManager;
    }
    public Settings getSettings() {
        return settings;
    }
    public boolean loadSettings() {
        log("Loading Settings from config.yml...");
        if (configObject == null) configObject = new Config<>(this, Settings.class);
        settings = configObject.loadConfigObject();
        if (settings == null) {
            logError("Settings did not load correctly - disabling plugin - please check config.yml");
            getPluginLoader().disablePlugin(this);
            return false;
        }
        log("Saving default panels...");
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "island_creation_panel.yml"))) {
            log("Saving default island_creation_panel...");
            this.saveResource("panels/island_creation_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "language_panel.yml"))) {
            log("Saving default language_panel...");
            this.saveResource("panels/language_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "island_homes_panel.yml"))) {
            log("Saving default island_homes_panel...");
            this.saveResource("panels/island_homes_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "team_invite_panel.yml"))) {
            log("Saving default team_invite_panel...");
            this.saveResource("panels/team_invite_panel.yml", false);
        }
        if (!Files.exists(Path.of(this.getDataFolder().getPath(), "panels", "team_panel.yml"))) {
            log("Saving default team_panel...");
            this.saveResource("panels/team_panel.yml", false);
        }
        return true;
    }
    @Override
    public void saveConfig() {
        if (settings != null) configObject.saveConfigObject(settings);
    }
    public Notifier getNotifier() {
        return notifier;
    }
    public HeadGetter getHeadGetter() {
        return headGetter;
    }
    public void log(String string) {
        getLogger().info(() -> string);
    }
    public void logDebug(Object object) {
        getLogger().info(() -> "DEBUG: " + object);
    }
    public void logError(String error) {
        getLogger().severe(() -> error);
    }
    public void logStacktrace(@NonNull Throwable throwable) {
        logError(ExceptionUtils.getStackTrace(throwable));
    }
    public void logWarning(String warning) {
        getLogger().warning(() -> warning);
    }
    public BlueprintsManager getBlueprintsManager() {
        return blueprintsManager;
    }
    public boolean isLoaded() {
        return isLoaded;
    }
    public HooksManager getHooks() {
        return hooksManager;
    }
    public Optional<VaultHook> getVault() {
        return Optional.ofNullable((VaultHook) hooksManager.getHook("Vault").orElse(null));
    }
    public PlaceholdersManager getPlaceholdersManager() {
        return placeholdersManager;
    }
    public IslandDeletionManager getIslandDeletionManager() {
        return islandDeletionManager;
    }
    @NonNull
    public Optional<BStats> getMetrics() {
        return Optional.ofNullable(metrics);
    }
    public WebManager getWebManager() {
        return webManager;
    }
    @Override
    public ChunkGenerator getDefaultWorldGenerator(@NonNull String worldName, String id) {
        return addonsManager.getDefaultWorldGenerator(worldName, id);
    }
    @Override
    public void reloadConfig() {
        loadSettings();
    }
    public boolean isShutdown() {
        return shutdown;
    }
}
package world.bentobox.bentobox;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import org.bukkit.Material;
import com.google.common.collect.ImmutableList;
import world.bentobox.bentobox.api.configuration.ConfigComment;
import world.bentobox.bentobox.api.configuration.ConfigEntry;
import world.bentobox.bentobox.api.configuration.ConfigObject;
import world.bentobox.bentobox.api.configuration.StoreAt;
import world.bentobox.bentobox.database.DatabaseSetup.DatabaseType;
@StoreAt(filename = "config.yml") 
@ConfigComment("BentoBox v[version] configuration file.")
@ConfigComment("")
public class Settings implements ConfigObject {
    @ConfigComment("Default language for new players.")
    @ConfigComment("This is the filename in the locale folder without .yml.")
    @ConfigComment("If this does not exist, the default en-US will be used.")
    @ConfigEntry(path = "general.default-language")
    private String defaultLanguage = "en-US";
    @ConfigComment("Use economy or not. If true, an economy plugin is required. If false, no money is used or given.")
    @ConfigComment("If there is no economy plugin present anyway, money will be automatically disabled.")
    @ConfigEntry(path = "general.use-economy")
    private boolean useEconomy = true;
    @ConfigComment("Console commands to run when BentoBox has loaded all worlds and addons.")
    @ConfigComment("Commands are run as the console.")
    @ConfigComment("e.g. set aliases for worlds in Multiverse here, or anything you need to")
    @ConfigComment("run after the plugin is fully loaded.")
    @ConfigEntry(path = "general.ready-commands", since = "1.24.2")
    private List<String> readyCommands = new ArrayList<>();
    @ConfigComment("JSON, MYSQL, MARIADB, MONGODB, SQLITE, and POSTGRESQL.")
    @ConfigComment("Transition database options are:")
    @ConfigComment("  JSON2MARIADB, JSON2MYSQL, JSON2MONGODB, JSON2SQLITE, JSON2POSTGRESQL")
    @ConfigComment("  MYSQL2JSON, MARIADB2JSON, MONGODB2JSON, SQLITE2JSON, POSTGRESQL2JSON")
    @ConfigComment("If you need others, please make a feature request.")
    @ConfigComment("Minimum required versions:")
    @ConfigComment("   MySQL versions 5.7 or later")
    @ConfigComment("   MariaDB versions 10.2.3 or later")
    @ConfigComment("   MongoDB versions 3.6 or later")
    @ConfigComment("   SQLite versions 3.28 or later")
    @ConfigComment("   PostgreSQL versions 9.4 or later")
    @ConfigComment("Transition options enable migration from one database type to another. Use /bbox migrate.")
    @ConfigComment("JSON is a file-based database.")
    @ConfigComment("MYSQL might not work with all implementations: if available, use a dedicated database type (e.g. MARIADB).")
    @ConfigComment("BentoBox uses HikariCP for connecting with SQL databases.")
    @ConfigComment("If you use MONGODB, you must also run the BSBMongo plugin (not addon).")
    @ConfigComment("See https:
    @ConfigEntry(path = "general.database.type", video = "https:
    private DatabaseType databaseType = DatabaseType.JSON;
    @ConfigEntry(path = "general.database.host")
    private String databaseHost = "localhost";
    @ConfigComment("Port 3306 is MySQL's default. Port 27017 is MongoDB's default.")
    @ConfigEntry(path = "general.database.port")
    private int databasePort = 3306;
    @ConfigEntry(path = "general.database.name")
    private String databaseName = "bentobox";
    @ConfigEntry(path = "general.database.username")
    private String databaseUsername = "username";
    @ConfigEntry(path = "general.database.password")
    private String databasePassword = "password";
    @ConfigComment("How often the data will be saved to file in mins. Default is 5 minutes.")
    @ConfigComment("This helps prevent issues if the server crashes.")
    @ConfigComment("Data is also saved at important points in the game.")
    @ConfigEntry(path = "general.database.backup-period")
    private int databaseBackupPeriod = 5;
    @ConfigComment("How many players will be saved in one tick. Default is 200")
    @ConfigComment("Reduce if you experience lag while saving.")
    @ConfigComment("Do not set this too low or data might get lost!")
    @ConfigEntry(path = "general.database.max-saved-players-per-tick")
    private int maxSavedPlayersPerTick = 20;
    @ConfigComment("How many islands will be saved in one tick. Default is 200")
    @ConfigComment("Reduce if you experience lag while saving.")
    @ConfigComment("Do not set this too low or data might get lost!")
    @ConfigEntry(path = "general.database.max-saved-islands-per-tick")
    private int maxSavedIslandsPerTick = 20;
    @ConfigComment("Number of active connections to the SQL database at the same time.")
    @ConfigComment("Default 10.")
    @ConfigEntry(path = "general.database.max-pool-size", since = "1.21.0")
    private int maximumPoolSize = 10;
    @ConfigComment("Enable SSL connection to MongoDB, MariaDB, MySQL and PostgreSQL databases.")
    @ConfigEntry(path = "general.database.use-ssl", since = "1.12.0")
    private boolean useSSL = false;
    @ConfigComment("Database table prefix. Adds a prefix to the database tables. Not used by flatfile databases.")
    @ConfigComment("Only the characters A-Z, a-z, 0-9 can be used. Invalid characters will become an underscore.")
    @ConfigComment("Set this to a unique value if you are running multiple BentoBox instances that share a database.")
    @ConfigComment("Be careful about length - databases usually have a limit of 63 characters for table lengths")
    @ConfigEntry(path = "general.database.prefix-character", since = "1.13.0")
    private String databasePrefix = "";
    @ConfigComment("Custom connection datasource properties that will be applied to connection pool.")
    @ConfigComment("Check available values to your SQL driver implementation.")
    @ConfigComment("Example: ")
    @ConfigComment("  custom-properties: ")
    @ConfigComment("    cachePrepStmts: 'true'")
    @ConfigComment("    prepStmtCacheSize: '250'")
    @ConfigComment("    prepStmtCacheSqlLimit: '2048'")
    @ConfigEntry(path = "general.database.custom-properties", since = "1.21.0")
    private Map<String, String> customPoolProperties = new HashMap<>();
    @ConfigComment("MongoDB client connection URI to override default connection options.")
    @ConfigComment("See: https:
    @ConfigEntry(path = "general.database.mongodb-connection-uri", since = "1.14.0")
    private String mongodbConnectionUri = "";
    @ConfigComment("Allow FTB Autonomous Activator to work (will allow a pseudo player [CoFH] to place and break blocks and hang items)")
    @ConfigComment("Add other fake player names here if required")
    @ConfigEntry(path = "general.fakeplayers", experimental = true)
    private Set<String> fakePlayers = new HashSet<>();
    @ConfigComment("Toggle whether panels should be closed or not when the player clicks anywhere outside of the inventory view.")
    @ConfigEntry(path = "panel.close-on-click-outside")
    private boolean closePanelOnClickOutside = true;
    @ConfigComment("Defines the Material of the item that fills the gaps (in the header, etc.) of most panels.")
    @ConfigEntry(path = "panel.filler-material", since = "1.14.0")
    private Material panelFillerMaterial = Material.LIGHT_BLUE_STAINED_GLASS_PANE;
    @ConfigComment("Toggle whether player head texture should be gathered from Mojang API or mc-heads.net cache server.")
    @ConfigComment("Mojang API sometime may be slow and may limit requests to the player data, so this will allow to")
    @ConfigComment("get player heads a bit faster then Mojang API.")
    @ConfigEntry(path = "panel.use-cache-server", since = "1.16.0")
    private boolean useCacheServer = false;
    @ConfigComment("Defines how long player skin texture link is stored into local cache before it is requested again.")
    @ConfigComment("Defined value is in the minutes.")
    @ConfigComment("Value 0 will not clear cache until server restart.")
    @ConfigEntry(path = "panel.head-cache-time", since = "1.14.1")
    private long playerHeadCacheTime = 60;
    @ConfigComment("Defines a number of player heads requested per tasks.")
    @ConfigComment("Setting it too large may lead to temporarily being blocked from head gatherer API.")
    @ConfigEntry(path = "panel.heads-per-call", since = "1.16.0")
    private int headsPerCall = 9;
    @ConfigComment("Defines a number of ticks between each player head request task.")
    @ConfigComment("Setting it too large may lead to temporarily being blocked from head gatherer API.")
    @ConfigEntry(path = "panel.ticks-between-calls", since = "1.16.0", needsRestart = true)
    private long ticksBetweenCalls = 10;
    @ConfigComment("Toggle whether superflat chunks regeneration should be logged in the server logs or not.")
    @ConfigComment("It can be spammy if there are a lot of superflat chunks to regenerate.")
    @ConfigComment("However, as superflat chunks regeneration can be performance-intensive, it is recommended to keep")
    @ConfigComment("this setting set to true, as it will help you know if there are regenerations taking place.")
    @ConfigEntry(path = "logs.clean-super-flat-chunks", since = "1.2.0")
    private boolean logCleanSuperFlatChunks = true;
    @ConfigComment("Toggle whether downloading data from GitHub should be logged in the server logs or not.")
    @ConfigEntry(path = "logs.github-download-data", since = "1.5.0")
    private boolean logGithubDownloadData = true;
    @ConfigComment("Override island distance mismatch checking. BentoBox normally refuses to run if")
    @ConfigComment("the island distance in the gamemode config is different to the one stored in the database")
    @ConfigComment("for safety. This overrides that check. You should never need this, and if you do not understand it")
    @ConfigComment("keep it as false")
    @ConfigEntry(path = "island.override-safety-check")
    private boolean overrideSafetyCheck = false;
    @ConfigComment("The default number of concurrent islands a player may have.")
    @ConfigComment("This may be overridden by individual game mode config settings.")
    @ConfigEntry(path = "island.concurrent-islands")
    private int islandNumber = 1;
    @ConfigComment("Hide used blueprints.")
    @ConfigComment("Blueprints can have a maximum use when players have concurrent islands.")
    @ConfigComment("If this is true, then ones that are used up will not be shown in the island create menu.")
    @ConfigEntry(path = "island.hide-used-blueprints", since = "2.3.0")
    private boolean hideUsedBlueprints = false;
    @ConfigComment("How long a player must wait until they can rejoin a team island after being kicked in minutes.")
    @ConfigComment("This slows the effectiveness of players repeating challenges")
    @ConfigComment("by repetitively being invited to a team island.")
    @ConfigEntry(path = "island.cooldown.time.invite")
    private int inviteCooldown = 60;
    @ConfigComment("How long a player must wait until they can coop a player in minutes.")
    @ConfigEntry(path = "island.cooldown.time.coop")
    private int coopCooldown = 5;
    @ConfigComment("How long a player must wait until they can trust a player in minutes.")
    @ConfigEntry(path = "island.cooldown.time.trust")
    private int trustCooldown = 5;
    @ConfigComment("How long a player must wait until they can ban a player after unbanning them. In minutes.")
    @ConfigEntry(path = "island.cooldown.time.ban")
    private int banCooldown = 10;
    @ConfigComment("How long a player must wait before they can reset their island again in seconds.")
    @ConfigEntry(path = "island.cooldown.time.reset")
    private int resetCooldown = 300;
    @ConfigComment("Whether the reset cooldown should be applied when the player creates an island for the first time or not.")
    @ConfigEntry(path = "island.cooldown.options.set-reset-cooldown-on-create", since = "1.2.0")
    private boolean resetCooldownOnCreate = true;
    @ConfigComment("Time in seconds that players have to confirm sensitive commands, e.g. island reset.")
    @ConfigEntry(path = "island.confirmation.time")
    private int confirmationTime = 10;
    @ConfigComment("Time in seconds that players have to stand still before teleport commands activate, e.g. island go.")
    @ConfigEntry(path = "island.delay.time")
    private int delayTime = 0;
    @ConfigComment("Ask the player to confirm the command he is using by typing it again.")
    @ConfigEntry(path = "island.confirmation.commands.kick")
    private boolean kickConfirmation = true;
    @ConfigEntry(path = "island.confirmation.commands.leave")
    private boolean leaveConfirmation = true;
    @ConfigEntry(path = "island.confirmation.commands.reset")
    private boolean resetConfirmation = true;
    @ConfigComment("Ask the recipient to confirm trust or coop invites.")
    @ConfigComment("Team invites will always require confirmation, for safety concerns.")
    @ConfigEntry(path = "island.confirmation.invites", since = "1.8.0")
    private boolean inviteConfirmation = false;
    @ConfigComment("Sets the minimum length an island custom name is required to have.")
    @ConfigEntry(path = "island.name.min-length")
    private int nameMinLength = 4;
    @ConfigComment("Sets the maximum length an island custom name cannot exceed.")
    @ConfigEntry(path = "island.name.max-length")
    private int nameMaxLength = 20;
    @ConfigComment("Requires island custom names to be unique in the gamemode the island is in.")
    @ConfigComment("As a result, only one island per gamemode are allowed to share the same name.")
    @ConfigComment("Note that island names are purely cosmetics and are not used as a way to programmatically identify islands.")
    @ConfigEntry(path = "island.name.uniqueness", since = "1.7.0")
    private boolean nameUniqueness = false;
    @ConfigComment("Remove hostile mob on teleport box radius")
    @ConfigComment("If hostile mobs are cleared on player teleport, then this sized box will be cleared")
    @ConfigComment("around the player. e.g. 5 means a 10 x 10 x 10 box around the player")
    @ConfigComment("Be careful not to make this too big. Does not cover standard nether or end teleports.")
    @ConfigEntry(path = "island.clear-radius", since = "1.6.0")
    private int clearRadius = 5;
    @ConfigComment("Minimum nether portal search radius. If this is too low, duplicate portals may appear.")
    @ConfigComment("Vanilla default is 128.")
    @ConfigEntry(path = "island.portal-search-radius", since = "1.16.2")
    private int minPortalSearchRadius = 64;
    @ConfigComment("Number of blocks to paste per tick when pasting blueprints.")
    @ConfigComment("Smaller values will help reduce noticeable lag but will make pasting take slightly longer.")
    @ConfigComment("On the contrary, greater values will make pasting take less time, but this benefit is quickly severely impacted by the")
    @ConfigComment("resulting amount of chunks that must be loaded to fulfill the process, which often causes the server to hang out.")
    @ConfigEntry(path = "island.paste-speed")
    private int pasteSpeed = 64;
    @ConfigComment("Island deletion: Number of chunks per world to regenerate per second.")
    @ConfigComment("If there is a nether and end then 3x this number will be regenerated per second.")
    @ConfigComment("Smaller values will help reduce noticeable lag but will make deleting take longer.")
    @ConfigComment("A setting of 0 will leave island blocks (not recommended).")
    @ConfigEntry(path = "island.delete-speed", since = "1.7.0")
    private int deleteSpeed = 1;
    @ConfigComment("Toggles whether islands, when players are resetting them, should be kept in the world or deleted.")
    @ConfigComment("* If set to 'true', whenever a player resets his island, his previous island will become unowned and won't be deleted from the world.")
    @ConfigComment("  You can, however, still delete those unowned islands through purging.")
    @ConfigComment("  On bigger servers, this can lead to an increasing world size.")
    @ConfigComment("  Yet, this allows admins to retrieve a player's old island in case of an improper use of the reset command.")
    @ConfigComment("  Admins can indeed re-add the player to his old island by registering him to it.")
    @ConfigComment("* If set to 'false', whenever a player resets his island, his previous island will be deleted from the world.")
    @ConfigComment("  This is the default behaviour.")
    @ConfigEntry(path = "island.deletion.keep-previous-island-on-reset", since = "1.13.0")
    private boolean keepPreviousIslandOnReset = false;
    @ConfigComment("Toggles how the islands are deleted.")
    @ConfigComment("* If set to 'false', all islands will be deleted at once.")
    @ConfigComment("  This is fast but may cause an impact on the performance")
    @ConfigComment("  as it'll load all the chunks of the in-deletion islands.")
    @ConfigComment("* If set to 'true', the islands will be deleted one by one.")
    @ConfigComment("  This is slower but will not cause any impact on the performance.")
    @ConfigEntry(path = "island.deletion.slow-deletion", since = "1.19.1")
    private boolean slowDeletion = false;
    @ConfigComment("By default, If the destination is not safe, the plugin will try to search for a safe spot around the destination,")
    @ConfigComment("then it will try to expand the y-coordinate up and down from the destination.")
    @ConfigComment("This setting limits how far the y-coordinate will be expanded.")
    @ConfigComment("If set to 0 or lower, the plugin will not expand the y-coordinate.")
    @ConfigEntry(path = "island.safe-spot-search-vertical-range", since = "1.19.1")
    private int safeSpotSearchVerticalRange = 400;
    @ConfigComment("By default, if the destination is not safe, the plugin will try to search for a safe spot around the destination.")
    @ConfigComment("This allows to change the distance for searching this spot. Larger value will mean longer position search.")
    @ConfigComment("This value is also used for valid nether portal linking between dimension.")
    @ConfigEntry(path = "island.safe-spot-search-range", since = "1.21.0")
    private int safeSpotSearchRange = 16;
    @ConfigComment("Toggle whether BentoBox can connect to GitHub to get data about updates and addons.")
    @ConfigComment("Disabling this will result in the deactivation of the update checker and of some other")
    @ConfigComment("features that rely on the data downloaded from the GitHub API.")
    @ConfigComment("It does not send any data.")
    @ConfigEntry(path = "web.github.download-data", since = "1.5.0")
    private boolean githubDownloadData = true;
    @ConfigComment("Time in minutes between each connection to the GitHub API.")
    @ConfigComment("This allows for up-to-the-minute information gathering.")
    @ConfigComment("However, as the GitHub API data does not get updated instantly, this value cannot be set to less than 60 minutes.")
    @ConfigComment("Setting this to 0 will make BentoBox download data only at startup.")
    @ConfigEntry(path = "web.github.connection-interval", since = "1.5.0")
    private int githubConnectionInterval = 120;
    @ConfigEntry(path = "web.updater.check-updates.bentobox", since = "1.3.0", hidden = true)
    private boolean checkBentoBoxUpdates = true;
    @ConfigEntry(path = "web.updater.check-updates.addons", since = "1.3.0", hidden = true)
    private boolean checkAddonsUpdates = true;
    public String getDefaultLanguage() {
        return defaultLanguage;
    }
    public void setDefaultLanguage(String defaultLanguage) {
        this.defaultLanguage = defaultLanguage;
    }
    public boolean isUseEconomy() {
        return useEconomy;
    }
    public void setUseEconomy(boolean useEconomy) {
        this.useEconomy = useEconomy;
    }
    public DatabaseType getDatabaseType() {
        return databaseType;
    }
    public void setDatabaseType(DatabaseType databaseType) {
        this.databaseType = databaseType;
    }
    public String getDatabaseHost() {
        return databaseHost;
    }
    public void setDatabaseHost(String databaseHost) {
        this.databaseHost = databaseHost;
    }
    public int getDatabasePort() {
        return databasePort;
    }
    public boolean isUseSSL() {
        return useSSL;
    }
    public void setUseSSL(boolean useSSL) {
        this.useSSL = useSSL;
    }
    public void setDatabasePort(int databasePort) {
        this.databasePort = databasePort;
    }
    public String getDatabaseName() {
        return databaseName;
    }
    public void setDatabaseName(String databaseName) {
        this.databaseName = databaseName;
    }
    public String getDatabaseUsername() {
        return databaseUsername;
    }
    public void setDatabaseUsername(String databaseUsername) {
        this.databaseUsername = databaseUsername;
    }
    public String getDatabasePassword() {
        return databasePassword;
    }
    public void setDatabasePassword(String databasePassword) {
        this.databasePassword = databasePassword;
    }
    public int getDatabaseBackupPeriod() {
        return databaseBackupPeriod;
    }
    public void setDatabaseBackupPeriod(int databaseBackupPeriod) {
        this.databaseBackupPeriod = databaseBackupPeriod;
    }
    public int getMaxSavedPlayersPerTick() {
        return maxSavedPlayersPerTick;
    }
    public void setMaxSavedPlayersPerTick(int maxSavedPlayersPerTick) {
        this.maxSavedPlayersPerTick = maxSavedPlayersPerTick;
    }
    public int getMaxSavedIslandsPerTick() {
        return maxSavedIslandsPerTick;
    }
    public void setMaxSavedIslandsPerTick(int maxSavedIslandsPerTick) {
        this.maxSavedIslandsPerTick = maxSavedIslandsPerTick;
    }
    public Set<String> getFakePlayers() {
        return fakePlayers;
    }
    public void setFakePlayers(Set<String> fakePlayers) {
        this.fakePlayers = fakePlayers;
    }
    public boolean isClosePanelOnClickOutside() {
        return closePanelOnClickOutside;
    }
    public void setClosePanelOnClickOutside(boolean closePanelOnClickOutside) {
        this.closePanelOnClickOutside = closePanelOnClickOutside;
    }
    public int getInviteCooldown() {
        return inviteCooldown;
    }
    public void setInviteCooldown(int inviteCooldown) {
        this.inviteCooldown = inviteCooldown;
    }
    public int getCoopCooldown() {
        return coopCooldown;
    }
    public void setCoopCooldown(int coopCooldown) {
        this.coopCooldown = coopCooldown;
    }
    public int getTrustCooldown() {
        return trustCooldown;
    }
    public void setTrustCooldown(int trustCooldown) {
        this.trustCooldown = trustCooldown;
    }
    public int getBanCooldown() {
        return banCooldown;
    }
    public void setBanCooldown(int banCooldown) {
        this.banCooldown = banCooldown;
    }
    public int getResetCooldown() {
        return resetCooldown;
    }
    public void setResetCooldown(int resetCooldown) {
        this.resetCooldown = resetCooldown;
    }
    public int getConfirmationTime() {
        return confirmationTime;
    }
    public void setConfirmationTime(int confirmationTime) {
        this.confirmationTime = confirmationTime;
    }
    public boolean isKickConfirmation() {
        return kickConfirmation;
    }
    public void setKickConfirmation(boolean kickConfirmation) {
        this.kickConfirmation = kickConfirmation;
    }
    public boolean isLeaveConfirmation() {
        return leaveConfirmation;
    }
    public void setLeaveConfirmation(boolean leaveConfirmation) {
        this.leaveConfirmation = leaveConfirmation;
    }
    public boolean isResetConfirmation() {
        return resetConfirmation;
    }
    public void setResetConfirmation(boolean resetConfirmation) {
        this.resetConfirmation = resetConfirmation;
    }
    public int getNameMinLength() {
        return nameMinLength;
    }
    public void setNameMinLength(int nameMinLength) {
        this.nameMinLength = nameMinLength;
    }
    public int getNameMaxLength() {
        return nameMaxLength;
    }
    public void setNameMaxLength(int nameMaxLength) {
        this.nameMaxLength = nameMaxLength;
    }
    public boolean isNameUniqueness() {
        return nameUniqueness;
    }
    public void setNameUniqueness(boolean nameUniqueness) {
        this.nameUniqueness = nameUniqueness;
    }
    public void setPasteSpeed(int pasteSpeed) {
        this.pasteSpeed = pasteSpeed;
    }
    public int getPasteSpeed() {
        return this.pasteSpeed;
    }
    public int getDeleteSpeed() {
        return deleteSpeed;
    }
    public void setDeleteSpeed(int deleteSpeed) {
        this.deleteSpeed = deleteSpeed;
    }
    public boolean isLogCleanSuperFlatChunks() {
        return logCleanSuperFlatChunks;
    }
    public void setLogCleanSuperFlatChunks(boolean logCleanSuperFlatChunks) {
        this.logCleanSuperFlatChunks = logCleanSuperFlatChunks;
    }
    public boolean isResetCooldownOnCreate() {
        return resetCooldownOnCreate;
    }
    public void setResetCooldownOnCreate(boolean resetCooldownOnCreate) {
        this.resetCooldownOnCreate = resetCooldownOnCreate;
    }
    public boolean isGithubDownloadData() {
        return githubDownloadData;
    }
    public void setGithubDownloadData(boolean githubDownloadData) {
        this.githubDownloadData = githubDownloadData;
    }
    public int getGithubConnectionInterval() {
        return githubConnectionInterval;
    }
    public void setGithubConnectionInterval(int githubConnectionInterval) {
        this.githubConnectionInterval = githubConnectionInterval;
    }
    public boolean isCheckBentoBoxUpdates() {
        return checkBentoBoxUpdates;
    }
    public void setCheckBentoBoxUpdates(boolean checkBentoBoxUpdates) {
        this.checkBentoBoxUpdates = checkBentoBoxUpdates;
    }
    public boolean isCheckAddonsUpdates() {
        return checkAddonsUpdates;
    }
    public void setCheckAddonsUpdates(boolean checkAddonsUpdates) {
        this.checkAddonsUpdates = checkAddonsUpdates;
    }
    public boolean isLogGithubDownloadData() {
        return logGithubDownloadData;
    }
    public void setLogGithubDownloadData(boolean logGithubDownloadData) {
        this.logGithubDownloadData = logGithubDownloadData;
    }
    public int getDelayTime() {
        return delayTime;
    }
    public void setDelayTime(int delayTime) {
        this.delayTime = delayTime;
    }
    public int getClearRadius() {
        if (clearRadius < 0)
            clearRadius = 0;
        return clearRadius;
    }
    public void setClearRadius(int clearRadius) {
        if (clearRadius < 0)
            clearRadius = 0;
        this.clearRadius = clearRadius;
    }
    public boolean isInviteConfirmation() {
        return inviteConfirmation;
    }
    public void setInviteConfirmation(boolean inviteConfirmation) {
        this.inviteConfirmation = inviteConfirmation;
    }
    public String getDatabasePrefix() {
        if (databasePrefix == null)
            databasePrefix = "";
        return databasePrefix.isEmpty() ? "" : databasePrefix.replaceAll("[^a-zA-Z0-9]", "_");
    }
    public void setDatabasePrefix(String databasePrefix) {
        this.databasePrefix = databasePrefix;
    }
    public boolean isKeepPreviousIslandOnReset() {
        return keepPreviousIslandOnReset;
    }
    public void setKeepPreviousIslandOnReset(boolean keepPreviousIslandOnReset) {
        this.keepPreviousIslandOnReset = keepPreviousIslandOnReset;
    }
    public String getMongodbConnectionUri() {
        return mongodbConnectionUri;
    }
    public void setMongodbConnectionUri(String mongodbConnectionUri) {
        this.mongodbConnectionUri = mongodbConnectionUri;
    }
    public Material getPanelFillerMaterial() {
        return panelFillerMaterial;
    }
    public void setPanelFillerMaterial(Material panelFillerMaterial) {
        this.panelFillerMaterial = panelFillerMaterial;
    }
    public long getPlayerHeadCacheTime() {
        return playerHeadCacheTime;
    }
    public void setPlayerHeadCacheTime(long playerHeadCacheTime) {
        this.playerHeadCacheTime = playerHeadCacheTime;
    }
    public boolean isUseCacheServer() {
        return useCacheServer;
    }
    public void setUseCacheServer(boolean useCacheServer) {
        this.useCacheServer = useCacheServer;
    }
    public int getHeadsPerCall() {
        return headsPerCall;
    }
    public void setHeadsPerCall(int headsPerCall) {
        this.headsPerCall = headsPerCall;
    }
    public long getTicksBetweenCalls() {
        return ticksBetweenCalls;
    }
    public void setTicksBetweenCalls(long ticksBetweenCalls) {
        this.ticksBetweenCalls = ticksBetweenCalls;
    }
    public int getMinPortalSearchRadius() {
        return minPortalSearchRadius;
    }
    public void setMinPortalSearchRadius(int minPortalSearchRadius) {
        this.minPortalSearchRadius = minPortalSearchRadius;
    }
    public int getSafeSpotSearchVerticalRange() {
        return safeSpotSearchVerticalRange;
    }
    public void setSafeSpotSearchVerticalRange(int safeSpotSearchVerticalRange) {
        this.safeSpotSearchVerticalRange = safeSpotSearchVerticalRange;
    }
    public boolean isSlowDeletion() {
        return slowDeletion;
    }
    public void setSlowDeletion(boolean slowDeletion) {
        this.slowDeletion = slowDeletion;
    }
    public int getMaximumPoolSize() {
        return maximumPoolSize;
    }
    public int getSafeSpotSearchRange() {
        return safeSpotSearchRange;
    }
    public void setMaximumPoolSize(int maximumPoolSize) {
        this.maximumPoolSize = maximumPoolSize;
    }
    public Map<String, String> getCustomPoolProperties() {
        return customPoolProperties;
    }
    public void setCustomPoolProperties(Map<String, String> customPoolProperties) {
        this.customPoolProperties = customPoolProperties;
    }
    public void setSafeSpotSearchRange(int safeSpotSearchRange) {
        this.safeSpotSearchRange = safeSpotSearchRange;
    }
    public List<String> getReadyCommands() {
        return ImmutableList.copyOf(Objects.requireNonNullElse(readyCommands, Collections.emptyList()));
    }
    public void setReadyCommands(List<String> readyCommands) {
        this.readyCommands = readyCommands;
    }
    public int getIslandNumber() {
        return islandNumber;
    }
    public void setIslandNumber(int islandNumber) {
        this.islandNumber = islandNumber;
    }
    public boolean isHideUsedBlueprints() {
        return hideUsedBlueprints;
    }
    public void setHideUsedBlueprints(boolean hideUsedBlueprints) {
        this.hideUsedBlueprints = hideUsedBlueprints;
    }
    public boolean isOverrideSafetyCheck() {
        return overrideSafetyCheck;
    }
    public void setOverrideSafetyCheck(boolean overrideSafetyCheck) {
        this.overrideSafetyCheck = overrideSafetyCheck;
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.sql.sqlite.SQLiteDatabase;
import world.bentobox.bentobox.database.yaml.YamlDatabase;
public class Yaml2SQLiteDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new YamlDatabase().getHandler(type), new SQLiteDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.yaml;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
public class YamlDatabase implements DatabaseSetup {
    private final YamlDatabaseConnector connector = new YamlDatabaseConnector(BentoBox.getInstance());
    public <T> AbstractDatabaseHandler<T> getConfig(Class<T> type) {
        return new ConfigHandler<>(BentoBox.getInstance(), type, connector);
    }
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new YamlDatabaseHandler<>(BentoBox.getInstance(), type, connector);
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.mongodb.MongoDBDatabase;
import world.bentobox.bentobox.database.yaml.YamlDatabase;
public class Yaml2MongoDBDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new YamlDatabase().getHandler(type), new MongoDBDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.sql.sqlite.SQLiteDatabase;
public class SQLite2JsonDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new SQLiteDatabase().getHandler(type), new JSONDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.sql.postgresql.PostgreSQLDatabase;
public class Json2PostgreSQLDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> dataObjectClass) {
        return new TransitionDatabaseHandler<>(dataObjectClass, new JSONDatabase().getHandler(dataObjectClass), new PostgreSQLDatabase().getHandler(dataObjectClass));
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.yaml.YamlDatabase;
public class Yaml2JsonDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new YamlDatabase().getHandler(type), new JSONDatabase().getHandler(type));
    }
}
package world.bentobox.bentobox.database;
import java.beans.IntrospectionException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.logging.Logger;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.Addon;
import world.bentobox.bentobox.database.objects.DataObject;
public class Database<T> {
    private final AbstractDatabaseHandler<T> handler;
    private final Logger logger;
    private static DatabaseSetup databaseSetup = DatabaseSetup.getDatabase();
    private static final Set<Class<? extends DataObject>> dataObjects = new HashSet<>();
    @SuppressWarnings("unchecked")
    public Database(BentoBox plugin, Class<T> type)  {
        this.logger = plugin.getLogger();
        handler = databaseSetup.getHandler(type);
        dataObjects.add((Class<? extends DataObject>) type);
    }
    @SuppressWarnings("unchecked")
    public Database(Addon addon, Class<T> type)  {
        this.logger = addon.getLogger();
        handler = databaseSetup.getHandler(type);
        dataObjects.add((Class<? extends DataObject>) type);
    }
    @NonNull
    public List<T> loadObjects() {
        List<T> result = new ArrayList<>();
        try {
            result = handler.loadObjects();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException
                | InvocationTargetException | ClassNotFoundException | IntrospectionException
                | NoSuchMethodException | SecurityException e) {
            logger.severe(() -> "Could not load objects from database! Error: " + e.getMessage());
        }
        return result;
    }
    @Nullable
    public T loadObject(String uniqueId) {
        T result = null;
        try {
            result = handler.loadObject(uniqueId);
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
                | ClassNotFoundException | IntrospectionException | SecurityException e) {
            logger.severe(() -> "Could not load object from database! " + e.getMessage());
        } catch (NoSuchMethodException e) {
            logger.severe(() -> "Could not load object from database! " + e.getMessage());
            logger.severe(() -> "Did you forget the JavaBean no-arg default constructor?");
        }
        return result;
    }
    public CompletableFuture<Boolean> saveObjectAsync(T instance) {
        try {
            return handler.saveObject(instance);
        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException
                | IntrospectionException e) {
            logger.severe(() -> "Could not save object to database! Error: " + e.getMessage());
            return new CompletableFuture<>();
        }
    }
    public boolean saveObject(T instance) {
        saveObjectAsync(instance).thenAccept(r -> {
            if (Boolean.FALSE.equals(r)) logger.severe(() -> "Could not save object to database!");
        });
        return true;
    }
    public boolean objectExists(String name) {
        return handler.objectExists(name);
    }
    public void deleteID(String uniqueId) {
        handler.deleteID(uniqueId);
    }
    public void deleteObject(T object) {
        try {
            handler.deleteObject(object);
        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException
                | IntrospectionException e) {
            logger.severe(() -> "Could not delete object! Error: " + e.getMessage());
        }
    }
    public void close() {
        handler.close();
    }
    public static Set<Class<? extends DataObject>> getDataobjects() {
        return dataObjects;
    }
    public @NonNull CompletableFuture<List<T>> loadObjectsASync() {
        return handler.loadObjectsASync();
    }
}
package world.bentobox.bentobox.database.transition;
import world.bentobox.bentobox.database.AbstractDatabaseHandler;
import world.bentobox.bentobox.database.DatabaseSetup;
import world.bentobox.bentobox.database.json.JSONDatabase;
import world.bentobox.bentobox.database.sql.mariadb.MariaDBDatabase;
public class Json2MariaDBDatabase implements DatabaseSetup {
    @Override
    public <T> AbstractDatabaseHandler<T> getHandler(Class<T> type) {
        return new TransitionDatabaseHandler<>(type, new JSONDatabase().getHandler(type), new MariaDBDatabase().getHandler(type));
    }
}