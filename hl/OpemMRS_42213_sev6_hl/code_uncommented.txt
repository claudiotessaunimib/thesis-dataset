package org.openmrs.module;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.SortedMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import org.aopalliance.aop.Advice;
import org.openmrs.GlobalProperty;
import org.openmrs.Privilege;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.context.Context;
import org.openmrs.api.context.Daemon;
import org.openmrs.module.Extension.MEDIA_TYPE;
import org.openmrs.util.CycleException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.Graph;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Advisor;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
import org.springframework.util.StringUtils;
import liquibase.Contexts;
public class ModuleFactory {
	private ModuleFactory() {
	}
	private static final Logger log = LoggerFactory.getLogger(ModuleFactory.class);
	protected static final Cache<String, Module> loadedModules = CacheBuilder.newBuilder()
		.softValues().build();
	protected static final Cache<String, Module> startedModules = CacheBuilder.newBuilder()
		.softValues().build();
	protected static final Map<String, List<Extension>> extensionMap = new HashMap<>();
	protected static final Cache<Module, ModuleClassLoader> moduleClassLoaders = CacheBuilder.newBuilder().weakKeys()
		.softValues().build();
	private static final Map<String, Set<ModuleClassLoader>> providedPackages = new ConcurrentHashMap<>();
	private static final String MODULE_CHANGELOG_FILENAME = "liquibase.xml";
	private static final Cache<String, DaemonToken> daemonTokens = CacheBuilder.newBuilder().softValues().build();
	private static final Set<String> actualStartupOrder = new LinkedHashSet<>();
	public static Module loadModule(File moduleFile) throws ModuleException {
		return loadModule(moduleFile, true);
	}
	public static Module loadModule(File moduleFile, Boolean replaceIfExists) throws ModuleException {
		Module module = new ModuleFileParser(Context.getMessageSourceService()).parse(moduleFile);
		if (module != null) {
			loadModule(module, replaceIfExists);
		}
		return module;
	}
	public static Module loadModule(Module module, Boolean replaceIfExists) throws ModuleException {
		log.debug("Adding module {} to the module queue", module.getName());
		Module oldModule = getLoadedModulesMap().get(module.getModuleId());
		if (oldModule != null) {
			int versionComparison = ModuleUtil.compareVersion(oldModule.getVersion(), module.getVersion());
			if (versionComparison < 0) {
				unloadModule(oldModule);
			} else if (versionComparison == 0) {
				if (replaceIfExists) {
					unloadModule(oldModule);
				} else {
					throw new ModuleException("A module with the same id and version already exists", module.getModuleId());
				}
			} else {
				return oldModule;
			}
		}
		getLoadedModulesMap().put(module.getModuleId(), module);
		return module;
	}
	public static void loadModules() {
		File modulesFolder = ModuleUtil.getModuleRepository();
		log.debug("Loading modules from: {}", modulesFolder.getAbsolutePath());
		File[] files = modulesFolder.listFiles();
		if (modulesFolder.isDirectory() && files != null) {
			loadModules(Arrays.asList(files));
		} else {
			log.error("modules folder: '" + modulesFolder.getAbsolutePath() + "' is not a directory or IO error occurred");
		}
	}
	public static void loadModules(List<File> modulesToLoad) {
		for (File f : modulesToLoad) {
			if (f.exists()) {
				if (!f.getName().startsWith(".")) {
					try {
						Module mod = loadModule(f, true);
						log.debug("Loaded module: " + mod + " successfully");
					}
					catch (Exception e) {
						log.error("Unable to load file in module directory: " + f + ". Skipping file.", e);
					}
				}
			} else {
				log.error("Could not find file in module directory: " + f);
			}
		}
		Map<String, Module> loadedModulesMap = getLoadedModulesMapPackage();
		for (Module m : loadedModulesMap.values()) {
			Map<String, String> startBeforeModules = m.getStartBeforeModulesMap();
			if (startBeforeModules.size() > 0) {
				for (String s : startBeforeModules.keySet()) {
					Module mod = loadedModulesMap.get(s);
					if (mod != null) {
						mod.addRequiredModule(m.getPackageName(), m.getVersion());
					}
				}
			}
		}
	}
	public static void startModules() {
		if (!getLoadedModules().isEmpty()) {
			List<Module> modules = getModulesThatShouldStart();
			try {
				modules = getModulesInStartupOrder(modules);
			}
			catch (CycleException ex) {
				String message = getCyclicDependenciesMessage(ex.getMessage());
				log.error(message, ex);
				notifySuperUsersAboutCyclicDependencies(ex);
				modules = (List<Module>) ex.getExtraData();
			}
			for (Module mod : modules) {
				if (mod.isStarted()) {
					continue;
				}
				if (!requiredModulesStarted(mod)) {
					String message = getFailedToStartModuleMessage(mod);
					log.error(message);
					mod.setStartupErrorMessage(message);
					notifySuperUsersAboutModuleFailure(mod);
					continue;
				}
				try {
					log.debug("starting module: {}", mod.getModuleId());
					startModule(mod);
				}
				catch (Exception e) {
					log.error("Error while starting module: " + mod.getName(), e);
					mod.setStartupErrorMessage("Error while starting module", e);
					notifySuperUsersAboutModuleFailure(mod);
				}
			}
		}
	}
	private static List<Module> getModulesThatShouldStart() {
		List<Module> modules = new ArrayList<>();
		AdministrationService adminService = Context.getAdministrationService();
		for (Module mod : getLoadedModulesCoreFirst()) {
			String key = mod.getModuleId() + ".started";
			String startedProp = adminService.getGlobalProperty(key, null);
			String mandatoryProp = adminService.getGlobalProperty(mod.getModuleId() + ".mandatory", null);
			boolean isCoreToOpenmrs = mod.isCore() && !ModuleUtil.ignoreCoreModules();
			if (startedProp == null || "true".equals(startedProp) || "true".equalsIgnoreCase(mandatoryProp)
				|| mod.isMandatory() || isCoreToOpenmrs) {
				modules.add(mod);
			}
		}
		return modules;
	}
	public static List<Module> getModulesInStartupOrder(Collection<Module> modules) throws CycleException {
		Graph<Module> graph = new Graph<>();
		for (Module mod : modules) {
			graph.addNode(mod);
			for (String key : mod.getRequiredModules()) {
				Module module = getModuleByPackage(key);
				Module fromNode = graph.getNode(module);
				if (fromNode == null) {
					fromNode = module;
				}
				if (fromNode != null) {
					graph.addEdge(graph.new Edge(
						fromNode,
						mod));
				}
			}
			for (String key : mod.getAwareOfModules()) {
				Module module = getModuleByPackage(key);
				Module fromNode = graph.getNode(module);
				if (fromNode == null) {
					fromNode = module;
				}
				if (fromNode != null) {
					graph.addEdge(graph.new Edge(
						fromNode,
						mod));
				}
			}
		}
		return graph.topologicalSort();
	}
	private static void notifySuperUsersAboutModuleFailure(Module mod) {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
			Context.getAlertService().notifySuperUsers("Module.startupError.notification.message", null, mod.getName());
		}
		catch (Exception e) {
			log.error("Unable to send an alert to the super users", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
		}
	}
	private static void notifySuperUsersAboutCyclicDependencies(Exception ex) {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
			Context.getAlertService().notifySuperUsers("Module.error.cyclicDependencies", ex, ex.getMessage());
		}
		catch (Exception e) {
			log.error("Unable to send an alert to the super users", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
		}
	}
	public static List<Module> getLoadedModulesCoreFirst() {
		List<Module> list = new ArrayList<>(getLoadedModules());
		final Collection<String> coreModuleIds = ModuleConstants.CORE_MODULES.keySet();
		list.sort((left, right) -> {
			Integer leftVal = coreModuleIds.contains(left.getModuleId()) ? 0 : 1;
			Integer rightVal = coreModuleIds.contains(right.getModuleId()) ? 0 : 1;
			return leftVal.compareTo(rightVal);
		});
		return list;
	}
	private static List<String> getMissingRequiredModules(Module module) {
		List<String> ret = new ArrayList<>();
		for (String moduleName : module.getRequiredModules()) {
			boolean started = false;
			for (Module mod : getStartedModules()) {
				if (mod.getPackageName().equals(moduleName)) {
					String reqVersion = module.getRequiredModuleVersion(moduleName);
					if (reqVersion == null || ModuleUtil.compareVersion(mod.getVersion(), reqVersion) >= 0) {
						started = true;
					}
					break;
				}
			}
			if (!started) {
				String moduleVersion = module.getRequiredModuleVersion(moduleName);
				moduleName = moduleName.replace("org.openmrs.module.", "").replace("org.openmrs.", "");
				ret.add(moduleName + (moduleVersion != null ? " " + moduleVersion : ""));
			}
		}
		return ret;
	}
	public static Collection<Module> getLoadedModules() {
		if (getLoadedModulesMap().size() > 0) {
			return getLoadedModulesMap().values();
		}
		return Collections.emptyList();
	}
	public static Map<String, Module> getLoadedModulesMap() {
		return loadedModules.asMap();
	}
	public static Map<String, Module> getLoadedModulesMapPackage() {
		Map<String, Module> map = new HashMap<>();
		for (Module loadedModule : getLoadedModulesMap().values()) {
			map.put(loadedModule.getPackageName(), loadedModule);
		}
		return map;
	}
	public static Collection<Module> getStartedModules() {
		if (getStartedModulesMap().size() > 0) {
			return getStartedModulesMap().values();
		}
		return Collections.emptyList();
	}
	public static List<Module> getStartedModulesInOrder() {
		List<Module> modules = new ArrayList<>();
		if (actualStartupOrder != null) {
			for (String moduleId : actualStartupOrder) {
				modules.add(getStartedModulesMap().get(moduleId));
			}
		} else {
			modules.addAll(getStartedModules());
		}
		return modules;
	}
	public static Map<String, Module> getStartedModulesMap() {
		return startedModules.asMap();
	}
	public static Module getModuleById(String moduleId) {
		return getLoadedModulesMap().get(moduleId);
	}
	public static Module getStartedModuleById(String moduleId) {
		return getStartedModulesMap().get(moduleId);
	}
	public static Module getModuleByPackage(String modulePackage) {
		for (Module mod : getLoadedModulesMap().values()) {
			if (mod.getPackageName().equals(modulePackage)) {
				return mod;
			}
		}
		return null;
	}
	public static Module startModule(Module module) throws ModuleException {
		return startModule(module, false, null);
	}
	public static Module startModule(Module module, boolean isOpenmrsStartup,
		AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		if (!requiredModulesStarted(module)) {
			int missingModules = 0;
			for (String packageName : module.getRequiredModulesMap().keySet()) {
				Module mod = getModuleByPackage(packageName);
				if (mod == null) {
					missingModules++;
					continue;
				}
				if (!mod.isStarted()) {
					startModule(mod);
				}
			}
			if (missingModules > 0) {
				String message = getFailedToStartModuleMessage(module);
				log.error(message);
				module.setStartupErrorMessage(message);
				notifySuperUsersAboutModuleFailure(module);
				return module;
			}
		}
		return Daemon.startModule(module, isOpenmrsStartup, applicationContext);
	}
	public static Module startModuleInternal(Module module) throws ModuleException {
		return startModuleInternal(module, false, null);
	}
	public static Module startModuleInternal(Module module, boolean isOpenmrsStartup,
		AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		if (module != null) {
			String moduleId = module.getModuleId();
			try {
				String requireVersion = module.getRequireOpenmrsVersion();
				ModuleUtil.checkRequiredVersion(OpenmrsConstants.OPENMRS_VERSION_SHORT, requireVersion);
				if (!requiredModulesStarted(module)) {
					throw new ModuleException(getFailedToStartModuleMessage(module));
				}
				ModuleClassLoader moduleClassLoader = new ModuleClassLoader(module, ModuleFactory.class.getClassLoader());
				getModuleClassLoaderMap().put(module, moduleClassLoader);
				registerProvidedPackages(moduleClassLoader);
				Map<String, List<Extension>> moduleExtensionMap = new HashMap<>();
				for (Extension ext : module.getExtensions()) {
					String extId = ext.getExtensionId();
					List<Extension> tmpExtensions = moduleExtensionMap.computeIfAbsent(extId, k -> new ArrayList<>());
					tmpExtensions.add(ext);
				}
				Comparator<Extension> sortOrder = (e1, e2) -> Integer.valueOf(e1.getOrder()).compareTo(e2.getOrder());
				for (Map.Entry<String, List<Extension>> moduleExtensionEntry : moduleExtensionMap.entrySet()) {
					List<Extension> sortedModuleExtensions = moduleExtensionEntry.getValue();
					sortedModuleExtensions.sort(sortOrder);
					List<Extension> extensions = getExtensionMap().computeIfAbsent(moduleExtensionEntry.getKey(),
						k -> new ArrayList<>());
					for (Extension ext : sortedModuleExtensions) {
						log.debug("Adding to mapping ext: " + ext.getExtensionId() + " ext.class: " + ext.getClass());
						extensions.add(ext);
					}
				}
				SortedMap<String, String> diffs = SqlDiffFileParser.getSqlDiffs(module);
				try {
					Context.addProxyPrivilege("");
					for (Map.Entry<String, String> entry : diffs.entrySet()) {
						String version = entry.getKey();
						String sql = entry.getValue();
						if (StringUtils.hasText(sql)) {
							runDiff(module, version, sql);
						}
					}
				}
				finally {
					Context.removeProxyPrivilege("");
				}
				runLiquibase(module);
				getStartedModulesMap().put(moduleId, module);
				actualStartupOrder.add(moduleId);
				try {
					saveGlobalProperty(moduleId + ".started", "true", getGlobalPropertyStartedDescription(moduleId));
					saveGlobalProperty(moduleId + ".mandatory", String.valueOf(module.isMandatory()),
						getGlobalPropertyMandatoryModuleDescription(moduleId));
				}
				catch (Exception e) {
					log.debug("Got an error when trying to set the global property on module startup", e);
				}
				if (!module.getPrivileges().isEmpty() || !module.getGlobalProperties().isEmpty()) {
					log.debug("Updating core dataset");
					Context.checkCoreDataset();
				}
				try {
					if (module.getModuleActivator() != null) {
						module.getModuleActivator().willStart();
					}
				}
				catch (ModuleException e) {
					throw e;
				}
				catch (Exception e) {
					throw new ModuleException("Error while calling module's Activator.startup()/willStart() method", e);
				}
				module.clearStartupError();
			}
			catch (Exception e) {
				log.warn("Error while trying to start module: " + moduleId, e);
				module.setStartupErrorMessage("Error while trying to start module", e);
				notifySuperUsersAboutModuleFailure(module);
				try {
					boolean skipOverStartedProperty = false;
					if (e instanceof ModuleMustStartException) {
						skipOverStartedProperty = true;
					}
					stopModule(module, skipOverStartedProperty, true);
				}
				catch (Exception e2) {
					log.debug("Error while stopping module: " + moduleId, e2);
				}
			}
		}
		if (applicationContext != null) {
			ModuleUtil.refreshApplicationContext(applicationContext, isOpenmrsStartup, module);
		}
		return module;
	}
	private static void registerProvidedPackages(ModuleClassLoader moduleClassLoader) {
		for (String providedPackage : moduleClassLoader.getProvidedPackages()) {
			Set<ModuleClassLoader> newSet = new HashSet<>();
			Set<ModuleClassLoader> set = providedPackages.get(providedPackage);
			if (set != null) {
				newSet.addAll(set);
			}
			newSet.add(moduleClassLoader);
			providedPackages.put(providedPackage, newSet);
		}
	}
	private static void unregisterProvidedPackages(ModuleClassLoader moduleClassLoader) {
		for (String providedPackage : moduleClassLoader.getProvidedPackages()) {
			Set<ModuleClassLoader> newSet = new HashSet<>();
			Set<ModuleClassLoader> set = providedPackages.get(providedPackage);
			if (set != null) {
				newSet.addAll(set);
			}
			newSet.remove(moduleClassLoader);
			providedPackages.put(providedPackage, newSet);
		}
	}
	public static Set<ModuleClassLoader> getModuleClassLoadersForPackage(String packageName) {
		Set<ModuleClassLoader> set = providedPackages.get(packageName);
		if (set == null) {
			return Collections.emptySet();
		} else {
			return new HashSet<>(set);
		}
	}
	private static String getFailedToStartModuleMessage(Module module) {
		String[] params = { module.getName(), String.join(",", getMissingRequiredModules(module)) };
		return Context.getMessageSourceService().getMessage("Module.error.moduleCannotBeStarted", params,
			Context.getLocale());
	}
	private static String getCyclicDependenciesMessage(String message) {
		return Context.getMessageSourceService().getMessage("Module.error.cyclicDependencies", new Object[] { message },
			Context.getLocale());
	}
	public static void loadAdvice(Module module) {
		for (AdvicePoint advice : module.getAdvicePoints()) {
			Class<?> cls;
			try {
				cls = Context.loadClass(advice.getPoint());
				Object aopObject = advice.getClassInstance();
				if (aopObject instanceof Advisor) {
					log.debug("adding advisor [{}]", aopObject.getClass());
					Context.addAdvisor(cls, (Advisor) aopObject);
				} else if (aopObject != null) {
					log.debug("adding advice [{}]", aopObject.getClass());
					Context.addAdvice(cls, (Advice) aopObject);
				} else {
					log.debug("Could not load advice class for {} [{}]", advice.getPoint(), advice.getClassName());
				}
			}
			catch (ClassNotFoundException | NoClassDefFoundError e) {
				log.warn("Could not load advice point [{}]", advice.getPoint(), e);
			}
		}
	}
	private static void runDiff(Module module, String version, String sql) {
		AdministrationService as = Context.getAdministrationService();
		String key = module.getModuleId() + ".database_version";
		GlobalProperty gp = as.getGlobalPropertyObject(key);
		boolean executeSQL = false;
		if (gp != null && StringUtils.hasLength(gp.getPropertyValue())) {
			String currentDbVersion = gp.getPropertyValue();
			if (log.isDebugEnabled()) {
				log.debug("version:column {}:{}", version, currentDbVersion);
				log.debug("compare: {}", ModuleUtil.compareVersion(version, currentDbVersion));
			}
			if (ModuleUtil.compareVersion(version, currentDbVersion) > 0) {
				executeSQL = true;
			}
		} else {
			executeSQL = true;
		}
		if (executeSQL) {
			try {
				Context.addProxyPrivilege(PrivilegeConstants.SQL_LEVEL_ACCESS);
				log.debug("Executing sql: " + sql);
				String[] sqlStatements = sql.split(";");
				for (String sqlStatement : sqlStatements) {
					if (sqlStatement.trim().length() > 0) {
						as.executeSQL(sqlStatement, false);
					}
				}
			}
			finally {
				Context.removeProxyPrivilege(PrivilegeConstants.SQL_LEVEL_ACCESS);
			}
			try {
				Context.addProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
				String description = "DO NOT MODIFY.  Current database version number for the " + module.getModuleId()
					+ " module.";
				if (gp == null) {
					log.info("Global property " + key + " was not found. Creating one now.");
					gp = new GlobalProperty(key, version, description);
					as.saveGlobalProperty(gp);
				} else if (!gp.getPropertyValue().equals(version)) {
					log.info("Updating global property " + key + " to version: " + version);
					gp.setDescription(description);
					gp.setPropertyValue(version);
					as.saveGlobalProperty(gp);
				} else {
					log.error("Should not be here. GP property value and sqldiff version should not be equal");
				}
			}
			finally {
				Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			}
		}
	}
	private static void runLiquibase(Module module) {
		ModuleClassLoader moduleClassLoader = getModuleClassLoader(module);
		boolean liquibaseFileExists = false;
		if (moduleClassLoader != null) {
			try (InputStream inStream = moduleClassLoader.getResourceAsStream(MODULE_CHANGELOG_FILENAME)) {
				liquibaseFileExists = (inStream != null);
			}
			catch (IOException ignored) {
			}
		}
		if (liquibaseFileExists) {
			try {
				DatabaseUpdater.executeChangelog(MODULE_CHANGELOG_FILENAME, new Contexts(), null, moduleClassLoader);
			}
			catch (InputRequiredException e) {
				throw new ModuleException("Input during database updates is not yet implemented.", module.getName(), e);
			}
			catch (Exception e) {
				throw new ModuleException("Unable to update data model using " + MODULE_CHANGELOG_FILENAME + ".",
					module.getName(), e);
			}
		}
	}
	public static void stopModule(Module mod) {
		stopModule(mod, false, false);
	}
	public static void stopModule(Module mod, boolean isShuttingDown) {
		stopModule(mod, isShuttingDown, false);
	}
	public static List<Module> stopModule(Module mod, boolean skipOverStartedProperty, boolean isFailedStartup)
		throws ModuleMustStartException {
		List<Module> dependentModulesStopped = new ArrayList<>();
		if (mod != null) {
			if (!ModuleFactory.isModuleStarted(mod)) {
				return dependentModulesStopped;
			}
			try {
				if (mod.getModuleActivator() != null) {
					mod.getModuleActivator().willStop();
				}
			}
			catch (Exception t) {
				log.warn("Unable to call module's Activator.willStop() method", t);
			}
			String moduleId = mod.getModuleId();
			if (!isFailedStartup && mod.isMandatory()) {
				throw new MandatoryModuleException(moduleId);
			}
			if (!isFailedStartup && ModuleConstants.CORE_MODULES.containsKey(moduleId)) {
				throw new OpenmrsCoreModuleException(moduleId);
			}
			String modulePackage = mod.getPackageName();
			List<Module> startedModulesCopy = new ArrayList<>(getStartedModules());
			for (Module dependentModule : startedModulesCopy) {
				if (dependentModule != null && !dependentModule.equals(mod)
					&& isModuleRequiredByAnother(dependentModule, modulePackage)) {
					dependentModulesStopped.add(dependentModule);
					dependentModulesStopped.addAll(stopModule(dependentModule, skipOverStartedProperty, isFailedStartup));
				}
			}
			getStartedModulesMap().remove(moduleId);
			if (actualStartupOrder != null) {
				actualStartupOrder.remove(moduleId);
				for (Module depModule : dependentModulesStopped) {
					actualStartupOrder.remove(depModule.getModuleId());
				}
			}
			if (!skipOverStartedProperty && !Context.isRefreshingContext()) {
				saveGlobalProperty(moduleId + ".started", "false", getGlobalPropertyStartedDescription(moduleId));
			}
			ModuleClassLoader moduleClassLoader = getModuleClassLoaderMap().get(mod);
			if (moduleClassLoader != null) {
				unregisterProvidedPackages(moduleClassLoader);
				log.debug("Mod was in classloader map.  Removing advice and extensions.");
				try {
					for (AdvicePoint advice : mod.getAdvicePoints()) {
						Class cls;
						try {
							cls = Context.loadClass(advice.getPoint());
							Object aopObject = advice.getClassInstance();
							if (aopObject instanceof Advisor) {
								log.debug("adding advisor: " + aopObject.getClass());
								Context.removeAdvisor(cls, (Advisor) aopObject);
							} else {
								log.debug("Adding advice: " + aopObject.getClass());
								Context.removeAdvice(cls, (Advice) aopObject);
							}
						}
						catch (Exception t) {
							log.warn("Could not remove advice point: " + advice.getPoint(), t);
						}
					}
				}
				catch (Exception t) {
					log.warn("Error while getting advicePoints from module: " + moduleId, t);
				}
				try {
					for (Extension ext : mod.getExtensions()) {
						String extId = ext.getExtensionId();
						try {
							List<Extension> tmpExtensions = getExtensions(extId);
							tmpExtensions.remove(ext);
							getExtensionMap().put(extId, tmpExtensions);
						}
						catch (Exception exterror) {
							log.warn("Error while getting extension: " + ext, exterror);
						}
					}
				}
				catch (Exception t) {
					log.warn("Error while getting extensions from module: " + moduleId, t);
				}
			}
			List<OpenmrsService> services = Context.getModuleOpenmrsServices(modulePackage);
			if (services != null) {
				for (OpenmrsService service : services) {
					service.onShutdown();
				}
			}
			try {
				if (mod.getModuleActivator() != null) {
					mod.getModuleActivator().stopped();
				}
			}
			catch (Exception t) {
				log.warn("Unable to call module's Activator.shutdown() method", t);
			}
			mod.getExtensions().clear();
			mod.setModuleActivator(null);
			mod.disposeAdvicePointsClassInstance();
			ModuleClassLoader cl = removeClassLoader(mod);
			if (cl != null) {
				cl.dispose();
				File folder = OpenmrsClassLoader.getLibCacheFolder();
				File tmpModuleDir = new File(folder, moduleId);
				try {
					OpenmrsUtil.deleteDirectory(tmpModuleDir);
				}
				catch (IOException e) {
					log.warn("Unable to delete libcachefolder for " + moduleId);
				}
			}
		}
		return dependentModulesStopped;
	}
	private static boolean isModuleRequiredByAnother(Module dependentModule, String modulePackage) {
		return dependentModule.getRequiredModules() != null && dependentModule.getRequiredModules().contains(modulePackage);
	}
	private static ModuleClassLoader removeClassLoader(Module mod) {
		ModuleClassLoader cl = moduleClassLoaders.getIfPresent(mod);
		if (cl == null) {
			log.warn("Module: " + mod.getModuleId() + " does not exist");
		}
		moduleClassLoaders.invalidate(mod);
		return cl;
	}
	public static void unloadModule(Module mod) {
		if (isModuleStarted(mod)) {
			stopModule(mod, true);
		}
		getLoadedModules().remove(mod);
		if (mod != null) {
			File file = mod.getFile();
			boolean deleted = file.delete();
			if (!deleted) {
				file.deleteOnExit();
				log.warn("Could not delete " + file.getAbsolutePath());
			}
		}
	}
	public static List<Extension> getExtensions(String pointId) {
		List<Extension> extensions;
		Map<String, List<Extension>> extensionMap = getExtensionMap();
		extensions = extensionMap.get(pointId);
		if (extensions == null) {
			extensions = new ArrayList<>();
		}
		if (!pointId.contains(Extension.EXTENSION_ID_SEPARATOR)) {
			for (MEDIA_TYPE mediaType : Extension.MEDIA_TYPE.values()) {
				List<Extension> tmpExtensions = extensionMap.get(Extension.toExtensionId(pointId, mediaType));
				if (tmpExtensions != null) {
					for (Extension ext : tmpExtensions) {
						if (!extensions.contains(ext)) {
							extensions.add(ext);
						}
					}
				}
			}
		}
		log.debug("Getting extensions defined by : " + pointId);
		return extensions;
	}
	public static List<Extension> getExtensions(String pointId, Extension.MEDIA_TYPE type) {
		String key = Extension.toExtensionId(pointId, type);
		List<Extension> extensions = getExtensionMap().get(key);
		if (extensions != null) {
			log.debug("Getting extensions defined by : " + key);
			return extensions;
		} else {
			return getExtensions(pointId);
		}
	}
	public static List<Privilege> getPrivileges() {
		List<Privilege> privileges = new ArrayList<>();
		for (Module mod : getStartedModules()) {
			privileges.addAll(mod.getPrivileges());
		}
		log.debug(privileges.size() + " new privileges");
		return privileges;
	}
	public static List<GlobalProperty> getGlobalProperties() {
		List<GlobalProperty> globalProperties = new ArrayList<>();
		for (Module mod : getStartedModules()) {
			globalProperties.addAll(mod.getGlobalProperties());
		}
		log.debug(globalProperties.size() + " new global properties");
		return globalProperties;
	}
	public static boolean isModuleStarted(Module mod) {
		return getStartedModulesMap().containsValue(mod);
	}
	public static boolean isModuleStarted(String moduleId) {
		return getStartedModulesMap().containsKey(moduleId);
	}
	public static ModuleClassLoader getModuleClassLoader(Module mod) throws ModuleException {
		ModuleClassLoader mcl = getModuleClassLoaderMap().get(mod);
		if (mcl == null) {
			log.debug("Module classloader not found for module with id: " + mod.getModuleId());
		}
		return mcl;
	}
	public static ModuleClassLoader getModuleClassLoader(String moduleId) throws ModuleException {
		Module mod = getStartedModulesMap().get(moduleId);
		if (mod == null) {
			log.debug("Module id not found in list of started modules: " + moduleId);
		}
		return getModuleClassLoader(mod);
	}
	public static Collection<ModuleClassLoader> getModuleClassLoaders() {
		Map<Module, ModuleClassLoader> classLoaders = getModuleClassLoaderMap();
		if (classLoaders.size() > 0) {
			return classLoaders.values();
		}
		return Collections.emptyList();
	}
	public static Map<Module, ModuleClassLoader> getModuleClassLoaderMap() {
		if (moduleClassLoaders == null) {
			return Collections.emptyMap();
		}
		return moduleClassLoaders.asMap();
	}
	public static Map<String, List<Extension>> getExtensionMap() {
		return extensionMap;
	}
	private static boolean requiredModulesStarted(Module module) {
		for (String reqModPackage : module.getRequiredModules()) {
			boolean started = false;
			for (Module mod : getStartedModules()) {
				if (mod.getPackageName().equals(reqModPackage)) {
					String reqVersion = module.getRequiredModuleVersion(reqModPackage);
					if (reqVersion == null || ModuleUtil.compareVersion(mod.getVersion(), reqVersion) >= 0) {
						started = true;
					}
					break;
				}
			}
			if (!started) {
				return false;
			}
		}
		return true;
	}
	public static Module updateModule(Module mod) throws ModuleException {
		if (mod.getDownloadURL() == null) {
			return mod;
		}
		URL url;
		try {
			url = new URL(mod.getDownloadURL());
		}
		catch (MalformedURLException e) {
			throw new ModuleException("Unable to download module update", e);
		}
		unloadModule(mod);
		InputStream inputStream = ModuleUtil.getURLStream(url);
		log.warn("url pathname: " + url.getPath());
		String filename = url.getPath().substring(url.getPath().lastIndexOf("/"));
		File moduleFile = ModuleUtil.insertModuleFile(inputStream, filename);
		try {
			Module newModule = loadModule(moduleFile);
			startModule(newModule);
			return newModule;
		}
		catch (Exception e) {
			log.warn("Error while unloading old module and loading in new module");
			moduleFile.delete();
			return mod;
		}
	}
	public static boolean isTokenValid(DaemonToken token) {
		if (token == null) {
			return false;
		} else {
			synchronized (daemonTokens) {
				DaemonToken validToken = daemonTokens.getIfPresent(token.getId());
				return validToken != null && validToken == token;
			}
		}
	}
	static void passDaemonToken(Module module) {
		ModuleActivator moduleActivator = module.getModuleActivator();
		if (moduleActivator instanceof DaemonTokenAware) {
			DaemonToken daemonToken = getDaemonToken(module);
			((DaemonTokenAware) module.getModuleActivator()).setDaemonToken(daemonToken);
		}
	}
	private static DaemonToken getDaemonToken(Module module) {
		DaemonToken token;
		try {
			token = daemonTokens.get(module.getModuleId(), () -> new DaemonToken(module.getModuleId()));
		}
		catch (ExecutionException e) {
			throw new APIException(e);
		}
		return token;
	}
	private static String getGlobalPropertyStartedDescription(String moduleId) {
		String ret = "DO NOT MODIFY. true/false whether or not the " + moduleId;
		ret += " module has been started.  This is used to make sure modules that were running ";
		ret += " prior to a restart are started again";
		return ret;
	}
	private static String getGlobalPropertyMandatoryModuleDescription(String moduleId) {
		String ret = "true/false whether or not the " + moduleId;
		ret += " module MUST start when openmrs starts.  This is used to make sure that mission critical";
		ret += " modules are always running if openmrs is running.";
		return ret;
	}
	private static void saveGlobalProperty(String key, String value, String desc) {
		try {
			AdministrationService as = Context.getAdministrationService();
			GlobalProperty gp = as.getGlobalPropertyObject(key);
			if (gp == null) {
				gp = new GlobalProperty(key, value, desc);
			} else {
				gp.setPropertyValue(value);
			}
			as.saveGlobalProperty(gp);
		}
		catch (Exception e) {
			log.warn("Unable to save the global property", e);
		}
	}
	public static List<String> getDependencies(String moduleId) {
		List<String> dependentModules = null;
		Module module = getModuleById(moduleId);
		Map<String, Module> startedModules = getStartedModulesMap();
		String modulePackage = module.getPackageName();
		for (Entry<String, Module> entry : startedModules.entrySet()) {
			if (!moduleId.equals(entry.getKey()) && entry.getValue().getRequiredModules().contains(modulePackage)) {
				if (dependentModules == null) {
					dependentModules = new ArrayList<>();
				}
				dependentModules.add(entry.getKey() + " " + entry.getValue().getVersion());
			}
		}
		return dependentModules;
	}
}
package org.openmrs.module;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.openmrs.GlobalProperty;
import org.openmrs.Privilege;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
public final class Module {
	private static final Logger log = LoggerFactory.getLogger(Module.class);
	private String name;
	private String moduleId;
	private String packageName;
	private String description;
	private String author;
	private String version;
	private String updateURL; 
	private String updateVersion = null; 
	private String downloadURL = null; 
	private ModuleActivator moduleActivator;
	private String activatorName;
	private String requireOpenmrsVersion;
	private String requireDatabaseVersion;
	private Map<String, String> requiredModulesMap;
	private Map<String, String> awareOfModulesMap;
	private Map<String, String> startBeforeModulesMap;
	private List<AdvicePoint> advicePoints = new ArrayList<>();
	private Map<String, String> extensionNames = new IdentityHashMap<>();
	private List<Extension> extensions = new ArrayList<>();
	private Map<String, Properties> messages = new HashMap<>();
	private List<Privilege> privileges = new ArrayList<>();
	private List<GlobalProperty> globalProperties = new ArrayList<>();
	private List<String> mappingFiles = new ArrayList<>();
	private Set<String> packagesWithMappedClasses = new HashSet<>();
	private String configVersion;
	private Document config = null;
	private Document sqldiff = null;
	private boolean mandatory = Boolean.FALSE;
	private List<ModuleConditionalResource> conditionalResources = new ArrayList<>();
	private File file = null;
	private String startupErrorMessage = null;
	public Module(String name) {
		this.name = name;
	}
	public Module(String name, String moduleId, String packageName, String author, String description, String version,
				  String configVersion) {
		this.name = name;
		this.moduleId = moduleId;
		this.packageName = packageName;
		this.author = author;
		this.description = description;
		this.version = version;
		this.configVersion = configVersion;
		log.debug("Creating module " + name);
	}
	@Override
	public boolean equals(Object obj) {
		if (obj != null && obj instanceof Module) {
			Module mod = (Module) obj;
			return getModuleId().equals(mod.getModuleId());
		}
		return false;
	}
	@Override
	public int hashCode() {
		return new HashCodeBuilder().append(getModuleId()).toHashCode();
	}
	public ModuleActivator getModuleActivator() {
		try {
			if (moduleActivator == null) {
				ModuleClassLoader classLoader = ModuleFactory.getModuleClassLoader(this);
				if (classLoader == null) {
					throw new ModuleException("The classloader is null", getModuleId());
				}
				Class<?> c = classLoader.loadClass(getActivatorName());
				Object o = c.newInstance();
				if (ModuleActivator.class.isAssignableFrom(o.getClass())) {
					setModuleActivator((ModuleActivator) o);
				}
			}
		}
		catch (ClassNotFoundException | NoClassDefFoundError e) {
			throw new ModuleException("Unable to load/find moduleActivator: '" + getActivatorName() + "'", name, e);
		}
		catch (IllegalAccessException e) {
			throw new ModuleException("Unable to load/access moduleActivator: '" + getActivatorName() + "'", name, e);
		}
		catch (InstantiationException e) {
			throw new ModuleException("Unable to load/instantiate moduleActivator: '" + getActivatorName() + "'", name, e);
		}
		return moduleActivator;
	}
	public void setModuleActivator(ModuleActivator moduleActivator) {
		this.moduleActivator = moduleActivator;
	}
	public String getActivatorName() {
		return activatorName;
	}
	public void setActivatorName(String activatorName) {
		this.activatorName = activatorName;
	}
	public String getAuthor() {
		return author;
	}
	public void setAuthor(String author) {
		this.author = author;
	}
	public String getDescription() {
		return description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getRequireDatabaseVersion() {
		return requireDatabaseVersion;
	}
	public void setRequireDatabaseVersion(String requireDatabaseVersion) {
		this.requireDatabaseVersion = requireDatabaseVersion;
	}
	public List<String> getRequiredModules() {
		return requiredModulesMap == null ? null : new ArrayList<>(requiredModulesMap.keySet());
	}
	public String getRequiredModuleVersion(String moduleName) {
		return requiredModulesMap == null ? null : requiredModulesMap.get(moduleName);
	}
	public void setRequiredModules(List<String> requiredModules) {
		if (requiredModulesMap == null) {
			requiredModulesMap = new HashMap<>();
		}
		for (String module : requiredModules) {
			requiredModulesMap.put(module, null);
		}
	}
	public void addRequiredModule(String requiredModule, String version) {
		if (requiredModulesMap != null) {
			requiredModulesMap.put(requiredModule, version);
		}
	}
	public void setRequiredModulesMap(Map<String, String> requiredModulesMap) {
		this.requiredModulesMap = requiredModulesMap;
	}
	public Map<String, String> getRequiredModulesMap() {
		return requiredModulesMap;
	}
	public void setStartBeforeModulesMap(Map<String, String> startBeforeModulesMap) {
		this.startBeforeModulesMap = startBeforeModulesMap;
	}
	public Map<String, String> getStartBeforeModulesMap() {
		return this.startBeforeModulesMap;
	}
	public List<String> getStartBeforeModules() {
		return this.startBeforeModulesMap == null ? null : new ArrayList<>(this.startBeforeModulesMap.keySet());
	}
	public void setAwareOfModulesMap(Map<String, String> awareOfModulesMap) {
		this.awareOfModulesMap = awareOfModulesMap;
	}
	public List<String> getAwareOfModules() {
		return awareOfModulesMap == null ? null : new ArrayList<>(awareOfModulesMap.keySet());
	}
	public String getAwareOfModuleVersion(String awareOfModule) {
		return awareOfModulesMap == null ? null : awareOfModulesMap.get(awareOfModule);
	}
	public String getRequireOpenmrsVersion() {
		return requireOpenmrsVersion;
	}
	public void setRequireOpenmrsVersion(String requireOpenmrsVersion) {
		this.requireOpenmrsVersion = requireOpenmrsVersion;
	}
	public String getModuleId() {
		return moduleId;
	}
	public String getModuleIdAsPath() {
		return moduleId == null ? null : moduleId.replace('.', '/');
	}
	public void setModuleId(String moduleId) {
		this.moduleId = moduleId;
	}
	public String getPackageName() {
		return packageName;
	}
	public void setPackageName(String packageName) {
		this.packageName = packageName;
	}
	public String getVersion() {
		return version;
	}
	public void setVersion(String version) {
		this.version = version;
	}
	public String getUpdateURL() {
		return updateURL;
	}
	public void setUpdateURL(String updateURL) {
		this.updateURL = updateURL;
	}
	public String getDownloadURL() {
		return downloadURL;
	}
	public void setDownloadURL(String downloadURL) {
		this.downloadURL = downloadURL;
	}
	public String getUpdateVersion() {
		return updateVersion;
	}
	public void setUpdateVersion(String updateVersion) {
		this.updateVersion = updateVersion;
	}
	public List<Extension> getExtensions() {
		if (isNoNeedToExpand()) {
			return extensions;
		}
		return expandExtensionNames();
	}
	public void setExtensions(List<Extension> extensions) {
		this.extensions = extensions;
	}
	public void setExtensionNames(Map<String, String> map) {
		if (log.isDebugEnabled()) {
			for (Map.Entry<String, String> entry : extensionNames.entrySet()) {
				log.debug("Setting extension names: {} : {}", entry.getKey(), entry.getValue());
			}
		}
		this.extensionNames = map;
	}
	private boolean isNoNeedToExpand() {
		if (extensionNames == null || extensionNames.isEmpty()) {
			return true;
		}
		for (Extension ext : extensions) {
			if (!extensionNames.get(ext.getPointId()).equals(ext.getClass().getName())) {
				return false;
			}
		}
		return extensions.size() == extensionNames.size();
	}
	private List<Extension> expandExtensionNames() {
		ModuleClassLoader moduleClsLoader = ModuleFactory.getModuleClassLoader(this);
		if (moduleClsLoader == null) {
			log.debug("Module class loader is not available, maybe the module {} is stopped/stopping", getName());
			return extensions;
		}
		extensions.clear();
		for (Map.Entry<String, String> entry : extensionNames.entrySet()) {
			String point = entry.getKey();
			String className = entry.getValue();
			log.debug(getModuleId() + ": Expanding extension name (point|class): {}|{}", point, className);
			try {
				Class<?> cls = moduleClsLoader.loadClass(className);
				Extension ext = (Extension) cls.newInstance();
				ext.setPointId(point);
				ext.setModuleId(this.getModuleId());
				extensions.add(ext);
				log.debug(getModuleId() + ": Added extension: {}|{}", ext.getExtensionId(), ext.getClass());
			}
			catch (ClassNotFoundException | InstantiationException | IllegalAccessException | NoClassDefFoundError e) {
				log.warn(getModuleId() + ": Unable to create instance of class defined for extension point: " + point, e);
			}
		}
		return extensions;
	}
	public List<AdvicePoint> getAdvicePoints() {
		return advicePoints;
	}
	public void setAdvicePoints(List<AdvicePoint> advicePoints) {
		this.advicePoints = advicePoints;
	}
	public File getFile() {
		return file;
	}
	public void setFile(File file) {
		this.file = file;
	}
	@Deprecated
	public Map<String, Properties> getMessages() {
		return messages;
	}
	@Deprecated
	public void setMessages(Map<String, Properties> messages) {
		this.messages = messages;
	}
	public List<GlobalProperty> getGlobalProperties() {
		return globalProperties;
	}
	public void setGlobalProperties(List<GlobalProperty> globalProperties) {
		this.globalProperties = globalProperties;
	}
	public List<Privilege> getPrivileges() {
		return privileges;
	}
	public void setPrivileges(List<Privilege> privileges) {
		this.privileges = privileges;
	}
	public Document getConfig() {
		return config;
	}
	public void setConfig(Document config) {
		this.config = config;
	}
	public String getConfigVersion() {
		return configVersion;
	}
	public void setConfigVersion(String configVersion) {
		this.configVersion = configVersion;
	}
	public Document getSqldiff() {
		return sqldiff;
	}
	public void setSqldiff(Document sqldiff) {
		this.sqldiff = sqldiff;
	}
	public List<String> getMappingFiles() {
		return mappingFiles;
	}
	public void setMappingFiles(List<String> mappingFiles) {
		this.mappingFiles = mappingFiles;
	}
	public Set<String> getPackagesWithMappedClasses() {
		return packagesWithMappedClasses;
	}
	public void setPackagesWithMappedClasses(Set<String> packagesToScan) {
		this.packagesWithMappedClasses = packagesToScan;
	}
	public boolean isMandatory() {
		return mandatory;
	}
	public void setMandatory(boolean mandatory) {
		this.mandatory = mandatory;
	}
	public boolean isCoreModule() {
		return !ModuleUtil.ignoreCoreModules() && ModuleConstants.CORE_MODULES.containsKey(moduleId);
	}
	public boolean isStarted() {
		return ModuleFactory.isModuleStarted(this);
	}
	public void setStartupErrorMessage(String e) {
		if (e == null) {
			throw new ModuleException("Startup error message cannot be null", this.getModuleId());
		}
		this.startupErrorMessage = e;
	}
	public void setStartupErrorMessage(String exceptionMessage, Throwable t) {
		if (t == null) {
			throw new ModuleException("Startup error value cannot be null", this.getModuleId());
		}
		StringBuilder sb = new StringBuilder();
		if (exceptionMessage != null) {
			sb.append(exceptionMessage);
			sb.append("\n");
		}
		sb.append(t.getMessage());
		sb.append("\n");
		this.startupErrorMessage = sb.toString();
	}
	public String getStartupErrorMessage() {
		return startupErrorMessage;
	}
	public Boolean hasStartupError() {
		return (this.startupErrorMessage != null);
	}
	public void clearStartupError() {
		this.startupErrorMessage = null;
	}
	@Override
	public String toString() {
		if (moduleId == null) {
			return super.toString();
		}
		return moduleId;
	}
	public void disposeAdvicePointsClassInstance() {
		if (advicePoints == null) {
			return;
		}
		for (AdvicePoint advicePoint : advicePoints) {
			advicePoint.disposeClassInstance();
		}
	}
	public List<ModuleConditionalResource> getConditionalResources() {
		return conditionalResources;
	}
	public void setConditionalResources(List<ModuleConditionalResource> conditionalResources) {
		this.conditionalResources = conditionalResources;
	}
	public boolean isCore() {
		return ModuleConstants.CORE_MODULES.containsKey(getModuleId());
	}
}
package org.openmrs.module.web.filter;
import java.io.Serializable;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
public class ModuleFilterMapping implements Serializable {
	public static final long serialVersionUID = 1;
	private static final Logger log = LoggerFactory.getLogger(ModuleFilterMapping.class);
	private static final Deque<ModuleFilterMapping> EMPTY_DEQUE = new ArrayDeque<>(0);
	private Module module;
	private String filterName;
	private List<String> servletNames = new ArrayList<>();
	private List<String> urlPatterns = new ArrayList<>();
	public ModuleFilterMapping(Module module) {
		this.module = module;
	}
	public Module getModule() {
		return module;
	}
	public void setModule(Module module) {
		this.module = module;
	}
	public String getFilterName() {
		return filterName;
	}
	public void setFilterName(String filterName) {
		this.filterName = filterName;
	}
	public List<String> getServletNames() {
		return servletNames;
	}
	public void setServletNames(List<String> servletNames) {
		this.servletNames = servletNames;
	}
	public void addServletName(String servletName) {
		this.servletNames.add(servletName);
	}
	public List<String> getUrlPatterns() {
		return urlPatterns;
	}
	public void setUrlPatterns(List<String> urlPatterns) {
		this.urlPatterns = urlPatterns;
	}
	public void addUrlPattern(String urlPattern) {
		this.urlPatterns.add(urlPattern);
	}
	public static boolean filterMappingPasses(ModuleFilterMapping filterMapping, String requestPath) {
		if (requestPath == null) {
			return false;
		}
		for (String patternToCheck : filterMapping.getUrlPatterns()) {
			if (urlPatternMatches(patternToCheck, requestPath)) {
				return true;
			}
		}
		for (String patternToCheck : filterMapping.getServletNames()) {
			if (servletNameMatches(patternToCheck, requestPath)) {
				return true;
			}
		}
		return false;
	}
	public static boolean urlPatternMatches(String patternToCheck, String requestPath) {
		if (patternToCheck == null) {
			return false;
		}
		log.debug("Checking URL <" + requestPath + "> against pattern <" + patternToCheck + ">");
		if ("*".equals(patternToCheck) || "
	public static boolean servletNameMatches(String patternToCheck, String servletName) {
		if (servletName == null) {
			return false;
		}
		log.debug("Checking servlet <" + servletName + "> against pattern <" + patternToCheck + ">");
		return ("*").equals(patternToCheck) || servletName.equals(patternToCheck);
	}
	public static Deque<ModuleFilterMapping> retrieveFilterMappings(Module module){
		Deque<ModuleFilterMapping> mappings;
		try {
			Element rootNode = module.getConfig().getDocumentElement();
			NodeList mappingNodes = rootNode.getElementsByTagName("filter-mapping");
			if (mappingNodes.getLength() > 0) {
				mappings = new ArrayDeque<>(mappingNodes.getLength());
				for (int i = 0; i < mappingNodes.getLength(); i++) {
					ModuleFilterMapping mapping = new ModuleFilterMapping(module);
					Node node = mappingNodes.item(i);
					NodeList configNodes = node.getChildNodes();
					for (int j = 0; j < configNodes.getLength(); j++) {
						Node configNode = configNodes.item(j);
						switch (configNode.getNodeName()) {
							case "filter-name":
								mapping.setFilterName(configNode.getTextContent());
								break;
							case "url-pattern":
								mapping.addUrlPattern(configNode.getTextContent());
								break;
							case "servlet-name":
								mapping.addServletName(configNode.getTextContent());
								break;
						}
					}
					mappings.add(mapping);
				}
				log.debug("Retrieved {} filter-mappings for {}: {}", mappings.size(), module, mappings);
				return mappings;
			}
		}
		catch (Exception e) {
			throw new ModuleException("Unable to parse filters in module configuration.", e);
		}
		return EMPTY_DEQUE;
	}
}
package org.openmrs.module;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class AdvicePoint {
	private static final Logger log = LoggerFactory.getLogger(AdvicePoint.class);
	private String point;
	private Object classInstance;
	private Module module;
	private String className;
	public AdvicePoint() {
	}
	public AdvicePoint(String point, Class<?> clazz) {
		this.point = point;
		try {
			this.classInstance = clazz.newInstance();
		}
		catch (Exception e) {
			log.error("Unable to get instance of: [{}]", clazz.getName(), e);
		}
	}
	public AdvicePoint(Module mod, String point, String className) {
		this.point = point;
		this.module = mod;
		this.className = className;
	}
	public String getPoint() {
		return point;
	}
	public Object getClassInstance() {
		if (classInstance != null) {
			return classInstance;
		}
		Object o = null;
		try {
			Class<?> c = ModuleFactory.getModuleClassLoader(getModule()).loadClass(getClassName());
			o = c.newInstance();
		}
		catch (Exception | LinkageError e) {
			log.warn("Could not get instance for advice point [{}]", point, e);
		}
		classInstance = o;
		return o;
	}
	public String getClassName() {
		return className;
	}
	public Module getModule() {
		return module;
	}
	public void disposeClassInstance() {
		classInstance = null;
	}
}
package org.openmrs.module;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.GlobalProperty;
import org.openmrs.Privilege;
import org.openmrs.api.context.Context;
import org.openmrs.customdatatype.CustomDatatype;
import org.openmrs.messagesource.MessageSourceService;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
public class ModuleFileParser {
	private static final Logger log = LoggerFactory.getLogger(ModuleFileParser.class);
	private static final String MODULE_CONFIG_XML_FILENAME = "config.xml";
	private static final String OPENMRS_MODULE_FILE_EXTENSION = ".omod";
	private static final Pattern OPENMRS_DTD_SYSTEM_ID_PATTERN = Pattern.compile("https?:
	private static List<String> validConfigVersions = new ArrayList<>();
	static {
		validConfigVersions.add("1.0");
		validConfigVersions.add("1.1");
		validConfigVersions.add("1.2");
		validConfigVersions.add("1.3");
		validConfigVersions.add("1.4");
		validConfigVersions.add("1.5");
		validConfigVersions.add("1.6");
		validConfigVersions.add("1.7");
		validConfigVersions.add("2.0");
	}
	private File moduleFile;
	private MessageSourceService messageSourceService;
	public ModuleFileParser(MessageSourceService messageSourceService) {
		this.messageSourceService = Objects.requireNonNull(messageSourceService, "messageSourceService must not be null");
	}
	@Deprecated
	public ModuleFileParser(File moduleFile) {
		this.messageSourceService = Context.getMessageSourceService();
		validateFileIsNotNull(moduleFile);
		validateFileHasModuleFileExtension(moduleFile);
		this.moduleFile = moduleFile;
	}
	private void validateFileIsNotNull(File moduleFile) {
		if (moduleFile == null) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.fileCannotBeNull"));
		}
	}
	private void validateFileHasModuleFileExtension(File moduleFile) {
		if (!moduleFile.getName().endsWith(OPENMRS_MODULE_FILE_EXTENSION)) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.invalidFileExtension"),
				moduleFile.getName());
		}
	}
	@Deprecated
	public ModuleFileParser(InputStream inputStream) {
		this.messageSourceService = Context.getMessageSourceService();
		this.moduleFile = createTempFile("moduleUpgrade", OPENMRS_MODULE_FILE_EXTENSION);
		copyInputStreamToFile(inputStream, this.moduleFile);
	}
	public Module parse(InputStream inputStream) {
		File moduleFile = createTempFile("moduleUpgrade", OPENMRS_MODULE_FILE_EXTENSION);
		copyInputStreamToFile(inputStream, moduleFile);
		return parse(moduleFile);
	}
	private File createTempFile(String prefix, String suffix) {
		File file;
		try {
			file = File.createTempFile(prefix, suffix);
		}
		catch (IOException e) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.cannotCreateFile"), e);
		}
		return file;
	}
	private void copyInputStreamToFile(InputStream inputStream, File file) {
		try (FileOutputStream outputStream = new FileOutputStream(file)) {
			OpenmrsUtil.copyFile(inputStream, outputStream);
		}
		catch (IOException e) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.cannotCreateFile"), e);
		}
		finally {
			try {
				inputStream.close();
			}
			catch (Exception e) { }
		}
	}
	@Deprecated
	ModuleFileParser() {
	}
	@Deprecated
	public Module parse() throws ModuleException {
		return parse(this.moduleFile);
	}
	public Module parse(File moduleFile) {
		validateFileIsNotNull(moduleFile);
		validateFileHasModuleFileExtension(moduleFile);
		return createModule(getModuleConfigXml(moduleFile), moduleFile);
	}
	private Document getModuleConfigXml(File moduleFile) {
		Document config;
		try (JarFile jarfile = new JarFile(moduleFile)) {
			ZipEntry configEntry = getConfigXmlZipEntry(jarfile, moduleFile);
			config = parseConfigXml(jarfile, configEntry, moduleFile);
		}
		catch (IOException e) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.cannotGetJarFile"),
				moduleFile.getName(), e);
		}
		return config;
	}
	private ZipEntry getConfigXmlZipEntry(JarFile jarfile, File moduleFile) {
		ZipEntry config = jarfile.getEntry(MODULE_CONFIG_XML_FILENAME);
		if (config == null) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.noConfigFile"),
				moduleFile.getName());
		}
		return config;
	}
	private Document parseConfigXml(JarFile jarfile, ZipEntry configEntry, File moduleFile) {
		Document config;
		try (InputStream configStream = jarfile.getInputStream(configEntry)) {
			config = parseConfigXmlStream(configStream, moduleFile);
		}
		catch (IOException e) {
			throw new ModuleException(messageSourceService.getMessage(
				"Module.error.cannotGetConfigFileStream"), moduleFile.getName(), e);
		}
		return config;
	}
	private Document parseConfigXmlStream(InputStream configStream, File moduleFile) {
		Document config;
		try {
			DocumentBuilder db = newDocumentBuilder();
			config = db.parse(configStream);
		}
		catch (Exception e) {
			log.error("Error parsing " + MODULE_CONFIG_XML_FILENAME + ": " + configStream.toString(), e);
			String output = "";
			try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
				byte[] buffer = new byte[4096];
				int bytesRead;
				while ((bytesRead = configStream.read(buffer)) != -1) {
					out.write(buffer, 0, bytesRead);
				}
				output = out.toString(StandardCharsets.UTF_8.name());
			}
			catch (Exception e2) {
				log.warn("Another error parsing " + MODULE_CONFIG_XML_FILENAME, e2);
			}
			log.error("{} content: {}", MODULE_CONFIG_XML_FILENAME, output);
			throw new ModuleException(messageSourceService.getMessage("Module.error.cannotParseConfigFile"),
				moduleFile.getName(), e);
		}
		return config;
	}
	private DocumentBuilder newDocumentBuilder() throws ParserConfigurationException {
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db = dbf.newDocumentBuilder();
		db.setEntityResolver((publicId, systemId) -> {
			Matcher dtdMatcher = OPENMRS_DTD_SYSTEM_ID_PATTERN.matcher(systemId);
			if (dtdMatcher.matches()) {
				String dtdFile = dtdMatcher.group("config");
				return new InputSource(OpenmrsClassLoader.getInstance().getResourceAsStream("org/openmrs/module/dtd/" + dtdFile));
			}
			return new InputSource(new StringReader(""));
		});
		return db;
	}
	private Module createModule(Document config, File moduleFile) {
		Element configRoot = config.getDocumentElement();
		String configVersion = ensureValidModuleConfigVersion(configRoot, moduleFile);
		String name = ensureNonEmptyName(configRoot, moduleFile);
		String moduleId = ensureNonEmptyId(configRoot, name);
		String packageName = ensureNonEmptyPackage(configRoot, name);
		String author = getElementTrimmed(configRoot, "author");
		String desc = getElementTrimmed(configRoot, "description");
		String version = getElementTrimmed(configRoot, "version");
		Module module = new Module(name, moduleId, packageName, author, desc, version, configVersion);
		module.setActivatorName(getElementTrimmed(configRoot, "activator"));
		module.setRequireDatabaseVersion(getElementTrimmed(configRoot, "require_database_version"));
		module.setRequireOpenmrsVersion(getElementTrimmed(configRoot, "require_version"));
		module.setUpdateURL(getElementTrimmed(configRoot, "updateURL"));
		module.setRequiredModulesMap(extractRequiredModules(configRoot));
		module.setAwareOfModulesMap(extractAwareOfModules(configRoot));
		module.setStartBeforeModulesMap(extractStartBeforeModules(configRoot));
		module.setAdvicePoints(extractAdvice(configRoot, module));
		module.setExtensionNames(extractExtensions(configRoot));
		module.setPrivileges(extractPrivileges(configRoot));
		module.setGlobalProperties(extractGlobalProperties(configRoot));
		module.setMappingFiles(extractMappingFiles(configRoot));
		module.setPackagesWithMappedClasses(extractPackagesWithMappedClasses(configRoot));
		module.setMandatory(extractMandatory(configRoot, configVersion));
		module.setConditionalResources(extractConditionalResources(configRoot));
		module.setConfig(config);
		module.setFile(moduleFile);
		return module;
	}
	private String ensureValidModuleConfigVersion(Element configRoot, File moduleFile) {
		String configVersion = configRoot.getAttribute("configVersion").trim();
		validateModuleConfigVersion(configVersion, moduleFile);
		return configVersion;
	}
	private void validateModuleConfigVersion(String version, File moduleFile) {
		if (!validConfigVersions.contains(version)) {
			throw new ModuleException(Context.getMessageSourceService().getMessage("Module.error.invalidConfigVersion",
				new Object[] { version, String.join(", ", validConfigVersions) }, Context.getLocale()),
				moduleFile.getName());
		}
	}
	private String ensureNonEmptyName(Element configRoot, File moduleFile) {
		return getTrimmedElementOrFail(configRoot, "name", "Module.error.nameCannotBeEmpty", moduleFile.getName());
	}
	private String ensureNonEmptyId(Element configRoot, String name) {
		return getTrimmedElementOrFail(configRoot, "id", "Module.error.idCannotBeEmpty", name);
	}
	private String ensureNonEmptyPackage(Element configRoot, String name) {
		return getTrimmedElementOrFail(configRoot, "package", "Module.error.packageCannotBeEmpty", name);
	}
	private Map<String, String> extractRequiredModules(Element configRoot) {
		return extractModulesWithVersionAttribute(configRoot, "require_module", "require_modules");
	}
	private Map<String, String> extractAwareOfModules(Element configRoot) {
		return extractModulesWithVersionAttribute(configRoot, "aware_of_module", "aware_of_modules");
	}
	private Map<String, String> extractStartBeforeModules(Element configRoot) {
		Map<String, String> result = extractModulesWithVersionAttribute(configRoot, "module", "start_before_modules");
		result.putAll(extractModulesWithVersionAttribute(configRoot, "start_before_module", "start_before_modules"));
		return result;
	}
	private Map<String, String> extractModulesWithVersionAttribute(Element configRoot, String elementName,
		String elementParentName) {
		NodeList parents = configRoot.getElementsByTagName(elementParentName);
		Map<String, String> result = new HashMap<>();
		if (parents.getLength() == 0) {
			return result;
		}
		Element firstParent = (Element) parents.item(0);
		NodeList children = firstParent.getElementsByTagName(elementName);
		int i = 0;
		while (i < children.getLength()) {
			Element child = (Element) children.item(i);
			Attr versionAttribute = child.getAttributeNode("version");
			String version = versionAttribute == null ? null : versionAttribute.getValue();
			result.put(child.getTextContent().trim(), version);
			i++;
		}
		return result;
	}
	private List<AdvicePoint> extractAdvice(Element configRoot, Module module) {
		List<AdvicePoint> result = new ArrayList<>();
		NodeList advice = configRoot.getElementsByTagName("advice");
		if (advice.getLength() == 0) {
			return result;
		}
		log.debug("# advice: {}", advice.getLength());
		int i = 0;
		while (i < advice.getLength()) {
			Element element = (Element) advice.item(i);
			String point = getElementTrimmed(element, "point");
			String adviceClass = getElementTrimmed(element, "class");
			log.debug("advice point: {}, class: {}", point, adviceClass);
			if (point.isEmpty() || adviceClass.isEmpty()) {
				log.warn("'point' and 'class' are required for advice. Given '{}' and '{}'", point, adviceClass);
			} else {
				result.add(new AdvicePoint(module, point, adviceClass));
			}
			i++;
		}
		return result;
	}
	private Map<String, String> extractExtensions(Element configRoot) {
		Map<String, String> result = new IdentityHashMap<>();
		NodeList extensions = configRoot.getElementsByTagName("extension");
		if (extensions.getLength() == 0) {
			return result;
		}
		log.debug("# extensions: {}", extensions.getLength());
		int i = 0;
		while (i < extensions.getLength()) {
			Element element = (Element) extensions.item(i);
			String point = getElementTrimmed(element, "point");
			String extClass = getElementTrimmed(element, "class");
			log.debug("extension point: {}, class: {}", point, extClass);
			if (point.isEmpty() || extClass.isEmpty()) {
				log.warn("'point' and 'class' are required for extensions. Given '{}' and '{}'", point, extClass);
			} else if (point.contains(Extension.EXTENSION_ID_SEPARATOR)) {
				log.warn("Point id contains illegal character: '{}'", Extension.EXTENSION_ID_SEPARATOR);
			} else {
				result.put(point, extClass);
			}
			i++;
		}
		return result;
	}
	private List<Privilege> extractPrivileges(Element configRoot) {
		List<Privilege> result = new ArrayList<>();
		NodeList privileges = configRoot.getElementsByTagName("privilege");
		if (privileges.getLength() == 0) {
			return result;
		}
		log.debug("# privileges: {}", privileges.getLength());
		int i = 0;
		while (i < privileges.getLength()) {
			Element element = (Element) privileges.item(i);
			String name = getElementTrimmed(element, "name");
			String description = getElementTrimmed(element, "description");
			log.debug("extension name: {}, description: {}", name, description);
			if (name.isEmpty() || description.isEmpty()) {
				log.warn("'name' and 'description' are required for privilege. Given '{}' and '{}'", name, description);
			} else {
				result.add(new Privilege(name, description));
			}
			i++;
		}
		return result;
	}
	private List<GlobalProperty> extractGlobalProperties(Element configRoot) {
		List<GlobalProperty> result = new ArrayList<>();
		NodeList propNodes = configRoot.getElementsByTagName("globalProperty");
		if (propNodes.getLength() == 0) {
			return result;
		}
		log.debug("# global properties: {}", propNodes.getLength());
		int i = 0;
		while (i < propNodes.getLength()) {
			Element gpElement = (Element) propNodes.item(i);
			GlobalProperty globalProperty = extractGlobalProperty(gpElement);
			if (globalProperty != null) {
				result.add(globalProperty);
			}
			i++;
		}
		return result;
	}
	private GlobalProperty extractGlobalProperty(Element element) {
		String property = getElementTrimmed(element, "property");
		String defaultValue = getElementTrimmed(element, "defaultValue");
		String description = removeTabsAndTrim(getElementTrimmed(element, "description"));
		String datatypeClassname = getElementTrimmed(element, "datatypeClassname");
		String datatypeConfig = getElementTrimmed(element, "datatypeConfig");
		String viewPrivilege = removeTabsAndTrim(getElementTrimmed(element, "viewPrivilege"));
		String editPrivilege = removeTabsAndTrim(getElementTrimmed(element, "editPrivilege"));
		String deletePrivilege = removeTabsAndTrim(getElementTrimmed(element, "deletePrivilege"));
		log.debug("property: {}, defaultValue: {}", property, defaultValue);
		log.debug("description: {}, datatypeClassname: {}", description, datatypeClassname);
		log.debug("datatypeConfig: {}", datatypeConfig);
		log.debug("viewPrivilege: {}, editPrivilege: {}, deletePrivilege: {}", viewPrivilege, editPrivilege, deletePrivilege);
		return createGlobalProperty(property, defaultValue, description, datatypeClassname,
			datatypeConfig, viewPrivilege, editPrivilege, deletePrivilege);
	}
	private String removeTabsAndTrim(String string) {
		return string.replaceAll("	", "").trim();
	}
	private GlobalProperty createGlobalProperty(String property, String defaultValue, String description,
		String datatypeClassname, String datatypeConfig, String viewPrivilege, String editPrivilege, String deletePrivilege) {
		GlobalProperty globalProperty = null;
		if (property.isEmpty()) {
			log.warn("'property' is required for global properties. Given '{}'", property);
			return globalProperty;
		}
		if (!datatypeClassname.isEmpty()) {
			globalProperty = createGlobalPropertyWithDatatype(property, defaultValue, description, datatypeClassname,
				datatypeConfig);
		} else {
			globalProperty = new GlobalProperty(property, defaultValue, description);
		}
		if (!viewPrivilege.isEmpty()) {
			globalProperty.setViewPrivilege(new Privilege(viewPrivilege));
		}
		if (!editPrivilege.isEmpty()) {
			globalProperty.setEditPrivilege(new Privilege(editPrivilege));
		}
		if (!deletePrivilege.isEmpty()) {
			globalProperty.setDeletePrivilege(new Privilege(deletePrivilege));
		}
		return globalProperty;
	}
	private GlobalProperty createGlobalPropertyWithDatatype(String property, String defaultValue, String description,
		String datatypeClassname, String datatypeConfig) {
		GlobalProperty globalProperty = null;
		try {
			Class<CustomDatatype<?>> datatypeClazz = (Class<CustomDatatype<?>>) Class.forName(datatypeClassname)
				.asSubclass(CustomDatatype.class);
			globalProperty = new GlobalProperty(property, defaultValue, description, datatypeClazz, datatypeConfig);
		}
		catch (ClassCastException ex) {
			log.error("The class specified by 'datatypeClassname' (" + datatypeClassname
				+ ") must be a subtype of 'org.openmrs.customdatatype.CustomDatatype<?>'.", ex);
		}
		catch (ClassNotFoundException ex) {
			log.error("The class specified by 'datatypeClassname' (" + datatypeClassname
				+ ") could not be found.", ex);
		}
		return globalProperty;
	}
	private List<String> extractMappingFiles(Element configRoot) {
		List<String> result = new ArrayList<>();
		splitTagContentByWhitespace(configRoot, "mappingFiles", result);
		return result;
	}
	private Set<String> extractPackagesWithMappedClasses(Element configRoot) {
		Set<String> result = new HashSet<>();
		splitTagContentByWhitespace(configRoot, "packagesWithMappedClasses", result);
		return result;
	}
	private Collection<String> splitTagContentByWhitespace(Element rootNode, String tag, Collection<String> result) {
		String content = getElement(rootNode, tag);
		for (String s : content.split("\\s")) {
			String s2 = s.trim();
			if (s2.length() > 0) {
				result.add(s2);
			}
		}
		return result;
	}
	private String getTrimmedElementOrFail(Element rootNode, String elementName, String errorMessageKey, String moduleName) {
		String element = getElementTrimmed(rootNode, elementName);
		if (element == null || element.length() == 0) {
			throw new ModuleException(messageSourceService.getMessage(errorMessageKey),
				moduleName);
		}
		return element;
	}
	private String getElementTrimmed(Element element, String name) {
		return getElement(element, name).trim();
	}
	private String getElement(Element root, String tag) {
		if (root.getElementsByTagName(tag).getLength() > 0) {
			return root.getElementsByTagName(tag).item(0).getTextContent();
		}
		return "";
	}
	private boolean extractMandatory(Element configRoot, String configVersion) {
		if (Double.parseDouble(configVersion) >= 1.3) {
			String mandatory = getElementTrimmed(configRoot, "mandatory");
			return "true".equalsIgnoreCase(mandatory);
		}
		return false;
	}
	List<ModuleConditionalResource> extractConditionalResources(Element configRoot) {
		List<ModuleConditionalResource> conditionalResources = new ArrayList<>();
		NodeList parentConditionalResources = configRoot.getElementsByTagName("conditionalResources");
		if (parentConditionalResources.getLength() == 0) {
			return new ArrayList<>();
		} else if (parentConditionalResources.getLength() > 1) {
			throw new IllegalArgumentException("Found multiple conditionalResources tags. There can be only one.");
		}
		NodeList conditionalResourcesNode = parentConditionalResources.item(0).getChildNodes();
		for (int i = 0; i < conditionalResourcesNode.getLength(); i++) {
			Node conditionalResourceNode = conditionalResourcesNode.item(i);
			if ("#text".equals(conditionalResourceNode.getNodeName())) {
				continue;
			}
			if (!"conditionalResource".equals(conditionalResourceNode.getNodeName())) {
				throw new IllegalArgumentException("Found the " + conditionalResourceNode.getNodeName()
					+ " node under conditionalResources. Only conditionalResource is allowed.");
			}
			NodeList resourceElements = conditionalResourceNode.getChildNodes();
			ModuleConditionalResource resource = new ModuleConditionalResource();
			conditionalResources.add(resource);
			for (int j = 0; j < resourceElements.getLength(); j++) {
				Node resourceElement = resourceElements.item(j);
				if ("path".equals(resourceElement.getNodeName())) {
					if (StringUtils.isBlank(resourceElement.getTextContent())) {
						throw new IllegalArgumentException("The path of a conditional resource must not be blank");
					}
					resource.setPath(resourceElement.getTextContent());
				} else if ("openmrsVersion".equals(resourceElement.getNodeName())) {
					if (StringUtils.isBlank(resource.getOpenmrsPlatformVersion())) {
						resource.setOpenmrsPlatformVersion(resourceElement.getTextContent());
					}
				} else if ("openmrsPlatformVersion".equals(resourceElement.getNodeName())) {
					resource.setOpenmrsPlatformVersion(resourceElement.getTextContent());
				} else if ("modules".equals(resourceElement.getNodeName())) {
					NodeList modulesNode = resourceElement.getChildNodes();
					for (int k = 0; k < modulesNode.getLength(); k++) {
						Node moduleNode = modulesNode.item(k);
						if ("module".equals(moduleNode.getNodeName())) {
							NodeList moduleElements = moduleNode.getChildNodes();
							ModuleConditionalResource.ModuleAndVersion module = new ModuleConditionalResource.ModuleAndVersion();
							resource.getModules().add(module);
							for (int m = 0; m < moduleElements.getLength(); m++) {
								Node moduleElement = moduleElements.item(m);
								if ("moduleId".equals(moduleElement.getNodeName())) {
									module.setModuleId(moduleElement.getTextContent());
								} else if ("version".equals(moduleElement.getNodeName())) {
									module.setVersion(moduleElement.getTextContent());
								}
							}
						}
					}
				}
			}
		}
		return conditionalResources;
	}
}
package org.openmrs.module;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.openmrs.GlobalProperty;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.context.Context;
import org.openmrs.api.context.ServiceContext;
import org.openmrs.scheduler.SchedulerUtil;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
public class ModuleUtil {
	private ModuleUtil() {
	}
	private static final Logger log = LoggerFactory.getLogger(ModuleUtil.class);
	public static void startup(Properties props) throws ModuleMustStartException {
		String moduleListString = props.getProperty(ModuleConstants.RUNTIMEPROPERTY_MODULE_LIST_TO_LOAD);
		if (moduleListString == null || moduleListString.isEmpty()) {
			log.debug("Starting all modules");
			ModuleFactory.loadModules();
		} else {
			log.debug("Starting all modules in this list: " + moduleListString);
			String[] moduleArray = moduleListString.split(" ");
			List<File> modulesToLoad = new ArrayList<>();
			for (String modulePath : moduleArray) {
				if (modulePath != null && modulePath.length() > 0) {
					File file = new File(modulePath);
					if (file.exists()) {
						modulesToLoad.add(file);
					} else {
						InputStream stream = ModuleUtil.class.getClassLoader().getResourceAsStream(modulePath);
						if (stream != null) {
							try {
								String tmpDir = System.getProperty("java.io.tmpdir");
								File expandedFile = File.createTempFile(file.getName() + "-", ".omod", new File(tmpDir));
								FileOutputStream outStream = new FileOutputStream(expandedFile, false);
								OpenmrsUtil.copyFile(stream, outStream);
								modulesToLoad.add(expandedFile);
								expandedFile.deleteOnExit();
							}
							catch (IOException io) {
								log.error("Unable to expand classpath found module: " + modulePath, io);
							}
						} else {
							log
							        .error("Unable to load module at path: "
							                + modulePath
							                + " because no file exists there and it is not found on the classpath. (absolute path tried: "
							                + file.getAbsolutePath() + ")");
						}
					}
				}
			}
			ModuleFactory.loadModules(modulesToLoad);
		}
		ModuleFactory.startModules();
		if (log.isDebugEnabled()) {
			Collection<Module> modules = ModuleFactory.getStartedModules();
			if (modules == null || modules.isEmpty()) {
				log.debug("No modules loaded");
			} else {
				log.debug("Found and loaded {} module(s)", modules.size());
			}
		}
		checkOpenmrsCoreModulesStarted();
		checkMandatoryModulesStarted();
	}
	public static void shutdown() {
		List<Module> modules = new ArrayList<>(ModuleFactory.getStartedModules());
		for (Module mod : modules) {
			log.debug("stopping module: {}", mod.getModuleId());
			if (mod.isStarted()) {
				ModuleFactory.stopModule(mod, true, true);
			}
		}
		log.debug("done shutting down modules");
		ModuleFactory.extensionMap.clear();
		ModuleFactory.loadedModules.invalidateAll();
		ModuleFactory.moduleClassLoaders.invalidateAll();
		ModuleFactory.startedModules.invalidateAll();
	}
	public static File insertModuleFile(InputStream inputStream, String filename) {
		File folder = getModuleRepository();
		if (OpenmrsUtil.folderContains(folder, filename)) {
			throw new ModuleException(filename + " is already associated with a loaded module.");
		}
		File file = new File(folder.getAbsolutePath(), filename);
		try (FileOutputStream outputStream = new FileOutputStream(file)) {
			OpenmrsUtil.copyFile(inputStream, outputStream);
		}
		catch (IOException e) {
			throw new ModuleException("Can't create module file for " + filename, e);
		}
		finally {
			try {
				inputStream.close();
			}
			catch (Exception e) { }
		}
		return file;
	}
	public static boolean isOpenmrsVersionInVersions(String ...versions) {
		if (versions == null || versions.length == 0) {
			return false;
		}
		boolean result = false;
		for (String version : versions) {
			if (matchRequiredVersions(OpenmrsConstants.OPENMRS_VERSION_SHORT, version)) {
				result = true;
				break;
			}
		}
		return result;
	}
	public static boolean matchRequiredVersions(String version, String versionRange) {
		if (StringUtils.isNotEmpty(versionRange)) {
			String[] ranges = versionRange.split(",");
			for (String range : ranges) {
				String separator = "-";
				if (range.indexOf("*") > 0 || range.indexOf(separator) > 0 && (!isVersionWithQualifier(range))) {
					String lowerBound = range;
					String upperBound = range;
					int indexOfSeparator = range.indexOf(separator);
					while (indexOfSeparator > 0) {
						lowerBound = range.substring(0, indexOfSeparator);
						upperBound = range.substring(indexOfSeparator + 1);
						if (upperBound.matches("^\\s?\\d+.*")) {
							break;
						}
						indexOfSeparator = range.indexOf(separator, indexOfSeparator + 1);
					}
					lowerBound = StringUtils.remove(lowerBound, lowerBound.replaceAll("^\\s?\\d+[\\.\\d+\\*?|\\.\\*]+", ""));
					upperBound = StringUtils.remove(upperBound, upperBound.replaceAll("^\\s?\\d+[\\.\\d+\\*?|\\.\\*]+", ""));
					if (lowerBound.indexOf("*") > 0) {
						lowerBound = lowerBound.replaceAll("\\*", "0");
					}
					if (upperBound.indexOf("*") > 0) {
						upperBound = upperBound.replaceAll("\\*", Integer.toString(Integer.MAX_VALUE));
					}
					int lowerReturn = compareVersion(version, lowerBound);
					int upperReturn = compareVersion(version, upperBound);
					if (lowerReturn < 0 || upperReturn > 0) {
						log.debug("Version " + version + " is not between " + lowerBound + " and " + upperBound);
					} else {
						return true;
					}
				} else {
					if (compareVersion(version, range) < 0) {
						log.debug("Version " + version + " is below " + range);
					} else {
						return true;
					}
				}
			}
		}
		else {
			return true;
		}
		return false;
	}
	public static void checkRequiredVersion(String version, String versionRange) throws ModuleException {
		if (!matchRequiredVersions(version, versionRange)) {
			String ms = Context.getMessageSourceService().getMessage("Module.requireVersion.outOfBounds",
			    new String[] { versionRange, version }, Context.getLocale());
			throw new ModuleException(ms);
		}
	}
	public static int compareVersion(String version, String value) {
		try {
			if (version == null || value == null) {
				return 0;
			}
			List<String> versions = new ArrayList<>();
			List<String> values = new ArrayList<>();
			String separator = "-";
			int qualifierIndex = version.indexOf(separator);
			if (qualifierIndex != -1) {
				version = version.substring(0, qualifierIndex);
			}
			qualifierIndex = value.indexOf(separator);
			if (qualifierIndex != -1) {
				value = value.substring(0, qualifierIndex);
			}
			Collections.addAll(versions, version.split("\\."));
			Collections.addAll(values, value.split("\\."));
			while (versions.size() < values.size()) {
				versions.add("0");
			}
			while (values.size() < versions.size()) {
				values.add("0");
			}
			for (int x = 0; x < versions.size(); x++) {
				String verNum = versions.get(x).trim();
				String valNum = values.get(x).trim();
				Long ver = NumberUtils.toLong(verNum, 0);
				Long val = NumberUtils.toLong(valNum, 0);
				int ret = ver.compareTo(val);
				if (ret != 0) {
					return ret;
				}
			}
		}
		catch (NumberFormatException e) {
			log.error("Error while converting a version/value to an integer: " + version + "/" + value, e);
		}
		return 0;
	}
	public static boolean isVersionWithQualifier(String version) {
		Matcher matcher = Pattern.compile("(\\d+)\\.(\\d+)(\\.(\\d+))?(\\-([A-Za-z]+))").matcher(version);
		return matcher.matches();
	}
	public static File getModuleRepository() {
		String folderName = Context.getRuntimeProperties().getProperty(ModuleConstants.REPOSITORY_FOLDER_RUNTIME_PROPERTY);
		if (StringUtils.isBlank(folderName)) {
			AdministrationService as = Context.getAdministrationService();
			folderName = as.getGlobalProperty(ModuleConstants.REPOSITORY_FOLDER_PROPERTY,
			    ModuleConstants.REPOSITORY_FOLDER_PROPERTY_DEFAULT);
		}
		File folder = new File(folderName);
		if (!folder.exists()) {
			folder = new File(OpenmrsUtil.getApplicationDataDirectory(), folderName);
		}
		if (!folder.exists()) {
			log.warn("Module repository " + folder.getAbsolutePath() + " doesn't exist.  Creating directories now.");
			folder.mkdirs();
		}
		if (!folder.isDirectory()) {
			throw new ModuleException("Module repository is not a directory at: " + folder.getAbsolutePath());
		}
		return folder;
	}
	public static URL file2url(final File file) throws MalformedURLException {
		if (file == null) {
			return null;
		}
		try {
			return file.getCanonicalFile().toURI().toURL();
		}
		catch (IOException | NoSuchMethodError ioe) {
			throw new MalformedURLException("Cannot convert: " + file.getName() + " to url");
		}
	}
	public static void expandJar(File fileToExpand, File tmpModuleDir, String name, boolean keepFullPath) throws IOException {
		String docBase = tmpModuleDir.getAbsolutePath();
		try (JarFile jarFile = new JarFile(fileToExpand)) {
			Enumeration<JarEntry> jarEntries = jarFile.entries();
			boolean foundName = (name == null);
			while (jarEntries.hasMoreElements()) {
				JarEntry jarEntry = jarEntries.nextElement();
				if (name == null || jarEntry.getName().startsWith(name)) {
					String entryName = jarEntry.getName();
					if (!keepFullPath && name != null) {
						entryName = entryName.replaceFirst(name, "");
					}
					int last = entryName.lastIndexOf('/');
					if (last >= 0) {
						File parent = new File(docBase, entryName.substring(0, last));
						parent.mkdirs();
						log.debug("Creating parent dirs: " + parent.getAbsolutePath());
					}
					if (entryName.endsWith("/") || "".equals(entryName)) {
						continue;
					}
					try(InputStream input = jarFile.getInputStream(jarEntry)) {
						expand(input, docBase, entryName);
					}
					foundName = true;
				}
			}
			if (!foundName) {
				log.debug("Unable to find: " + name + " in file " + fileToExpand.getAbsolutePath());
			}
		}
		catch (IOException e) {
			log.warn("Unable to delete tmpModuleFile on error", e);
			throw e;
		}
	}
	private static void expand(InputStream input, String fileDir, String name) throws IOException {
		log.debug("expanding: {}", name);
		File file = new File(fileDir, name);
		if (!file.toPath().normalize().startsWith(fileDir)) {
			throw new UnsupportedOperationException("Attempted to write file '" + name + "' rejected as it attempts to write outside the chosen directory. This may be the result of a zip-slip style attack.");
		}
		try (FileOutputStream outStream = new FileOutputStream(file)) {
			OpenmrsUtil.copyFile(input, outStream);
		}
	}
	public static InputStream getURLStream(URL url) {
		InputStream in = null;
		try {
			URLConnection uc = url.openConnection();
			uc.setDefaultUseCaches(false);
			uc.setUseCaches(false);
			uc.setRequestProperty("Cache-Control", "max-age=0,no-cache");
			uc.setRequestProperty("Pragma", "no-cache");
			log.debug("Logging an attempt to connect to: " + url);
			in = openConnectionCheckRedirects(uc);
		}
		catch (IOException io) {
			log.warn("io while reading: " + url, io);
		}
		return in;
	}
	protected static InputStream openConnectionCheckRedirects(URLConnection c) throws IOException {
		boolean redir;
		int redirects = 0;
		InputStream in;
		do {
			if (c instanceof HttpURLConnection) {
				((HttpURLConnection) c).setInstanceFollowRedirects(false);
			}
			in = c.getInputStream();
			redir = false;
			if (c instanceof HttpURLConnection) {
				HttpURLConnection http = (HttpURLConnection) c;
				int stat = http.getResponseCode();
				if (stat == 300 || stat == 301 || stat == 302 || stat == 303 || stat == 305 || stat == 307) {
					URL base = http.getURL();
					String loc = http.getHeaderField("Location");
					URL target = null;
					if (loc != null) {
						target = new URL(base, loc);
					}
					http.disconnect();
					if (target == null || !("http".equals(target.getProtocol()) || "https".equals(target.getProtocol()))
					        || redirects >= 5) {
						throw new SecurityException("illegal URL redirect");
					}
					redir = true;
					c = target.openConnection();
					redirects++;
				}
			}
		} while (redir);
		return in;
	}
	public static String getURL(URL url) {
		InputStream in = null;
		ByteArrayOutputStream out = null;
		String output = "";
		try {
			in = getURLStream(url);
			if (in == null) {
				return "";
			}
			out = new ByteArrayOutputStream();
			OpenmrsUtil.copyFile(in, out);
			output = out.toString(StandardCharsets.UTF_8.name());
		}
		catch (IOException io) {
			log.warn("io while reading: " + url, io);
		}
		finally {
			try {
				in.close();
			}
			catch (Exception e) { }
			try {
				out.close();
			}
			catch (Exception e) { }
		}
		return output;
	}
	public static Boolean checkForModuleUpdates() throws ModuleException {
		Boolean updateFound = false;
		for (Module mod : ModuleFactory.getLoadedModules()) {
			String updateURL = mod.getUpdateURL();
			if (StringUtils.isNotEmpty(updateURL)) {
				try {
					URL url = new URL(updateURL);
					if (!url.toString().endsWith(ModuleConstants.UPDATE_FILE_NAME)) {
						log.warn("Illegal url: " + url);
						continue;
					}
					String content = getURL(url);
					if ("".equals(content)) {
						continue;
					}
					UpdateFileParser parser = new UpdateFileParser(content);
					parser.parse();
					log.debug("Update for mod: " + mod.getModuleId() + " compareVersion result: "
					        + compareVersion(mod.getVersion(), parser.getCurrentVersion()));
					if (compareVersion(mod.getVersion(), parser.getCurrentVersion()) < 0) {
						if (mod.getModuleId().equals(parser.getModuleId())) {
							mod.setDownloadURL(parser.getDownloadURL());
							mod.setUpdateVersion(parser.getCurrentVersion());
							updateFound = true;
						} else {
							log.warn("Module id does not match in update.rdf:" + parser.getModuleId());
						}
					} else {
						mod.setDownloadURL(null);
						mod.setUpdateVersion(null);
					}
				}
				catch (ModuleException e) {
					log.warn("Unable to get updates from update.xml", e);
				}
				catch (MalformedURLException e) {
					log.warn("Unable to form a URL object out of: " + updateURL, e);
				}
			}
		}
		return updateFound;
	}
	public static Boolean allowAdmin() {
		Properties properties = Context.getRuntimeProperties();
		String prop = properties.getProperty(ModuleConstants.RUNTIMEPROPERTY_ALLOW_UPLOAD, null);
		if (prop == null) {
			prop = properties.getProperty(ModuleConstants.RUNTIMEPROPERTY_ALLOW_ADMIN, "false");
		}
		return "true".equals(prop);
	}
	public static AbstractRefreshableApplicationContext refreshApplicationContext(AbstractRefreshableApplicationContext ctx) {
		return refreshApplicationContext(ctx, false, null);
	}
	public static AbstractRefreshableApplicationContext refreshApplicationContext(AbstractRefreshableApplicationContext ctx,
	        boolean isOpenmrsStartup, Module startedModule) {
		Set<Module> startedModules = new LinkedHashSet<>(ModuleFactory.getStartedModulesInOrder());
		for (Module module : startedModules) {
			try {
				if (module.getModuleActivator() != null) {
					Thread.currentThread().setContextClassLoader(ModuleFactory.getModuleClassLoader(module));
					module.getModuleActivator().willRefreshContext();
				}
			}
			catch (Exception e) {
				log.warn("Unable to call willRefreshContext() method in the module's activator", e);
			}
		}
		OpenmrsClassLoader.saveState();
		SchedulerUtil.shutdown();
		ServiceContext.destroyInstance();
		try {
			ctx.stop();
			ctx.close();
		}
		catch (Exception e) {
			log.warn("Exception while stopping and closing context: ", e);
		}
		OpenmrsClassLoader.destroyInstance();
		ctx.setClassLoader(OpenmrsClassLoader.getInstance());
		Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
		ServiceContext.getInstance().startRefreshingContext();
		try {
			ctx.refresh();
		}
		finally {
			ServiceContext.getInstance().doneRefreshingContext();
		}
		ctx.setClassLoader(OpenmrsClassLoader.getInstance());
		Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
		OpenmrsClassLoader.restoreState();
		SchedulerUtil.startup(Context.getRuntimeProperties());
		OpenmrsClassLoader.setThreadsToNewClassLoader();
		log.debug("Reloading advice for all started modules: {}", startedModules.size());
		try {
			Context.openSessionWithCurrentUser();
			for (Module module : startedModules) {
				if (!module.isStarted()) {
					continue;
				}
				ModuleFactory.loadAdvice(module);
				try {
					ModuleFactory.passDaemonToken(module);
					if (module.getModuleActivator() != null) {
						module.getModuleActivator().contextRefreshed();
						try {
							if (isOpenmrsStartup) {
								module.getModuleActivator().started();
							}
							else if (!isOpenmrsStartup && module.equals(startedModule)) {
								module.getModuleActivator().started();
							}
						}
						catch (Exception e) {
							log.warn("Unable to invoke started() method on the module's activator", e);
							ModuleFactory.stopModule(module, true, true);
						}
					}
				}
				catch (Exception e) {
					log.warn("Unable to invoke method on the module's activator ", e);
				}
			}
		}
		finally {
			Context.closeSessionWithCurrentUser();
		}
		return ctx;
	}
	protected static void checkMandatoryModulesStarted() throws ModuleException {
		List<String> mandatoryModuleIds = getMandatoryModules();
		Set<String> startedModuleIds = ModuleFactory.getStartedModulesMap().keySet();
		mandatoryModuleIds.removeAll(startedModuleIds);
		if (!mandatoryModuleIds.isEmpty()) {
			throw new MandatoryModuleException(mandatoryModuleIds);
		}
	}
	protected static void checkOpenmrsCoreModulesStarted() throws OpenmrsCoreModuleException {
		if (ignoreCoreModules()) {
			return;
		}
		Map<String, String> coreModules = new HashMap<>(ModuleConstants.CORE_MODULES);
		Collection<Module> startedModules = ModuleFactory.getStartedModulesMap().values();
		for (Module mod : startedModules) {
			String moduleId = mod.getModuleId();
			if (coreModules.containsKey(moduleId)) {
				String coreReqVersion = coreModules.get(moduleId);
				if (compareVersion(mod.getVersion(), coreReqVersion) >= 0) {
					coreModules.remove(moduleId);
				} else {
					log.debug("Module: " + moduleId + " is a core module and is started, but its version: "
					        + mod.getVersion() + " is not within the required version: " + coreReqVersion);
				}
			}
		}
		if (coreModules.size() > 0) {
			throw new OpenmrsCoreModuleException(coreModules);
		}
	}
	public static boolean ignoreCoreModules() {
		String ignoreCoreModules = Context.getRuntimeProperties().getProperty(ModuleConstants.IGNORE_CORE_MODULES_PROPERTY,
		    "false");
		return Boolean.parseBoolean(ignoreCoreModules);
	}
	public static List<String> getMandatoryModules() {
		List<String> mandatoryModuleIds = new ArrayList<>();
		try {
			List<GlobalProperty> props = Context.getAdministrationService().getGlobalPropertiesBySuffix(".mandatory");
			for (GlobalProperty prop : props) {
				if ("true".equalsIgnoreCase(prop.getPropertyValue())) {
					mandatoryModuleIds.add(prop.getProperty().replace(".mandatory", ""));
				}
			}
		}
		catch (Exception e) {
			log.warn("Unable to get the mandatory module list", e);
		}
		return mandatoryModuleIds;
	}
	public static Module getModuleForPath(String path) {
		int ind = path.lastIndexOf('/');
		if (ind <= 0) {
			throw new IllegalArgumentException(
			        "Input must be /moduleId/resource. Input needs a / after the first character: " + path);
		}
		String moduleId = path.startsWith("/") ? path.substring(1, ind) : path.substring(0, ind);
		moduleId = moduleId.replace('/', '.');
		while (true) {
			Module mod = ModuleFactory.getStartedModuleById(moduleId);
			if (mod != null) {
				return mod;
			}
			ind = moduleId.lastIndexOf('.');
			if (ind < 0) {
				break;
			}
			moduleId = moduleId.substring(0, ind);
		}
		return null;
	}
	public static String getPathForResource(Module module, String path) {
		if (path.startsWith("/")) {
			path = path.substring(1);
		}
		return path.substring(module.getModuleIdAsPath().length());
	}
	public static Collection<String> getPackagesFromFile(File file) {
		if (!file.getName().endsWith(".jar")) {
			return Collections.emptySet();
		}
		Set<String> packagesProvided = new HashSet<>();
		JarFile jar = null;
		try {
			jar = new JarFile(file);
			Enumeration<JarEntry> jarEntries = jar.entries();
			while (jarEntries.hasMoreElements()) {
				JarEntry jarEntry = jarEntries.nextElement();
				if (jarEntry.isDirectory()) {
					continue;
				}
				String name = jarEntry.getName();
				if (name.startsWith("lib") || name.startsWith("META-INF") || name.startsWith("web/module")) {
					continue;
				}
				Integer indexOfLastSlash = name.lastIndexOf("/");
				if (indexOfLastSlash <= 0) {
					continue;
				}
				String packageName = name.substring(0, indexOfLastSlash);
				packageName = packageName.replaceAll("/", ".");
				if (packagesProvided.add(packageName) && log.isTraceEnabled()) {
					log.trace("Adding module's jarentry with package: " + packageName);
				}
			}
			jar.close();
		}
		catch (IOException e) {
			log.error("Error while reading file: " + file.getAbsolutePath(), e);
		}
		finally {
			if (jar != null) {
				try {
					jar.close();
				}
				catch (IOException e) {
				}
			}
		}
		return packagesProvided;
	}
	public static InputStream getResourceFromApi(JarFile jarFile, String moduleId, String version, String resource) {
		String apiLocation = "lib/" + moduleId + "-api-" + version + ".jar";
		return getResourceFromInnerJar(jarFile, apiLocation, resource);
	}
	private static InputStream getResourceFromInnerJar(JarFile outerJarFile, String innerJarFileLocation, String resource) {
		File tempFile = null;
		FileOutputStream tempOut = null;
		JarFile innerJarFile = null;
		InputStream innerInputStream = null;
		try {
			tempFile = File.createTempFile("tempFile", "jar");
			tempOut = new FileOutputStream(tempFile);
			ZipEntry innerJarFileEntry = outerJarFile.getEntry(innerJarFileLocation);
			if (innerJarFileEntry != null) {
				IOUtils.copy(outerJarFile.getInputStream(innerJarFileEntry), tempOut);
				innerJarFile = new JarFile(tempFile);
				ZipEntry targetEntry = innerJarFile.getEntry(resource);
				if (targetEntry != null) {
					innerInputStream = innerJarFile.getInputStream(targetEntry);
					byte[] byteArray = IOUtils.toByteArray(innerInputStream);
					return new ByteArrayInputStream(byteArray);
				}
			}
		}
		catch (IOException e) {
			log.error("Unable to get '" + resource + "' from '" + innerJarFileLocation + "' of '" + outerJarFile.getName()
			        + "'", e);
		}
		finally {
			IOUtils.closeQuietly(tempOut);
			IOUtils.closeQuietly(innerInputStream);
			try {
				if (innerJarFile != null) {
					innerJarFile.close();
				}
			}
			catch (IOException e) {
				log.warn("Unable to close inner jarfile: " + innerJarFile, e);
			}
			if (tempFile != null && !tempFile.delete()) {
				log.warn("Could not delete temporary jarfile: " + tempFile);
			}
		}
		return null;
	}
	public static File getDevelopmentDirectory(String moduleId) {
		String directory = System.getProperty(moduleId + ".development.directory");
		if (StringUtils.isNotBlank(directory)) {
			return new File(directory);
		}
		return null;
	}
}
package org.openmrs;
import java.util.Date;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.openmrs.customdatatype.CustomDatatype;
import org.openmrs.customdatatype.CustomDatatypeUtil;
import org.openmrs.customdatatype.CustomValueDescriptor;
import org.openmrs.customdatatype.SingleCustomValue;
@Audited
public class GlobalProperty extends BaseOpenmrsObject implements CustomValueDescriptor, SingleCustomValue<GlobalProperty> {
	private static final long serialVersionUID = 1L;
	private String property = "";
	private String propertyValue = "";
	private transient Object typedValue;
	private boolean dirty = false;
	private String description = "";
	private String datatypeClassname;
	private String datatypeConfig;
	private String preferredHandlerClassname;
	private String handlerConfig;
	private User changedBy;
	private Date dateChanged;
	private Privilege viewPrivilege;
	private Privilege editPrivilege;
	private Privilege deletePrivilege;
	public GlobalProperty() {
	}
	public GlobalProperty(String property) {
		this.property = property;
	}
	public GlobalProperty(String property, String value) {
		this(property);
		this.propertyValue = value;
	}
	public GlobalProperty(String property, String value, String description) {
		this(property, value);
		this.description = description;
	}
	public GlobalProperty(String property, String value, String description,
	    Class<? extends CustomDatatype<?>> datatypeClass, String datatypeConfig) {
		this(property, value, description);
		this.datatypeClassname = datatypeClass.getName();
		this.datatypeConfig = datatypeConfig;
	}
	public String getProperty() {
		return property;
	}
	public void setProperty(String property) {
		this.property = property;
	}
	public String getPropertyValue() {
		return propertyValue;
	}
	public void setPropertyValue(String propertyValue) {
		this.propertyValue = propertyValue;
	}
	public String getDescription() {
		return description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	@Override
	public Integer getId() {
		throw new UnsupportedOperationException();
	}
	@Override
	public void setId(Integer id) {
		throw new UnsupportedOperationException();
	}
	@Override
	public String getDatatypeClassname() {
		return datatypeClassname;
	}
	public void setDatatypeClassname(String datatypeClassname) {
		this.datatypeClassname = datatypeClassname;
	}
	@Override
	public String getDatatypeConfig() {
		return datatypeConfig;
	}
	public void setDatatypeConfig(String datatypeConfig) {
		this.datatypeConfig = datatypeConfig;
	}
	@Override
	public String getPreferredHandlerClassname() {
		return preferredHandlerClassname;
	}
	public void setPreferredHandlerClassname(String preferredHandlerClassname) {
		this.preferredHandlerClassname = preferredHandlerClassname;
	}
	@Override
	public String getHandlerConfig() {
		return handlerConfig;
	}
	public void setHandlerConfig(String handlerConfig) {
		this.handlerConfig = handlerConfig;
	}
	@Override
	public String toString() {
		return "property: " + getProperty() + " value: " + getPropertyValue();
	}
	@Override
	public GlobalProperty getDescriptor() {
		return this;
	}
	@Override
	public String getValueReference() {
		return getPropertyValue();
	}
	@Override
	public void setValueReferenceInternal(String valueToPersist) {
		setPropertyValue(valueToPersist);
	}
	@Override
	public Object getValue() {
		if (typedValue == null) {
			typedValue = CustomDatatypeUtil.getDatatypeOrDefault(this).fromReferenceString(getValueReference());
		}
		return typedValue;
	}
	@Override
	public <T> void setValue(T typedValue){
		this.typedValue = typedValue;
		dirty = true;
	}
	@Deprecated
	@JsonIgnore
	@Override
	public boolean isDirty() {
		return getDirty();
	}
	public boolean getDirty() {
		return dirty;
	}
	public User getChangedBy() {
		return changedBy;
	}
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	public Date getDateChanged() {
		return dateChanged;
	}
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	public Privilege getViewPrivilege() {
		return viewPrivilege;
	}
	public void setViewPrivilege(Privilege viewPrivilege) {
		this.viewPrivilege = viewPrivilege;
	}
	public Privilege getEditPrivilege() {
		return editPrivilege;
	}
	public void setEditPrivilege(Privilege editPrivilege) {
		this.editPrivilege = editPrivilege;
	}
	public Privilege getDeletePrivilege() {
		return deletePrivilege;
	}
	public void setDeletePrivilege(Privilege deletePrivilege) {
		this.deletePrivilege = deletePrivilege;
	}
}
package org.openmrs;
import org.hibernate.envers.Audited;
@Audited
public class Privilege extends BaseChangeableOpenmrsMetadata {
	public static final long serialVersionUID = 312L;
	private String privilege;
	public Privilege() {
	}
	public Privilege(String privilege) {
		this.privilege = privilege;
	}
	public Privilege(String privilege, String description) {
		this.privilege = privilege;
		setDescription(description);
	}
	public String getPrivilege() {
		return privilege;
	}
	public void setPrivilege(String privilege) {
		this.privilege = privilege;
	}
	@Override
	public String getName() {
		return this.getPrivilege();
	}
	@Override
	public String toString() {
		return this.privilege;
	}
	@Override
	public Integer getId() {
		throw new UnsupportedOperationException();
	}
	@Override
	public void setId(Integer id) {
		throw new UnsupportedOperationException();
	}
}
package org.openmrs.api.context;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.stream.Collectors;
import org.apache.commons.collections.CollectionUtils;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.APIAuthenticationException;
import org.openmrs.api.APIException;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.db.ContextDAO;
import org.openmrs.module.DaemonToken;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleException;
import org.openmrs.module.ModuleFactory;
import org.openmrs.scheduler.Task;
import org.openmrs.scheduler.timer.TimerSchedulerTask;
import org.openmrs.util.OpenmrsSecurityManager;
import org.openmrs.util.OpenmrsThreadPoolHolder;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
public final class Daemon {
	static final String DAEMON_USER_UUID = "A4F30A1B-5EB9-11DF-A648-37A07F9C90FB";
	private static final ThreadLocal<Boolean> isDaemonThread = new ThreadLocal<>();
	private static final ThreadLocal<User> daemonThreadUser = new ThreadLocal<>();
	private Daemon() {
	}
	public static Module startModule(Module module) throws ModuleException {
		return startModule(module, false, null);
	}
	public static Module startModule(final Module module, final boolean isOpenmrsStartup,
	        final AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (callerClass != Daemon.class && callerClass != ModuleFactory.class) {
			throw new APIException("Module.factory.only", new Object[] { callerClass.getName() });
		}
		Future<Module> moduleStartFuture = runInDaemonThreadInternal(() -> ModuleFactory.startModuleInternal(module, isOpenmrsStartup, applicationContext));
		try {
			return moduleStartFuture.get();
		}
		catch (InterruptedException e) {
		} catch (ExecutionException e) {
			if (e.getCause() instanceof ModuleException) {
				throw (ModuleException) e.getCause();
			} else {
				throw new ModuleException("Unable to start module " + module.getName(), e);
			}
		}
		return module;
	}
	public static User createUser(User user, String password, List<String> roleNames) throws Exception {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (!ContextDAO.class.isAssignableFrom(callerClass)) {
			throw new APIException("Context.DAO.only", new Object[] { callerClass.getName() });
		}
		Future<User> userFuture = runInDaemonThreadInternal(() -> {
			if ((user.getId() != null && Context.getUserService().getUser(user.getId()) != null) || Context.getUserService().getUserByUuid(user.getUuid()) != null || Context.getUserService().getUserByUsername(user.getUsername()) != null || (user.getEmail() != null && Context.getUserService().getUserByUsernameOrEmail(user.getEmail()) != null) ) {
				throw new APIException("User.creating.already.exists", new Object[] { user.getDisplayString() });
			}
			if (!CollectionUtils.isEmpty(roleNames)) {
				List<Role> roles = roleNames.stream().map(roleName -> Context.getUserService().getRole(roleName)).collect(Collectors.toList());
				roles.forEach(user::addRole);
			}
			return Context.getUserService().createUser(user, password);
		});
		try {
			return userFuture.get();
		}
		catch (InterruptedException e) {
		}
		catch (ExecutionException e) {
			if (e.getCause() instanceof Exception) {
				throw (Exception) e.getCause();
			} else {
				throw new RuntimeException(e.getCause());
			}
		}
		return null;
	}	
	public static void executeScheduledTask(final Task task) throws Exception {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (!TimerSchedulerTask.class.isAssignableFrom(callerClass)) {
			throw new APIException("Scheduler.timer.task.only", new Object[] { callerClass.getName() });
		}
		Future<?> scheduleTaskFuture = runInDaemonThreadInternal(() -> TimerSchedulerTask.execute(task));
		try {
			scheduleTaskFuture.get();
		}
		catch (InterruptedException e) {
		} catch (ExecutionException e) {
			if (e.getCause() instanceof Exception) {
				throw (Exception) e.getCause();
			} else {
				throw new RuntimeException(e.getCause());
			}
		}
	}
	@Deprecated
	public static Thread runInNewDaemonThread(final Runnable runnable) {
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		final CountDownLatch countDownLatch = new CountDownLatch(1);
		DaemonThread thread = new DaemonThread() {
			@Override
			public void run() {
				isDaemonThread.set(true);
				try {
					Context.openSession();
					countDownLatch.countDown();
					runnable.run();
				}
				finally {
					try {
						Context.closeSession();
					} finally {
						isDaemonThread.remove();
						daemonThreadUser.remove();
					}
				}
			}
		};
		OpenmrsThreadPoolHolder.threadExecutor.execute(thread);
		try {
			countDownLatch.await();
		} catch (InterruptedException ignored) {
		}
		return thread;
	}
	@SuppressWarnings({"squid:S1217", "unused"})
	public static <T> Future<T> runInNewDaemonThread(final Callable<T> callable) {
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		return runInDaemonThreadInternal(callable);
	}
	@SuppressWarnings({"squid:S1217", "unused"})
	public static Future<?> runNewDaemonTask(final Runnable runnable) {
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		return runInDaemonThreadInternal(runnable);
	}
	public static boolean isDaemonThread() {
		Boolean b = isDaemonThread.get();
		if (b == null || !b) {
			Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(1);
			return callerClass.equals(Daemon.class) || callerClass.getName().equals("org.openmrs.web.WebDaemon");
		} else {
			return true;
		}
	}
	public static void runStartupForService(final OpenmrsService service) throws ModuleException {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (callerClass != ServiceContext.class) {
			throw new APIException("Service.context.only", new Object[] { callerClass.getName() });
		}
		Future<?> future = runInDaemonThreadInternal(service::onStartup);
		try {
			future.get();
		}
		catch (InterruptedException e) {
		}
		catch (ExecutionException e) {
			if (e.getCause() instanceof ModuleException) {
				throw (ModuleException) e.getCause();
			} else {
				throw new ModuleException("Unable to run onStartup() method of service {}", service.getClass().getSimpleName(), e);
			}
		}
	}
	@Deprecated
	@SuppressWarnings({"squid:S1217", "unused"})
	public static Thread runInDaemonThread(final Runnable runnable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token " + token);
		}
		DaemonThread thread = new DaemonThread() {
			@Override
			public void run() {
				isDaemonThread.set(true);
				try {
					Context.openSession();
					runnable.run();
				}
				finally {
					try {
						Context.closeSession();
					} finally {
						isDaemonThread.remove();
						daemonThreadUser.remove();
					}
				}
			}
		};
		OpenmrsThreadPoolHolder.threadExecutor.execute(thread);
		return thread;
	}
	@SuppressWarnings({"squid:S1217", "unused"})
	public static <T> Future<T> runInDaemonThread(final Callable<T> callable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token");
		}
		return runInDaemonThreadInternal(callable);
	}
	@SuppressWarnings("squid:S1217")
	public static Future<?> runInDaemonThreadWithoutResult(final Runnable runnable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token");
		}
		return runInDaemonThreadInternal(runnable);
	}
	public static void runInDaemonThreadAndWait(final Runnable runnable, DaemonToken token) {
		Future<?> daemonThread = runInDaemonThreadWithoutResult(runnable, token);
		try {
			daemonThread.get();
		}
		catch (InterruptedException | ExecutionException e) {
		}
	}
	private static <T> Future<T> runInDaemonThreadInternal(Callable<T> callable) {
		return OpenmrsThreadPoolHolder.threadExecutor.submit(() -> {
			isDaemonThread.set(true);
			try {
				Context.openSession();
				return callable.call();
			}
			finally {
				try {
					Context.closeSession();
				} finally {
					isDaemonThread.remove();
					daemonThreadUser.remove();
				}
			}
		});
	}
	private static Future<?> runInDaemonThreadInternal(Runnable runnable) {
		CountDownLatch countDownLatch = getCountDownLatch(runnable instanceof Thread);
		Future<?> result = OpenmrsThreadPoolHolder.threadExecutor.submit(() -> {
			isDaemonThread.set(true);
			try {
				Context.openSession();
				countDownLatch.countDown();
				runnable.run();
			}
			finally {
				try {
					Context.closeSession();
				} finally {
					isDaemonThread.remove();
					daemonThreadUser.remove();
				}
			}
		});
		try {
			countDownLatch.await();
		} catch (InterruptedException ignored) {}
		return result;
	}
	private static CountDownLatch getCountDownLatch(boolean isThread) {
		return isThread ? new CountDownLatch(1) : new CountDownLatch(0);
	}
	protected static class DaemonThread extends Thread {
		protected Object returnedObject = null;
		protected Exception exceptionThrown = null;
		public Exception getExceptionThrown() {
			return exceptionThrown;
		}
	}
	public static boolean isDaemonUser(User user) {
		return DAEMON_USER_UUID.equals(user.getUuid());
	}
	public static User getDaemonThreadUser() {
		if (isDaemonThread()) {
			User user = daemonThreadUser.get();
			if (user == null) {
				user = Context.getContextDAO().getUserByUuid(DAEMON_USER_UUID);
				daemonThreadUser.set(user);
			}
			return user;
		} else {
			return null;
		}
	}
	public static String getDaemonUserUuid() {
		return DAEMON_USER_UUID;
	}
}
package org.openmrs.module.web.filter;
import java.io.Serializable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
public class ModuleFilterDefinition implements Serializable {
	public static final long serialVersionUID = 1;
	private static final Logger log = LoggerFactory.getLogger(ModuleFilterDefinition.class);
	private Module module;
	private String filterName;
	private String filterClass;
	private Map<String, String> initParameters = new HashMap<>();
	public ModuleFilterDefinition(Module module) {
		this.module = module;
	}
	public Module getModule() {
		return module;
	}
	public void setModule(Module module) {
		this.module = module;
	}
	public String getFilterName() {
		return filterName;
	}
	public void setFilterName(String filterName) {
		this.filterName = filterName;
	}
	public String getFilterClass() {
		return filterClass;
	}
	public void setFilterClass(String filterClass) {
		this.filterClass = filterClass;
	}
	public Map<String, String> getInitParameters() {
		return initParameters;
	}
	public void setInitParameters(Map<String, String> initParameters) {
		this.initParameters = initParameters;
	}
	public void addInitParameter(String parameterName, String parameterValue) {
		this.initParameters.put(parameterName, parameterValue);
	}
	public static List<ModuleFilterDefinition> retrieveFilterDefinitions(Module module)  {
		List<ModuleFilterDefinition> filters = new ArrayList<>();
		try {
			Element rootNode = module.getConfig().getDocumentElement();
			NodeList filterNodes = rootNode.getElementsByTagName("filter");
			if (filterNodes.getLength() > 0) {
				for (int i = 0; i < filterNodes.getLength(); i++) {
					ModuleFilterDefinition filter = new ModuleFilterDefinition(module);
					Node node = filterNodes.item(i);
					NodeList configNodes = node.getChildNodes();
					for (int j = 0; j < configNodes.getLength(); j++) {
						Node configNode = configNodes.item(j);
						switch (configNode.getNodeName()) {
							case "filter-name":
								filter.setFilterName(configNode.getTextContent().trim());
								break;
							case "filter-class":
								filter.setFilterClass(configNode.getTextContent().trim());
								break;
							case "init-param":
								NodeList paramNodes = configNode.getChildNodes();
								String paramName = "";
								String paramValue = "";
								for (int k = 0; k < paramNodes.getLength(); k++) {
									Node paramNode = paramNodes.item(k);
									if ("param-name".equals(paramNode.getNodeName())) {
										paramName = paramNode.getTextContent().trim();
									} else if ("param-value".equals(paramNode.getNodeName())) {
										paramValue = paramNode.getTextContent().trim();
									}
								}
								filter.addInitParameter(paramName, paramValue);
								break;
						}
					}
					filters.add(filter);
				}
			}
		}
		catch (Exception e) {
			throw new ModuleException("Unable to parse filters in module configuration.", e);
		}
		log.debug("Retrieved {} filters for {}: {}", filters.size(), module, filters);
		return filters;
	}
}
package org.openmrs.module;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLStreamHandlerFactory;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.CodeSource;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.api.APIException;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class ModuleClassLoader extends URLClassLoader {
	private static final Logger log = LoggerFactory.getLogger(ModuleClassLoader.class);
	private final Module module;
	private Module[] requiredModules;
	private Module[] awareOfModules;
	private Map<URI, File> libraryCache;
	private boolean probeParentLoaderLast = true;
	private Set<String> providedPackages = new LinkedHashSet<>();
	private boolean disposed = false;
	protected ModuleClassLoader(final Module module, final List<URL> urls, final ClassLoader parent,
	    final URLStreamHandlerFactory factory) {
		super(urls.toArray(new URL[urls.size()]), parent, factory);
		if (parent instanceof OpenmrsClassLoader) {
			throw new IllegalArgumentException("Parent must not be OpenmrsClassLoader nor null");
		} else if (parent instanceof ModuleClassLoader) {
			throw new IllegalArgumentException("Parent must not be ModuleClassLoader");
		}
		log.debug("URLs length: {}", urls.size());
		this.module = module;
		requiredModules = collectRequiredModuleImports(module);
		awareOfModules = collectAwareOfModuleImports(module);
		libraryCache = new WeakHashMap<>();
	}
	protected ModuleClassLoader(final Module module, final List<URL> urls, final ClassLoader parent) {
		this(module, urls, parent, null);
		File devDir = ModuleUtil.getDevelopmentDirectory(module.getModuleId());
		if (devDir != null) {
			File[] fileList = devDir.listFiles();
			if (fileList == null) {
				return;
			}
			for (File file : fileList) {
				if (!file.isDirectory()) {
					continue;
				}
				File dir = Paths.get(devDir.getAbsolutePath(), file.getName(), "target", "classes").toFile();
				if (dir.exists()) {
					Collection<File> files = FileUtils.listFiles(dir, new String[] { "class" }, true);
					addClassFilePackages(files, dir.getAbsolutePath().length() + 1);
				}
			}
		} else {
			for (URL url : urls) {
				providedPackages.addAll(ModuleUtil.getPackagesFromFile(OpenmrsUtil.url2file(url)));
			}
		}
	}
	private void addClassFilePackages(Collection<File> files, int dirLength) {
		for (File file : files) {
			String name = file.getAbsolutePath().substring(dirLength);
			Integer indexOfLastSlash = name.lastIndexOf(File.separator);
			if (indexOfLastSlash > 0) {
				String packageName = name.substring(0, indexOfLastSlash);
				packageName = packageName.replace(File.separator, ".");
				providedPackages.add(packageName);
			}
		}
	}
	protected ModuleClassLoader(final Module module, final List<URL> urls) {
		this(module, urls, null);
	}
	public ModuleClassLoader(final Module module, final ClassLoader parent) {
		this(module, getUrls(module), parent);
	}
	public Module getModule() {
		return module;
	}
	public boolean isDisposed() {
		return disposed;
	}
	private static URL getClassBaseUrl(final Class<?> cls) {
		ProtectionDomain pd = cls.getProtectionDomain();
		if (pd != null) {
			CodeSource cs = pd.getCodeSource();
			if (cs != null) {
				return cs.getLocation();
			}
		}
		return null;
	}
	private static List<URL> getUrls(final Module module) {
		List<URL> result = new LinkedList<>();
		List<String> devFolderNames = new ArrayList<>();
		File devDir = ModuleUtil.getDevelopmentDirectory(module.getModuleId());
		try {
			if (devDir != null) {
				File[] fileList = devDir.listFiles();
				if (fileList != null) {
					for (File file : fileList) {
						if (!file.isDirectory()) {
							continue;
						}
						File dir = Paths.get(devDir.getAbsolutePath(), file.getName(), "target", "classes").toFile();
						if (dir.exists()) {
							result.add(dir.toURI().toURL());
							devFolderNames.add(file.getName());
						}
					}
				}
			}
		}
		catch (MalformedURLException ex) {
			log.error("Failed to add development folder to the classpath", ex);
		}
		File tmpModuleDir = getLibCacheFolderForModule(module);
		if (devDir == null) {
			File tmpModuleJar = new File(tmpModuleDir, module.getModuleId() + ".jar");
			if (!tmpModuleJar.exists()) {
				try {
					tmpModuleJar.createNewFile();
				}
				catch (IOException io) {
					log.warn("Unable to create tmpModuleFile", io);
				}
			}
			FileInputStream in = null;
			FileOutputStream out = null;
			try {
				in = new FileInputStream(module.getFile());
				out = new FileOutputStream(tmpModuleJar);
				OpenmrsUtil.copyFile(in, out);
			}
			catch (IOException io) {
				log.warn("Unable to copy tmpModuleFile", io);
			}
			finally {
				try {
					in.close();
				}
				catch (Exception e) { }
				try {
					out.close();
				}
				catch (Exception e) { }
			}
			URL moduleFileURL;
			try {
				moduleFileURL = ModuleUtil.file2url(tmpModuleJar);
				result.add(moduleFileURL);
			}
			catch (MalformedURLException e) {
				log.warn("Unable to add files from module to URL list: " + module.getModuleId(), e);
			}
		}
		try {
			log.debug("Expanding /lib folder in module");
			ModuleUtil.expandJar(module.getFile(), tmpModuleDir, "lib", true);
			File libdir = new File(tmpModuleDir, "lib");
			if (libdir != null && libdir.exists()) {
				Map<String, String> startedRelatedModules = new HashMap<>();
				for (Module requiredModule : collectRequiredModuleImports(module)) {
					startedRelatedModules.put(requiredModule.getModuleId(), requiredModule.getVersion());
				}
				for (Module awareOfModule : collectAwareOfModuleImports(module)) {
					startedRelatedModules.put(awareOfModule.getModuleId(), awareOfModule.getVersion());
				}
				Collection<File> files = FileUtils.listFiles(libdir, new String[] { "jar" }, true);
				for (File file : files) {
					if (devDir != null) {
						boolean jarForDevFolder = false;
						for (String folderName : devFolderNames) {
							if (file.getName().startsWith(module.getModuleId() + "-" + folderName + "-")) {
								jarForDevFolder = true;
								break;
							}
						}
						if (jarForDevFolder) {
							continue;
						}
					}
					URL fileUrl = ModuleUtil.file2url(file);
					boolean include = shouldResourceBeIncluded(module, fileUrl, OpenmrsConstants.OPENMRS_VERSION_SHORT,
					    startedRelatedModules);
					if (include) {
						log.debug("Including file in classpath: {}", fileUrl);
						result.add(fileUrl);
					} else {
						log.debug("Excluding file from classpath: {}", fileUrl);
					}
				}
			}
		}
		catch (MalformedURLException e) {
			log.warn("Error while adding module 'lib' folder to URL result list");
		}
		catch (IOException io) {
			log.warn("Error while expanding lib folder", io);
		}
		return result;
	}
	static boolean shouldResourceBeIncluded(Module module, URL fileUrl, String openmrsVersion,
	        Map<String, String> startedRelatedModules) {
		boolean include = true;
		for (ModuleConditionalResource conditionalResource : module.getConditionalResources()) {
			if (isMatchingConditionalResource(module, fileUrl, conditionalResource)) {
				include = false;
				if (StringUtils.isNotBlank(conditionalResource.getOpenmrsPlatformVersion())) {
					include = ModuleUtil.matchRequiredVersions(openmrsVersion,
					    conditionalResource.getOpenmrsPlatformVersion());
					if (!include) {
						return false;
					}
				}
				if (conditionalResource.getModules() != null) {
					for (ModuleConditionalResource.ModuleAndVersion conditionalModuleResource : conditionalResource
					        .getModules()) {
						if ("!".equals(conditionalModuleResource.getVersion())) {
							include = !ModuleFactory.isModuleStarted(conditionalModuleResource.getModuleId());
							if (!include) {
								return false;
							}
						} else {
							String moduleVersion = startedRelatedModules.get(conditionalModuleResource.getModuleId());
							if (moduleVersion != null) {
								include = ModuleUtil.matchRequiredVersions(moduleVersion,
								    conditionalModuleResource.getVersion());
								if (!include) {
									return false;
								}
							}
						}
					}
				}
			}
		}
		return include;
	}
	static boolean isMatchingConditionalResource(Module module, URL fileUrl, ModuleConditionalResource conditionalResource) {
		FileSystem fileSystem = FileSystems.getDefault();
		if (ModuleUtil.matchRequiredVersions(module.getConfigVersion(), "2.0")) {
			return fileSystem.getPathMatcher(String.format("glob:**/%s", preprocessGlobPattern(conditionalResource.getPath())))
				.matches(Paths.get(fileUrl.getPath()));
		}
		return fileUrl.getPath().matches(".*" + conditionalResource.getPath() + "$");
	}
	private static String preprocessGlobPattern(String globPattern) {
		if (globPattern == null || globPattern.isEmpty()) {
			return "";
		}
		globPattern = globPattern.replace("\\", "/");
		globPattern = globPattern.replaceAll("
		if (globPattern.startsWith("file:/")) {
			globPattern = globPattern.substring(5);
		}
		if (globPattern.matches("^[a-zA-Z]:/.*")) {
			globPattern = globPattern.substring(2);
		}
		if (globPattern.startsWith("/")) {
			globPattern = globPattern.substring(1);
		}
		return globPattern;
	}
	public static File getLibCacheFolderForModule(Module module) {
		File tmpModuleDir = new File(OpenmrsClassLoader.getLibCacheFolder(), module.getModuleId());
		if (!tmpModuleDir.exists()) {
			tmpModuleDir.mkdir();
			tmpModuleDir.deleteOnExit();
		}
		return tmpModuleDir;
	}
	private static List<URL> getUrls(final Module module, final URL[] existingUrls) {
		List<URL> urls = Arrays.asList(existingUrls);
		List<URL> result = new LinkedList<>();
		for (URL url : getUrls(module)) {
			if (!urls.contains(url)) {
				result.add(url);
			}
		}
		return result;
	}
	protected static Module[] collectRequiredModuleImports(Module module) {
		Map<String, Module> publicImportsMap = new WeakHashMap<>();
		for (String moduleId : ModuleConstants.CORE_MODULES.keySet()) {
			Module coreModule = ModuleFactory.getModuleById(moduleId);
			if (coreModule == null && !ModuleUtil.ignoreCoreModules()) {
				log.error("Unable to find an openmrs core loaded module with id: " + moduleId);
				throw new APIException("Module.error.shouldNotBeHere", (Object[]) null);
			}
			if (coreModule != null && !moduleId.equals(module.getModuleId())) {
				publicImportsMap.put(moduleId, coreModule);
			}
		}
		for (String requiredPackage : module.getRequiredModules()) {
			Module requiredModule = ModuleFactory.getModuleByPackage(requiredPackage);
			if (ModuleFactory.isModuleStarted(requiredModule)) {
				publicImportsMap.put(requiredModule.getModuleId(), requiredModule);
			}
		}
		return publicImportsMap.values().toArray(new Module[publicImportsMap.size()]);
	}
	protected static Module[] collectAwareOfModuleImports(Module module) {
		Map<String, Module> publicImportsMap = new WeakHashMap<>();
		for (String awareOfPackage : module.getAwareOfModules()) {
			Module awareOfModule = ModuleFactory.getModuleByPackage(awareOfPackage);
			if (ModuleFactory.isModuleStarted(awareOfModule)) {
				publicImportsMap.put(awareOfModule.getModuleId(), awareOfModule);
			}
		}
		return publicImportsMap.values().toArray(new Module[publicImportsMap.size()]);
	}
	protected void modulesSetChanged() {
		List<URL> newUrls = getUrls(getModule(), getURLs());
		for (URL u : newUrls) {
			addURL(u);
		}
		if (log.isDebugEnabled()) {
			StringBuilder buf = new StringBuilder();
			buf.append("New code URL's populated for module ").append(getModule()).append(":\r\n");
			for (URL u : newUrls) {
				buf.append("\t");
				buf.append(u);
				buf.append("\r\n");
			}
			log.debug(buf.toString());
		}
		requiredModules = collectRequiredModuleImports(getModule());
		awareOfModules = collectAwareOfModuleImports(getModule());
		libraryCache.entrySet().removeIf(uriFileEntry -> uriFileEntry.getValue() == null);
	}
	public void dispose() {
		log.debug("Disposing of ModuleClassLoader: {}", this);
		for (File file : libraryCache.values()) {
			file.delete();
		}
		libraryCache.clear();
		requiredModules = null;
		awareOfModules = null;
		disposed = true;
	}
	public void setProbeParentLoaderLast(final boolean value) {
		probeParentLoaderLast = value;
	}
	@Override
	protected Class<?> loadClass(final String name, final boolean resolve) throws ClassNotFoundException {
		Class<?> result = findLoadedClass(name);
		if (result == null) {
			if (probeParentLoaderLast) {
				try {
					result = loadClass(name, resolve, this, null);
				}
				catch (ClassNotFoundException cnfe) {
				}
				if (result == null && getParent() != null) {
					result = getParent().loadClass(name);
				}
			} else {
				try {
					if (getParent() != null) {
						result = getParent().loadClass(name);
					}
				}
				catch (ClassNotFoundException cnfe) {
				}
				if (result == null) {
					result = loadClass(name, resolve, this, null);
				}
			}
		}
		if (resolve) {
			resolveClass(result);
		}
		return result;
	}
	protected synchronized Class<?> loadClass(final String name, final boolean resolve, final ModuleClassLoader requestor,
	        Set<String> seenModules) throws ClassNotFoundException {
		if (log.isTraceEnabled()) {
			log.trace("Loading " + name + " " + getModule() + ", seenModules: " + seenModules + ", requestor: " + requestor
			        + ", resolve? " + resolve);
			StringBuilder output = new StringBuilder();
			for (StackTraceElement element : Thread.currentThread().getStackTrace()) {
				if (element.getClassName().contains("openmrs")) {
					output.append("+ ");
				}
				output.append(element);
				output.append("\n");
			}
			log.trace("Stacktrace: " + output.toString());
		}
		if ((seenModules != null) && seenModules.contains(getModule().getModuleId())) {
			throw new ClassNotFoundException("Can't load class " + name + " from module " + getModule().getModuleId()
			        + ". It has been tried before.");
		}
		if ((this != requestor) && !ModuleFactory.isModuleStarted(getModule())) {
			String msg = "Can't load class " + name + ", because module " + getModule().getModuleId()
			        + " is not yet started.";
			log.warn(msg);
			throw new ClassNotFoundException(msg);
		}
		Class<?> result = findLoadedClass(name);
		if (result == null) {
			try {
				result = findClass(name);
			}
			catch (ClassNotFoundException e) {
			}
		}
		if (result != null) {
			checkClassVisibility(result, requestor);
			return result;
		}
		if (seenModules == null) {
			seenModules = new HashSet<>();
		}
		seenModules.add(getModule().getModuleId());
		List<Module> importedModules = new ArrayList<>();
		if (requiredModules != null) {
			Collections.addAll(importedModules, requiredModules);
		}
		if (awareOfModules != null) {
			Collections.addAll(importedModules, awareOfModules);
		}
		for (Module importedModule : importedModules) {
			if (seenModules.contains(importedModule.getModuleId())) {
				continue;
			}
			ModuleClassLoader moduleClassLoader = ModuleFactory.getModuleClassLoader(importedModule);
			if (moduleClassLoader != null) {
				try {
					result = moduleClassLoader.loadClass(name, resolve, requestor, seenModules);
					return result;
				}
				catch (ClassNotFoundException e) {
				}
			}
		}
		throw new ClassNotFoundException(name);
	}
	protected void checkClassVisibility(final Class<?> cls, final ModuleClassLoader requestor)
	        throws ClassNotFoundException {
		if (this == requestor) {
			return;
		}
		URL lib = getClassBaseUrl(cls);
		if (lib == null) {
			return;
		}
		ClassLoader loader = cls.getClassLoader();
		if (!(loader instanceof ModuleClassLoader)) {
			return;
		}
		if (loader != this) {
			((ModuleClassLoader) loader).checkClassVisibility(cls, requestor);
		}
	}
	@Override
	protected String findLibrary(final String name) {
		if ((name == null) || "".equals(name.trim())) {
			return null;
		}
		if (log.isTraceEnabled()) {
			log.trace("findLibrary(String): name=" + name + ", this=" + this);
		}
		String libname = System.mapLibraryName(name);
		String result = null;
		if (log.isTraceEnabled()) {
			log.trace(
			    "findLibrary(String): name=" + name + ", libname=" + libname + ", result=" + result + ", this=" + this);
		}
		return result;
	}
	protected File cacheLibrary(final URL libUrl, final String libname) {
		File cacheFolder = OpenmrsClassLoader.getLibCacheFolder();
		URI libUri;
		try {
			libUri = libUrl.toURI();
		}
		catch (URISyntaxException e) {
			throw new IllegalArgumentException(libUrl.getPath() + " is not a valid URI", e);
		}
		if (libraryCache.containsKey(libUri)) {
			return libraryCache.get(libUri);
		}
		File result;
		try {
			if (cacheFolder == null) {
				throw new IOException("can't initialize libraries cache folder");
			}
			File libCacheModuleFolder = new File(cacheFolder, getModule().getModuleId());
			if (!libCacheModuleFolder.exists() && !libCacheModuleFolder.mkdirs()) {
				throw new IOException("can't create cache folder " + libCacheModuleFolder);
			}
			result = new File(libCacheModuleFolder, libname);
			InputStream in = OpenmrsUtil.getResourceInputStream(libUrl);
			try {
				FileOutputStream fileOut = new FileOutputStream(result);
				OutputStream out = new BufferedOutputStream(fileOut);
				try {
					OpenmrsUtil.copyFile(in, out);
				}
				finally {
					try {
						out.close();
					}
					catch (Exception e) { }
					try {
						fileOut.close();
					}
					catch (Exception e) {}
				}
			}
			finally {
				try {
					in.close();
				}
				catch (Exception e) { }
			}
			libraryCache.put(libUri, result);
			log.debug("library {} successfully cached from URL {} and saved to local file {}", libname, libUrl, result);
		}
		catch (IOException ioe) {
			log.error("can't cache library " + libname + " from URL " + libUrl, ioe);
			libraryCache.put(libUri, null);
			result = null;
		}
		return result;
	}
	@Override
	public URL findResource(final String name) {
		URL result = findResource(name, this, null);
		return expandIfNecessary(result);
	}
	@Override
	public Enumeration<URL> findResources(final String name) throws IOException {
		List<URL> result = new LinkedList<>();
		findResources(result, name, this, null);
		for (URL url : result) {
			url = expandIfNecessary(url);
		}
		return Collections.enumeration(result);
	}
	protected URL findResource(final String name, final ModuleClassLoader requestor, Set<String> seenModules) {
		if (log.isTraceEnabled() && name != null && name.contains("starter")) {
			if (seenModules != null) {
				log.trace("seenModules.size: " + seenModules.size());
			}
			log.trace("name: " + name);
			for (URL url : getURLs()) {
				log.trace("url: " + url);
			}
		}
		if ((seenModules != null) && seenModules.contains(getModule().getModuleId())) {
			return null;
		}
		URL result = super.findResource(name);
		if (result != null) {
			if (isResourceVisible(name, result, requestor)) {
				return result;
			}
			log.debug("Resource is not visible");
			return null;
		}
		if (seenModules == null) {
			seenModules = new HashSet<>();
		}
		seenModules.add(getModule().getModuleId());
		if (requiredModules != null) {
			for (Module publicImport : requiredModules) {
				if (seenModules.contains(publicImport.getModuleId())) {
					continue;
				}
				ModuleClassLoader mcl = ModuleFactory.getModuleClassLoader(publicImport);
				if (mcl != null) {
					result = mcl.findResource(name, requestor, seenModules);
				}
				if (result != null) {
					return result;
				}
			}
		}
		for (Module publicImport : awareOfModules) {
			if (seenModules.contains(publicImport.getModuleId())) {
				continue;
			}
			ModuleClassLoader mcl = ModuleFactory.getModuleClassLoader(publicImport);
			if (mcl != null) {
				result = mcl.findResource(name, requestor, seenModules);
			}
			if (result != null) {
				return result;
			}
		}
		return result;
	}
	protected void findResources(final List<URL> result, final String name, final ModuleClassLoader requestor,
	        Set<String> seenModules) throws IOException {
		if ((seenModules != null) && seenModules.contains(getModule().getModuleId())) {
			return;
		}
		for (Enumeration<URL> enm = super.findResources(name); enm.hasMoreElements();) {
			URL url = enm.nextElement();
			if (isResourceVisible(name, url, requestor)) {
				result.add(url);
			}
		}
		if (seenModules == null) {
			seenModules = new HashSet<>();
		}
		seenModules.add(getModule().getModuleId());
		if (requiredModules != null) {
			for (Module publicImport : requiredModules) {
				if (seenModules.contains(publicImport.getModuleId())) {
					continue;
				}
				ModuleClassLoader mcl = ModuleFactory.getModuleClassLoader(publicImport);
				if (mcl != null) {
					mcl.findResources(result, name, requestor, seenModules);
				}
			}
		}
		for (Module publicImport : awareOfModules) {
			if (seenModules.contains(publicImport.getModuleId())) {
				continue;
			}
			ModuleClassLoader mcl = ModuleFactory.getModuleClassLoader(publicImport);
			if (mcl != null) {
				mcl.findResources(result, name, requestor, seenModules);
			}
		}
	}
	protected boolean isResourceVisible(final String name, final URL url, final ModuleClassLoader requestor) {
		if (this == requestor) {
			return true;
		}
		try {
			String file = url.getFile();
			new URL(url.getProtocol(), url.getHost(), file.substring(0, file.length() - name.length()));
		}
		catch (MalformedURLException mue) {
			log.error("can't get resource library URL", mue);
			return false;
		}
		return true;
	}
	private URL expandIfNecessary(URL result) {
		if (result == null || !"jar".equals(result.getProtocol())) {
			return result;
		}
		File tmpFolder = getLibCacheFolderForModule(module);
		return OpenmrsClassLoader.expandURL(result, tmpFolder);
	}
	public Set<String> getProvidedPackages() {
		return providedPackages;
	}
	@Override
	public String toString() {
		return "{ModuleClassLoader: uid=" + System.identityHashCode(this) + "; " + module + "}";
	}
}
package org.openmrs.api.impl;
import java.io.UnsupportedEncodingException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.ConceptSource;
import org.openmrs.GlobalProperty;
import org.openmrs.ImplementationId;
import org.openmrs.OpenmrsData;
import org.openmrs.OpenmrsMetadata;
import org.openmrs.OpenmrsObject;
import org.openmrs.Privilege;
import org.openmrs.User;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.EventListeners;
import org.openmrs.api.GlobalPropertyListener;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.AdministrationDAO;
import org.openmrs.customdatatype.CustomDatatype;
import org.openmrs.customdatatype.CustomDatatypeUtil;
import org.openmrs.customdatatype.CustomValueDescriptor;
import org.openmrs.customdatatype.Customizable;
import org.openmrs.customdatatype.SingleCustomValue;
import org.openmrs.layout.LayoutSupport;
import org.openmrs.layout.LayoutTemplate;
import org.openmrs.messagesource.PresentationMessage;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.ModuleUtil;
import org.openmrs.obs.ComplexData;
import org.openmrs.person.PersonMergeLogData;
import org.openmrs.util.HttpClient;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.Errors;
@Transactional
public class AdministrationServiceImpl extends BaseOpenmrsService implements AdministrationService, GlobalPropertyListener {
	private static final Logger log = LoggerFactory.getLogger(AdministrationServiceImpl.class);
	protected AdministrationDAO dao;
	private EventListeners eventListeners;
	private GlobalLocaleList globalLocaleList;
	private HttpClient implementationIdHttpClient;
	public AdministrationServiceImpl() {
	}
	@Override
	public void setAdministrationDAO(AdministrationDAO dao) {
		this.dao = dao;
	}
	public void setEventListeners(EventListeners eventListeners) {
		this.eventListeners = eventListeners;
	}
	protected SortedMap<String, String> systemVariables = null;
	private Set<Locale> presentationLocales;
	@Override
	@Transactional(readOnly = true)
	public SortedMap<String, String> getSystemVariables() throws APIException {
		if (systemVariables == null) {
			systemVariables = new TreeMap<>();
			try {
				systemVariables.put("OPENMRS_HOSTNAME", InetAddress.getLocalHost().getCanonicalHostName());
			}
			catch (UnknownHostException e) {
				systemVariables.put("OPENMRS_HOSTNAME", "Unknown host: " + e.getMessage());
			}
			systemVariables.put("OPENMRS_VERSION", String.valueOf(OpenmrsConstants.OPENMRS_VERSION));
			systemVariables.put("DATABASE_NAME", OpenmrsConstants.DATABASE_NAME);
			systemVariables.put("DATABASE_BUSINESS_NAME", OpenmrsConstants.DATABASE_BUSINESS_NAME);
			systemVariables.put("OBSCURE_PATIENTS", String.valueOf(OpenmrsConstants.OBSCURE_PATIENTS));
			systemVariables.put("OBSCURE_PATIENTS_FAMILY_NAME", OpenmrsConstants.OBSCURE_PATIENTS_FAMILY_NAME);
			systemVariables.put("OBSCURE_PATIENTS_GIVEN_NAME", OpenmrsConstants.OBSCURE_PATIENTS_GIVEN_NAME);
			systemVariables.put("OBSCURE_PATIENTS_MIDDLE_NAME", OpenmrsConstants.OBSCURE_PATIENTS_MIDDLE_NAME);
			systemVariables.put("MODULE_REPOSITORY_PATH", ModuleUtil.getModuleRepository().getAbsolutePath());
			systemVariables.put("OPERATING_SYSTEM_KEY", String.valueOf(OpenmrsConstants.OPERATING_SYSTEM_KEY));
			systemVariables.put("OPERATING_SYSTEM", String.valueOf(OpenmrsConstants.OPERATING_SYSTEM));
		}
		return systemVariables;
	}
	@Override
	@Transactional(readOnly = true)
	public String getGlobalProperty(String propertyName) throws APIException {
		if (propertyName == null) {
			return null;
		}
		GlobalProperty gp = dao.getGlobalPropertyObject(propertyName);
		if (gp != null) {
			if (canViewGlobalProperty(gp)) {
				return gp.getPropertyValue();
			} else {
				throw new APIException("GlobalProperty.error.privilege.required.view", new Object[] {
					gp.getViewPrivilege().getPrivilege(), propertyName });
			}
		} else {
			return null;
		}
	}
	private boolean canViewGlobalProperty(GlobalProperty property) {
		if (property.getViewPrivilege() == null) {
			return true;
		}
		return Context.getAuthenticatedUser().hasPrivilege(property.getViewPrivilege().getPrivilege());
	}
	private boolean canDeleteGlobalProperty(GlobalProperty property) {
		if (property.getDeletePrivilege() == null) {
			return true;
		}
		return Context.getAuthenticatedUser().hasPrivilege(property.getDeletePrivilege().getPrivilege());
	}
	private boolean canEditGlobalProperty(GlobalProperty property) {
		if (property.getEditPrivilege() == null) {
			return true;
		}
		return Context.getAuthenticatedUser().hasPrivilege(property.getEditPrivilege().getPrivilege());
	}
	private List<GlobalProperty> filterGlobalPropertiesByViewPrivilege(List<GlobalProperty> properties) {
		if (properties != null) {
			for (Iterator<GlobalProperty> iterator = properties.iterator(); iterator.hasNext();) {
				GlobalProperty property = iterator.next();
				Privilege vp = property.getViewPrivilege();
				if (vp != null && !Context.getAuthenticatedUser().hasPrivilege(vp.getPrivilege())) {
					iterator.remove();
				}
			}
		}
		return properties;
	}
	@Override
	@Transactional(readOnly = true)
	public String getGlobalProperty(String propertyName, String defaultValue) throws APIException {
		String s = Context.getAdministrationService().getGlobalProperty(propertyName);
		if (s == null) {
			return defaultValue;
		}
		return s;
	}
	@Override
	@Transactional(readOnly = true)
	public GlobalProperty getGlobalPropertyObject(String propertyName) {
		GlobalProperty gp = dao.getGlobalPropertyObject(propertyName);
		if (gp != null) {
			if (canViewGlobalProperty(gp)) {
				return gp;
			} else {
				throw new APIException("GlobalProperty.error.privilege.required.view", new Object[] {
					gp.getViewPrivilege().getPrivilege(), propertyName });
			}
		} else {
			return null;
		}
	}
	@Override
	public void setGlobalProperty(String propertyName, String propertyValue) throws APIException {
		GlobalProperty gp = Context.getAdministrationService().getGlobalPropertyObject(propertyName);
		if (gp == null) {
			gp = new GlobalProperty();
			gp.setProperty(propertyName);
		}
		gp.setPropertyValue(propertyValue);
		Context.getAdministrationService().saveGlobalProperty(gp);
	}
	@Override
	public void updateGlobalProperty(String propertyName, String propertyValue) throws IllegalStateException {
		GlobalProperty gp = Context.getAdministrationService().getGlobalPropertyObject(propertyName);
		if (gp == null) {
			throw new IllegalStateException("Global property with the given propertyName does not exist" + propertyName);
		}
		if (!canEditGlobalProperty(gp)) {
			throw new APIException("GlobalProperty.error.privilege.required.edit", new Object[] {
				gp.getEditPrivilege().getPrivilege(), propertyName });
		}
		gp.setPropertyValue(propertyValue);
		dao.saveGlobalProperty(gp);
	}
	@Override
	@Transactional(readOnly = true)
	public List<GlobalProperty> getAllGlobalProperties() throws APIException {
		return filterGlobalPropertiesByViewPrivilege(dao.getAllGlobalProperties());
	}
	@Override
	@Transactional(readOnly = true)
	public List<GlobalProperty> getGlobalPropertiesByPrefix(String prefix) {
		return filterGlobalPropertiesByViewPrivilege(dao.getGlobalPropertiesByPrefix(prefix));
	}
	@Override
	@Transactional(readOnly = true)
	public List<GlobalProperty> getGlobalPropertiesBySuffix(String suffix) {
		return filterGlobalPropertiesByViewPrivilege(dao.getGlobalPropertiesBySuffix(suffix));
	}
	@Override
	public void purgeGlobalProperty(GlobalProperty globalProperty) throws APIException {
		if (!canDeleteGlobalProperty(globalProperty)) {
			throw new APIException("GlobalProperty.error.privilege.required.purge", new Object[] {
				globalProperty.getDeletePrivilege().getPrivilege(), globalProperty.getProperty() });
		}
		notifyGlobalPropertyDelete(globalProperty.getProperty());
		dao.deleteGlobalProperty(globalProperty);
	}
	@Override
	@CacheEvict(value = "userSearchLocales", allEntries = true)
	public List<GlobalProperty> saveGlobalProperties(List<GlobalProperty> props) throws APIException {
		log.debug("saving a list of global properties");
		for (GlobalProperty prop : props) {
			if (prop.getProperty() != null && prop.getProperty().length() > 0) {
				Context.getAdministrationService().saveGlobalProperty(prop);
			}
		}
		return props;
	}
	@Override
	@CacheEvict(value = "userSearchLocales", allEntries = true)
	public GlobalProperty saveGlobalProperty(GlobalProperty gp) throws APIException {
		if (!canEditGlobalProperty(gp)) {
			throw new APIException("GlobalProperty.error.privilege.required.edit", new Object[] {
				gp.getEditPrivilege().getPrivilege(), gp.getProperty() });
		}
		if (gp.getProperty() != null && gp.getProperty().length() > 0) {
			if (gp.getProperty().equals(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST)) {
				if (gp.getPropertyValue() != null) {
					List<Locale> localeList = new ArrayList<>();
					for (String localeString : gp.getPropertyValue().split(",")) {
						localeList.add(LocaleUtility.fromSpecification(localeString.trim()));
					}
					if (!localeList.contains(LocaleUtility.getDefaultLocale())) {
						gp.setPropertyValue(StringUtils.join(getAllowedLocales(), ", "));
						throw new APIException(Context.getMessageSourceService().getMessage(
						    "general.locale.localeListNotIncludingDefaultLocale",
						    new Object[] { LocaleUtility.getDefaultLocale() }, null));
					}
				}
			} else if (gp.getProperty().equals(OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE)
						&& gp.getPropertyValue() != null) {
					List<Locale> localeList = getAllowedLocales();
					if (!localeList.contains(LocaleUtility.fromSpecification(gp.getPropertyValue().trim()))) {
						String value = gp.getPropertyValue();
						gp.setPropertyValue(LocaleUtility.getDefaultLocale().toString());
						throw new APIException((Context.getMessageSourceService().getMessage(
						    "general.locale.defaultNotInAllowedLocalesList", new Object[] { value }, null)));
					}
			}
			CustomDatatypeUtil.saveIfDirty(gp);
			dao.saveGlobalProperty(gp);
			notifyGlobalPropertyChange(gp);
			return gp;
		}
		return gp;
	}
	@Override
	public List<List<Object>> executeSQL(String sql, boolean selectOnly) throws APIException {
		if (sql == null || "".equals(sql.trim())) {
			return null;
		}
		return dao.executeSQL(sql, selectOnly);
	}
	@Override
	public void addGlobalPropertyListener(GlobalPropertyListener listener) {
		eventListeners.getGlobalPropertyListeners().add(listener);
	}
	@Override
	public void removeGlobalPropertyListener(GlobalPropertyListener listener) {
		eventListeners.getGlobalPropertyListeners().remove(listener);
	}
	private void notifyGlobalPropertyChange(GlobalProperty gp) {
		for (GlobalPropertyListener listener : eventListeners.getGlobalPropertyListeners()) {
			if (listener.supportsPropertyName(gp.getProperty())) {
				listener.globalPropertyChanged(gp);
			}
		}
	}
	private void notifyGlobalPropertyDelete(String propertyName) {
		for (GlobalPropertyListener listener : eventListeners.getGlobalPropertyListeners()) {
			if (listener.supportsPropertyName(propertyName)) {
				listener.globalPropertyDeleted(propertyName);
			}
		}
	}
	@Override
	@Transactional(readOnly = true)
	public ImplementationId getImplementationId() throws APIException {
		String property = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_IMPLEMENTATION_ID);
		if (property == null) {
			return null;
		}
		try {
			return Context.getSerializationService().getDefaultSerializer().deserialize(property, ImplementationId.class);
		}
		catch (Exception e) {
			log.debug("Error while getting implementation id", e);
		}
		return null;
	}
	@Override
	public void setImplementationId(ImplementationId implementationId) throws APIException {
		if (implementationId == null) {
			return;
		}
		String description = implementationId.getDescription();
		try {
			description = checkImplementationIdValidity(implementationId.getImplementationId(), description,
			    implementationId.getPassphrase());
			implementationId.setDescription(description);
			boolean foundMatchingSource = false;
			List<ConceptSource> sources = Context.getConceptService().getAllConceptSources(false);
			if (sources != null) {
				for (ConceptSource source : sources) {
					if (implementationId.getImplementationId().equals(source.getHl7Code())) {
						foundMatchingSource = true;
					}
				}
			}
			if (!foundMatchingSource) {
				ConceptSource newConceptSource = new ConceptSource();
				newConceptSource.setName(implementationId.getName());
				newConceptSource.setDescription(implementationId.getDescription());
				newConceptSource.setHl7Code(implementationId.getImplementationId());
				if (Context.getAuthenticatedUser() == null) {
					newConceptSource.setCreator(new User(1)); 
				}
				Context.getConceptService().saveConceptSource(newConceptSource);
			}
			String value = Context.getSerializationService().getDefaultSerializer().serialize(implementationId);
			Context.getAdministrationService().saveGlobalProperty(
			    new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_IMPLEMENTATION_ID, value));
		}
		catch (APIException e) {
			throw e;
		}
		catch (Exception e) {
			throw new APIException(e);
		}
		finally {
		}
	}
	private String checkImplementationIdValidity(String implementationId, String description, String passphrase)
	        throws APIException {
		if (StringUtils.isEmpty(implementationId)) {
			throw new APIException("cannot.be.empty", new Object[] { "implementationid" });
		}
		if (StringUtils.isEmpty(description)) {
			throw new APIException("cannot.be.empty", new Object[] { "description" });
		}
		if (StringUtils.isEmpty(passphrase)) {
			throw new APIException("cannot.be.empty", new Object[] { "passphrase" });
		}
		Map<String, String> data = new HashMap<>();
		data.put("implementationId", implementationId);
		data.put("description", description);
		data.put("passphrase", passphrase);
		String response = implementationIdHttpClient.post(data);
		response = response.trim();
		if ("".equals(response)) {
			String ms = Context.getMessageSourceService().getMessage("ImplementationId.connectionError",
			    new String[] { implementationId }, Context.getLocale());
			throw new APIException(ms);
		}
		log.debug("Response: {}", response);
		if (response.startsWith("Success")) {
			response = response.replace("Success", "");
			return response.trim();
		}
		String ms = Context.getMessageSourceService().getMessage("ImplementationId.invalidIdorPassphrase",
		    new String[] { description }, Context.getLocale());
		throw new APIException(ms);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Locale> getAllowedLocales() {
		if (globalLocaleList == null) {
			globalLocaleList = new GlobalLocaleList();
			Context.getAdministrationService().addGlobalPropertyListener(globalLocaleList);
		}
		Set<Locale> allowedLocales = globalLocaleList.getAllowedLocales();
		if (allowedLocales == null) {
			String currentPropertyValue = Context.getAdministrationService().getGlobalProperty(
			    OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, LocaleUtility.getDefaultLocale().toString());
			GlobalProperty allowedLocalesProperty = new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST,
			        currentPropertyValue);
			globalLocaleList.globalPropertyChanged(allowedLocalesProperty);
			allowedLocales = globalLocaleList.getAllowedLocales();
		}
		return new ArrayList<>(allowedLocales);
	}
	public void setGlobalLocaleList(GlobalLocaleList gll) {
		globalLocaleList = gll;
	}
	@Override
	@Transactional(readOnly = true)
	public Set<Locale> getPresentationLocales() {
		if (presentationLocales == null) {
			presentationLocales = new LinkedHashSet<>();
			Collection<Locale> messageLocales = Context.getMessageSourceService().getLocales();
			List<Locale> allowedLocales = getAllowedLocales();
			for (Locale locale : allowedLocales) {
				if (StringUtils.isEmpty(locale.getCountry())) {
					List<Locale> localsWithSameLanguage = new ArrayList<>();
					for (Locale possibleLocale : messageLocales) {
						if (locale.getLanguage().equals(possibleLocale.getLanguage())
						        && !StringUtils.isEmpty(possibleLocale.getCountry())) {
							localsWithSameLanguage.add(possibleLocale);
						}
					}
					if (!localsWithSameLanguage.isEmpty()) {
						presentationLocales.addAll(localsWithSameLanguage);
					} else {
						if (messageLocales.contains(locale)) {
							presentationLocales.add(locale);
						}
					}
				} else {
					if (messageLocales.contains(locale)) {
						presentationLocales.add(locale);
					} else {
						for (Locale possibleLocale : messageLocales) {
							if (locale.getLanguage().equals(possibleLocale.getLanguage())
							        && StringUtils.isEmpty(possibleLocale.getCountry())) {
								presentationLocales.add(possibleLocale);
							}
						}
					}
				}
			}
		}
		return presentationLocales;
	}
	@Override
	public void globalPropertyChanged(GlobalProperty newValue) {
		if (newValue.getProperty().equals(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST)) {
			presentationLocales = null;
		}
	}
	@Override
	public void globalPropertyDeleted(String propertyName) {
	}
	@Override
	public boolean supportsPropertyName(String propertyName) {
		return propertyName.equals(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST);
	}
	@Override
	@Transactional(readOnly = true)
	public GlobalProperty getGlobalPropertyByUuid(String uuid) {
		GlobalProperty gp =  dao.getGlobalPropertyByUuid(uuid);
		if (gp == null) {
			return null;
		} else if (canViewGlobalProperty(gp)) {
			return gp;
		} else {
			throw new APIException("GlobalProperty.error.privilege.required.view", new Object[] {
				gp.getViewPrivilege().getPrivilege(), gp.getProperty() });
		}
	}
	@Override
	@SuppressWarnings("unchecked")
	public <T> T getGlobalPropertyValue(String propertyName, T defaultValue) throws APIException {
		if (defaultValue == null) {
			throw new IllegalArgumentException("The defaultValue argument cannot be null");
		}
		String propVal = Context.getAdministrationService().getGlobalProperty(propertyName);
		if (StringUtils.isEmpty(propVal)) {
			return defaultValue;
		}
		try {
			return (T) defaultValue.getClass().getDeclaredConstructor(String.class).newInstance(propVal);
		}
		catch (InstantiationException e) {
			throw new APIException("is.not.able.instantiated", new Object[] { defaultValue.getClass().getName(), propVal },
			        e);
		}
		catch (NoSuchMethodException e) {
			throw new APIException("does.not.have.string.constructor", new Object[] { defaultValue.getClass().getName() }, e);
		}
		catch (Exception e) {
			log.error("Unable to turn value '" + propVal + "' into type " + defaultValue.getClass().getName(), e);
			return defaultValue;
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Map<String, Map<String, String>> getSystemInformation() throws APIException {
		Map<String, Map<String, String>> systemInfoMap = new LinkedHashMap<>();
		systemInfoMap.put("SystemInfo.title.openmrsInformation", new LinkedHashMap<String, String>() {
			private static final long serialVersionUID = 1L;
			{
				put("SystemInfo.OpenMRSInstallation.systemDate", new SimpleDateFormat("yyyy-MM-dd").format(Calendar
				        .getInstance().getTime()));
				put("SystemInfo.OpenMRSInstallation.systemTime", new SimpleDateFormat("HH:mm:ss").format(Calendar
				        .getInstance().getTime()));
				put("SystemInfo.OpenMRSInstallation.openmrsVersion", OpenmrsConstants.OPENMRS_VERSION);
				try {
					put("SystemInfo.hostname", InetAddress.getLocalHost().getCanonicalHostName());
				}
				catch (UnknownHostException e) {
					put("SystemInfo.hostname", "Unknown host: " + e.getMessage());
				}
			}
		});
		systemInfoMap.put("SystemInfo.title.javaRuntimeEnvironmentInformation", new LinkedHashMap<String, String>() {
			Properties properties = System.getProperties();
			private static final long serialVersionUID = 1L;
			{
				put("SystemInfo.JavaRuntimeEnv.operatingSystem", properties.getProperty("os.name"));
				put("SystemInfo.JavaRuntimeEnv.operatingSystemArch", properties.getProperty("os.arch"));
				put("SystemInfo.JavaRuntimeEnv.operatingSystemVersion", properties.getProperty("os.version"));
				put("SystemInfo.JavaRuntimeEnv.javaVersion", properties.getProperty("java.version"));
				put("SystemInfo.JavaRuntimeEnv.javaVendor", properties.getProperty("java.vendor"));
				put("SystemInfo.JavaRuntimeEnv.jvmVersion", properties.getProperty("java.vm.version"));
				put("SystemInfo.JavaRuntimeEnv.jvmVendor", properties.getProperty("java.vm.vendor"));
				put("SystemInfo.JavaRuntimeEnv.javaRuntimeName", properties.getProperty("java.runtime.name"));
				put("SystemInfo.JavaRuntimeEnv.javaRuntimeVersion", properties.getProperty("java.runtime.version"));
				put("SystemInfo.JavaRuntimeEnv.userName", properties.getProperty("user.name"));
				put("SystemInfo.JavaRuntimeEnv.systemLanguage", properties.getProperty("user.language"));
				put("SystemInfo.JavaRuntimeEnv.systemTimezone", properties.getProperty("user.timezone"));
				put("SystemInfo.JavaRuntimeEnv.fileSystemEncoding", properties.getProperty("sun.jnu.encoding"));
				put("SystemInfo.JavaRuntimeEnv.userDirectory", properties.getProperty("user.dir"));
				put("SystemInfo.JavaRuntimeEnv.tempDirectory", properties.getProperty("java.io.tmpdir"));
			}
		});
		systemInfoMap.put("SystemInfo.title.memoryInformation", new LinkedHashMap<String, String>() {
			private static final long serialVersionUID = 1L;
			Runtime runtime = Runtime.getRuntime();
			{
				put("SystemInfo.Memory.totalMemory", convertToMegaBytes(runtime.totalMemory()));
				put("SystemInfo.Memory.freeMemory", convertToMegaBytes(runtime.freeMemory()));
				put("SystemInfo.Memory.maximumHeapSize", convertToMegaBytes(runtime.maxMemory()));
			}
		});
		systemInfoMap.put("SystemInfo.title.dataBaseInformation", new LinkedHashMap<String, String>() {
			Properties properties = Context.getRuntimeProperties();
			private static final long serialVersionUID = 1L;
			{
				put("SystemInfo.Database.name", OpenmrsConstants.DATABASE_NAME);
				put("SystemInfo.Database.connectionURL", properties.getProperty("connection.url"));
				put("SystemInfo.Database.userName", properties.getProperty("connection.username"));
				put("SystemInfo.Database.driver", properties.getProperty("hibernate.connection.driver_class"));
				put("SystemInfo.Database.dialect", properties.getProperty("hibernate.dialect"));
			}
		});
		systemInfoMap.put("SystemInfo.title.moduleInformation", new LinkedHashMap<String, String>() {
			private static final long serialVersionUID = 1L;
			{
				put("SystemInfo.Module.repositoryPath", ModuleUtil.getModuleRepository().getAbsolutePath());
				Collection<Module> loadedModules = ModuleFactory.getLoadedModules();
				for (Module module : loadedModules) {
					String moduleInfo = module.getVersion() + " "
					        + (module.isStarted() ? "" : Context.getMessageSourceService().getMessage("Module.notStarted"));
					put(module.getName(), moduleInfo);
				}
			}
		});
		return systemInfoMap;
	}
	private String convertToMegaBytes(long bytes) {
		final int ONE_KILO_BYTE = 1024;
		return String.valueOf(bytes / ONE_KILO_BYTE / ONE_KILO_BYTE) + " MB";
	}
	@Override
	public void purgeGlobalProperties(List<GlobalProperty> globalProperties) throws APIException {
		for (GlobalProperty globalProperty : globalProperties) {
			Context.getAdministrationService().purgeGlobalProperty(globalProperty);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public int getMaximumPropertyLength(Class<? extends OpenmrsObject> aClass, String fieldName) {
		return dao.getMaximumPropertyLength(aClass, fieldName);
	}
	@Override
	@Transactional(readOnly = true)
	public void validate(Object object, Errors errors) throws APIException {
		if (object == null) {
			throw new APIException("error.null", (Object[]) null);
		}
		dao.validate(object, errors);
	}
	@Override
	@Cacheable(value = "userSearchLocales")
	public List<Locale> getSearchLocales(Locale currentLocale, User user) throws APIException {
		Set<Locale> locales = new LinkedHashSet<>();
		locales.add(currentLocale); 
		locales.add(new Locale(currentLocale.getLanguage()));
		if (user != null) {
			List<Locale> proficientLocales = user.getProficientLocales();
			if (proficientLocales != null) {
				locales.addAll(proficientLocales);
			}
		}
		List<Locale> allowedLocales = Context.getAdministrationService().getAllowedLocales();
		if (allowedLocales != null) {
			Set<Locale> retainLocales = new HashSet<>();
			for (Locale allowedLocale : allowedLocales) {
				retainLocales.add(allowedLocale);
				retainLocales.add(new Locale(allowedLocale.getLanguage()));
			}
			locales.retainAll(retainLocales);
		}
		return new ArrayList<>(locales);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Locale> getSearchLocales(){
		return Context.getAdministrationService().getSearchLocales(Context.getLocale(), Context.getAuthenticatedUser());
	}
	@Override
	public void setImplementationIdHttpClient(HttpClient implementationIdHttpClient) {
		this.implementationIdHttpClient = implementationIdHttpClient;
	}
	@Override
	public boolean isDatabaseStringComparisonCaseSensitive() {
		return dao.isDatabaseStringComparisonCaseSensitive();
	}
	@Override
	public void updatePostgresSequence() {
		dao.updatePostgresSequence();
	}
	@Override
	public List<String> getSerializerWhitelistTypes() {
		List<String> whitelistTypes = new ArrayList<>();
		List<Class<?>> hierarchyTypes = getSerializerDefaultWhitelistHierarchyTypes();
		for (Class<?> hierarchyType: hierarchyTypes) {
			whitelistTypes.add(GP_SERIALIZER_WHITELIST_HIERARCHY_TYPES_PREFIX + hierarchyType.getName());
		}
		List<GlobalProperty> gpTypes = getGlobalPropertiesBySuffix(
			AdministrationService.GP_SUFFIX_SERIALIZER_WHITELIST_TYPES);
		for (GlobalProperty gpType: gpTypes) {
			String[] types = gpType.getPropertyValue().split(",");
			for (String type: types) {
				if(!StringUtils.isBlank(type)) {
					whitelistTypes.add(type.trim());
				}
			}
		}
		return whitelistTypes;
	}
	public static List<Class<?>> getSerializerDefaultWhitelistHierarchyTypes() {
		List<Class<?>> types = Arrays.asList(OpenmrsObject.class, OpenmrsMetadata.class, OpenmrsData.class, 
			CustomDatatype.class, SingleCustomValue.class, CustomValueDescriptor.class, Customizable.class,
			LayoutTemplate.class, LayoutSupport.class, ComplexData.class, PresentationMessage.class,
			PersonMergeLogData.class);
		return types;
	}
}
package org.openmrs.api.db.hibernate;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import org.hibernate.HibernateException;
import org.hibernate.Interceptor;
import org.hibernate.boot.Metadata;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.integrator.spi.Integrator;
import org.hibernate.service.spi.SessionFactoryServiceRegistry;
import org.openmrs.api.context.Context;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.hibernate5.LocalSessionFactoryBean;
public class HibernateSessionFactoryBean extends LocalSessionFactoryBean implements Integrator {
	private static final Logger log = LoggerFactory.getLogger(HibernateSessionFactoryBean.class);
	protected Set<String> mappingResources = new HashSet<>();
	protected Set<String> packagesToScan = new HashSet<>();
	protected ChainingInterceptor chainingInterceptor = new ChainingInterceptor();
	@Autowired(required = false)
	public Map<String, Interceptor> interceptors = new HashMap<>();
	private Metadata metadata;
	@Override
	public void setMappingResources(String... mappingResources) {
		Collections.addAll(this.mappingResources, mappingResources);
		super.setMappingResources(this.mappingResources.toArray(new String[] {}));
	}
	@Override
	public void setPackagesToScan(String... packagesToScan) {
		this.packagesToScan.addAll(Arrays.asList(packagesToScan));
		super.setPackagesToScan(this.packagesToScan.toArray(new String[0]));
	}
	public Set<String> getModuleMappingResources() {
		for (Module mod : ModuleFactory.getStartedModules()) {
			mappingResources.addAll(mod.getMappingFiles());
		}
		return mappingResources;
	}
	public Set<String> getModulePackagesWithMappedClasses() {
		Set<String> packages = new HashSet<>();
		for (Module module : ModuleFactory.getStartedModules()) {
			packages.addAll(module.getPackagesWithMappedClasses());
		}
		return packages;
	}
	@Override
	public void afterPropertiesSet() throws IOException {
		log.debug("Configuring hibernate sessionFactory properties");
		Properties config = getHibernateProperties();
		Properties moduleProperties = Context.getConfigProperties();
		for (Map.Entry<Object, Object> entry : moduleProperties.entrySet()) {
			Object key = entry.getKey();
			String prop = (String) key;
			String value = (String) entry.getValue();
			log.trace("Setting module property: " + prop + ":" + value);
			config.setProperty(prop, value);
			if (!prop.startsWith("hibernate")) {
				config.setProperty("hibernate." + prop, value);
			}
		}
		Properties properties = Context.getRuntimeProperties();
		for (Map.Entry<Object, Object> entry : properties.entrySet()) {
			Object key = entry.getKey();
			String prop = (String) key;
			String value = (String) entry.getValue();
			log.trace("Setting property: " + prop + ":" + value);
			config.setProperty(prop, value);
			if (!prop.startsWith("hibernate")) {
				config.setProperty("hibernate." + prop, value);
			}
		}
		try {
			InputStream propertyStream = getClass().getResourceAsStream("/hibernate.default.properties");
			Properties props = new Properties();
			OpenmrsUtil.loadProperties(props, propertyStream);
			propertyStream.close();
			for (Entry<Object, Object> prop : props.entrySet()) {
				if (!config.containsKey(prop.getKey())) {
					config.put(prop.getKey(), prop.getValue());
				}
			}
		}
		catch (IOException e) {
			log.error(MarkerFactory.getMarker("FATAL"), "Unable to load default hibernate properties", e);
		}
		log.debug("Replacing variables in hibernate properties");
		final String applicationDataDirectory = OpenmrsUtil.getApplicationDataDirectory();
		for (Entry<Object, Object> entry : config.entrySet()) {
			String value = (String) entry.getValue();
			value = value.replace("%APPLICATION_DATA_DIRECTORY%", applicationDataDirectory);
			entry.setValue(value);
		}
		log.debug("Setting global Hibernate Session Interceptor for SessionFactory, Interceptor: " + chainingInterceptor);
		List<String> keys = new ArrayList<>(interceptors.keySet());
		Collections.sort(keys);
		for (String key : keys) {
			chainingInterceptor.addInterceptor(interceptors.get(key));
		}
		setEntityInterceptor(chainingInterceptor);
		setMappingResources(getModuleMappingResources().toArray(new String[0]));
		setPackagesToScan(getModulePackagesWithMappedClasses().toArray(new String[0]));
		setHibernateIntegrators(this);
		super.afterPropertiesSet();
	}
	@Override
	public void destroy() throws HibernateException {
		try {
			super.destroy();
		}
		catch (IllegalStateException e) {
		}
	}
	@Override
	public void integrate(Metadata metadata, SessionFactoryImplementor sessionFactory,
			SessionFactoryServiceRegistry serviceRegistry) {
		this.metadata = metadata;
	}
	@Override
	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
	}
	public Metadata getMetadata() {
		return metadata;
	}
}
package org.openmrs.messagesource.impl;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import org.openmrs.messagesource.MutableMessageSource;
import org.openmrs.messagesource.PresentationMessage;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleClassLoader;
import org.openmrs.module.ModuleFactory;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;
public class MutableResourceBundleMessageSource extends ReloadableResourceBundleMessageSource implements MutableMessageSource {
	private static final Logger log = LoggerFactory.getLogger(MutableResourceBundleMessageSource.class);
	private String[] basenames = new String[0];
	private int cacheMilliseconds = -1;
	private long lastCached = System.currentTimeMillis();
	private Collection<Locale> locales;
	@Override
	public Collection<Locale> getLocales() {
		long now = System.currentTimeMillis();
		if (locales == null || cacheMilliseconds <= 0 || now - cacheMilliseconds > lastCached) {
			locales = findLocales();
			lastCached = now;
		}
		return locales;
	}
	@Override
	public void setCacheSeconds(int cacheSeconds) {
		this.cacheMilliseconds = cacheSeconds * 1000;
		super.setCacheSeconds(cacheSeconds);
	}
	private Collection<Locale> findLocales() {
		Collection<Locale> foundLocales = new HashSet<>();
		for (Resource propertiesFile : findPropertiesFiles()) {
			String filename = propertiesFile.getFilename();
			Locale parsedLocale = parseLocaleFrom(filename);
			foundLocales.add(parsedLocale);
		}
		if (foundLocales.isEmpty()) {
			log.warn("no locales found.");
		}
		return foundLocales;
	}
	private Locale parseLocaleFrom(String filename) {
		Locale parsedLocale;
		filename = filename.substring("messages".length());
		String localespec = filename.substring(0, filename.indexOf('.'));
		if ("".equals(localespec)) {
			parsedLocale = Locale.getDefault();
		} else {
			localespec = localespec.substring(1); 
			parsedLocale = LocaleUtility.fromSpecification(localespec);
		}
		return parsedLocale;
	}
	@Override
	public Collection<PresentationMessage> getPresentations() {
		Collection<PresentationMessage> presentations = new ArrayList<>();
		for (Resource propertiesFile : findPropertiesFiles()) {
			Locale currentLocale = parseLocaleFrom(propertiesFile.getFilename());
			Properties props = new Properties();
			try {
				OpenmrsUtil.loadProperties(props, propertiesFile.getInputStream());
				for (Map.Entry<Object, Object> property : props.entrySet()) {
					presentations.add(new PresentationMessage(property.getKey().toString(), currentLocale, property
					        .getValue().toString(), ""));
				}
			}
			catch (Exception e) {
				log.error("Unable to load properties from file: " + propertiesFile.getFilename(), e);
			}
		}
		return presentations;
	}
	@Override
	public void setBasename(String basename) {
		super.setBasename(basename);
		this.basenames = new String[] { basename };
	}
	@Override
	public void setBasenames(String... basenames) {
		if (basenames == null) {
			this.basenames = new String[0];
		} else {
			this.basenames = Arrays.copyOf(basenames, basenames.length);
		}
		Collection<Module> modules = ModuleFactory.getStartedModules();
		if (!modules.isEmpty()) {
			String[] names =  new String[this.basenames.length + modules.size()];
			System.arraycopy(this.basenames, 0, names, 0, this.basenames.length);
			int index = this.basenames.length;
			for (Module module : modules) {
				names[index] = "jar:file:" + module.getFile().getAbsolutePath() + "!/messages";
				index++;
			}
			basenames = names;
		}
		super.setBasenames(basenames);
	}
	@Override
	public void addPresentation(PresentationMessage message) {
		Resource propertyFile = findPropertiesFileFor(message.getCode());
		if (propertyFile != null) {
			Properties props = new Properties();
			try {
				OpenmrsUtil.loadProperties(props, propertyFile.getInputStream());
				props.setProperty(message.getCode(), message.getMessage());
			}
			catch (Exception e) {
				log.error("Error generated", e);
			}
		}
	}
	@Override
	public void removePresentation(PresentationMessage message) {
		Resource propertyFile = findPropertiesFileFor(message.getCode());
		if (propertyFile != null) {
			Properties props = new Properties();
			try {
				OpenmrsUtil.loadProperties(props, propertyFile.getInputStream());
				props.remove(message.getCode());
			}
			catch (Exception e) {
				log.error("Error generated", e);
			}
		}
	}
	private Resource findPropertiesFileFor(String code) {
		Properties props = new Properties();
		Resource foundFile = null;
		for (Resource propertiesFile : findPropertiesFiles()) {
			props.clear();
			try {
				OpenmrsUtil.loadProperties(props, propertiesFile.getInputStream());
			}
			catch (Exception e) {
				log.error("Error generated", e);
			}
			if (props.containsKey(code)) {
				foundFile = propertiesFile;
				break;
			}
		}
		return foundFile;
	}
	private Resource[] findPropertiesFiles() {
		Set<Resource> resourceSet = new HashSet<>();
		try {
			String pattern = "classpath*:messages*.properties";
			ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver(OpenmrsClassLoader.getInstance());
			Resource[] propertiesFiles = resourceResolver.getResources(pattern);
			Collections.addAll(resourceSet, propertiesFiles);
			for (ModuleClassLoader moduleClassLoader : ModuleFactory.getModuleClassLoaders()) {
				resourceResolver = new PathMatchingResourcePatternResolver(moduleClassLoader);
				propertiesFiles = resourceResolver.getResources(pattern);
				Collections.addAll(resourceSet, propertiesFiles);
			}
		}
		catch (IOException e) {
			log.error("Error generated", e);
		}
		if (log.isWarnEnabled() && (resourceSet.isEmpty())) {
			log.warn("No properties files found.");
		}
		return resourceSet.toArray(new Resource[resourceSet.size()]);
	}
	@Override
	public void merge(MutableMessageSource fromSource, boolean overwrite) {
		Resource[] propertiesFiles = findPropertiesFiles();
		Map<Locale, List<Resource>> localeToFilesMap = new HashMap<>();
		Map<Resource, Properties> fileToPropertiesMap = new HashMap<>();
		for (Resource propertiesFile : propertiesFiles) {
			Properties props = new Properties();
			Locale propsLocale = parseLocaleFrom(propertiesFile.getFilename());
			List<Resource> propList = localeToFilesMap.computeIfAbsent(propsLocale, k -> new ArrayList<>());
			propList.add(propertiesFile);
			try {
				OpenmrsUtil.loadProperties(props, propertiesFile.getInputStream());
				fileToPropertiesMap.put(propertiesFile, props);
			}
			catch (Exception e) {
				log.error("Unable to load properties from file: " + propertiesFile.getFilename(), e);
			}
		}
		for (PresentationMessage message : fromSource.getPresentations()) {
			Locale messageLocale = message.getLocale();
			List<Resource> filelist = localeToFilesMap.get(messageLocale);
			if (filelist != null) {
				Properties propertyDestination = null;
				boolean propExists = false;
				for (Resource propertiesFile : filelist) {
					Properties possibleDestination = fileToPropertiesMap.get(propertiesFile);
					if (possibleDestination.containsKey(message.getCode())) {
						propertyDestination = possibleDestination;
						propExists = true;
						break;
					} else if (propertyDestination == null) {
						propertyDestination = possibleDestination;
					}
				}
				if (!propExists || overwrite) {
					propertyDestination.put(message.getCode(), message.getMessage());
				}
			}
			message.getCode();
		}
	}
	@Override
	public PresentationMessage getPresentation(String key, Locale forLocale) {
		return null;
	}
	@Override
	public Collection<PresentationMessage> getPresentationsInLocale(Locale locale) {
		return null;
	}
}
package org.openmrs.module.web;
import java.io.IOException;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Map;
import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class ModuleServlet extends HttpServlet {
	private static final long serialVersionUID = 1239820102030303L;
	private static final Logger log = LoggerFactory.getLogger(ModuleServlet.class);
	@Override
	protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		log.debug("In service method for module servlet: " + request.getPathInfo());
		String servletName = request.getPathInfo();
		int end = servletName.indexOf("/", 1);
		String moduleId = null;
		if (end > 0) {
			moduleId = servletName.substring(1, end);
		}
		log.debug("ModuleId: " + moduleId);
		Module mod = ModuleFactory.getModuleById(moduleId);
		int start = 1;
		if (mod != null) {
			log.debug("Module with id " + moduleId + " found.  Looking for servlet name after " + moduleId + " in url path");
			start = moduleId.length() + 2;
		}
		end = servletName.indexOf("/", start);
		if (end == -1 || end > servletName.length()) {
			end = servletName.length();
		}
		servletName = servletName.substring(start, end);
		log.debug("Servlet name: " + servletName);
		HttpServlet servlet = WebModuleUtil.getServlet(servletName);
		if (servlet == null) {
			log.warn("No servlet with name: " + servletName + " was found");
			response.setStatus(HttpServletResponse.SC_NOT_FOUND);
			return;
		}
		servlet.service(request, response);
	}
	public static class SimpleServletConfig implements ServletConfig {
		private String name;
		private ServletContext servletContext;
		private final Map<String, String> initParameters;
		public SimpleServletConfig(String name, ServletContext servletContext, Map<String, String> initParameters) {
			this.name = name;
			this.servletContext = servletContext;
			this.initParameters = initParameters;
		}
		@Override
		public String getServletName() {
			return name;
		}
		@Override
		public ServletContext getServletContext() {
			return servletContext;
		}
		@Override
		public String getInitParameter(String paramName) {
			return initParameters.get(paramName);
		}
		@Override
		public Enumeration<String> getInitParameterNames() {
			return Collections.enumeration(initParameters.keySet());
		}
	}
}
package org.openmrs.module.web;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringReader;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Deque;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Pattern;
import javax.servlet.Filter;
import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleException;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.ModuleUtil;
import org.openmrs.module.web.filter.ModuleFilterConfig;
import org.openmrs.module.web.filter.ModuleFilterDefinition;
import org.openmrs.module.web.filter.ModuleFilterMapping;
import org.openmrs.scheduler.SchedulerException;
import org.openmrs.scheduler.SchedulerService;
import org.openmrs.scheduler.TaskDefinition;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.web.DispatcherServlet;
import org.openmrs.web.StaticDispatcherServlet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.context.support.WebApplicationContextUtils;
import org.springframework.web.context.support.XmlWebApplicationContext;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
public class WebModuleUtil {
	private WebModuleUtil() {
	}
	private static final Logger log = LoggerFactory.getLogger(WebModuleUtil.class);
	private static final Lock SERVLET_LOCK = new ReentrantLock();
	private static final Lock FILTERS_LOCK = new ReentrantLock();
	private static final Map<String, HttpServlet> MODULE_SERVLETS = new HashMap<>();
	private static final Map<Module, Collection<Filter>> MODULE_FILTERS = new HashMap<>();
	private static final Map<String, Filter> MODULE_FILTERS_BY_NAME = new HashMap<>();
	private static final Deque<ModuleFilterMapping> MODULE_FILTER_MAPPINGS = new ArrayDeque<>();
	private static DispatcherServlet dispatcherServlet = null;
	private static StaticDispatcherServlet staticDispatcherServlet = null;
	public static boolean startModule(Module mod, ServletContext servletContext, boolean delayContextRefresh) {
		log.debug("trying to start module {}", mod);
		if (ModuleFactory.isModuleStarted(mod) && !mod.hasStartupError()) {
			String realPath = getRealPath(servletContext);
			if (realPath == null) {
				realPath = System.getProperty("user.dir");
			}
			File webInf = new File(realPath + "/WEB-INF".replace("/", File.separator));
			if (!webInf.exists()) {
				webInf.mkdir();
			}
			boolean moduleNeedsContextRefresh = false;
			JarFile jarFile = null;
			OutputStream outStream = null;
			InputStream inStream = null;
			try {
				File modFile = mod.getFile();
				jarFile = new JarFile(modFile);
				Enumeration<JarEntry> entries = jarFile.entries();
				while (entries.hasMoreElements()) {
					JarEntry entry = entries.nextElement();
					String name = entry.getName();
					if (Paths.get(name).startsWith("..")) {
						throw new UnsupportedOperationException("Attempted to write file '" + name + "' rejected as it attempts to write outside the chosen directory. This may be the result of a zip-slip style attack.");
					}
					log.debug("Entry name: {}", name);
					if (name.startsWith("web/module/")) {
						String filepath = name.substring(11);
						StringBuilder absPath = new StringBuilder(realPath + "/WEB-INF");
						if (filepath.startsWith("tags/")) {
							filepath = filepath.substring(5);
							absPath.append("/tags/module/");
						}
						else {
							absPath.append("/view/module/");
						}
						absPath.append(mod.getModuleIdAsPath()).append("/").append(filepath);
						log.debug("Moving file from: {} to {}", name, absPath);
						File outFile = new File(absPath.toString().replace("/", File.separator));
						if (entry.isDirectory()) {
							if (!outFile.exists()) {
								outFile.mkdirs();
							}
						} else {
							File parentDir = outFile.getParentFile();
							if (!parentDir.exists()) {
								parentDir.mkdirs();
							}
							outStream = new FileOutputStream(outFile, false);
							inStream = jarFile.getInputStream(entry);
							OpenmrsUtil.copyFile(inStream, outStream);
						}
					} else if ("moduleApplicationContext.xml".equals(name) || "webModuleApplicationContext.xml".equals(name)) {
						moduleNeedsContextRefresh = true;
					} else if (name.equals(mod.getModuleId() + "Context.xml")) {
						String msg = "DEPRECATED: '" + name
						        + "' should be named 'moduleApplicationContext.xml' now. Please update/upgrade. ";
						throw new ModuleException(msg, mod.getModuleId());
					}
				}
			}
			catch (IOException io) {
				log.warn("Unable to copy files from module " + mod.getModuleId() + " to the web layer", io);
			}
			finally {
				if (jarFile != null) {
					try {
						jarFile.close();
					}
					catch (IOException io) {
						log.warn("Couldn't close jar file: " + jarFile.getName(), io);
					}
				}
				if (inStream != null) {
					try {
						inStream.close();
					}
					catch (IOException io) {
						log.warn("Couldn't close InputStream: " + io);
					}
				}
				if (outStream != null) {
					try {
						outStream.close();
					}
					catch (IOException io) {
						log.warn("Couldn't close OutputStream: " + io);
					}
				}
			}
			InputStream inputStream = null;
			try {
				Document config = mod.getConfig();
				Element root = config.getDocumentElement();
				if (root.getElementsByTagName("dwr").getLength() > 0) {
					File f = new File(realPath + "/WEB-INF/dwr-modules.xml".replace("/", File.separator));
					if (!f.exists()) {
						createDwrModulesXml(realPath);
					}
					inputStream = new FileInputStream(f);
					Document dwrmodulexml = getDWRModuleXML(inputStream, realPath);
					Element outputRoot = dwrmodulexml.getDocumentElement();
					Node node = root.getElementsByTagName("dwr").item(0);
					Node current = node.getFirstChild();
					while (current != null) {
						if ("allow".equals(current.getNodeName()) || "signatures".equals(current.getNodeName())
						        || "init".equals(current.getNodeName())) {
							((Element) current).setAttribute("moduleId", mod.getModuleId());
							outputRoot.appendChild(dwrmodulexml.importNode(current, true));
						}
						current = current.getNextSibling();
					}
					moduleNeedsContextRefresh = true;
					OpenmrsUtil.saveDocument(dwrmodulexml, f);
				}
			}
			catch (FileNotFoundException e) {
				throw new ModuleException(realPath + "/WEB-INF/dwr-modules.xml file doesn't exist.", e);
			}
			finally {
				if (inputStream != null) {
					try {
						inputStream.close();
					}
					catch (IOException io) {
						log.error("Error while closing input stream", io);
					}
				}
			}
			String folderPath = realPath + "/WEB-INF/view/module/" + mod.getModuleIdAsPath();
			File outFile = new File(folderPath.replace("/", File.separator));
			outFile.deleteOnExit();
			if (!moduleNeedsContextRefresh && mod.getAdvicePoints() != null && !mod.getAdvicePoints().isEmpty()) {
				moduleNeedsContextRefresh = true;
			}
			if (moduleNeedsContextRefresh && !delayContextRefresh) {
				log.debug("Refreshing context for module {}", mod);
				try {
					refreshWAC(servletContext, false, mod);
					log.debug("Done Refreshing WAC");
				}
				catch (Exception e) {
					String msg = "Unable to refresh the WebApplicationContext";
					mod.setStartupErrorMessage(msg, e);
					if (log.isWarnEnabled()) {
						log.warn(msg + " for module: " + mod.getModuleId(), e);
					}
					try {
						stopModule(mod, servletContext, true);
						ModuleFactory.stopModule(mod, true, true); 
					}
					catch (Exception e2) {
						if (log.isWarnEnabled()) {
							log.warn("Error while stopping a module that had an error on refreshWAC", e2);
						}
					}
					refreshWAC(servletContext, false, mod);
					notifySuperUsersAboutModuleFailure(mod);
				}
			}
			if (!delayContextRefresh && ModuleFactory.isModuleStarted(mod)) {
				log.debug("Loading servlets and filters for module {}", mod);
				servletContext.setAttribute(OpenmrsJspServlet.OPENMRS_TLD_SCAN_NEEDED, true);
				loadServlets(mod, servletContext);
				loadFilters(mod, servletContext);
			}
			return (moduleNeedsContextRefresh && delayContextRefresh);
		}
		return false;
	}
	private static void stopTasks(Module mod) {
		SchedulerService schedulerService;
		try {
			schedulerService = Context.getSchedulerService();
		} catch (NullPointerException | APIException e) {
			return;
		}
		String modulePackageName = mod.getPackageName();
		for (TaskDefinition task : schedulerService.getRegisteredTasks()) {
			String taskClass = task.getTaskClass();
			if (isModulePackageNameInTaskClass(modulePackageName, taskClass)) {
				try {
					schedulerService.shutdownTask(task);
				}
				catch (SchedulerException e) {
					log.error("Couldn't stop task:" + task + " for module: " + mod);
				}
			}
		}
	}
	public static boolean isModulePackageNameInTaskClass(String modulePackageName, String taskClass) {
		return modulePackageName.length() <= taskClass.length()
		        && taskClass.matches(Pattern.quote(modulePackageName) + "(\\..*)+");
	}
	private static void notifySuperUsersAboutModuleFailure(Module mod) {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
			Context.addProxyPrivilege(PrivilegeConstants.GET_USERS);
			Context.getAlertService().notifySuperUsers("Module.startupError.notification.message", null, mod.getName());
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.GET_USERS);
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
		}
	}
	public static void loadServlets(Module mod, ServletContext servletContext) {
		Element rootNode = mod.getConfig().getDocumentElement();
		NodeList servletTags = rootNode.getElementsByTagName("servlet");
		for (int i = 0; i < servletTags.getLength(); i++) {
			Node node = servletTags.item(i);
			NodeList childNodes = node.getChildNodes();
			String name = "", className = "";
			Map<String, String> initParams = new HashMap<>();
			for (int j = 0; j < childNodes.getLength(); j++) {
				Node childNode = childNodes.item(j);
				if ("servlet-name".equals(childNode.getNodeName())) {
					if (childNode.getTextContent() != null) {
						name = childNode.getTextContent().trim();
					}
				} else if ("servlet-class".equals(childNode.getNodeName()) && childNode.getTextContent() != null) {
					className = childNode.getTextContent().trim();
				} else if ("init-param".equals(childNode.getNodeName())) {
					NodeList initParamChildren = childNode.getChildNodes();
					String paramName = null, paramValue = null;
					for (int k = 0; k < initParamChildren.getLength(); k++) {
						Node initParamChild = initParamChildren.item(k);
						if ("param-name".equals(initParamChild.getNodeName()) && initParamChild.getTextContent() != null) {
							paramName = initParamChild.getTextContent().trim();
						} else if ("param-value".equals(initParamChild.getNodeName()) && initParamChild.getTextContent() != null) {
							paramValue = initParamChild.getTextContent().trim();
						}
					}
					if (paramName != null && paramValue != null) {
						initParams.put(paramName, paramValue);
					}
				}
			}
			if (name.length() == 0 || className.length() == 0) {
				log.warn("both 'servlet-name' and 'servlet-class' are required for the 'servlet' tag. Given '" + name
				        + "' and '" + className + "' for module " + mod.getName());
				continue;
			}
			HttpServlet httpServlet;
			try {
				httpServlet = (HttpServlet) ModuleFactory.getModuleClassLoader(mod).loadClass(className).newInstance();
			}
			catch (ClassCastException e) {
				log.warn("Class {} from module {} is not a valid HttpServlet", className, mod, e);
				continue;
			}
			catch (ClassNotFoundException e) {
				log.warn("Class {} not found for servlet {} from module {}", className, name, mod, e);
				continue;
			}
			catch (IllegalAccessException e) {
				log.warn("Class {} cannot be accessed for servlet {} from module {}", className, name, mod, e);
				continue;
			}
			catch (InstantiationException e) {
				log.warn("Class {} cannot be instantiated for servlet {} from module {}", className, name, mod, e);
				continue;
			}
			try {
				log.debug("Initializing {} servlet. - {}.", name, httpServlet);
				ServletConfig servletConfig = new ModuleServlet.SimpleServletConfig(name, servletContext, initParams);
				httpServlet.init(servletConfig);
			}
			catch (Exception e) {
				log.warn("Unable to initialize servlet {}", name, e);
				throw new ModuleException("Unable to initialize servlet " + name, mod.getModuleId(), e);
			}
			HttpServlet otherServletUsingSameName = MODULE_SERVLETS.get(name);
			if (otherServletUsingSameName != null) {
				String otherServletName = otherServletUsingSameName.getClass().getName();
				throw new ModuleException("A servlet mapping with name " + name + " is already in use and pointing at: "
				        + otherServletName + " from another installed module and this module is trying"
				        + " to use that same name.  Either the module attempting to be installed (" + mod
				        + ") will not work or the other one will not.  Please consult the developers of these two"
				        + " modules to sort this out.");
			}
			log.debug("Caching the {} servlet.", name);
			SERVLET_LOCK.lock();
			try {
				MODULE_SERVLETS.put(name, httpServlet);
			} finally {
				SERVLET_LOCK.unlock();
			}
		}
	}
	public static void unloadServlets(Module mod) {
		Element rootNode = mod.getConfig().getDocumentElement();
		NodeList servletTags = rootNode.getElementsByTagName("servlet");
		for (int i = 0; i < servletTags.getLength(); i++) {
			Node node = servletTags.item(i);
			NodeList childNodes = node.getChildNodes();
			String name;
			for (int j = 0; j < childNodes.getLength(); j++) {
				Node childNode = childNodes.item(j);
				if ("servlet-name".equals(childNode.getNodeName()) && childNode.getTextContent() != null) {
					name = childNode.getTextContent().trim();
					HttpServlet servlet;
					SERVLET_LOCK.lock();
					try {
						servlet = MODULE_SERVLETS.get(name);
					} finally {
						SERVLET_LOCK.unlock();
					}
					if (servlet != null) {
						servlet.destroy();
					}
					SERVLET_LOCK.lock();
					try {
						MODULE_SERVLETS.remove(name);
					} finally {
						SERVLET_LOCK.unlock();
					}
				}
			}
		}
	}
	public static void loadFilters(Module module, ServletContext servletContext) {
		Map<String, Filter> filters = new LinkedHashMap<>();
		Map<String, Filter> existingFilters;
		FILTERS_LOCK.lock();
		try {
			existingFilters = new HashMap<>(MODULE_FILTERS_BY_NAME);
		} finally {
			FILTERS_LOCK.unlock();
		}
		for (ModuleFilterDefinition def : ModuleFilterDefinition.retrieveFilterDefinitions(module)) {
			String name = def.getFilterName();
			String className = def.getFilterClass();
			if (existingFilters.containsKey(name)) {
				throw new ModuleException("A filter with the name " + name + " is already in use and pointing at: "
					+ existingFilters.get(name).getClass().getName()
					+ " from another installed module and this module is trying"
					+ " to use that same name.  Either the module attempting to be installed (" + module
					+ ") will not work or the other one will not.  Please consult the developers of these two"
					+ " modules to sort this out.");
			}
			ModuleFilterConfig config = ModuleFilterConfig.getInstance(def, servletContext);
			Filter filter;
			try {
				filter = (Filter) ModuleFactory.getModuleClassLoader(module).loadClass(className).newInstance();
			}
			catch (ClassCastException e) {
				log.warn("Class {} from module {} is not a valid Filter", className, module, e);
				continue;
			}
			catch (ClassNotFoundException e) {
				log.warn("Class {} not found for servlet {} from module {}", className, name, module, e);
				continue;
			}
			catch (IllegalAccessException e) {
				log.warn("Class {} cannot be accessed for servlet {} from module {}", className, name, module, e);
				continue;
			}
			catch (InstantiationException e) {
				log.warn("Class {} cannot be instantiated for servlet {} from module {}", className, name, module, e);
				continue;
			}
			try {
				log.debug("Initializing {} filter. - {}.", name, filter);
				filter.init(config);
			}
			catch (Exception e) {
				log.warn("Unable to initialize servlet {}", name, e);
				throw new ModuleException("Unable to initialize servlet " + name, module.getModuleId(), e);
			}
			filters.put(name, filter);
		}
		FILTERS_LOCK.lock();
		try {
			MODULE_FILTERS.put(module, filters.values());
			MODULE_FILTERS_BY_NAME.putAll(filters);
			log.debug("Module {} successfully loaded {} filters.", module, filters.size());
			Deque<ModuleFilterMapping> modMappings = ModuleFilterMapping.retrieveFilterMappings(module);
			modMappings.descendingIterator().forEachRemaining(MODULE_FILTER_MAPPINGS::addFirst);
			log.debug("Module {} successfully loaded {} filter mappings.", module, modMappings.size());
		} finally {
			FILTERS_LOCK.unlock();
		}
	}
	public static void unloadFilters(Module module) {
		for (Iterator<ModuleFilterMapping> mapIter = MODULE_FILTER_MAPPINGS.iterator(); mapIter.hasNext();) {
			ModuleFilterMapping mapping = mapIter.next();
			if (module.equals(mapping.getModule())) {
				mapIter.remove();
				log.debug("Removed ModuleFilterMapping: " + mapping);
			}
		}
		Collection<Filter> filters = MODULE_FILTERS.get(module);
		if (filters != null) {
			try {
				for (Filter f : filters) {
					f.destroy();
				}
			}
			catch (Exception e) {
				log.warn("An error occurred while trying to destroy and remove module Filter.", e);
			}
			log.debug("Module: " + module.getModuleId() + " successfully unloaded " + filters.size() + " filters.");
			MODULE_FILTERS.remove(module);
			MODULE_FILTERS_BY_NAME.values().removeIf(filters::contains);
		}
	}
	public static Collection<Filter> getFilters() {
		return MODULE_FILTERS_BY_NAME.values();
	}
	public static Collection<ModuleFilterMapping> getFilterMappings() {
		return new ArrayList<>(MODULE_FILTER_MAPPINGS);
	}
	public static List<Filter> getFiltersForRequest(ServletRequest request) {
		List<Filter> filters = new ArrayList<>();
		if (request != null) {
			HttpServletRequest httpRequest = (HttpServletRequest) request;
			String requestPath = httpRequest.getRequestURI();
			if (requestPath != null) {
				if (requestPath.startsWith(httpRequest.getContextPath())) {
					requestPath = requestPath.substring(httpRequest.getContextPath().length());
				}
				for (ModuleFilterMapping filterMapping : WebModuleUtil.getFilterMappings()) {
					if (ModuleFilterMapping.filterMappingPasses(filterMapping, requestPath)) {
						Filter passedFilter = MODULE_FILTERS_BY_NAME.get(filterMapping.getFilterName());
						if (passedFilter != null) {
							filters.add(passedFilter);
						} else {
							log.warn("Unable to retrieve filter that has a name of " + filterMapping.getFilterName()
							        + " in filter mapping.");
						}
					}
				}
			}
		}
		return filters;
	}
	private static Document getDWRModuleXML(InputStream inputStream, String realPath) {
		Document dwrmodulexml;
		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder db = dbf.newDocumentBuilder();
			db.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader("")));
			dwrmodulexml = db.parse(inputStream);
		}
		catch (Exception e) {
			throw new ModuleException("Error parsing dwr-modules.xml file", e);
		}
		return dwrmodulexml;
	}
	public static void shutdownModules(ServletContext servletContext) {
		String realPath = getRealPath(servletContext);
		String messagesPath = realPath + "/WEB-INF/";
		File folder = new File(messagesPath.replace("/", File.separator));
		File[] files = folder.listFiles();
		if (folder.exists() && files != null) {
			Properties emptyProperties = new Properties();
			for (File f : files) {
				if (f.getName().startsWith("module_messages")) {
					OpenmrsUtil.storeProperties(emptyProperties, f, "");
				}
			}
		}
		for (Module mod : ModuleFactory.getLoadedModules()) {
			stopModule(mod, servletContext, true);
		}
	}
	public static void stopModule(Module mod, ServletContext servletContext) {
		stopModule(mod, servletContext, false);
	}
	public static void stopModule(Module mod, ServletContext servletContext, boolean skipRefresh) {
		String moduleId = mod.getModuleId();
		String modulePackage = mod.getPackageName();
		for (Module dependentModule : ModuleFactory.getStartedModules()) {
			if (!dependentModule.equals(mod) && dependentModule.getRequiredModules().contains(modulePackage)) {
				stopModule(dependentModule, servletContext, skipRefresh);
			}
		}
		String realPath = getRealPath(servletContext);
		String absPath = realPath + "/WEB-INF/view/module/" + moduleId;
		File moduleWebFolder = new File(absPath.replace("/", File.separator));
		if (moduleWebFolder.exists()) {
			try {
				OpenmrsUtil.deleteDirectory(moduleWebFolder);
			}
			catch (IOException io) {
				log.warn("Couldn't delete: " + moduleWebFolder.getAbsolutePath(), io);
			}
		}
		unloadServlets(mod);
		unloadFilters(mod);
		stopTasks(mod);
		InputStream inputStream = null;
		try {
			Document config = mod.getConfig();
			Element root = config.getDocumentElement();
			if (root.getElementsByTagName("dwr").getLength() > 0) {
				File f = new File(realPath + "/WEB-INF/dwr-modules.xml".replace("/", File.separator));
				if (!f.exists()) {
					createDwrModulesXml(realPath);
				}
				inputStream = new FileInputStream(f);
				Document dwrmodulexml = getDWRModuleXML(inputStream, realPath);
				Element outputRoot = dwrmodulexml.getDocumentElement();
				NodeList nodeList = outputRoot.getChildNodes();
				int i = 0;
				while (i < nodeList.getLength()) {
					Node current = nodeList.item(i);
					if ("allow".equals(current.getNodeName()) || "signatures".equals(current.getNodeName())) {
						NamedNodeMap attrs = current.getAttributes();
						Node attr = attrs.getNamedItem("moduleId");
						if (attr != null && moduleId.equals(attr.getNodeValue())) {
							outputRoot.removeChild(current);
						} else {
							i++;
						}
					} else {
						i++;
					}
				}
				OpenmrsUtil.saveDocument(dwrmodulexml, f);
			}
		}
		catch (FileNotFoundException e) {
			throw new ModuleException(realPath + "/WEB-INF/dwr-modules.xml file doesn't exist.", e);
		}
		finally {
			if (inputStream != null) {
				try {
					inputStream.close();
				}
				catch (IOException io) {
					log.error("Error while closing input stream", io);
				}
			}
		}
		if (!skipRefresh) {	
			refreshWAC(servletContext, false, null);
		}
	}
	public static XmlWebApplicationContext refreshWAC(ServletContext servletContext, boolean isOpenmrsStartup,
	        Module startedModule) {
		XmlWebApplicationContext wac = (XmlWebApplicationContext) WebApplicationContextUtils
		        .getWebApplicationContext(servletContext);
		log.debug("Refreshing web application Context of class: {}", wac.getClass().getName());
		if (dispatcherServlet != null) {
			dispatcherServlet.stopAndCloseApplicationContext();
		}
		if (staticDispatcherServlet != null) {
			staticDispatcherServlet.stopAndCloseApplicationContext();
		}
		XmlWebApplicationContext newAppContext = (XmlWebApplicationContext) ModuleUtil.refreshApplicationContext(wac,
		    isOpenmrsStartup, startedModule);
		try {
			if (dispatcherServlet != null) {
				dispatcherServlet.reInitFrameworkServlet();
			}
			if (staticDispatcherServlet != null) {
				staticDispatcherServlet.refreshApplicationContext();
			}
		}
		catch (ServletException se) {
			log.warn("Caught a servlet exception while refreshing the dispatcher servlet", se);
		}
		return newAppContext;
	}
	public static void setDispatcherServlet(DispatcherServlet ds) {
		log.debug("Setting dispatcher servlet: " + ds);
		dispatcherServlet = ds;
	}
	public static void setStaticDispatcherServlet(StaticDispatcherServlet ds) {
		log.debug("Setting dispatcher servlet for static content: " + ds);
		staticDispatcherServlet = ds;
	}
	public static HttpServlet getServlet(String servletName) {
		return MODULE_SERVLETS.get(servletName);
	}
	public static String getModuleWebFolder(String moduleId) {
		if (dispatcherServlet == null) {
			throw new ModuleException("Dispatcher servlet must be present in the web environment");
		}
		String moduleFolder = "WEB-INF/view/module/";
		String realPath = dispatcherServlet.getServletContext().getRealPath("");
		String moduleWebFolder;
		if (realPath.endsWith(File.separator) || realPath.endsWith("/")) {
			moduleWebFolder = realPath + moduleFolder;
		} else {
			moduleWebFolder = realPath + "/" + moduleFolder;
		}
		moduleWebFolder += moduleId;
		return moduleWebFolder.replace("/", File.separator);
	}
	public static void createDwrModulesXml(String realPath) {
		try {
			DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
			Document doc = docBuilder.newDocument();
			Element rootElement = doc.createElement("dwr");
			doc.appendChild(rootElement);
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			Transformer transformer = transformerFactory.newTransformer();
			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(realPath
			        + "/WEB-INF/dwr-modules.xml".replace("/", File.separator)));
			transformer.transform(source, result);
		}
		catch (ParserConfigurationException pce) {
			log.error("Failed to parse document", pce);
		}
		catch (TransformerException tfe) {
			log.error("Failed to transorm xml source", tfe);
		}
	}
	public static String getRealPath(ServletContext servletContext) {
		return servletContext.getRealPath("");
	}
}
package org.openmrs.web;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.web.WebModuleUtil;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.web.filter.initialization.InitializationFilter;
import org.openmrs.web.filter.update.UpdateFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeansException;
import org.springframework.web.context.support.XmlWebApplicationContext;
public class DispatcherServlet extends org.springframework.web.servlet.DispatcherServlet {
	private static final long serialVersionUID = -6925172744402818729L;
	private static final Logger log = LoggerFactory.getLogger(DispatcherServlet.class);
	@Override
	protected void initFrameworkServlet() throws ServletException, BeansException {
		Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
		log.debug("Framework being initialized");
		WebModuleUtil.setDispatcherServlet(this);
		super.initFrameworkServlet();
	}
	public void reInitFrameworkServlet() throws ServletException {
		log.debug("Framework being REinitialized");
		Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
		((XmlWebApplicationContext) getWebApplicationContext()).setClassLoader(OpenmrsClassLoader.getInstance());
		init();
		for (Module module : ModuleFactory.getStartedModules()) {
			ModuleFactory.loadAdvice(module);
		}
	}
	@Override
	public void init(ServletConfig config) throws ServletException {
		super.init(config);
		if (UpdateFilter.updatesRequired() && !DatabaseUpdater.allowAutoUpdate()) {
			log.info("DB updates are required, the update wizard must be run");
		}
		if (InitializationFilter.initializationRequired()) {
			log.info("Runtime properties were not found or the database is empty, so initialization is required");
		}
	}
	public void stopAndCloseApplicationContext() {
		try {
			XmlWebApplicationContext ctx = (XmlWebApplicationContext) getWebApplicationContext();
			ctx.stop();
			ctx.close();
		}
		catch (Exception e) {
			log.error("Exception while stopping and closing dispatcherServlet context: ", e);
		}
	}
}
package org.openmrs.module.web;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleUtil;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class ModuleResourcesServlet extends HttpServlet {
	private static final String MODULE_PATH = "/WEB-INF/view/module/";
	private static final long serialVersionUID = 1239820102030344L;
	private static final Logger log = LoggerFactory.getLogger(ModuleResourcesServlet.class);
	@Override
	protected long getLastModified(HttpServletRequest req) {
		File f = getFile(req);
		if (f == null) {
			return super.getLastModified(req);
		}
		return f.lastModified();
	}
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		log.debug("In service method for module servlet: " + request.getPathInfo());
		File f = getFile(request);
		if (f == null) {
			response.setStatus(HttpServletResponse.SC_NOT_FOUND);
			return;
		}
		response.setDateHeader("Last-Modified", f.lastModified());
		response.setContentLength(Long.valueOf(f.length()).intValue());
		String mimeType = getServletContext().getMimeType(f.getName());
		response.setContentType(mimeType);
		FileInputStream is = new FileInputStream(f);
		try {
			OpenmrsUtil.copyFile(is, response.getOutputStream());
		}
		finally {
			OpenmrsUtil.closeStream(is);
		}
	}
	protected File getFile(HttpServletRequest request) {
		String path = request.getPathInfo();
		Module module = ModuleUtil.getModuleForPath(path);
		if (module == null) {
			log.warn("No module handles the path: " + path);
			return null;
		}
		String relativePath = ModuleUtil.getPathForResource(module, path);
		String realPath = getServletContext().getRealPath("") + MODULE_PATH + module.getModuleIdAsPath() + "/resources"
		        + relativePath;
		File devDir = ModuleUtil.getDevelopmentDirectory(module.getModuleId());
		if (devDir != null) {
			realPath = devDir.getAbsolutePath() + "/omod/target/classes/web/module/resources" + relativePath;
		}
		realPath = realPath.replace("/", File.separator);
		File f = new File(realPath);
		if (!f.exists()) {
			log.warn("No file with path '" + realPath + "' exists for module '" + module.getModuleId() + "'");
			return null;
		}
		return f;
	}
}
package org.openmrs.web;
import org.apache.logging.log4j.LogManager;
import org.openmrs.api.context.Context;
import org.openmrs.logging.OpenmrsLoggingUtil;
import org.openmrs.module.MandatoryModuleException;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.ModuleMustStartException;
import org.openmrs.module.OpenmrsCoreModuleException;
import org.openmrs.module.web.OpenmrsJspServlet;
import org.openmrs.module.web.WebModuleUtil;
import org.openmrs.scheduler.SchedulerUtil;
import org.openmrs.util.DatabaseUpdateException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.MemoryLeakUtil;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.web.filter.initialization.DatabaseDetective;
import org.openmrs.web.filter.initialization.InitializationFilter;
import org.openmrs.web.filter.update.UpdateFilter;
import org.owasp.csrfguard.CsrfGuard;
import org.owasp.csrfguard.CsrfGuardServletContextListener;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;
import org.springframework.beans.factory.BeanCreationException;
import org.springframework.util.StringUtils;
import org.springframework.web.context.ContextLoader;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.XmlWebApplicationContext;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.ServletException;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.StringReader;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Driver;
import java.sql.DriverManager;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
public final class Listener extends ContextLoader implements ServletContextListener, HttpSessionListener {
	private static final org.slf4j.Logger log = LoggerFactory.getLogger(Listener.class);
	private static boolean runtimePropertiesFound = false;
	private static Throwable errorAtStartup = null;
	private static boolean setupNeeded = false;
	private static boolean openmrsStarted = false;
	public static boolean runtimePropertiesFound() {
		return runtimePropertiesFound;
	}
	public static boolean errorOccurredAtStartup() {
		return errorAtStartup != null;
	}
	public static boolean isSetupNeeded() {
		return setupNeeded;
	}
	public static boolean isOpenmrsStarted() {
		return openmrsStarted;
	}
	public static Throwable getErrorAtStartup() {
		return errorAtStartup;
	}
	public static void setRuntimePropertiesFound(boolean runtimePropertiesFound) {
		Listener.runtimePropertiesFound = runtimePropertiesFound;
	}
	public static void setErrorAtStartup(Throwable errorAtStartup) {
		Listener.errorAtStartup = errorAtStartup;
	}
	@Override
	public void sessionCreated(HttpSessionEvent se) {
		for (HttpSessionListener listener : getHttpSessionListeners()) {
			listener.sessionCreated(se);
		}
	}
	@Override
	public void sessionDestroyed(HttpSessionEvent se) {
		for (HttpSessionListener listener : getHttpSessionListeners()) {
			listener.sessionDestroyed(se);
		}
	}
	private List<HttpSessionListener> getHttpSessionListeners() {
		List<HttpSessionListener> httpSessionListeners = Collections.emptyList();
		if (openmrsStarted) {
			try {
				httpSessionListeners = Context.getRegisteredComponents(HttpSessionListener.class);
			}
			catch (Exception e) {
				log.warn("An error occurred trying to retrieve HttpSessionListener beans from the context", e);
			}
		}
		return httpSessionListeners;
	}
	@Override
	public void contextInitialized(ServletContextEvent event) {
		log.debug("Starting the OpenMRS webapp");
		try {
			OpenmrsUtil.validateJavaVersion();
			ServletContext servletContext = event.getServletContext();
			loadConstants(servletContext);
			clearDWRFile(servletContext);
			setApplicationDataDirectory(servletContext);
			Properties props = getRuntimeProperties();
			if (props != null) {
				setRuntimePropertiesFound(true);
				Context.setRuntimeProperties(props);
				String appDataRuntimeProperty = props
				        .getProperty(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_RUNTIME_PROPERTY, null);
				if (StringUtils.hasLength(appDataRuntimeProperty)) {
					OpenmrsUtil.setApplicationDataDirectory(null);
				}
				OpenmrsLoggingUtil.applyLogLevel(getClass().toString(), "INFO");
				log.info("Using runtime properties file: {}",
				         OpenmrsUtil.getRuntimePropertiesFilePathName(WebConstants.WEBAPP_NAME));
			}
			loadCsrfGuardProperties(servletContext);
			Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
			if (!setupNeeded()) {
				copyCustomizationIntoWebapp(servletContext, props);
				XmlWebApplicationContext context = (XmlWebApplicationContext) createWebApplicationContext(servletContext);
				configureAndRefreshWebApplicationContext(context, servletContext);
				servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);
				WebDaemon.startOpenmrs(event.getServletContext());
			} else {
				setupNeeded = true;
			}
		}
		catch (Exception e) {
			setErrorAtStartup(e);
			log.error(MarkerFactory.getMarker("FATAL"), "Failed to obtain JDBC connection", e);
		}
	}
	private void loadCsrfGuardProperties(ServletContext servletContext) throws IOException {
		File csrfGuardFile = new File(OpenmrsUtil.getApplicationDataDirectory(), "csrfguard.properties");
		Properties csrfGuardProperties = new Properties();
		if (csrfGuardFile.exists()) {
			try (InputStream csrfGuardInputStream = Files.newInputStream(csrfGuardFile.toPath())) {
				csrfGuardProperties.load(csrfGuardInputStream);
			}
			catch (Exception e) {
				log.error("Error loading csrfguard.properties file at " + csrfGuardFile.getAbsolutePath(), e);
				throw e;
			}
		}
		else {
			String fileName = servletContext.getRealPath("/WEB-INF/csrfguard.properties");
			try (InputStream csrfGuardInputStream = Files.newInputStream(Paths.get(fileName))) {
				csrfGuardProperties.load(csrfGuardInputStream);
			}
			catch (Exception e) {
				log.error("Error loading csrfguard.properties file at " +  fileName, e);
				throw e;
			}
		}
		Properties runtimeProperties = getRuntimeProperties();
		if (runtimeProperties != null) {
			runtimeProperties.stringPropertyNames().forEach(property -> {
				if (property.startsWith("org.owasp.csrfguard")) {
					csrfGuardProperties.setProperty(property, runtimeProperties.getProperty(property));
				}
			});	
		}
		CsrfGuard.load(csrfGuardProperties);
		try {
			Field field = CsrfGuardServletContextListener.class.getDeclaredField("servletContext");
			field.setAccessible(true);
			field.set(null, servletContext.getContextPath());
		}
		catch (Exception ex) {
			log.error("Failed to set the CSRFGuard servlet context", ex);
		}
	}
	private boolean setupNeeded() throws Exception {
		if (!runtimePropertiesFound) {
			return true;
		}
		DatabaseDetective databaseDetective = new DatabaseDetective();
		if (databaseDetective.isDatabaseEmpty(OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME))) {
			return true;
		}
		return DatabaseUpdater.updatesRequired() && !DatabaseUpdater.allowAutoUpdate();
	}
	public static void startOpenmrs(ServletContext servletContext) throws ServletException {
		openmrsStarted = false;
		try {
			Listener.loadBundledModules(servletContext);
			Context.startup(getRuntimeProperties());
		}
		catch (DatabaseUpdateException | InputRequiredException updateEx) {
			throw new ServletException("Should not be here because updates were run previously", updateEx);
		}
		catch (MandatoryModuleException mandatoryModEx) {
			throw new ServletException(mandatoryModEx);
		}
		catch (OpenmrsCoreModuleException coreModEx) {
			throw coreModEx;
		}
		try {
			Listener.performWebStartOfModules(servletContext);
			SchedulerUtil.startup(getRuntimeProperties());
		}
		catch (Exception t) {
			Context.shutdown();
			WebModuleUtil.shutdownModules(servletContext);
			throw new ServletException(t);
		}
		finally {
			Context.closeSession();
		}
		openmrsStarted = true;
	}
	private void loadConstants(ServletContext servletContext) {
		WebConstants.BUILD_TIMESTAMP = servletContext.getInitParameter("build.timestamp");
		WebConstants.WEBAPP_NAME = getContextPath(servletContext);
		WebConstants.MODULE_REPOSITORY_URL = servletContext.getInitParameter("module.repository.url");
		if (!"openmrs".equalsIgnoreCase(WebConstants.WEBAPP_NAME)) {
			OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY = WebConstants.WEBAPP_NAME
			        + "_APPLICATION_DATA_DIRECTORY";
		}
	}
	private void setApplicationDataDirectory(ServletContext servletContext) {
		String appDataDir = servletContext.getInitParameter("application.data.directory");
		if (StringUtils.hasLength(appDataDir)) {
			OpenmrsUtil.setApplicationDataDirectory(appDataDir);
		} else if (!"openmrs".equalsIgnoreCase(WebConstants.WEBAPP_NAME)) {
			OpenmrsUtil.setApplicationDataDirectory(
			    Paths.get(OpenmrsUtil.getApplicationDataDirectory(), WebConstants.WEBAPP_NAME).toString());
		}
	}
	private String getContextPath(ServletContext servletContext) {
		String contextPath = servletContext.getContextPath();
		if (contextPath.startsWith("/")) {
			contextPath = contextPath.substring(1);
		}
		return contextPath;
	}
	private void clearDWRFile(ServletContext servletContext) {
		File dwrFile = Paths.get(servletContext.getRealPath(""), "WEB-INF", "dwr-modules.xml").toFile();
		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder db = dbf.newDocumentBuilder();
			db.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader("")));
			Document doc = db.parse(dwrFile);
			Element elem = doc.getDocumentElement();
			elem.setTextContent("");
			OpenmrsUtil.saveDocument(doc, dwrFile);
		}
		catch (Exception e) {
			log.debug("Error clearing dwr-modules.xml", e);
			dwrFile.delete();
			OutputStreamWriter writer = null;
			try {
				writer = new OutputStreamWriter(new FileOutputStream(dwrFile), StandardCharsets.UTF_8);
				writer.write(
				    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE dwr PUBLIC \"-
			}
			catch (IOException io) {
				log.error(
				    "Unable to clear out the " + dwrFile.getAbsolutePath() + " file.  Please redeploy the openmrs war file",
				    io);
			}
			finally {
				if (writer != null) {
					try {
						writer.close();
					}
					catch (IOException io) {
						log.warn("Couldn't close Writer: " + io);
					}
				}
			}
		}
	}
	private void copyCustomizationIntoWebapp(ServletContext servletContext, Properties props) {
		String realPath = servletContext.getRealPath("");
		Map<String, String> custom = new HashMap<>();
		custom.put("custom.template.dir", "/WEB-INF/template");
		custom.put("custom.index.jsp.file", "/WEB-INF/view/index.jsp");
		custom.put("custom.login.jsp.file", "/WEB-INF/view/login.jsp");
		custom.put("custom.patientDashboardForm.jsp.file", "/WEB-INF/view/patientDashboardForm.jsp");
		custom.put("custom.images.dir", "/images");
		custom.put("custom.style.css.file", "/style.css");
		custom.put("custom.messages", "/WEB-INF/custom_messages.properties");
		custom.put("custom.messages_fr", "/WEB-INF/custom_messages_fr.properties");
		custom.put("custom.messages_es", "/WEB-INF/custom_messages_es.properties");
		custom.put("custom.messages_de", "/WEB-INF/custom_messages_de.properties");
		for (Map.Entry<String, String> entry : custom.entrySet()) {
			String prop = entry.getKey();
			String webappPath = entry.getValue();
			String userOverridePath = props.getProperty(prop);
			if (userOverridePath != null) {
				String absolutePath = realPath + webappPath;
				File file = new File(userOverridePath);
				if (file.exists() && !userOverridePath.startsWith(".")) {
					log.debug("Overriding file: " + absolutePath);
					log.debug("Overriding file with: " + userOverridePath);
					if (file.isDirectory()) {
						File[] files = file.listFiles();
						if (files != null) {
							for (File f : files) {
								userOverridePath = f.getAbsolutePath();
								if (!f.getName().startsWith(".")) {
									String tmpAbsolutePath = absolutePath + "/" + f.getName();
									if (!copyFile(userOverridePath, tmpAbsolutePath)) {
										log.warn("Unable to copy file in folder defined by runtime property: " + prop);
										log.warn("Your source directory (or a file in it) '" + userOverridePath
													+ " cannot be loaded or destination '" + tmpAbsolutePath + "' cannot be found");
									}
								}
							}
						}
					} else {
						if (!copyFile(userOverridePath, absolutePath)) {
							log.warn("Unable to copy file defined by runtime property: " + prop);
							log.warn("Your source file '" + userOverridePath + " cannot be loaded or destination '"
							        + absolutePath + "' cannot be found");
						}
					}
				}
			}
		}
	}
	private boolean copyFile(String fromPath, String toPath) {
		FileInputStream inputStream = null;
		FileOutputStream outputStream = null;
		try {
			inputStream = new FileInputStream(fromPath);
			outputStream = new FileOutputStream(toPath);
			OpenmrsUtil.copyFile(inputStream, outputStream);
		}
		catch (IOException io) {
			return false;
		}
		finally {
			try {
				if (inputStream != null) {
					inputStream.close();
				}
			}
			catch (IOException io) {
				log.warn("Unable to close input stream", io);
			}
			try {
				if (outputStream != null) {
					outputStream.close();
				}
			}
			catch (IOException io) {
				log.warn("Unable to close input stream", io);
			}
		}
		return true;
	}
	public static void loadBundledModules(ServletContext servletContext) {
		File folder = Paths.get(servletContext.getRealPath(""), "WEB-INF", "bundledModules").toFile();
		if (!folder.exists()) {
			log.warn("Bundled module folder doesn't exist: " + folder.getAbsolutePath());
			return;
		}
		if (!folder.isDirectory()) {
			log.warn("Bundled module folder isn't really a directory: " + folder.getAbsolutePath());
			return;
		}
		File[] files = folder.listFiles();
		if (files != null) {
			for (File f : files) {
				if (!f.getName().startsWith(".")) { 
					try {
						Module mod = ModuleFactory.loadModule(f);
						log.debug("Loaded bundled module: " + mod + " successfully");
					}
					catch (Exception e) {
						log.warn("Error while trying to load bundled module " + f.getName() + "", e);
					}
				}
			}
		}
	}
	@SuppressWarnings("squid:S1215")
	@Override
	public void contextDestroyed(ServletContextEvent event) {
		try {
			openmrsStarted = false;
			Context.openSession();
			Context.shutdown();
			WebModuleUtil.shutdownModules(event.getServletContext());
		}
		catch (Exception e) {
			if (!"contextDAO is null".equals(e.getMessage())) {
				System.out.println("Listener.contextDestroyed: Error while shutting down openmrs: ");
				log.error("Listener.contextDestroyed: Error while shutting down openmrs: ", e);
			}
		}
		finally {
			if ("true".equalsIgnoreCase(System.getProperty("FUNCTIONAL_TEST_MODE"))) {
				String filename = WebConstants.WEBAPP_NAME + "-test-runtime.properties";
				File file = new File(OpenmrsUtil.getApplicationDataDirectory(), filename);
				System.out.println(filename + " delete=" + file.delete());
			}
			Context.closeSession();
		}
		try {
			for (Enumeration<Driver> e = DriverManager.getDrivers(); e.hasMoreElements();) {
				Driver driver = e.nextElement();
				ClassLoader classLoader = driver.getClass().getClassLoader();
				if (classLoader == null || classLoader == getClass().getClassLoader()) {
					DriverManager.deregisterDriver(driver);
				} else {
					System.err.println("Didn't remove driver class: " + driver.getClass() + " with classloader of: "
					        + driver.getClass().getClassLoader());
				}
			}
		}
		catch (Exception e) {
			System.err.println("Listener.contextDestroyed: Failed to cleanup drivers in webapp");
			log.error("Listener.contextDestroyed: Failed to cleanup drivers in webapp", e);
		}
		MemoryLeakUtil.shutdownMysqlCancellationTimer();
		OpenmrsClassLoader.onShutdown();
		LogManager.shutdown();
		System.gc();
		System.gc();
	}
	public static Properties getRuntimeProperties() {
		return OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME);
	}
	public static void performWebStartOfModules(ServletContext servletContext) throws ModuleMustStartException, Exception {
		List<Module> startedModules = new ArrayList<>(ModuleFactory.getStartedModules());
		performWebStartOfModules(startedModules, servletContext);
	}
	public static void performWebStartOfModules(Collection<Module> startedModules, ServletContext servletContext)
	        throws ModuleMustStartException, Exception {
		boolean someModuleNeedsARefresh = false;
		for (Module mod : startedModules) {
			try {
				boolean thisModuleCausesRefresh = WebModuleUtil.startModule(mod, servletContext,
				    true);
				someModuleNeedsARefresh = someModuleNeedsARefresh || thisModuleCausesRefresh;
			}
			catch (Exception e) {
				mod.setStartupErrorMessage("Unable to start module", e);
			}
		}
		if (someModuleNeedsARefresh) {
			try {
				WebModuleUtil.refreshWAC(servletContext, true, null);
			}
			catch (ModuleMustStartException | BeanCreationException ex) {
				throw ex;
			}
			catch (Exception e) {
				Throwable rootCause = getActualRootCause(e, true);
				if (rootCause != null) {
					log.error(MarkerFactory.getMarker("FATAL"),
					    "Unable to refresh the spring application context.  Root Cause was:", rootCause);
				} else {
					log.error(MarkerFactory.getMarker("FATAL"),
					    "nable to refresh the spring application context. Unloading all modules,  Error was:", e);
				}
				try {
					WebModuleUtil.shutdownModules(servletContext);
					for (Module mod : ModuleFactory.getLoadedModules()) {
						if (!mod.isCoreModule() && !mod.isMandatory()) {
							try {
								ModuleFactory.stopModule(mod, true, true);
							}
							catch (Exception t3) {
								log.trace("Unable to shutdown module:" + mod, t3);
							}
						}
					}
					WebModuleUtil.refreshWAC(servletContext, true, null);
				}
				catch (MandatoryModuleException ex) {
					throw new MandatoryModuleException(ex.getModuleId(), "Got an error while starting a mandatory module: "
					        + e.getMessage() + ". Check the server logs for more information");
				}
				catch (Exception t2) {
					log.warn("caught another error: ", t2);
					throw t2;
				}
			}
		}
		for (Module mod : ModuleFactory.getStartedModulesInOrder()) {
			WebModuleUtil.loadServlets(mod, servletContext);
			WebModuleUtil.loadFilters(mod, servletContext);
		}
		servletContext.setAttribute(OpenmrsJspServlet.OPENMRS_TLD_SCAN_NEEDED, true);
	}
	private static Throwable getActualRootCause(Throwable t, boolean isOriginalError) {
		if (t.getCause() != null) {
			return getActualRootCause(t.getCause(), false);
		}
		if (!isOriginalError) {
			return t;
		}
		return null;
	}
}
package org.openmrs.module;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.util.List;
import java.util.ArrayList;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.jar.JarFile;
import java.util.zip.ZipEntry;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
public class SqlDiffFileParser {
	private SqlDiffFileParser() {
	}
	private static final Logger log = LoggerFactory.getLogger(SqlDiffFileParser.class);
	private static final String SQLDIFF_CHANGELOG_FILENAME = "sqldiff.xml";
	public static SortedMap<String, String> getSqlDiffs(Module module) throws ModuleException {
		if (module == null) {
			throw new ModuleException("Module cannot be null");
		}
		SortedMap<String, String> map = new TreeMap<>(new VersionComparator());
		InputStream diffStream;
		JarFile jarfile = null;
		try {
			try {
				jarfile = new JarFile(module.getFile());
			}
			catch (IOException e) {
				throw new ModuleException("Unable to get jar file", module.getName(), e);
			}
			diffStream = ModuleUtil.getResourceFromApi(jarfile, module.getModuleId(), module.getVersion(),
			    SQLDIFF_CHANGELOG_FILENAME);
			if (diffStream == null) {
				ZipEntry diffEntry = jarfile.getEntry(SQLDIFF_CHANGELOG_FILENAME);
				if (diffEntry == null) {
					log.debug("No sqldiff.xml found for module: " + module.getName());
					return map;
				} else {
					try {
						diffStream = jarfile.getInputStream(diffEntry);
					}
					catch (IOException e) {
						throw new ModuleException("Unable to get sql diff file stream", module.getName(), e);
					}
				}
			}
			try {
				Document diffDoc;
				try {
					DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
					DocumentBuilder db = dbf.newDocumentBuilder();
					db.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader("")));
					diffDoc = db.parse(diffStream);
				}
				catch (Exception e) {
					throw new ModuleException("Error parsing diff sqldiff.xml file", module.getName(), e);
				}
				Element rootNode = diffDoc.getDocumentElement();
				String diffVersion = rootNode.getAttribute("version");
				if (!validConfigVersions().contains(diffVersion)) {
					throw new ModuleException("Invalid config version: " + diffVersion, module.getModuleId());
				}
				NodeList diffNodes = getDiffNodes(rootNode, diffVersion);
				if (diffNodes != null && diffNodes.getLength() > 0) {
					int i = 0;
					while (i < diffNodes.getLength()) {
						Element el = (Element) diffNodes.item(i++);
						String version = getElement(el, diffVersion, "version");
						String sql = getElement(el, diffVersion, "sql");
						map.put(version, sql);
					}
				}
			}
			catch (ModuleException e) {
				if (diffStream != null) {
					try {
						diffStream.close();
					}
					catch (IOException io) {
						log.error("Error while closing config stream for module: " + module.getModuleId(), io);
					}
				}
				throw e;
			}
		}
		finally {
			try {
				if (jarfile != null) {
					jarfile.close();
				}
			}
			catch (IOException e) {
				log.warn("Unable to close jarfile: " + jarfile.getName());
			}
		}
		return map;
	}
	private static String getElement(Element element, String version, String tag) {
		if (element.getElementsByTagName(tag).getLength() > 0) {
			return element.getElementsByTagName(tag).item(0).getTextContent();
		}
		return "";
	}
	private static List<String> validConfigVersions() {
		List<String> versions = new ArrayList<>();
		versions.add("1.0");
		return versions;
	}
	private static NodeList getDiffNodes(Element element, String version) {
		NodeList diffNodes = null;
		if ("1.0".equals(version)) {
			diffNodes = element.getElementsByTagName("diff");
		}
		return diffNodes;
	}
}
package org.openmrs.annotation;
import java.io.IOException;
import java.util.Map;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.ModuleUtil;
import org.openmrs.util.OpenmrsConstants;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;
import org.springframework.core.type.filter.TypeFilter;
public class OpenmrsProfileExcludeFilter implements TypeFilter {
	@Override
	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
		Map<String, Object> openmrsProfileAttributes = metadataReader.getAnnotationMetadata().getAnnotationAttributes(
				"org.openmrs.annotation.OpenmrsProfile");
		if (openmrsProfileAttributes != null) {
			return !matchOpenmrsProfileAttributes(openmrsProfileAttributes);
		} else {
			return false;
		}
	}
	public boolean matchOpenmrsProfileAttributes(Map<String, Object> openmrsProfile) {
		Object openmrsPlatformVersion = openmrsProfile.get("openmrsPlatformVersion");
		if (StringUtils.isBlank((String) openmrsPlatformVersion)) {
			openmrsPlatformVersion = openmrsProfile.get("openmrsVersion");
		}
		if (StringUtils.isNotBlank((String) openmrsPlatformVersion)
				&& !ModuleUtil.matchRequiredVersions(OpenmrsConstants.OPENMRS_VERSION_SHORT, (String) openmrsPlatformVersion)) {
			return false;
		}
		String[] modules = (String[]) openmrsProfile.get("modules");
		for (String moduleAndVersion : modules) {
			if ("!".equals(moduleAndVersion.substring(0, 1))) {
				if (ModuleFactory.isModuleStarted(moduleAndVersion.substring(1))) {
					return false;
				}
			}
			else {
				String[] splitModuleAndVersion = moduleAndVersion.split(":");
				String moduleId = splitModuleAndVersion[0];
				String moduleVersion = splitModuleAndVersion[1];
				boolean moduleMatched = false;
				for (Module module : ModuleFactory.getStartedModules()) {
					if (module.getModuleId().equals(moduleId)
							&& ModuleUtil.matchRequiredVersions(module.getVersion(), moduleVersion)) {
						moduleMatched = true;
						break;
					}
				}
				if (!moduleMatched) {
					return false;
				}
			}
		}
		return true;
	}
}