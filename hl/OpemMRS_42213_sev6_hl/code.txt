/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 * 
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.SortedMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import org.aopalliance.aop.Advice;
import org.openmrs.GlobalProperty;
import org.openmrs.Privilege;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.context.Context;
import org.openmrs.api.context.Daemon;
import org.openmrs.module.Extension.MEDIA_TYPE;
import org.openmrs.util.CycleException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.Graph;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Advisor;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
import org.springframework.util.StringUtils;
import liquibase.Contexts;
/**
 * Methods for loading, starting, stopping, and storing OpenMRS modules
 */
public class ModuleFactory {
	
	private ModuleFactory() {
	}
	
	private static final Logger log = LoggerFactory.getLogger(ModuleFactory.class);
	
	protected static final Cache<String, Module> loadedModules = CacheBuilder.newBuilder()
		.softValues().build();
	
	protected static final Cache<String, Module> startedModules = CacheBuilder.newBuilder()
		.softValues().build();
	
	protected static final Map<String, List<Extension>> extensionMap = new HashMap<>();
	
	// maps to keep track of the memory and objects to free/close
	protected static final Cache<Module, ModuleClassLoader> moduleClassLoaders = CacheBuilder.newBuilder().weakKeys()
		.softValues().build();
	
	private static final Map<String, Set<ModuleClassLoader>> providedPackages = new ConcurrentHashMap<>();
	
	// the name of the file within a module file
	private static final String MODULE_CHANGELOG_FILENAME = "liquibase.xml";
	
	private static final Cache<String, DaemonToken> daemonTokens = CacheBuilder.newBuilder().softValues().build();
	
	private static final Set<String> actualStartupOrder = new LinkedHashSet<>();
	
	/**
	 * Add a module (in the form of a jar file) to the list of openmrs modules Returns null if an error
	 * occurred and/or module was not successfully loaded
	 *
	 * @param moduleFile
	 * @return Module
	 */
	public static Module loadModule(File moduleFile) throws ModuleException {
		
		return loadModule(moduleFile, true);
		
	}
	
	/**
	 * Add a module (in the form of a jar file) to the list of openmrs modules Returns null if an error
	 * occurred and/or module was not successfully loaded
	 *
	 * @param moduleFile
	 * @param replaceIfExists unload a module that has the same moduleId if one is loaded already
	 * @return Module
	 */
	public static Module loadModule(File moduleFile, Boolean replaceIfExists) throws ModuleException {
		Module module = new ModuleFileParser(Context.getMessageSourceService()).parse(moduleFile);
		
		if (module != null) {
			loadModule(module, replaceIfExists);
		}
		
		return module;
	}
	
	/**
	 * Add a module to the list of openmrs modules
	 *
	 * @param module
	 * @param replaceIfExists unload a module that has the same moduleId if one is loaded already
	 *            <strong>Should</strong> load module if it is currently not loaded
	 *            <strong>Should</strong> not load module if already loaded <strong>Should</strong>
	 *            always load module if replacement is wanted <strong>Should</strong> not load an older
	 *            version of the same module <strong>Should</strong> load a newer version of the same
	 *            module
	 * @return module the module that was loaded or if the module exists already with the same version,
	 *         the old module
	 */
	public static Module loadModule(Module module, Boolean replaceIfExists) throws ModuleException {
		
		log.debug("Adding module {} to the module queue", module.getName());
		
		Module oldModule = getLoadedModulesMap().get(module.getModuleId());
		if (oldModule != null) {
			int versionComparison = ModuleUtil.compareVersion(oldModule.getVersion(), module.getVersion());
			if (versionComparison < 0) {
				// if oldModule version is lower, unload it and use the new
				unloadModule(oldModule);
			} else if (versionComparison == 0) {
				if (replaceIfExists) {
					// if the versions are the same and we're told to replaceIfExists, use the new
					unloadModule(oldModule);
				} else {
					// if the versions are equal and we're not told to replaceIfExists, jump out of here in a bad way
					throw new ModuleException("A module with the same id and version already exists", module.getModuleId());
				}
			} else {
				// if the older (already loaded) module is newer, keep that original one that was loaded. return that one.
				return oldModule;
			}
		}
		
		getLoadedModulesMap().put(module.getModuleId(), module);
		
		return module;
	}
	
	/**
	 * Load OpenMRS modules from <code>OpenmrsUtil.getModuleRepository()</code>
	 */
	public static void loadModules() {
		
		// load modules from the user's module repository directory
		File modulesFolder = ModuleUtil.getModuleRepository();
		
		log.debug("Loading modules from: {}", modulesFolder.getAbsolutePath());
		
		File[] files = modulesFolder.listFiles();
		if (modulesFolder.isDirectory() && files != null) {
			loadModules(Arrays.asList(files));
		} else {
			log.error("modules folder: '" + modulesFolder.getAbsolutePath() + "' is not a directory or IO error occurred");
		}
	}
	
	/**
	 * Attempt to load the given files as OpenMRS modules
	 *
	 * @param modulesToLoad the list of files to try and load <strong>Should</strong> not crash when
	 *            file is not found or broken <strong>Should</strong> setup requirement mappings for
	 *            every module <strong>Should</strong> not start the loaded modules
	 */
	public static void loadModules(List<File> modulesToLoad) {
		// loop over the modules and load all the modules that we can
		for (File f : modulesToLoad) {
			if (f.exists()) {
				// ignore .svn folder and the like
				if (!f.getName().startsWith(".")) {
					try {
						// last module loaded wins
						Module mod = loadModule(f, true);
						log.debug("Loaded module: " + mod + " successfully");
					}
					catch (Exception e) {
						log.error("Unable to load file in module directory: " + f + ". Skipping file.", e);
					}
				}
			} else {
				log.error("Could not find file in module directory: " + f);
			}
		}
		
		//inform modules, that they can't start before other modules
		
		Map<String, Module> loadedModulesMap = getLoadedModulesMapPackage();
		for (Module m : loadedModulesMap.values()) {
			Map<String, String> startBeforeModules = m.getStartBeforeModulesMap();
			if (startBeforeModules.size() > 0) {
				for (String s : startBeforeModules.keySet()) {
					Module mod = loadedModulesMap.get(s);
					if (mod != null) {
						mod.addRequiredModule(m.getPackageName(), m.getVersion());
					}
				}
			}
		}
	}
	
	/**
	 * Try to start all of the loaded modules that have the global property <i>moduleId</i>.started is
	 * set to "true" or the property does not exist. Otherwise, leave it as only "loaded"<br>
	 * <br>
	 * Modules that are already started will be skipped.
	 */
	public static void startModules() {
		
		// loop over and try starting each of the loaded modules
		if (!getLoadedModules().isEmpty()) {
			
			List<Module> modules = getModulesThatShouldStart();
			
			try {
				modules = getModulesInStartupOrder(modules);
			}
			catch (CycleException ex) {
				String message = getCyclicDependenciesMessage(ex.getMessage());
				log.error(message, ex);
				notifySuperUsersAboutCyclicDependencies(ex);
				modules = (List<Module>) ex.getExtraData();
			}
			
			// try and start the modules that should be started
			for (Module mod : modules) {
				
				if (mod.isStarted()) {
					// skip over modules that are already started
					continue;
				}
				
				// Skip module if required ones are not started
				if (!requiredModulesStarted(mod)) {
					String message = getFailedToStartModuleMessage(mod);
					log.error(message);
					mod.setStartupErrorMessage(message);
					notifySuperUsersAboutModuleFailure(mod);
					continue;
				}
				
				try {
					log.debug("starting module: {}", mod.getModuleId());
					startModule(mod);
				}
				catch (Exception e) {
					log.error("Error while starting module: " + mod.getName(), e);
					mod.setStartupErrorMessage("Error while starting module", e);
					notifySuperUsersAboutModuleFailure(mod);
				}
			}
		}
	}
	
	/**
	 * Obtain the list of modules that should be started
	 *
	 * @return list of modules
	 */
	private static List<Module> getModulesThatShouldStart() {
		List<Module> modules = new ArrayList<>();
		
		AdministrationService adminService = Context.getAdministrationService();
		
		for (Module mod : getLoadedModulesCoreFirst()) {
			
			String key = mod.getModuleId() + ".started";
			String startedProp = adminService.getGlobalProperty(key, null);
			String mandatoryProp = adminService.getGlobalProperty(mod.getModuleId() + ".mandatory", null);
			
			boolean isCoreToOpenmrs = mod.isCore() && !ModuleUtil.ignoreCoreModules();
			
			// if a 'moduleid.started' property doesn't exist, start the module anyway
			// as this is probably the first time they are loading it
			if (startedProp == null || "true".equals(startedProp) || "true".equalsIgnoreCase(mandatoryProp)
				|| mod.isMandatory() || isCoreToOpenmrs) {
				modules.add(mod);
			}
		}
		return modules;
	}
	
	/**
	 * Sort modules in startup order based on required and aware-of dependencies
	 *
	 * @param modules list of modules to sort
	 * @return list of modules sorted by dependencies
	 * @throws CycleException
	 */
	public static List<Module> getModulesInStartupOrder(Collection<Module> modules) throws CycleException {
		Graph<Module> graph = new Graph<>();
		
		for (Module mod : modules) {
			
			graph.addNode(mod);
			
			// Required dependencies
			for (String key : mod.getRequiredModules()) {
				Module module = getModuleByPackage(key);
				Module fromNode = graph.getNode(module);
				if (fromNode == null) {
					fromNode = module;
				}
				
				if (fromNode != null) {
					graph.addEdge(graph.new Edge(
						fromNode,
						mod));
				}
			}
			
			// Aware-of dependencies
			for (String key : mod.getAwareOfModules()) {
				Module module = getModuleByPackage(key);
				Module fromNode = graph.getNode(module);
				if (fromNode == null) {
					fromNode = module;
				}
				
				if (fromNode != null) {
					graph.addEdge(graph.new Edge(
						fromNode,
						mod));
				}
			}
		}
		
		return graph.topologicalSort();
	}
	
	/**
	 * Send an Alert to all super users that the given module did not start successfully.
	 *
	 * @param mod The Module that failed
	 */
	private static void notifySuperUsersAboutModuleFailure(Module mod) {
		try {
			// Add the privileges necessary for notifySuperUsers
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
			
			// Send an alert to all administrators
			Context.getAlertService().notifySuperUsers("Module.startupError.notification.message", null, mod.getName());
		}
		catch (Exception e) {
			log.error("Unable to send an alert to the super users", e);
		}
		finally {
			// Remove added privileges
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
		}
	}
	
	/**
	 * Send an Alert to all super users that modules did not start due to cyclic dependencies
	 */
	private static void notifySuperUsersAboutCyclicDependencies(Exception ex) {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
			Context.getAlertService().notifySuperUsers("Module.error.cyclicDependencies", ex, ex.getMessage());
		}
		catch (Exception e) {
			log.error("Unable to send an alert to the super users", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
		}
	}
	
	/**
	 * Returns all modules found/loaded into the system (started and not started), with the core modules
	 * at the start of that list
	 *
	 * @return <code>List&lt;Module&gt;</code> of the modules loaded into the system, with the core
	 *         modules first.
	 */
	public static List<Module> getLoadedModulesCoreFirst() {
		List<Module> list = new ArrayList<>(getLoadedModules());
		final Collection<String> coreModuleIds = ModuleConstants.CORE_MODULES.keySet();
		list.sort((left, right) -> {
			Integer leftVal = coreModuleIds.contains(left.getModuleId()) ? 0 : 1;
			Integer rightVal = coreModuleIds.contains(right.getModuleId()) ? 0 : 1;
			return leftVal.compareTo(rightVal);
		});
		return list;
	}
	
	/**
	 * Convenience method to return a List of Strings containing a description of which modules the
	 * passed module requires but which are not started. The returned description of each module is the
	 * moduleId followed by the required version if one is specified
	 *
	 * @param module the module to check required modules for
	 * @return List&lt;String&gt; of module names + optional required versions: "org.openmrs.formentry
	 *         1.8, org.rg.patientmatching"
	 */
	private static List<String> getMissingRequiredModules(Module module) {
		List<String> ret = new ArrayList<>();
		for (String moduleName : module.getRequiredModules()) {
			boolean started = false;
			for (Module mod : getStartedModules()) {
				if (mod.getPackageName().equals(moduleName)) {
					String reqVersion = module.getRequiredModuleVersion(moduleName);
					if (reqVersion == null || ModuleUtil.compareVersion(mod.getVersion(), reqVersion) >= 0) {
						started = true;
					}
					break;
				}
			}
			
			if (!started) {
				String moduleVersion = module.getRequiredModuleVersion(moduleName);
				moduleName = moduleName.replace("org.openmrs.module.", "").replace("org.openmrs.", "");
				ret.add(moduleName + (moduleVersion != null ? " " + moduleVersion : ""));
			}
		}
		return ret;
	}
	
	/**
	 * Returns all modules found/loaded into the system (started and not started)
	 *
	 * @return <code>Collection&lt;Module&gt;</code> of the modules loaded into the system
	 */
	public static Collection<Module> getLoadedModules() {
		if (getLoadedModulesMap().size() > 0) {
			return getLoadedModulesMap().values();
		}
		
		return Collections.emptyList();
	}
	
	/**
	 * Returns all modules found/loaded into the system (started and not started) in the form of a
	 * map&lt;ModuleId, Module&gt;
	 *
	 * @return map&lt;ModuleId, Module&gt;
	 */
	public static Map<String, Module> getLoadedModulesMap() {
		return loadedModules.asMap();
	}
	
	/**
	 * Returns all modules found/loaded into the system (started and not started) in the form of a
	 * map&lt;PackageName, Module&gt;
	 *
	 * @return map&lt;PackageName, Module&gt;
	 */
	public static Map<String, Module> getLoadedModulesMapPackage() {
		Map<String, Module> map = new HashMap<>();
		for (Module loadedModule : getLoadedModulesMap().values()) {
			map.put(loadedModule.getPackageName(), loadedModule);
		}
		return map;
	}
	
	/**
	 * Returns the modules that have been successfully started
	 *
	 * @return <code>Collection&lt;Module&gt;</code> of the started modules
	 */
	public static Collection<Module> getStartedModules() {
		if (getStartedModulesMap().size() > 0) {
			return getStartedModulesMap().values();
		}
		
		return Collections.emptyList();
	}
	
	public static List<Module> getStartedModulesInOrder() {
		List<Module> modules = new ArrayList<>();
		if (actualStartupOrder != null) {
			for (String moduleId : actualStartupOrder) {
				modules.add(getStartedModulesMap().get(moduleId));
			}
		} else {
			modules.addAll(getStartedModules());
		}
		return modules;
	}
	
	/**
	 * Returns the modules that have been successfully started in the form of a map&lt;ModuleId,
	 * Module&gt;
	 *
	 * @return Map&lt;ModuleId, Module&gt;
	 */
	public static Map<String, Module> getStartedModulesMap() {
		return startedModules.asMap();
	}
	
	/**
	 * @param moduleId
	 * @return Module matching module id or null if none
	 */
	public static Module getModuleById(String moduleId) {
		return getLoadedModulesMap().get(moduleId);
	}
	
	/**
	 * @param moduleId
	 * @return Module matching moduleId, if it is started or null otherwise
	 */
	public static Module getStartedModuleById(String moduleId) {
		return getStartedModulesMap().get(moduleId);
	}
	
	/**
	 * @param modulePackage
	 * @return Module matching module package or null if none
	 */
	public static Module getModuleByPackage(String modulePackage) {
		for (Module mod : getLoadedModulesMap().values()) {
			if (mod.getPackageName().equals(modulePackage)) {
				return mod;
			}
		}
		return null;
	}
	
	/**
	 * @see #startModule(Module, boolean, AbstractRefreshableApplicationContext)
	 * @see #startModuleInternal(Module)
	 * @see Daemon#startModule(Module)
	 */
	public static Module startModule(Module module) throws ModuleException {
		return startModule(module, false, null);
	}
	
	/**
	 * Runs through extensionPoints and then calls {@link BaseModuleActivator#willStart()} on the
	 * Module's activator. This method is run in a new thread and is authenticated as the Daemon user.
	 * If a non null application context is passed in, it gets refreshed to make the module's services
	 * available
	 *
	 * @param module Module to start
	 * @param isOpenmrsStartup Specifies whether this module is being started at application startup or
	 *            not, this argument is ignored if a null application context is passed in
	 * @param applicationContext the spring application context instance to refresh
	 * @throws ModuleException if the module throws any kind of error at startup or in an activator
	 * @see #startModuleInternal(Module, boolean, AbstractRefreshableApplicationContext)
	 * @see Daemon#startModule(Module, boolean, AbstractRefreshableApplicationContext)
	 */
	public static Module startModule(Module module, boolean isOpenmrsStartup,
		AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		
		if (!requiredModulesStarted(module)) {
			int missingModules = 0;
			
			for (String packageName : module.getRequiredModulesMap().keySet()) {
				Module mod = getModuleByPackage(packageName);
				
				// mod not installed
				if (mod == null) {
					missingModules++;
					continue;
				}
				
				if (!mod.isStarted()) {
					startModule(mod);
				}
			}
			
			if (missingModules > 0) {
				String message = getFailedToStartModuleMessage(module);
				log.error(message);
				module.setStartupErrorMessage(message);
				notifySuperUsersAboutModuleFailure(module);
				// instead of return null, i realized that Daemon.startModule() always returns a Module
				// object,irrespective of whether the startup succeeded
				return module;
			}
		}
		return Daemon.startModule(module, isOpenmrsStartup, applicationContext);
	}
	
	/**
	 * This method should not be called directly.<br>
	 * <br>
	 * The {@link #startModule(Module)} (and hence {@link Daemon#startModule(Module)}) calls this method
	 * in a new Thread and is authenticated as the {@link Daemon} user<br>
	 * <br>
	 * Runs through extensionPoints and then calls {@link BaseModuleActivator#willStart()} on the
	 * Module's activator.
	 *
	 * @param module Module to start
	 */
	public static Module startModuleInternal(Module module) throws ModuleException {
		return startModuleInternal(module, false, null);
	}
	
	/**
	 * This method should not be called directly.<br>
	 * <br>
	 * The {@link #startModule(Module)} (and hence {@link Daemon#startModule(Module)}) calls this method
	 * in a new Thread and is authenticated as the {@link Daemon} user<br>
	 * <br>
	 * Runs through extensionPoints and then calls {@link BaseModuleActivator#willStart()} on the
	 * Module's activator. <br>
	 * <br>
	 * If a non null application context is passed in, it gets refreshed to make the module's services
	 * available
	 *
	 * @param module Module to start
	 * @param isOpenmrsStartup Specifies whether this module is being started at application startup or
	 *            not, this argument is ignored if a null application context is passed in
	 * @param applicationContext the spring application context instance to refresh
	 */
	public static Module startModuleInternal(Module module, boolean isOpenmrsStartup,
		AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		
		if (module != null) {
			String moduleId = module.getModuleId();
			
			try {
				
				// check to be sure this module can run with our current version
				// of OpenMRS code
				String requireVersion = module.getRequireOpenmrsVersion();
				ModuleUtil.checkRequiredVersion(OpenmrsConstants.OPENMRS_VERSION_SHORT, requireVersion);
				
				// check for required modules
				if (!requiredModulesStarted(module)) {
					throw new ModuleException(getFailedToStartModuleMessage(module));
				}
				
				// fire up the classloader for this module
				ModuleClassLoader moduleClassLoader = new ModuleClassLoader(module, ModuleFactory.class.getClassLoader());
				getModuleClassLoaderMap().put(module, moduleClassLoader);
				registerProvidedPackages(moduleClassLoader);
				
				// don't load the advice objects into the Context
				// At startup, the spring context isn't refreshed until all modules
				// have been loaded.  This causes errors if called here during a
				// module's startup if one of these advice points is on another
				// module because that other module's service won't have been loaded
				// into spring yet.  All advice for all modules must be reloaded
				// a spring context refresh anyway
				
				// map extension point to a list of extensions for this module only
				Map<String, List<Extension>> moduleExtensionMap = new HashMap<>();
				for (Extension ext : module.getExtensions()) {
					
					String extId = ext.getExtensionId();
					List<Extension> tmpExtensions = moduleExtensionMap.computeIfAbsent(extId, k -> new ArrayList<>());
					
					tmpExtensions.add(ext);
				}
				
				// Sort this module's extensions, and merge them into the full extensions map
				Comparator<Extension> sortOrder = (e1, e2) -> Integer.valueOf(e1.getOrder()).compareTo(e2.getOrder());
				for (Map.Entry<String, List<Extension>> moduleExtensionEntry : moduleExtensionMap.entrySet()) {
					// Sort this module's extensions for current extension point
					List<Extension> sortedModuleExtensions = moduleExtensionEntry.getValue();
					sortedModuleExtensions.sort(sortOrder);
					
					// Get existing extensions, and append the ones from the new module
					List<Extension> extensions = getExtensionMap().computeIfAbsent(moduleExtensionEntry.getKey(),
						k -> new ArrayList<>());
					for (Extension ext : sortedModuleExtensions) {
						log.debug("Adding to mapping ext: " + ext.getExtensionId() + " ext.class: " + ext.getClass());
						extensions.add(ext);
					}
				}
				
				// run the module's sql update script
				// This and the property updates are the only things that can't
				// be undone at startup, so put these calls after any other
				// calls that might hinder startup
				SortedMap<String, String> diffs = SqlDiffFileParser.getSqlDiffs(module);
				
				try {
					// this method must check and run queries against the database.
					// to do this, it must be "authenticated".  Give the current
					// "user" the proxy privilege so this can be done. ("user" might
					// be nobody because this is being run at startup)
					Context.addProxyPrivilege("");
					
					for (Map.Entry<String, String> entry : diffs.entrySet()) {
						String version = entry.getKey();
						String sql = entry.getValue();
						if (StringUtils.hasText(sql)) {
							runDiff(module, version, sql);
						}
					}
				}
				finally {
					// take the "authenticated" privilege away from the current "user"
					Context.removeProxyPrivilege("");
				}
				
				// run module's optional liquibase.xml immediately after sqldiff.xml
				runLiquibase(module);
				
				// effectively mark this module as started successfully
				getStartedModulesMap().put(moduleId, module);
				actualStartupOrder.add(moduleId);
				
				try {
					// save the state of this module for future restarts
					saveGlobalProperty(moduleId + ".started", "true", getGlobalPropertyStartedDescription(moduleId));
					
					// save the mandatory status
					saveGlobalProperty(moduleId + ".mandatory", String.valueOf(module.isMandatory()),
						getGlobalPropertyMandatoryModuleDescription(moduleId));
				}
				catch (Exception e) {
					// pass over errors because this doesn't really concern startup
					// passing over this also allows for multiple of the same-named modules
					// to be loaded in junit tests that are run within one session
					log.debug("Got an error when trying to set the global property on module startup", e);
				}
				
				// (this must be done after putting the module in the started
				// list)
				// if this module defined any privileges or global properties,
				// make sure they are added to the database
				// (Unfortunately, placing the call here will duplicate work
				// done at initial app startup)
				if (!module.getPrivileges().isEmpty() || !module.getGlobalProperties().isEmpty()) {
					log.debug("Updating core dataset");
					Context.checkCoreDataset();
					// checkCoreDataset() currently doesn't throw an error. If
					// it did, it needs to be
					// caught and the module needs to be stopped and given a
					// startup error
				}
				
				// should be near the bottom so the module has all of its stuff
				// set up for it already.
				try {
					if (module.getModuleActivator() != null) {
						// if extends BaseModuleActivator
						module.getModuleActivator().willStart();
					}
				}
				catch (ModuleException e) {
					// just rethrow module exceptions. This should be used for a
					// module marking that it had trouble starting
					throw e;
				}
				catch (Exception e) {
					throw new ModuleException("Error while calling module's Activator.startup()/willStart() method", e);
				}
				
				// erase any previous startup error
				module.clearStartupError();
			}
			catch (Exception e) {
				log.warn("Error while trying to start module: " + moduleId, e);
				module.setStartupErrorMessage("Error while trying to start module", e);
				notifySuperUsersAboutModuleFailure(module);
				// undo all of the actions in startup
				try {
					boolean skipOverStartedProperty = false;
					
					if (e instanceof ModuleMustStartException) {
						skipOverStartedProperty = true;
					}
					
					stopModule(module, skipOverStartedProperty, true);
				}
				catch (Exception e2) {
					// this will probably occur about the same place as the
					// error in startup
					log.debug("Error while stopping module: " + moduleId, e2);
				}
			}
			
		}
		
		if (applicationContext != null) {
			ModuleUtil.refreshApplicationContext(applicationContext, isOpenmrsStartup, module);
		}
		
		return module;
	}
	
	private static void registerProvidedPackages(ModuleClassLoader moduleClassLoader) {
		for (String providedPackage : moduleClassLoader.getProvidedPackages()) {
			Set<ModuleClassLoader> newSet = new HashSet<>();
			
			Set<ModuleClassLoader> set = providedPackages.get(providedPackage);
			if (set != null) {
				newSet.addAll(set);
			}
			
			newSet.add(moduleClassLoader);
			providedPackages.put(providedPackage, newSet);
		}
	}
	
	private static void unregisterProvidedPackages(ModuleClassLoader moduleClassLoader) {
		for (String providedPackage : moduleClassLoader.getProvidedPackages()) {
			Set<ModuleClassLoader> newSet = new HashSet<>();
			
			Set<ModuleClassLoader> set = providedPackages.get(providedPackage);
			if (set != null) {
				newSet.addAll(set);
			}
			newSet.remove(moduleClassLoader);
			
			providedPackages.put(providedPackage, newSet);
		}
	}
	
	public static Set<ModuleClassLoader> getModuleClassLoadersForPackage(String packageName) {
		Set<ModuleClassLoader> set = providedPackages.get(packageName);
		if (set == null) {
			return Collections.emptySet();
		} else {
			return new HashSet<>(set);
		}
	}
	
	/**
	 * Gets the error message of a module which fails to start.
	 *
	 * @param module the module that has failed to start.
	 * @return the message text.
	 */
	private static String getFailedToStartModuleMessage(Module module) {
		String[] params = { module.getName(), String.join(",", getMissingRequiredModules(module)) };
		return Context.getMessageSourceService().getMessage("Module.error.moduleCannotBeStarted", params,
			Context.getLocale());
	}
	
	/**
	 * Gets the error message of cyclic dependencies between modules
	 *
	 * @return the message text.
	 */
	private static String getCyclicDependenciesMessage(String message) {
		return Context.getMessageSourceService().getMessage("Module.error.cyclicDependencies", new Object[] { message },
			Context.getLocale());
	}
	
	/**
	 * Loop over the given module's advice objects and load them into the Context This needs to be
	 * called for all started modules after every restart of the Spring Application Context
	 *
	 * @param module
	 */
	public static void loadAdvice(Module module) {
		for (AdvicePoint advice : module.getAdvicePoints()) {
			Class<?> cls;
			try {
				cls = Context.loadClass(advice.getPoint());
				Object aopObject = advice.getClassInstance();
				if (aopObject instanceof Advisor) {
					log.debug("adding advisor [{}]", aopObject.getClass());
					Context.addAdvisor(cls, (Advisor) aopObject);
				} else if (aopObject != null) {
					log.debug("adding advice [{}]", aopObject.getClass());
					Context.addAdvice(cls, (Advice) aopObject);
				} else {
					log.debug("Could not load advice class for {} [{}]", advice.getPoint(), advice.getClassName());
				}
			}
			catch (ClassNotFoundException | NoClassDefFoundError e) {
				log.warn("Could not load advice point [{}]", advice.getPoint(), e);
			}
		}
	}
	
	/**
	 * Execute the given sql diff section for the given module
	 *
	 * @param module the module being executed on
	 * @param version the version of this sql diff
	 * @param sql the actual sql statements to run (separated by semi colons)
	 */
	private static void runDiff(Module module, String version, String sql) {
		AdministrationService as = Context.getAdministrationService();
		
		String key = module.getModuleId() + ".database_version";
		GlobalProperty gp = as.getGlobalPropertyObject(key);
		
		boolean executeSQL = false;
		
		// check given version against current version
		if (gp != null && StringUtils.hasLength(gp.getPropertyValue())) {
			String currentDbVersion = gp.getPropertyValue();
			if (log.isDebugEnabled()) {
				log.debug("version:column {}:{}", version, currentDbVersion);
				log.debug("compare: {}", ModuleUtil.compareVersion(version, currentDbVersion));
			}
			if (ModuleUtil.compareVersion(version, currentDbVersion) > 0) {
				executeSQL = true;
			}
		} else {
			executeSQL = true;
		}
		
		// version is greater than the currently installed version. execute this update.
		if (executeSQL) {
			try {
				Context.addProxyPrivilege(PrivilegeConstants.SQL_LEVEL_ACCESS);
				log.debug("Executing sql: " + sql);
				String[] sqlStatements = sql.split(";");
				for (String sqlStatement : sqlStatements) {
					if (sqlStatement.trim().length() > 0) {
						as.executeSQL(sqlStatement, false);
					}
				}
			}
			finally {
				Context.removeProxyPrivilege(PrivilegeConstants.SQL_LEVEL_ACCESS);
			}
			
			// save the global property
			try {
				Context.addProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
				
				String description = "DO NOT MODIFY.  Current database version number for the " + module.getModuleId()
					+ " module.";
				
				if (gp == null) {
					log.info("Global property " + key + " was not found. Creating one now.");
					gp = new GlobalProperty(key, version, description);
					as.saveGlobalProperty(gp);
				} else if (!gp.getPropertyValue().equals(version)) {
					log.info("Updating global property " + key + " to version: " + version);
					gp.setDescription(description);
					gp.setPropertyValue(version);
					as.saveGlobalProperty(gp);
				} else {
					log.error("Should not be here. GP property value and sqldiff version should not be equal");
				}
				
			}
			finally {
				Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			}
			
		}
		
	}
	
	/**
	 * Execute all not run changeSets in liquibase.xml for the given module
	 *
	 * @param module the module being executed on
	 */
	private static void runLiquibase(Module module) {
		ModuleClassLoader moduleClassLoader = getModuleClassLoader(module);
		boolean liquibaseFileExists = false;
		
		if (moduleClassLoader != null) {
			try (InputStream inStream = moduleClassLoader.getResourceAsStream(MODULE_CHANGELOG_FILENAME)) {
				liquibaseFileExists = (inStream != null);
			}
			catch (IOException ignored) {
				
			}
		}
		
		if (liquibaseFileExists) {
			try {
				// run liquibase.xml by Liquibase API
				DatabaseUpdater.executeChangelog(MODULE_CHANGELOG_FILENAME, new Contexts(), null, moduleClassLoader);
			}
			catch (InputRequiredException e) {
				// the user would be stepped through the questions returned here.
				throw new ModuleException("Input during database updates is not yet implemented.", module.getName(), e);
			}
			catch (Exception e) {
				throw new ModuleException("Unable to update data model using " + MODULE_CHANGELOG_FILENAME + ".",
					module.getName(), e);
			}
		}
	}
	
	/**
	 * Runs through the advice and extension points and removes from api. <br>
	 * Also calls mod.Activator.shutdown()
	 *
	 * @param mod module to stop
	 * @see ModuleFactory#stopModule(Module, boolean, boolean)
	 */
	public static void stopModule(Module mod) {
		stopModule(mod, false, false);
	}
	
	/**
	 * Runs through the advice and extension points and removes from api.<br>
	 * Also calls mod.Activator.shutdown()
	 *
	 * @param mod the module to stop
	 * @param isShuttingDown true if this is called during the process of shutting down openmrs
	 * @see #stopModule(Module, boolean, boolean)
	 */
	public static void stopModule(Module mod, boolean isShuttingDown) {
		stopModule(mod, isShuttingDown, false);
	}
	
	/**
	 * Runs through the advice and extension points and removes from api.<br>
	 * <code>skipOverStartedProperty</code> should only be true when openmrs is stopping modules because
	 * it is shutting down. When normally stopping a module, use {@link #stopModule(Module)} (or leave
	 * value as false). This property controls whether the globalproperty is set for startup/shutdown.
	 * <br>
	 * Also calls module's {@link ModuleActivator#stopped()}
	 *
	 * @param mod module to stop
	 * @param skipOverStartedProperty true if we don't want to set &lt;moduleid&gt;.started to false
	 * @param isFailedStartup true if this is being called as a cleanup because of a failed module
	 *            startup
	 * @return list of dependent modules that were stopped because this module was stopped. This will
	 *         never be null.
	 */
	public static List<Module> stopModule(Module mod, boolean skipOverStartedProperty, boolean isFailedStartup)
		throws ModuleMustStartException {
		
		List<Module> dependentModulesStopped = new ArrayList<>();
		
		if (mod != null) {
			
			if (!ModuleFactory.isModuleStarted(mod)) {
				return dependentModulesStopped;
			}
			
			try {
				// if extends BaseModuleActivator
				if (mod.getModuleActivator() != null) {
					mod.getModuleActivator().willStop();
				}
			}
			catch (Exception t) {
				log.warn("Unable to call module's Activator.willStop() method", t);
			}
			
			String moduleId = mod.getModuleId();
			
			// don't allow mandatory modules to be stopped
			// don't use database checks here because spring might be in a bad state
			if (!isFailedStartup && mod.isMandatory()) {
				throw new MandatoryModuleException(moduleId);
			}
			
			if (!isFailedStartup && ModuleConstants.CORE_MODULES.containsKey(moduleId)) {
				throw new OpenmrsCoreModuleException(moduleId);
			}
			
			String modulePackage = mod.getPackageName();
			
			// stop all dependent modules
			// copy modules to new list to avoid "concurrent modification exception"
			List<Module> startedModulesCopy = new ArrayList<>(getStartedModules());
			for (Module dependentModule : startedModulesCopy) {
				if (dependentModule != null && !dependentModule.equals(mod)
					&& isModuleRequiredByAnother(dependentModule, modulePackage)) {
					dependentModulesStopped.add(dependentModule);
					dependentModulesStopped.addAll(stopModule(dependentModule, skipOverStartedProperty, isFailedStartup));
				}
			}
			
			getStartedModulesMap().remove(moduleId);
			if (actualStartupOrder != null) {
				actualStartupOrder.remove(moduleId);
				for (Module depModule : dependentModulesStopped) {
					actualStartupOrder.remove(depModule.getModuleId());
				}
			}
			
			if (!skipOverStartedProperty && !Context.isRefreshingContext()) {
				saveGlobalProperty(moduleId + ".started", "false", getGlobalPropertyStartedDescription(moduleId));
			}
			
			ModuleClassLoader moduleClassLoader = getModuleClassLoaderMap().get(mod);
			if (moduleClassLoader != null) {
				unregisterProvidedPackages(moduleClassLoader);
				
				log.debug("Mod was in classloader map.  Removing advice and extensions.");
				// remove all advice by this module
				try {
					for (AdvicePoint advice : mod.getAdvicePoints()) {
						Class cls;
						try {
							cls = Context.loadClass(advice.getPoint());
							Object aopObject = advice.getClassInstance();
							if (aopObject instanceof Advisor) {
								log.debug("adding advisor: " + aopObject.getClass());
								Context.removeAdvisor(cls, (Advisor) aopObject);
							} else {
								log.debug("Adding advice: " + aopObject.getClass());
								Context.removeAdvice(cls, (Advice) aopObject);
							}
						}
						catch (Exception t) {
							log.warn("Could not remove advice point: " + advice.getPoint(), t);
						}
					}
				}
				catch (Exception t) {
					log.warn("Error while getting advicePoints from module: " + moduleId, t);
				}
				
				// remove all extensions by this module
				try {
					for (Extension ext : mod.getExtensions()) {
						String extId = ext.getExtensionId();
						try {
							List<Extension> tmpExtensions = getExtensions(extId);
							tmpExtensions.remove(ext);
							getExtensionMap().put(extId, tmpExtensions);
						}
						catch (Exception exterror) {
							log.warn("Error while getting extension: " + ext, exterror);
						}
					}
				}
				catch (Exception t) {
					log.warn("Error while getting extensions from module: " + moduleId, t);
				}
			}
			
			//Run the onShutdown() method for openmrs services in this module.
			List<OpenmrsService> services = Context.getModuleOpenmrsServices(modulePackage);
			if (services != null) {
				for (OpenmrsService service : services) {
					service.onShutdown();
				}
			}
			
			try {
				if (mod.getModuleActivator() != null) {// extends BaseModuleActivator
					mod.getModuleActivator().stopped();
				}
			}
			catch (Exception t) {
				log.warn("Unable to call module's Activator.shutdown() method", t);
			}
			
			//Since extensions are loaded by the module class loader which is about to be disposed,
			//we need to clear them, else we shall never be able to unload the class loader until
			//when we unload the module, hence resulting into two problems:
			// 1) Memory leakage for start/stop module.
			// 2) Calls to Context.getService(Service.class) which are made within these extensions 
			//	  will throw APIException("Service not found: ") because their calls to Service.class
			//    will pass in a Class from the old module class loader (which loaded them) yet the
			//    ServiceContext will have new services from a new module class loader.
			//
			//Same thing applies to activator, moduleActivator and AdvicePoint classInstance.
			mod.getExtensions().clear();
			mod.setModuleActivator(null);
			mod.disposeAdvicePointsClassInstance();
			
			ModuleClassLoader cl = removeClassLoader(mod);
			if (cl != null) {
				cl.dispose();
				// remove files from lib cache
				File folder = OpenmrsClassLoader.getLibCacheFolder();
				File tmpModuleDir = new File(folder, moduleId);
				try {
					OpenmrsUtil.deleteDirectory(tmpModuleDir);
				}
				catch (IOException e) {
					log.warn("Unable to delete libcachefolder for " + moduleId);
				}
			}
		}
		
		return dependentModulesStopped;
	}
	
	/**
	 * Checks if a module is required by another
	 *
	 * @param dependentModule the module whose required modules are to be checked
	 * @param modulePackage the package of the module to check if required by another
	 * @return true if the module is required, else false
	 */
	private static boolean isModuleRequiredByAnother(Module dependentModule, String modulePackage) {
		return dependentModule.getRequiredModules() != null && dependentModule.getRequiredModules().contains(modulePackage);
	}
	
	private static ModuleClassLoader removeClassLoader(Module mod) {
		// create map if it is null
		ModuleClassLoader cl = moduleClassLoaders.getIfPresent(mod);
		if (cl == null) {
			log.warn("Module: " + mod.getModuleId() + " does not exist");
		}
		
		moduleClassLoaders.invalidate(mod);
		
		return cl;
	}
	
	/**
	 * Removes module from module repository
	 *
	 * @param mod module to unload
	 */
	public static void unloadModule(Module mod) {
		
		// remove this module's advice and extensions
		if (isModuleStarted(mod)) {
			stopModule(mod, true);
		}
		
		// remove from list of loaded modules
		getLoadedModules().remove(mod);
		
		if (mod != null) {
			// remove the file from the module repository
			File file = mod.getFile();
			
			boolean deleted = file.delete();
			if (!deleted) {
				file.deleteOnExit();
				log.warn("Could not delete " + file.getAbsolutePath());
			}
			
		}
	}
	
	/**
	 * Return all of the extensions associated with the given <code>pointId</code> Returns empty
	 * extension list if no modules extend this pointId
	 *
	 * @param pointId
	 * @return List of extensions
	 */
	public static List<Extension> getExtensions(String pointId) {
		List<Extension> extensions;
		Map<String, List<Extension>> extensionMap = getExtensionMap();
		
		// get all extensions for this exact pointId
		extensions = extensionMap.get(pointId);
		if (extensions == null) {
			extensions = new ArrayList<>();
		}
		
		// if this pointId doesn't contain the separator character, search
		// for this point prepended with each MEDIA TYPE
		if (!pointId.contains(Extension.EXTENSION_ID_SEPARATOR)) {
			for (MEDIA_TYPE mediaType : Extension.MEDIA_TYPE.values()) {
				
				// get all extensions for this type and point id
				List<Extension> tmpExtensions = extensionMap.get(Extension.toExtensionId(pointId, mediaType));
				
				// 'extensions' should be a unique list
				if (tmpExtensions != null) {
					for (Extension ext : tmpExtensions) {
						if (!extensions.contains(ext)) {
							extensions.add(ext);
						}
					}
				}
			}
		}
		
		log.debug("Getting extensions defined by : " + pointId);
		return extensions;
	}
	
	/**
	 * Return all of the extensions associated with the given <code>pointId</code> Returns
	 * getExtension(pointId) if no modules extend this pointId for given media type
	 *
	 * @param pointId
	 * @param type Extension.MEDIA_TYPE
	 * @return List of extensions
	 */
	public static List<Extension> getExtensions(String pointId, Extension.MEDIA_TYPE type) {
		String key = Extension.toExtensionId(pointId, type);
		List<Extension> extensions = getExtensionMap().get(key);
		if (extensions != null) {
			log.debug("Getting extensions defined by : " + key);
			return extensions;
		} else {
			return getExtensions(pointId);
		}
	}
	
	/**
	 * Get a list of required Privileges defined by the modules
	 *
	 * @return <code>List&lt;Privilege&gt;</code> of the required privileges
	 */
	public static List<Privilege> getPrivileges() {
		
		List<Privilege> privileges = new ArrayList<>();
		
		for (Module mod : getStartedModules()) {
			privileges.addAll(mod.getPrivileges());
		}
		
		log.debug(privileges.size() + " new privileges");
		
		return privileges;
	}
	
	/**
	 * Get a list of required GlobalProperties defined by the modules
	 *
	 * @return <code>List&lt;GlobalProperty&gt;</code> object of the module's global properties
	 */
	public static List<GlobalProperty> getGlobalProperties() {
		
		List<GlobalProperty> globalProperties = new ArrayList<>();
		
		for (Module mod : getStartedModules()) {
			globalProperties.addAll(mod.getGlobalProperties());
		}
		
		log.debug(globalProperties.size() + " new global properties");
		
		return globalProperties;
	}
	
	/**
	 * Checks whether the given module is activated
	 *
	 * @param mod Module to check
	 * @return true if the module is started, false otherwise
	 */
	public static boolean isModuleStarted(Module mod) {
		return getStartedModulesMap().containsValue(mod);
	}
	
	/**
	 * Checks whether the given module, identified by its id, is started.
	 *
	 * @param moduleId module id. e.g formentry, logic
	 * @since 1.9
	 * @return true if the module is started, false otherwise
	 */
	public static boolean isModuleStarted(String moduleId) {
		return getStartedModulesMap().containsKey(moduleId);
	}
	
	/**
	 * Get a module's classloader
	 *
	 * @param mod Module to fetch the class loader for
	 * @return ModuleClassLoader pertaining to this module. Returns null if the module is not started
	 * @throws ModuleException if the module does not have a registered classloader
	 */
	public static ModuleClassLoader getModuleClassLoader(Module mod) throws ModuleException {
		ModuleClassLoader mcl = getModuleClassLoaderMap().get(mod);
		
		if (mcl == null) {
			log.debug("Module classloader not found for module with id: " + mod.getModuleId());
		}
		
		return mcl;
	}
	
	/**
	 * Get a module's classloader via the module id
	 *
	 * @param moduleId <code>String</code> id of the module
	 * @return ModuleClassLoader pertaining to this module. Returns null if the module is not started
	 * @throws ModuleException if this module isn't started or doesn't have a classloader
	 * @see #getModuleClassLoader(Module)
	 */
	public static ModuleClassLoader getModuleClassLoader(String moduleId) throws ModuleException {
		Module mod = getStartedModulesMap().get(moduleId);
		if (mod == null) {
			log.debug("Module id not found in list of started modules: " + moduleId);
		}
		
		return getModuleClassLoader(mod);
	}
	
	/**
	 * Returns all module classloaders This method will not return null
	 *
	 * @return Collection&lt;ModuleClassLoader&gt; all known module classloaders or empty list.
	 */
	public static Collection<ModuleClassLoader> getModuleClassLoaders() {
		Map<Module, ModuleClassLoader> classLoaders = getModuleClassLoaderMap();
		if (classLoaders.size() > 0) {
			return classLoaders.values();
		}
		
		return Collections.emptyList();
	}
	
	/**
	 * Return all current classloaders keyed on module object
	 *
	 * @return Map&lt;Module, ModuleClassLoader&gt;
	 */
	public static Map<Module, ModuleClassLoader> getModuleClassLoaderMap() {
		// because the OpenMRS classloader depends on this static function, it is weirdly possible for this to get called
		// as this classfile is loaded, in which case, the static final field can be null.
		if (moduleClassLoaders == null) {
			return Collections.emptyMap();
		}
		
		return moduleClassLoaders.asMap();
	}
	
	/**
	 * Return the current extension map keyed on extension point id
	 *
	 * @return Map&lt;String, List&lt;Extension&gt;&gt;
	 */
	public static Map<String, List<Extension>> getExtensionMap() {
		return extensionMap;
	}
	
	/**
	 * Tests whether all modules mentioned in module.requiredModules are loaded and started already (by
	 * being in the startedModules list)
	 *
	 * @param module
	 * @return true/false boolean whether this module's required modules are all started
	 */
	private static boolean requiredModulesStarted(Module module) {
		//required
		for (String reqModPackage : module.getRequiredModules()) {
			boolean started = false;
			for (Module mod : getStartedModules()) {
				if (mod.getPackageName().equals(reqModPackage)) {
					String reqVersion = module.getRequiredModuleVersion(reqModPackage);
					if (reqVersion == null || ModuleUtil.compareVersion(mod.getVersion(), reqVersion) >= 0) {
						started = true;
					}
					break;
				}
			}
			
			if (!started) {
				return false;
			}
		}
		
		return true;
	}
	
	/**
	 * Update the module: 1) Download the new module 2) Unload the old module 3) Load/start the new
	 * module
	 *
	 * @param mod
	 */
	public static Module updateModule(Module mod) throws ModuleException {
		if (mod.getDownloadURL() == null) {
			return mod;
		}
		
		URL url;
		try {
			url = new URL(mod.getDownloadURL());
		}
		catch (MalformedURLException e) {
			throw new ModuleException("Unable to download module update", e);
		}
		
		unloadModule(mod);
		
		// copy content to a temporary file
		InputStream inputStream = ModuleUtil.getURLStream(url);
		log.warn("url pathname: " + url.getPath());
		String filename = url.getPath().substring(url.getPath().lastIndexOf("/"));
		File moduleFile = ModuleUtil.insertModuleFile(inputStream, filename);
		
		try {
			// load, and start the new module
			Module newModule = loadModule(moduleFile);
			startModule(newModule);
			return newModule;
		}
		catch (Exception e) {
			log.warn("Error while unloading old module and loading in new module");
			moduleFile.delete();
			return mod;
		}
		
	}
	
	/**
	 * Validates the given token.
	 * <p>
	 * It is thread safe.
	 *
	 * @param token
	 * @since 1.9.2
	 */
	public static boolean isTokenValid(DaemonToken token) {
		if (token == null) {
			return false;
		} else {
			//We need to synchronize to guarantee that the last passed token is valid.
			synchronized (daemonTokens) {
				DaemonToken validToken = daemonTokens.getIfPresent(token.getId());
				//Compare by reference to defend from overridden equals.
				return validToken != null && validToken == token;
			}
		}
	}
	
	/**
	 * Passes a daemon token to the given module.
	 * <p>
	 * The token is passed to that module's {@link ModuleActivator} if it implements
	 * {@link DaemonTokenAware}.
	 * <p>
	 * This method is called automatically before {@link ModuleActivator#contextRefreshed()} or
	 * {@link ModuleActivator#started()}. Note that it may be called multiple times and there is no
	 * guarantee that it will always pass the same token. The last passed token is valid, whereas
	 * previously passed tokens may be invalidated.
	 * <p>
	 * It is thread safe.
	 *
	 * @param module
	 * @since 1.9.2
	 */
	static void passDaemonToken(Module module) {
		ModuleActivator moduleActivator = module.getModuleActivator();
		if (moduleActivator instanceof DaemonTokenAware) {
			DaemonToken daemonToken = getDaemonToken(module);
			((DaemonTokenAware) module.getModuleActivator()).setDaemonToken(daemonToken);
		}
	}
	
	/**
	 * Gets a new or existing token. Uses weak references for tokens so that they are garbage collected
	 * when not needed.
	 * <p>
	 * It is thread safe.
	 *
	 * @param module
	 * @return the token
	 */
	private static DaemonToken getDaemonToken(Module module) {
		DaemonToken token;
		try {
			token = daemonTokens.get(module.getModuleId(), () -> new DaemonToken(module.getModuleId()));
		}
		catch (ExecutionException e) {
			throw new APIException(e);
		}
		
		return token;
	}
	
	/**
	 * Returns the description for the [moduleId].started global property
	 *
	 * @param moduleId
	 * @return description to use for the .started property
	 */
	private static String getGlobalPropertyStartedDescription(String moduleId) {
		String ret = "DO NOT MODIFY. true/false whether or not the " + moduleId;
		ret += " module has been started.  This is used to make sure modules that were running ";
		ret += " prior to a restart are started again";
		
		return ret;
	}
	
	/**
	 * Returns the description for the [moduleId].mandatory global property
	 *
	 * @param moduleId
	 * @return description to use for .mandatory property
	 */
	private static String getGlobalPropertyMandatoryModuleDescription(String moduleId) {
		String ret = "true/false whether or not the " + moduleId;
		ret += " module MUST start when openmrs starts.  This is used to make sure that mission critical";
		ret += " modules are always running if openmrs is running.";
		
		return ret;
	}
	
	/**
	 * Convenience method to save a global property with the given value. Proxy privileges are added so
	 * that this can occur at startup.
	 *
	 * @param key the property for this global property
	 * @param value the value for this global property
	 * @param desc the description
	 * @see AdministrationService#saveGlobalProperty(GlobalProperty)
	 */
	private static void saveGlobalProperty(String key, String value, String desc) {
		try {
			AdministrationService as = Context.getAdministrationService();
			GlobalProperty gp = as.getGlobalPropertyObject(key);
			if (gp == null) {
				gp = new GlobalProperty(key, value, desc);
			} else {
				gp.setPropertyValue(value);
			}
			
			as.saveGlobalProperty(gp);
		}
		catch (Exception e) {
			log.warn("Unable to save the global property", e);
		}
	}
	
	/**
	 * Convenience method used to identify module interdependencies and alert the user before modules
	 * are shut down.
	 *
	 * @param moduleId the moduleId used to identify the module being validated
	 * @return List&lt;dependentModules&gt; the list of moduleId's which depend on the module about to
	 *         be shutdown.
	 * @since 1.10
	 */
	public static List<String> getDependencies(String moduleId) {
		List<String> dependentModules = null;
		Module module = getModuleById(moduleId);
		
		Map<String, Module> startedModules = getStartedModulesMap();
		String modulePackage = module.getPackageName();
		
		for (Entry<String, Module> entry : startedModules.entrySet()) {
			if (!moduleId.equals(entry.getKey()) && entry.getValue().getRequiredModules().contains(modulePackage)) {
				if (dependentModules == null) {
					dependentModules = new ArrayList<>();
				}
				dependentModules.add(entry.getKey() + " " + entry.getValue().getVersion());
			}
		}
		return dependentModules;
	}
}

/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.openmrs.GlobalProperty;
import org.openmrs.Privilege;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
/**
 * Generic module class that openmrs manipulates
 *
 * @version 1.0
 */
public final class Module {
	
	private static final Logger log = LoggerFactory.getLogger(Module.class);
	
	private String name;
	
	private String moduleId;
	
	private String packageName;
	
	private String description;
	
	private String author;
	
	private String version;
	
	private String updateURL; // should be a URL to an update.rdf file
	
	private String updateVersion = null; // version obtained from the remote update.rdf file
	
	private String downloadURL = null; // will only be populated when the remote file is newer than the current module
	
	private ModuleActivator moduleActivator;
	
	private String activatorName;
	
	private String requireOpenmrsVersion;
	
	private String requireDatabaseVersion;
	
	private Map<String, String> requiredModulesMap;
	
	private Map<String, String> awareOfModulesMap;
	
	private Map<String, String> startBeforeModulesMap;
	
	private List<AdvicePoint> advicePoints = new ArrayList<>();
	
	private Map<String, String> extensionNames = new IdentityHashMap<>();
	
	private List<Extension> extensions = new ArrayList<>();
	
	private Map<String, Properties> messages = new HashMap<>();
	
	private List<Privilege> privileges = new ArrayList<>();
	
	private List<GlobalProperty> globalProperties = new ArrayList<>();
	
	private List<String> mappingFiles = new ArrayList<>();
	
	private Set<String> packagesWithMappedClasses = new HashSet<>();
	
	private String configVersion;
	
	private Document config = null;
	
	private Document sqldiff = null;
	
	private boolean mandatory = Boolean.FALSE;
	
	private List<ModuleConditionalResource> conditionalResources = new ArrayList<>();
	
	// keep a reference to the file that we got this module from so we can delete
	// it if necessary
	private File file = null;
	
	private String startupErrorMessage = null;
	
	/**
	 * Simple constructor
	 *
	 * @param name
	 */
	public Module(String name) {
		this.name = name;
	}
	
	/**
	 * Main constructor
	 *
	 * @param name
	 * @param moduleId
	 * @param packageName
	 * @param author
	 * @param description
	 * @param version
	 */
	public Module(String name, String moduleId, String packageName, String author, String description, String version,
				  String configVersion) {
		this.name = name;
		this.moduleId = moduleId;
		this.packageName = packageName;
		this.author = author;
		this.description = description;
		this.version = version;
		this.configVersion = configVersion;
		log.debug("Creating module " + name);
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj != null && obj instanceof Module) {
			Module mod = (Module) obj;
			return getModuleId().equals(mod.getModuleId());
		}
		return false;
	}
	
	@Override
	public int hashCode() {
		return new HashCodeBuilder().append(getModuleId()).toHashCode();
	}
	
	/**
	 * @return the moduleActivator
	 */
	public ModuleActivator getModuleActivator() {
		try {
			if (moduleActivator == null) {
				ModuleClassLoader classLoader = ModuleFactory.getModuleClassLoader(this);
				if (classLoader == null) {
					throw new ModuleException("The classloader is null", getModuleId());
				}
				
				Class<?> c = classLoader.loadClass(getActivatorName());
				Object o = c.newInstance();
				if (ModuleActivator.class.isAssignableFrom(o.getClass())) {
					setModuleActivator((ModuleActivator) o);
				}
			}
			
		}
		catch (ClassNotFoundException | NoClassDefFoundError e) {
			
			throw new ModuleException("Unable to load/find moduleActivator: '" + getActivatorName() + "'", name, e);
		}
		catch (IllegalAccessException e) {
			throw new ModuleException("Unable to load/access moduleActivator: '" + getActivatorName() + "'", name, e);
		}
		catch (InstantiationException e) {
			throw new ModuleException("Unable to load/instantiate moduleActivator: '" + getActivatorName() + "'", name, e);
		}
		return moduleActivator;
	}
	
	/**
	 * @param moduleActivator the moduleActivator to set
	 */
	public void setModuleActivator(ModuleActivator moduleActivator) {
		this.moduleActivator = moduleActivator;
	}
	
	/**
	 * @return the activatorName
	 */
	public String getActivatorName() {
		return activatorName;
	}
	
	/**
	 * @param activatorName the activatorName to set
	 */
	public void setActivatorName(String activatorName) {
		this.activatorName = activatorName;
	}
	
	/**
	 * @return the author
	 */
	public String getAuthor() {
		return author;
	}
	
	/**
	 * @param author the author to set
	 */
	public void setAuthor(String author) {
		this.author = author;
	}
	
	/**
	 * @return the description
	 */
	public String getDescription() {
		return description;
	}
	
	/**
	 * @param description the description to set
	 */
	public void setDescription(String description) {
		this.description = description;
	}
	
	/**
	 * @return the name
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * @param name the name to set
	 */
	public void setName(String name) {
		this.name = name;
	}
	
	/**
	 * @return the requireDatabaseVersion
	 */
	public String getRequireDatabaseVersion() {
		return requireDatabaseVersion;
	}
	
	/**
	 * @param requireDatabaseVersion the requireDatabaseVersion to set
	 */
	public void setRequireDatabaseVersion(String requireDatabaseVersion) {
		this.requireDatabaseVersion = requireDatabaseVersion;
	}
	
	/**
	 * This list of strings is just what is included in the config.xml file, the full package names:
	 * e.g. org.openmrs.module.formentry
	 *
	 * @return the list of requiredModules
	 */
	public List<String> getRequiredModules() {
		return requiredModulesMap == null ? null : new ArrayList<>(requiredModulesMap.keySet());
	}
	
	/**
	 * Convenience method to get the version of this given module that is required
	 *
	 * @return the version of the given required module, or null if there are no version constraints
	 * @since 1.5
	 * <strong>Should</strong> return null if no required modules exist
	 * <strong>Should</strong> return null if no required module by given name exists
	 */
	public String getRequiredModuleVersion(String moduleName) {
		return requiredModulesMap == null ? null : requiredModulesMap.get(moduleName);
	}
	
	/**
	 * This is a convenience method to set all the required modules without any version requirements
	 *
	 * @param requiredModules the requiredModules to set for this module
	 * <strong>Should</strong> set modules when there is a null required modules map
	 */
	public void setRequiredModules(List<String> requiredModules) {
		if (requiredModulesMap == null) {
			requiredModulesMap = new HashMap<>();
		}
		
		for (String module : requiredModules) {
			requiredModulesMap.put(module, null);
		}
	}
	
	/**
	 * @param requiredModule the requiredModule to add for this module
	 * @param version version requiredModule
	 * <strong>Should</strong> add module to required modules map
	 */
	public void addRequiredModule(String requiredModule, String version) {
		if (requiredModulesMap != null) {
			requiredModulesMap.put(requiredModule, version);
		}
	}
	
	/**
	 * @param requiredModulesMap <code>Map&lt;String,String&gt;</code> of the <code>requiredModule</code>s
	 *            to set
	 * @since 1.5
	 */
	public void setRequiredModulesMap(Map<String, String> requiredModulesMap) {
		this.requiredModulesMap = requiredModulesMap;
	}
	
	/**
	 * Get the modules that are required for this module. The keys in this map are the module
	 * package names. The values in the map are the required version. If no specific version is
	 * required, it will be null.
	 *
	 * @return a map from required module to the version that is required
	 */
	public Map<String, String> getRequiredModulesMap() {
		return requiredModulesMap;
	}
	
	/**
	 * Sets modules that must start after this module
	 * @param startBeforeModulesMap the startedBefore modules to set
	 */
	public void setStartBeforeModulesMap(Map<String, String> startBeforeModulesMap) {
		this.startBeforeModulesMap = startBeforeModulesMap;
	}
	
	/**
	 * Gets modules which should start after this
	 * @return map where key is module name and value is module version
	 */
	public Map<String, String> getStartBeforeModulesMap() {
		return this.startBeforeModulesMap;
	}
	
	/**
	 * Gets names of modules which should start after this
	 * @since 1.11
	 * @return list of module names or null
	 */
	public List<String> getStartBeforeModules() {
		return this.startBeforeModulesMap == null ? null : new ArrayList<>(this.startBeforeModulesMap.keySet());
	}
	
	/**
	 * Sets the modules that this module is aware of.
	 *
	 * @param awareOfModulesMap <code>Map&lt;String,String&gt;</code> of the
	 *            <code>awareOfModulesMap</code>s to set
	 * @since 1.9
	 */
	public void setAwareOfModulesMap(Map<String, String> awareOfModulesMap) {
		this.awareOfModulesMap = awareOfModulesMap;
	}
	
	/**
	 * This list of strings is just what is included in the config.xml file, the full package names:
	 * e.g. org.openmrs.module.formentry, for the modules that this module is aware of.
	 *
	 * @since 1.9
	 * @return the list of awareOfModules
	 */
	public List<String> getAwareOfModules() {
		return awareOfModulesMap == null ? null : new ArrayList<>(awareOfModulesMap.keySet());
	}
	
	public String getAwareOfModuleVersion(String awareOfModule) {
		return awareOfModulesMap == null ? null : awareOfModulesMap.get(awareOfModule);
	}
	
	/**
	 * @return the requireOpenmrsVersion
	 */
	public String getRequireOpenmrsVersion() {
		return requireOpenmrsVersion;
	}
	
	/**
	 * @param requireOpenmrsVersion the requireOpenmrsVersion to set
	 */
	public void setRequireOpenmrsVersion(String requireOpenmrsVersion) {
		this.requireOpenmrsVersion = requireOpenmrsVersion;
	}
	
	/**
	 * @return the module id
	 */
	public String getModuleId() {
		return moduleId;
	}
	
	/**
	 * @return the module id, with all . replaced with /
	 */
	public String getModuleIdAsPath() {
		return moduleId == null ? null : moduleId.replace('.', '/');
	}
	
	/**
	 * @param moduleId the module id to set
	 */
	public void setModuleId(String moduleId) {
		this.moduleId = moduleId;
	}
	
	/**
	 * @return the packageName
	 */
	public String getPackageName() {
		return packageName;
	}
	
	/**
	 * @param packageName the packageName to set
	 */
	public void setPackageName(String packageName) {
		this.packageName = packageName;
	}
	
	/**
	 * @return the version
	 */
	public String getVersion() {
		return version;
	}
	
	/**
	 * @param version the version to set
	 */
	public void setVersion(String version) {
		this.version = version;
	}
	
	/**
	 * @return the updateURL
	 */
	public String getUpdateURL() {
		return updateURL;
	}
	
	/**
	 * @param updateURL the updateURL to set
	 */
	public void setUpdateURL(String updateURL) {
		this.updateURL = updateURL;
	}
	
	/**
	 * @return the downloadURL
	 */
	public String getDownloadURL() {
		return downloadURL;
	}
	
	/**
	 * @param downloadURL the downloadURL to set
	 */
	public void setDownloadURL(String downloadURL) {
		this.downloadURL = downloadURL;
	}
	
	/**
	 * @return the updateVersion
	 */
	public String getUpdateVersion() {
		return updateVersion;
	}
	
	/**
	 * @param updateVersion the updateVersion to set
	 */
	public void setUpdateVersion(String updateVersion) {
		this.updateVersion = updateVersion;
	}
	
	/**
	 * Expands (i.e. creates instances of) {@code Extension}s defined by their class name in {@link #setExtensionNames(Map)}.
	 * 
	 * @return the extensions
	 *
	 * <strong>Should</strong> not expand extensionNames if extensionNames is null
	 * <strong>Should</strong> not expand extensionNames if extensionNames is empty
	 * <strong>Should</strong> not expand extensionNames if extensions matches extensionNames
	 * <strong>Should</strong> expand extensionNames if extensions does not match extensionNames 
	 */
	public List<Extension> getExtensions() {
		if (isNoNeedToExpand()) {
			return extensions;
		}
		return expandExtensionNames();
	}
	
	/**
	 * @param extensions the extensions to set
	 */
	public void setExtensions(List<Extension> extensions) {
		this.extensions = extensions;
	}
	
	/**
	 * A map of pointId to classname. The classname is expected to be a class that extends the
	 * {@link Extension} object.
	 * <br>
	 * This map will be expanded into full Extension objects the first time {@link #getExtensions()}
	 * is called.
	 * <p>
	 * The map is a direct representation of {@code extension} tags in a module's config.xml. For example
	 * <pre>{@code
	 * <extension>
	 *     <point>org.openmrs.admin.list</point>
	 *     <class>org.openmrs.module.reporting.web.extension.ManageAdminListExt</class>
	 * </extension>
	 * }
	 * </pre>
	 * </p>
	 *
	 * @param map from pointid to classname of an extension
	 * @see ModuleFileParser
	 */
	public void setExtensionNames(Map<String, String> map) {
		if (log.isDebugEnabled()) {
			for (Map.Entry<String, String> entry : extensionNames.entrySet()) {
				log.debug("Setting extension names: {} : {}", entry.getKey(), entry.getValue());
			}
		}
		this.extensionNames = map;
	}
	private boolean isNoNeedToExpand() {
		if (extensionNames == null || extensionNames.isEmpty()) {
			return true;
		}
		
		for (Extension ext : extensions) {
			if (!extensionNames.get(ext.getPointId()).equals(ext.getClass().getName())) {
				return false;
			}
		}
		return extensions.size() == extensionNames.size();
	}
	
	/**
	 * Expand the temporary extensionNames map of pointid-classname to full pointid-classobject. <br>
	 * This has to be done after the fact because when the pointid-classnames are parsed, the
	 * module's objects aren't fully realized yet and so not all classes can be loaded. <br>
	 * <br>
	 *
	 * @return a list of full Extension objects
	 */
	private List<Extension> expandExtensionNames() {
		ModuleClassLoader moduleClsLoader = ModuleFactory.getModuleClassLoader(this);
		if (moduleClsLoader == null) {
			log.debug("Module class loader is not available, maybe the module {} is stopped/stopping", getName());
			return extensions;
		}
		
		extensions.clear();
		for (Map.Entry<String, String> entry : extensionNames.entrySet()) {
			String point = entry.getKey();
			String className = entry.getValue();
			log.debug(getModuleId() + ": Expanding extension name (point|class): {}|{}", point, className);
			try {
				Class<?> cls = moduleClsLoader.loadClass(className);
				Extension ext = (Extension) cls.newInstance();
				ext.setPointId(point);
				ext.setModuleId(this.getModuleId());
				extensions.add(ext);
				log.debug(getModuleId() + ": Added extension: {}|{}", ext.getExtensionId(), ext.getClass());
			}
			catch (ClassNotFoundException | InstantiationException | IllegalAccessException | NoClassDefFoundError e) {
				log.warn(getModuleId() + ": Unable to create instance of class defined for extension point: " + point, e);
			}
		}
		return extensions;
	}
	
	/**
	 * @return the advicePoints
	 */
	public List<AdvicePoint> getAdvicePoints() {
		return advicePoints;
	}
	
	/**
	 * @param advicePoints the advicePoints to set
	 */
	public void setAdvicePoints(List<AdvicePoint> advicePoints) {
		this.advicePoints = advicePoints;
	}
	
	public File getFile() {
		return file;
	}
	
	public void setFile(File file) {
		this.file = file;
	}
	
	/**
	 * Gets a mapping from locale to properties used by this module. The locales are represented as
	 * a string containing language and country codes.
	 *
	 * @return mapping from locales to properties
	 * @deprecated as of 2.0 because messages are automatically loaded from the classpath
	 */
	@Deprecated
	public Map<String, Properties> getMessages() {
		return messages;
	}
	
	/**
	 * Sets the map from locale to properties used by this module.
	 *
	 * @param messages map of locale to properties for that locale
	 * @deprecated as of 2.0 because messages are automatically loaded from the classpath
	 */
	@Deprecated
	public void setMessages(Map<String, Properties> messages) {
		this.messages = messages;
	}
	
	public List<GlobalProperty> getGlobalProperties() {
		return globalProperties;
	}
	
	public void setGlobalProperties(List<GlobalProperty> globalProperties) {
		this.globalProperties = globalProperties;
	}
	
	public List<Privilege> getPrivileges() {
		return privileges;
	}
	
	public void setPrivileges(List<Privilege> privileges) {
		this.privileges = privileges;
	}
	
	public Document getConfig() {
		return config;
	}
	
	public void setConfig(Document config) {
		this.config = config;
	}
	/**
	 * @since 2.8.0
	 */
	public String getConfigVersion() {
		return configVersion;
	}
	/**
	 * @since 2.8.0
	 */
	public void setConfigVersion(String configVersion) {
		this.configVersion = configVersion;
	}
	public Document getSqldiff() {
		return sqldiff;
	}
	
	public void setSqldiff(Document sqldiff) {
		this.sqldiff = sqldiff;
	}
	
	public List<String> getMappingFiles() {
		return mappingFiles;
	}
	
	public void setMappingFiles(List<String> mappingFiles) {
		this.mappingFiles = mappingFiles;
	}
	
	/**
	 * Packages to scan for classes with JPA annotated classes.
	 * @return the set of packages to scan
	 * @since 1.9.2, 1.10
	 */
	public Set<String> getPackagesWithMappedClasses() {
		return packagesWithMappedClasses;
	}
	
	/**
	 * @param packagesToScan
	 * @see #getPackagesWithMappedClasses()
	 * @since 1.9.2, 1.10
	 */
	public void setPackagesWithMappedClasses(Set<String> packagesToScan) {
		this.packagesWithMappedClasses = packagesToScan;
	}
	
	/**
	 * This property is set by the module owner to tell OpenMRS that once it is installed, it must
	 * always startup. This is intended for modules with system-critical monitoring or security
	 * checks that should always be in place.
	 *
	 * @return true if this module has said that it should always start up
	 */
	public boolean isMandatory() {
		return mandatory;
	}
	
	public void setMandatory(boolean mandatory) {
		this.mandatory = mandatory;
	}
	
	/**
	 * This is a convenience method to know whether this module is core to OpenMRS. A module is
	 * 'core' when this module is essentially part of the core code and must exist at all times
	 *
	 * @return true if this is an OpenMRS core module
	 * @see ModuleConstants#CORE_MODULES
	 */
	public boolean isCoreModule() {
		return !ModuleUtil.ignoreCoreModules() && ModuleConstants.CORE_MODULES.containsKey(moduleId);
	}
	
	public boolean isStarted() {
		return ModuleFactory.isModuleStarted(this);
	}
	
	/**
	 * @param e string to set as startup error message
	 * <strong>Should</strong> throw exception when message is null
	 */
	public void setStartupErrorMessage(String e) {
		if (e == null) {
			throw new ModuleException("Startup error message cannot be null", this.getModuleId());
		}
		
		this.startupErrorMessage = e;
	}
	
	/**
	 * Add the given exceptionMessage and throwable as the startup error for this module. This
	 * method loops over the stacktrace and adds the detailed message
	 *
	 * @param exceptionMessage optional. the default message to show on the first line of the error
	 *            message
	 * @param t throwable stacktrace to include in the error message
	 *
	 * <strong>Should</strong> throw exception when throwable is null
	 * <strong>Should</strong> set StartupErrorMessage when exceptionMessage is null
	 * <strong>Should</strong> append throwable's message to exceptionMessage
	 */
	public void setStartupErrorMessage(String exceptionMessage, Throwable t) {
		if (t == null) {
			throw new ModuleException("Startup error value cannot be null", this.getModuleId());
		}
		
		StringBuilder sb = new StringBuilder();
		
		// if exceptionMessage is not null, append it
		if (exceptionMessage != null) {
			sb.append(exceptionMessage);
			sb.append("\n");
		}
		
		sb.append(t.getMessage());
		sb.append("\n");
		
		this.startupErrorMessage = sb.toString();
	}
	
	public String getStartupErrorMessage() {
		return startupErrorMessage;
	}
	
	public Boolean hasStartupError() {
		return (this.startupErrorMessage != null);
	}
	
	public void clearStartupError() {
		this.startupErrorMessage = null;
	}
	
	@Override
	public String toString() {
		if (moduleId == null) {
			return super.toString();
		}
		
		return moduleId;
	}
	/*
	 * <strong>Should</strong> dispose all classInstances, not AdvicePoints
	 */	
	public void disposeAdvicePointsClassInstance() {
		if (advicePoints == null) {
			return;
		}
		
		for (AdvicePoint advicePoint : advicePoints) {
			advicePoint.disposeClassInstance();
		}
	}
	
	public List<ModuleConditionalResource> getConditionalResources() {
		return conditionalResources;
	}
	
	public void setConditionalResources(List<ModuleConditionalResource> conditionalResources) {
		this.conditionalResources = conditionalResources;
	}
	
	public boolean isCore() {
		return ModuleConstants.CORE_MODULES.containsKey(getModuleId());
	}
}

/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module.web.filter;
import java.io.Serializable;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
/**
 * This class represents the mapping of a Filter to a collection of Servlets and URLs
 */
public class ModuleFilterMapping implements Serializable {
	
	public static final long serialVersionUID = 1;
	
	private static final Logger log = LoggerFactory.getLogger(ModuleFilterMapping.class);
	
	private static final Deque<ModuleFilterMapping> EMPTY_DEQUE = new ArrayDeque<>(0);
	
	// Properties
	private Module module;
	
	private String filterName;
	
	private List<String> servletNames = new ArrayList<>();
	
	private List<String> urlPatterns = new ArrayList<>();
	
	/**
	 * Default constructor, requires a Module
	 * 
	 * @param module - the module to use to construct this ModuleFilterMapping
	 */
	public ModuleFilterMapping(Module module) {
		this.module = module;
	}
	
	/**
	 * @return - the {@link Module} that registered this FilterDefinition
	 */
	public Module getModule() {
		return module;
	}
	
	/**
	 * @param module the {@link Module}
	 */
	public void setModule(Module module) {
		this.module = module;
	}
	
	/**
	 * @return the name of the Filter
	 */
	public String getFilterName() {
		return filterName;
	}
	
	/**
	 * @param filterName the name of the Filter
	 */
	public void setFilterName(String filterName) {
		this.filterName = filterName;
	}
	
	/**
	 * @return a List of all Servlet Names mapped to this Filter
	 */
	public List<String> getServletNames() {
		return servletNames;
	}
	
	/**
	 * @param servletNames a List of all Servlet Names mapped to this filter
	 */
	public void setServletNames(List<String> servletNames) {
		this.servletNames = servletNames;
	}
	
	/**
	 * Adds a Servlet name to the List of those mapped to this filter
	 * 
	 * @param servletName - The servlet name to add
	 */
	public void addServletName(String servletName) {
		this.servletNames.add(servletName);
	}
	
	/**
	 * @return - a List of all Url Patterns mapped to this filter
	 */
	public List<String> getUrlPatterns() {
		return urlPatterns;
	}
	
	/**
	 * @param urlPatterns a List of all Url Patterns mapped to this filter
	 */
	public void setUrlPatterns(List<String> urlPatterns) {
		this.urlPatterns = urlPatterns;
	}
	
	/**
	 * Adds a Url pattern to the List of those mapped to this filter
	 * 
	 * @param urlPattern - The urlPattern to add
	 */
	public void addUrlPattern(String urlPattern) {
		this.urlPatterns.add(urlPattern);
	}
	
	/**
	 * Return <code>true</code> if the passed Filter passes one or more filter mappings otherwise,
	 * return <code>false</code>.
	 * 
	 * @param filterMapping - The {@link ModuleFilterMapping} to check for matching servlets and url
	 *            patterns
	 * @param requestPath - The URI of the request to check against the {@link ModuleFilterMapping},
	 * 	      with the context path already removed (since module filter mappings are relative to the
	 *        context path).
	 * @return - true if the given {@link ModuleFilterMapping} matches the passed requestPath For
	 *         example: Passing a ModuleFilterMapping containing a urlPattern of "*" would return
	 *         true for any requestPath Passing a ModuleFilterMapping containing a urlPattern of
	 *         "*.jsp" would return true for any requestPath ending in ".jsp"
	 * <strong>Should</strong> return false if the requestPath is null
	 * <strong>Should</strong> return true if the ModuleFilterMapping contains any matching urlPatterns for this
	 *         requestPath
	 * <strong>Should</strong> return true if the ModuleFilterMapping contains any matching servletNames for this
	 *         requestPath
	 * <strong>Should</strong> return false if no matches are found for this requestPath
	 */
	public static boolean filterMappingPasses(ModuleFilterMapping filterMapping, String requestPath) {
		
		// Return false if url is null
		if (requestPath == null) {
			return false;
		}
		
		for (String patternToCheck : filterMapping.getUrlPatterns()) {
			if (urlPatternMatches(patternToCheck, requestPath)) {
				return true;
			}
		}
		for (String patternToCheck : filterMapping.getServletNames()) {
			if (servletNameMatches(patternToCheck, requestPath)) {
				return true;
			}
		}
		
		// If none found, return false
		return false;
	}
	
	/**
	 * Return <code>true</code> if the context-relative request path matches the patternToCheck
	 * otherwise, return <code>false</code>.
	 * 
	 * @param patternToCheck String pattern to check
	 * @param requestPath to check
	 * <strong>Should</strong> return false if the patternToCheck is null
	 * <strong>Should</strong> return true if the pattern is *
	 * <strong>Should</strong> return true if the pattern is /*
	 * <strong>Should</strong> return true if the pattern matches the requestPath exactly
	 * <strong>Should</strong> return true if the pattern matches everything up to a suffix of /*
	 * <strong>Should</strong> return true if the pattern matches by extension
	 * <strong>Should</strong> return false if no pattern matches
	 */
	public static boolean urlPatternMatches(String patternToCheck, String requestPath) {
		
		// Return false if patternToCheck is null
		if (patternToCheck == null) {
			return false;
		}
		
		log.debug("Checking URL <" + requestPath + "> against pattern <" + patternToCheck + ">");
		
		// Match exact or full wildcard
		if ("*".equals(patternToCheck) || "/*".equals(patternToCheck) || patternToCheck.equals(requestPath)) {
			return true;
		}
		
		// Match wildcard
		if (patternToCheck.endsWith("/*")) {
			int patternLength = patternToCheck.length() - 2;
			if (patternToCheck.regionMatches(0, requestPath, 0, patternLength)) {
				return requestPath.length() == patternLength || '/' == requestPath.charAt(patternLength);
			}
			return false;
		}
		
		// Case 3 - Extension Match
		if (patternToCheck.startsWith("*.")) {
			int slash = requestPath.lastIndexOf('/');
			int period = requestPath.lastIndexOf('.');
			int reqLen = requestPath.length();
			int patLen = patternToCheck.length();
			
			if (slash >= 0 && period > slash && period != reqLen - 1 && reqLen - period == patLen - 1) {
				return (patternToCheck.regionMatches(2, requestPath, period + 1, patLen - 2));
			}
		}
		
		// If no match found by here, return false
		return false;
	}
	
	/**
	 * Return <code>true</code> if the specified servlet name matches the filterMapping otherwise
	 * return <code>false</code>.
	 * 
	 * @param patternToCheck String pattern to check
	 * @param servletName Servlet Name to check
	 * <strong>Should</strong> return false if the patternToCheck is null
	 * <strong>Should</strong> return true if the pattern is *
	 * <strong>Should</strong> return true if the pattern matches the servlet name exactly
	 * <strong>Should</strong> return false if no pattern matches
	 */
	public static boolean servletNameMatches(String patternToCheck, String servletName) {
		
		// Return false if servletName is null
		if (servletName == null) {
			return false;
		}
		
		log.debug("Checking servlet <" + servletName + "> against pattern <" + patternToCheck + ">");
		
		// Match exact or full wildcard
		return ("*").equals(patternToCheck) || servletName.equals(patternToCheck);
		
		// If none found, return false
	}
	
	/**
	 * Static method to parse through a Module's configuration file and return a List of
	 * ModuleFilterMapping objects for which there are configuration elements. Expected XML Format:
	 * 
	 * <pre>
	 * 	&lt;filter-mapping&gt;
	 * 		&lt;filter-name&gt;MyFilterName&lt;/filter-name&gt;
	 * 		&lt;url-pattern&gt;The pattern of URLs to match&lt;/filter-class&gt;
	 * 	&lt;/filter-mapping&gt;
	 * or
	 * 	&lt;filter-mapping&gt;
	 * 		&lt;filter-name&gt;MyFilterName&lt;/filter-name&gt;
	 * 		&lt;servlet-name&gt;The servlet name to match&lt;/servlet-name&gt;
	 * 	&lt;/filter-mapping&gt;
	 * </pre>
	 * 
	 * @param module - The {@link Module} for which you want to retrieve the defined
	 *            {@link ModuleFilterMapping}s
	 * @return - a {@link Deque} of {@link ModuleFilterMapping}s that are defined for the passed
	 *         {@link Module}
	 */
	public static Deque<ModuleFilterMapping> retrieveFilterMappings(Module module){
		Deque<ModuleFilterMapping> mappings;
		
		try {
			Element rootNode = module.getConfig().getDocumentElement();
			NodeList mappingNodes = rootNode.getElementsByTagName("filter-mapping");
			if (mappingNodes.getLength() > 0) {
				mappings = new ArrayDeque<>(mappingNodes.getLength());
				for (int i = 0; i < mappingNodes.getLength(); i++) {
					ModuleFilterMapping mapping = new ModuleFilterMapping(module);
					Node node = mappingNodes.item(i);
					NodeList configNodes = node.getChildNodes();
					for (int j = 0; j < configNodes.getLength(); j++) {
						Node configNode = configNodes.item(j);
						switch (configNode.getNodeName()) {
							case "filter-name":
								mapping.setFilterName(configNode.getTextContent());
								break;
							case "url-pattern":
								mapping.addUrlPattern(configNode.getTextContent());
								break;
							case "servlet-name":
								mapping.addServletName(configNode.getTextContent());
								break;
						}
					}
					mappings.add(mapping);
				}
				
				log.debug("Retrieved {} filter-mappings for {}: {}", mappings.size(), module, mappings);
				return mappings;
			}
		}
		catch (Exception e) {
			throw new ModuleException("Unable to parse filters in module configuration.", e);
		}
		
		return EMPTY_DEQUE;
	}
}

/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class AdvicePoint {
	
	private static final Logger log = LoggerFactory.getLogger(AdvicePoint.class);
	
	private String point;
	
	private Object classInstance;
	
	private Module module;
	
	private String className;
	
	public AdvicePoint() {
	}
	
	public AdvicePoint(String point, Class<?> clazz) {
		this.point = point;
		try {
			this.classInstance = clazz.newInstance();
		}
		catch (Exception e) {
			log.error("Unable to get instance of: [{}]", clazz.getName(), e);
		}
	}
	
	public AdvicePoint(Module mod, String point, String className) {
		this.point = point;
		this.module = mod;
		this.className = className;
	}
	
	public String getPoint() {
		return point;
	}
	
	/**
	 * @return the classInstance
	 */
	public Object getClassInstance() {
		if (classInstance != null) {
			return classInstance;
		}
		
		Object o = null;
		try {
			Class<?> c = ModuleFactory.getModuleClassLoader(getModule()).loadClass(getClassName());
			o = c.newInstance();
		}
		catch (Exception | LinkageError e) {
			log.warn("Could not get instance for advice point [{}]", point, e);
		}
		classInstance = o;
		return o;
	}
	
	/**
	 * @return the className
	 */
	public String getClassName() {
		return className;
	}
	
	/**
	 * @return the module
	 */
	public Module getModule() {
		return module;
	}
	
	public void disposeClassInstance() {
		classInstance = null;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.GlobalProperty;
import org.openmrs.Privilege;
import org.openmrs.api.context.Context;
import org.openmrs.customdatatype.CustomDatatype;
import org.openmrs.messagesource.MessageSourceService;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
/**
 * This class will parse an OpenMRS module, specifically its {@code config.xml} file into a {@link org.openmrs.module.Module} object.
 * <p>Typical usage is:
 * <ol>
 * <li>Create a {@code ModuleFileParser} with {@link #ModuleFileParser(MessageSourceService)}.
 * <li>Parse the module by passing the file to {@link #parse(File)}.</li>
 * </ol>
 * Note that the parser does not validate the {@code config.xml} file against the document type definition's (DTD).
 */
public class ModuleFileParser {
	
	private static final Logger log = LoggerFactory.getLogger(ModuleFileParser.class);
	private static final String MODULE_CONFIG_XML_FILENAME = "config.xml";
	private static final String OPENMRS_MODULE_FILE_EXTENSION = ".omod";
	
	//https://resources.openmrs.org/doctype/config-1.5.dtd
	private static final Pattern OPENMRS_DTD_SYSTEM_ID_PATTERN = Pattern.compile("https?://resources.openmrs.org/doctype/(?<config>config-[0-9.]+\\.dtd)");
	
	/**
	 * List out all of the possible version numbers for config files that openmrs has DTDs for.
	 * These are usually stored at http://resources.openmrs.org/doctype/config-x.x.dt
	 */
	private static List<String> validConfigVersions = new ArrayList<>();
	
	static {
		validConfigVersions.add("1.0");
		validConfigVersions.add("1.1");
		validConfigVersions.add("1.2");
		validConfigVersions.add("1.3");
		validConfigVersions.add("1.4");
		validConfigVersions.add("1.5");
		validConfigVersions.add("1.6");
		validConfigVersions.add("1.7");
		validConfigVersions.add("2.0");
	}
	
	// TODO - remove this field once ModuleFileParser(File), ModuleFileParser(InputStream) are removed.
	// There is no need to keep the file as state since moduleFileParser.parse(File) does not need it.
	// this is also why all private methods that need access to the file for parsing or error message get it as a parameter
	private File moduleFile;
	private MessageSourceService messageSourceService;
	/**
	 * Creates a ModuleFileParser.
	 *
	 * @param messageSourceService the message source used for error messages
	 * @since 2.2.0
	 */
	public ModuleFileParser(MessageSourceService messageSourceService) {
		this.messageSourceService = Objects.requireNonNull(messageSourceService, "messageSourceService must not be null");
	}
	
	/**
	 * Constructor
	 *
	 * @param moduleFile the module (jar)file that will be parsed
	 * @deprecated since 2.2.0 use {@link #ModuleFileParser(MessageSourceService)}
	 */
	@Deprecated
	public ModuleFileParser(File moduleFile) {
		this.messageSourceService = Context.getMessageSourceService();
		validateFileIsNotNull(moduleFile);
		validateFileHasModuleFileExtension(moduleFile);
		this.moduleFile = moduleFile;
	}
	private void validateFileIsNotNull(File moduleFile) {
		if (moduleFile == null) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.fileCannotBeNull"));
		}
	}
	private void validateFileHasModuleFileExtension(File moduleFile) {
		if (!moduleFile.getName().endsWith(OPENMRS_MODULE_FILE_EXTENSION)) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.invalidFileExtension"),
				moduleFile.getName());
		}
	}
	/**
	 * Convenience constructor to parse the given inputStream file into an omod. <br>
	 * This copies the stream into a temporary file just so things can be parsed.<br>
	 *
	 * @param inputStream the inputStream pointing to an omod file
	 * @deprecated since 2.2.0 use {@link #ModuleFileParser(MessageSourceService)}
	 */
	@Deprecated
	public ModuleFileParser(InputStream inputStream) {
		this.messageSourceService = Context.getMessageSourceService();
		this.moduleFile = createTempFile("moduleUpgrade", OPENMRS_MODULE_FILE_EXTENSION);
		copyInputStreamToFile(inputStream, this.moduleFile);
	}
	/**
	 * Parses the given {@code InputStream} of an OpenMRS module into a {@code Module}.
	 * This copies the stream into a temporary file and close given {@code InputStream}.
	 *
	 * @param inputStream the inputStream pointing to an omod file
	 * @since 2.2.0
	 */
	public Module parse(InputStream inputStream) {
		File moduleFile = createTempFile("moduleUpgrade", OPENMRS_MODULE_FILE_EXTENSION);
		copyInputStreamToFile(inputStream, moduleFile);
		return parse(moduleFile);
	}
	private File createTempFile(String prefix, String suffix) {
		File file;
		try {
			file = File.createTempFile(prefix, suffix);
		}
		catch (IOException e) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.cannotCreateFile"), e);
		}
		return file;
	}
	private void copyInputStreamToFile(InputStream inputStream, File file) {
		try (FileOutputStream outputStream = new FileOutputStream(file)) {
			OpenmrsUtil.copyFile(inputStream, outputStream);
		}
		catch (IOException e) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.cannotCreateFile"), e);
		}
		finally {
			try {
				inputStream.close();
			}
			catch (Exception e) { /* pass */}
		}
	}
	/**
	 * This constructor was created for testing purposes and is now deprecated.
	 * DO NOT USE.
	 *
	 * @deprecated since 2.2.0 use {@link #ModuleFileParser(MessageSourceService)}
	 */
	@Deprecated
	ModuleFileParser() {
	}
	/**
	 * Get the module.
	 * If you use this method only do so together with {@link #ModuleFileParser(File)} or {@link #ModuleFileParser(InputStream)}.
	 * Best use {@link #ModuleFileParser(MessageSourceService)} and {@link #parse(File)}
	 * since this method is deprecated.
	 *
	 * @return new module object
	 * @deprecated since 2.2.0 use {@link #parse(File)}
	 */
	@Deprecated
	public Module parse() throws ModuleException {
		return parse(this.moduleFile);
	}
	/**
	 * Get the module from an OpenMRS module file.
	 * 
	 * @param moduleFile the module file to be parsed
	 * @return new module object
	 * @since 2.2.0
	 */
	public Module parse(File moduleFile) {
		validateFileIsNotNull(moduleFile);
		validateFileHasModuleFileExtension(moduleFile);
		return createModule(getModuleConfigXml(moduleFile), moduleFile);
	}
	private Document getModuleConfigXml(File moduleFile) {
		Document config;
		try (JarFile jarfile = new JarFile(moduleFile)) {
			ZipEntry configEntry = getConfigXmlZipEntry(jarfile, moduleFile);
			config = parseConfigXml(jarfile, configEntry, moduleFile);
		}
		catch (IOException e) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.cannotGetJarFile"),
				moduleFile.getName(), e);
		}
		return config;
	}
	private ZipEntry getConfigXmlZipEntry(JarFile jarfile, File moduleFile) {
		ZipEntry config = jarfile.getEntry(MODULE_CONFIG_XML_FILENAME);
		if (config == null) {
			throw new ModuleException(messageSourceService.getMessage("Module.error.noConfigFile"),
				moduleFile.getName());
		}
		return config;
	}
	private Document parseConfigXml(JarFile jarfile, ZipEntry configEntry, File moduleFile) {
		Document config;
		try (InputStream configStream = jarfile.getInputStream(configEntry)) {
			config = parseConfigXmlStream(configStream, moduleFile);
		}
		catch (IOException e) {
			throw new ModuleException(messageSourceService.getMessage(
				"Module.error.cannotGetConfigFileStream"), moduleFile.getName(), e);
		}
		return config;
	}
	private Document parseConfigXmlStream(InputStream configStream, File moduleFile) {
		Document config;
		try {
			DocumentBuilder db = newDocumentBuilder();
			config = db.parse(configStream);
		}
		catch (Exception e) {
			log.error("Error parsing " + MODULE_CONFIG_XML_FILENAME + ": " + configStream.toString(), e);
			String output = "";
			try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
				// Now copy bytes from the URL to the output stream
				byte[] buffer = new byte[4096];
				int bytesRead;
				while ((bytesRead = configStream.read(buffer)) != -1) {
					out.write(buffer, 0, bytesRead);
				}
				output = out.toString(StandardCharsets.UTF_8.name());
			}
			catch (Exception e2) {
				log.warn("Another error parsing " + MODULE_CONFIG_XML_FILENAME, e2);
			}
			log.error("{} content: {}", MODULE_CONFIG_XML_FILENAME, output);
			throw new ModuleException(messageSourceService.getMessage("Module.error.cannotParseConfigFile"),
				moduleFile.getName(), e);
		}
		return config;
	}
	private DocumentBuilder newDocumentBuilder() throws ParserConfigurationException {
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db = dbf.newDocumentBuilder();
		// When asked to resolve external entities (such as a
		// DTD) we return an InputSource
		// with no data at the end, causing the parser to ignore
		// the DTD.
		db.setEntityResolver((publicId, systemId) -> {
			Matcher dtdMatcher = OPENMRS_DTD_SYSTEM_ID_PATTERN.matcher(systemId);
			if (dtdMatcher.matches()) {
				String dtdFile = dtdMatcher.group("config");
				return new InputSource(OpenmrsClassLoader.getInstance().getResourceAsStream("org/openmrs/module/dtd/" + dtdFile));
			}
			return new InputSource(new StringReader(""));
		});
		
		return db;
	}
	private Module createModule(Document config, File moduleFile) {
		Element configRoot = config.getDocumentElement();
		String configVersion = ensureValidModuleConfigVersion(configRoot, moduleFile);
		
		String name = ensureNonEmptyName(configRoot, moduleFile);
		String moduleId = ensureNonEmptyId(configRoot, name);
		String packageName = ensureNonEmptyPackage(configRoot, name);
		
		String author = getElementTrimmed(configRoot, "author");
		String desc = getElementTrimmed(configRoot, "description");
		String version = getElementTrimmed(configRoot, "version");
		Module module = new Module(name, moduleId, packageName, author, desc, version, configVersion);
		module.setActivatorName(getElementTrimmed(configRoot, "activator"));
		module.setRequireDatabaseVersion(getElementTrimmed(configRoot, "require_database_version"));
		module.setRequireOpenmrsVersion(getElementTrimmed(configRoot, "require_version"));
		module.setUpdateURL(getElementTrimmed(configRoot, "updateURL"));
		module.setRequiredModulesMap(extractRequiredModules(configRoot));
		module.setAwareOfModulesMap(extractAwareOfModules(configRoot));
		module.setStartBeforeModulesMap(extractStartBeforeModules(configRoot));
		module.setAdvicePoints(extractAdvice(configRoot, module));
		module.setExtensionNames(extractExtensions(configRoot));
		module.setPrivileges(extractPrivileges(configRoot));
		module.setGlobalProperties(extractGlobalProperties(configRoot));
		module.setMappingFiles(extractMappingFiles(configRoot));
		module.setPackagesWithMappedClasses(extractPackagesWithMappedClasses(configRoot));
		module.setMandatory(extractMandatory(configRoot, configVersion));
		module.setConditionalResources(extractConditionalResources(configRoot));
		module.setConfig(config);
		module.setFile(moduleFile);
		return module;
	}
	private String ensureValidModuleConfigVersion(Element configRoot, File moduleFile) {
		String configVersion = configRoot.getAttribute("configVersion").trim();
		validateModuleConfigVersion(configVersion, moduleFile);
		return configVersion;
	}
	private void validateModuleConfigVersion(String version, File moduleFile) {
		if (!validConfigVersions.contains(version)) {
			throw new ModuleException(Context.getMessageSourceService().getMessage("Module.error.invalidConfigVersion",
				new Object[] { version, String.join(", ", validConfigVersions) }, Context.getLocale()),
				moduleFile.getName());
		}
	}
	private String ensureNonEmptyName(Element configRoot, File moduleFile) {
		return getTrimmedElementOrFail(configRoot, "name", "Module.error.nameCannotBeEmpty", moduleFile.getName());
	}
	private String ensureNonEmptyId(Element configRoot, String name) {
		return getTrimmedElementOrFail(configRoot, "id", "Module.error.idCannotBeEmpty", name);
	}
	private String ensureNonEmptyPackage(Element configRoot, String name) {
		return getTrimmedElementOrFail(configRoot, "package", "Module.error.packageCannotBeEmpty", name);
	}
	/**
	 * load in required modules list
	 *
	 * @return map from module package name to required version
	 * @since 1.5
	 */
	private Map<String, String> extractRequiredModules(Element configRoot) {
		return extractModulesWithVersionAttribute(configRoot, "require_module", "require_modules");
	}
	
	/**
	 * load in list of modules we are aware of.
	 *
	 * @return map from module package name to aware of version
	 * @since 1.9
	 */
	private Map<String, String> extractAwareOfModules(Element configRoot) {
		return extractModulesWithVersionAttribute(configRoot, "aware_of_module", "aware_of_modules");
	}
	
	private Map<String, String> extractStartBeforeModules(Element configRoot) {
		Map<String, String> result = extractModulesWithVersionAttribute(configRoot, "module", "start_before_modules");
		result.putAll(extractModulesWithVersionAttribute(configRoot, "start_before_module", "start_before_modules"));
		return result;
	}
	private Map<String, String> extractModulesWithVersionAttribute(Element configRoot, String elementName,
		String elementParentName) {
		
		NodeList parents = configRoot.getElementsByTagName(elementParentName);
		
		Map<String, String> result = new HashMap<>();
		if (parents.getLength() == 0) {
			return result;
		}
		
		Element firstParent = (Element) parents.item(0);
		NodeList children = firstParent.getElementsByTagName(elementName);
		
		int i = 0;
		while (i < children.getLength()) {
			Element child = (Element) children.item(i);
			Attr versionAttribute = child.getAttributeNode("version");
			String version = versionAttribute == null ? null : versionAttribute.getValue();
			result.put(child.getTextContent().trim(), version);
			i++;
		}
		return result;
	}
	private List<AdvicePoint> extractAdvice(Element configRoot, Module module) {
		List<AdvicePoint> result = new ArrayList<>();
		NodeList advice = configRoot.getElementsByTagName("advice");
		if (advice.getLength() == 0) {
			return result;
		}
		log.debug("# advice: {}", advice.getLength());
		int i = 0;
		while (i < advice.getLength()) {
			Element element = (Element) advice.item(i);
			String point = getElementTrimmed(element, "point");
			String adviceClass = getElementTrimmed(element, "class");
			log.debug("advice point: {}, class: {}", point, adviceClass);
			if (point.isEmpty() || adviceClass.isEmpty()) {
				log.warn("'point' and 'class' are required for advice. Given '{}' and '{}'", point, adviceClass);
			} else {
				result.add(new AdvicePoint(module, point, adviceClass));
			}
			i++;
		}
		return result;
	}
	private Map<String, String> extractExtensions(Element configRoot) {
		Map<String, String> result = new IdentityHashMap<>();
		NodeList extensions = configRoot.getElementsByTagName("extension");
		if (extensions.getLength() == 0) {
			return result;
		}
		log.debug("# extensions: {}", extensions.getLength());
		int i = 0;
		while (i < extensions.getLength()) {
			Element element = (Element) extensions.item(i);
			String point = getElementTrimmed(element, "point");
			String extClass = getElementTrimmed(element, "class");
			log.debug("extension point: {}, class: {}", point, extClass);
			if (point.isEmpty() || extClass.isEmpty()) {
				log.warn("'point' and 'class' are required for extensions. Given '{}' and '{}'", point, extClass);
			} else if (point.contains(Extension.EXTENSION_ID_SEPARATOR)) {
				log.warn("Point id contains illegal character: '{}'", Extension.EXTENSION_ID_SEPARATOR);
			} else {
				result.put(point, extClass);
			}
			i++;
		}
		return result;
	}
	private List<Privilege> extractPrivileges(Element configRoot) {
		List<Privilege> result = new ArrayList<>();
		NodeList privileges = configRoot.getElementsByTagName("privilege");
		if (privileges.getLength() == 0) {
			return result;
		}
		log.debug("# privileges: {}", privileges.getLength());
		int i = 0;
		while (i < privileges.getLength()) {
			Element element = (Element) privileges.item(i);
			String name = getElementTrimmed(element, "name");
			String description = getElementTrimmed(element, "description");
			log.debug("extension name: {}, description: {}", name, description);
			if (name.isEmpty() || description.isEmpty()) {
				log.warn("'name' and 'description' are required for privilege. Given '{}' and '{}'", name, description);
			} else {
				result.add(new Privilege(name, description));
			}
			i++;
		}
		return result;
	}
	
	private List<GlobalProperty> extractGlobalProperties(Element configRoot) {
		
		List<GlobalProperty> result = new ArrayList<>();
		
		NodeList propNodes = configRoot.getElementsByTagName("globalProperty");
		if (propNodes.getLength() == 0) {
			return result;
		}
		
		log.debug("# global properties: {}", propNodes.getLength());
		int i = 0;
		while (i < propNodes.getLength()) {
			Element gpElement = (Element) propNodes.item(i);
			GlobalProperty globalProperty = extractGlobalProperty(gpElement);
			
			if (globalProperty != null) {
				result.add(globalProperty);
			}
			
			i++;
		}
		
		return result;
	}
	private GlobalProperty extractGlobalProperty(Element element) {
		String property = getElementTrimmed(element, "property");
		String defaultValue = getElementTrimmed(element, "defaultValue");
		String description = removeTabsAndTrim(getElementTrimmed(element, "description"));
		String datatypeClassname = getElementTrimmed(element, "datatypeClassname");
		String datatypeConfig = getElementTrimmed(element, "datatypeConfig");
		String viewPrivilege = removeTabsAndTrim(getElementTrimmed(element, "viewPrivilege"));
		String editPrivilege = removeTabsAndTrim(getElementTrimmed(element, "editPrivilege"));
		String deletePrivilege = removeTabsAndTrim(getElementTrimmed(element, "deletePrivilege"));
		
		log.debug("property: {}, defaultValue: {}", property, defaultValue);
		log.debug("description: {}, datatypeClassname: {}", description, datatypeClassname);
		log.debug("datatypeConfig: {}", datatypeConfig);
		log.debug("viewPrivilege: {}, editPrivilege: {}, deletePrivilege: {}", viewPrivilege, editPrivilege, deletePrivilege);
		return createGlobalProperty(property, defaultValue, description, datatypeClassname,
			datatypeConfig, viewPrivilege, editPrivilege, deletePrivilege);
	}
	private String removeTabsAndTrim(String string) {
		return string.replaceAll("	", "").trim();
	}
	private GlobalProperty createGlobalProperty(String property, String defaultValue, String description,
		String datatypeClassname, String datatypeConfig, String viewPrivilege, String editPrivilege, String deletePrivilege) {
		GlobalProperty globalProperty = null;
		if (property.isEmpty()) {
			log.warn("'property' is required for global properties. Given '{}'", property);
			return globalProperty;
		}
		if (!datatypeClassname.isEmpty()) {
			globalProperty = createGlobalPropertyWithDatatype(property, defaultValue, description, datatypeClassname,
				datatypeConfig);
		} else {
			globalProperty = new GlobalProperty(property, defaultValue, description);
		}
		
		if (!viewPrivilege.isEmpty()) {
			globalProperty.setViewPrivilege(new Privilege(viewPrivilege));
		}
		if (!editPrivilege.isEmpty()) {
			globalProperty.setEditPrivilege(new Privilege(editPrivilege));
		}
		if (!deletePrivilege.isEmpty()) {
			globalProperty.setDeletePrivilege(new Privilege(deletePrivilege));
		}
		
		return globalProperty;
	}
	private GlobalProperty createGlobalPropertyWithDatatype(String property, String defaultValue, String description,
		String datatypeClassname, String datatypeConfig) {
		GlobalProperty globalProperty = null;
		try {
			Class<CustomDatatype<?>> datatypeClazz = (Class<CustomDatatype<?>>) Class.forName(datatypeClassname)
				.asSubclass(CustomDatatype.class);
			globalProperty = new GlobalProperty(property, defaultValue, description, datatypeClazz, datatypeConfig);
		}
		catch (ClassCastException ex) {
			log.error("The class specified by 'datatypeClassname' (" + datatypeClassname
				+ ") must be a subtype of 'org.openmrs.customdatatype.CustomDatatype<?>'.", ex);
		}
		catch (ClassNotFoundException ex) {
			log.error("The class specified by 'datatypeClassname' (" + datatypeClassname
				+ ") could not be found.", ex);
		}
		return globalProperty;
	}
	private List<String> extractMappingFiles(Element configRoot) {
		List<String> result = new ArrayList<>();
		splitTagContentByWhitespace(configRoot, "mappingFiles", result);
		return result;
	}
	private Set<String> extractPackagesWithMappedClasses(Element configRoot) {
		Set<String> result = new HashSet<>();
		splitTagContentByWhitespace(configRoot, "packagesWithMappedClasses", result);
		return result;
	}
	private Collection<String> splitTagContentByWhitespace(Element rootNode, String tag, Collection<String> result) {
		String content = getElement(rootNode, tag);
		for (String s : content.split("\\s")) {
			String s2 = s.trim();
			if (s2.length() > 0) {
				result.add(s2);
			}
		}
		return result;
	}
	
	private String getTrimmedElementOrFail(Element rootNode, String elementName, String errorMessageKey, String moduleName) {
		String element = getElementTrimmed(rootNode, elementName);
		if (element == null || element.length() == 0) {
			throw new ModuleException(messageSourceService.getMessage(errorMessageKey),
				moduleName);
		}
		return element;
	}
	private String getElementTrimmed(Element element, String name) {
		return getElement(element, name).trim();
	}
	private String getElement(Element root, String tag) {
		if (root.getElementsByTagName(tag).getLength() > 0) {
			return root.getElementsByTagName(tag).item(0).getTextContent();
		}
		return "";
	}
	/**
	 * Looks for the "<mandatory>" element in the config file and returns true if the value is
	 * exactly "true".
	 */
	private boolean extractMandatory(Element configRoot, String configVersion) {
		if (Double.parseDouble(configVersion) >= 1.3) {
			String mandatory = getElementTrimmed(configRoot, "mandatory");
			return "true".equalsIgnoreCase(mandatory);
		}
		// this module has an older config file
		return false;
	}
	/**
	 * Parses conditionalResources tag.
	 *
	 * <strong>Should</strong> parse openmrsVersion and modules
	 * <strong>Should</strong> parse conditionalResource with whitespace
	 * <strong>Should</strong> throw exception if multiple conditionalResources tags found
	 * <strong>Should</strong> throw exception if conditionalResources contains invalid tag
	 * <strong>Should</strong> throw exception if path is blank
	 */
	List<ModuleConditionalResource> extractConditionalResources(Element configRoot) {
		List<ModuleConditionalResource> conditionalResources = new ArrayList<>();
		NodeList parentConditionalResources = configRoot.getElementsByTagName("conditionalResources");
		if (parentConditionalResources.getLength() == 0) {
			return new ArrayList<>();
		} else if (parentConditionalResources.getLength() > 1) {
			throw new IllegalArgumentException("Found multiple conditionalResources tags. There can be only one.");
		}
		NodeList conditionalResourcesNode = parentConditionalResources.item(0).getChildNodes();
		for (int i = 0; i < conditionalResourcesNode.getLength(); i++) {
			Node conditionalResourceNode = conditionalResourcesNode.item(i);
			if ("#text".equals(conditionalResourceNode.getNodeName())) {
				//ignore text and whitespace in particular
				continue;
			}
			if (!"conditionalResource".equals(conditionalResourceNode.getNodeName())) {
				throw new IllegalArgumentException("Found the " + conditionalResourceNode.getNodeName()
					+ " node under conditionalResources. Only conditionalResource is allowed.");
			}
			NodeList resourceElements = conditionalResourceNode.getChildNodes();
			ModuleConditionalResource resource = new ModuleConditionalResource();
			conditionalResources.add(resource);
			for (int j = 0; j < resourceElements.getLength(); j++) {
				Node resourceElement = resourceElements.item(j);
				if ("path".equals(resourceElement.getNodeName())) {
					if (StringUtils.isBlank(resourceElement.getTextContent())) {
						throw new IllegalArgumentException("The path of a conditional resource must not be blank");
					}
					resource.setPath(resourceElement.getTextContent());
				} else if ("openmrsVersion".equals(resourceElement.getNodeName())) {
					if (StringUtils.isBlank(resource.getOpenmrsPlatformVersion())) {
						resource.setOpenmrsPlatformVersion(resourceElement.getTextContent());
					}
				} else if ("openmrsPlatformVersion".equals(resourceElement.getNodeName())) {
					resource.setOpenmrsPlatformVersion(resourceElement.getTextContent());
				} else if ("modules".equals(resourceElement.getNodeName())) {
					NodeList modulesNode = resourceElement.getChildNodes();
					for (int k = 0; k < modulesNode.getLength(); k++) {
						Node moduleNode = modulesNode.item(k);
						if ("module".equals(moduleNode.getNodeName())) {
							NodeList moduleElements = moduleNode.getChildNodes();
							ModuleConditionalResource.ModuleAndVersion module = new ModuleConditionalResource.ModuleAndVersion();
							resource.getModules().add(module);
							for (int m = 0; m < moduleElements.getLength(); m++) {
								Node moduleElement = moduleElements.item(m);
								if ("moduleId".equals(moduleElement.getNodeName())) {
									module.setModuleId(moduleElement.getTextContent());
								} else if ("version".equals(moduleElement.getNodeName())) {
									module.setVersion(moduleElement.getTextContent());
								}
							}
						}
					}
				}
			}
		}
		return conditionalResources;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.openmrs.GlobalProperty;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.context.Context;
import org.openmrs.api.context.ServiceContext;
import org.openmrs.scheduler.SchedulerUtil;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
/**
 * Utility methods for working and manipulating modules
 */
public class ModuleUtil {
	private ModuleUtil() {
	}
	
	private static final Logger log = LoggerFactory.getLogger(ModuleUtil.class);
	
	/**
	 * Start up the module system with the given properties.
	 *
	 * @param props Properties (OpenMRS runtime properties)
	 */
	public static void startup(Properties props) throws ModuleMustStartException {
		
		String moduleListString = props.getProperty(ModuleConstants.RUNTIMEPROPERTY_MODULE_LIST_TO_LOAD);
		
		if (moduleListString == null || moduleListString.isEmpty()) {
			// Attempt to get all of the modules from the modules folder
			// and store them in the modules list
			log.debug("Starting all modules");
			ModuleFactory.loadModules();
		} else {
			// use the list of modules and load only those
			log.debug("Starting all modules in this list: " + moduleListString);
			
			String[] moduleArray = moduleListString.split(" ");
			List<File> modulesToLoad = new ArrayList<>();
			
			for (String modulePath : moduleArray) {
				if (modulePath != null && modulePath.length() > 0) {
					File file = new File(modulePath);
					if (file.exists()) {
						modulesToLoad.add(file);
					} else {
						// try to load the file from the classpath
						InputStream stream = ModuleUtil.class.getClassLoader().getResourceAsStream(modulePath);
						
						// expand the classpath-found file to a temporary location
						if (stream != null) {
							try {
								// get and make a temp directory if necessary
								String tmpDir = System.getProperty("java.io.tmpdir");
								File expandedFile = File.createTempFile(file.getName() + "-", ".omod", new File(tmpDir));
								
								// pull the name from the absolute path load attempt
								FileOutputStream outStream = new FileOutputStream(expandedFile, false);
								
								// do the actual file copying
								OpenmrsUtil.copyFile(stream, outStream);
								
								// add the freshly expanded file to the list of modules we're going to start up
								modulesToLoad.add(expandedFile);
								expandedFile.deleteOnExit();
							}
							catch (IOException io) {
								log.error("Unable to expand classpath found module: " + modulePath, io);
							}
						} else {
							log
							        .error("Unable to load module at path: "
							                + modulePath
							                + " because no file exists there and it is not found on the classpath. (absolute path tried: "
							                + file.getAbsolutePath() + ")");
						}
					}
				}
			}
			
			ModuleFactory.loadModules(modulesToLoad);
		}
		
		// start all of the modules we just loaded
		ModuleFactory.startModules();
		
		// some debugging info
		if (log.isDebugEnabled()) {
			Collection<Module> modules = ModuleFactory.getStartedModules();
			if (modules == null || modules.isEmpty()) {
				log.debug("No modules loaded");
			} else {
				log.debug("Found and loaded {} module(s)", modules.size());
			}
		}
		
		// make sure all openmrs required moduls are loaded and started
		checkOpenmrsCoreModulesStarted();
		
		// make sure all mandatory modules are loaded and started
		checkMandatoryModulesStarted();
	}
	
	/**
	 * Stops the module system by calling stopModule for all modules that are currently started
	 */
	public static void shutdown() {
		List<Module> modules = new ArrayList<>(ModuleFactory.getStartedModules());
		
		for (Module mod : modules) {
			log.debug("stopping module: {}", mod.getModuleId());
			
			if (mod.isStarted()) {
				ModuleFactory.stopModule(mod, true, true);
			}
		}
		
		log.debug("done shutting down modules");
		
		// clean up the static variables just in case they weren't done before
		ModuleFactory.extensionMap.clear();
		ModuleFactory.loadedModules.invalidateAll();
		ModuleFactory.moduleClassLoaders.invalidateAll();
		ModuleFactory.startedModules.invalidateAll();
	}
	
	/**
	 * Add the <code>inputStream</code> as a file in the modules repository
	 *
	 * @param inputStream <code>InputStream</code> to load
	 * @return filename String of the file's name of the stream
	 */
	public static File insertModuleFile(InputStream inputStream, String filename) {
		File folder = getModuleRepository();
		
		// check if module filename is already loaded
		if (OpenmrsUtil.folderContains(folder, filename)) {
			throw new ModuleException(filename + " is already associated with a loaded module.");
		}
		
		File file = new File(folder.getAbsolutePath(), filename);
		
		try (FileOutputStream outputStream = new FileOutputStream(file)) {
			OpenmrsUtil.copyFile(inputStream, outputStream);
		}
		catch (IOException e) {
			throw new ModuleException("Can't create module file for " + filename, e);
		}
		finally {
			try {
				inputStream.close();
			}
			catch (Exception e) { /* pass */}
		}
		
		return file;
	}
	/**
	 * Checks if the current OpenMRS version is in an array of versions.
	 * <p>
	 * This method calls {@link ModuleUtil#matchRequiredVersions(String, String)} internally.
	 * </p>
	 *
	 * @param versions the openmrs versions to be checked against the current openmrs version
	 * @return true if the current openmrs version is in versions otherwise false
	 * <strong>Should</strong> return false when versions is null
	 * <strong>Should</strong> return false when versions is empty
	 * <strong>Should</strong> return true if current openmrs version matches one element in versions
	 * <strong>Should</strong> return false if current openmrs version does not match any element in versions
	 */
	public static boolean isOpenmrsVersionInVersions(String ...versions) {
		if (versions == null || versions.length == 0) {
			return false;
		}
		boolean result = false;
		for (String version : versions) {
			if (matchRequiredVersions(OpenmrsConstants.OPENMRS_VERSION_SHORT, version)) {
				result = true;
				break;
			}
		}
		return result;
	}
	
	/**
	 * This method is an enhancement of {@link #compareVersion(String, String)} and adds support for
	 * wildcard characters and upperbounds. <br>
	 * <br>
	 * This method calls {@link ModuleUtil#checkRequiredVersion(String, String)} internally. <br>
	 * <br>
	 * The require version number in the config file can be in the following format:
	 * <ul>
	 * <li>1.2.3</li>
	 * <li>1.2.*</li>
	 * <li>1.2.2 - 1.2.3</li>
	 * <li>1.2.* - 1.3.*</li>
	 * </ul>
	 * <p>
	 * Again the possible require version number formats with their interpretation:
	 * <ul>
	 * <li>1.2.3 means 1.2.3 and above</li>
	 * <li>1.2.* means any version of the 1.2.x branch. That is 1.2.0, 1.2.1, 1.2.2,... but not 1.3.0, 1.4.0</li>
	 * <li>1.2.2 - 1.2.3 means 1.2.2 and 1.2.3 (inclusive)</li>
	 * <li>1.2.* - 1.3.* means any version of the 1.2.x and 1.3.x branch</li>
	 * </ul>
	 * </p>
	 *
	 * @param version openmrs version number to be compared
	 * @param versionRange value in the config file for required openmrs version
	 * @return true if the <code>version</code> is within the <code>value</code>
	 * <strong>Should</strong> allow ranged required version
	 * <strong>Should</strong> allow ranged required version with wild card
	 * <strong>Should</strong> allow ranged required version with wild card on one end
	 * <strong>Should</strong> allow single entry for required version
	 * <strong>Should</strong> allow required version with wild card
	 * <strong>Should</strong> allow non numeric character required version
	 * <strong>Should</strong> allow ranged non numeric character required version
	 * <strong>Should</strong> allow ranged non numeric character with wild card
	 * <strong>Should</strong> allow ranged non numeric character with wild card on one end
	 * <strong>Should</strong> return false when openmrs version beyond wild card range
	 * <strong>Should</strong> return false when required version beyond openmrs version
	 * <strong>Should</strong> return false when required version with wild card beyond openmrs version
	 * <strong>Should</strong> return false when required version with wild card on one end beyond openmrs version
	 * <strong>Should</strong> return false when single entry required version beyond openmrs version
	 * <strong>Should</strong> allow release type in the version
	 * <strong>Should</strong> match when revision number is below maximum revision number
	 * <strong>Should</strong> not match when revision number is above maximum revision number
	 * <strong>Should</strong> correctly set upper and lower limit for versionRange with qualifiers and wild card
	 * <strong>Should</strong> match when version has wild card plus qualifier and is within boundary
	 * <strong>Should</strong> not match when version has wild card plus qualifier and is outside boundary
	 * <strong>Should</strong> match when version has wild card and is within boundary
	 * <strong>Should</strong> not match when version has wild card and is outside boundary
	 * <strong>Should</strong> return true when required version is empty
	 */
	public static boolean matchRequiredVersions(String version, String versionRange) {
		// There is a null check so no risk in keeping the literal on the right side
		if (StringUtils.isNotEmpty(versionRange)) {
			String[] ranges = versionRange.split(",");
			for (String range : ranges) {
				// need to externalize this string
				String separator = "-";
				if (range.indexOf("*") > 0 || range.indexOf(separator) > 0 && (!isVersionWithQualifier(range))) {
					// if it contains "*" or "-" then we must separate those two
					// assume it's always going to be two part
					// assign the upper and lower bound
					// if there's no "-" to split lower and upper bound
					// then assign the same value for the lower and upper
					String lowerBound = range;
					String upperBound = range;
					
					int indexOfSeparator = range.indexOf(separator);
					while (indexOfSeparator > 0) {
						lowerBound = range.substring(0, indexOfSeparator);
						upperBound = range.substring(indexOfSeparator + 1);
						if (upperBound.matches("^\\s?\\d+.*")) {
							break;
						}
						indexOfSeparator = range.indexOf(separator, indexOfSeparator + 1);
					}
					
					// only preserve part of the string that match the following format:
					// - xx.yy.*
					// - xx.yy.zz*
					lowerBound = StringUtils.remove(lowerBound, lowerBound.replaceAll("^\\s?\\d+[\\.\\d+\\*?|\\.\\*]+", ""));
					upperBound = StringUtils.remove(upperBound, upperBound.replaceAll("^\\s?\\d+[\\.\\d+\\*?|\\.\\*]+", ""));
					
					// if the lower contains "*" then change it to zero
					if (lowerBound.indexOf("*") > 0) {
						lowerBound = lowerBound.replaceAll("\\*", "0");
					}
					
					// if the upper contains "*" then change it to maxRevisionNumber
					if (upperBound.indexOf("*") > 0) {
						upperBound = upperBound.replaceAll("\\*", Integer.toString(Integer.MAX_VALUE));
					}
					
					int lowerReturn = compareVersion(version, lowerBound);
					
					int upperReturn = compareVersion(version, upperBound);
					
					if (lowerReturn < 0 || upperReturn > 0) {
						log.debug("Version " + version + " is not between " + lowerBound + " and " + upperBound);
					} else {
						return true;
					}
				} else {
					if (compareVersion(version, range) < 0) {
						log.debug("Version " + version + " is below " + range);
					} else {
						return true;
					}
				}
			}
		}
		else {
			//no version checking if required version is not specified
			return true;
		}
		
		return false;
	}
	
	/**
	 * This method is an enhancement of {@link #compareVersion(String, String)} and adds support for
	 * wildcard characters and upperbounds. <br>
	 * <br>
	 * <br>
	 * The require version number in the config file can be in the following format:
	 * <ul>
	 * <li>1.2.3</li>
	 * <li>1.2.*</li>
	 * <li>1.2.2 - 1.2.3</li>
	 * <li>1.2.* - 1.3.*</li>
	 * </ul>
	 * <p>
	 * Again the possible require version number formats with their interpretation:
	 * <ul>
	 * <li>1.2.3 means 1.2.3 and above</li>
	 * <li>1.2.* means any version of the 1.2.x branch. That is 1.2.0, 1.2.1, 1.2.2,... but not 1.3.0, 1.4.0</li>
	 * <li>1.2.2 - 1.2.3 means 1.2.2 and 1.2.3 (inclusive)</li>
	 * <li>1.2.* - 1.3.* means any version of the 1.2.x and 1.3.x branch</li>
	 * </ul>
	 * </p>
	 *
	 * @param version openmrs version number to be compared
	 * @param versionRange value in the config file for required openmrs version
	 * @throws ModuleException if the <code>version</code> is not within the <code>value</code>
	 * <strong>Should</strong> throw ModuleException if openmrs version beyond wild card range
	 * <strong>Should</strong> throw ModuleException if required version beyond openmrs version
	 * <strong>Should</strong> throw ModuleException if required version with wild card beyond openmrs version
	 * <strong>Should</strong> throw ModuleException if required version with wild card on one end beyond openmrs
	 *         version
	 * <strong>Should</strong> throw ModuleException if single entry required version beyond openmrs version
	 * <strong>Should</strong> throw ModuleException if SNAPSHOT not handled correctly
	 * <strong>Should</strong> handle SNAPSHOT versions
	 * <strong>Should</strong> handle ALPHA versions
	 */
	public static void checkRequiredVersion(String version, String versionRange) throws ModuleException {
		if (!matchRequiredVersions(version, versionRange)) {
			String ms = Context.getMessageSourceService().getMessage("Module.requireVersion.outOfBounds",
			    new String[] { versionRange, version }, Context.getLocale());
			throw new ModuleException(ms);
		}
	}
	
	/**
	 * Compares <code>version</code> to <code>value</code> version and value are strings like
	 * 1.9.2.0 Returns <code>0</code> if either <code>version</code> or <code>value</code> is null.
	 *
	 * @param version String like 1.9.2.0
	 * @param value String like 1.9.2.0
	 * @return the value <code>0</code> if <code>version</code> is equal to the argument
	 *         <code>value</code>; a value less than <code>0</code> if <code>version</code> is
	 *         numerically less than the argument <code>value</code>; and a value greater than
	 *         <code>0</code> if <code>version</code> is numerically greater than the argument
	 *         <code>value</code>
	 * <strong>Should</strong> correctly comparing two version numbers
	 * <strong>Should</strong> treat SNAPSHOT as earliest version
	 */
	public static int compareVersion(String version, String value) {
		try {
			if (version == null || value == null) {
				return 0;
			}
			
			List<String> versions = new ArrayList<>();
			List<String> values = new ArrayList<>();
			String separator = "-";
			
			// strip off any qualifier e.g. "-SNAPSHOT"
			int qualifierIndex = version.indexOf(separator);
			if (qualifierIndex != -1) {
				version = version.substring(0, qualifierIndex);
			}
			
			qualifierIndex = value.indexOf(separator);
			if (qualifierIndex != -1) {
				value = value.substring(0, qualifierIndex);
			}
			
			Collections.addAll(versions, version.split("\\."));
			Collections.addAll(values, value.split("\\."));
			
			// match the sizes of the lists
			while (versions.size() < values.size()) {
				versions.add("0");
			}
			while (values.size() < versions.size()) {
				values.add("0");
			}
			
			for (int x = 0; x < versions.size(); x++) {
				String verNum = versions.get(x).trim();
				String valNum = values.get(x).trim();
				Long ver = NumberUtils.toLong(verNum, 0);
				Long val = NumberUtils.toLong(valNum, 0);
				
				int ret = ver.compareTo(val);
				if (ret != 0) {
					return ret;
				}
			}
		}
		catch (NumberFormatException e) {
			log.error("Error while converting a version/value to an integer: " + version + "/" + value, e);
		}
		
		// default return value if an error occurs or elements are equal
		return 0;
	}
	
	/**
	 * Checks for qualifier version (i.e "-SNAPSHOT", "-ALPHA" etc. after maven version conventions)
	 *
	 * @param version String like 1.9.2-SNAPSHOT
	 * @return true if version contains qualifier
	 */
	public static boolean isVersionWithQualifier(String version) {
		Matcher matcher = Pattern.compile("(\\d+)\\.(\\d+)(\\.(\\d+))?(\\-([A-Za-z]+))").matcher(version);
		return matcher.matches();
	}
	
	/**
	 * Gets the folder where modules are stored. ModuleExceptions are thrown on errors
	 *
	 * @return folder containing modules
	 * <strong>Should</strong> use the runtime property as the first choice if specified
	 * <strong>Should</strong> return the correct file if the runtime property is an absolute path
	 */
	public static File getModuleRepository() {
		
		String folderName = Context.getRuntimeProperties().getProperty(ModuleConstants.REPOSITORY_FOLDER_RUNTIME_PROPERTY);
		if (StringUtils.isBlank(folderName)) {
			AdministrationService as = Context.getAdministrationService();
			folderName = as.getGlobalProperty(ModuleConstants.REPOSITORY_FOLDER_PROPERTY,
			    ModuleConstants.REPOSITORY_FOLDER_PROPERTY_DEFAULT);
		}
		// try to load the repository folder straight away.
		File folder = new File(folderName);
		
		// if the property wasn't a full path already, assume it was intended to be a folder in the
		// application directory
		if (!folder.exists()) {
			folder = new File(OpenmrsUtil.getApplicationDataDirectory(), folderName);
		}
		
		// now create the modules folder if it doesn't exist
		if (!folder.exists()) {
			log.warn("Module repository " + folder.getAbsolutePath() + " doesn't exist.  Creating directories now.");
			folder.mkdirs();
		}
		
		if (!folder.isDirectory()) {
			throw new ModuleException("Module repository is not a directory at: " + folder.getAbsolutePath());
		}
		
		return folder;
	}
	
	/**
	 * Utility method to convert a {@link File} object to a local URL.
	 *
	 * @param file a file object
	 * @return absolute URL that points to the given file
	 * @throws MalformedURLException if file can't be represented as URL for some reason
	 */
	public static URL file2url(final File file) throws MalformedURLException {
		if (file == null) {
			return null;
		}
		try {
			return file.getCanonicalFile().toURI().toURL();
		}
		catch (IOException | NoSuchMethodError ioe) {
			throw new MalformedURLException("Cannot convert: " + file.getName() + " to url");
		}
	}
	
	/**
	 * Expand the given <code>fileToExpand</code> jar to the <code>tmpModuleFile</code> directory
	 *
	 * If <code>name</code> is null, the entire jar is expanded. If<code>name</code> is not null,
	 * then only that path/file is expanded.
	 *
	 * @param fileToExpand file pointing at a .jar
	 * @param tmpModuleDir directory in which to place the files
	 * @param name filename inside of the jar to look for and expand
	 * @param keepFullPath if true, will recreate entire directory structure in tmpModuleDir
	 *            relating to <code>name</code>. if false will start directory structure at
	 *            <code>name</code>
	 * <strong>Should</strong> expand entire jar if name is null
	 * <strong>Should</strong> expand entire jar if name is empty string
	 * <strong>Should</strong> expand directory with parent tree if name is directory and keepFullPath is true
	 * <strong>Should</strong> expand directory without parent tree if name is directory and keepFullPath is false
	 * <strong>Should</strong> expand file with parent tree if name is file and keepFullPath is true
	 */
	public static void expandJar(File fileToExpand, File tmpModuleDir, String name, boolean keepFullPath) throws IOException {
		String docBase = tmpModuleDir.getAbsolutePath();
		try (JarFile jarFile = new JarFile(fileToExpand)) {
			Enumeration<JarEntry> jarEntries = jarFile.entries();
			boolean foundName = (name == null);
			
			// loop over all of the elements looking for the match to 'name'
			while (jarEntries.hasMoreElements()) {
				JarEntry jarEntry = jarEntries.nextElement();
				if (name == null || jarEntry.getName().startsWith(name)) {
					String entryName = jarEntry.getName();
					// trim out the name path from the name of the new file
					if (!keepFullPath && name != null) {
						entryName = entryName.replaceFirst(name, "");
					}
					
					// if it has a slash, it's in a directory
					int last = entryName.lastIndexOf('/');
					if (last >= 0) {
						File parent = new File(docBase, entryName.substring(0, last));
						parent.mkdirs();
						log.debug("Creating parent dirs: " + parent.getAbsolutePath());
					}
					// we don't want to "expand" directories or empty names
					if (entryName.endsWith("/") || "".equals(entryName)) {
						continue;
					}
					try(InputStream input = jarFile.getInputStream(jarEntry)) {
						expand(input, docBase, entryName);
					}
					foundName = true;
				}
			}
			if (!foundName) {
				log.debug("Unable to find: " + name + " in file " + fileToExpand.getAbsolutePath());
			}
			
		}
		catch (IOException e) {
			log.warn("Unable to delete tmpModuleFile on error", e);
			throw e;
		}
	}
	
	/**
	 * Expand the given file in the given stream to a location (fileDir/name) The <code>input</code>
	 * InputStream is not closed in this method
	 *
	 * @param input stream to read from
	 * @param fileDir directory to copy to
	 * @param name file/directory within the <code>fileDir</code> to which we expand
	 *            <code>input</code>
	 * @return File the file created by the expansion.
	 * @throws IOException if an error occurred while copying
	 */
	private static void expand(InputStream input, String fileDir, String name) throws IOException {
		log.debug("expanding: {}", name);
		File file = new File(fileDir, name);
		if (!file.toPath().normalize().startsWith(fileDir)) {
			throw new UnsupportedOperationException("Attempted to write file '" + name + "' rejected as it attempts to write outside the chosen directory. This may be the result of a zip-slip style attack.");
		}
		
		try (FileOutputStream outStream = new FileOutputStream(file)) {
			OpenmrsUtil.copyFile(input, outStream);
		}
	}
	
	/**
	 * Downloads the contents of a URL and copies them to a string (Borrowed from oreilly)
	 *
	 * @param url
	 * @return InputStream of contents
	 * <strong>Should</strong> return a valid input stream for old module urls
	 */
	public static InputStream getURLStream(URL url) {
		InputStream in = null;
		try {
			URLConnection uc = url.openConnection();
			uc.setDefaultUseCaches(false);
			uc.setUseCaches(false);
			uc.setRequestProperty("Cache-Control", "max-age=0,no-cache");
			uc.setRequestProperty("Pragma", "no-cache");
			
			log.debug("Logging an attempt to connect to: " + url);
			
			in = openConnectionCheckRedirects(uc);
		}
		catch (IOException io) {
			log.warn("io while reading: " + url, io);
		}
		
		return in;
	}
	
	/**
	 * Convenience method to follow http to https redirects. Will follow a total of 5 redirects,
	 * then fail out due to foolishness on the url's part.
	 *
	 * @param c the {@link URLConnection} to open
	 * @return an {@link InputStream} that is not necessarily at the same url, possibly at a 403
	 *         redirect.
	 * @throws IOException
	 * @see #getURLStream(URL)
	 */
	protected static InputStream openConnectionCheckRedirects(URLConnection c) throws IOException {
		boolean redir;
		int redirects = 0;
		InputStream in;
		do {
			if (c instanceof HttpURLConnection) {
				((HttpURLConnection) c).setInstanceFollowRedirects(false);
			}
			// We want to open the input stream before getting headers
			// because getHeaderField() et al swallow IOExceptions.
			in = c.getInputStream();
			redir = false;
			if (c instanceof HttpURLConnection) {
				HttpURLConnection http = (HttpURLConnection) c;
				int stat = http.getResponseCode();
				if (stat == 300 || stat == 301 || stat == 302 || stat == 303 || stat == 305 || stat == 307) {
					URL base = http.getURL();
					String loc = http.getHeaderField("Location");
					URL target = null;
					if (loc != null) {
						target = new URL(base, loc);
					}
					http.disconnect();
					// Redirection should be allowed only for HTTP and HTTPS
					// and should be limited to 5 redirects at most.
					if (target == null || !("http".equals(target.getProtocol()) || "https".equals(target.getProtocol()))
					        || redirects >= 5) {
						throw new SecurityException("illegal URL redirect");
					}
					redir = true;
					c = target.openConnection();
					redirects++;
				}
			}
		} while (redir);
		return in;
	}
	
	/**
	 * Downloads the contents of a URL and copies them to a string (Borrowed from oreilly)
	 *
	 * @param url
	 * @return String contents of the URL
	 * <strong>Should</strong> return an update rdf page for old https dev urls
	 * <strong>Should</strong> return an update rdf page for old https module urls
	 * <strong>Should</strong> return an update rdf page for module urls
	 */
	public static String getURL(URL url) {
		InputStream in = null;
		ByteArrayOutputStream out = null;
		String output = "";
		try {
			in = getURLStream(url);
			if (in == null) {
				// skip this module if updateURL is not defined
				return "";
			}
			
			out = new ByteArrayOutputStream();
			OpenmrsUtil.copyFile(in, out);
			output = out.toString(StandardCharsets.UTF_8.name());
		}
		catch (IOException io) {
			log.warn("io while reading: " + url, io);
		}
		finally {
			try {
				in.close();
			}
			catch (Exception e) { /* pass */}
			try {
				out.close();
			}
			catch (Exception e) { /* pass */}
		}
		
		return output;
	}
	
	/**
	 * Iterates over the modules and checks each update.rdf file for an update
	 *
	 * @return True if an update was found for one of the modules, false if none were found
	 * @throws ModuleException
	 */
	public static Boolean checkForModuleUpdates() throws ModuleException {
		
		Boolean updateFound = false;
		
		for (Module mod : ModuleFactory.getLoadedModules()) {
			String updateURL = mod.getUpdateURL();
			if (StringUtils.isNotEmpty(updateURL)) {
				try {
					// get the contents pointed to by the url
					URL url = new URL(updateURL);
					if (!url.toString().endsWith(ModuleConstants.UPDATE_FILE_NAME)) {
						log.warn("Illegal url: " + url);
						continue;
					}
					String content = getURL(url);
					
					// skip empty or invalid updates
					if ("".equals(content)) {
						continue;
					}
					
					// process and parse the contents
					UpdateFileParser parser = new UpdateFileParser(content);
					parser.parse();
					
					log.debug("Update for mod: " + mod.getModuleId() + " compareVersion result: "
					        + compareVersion(mod.getVersion(), parser.getCurrentVersion()));
					
					// check the update.rdf version against the installed version
					if (compareVersion(mod.getVersion(), parser.getCurrentVersion()) < 0) {
						if (mod.getModuleId().equals(parser.getModuleId())) {
							mod.setDownloadURL(parser.getDownloadURL());
							mod.setUpdateVersion(parser.getCurrentVersion());
							updateFound = true;
						} else {
							log.warn("Module id does not match in update.rdf:" + parser.getModuleId());
						}
					} else {
						mod.setDownloadURL(null);
						mod.setUpdateVersion(null);
					}
				}
				catch (ModuleException e) {
					log.warn("Unable to get updates from update.xml", e);
				}
				catch (MalformedURLException e) {
					log.warn("Unable to form a URL object out of: " + updateURL, e);
				}
			}
		}
		
		return updateFound;
	}
	
	/**
	 * @return true/false whether the 'allow upload' or 'allow web admin' property has been turned
	 *         on
	 */
	public static Boolean allowAdmin() {
		
		Properties properties = Context.getRuntimeProperties();
		String prop = properties.getProperty(ModuleConstants.RUNTIMEPROPERTY_ALLOW_UPLOAD, null);
		if (prop == null) {
			prop = properties.getProperty(ModuleConstants.RUNTIMEPROPERTY_ALLOW_ADMIN, "false");
		}
		
		return "true".equals(prop);
	}
	
	/**
	 * @see ModuleUtil#refreshApplicationContext(AbstractRefreshableApplicationContext, boolean, Module)
	 */
	public static AbstractRefreshableApplicationContext refreshApplicationContext(AbstractRefreshableApplicationContext ctx) {
		return refreshApplicationContext(ctx, false, null);
	}
	
	/**
	 * Refreshes the given application context "properly" in OpenMRS. Will first shut down the
	 * Context and destroy the classloader, then will refresh and set everything back up again.
	 *
	 * @param ctx Spring application context that needs refreshing.
	 * @param isOpenmrsStartup if this refresh is being done at application startup.
	 * @param startedModule the module that was just started and waiting on the context refresh.
	 * @return AbstractRefreshableApplicationContext The newly refreshed application context.
	 */
	public static AbstractRefreshableApplicationContext refreshApplicationContext(AbstractRefreshableApplicationContext ctx,
	        boolean isOpenmrsStartup, Module startedModule) {
		//notify all started modules that we are about to refresh the context
		Set<Module> startedModules = new LinkedHashSet<>(ModuleFactory.getStartedModulesInOrder());
		for (Module module : startedModules) {
			try {
				if (module.getModuleActivator() != null) {
					Thread.currentThread().setContextClassLoader(ModuleFactory.getModuleClassLoader(module));
					module.getModuleActivator().willRefreshContext();
				}
			}
			catch (Exception e) {
				log.warn("Unable to call willRefreshContext() method in the module's activator", e);
			}
		}
		
		OpenmrsClassLoader.saveState();
		SchedulerUtil.shutdown();
		ServiceContext.destroyInstance();
		
		try {
			ctx.stop();
			ctx.close();
		}
		catch (Exception e) {
			log.warn("Exception while stopping and closing context: ", e);
			// Spring seems to be trying to refresh the context instead of /just/ stopping
			// pass
		}
		OpenmrsClassLoader.destroyInstance();
		ctx.setClassLoader(OpenmrsClassLoader.getInstance());
		Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
		
		ServiceContext.getInstance().startRefreshingContext();
		try {
			ctx.refresh();
		}
		finally {
			ServiceContext.getInstance().doneRefreshingContext();
		}
		
		ctx.setClassLoader(OpenmrsClassLoader.getInstance());
		Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
		
		OpenmrsClassLoader.restoreState();
		SchedulerUtil.startup(Context.getRuntimeProperties());
		
		OpenmrsClassLoader.setThreadsToNewClassLoader();
		
		// reload the advice points that were lost when refreshing Spring
		log.debug("Reloading advice for all started modules: {}", startedModules.size());
		
		try {
			//The call backs in this block may need lazy loading of objects
			//which will fail because we use an OpenSessionInViewFilter whose opened session
			//was closed when the application context was refreshed as above.
			//So we need to open another session now. TRUNK-3739
			Context.openSessionWithCurrentUser();
			for (Module module : startedModules) {
				if (!module.isStarted()) {
					continue;
				}
				
				ModuleFactory.loadAdvice(module);
				try {
					ModuleFactory.passDaemonToken(module);
					
					if (module.getModuleActivator() != null) {
						module.getModuleActivator().contextRefreshed();
						try {
							//if it is system start up, call the started method for all started modules
							if (isOpenmrsStartup) {
								module.getModuleActivator().started();
							}
							//if refreshing the context after a user started or uploaded a new module
							else if (!isOpenmrsStartup && module.equals(startedModule)) {
								module.getModuleActivator().started();
							}
						}
						catch (Exception e) {
							log.warn("Unable to invoke started() method on the module's activator", e);
							ModuleFactory.stopModule(module, true, true);
						}
					}
					
				}
				catch (Exception e) {
					log.warn("Unable to invoke method on the module's activator ", e);
				}
			}
		}
		finally {
			Context.closeSessionWithCurrentUser();
		}
		
		return ctx;
	}
	
	/**
	 * Looks at the &lt;moduleid&gt;.mandatory properties and at the currently started modules to make
	 * sure that all mandatory modules have been started successfully.
	 *
	 * @throws ModuleException if a mandatory module isn't started
	 * <strong>Should</strong> throw ModuleException if a mandatory module is not started
	 */
	protected static void checkMandatoryModulesStarted() throws ModuleException {
		
		List<String> mandatoryModuleIds = getMandatoryModules();
		Set<String> startedModuleIds = ModuleFactory.getStartedModulesMap().keySet();
		
		mandatoryModuleIds.removeAll(startedModuleIds);
		
		// any module ids left in the list are not started
		if (!mandatoryModuleIds.isEmpty()) {
			throw new MandatoryModuleException(mandatoryModuleIds);
		}
	}
	
	/**
	 * Looks at the list of modules in {@link ModuleConstants#CORE_MODULES} to make sure that all
	 * modules that are core to OpenMRS are started and have at least a minimum version that OpenMRS
	 * needs.
	 *
	 * @throws ModuleException if a module that is core to OpenMRS is not started
	 * <strong>Should</strong> throw ModuleException if a core module is not started
	 */
	protected static void checkOpenmrsCoreModulesStarted() throws OpenmrsCoreModuleException {
		
		// if there is a property telling us to ignore required modules, drop out early
		if (ignoreCoreModules()) {
			return;
		}
		
		// make a copy of the constant so we can modify the list
		Map<String, String> coreModules = new HashMap<>(ModuleConstants.CORE_MODULES);
		
		Collection<Module> startedModules = ModuleFactory.getStartedModulesMap().values();
		
		// loop through the current modules and test them
		for (Module mod : startedModules) {
			String moduleId = mod.getModuleId();
			if (coreModules.containsKey(moduleId)) {
				String coreReqVersion = coreModules.get(moduleId);
				if (compareVersion(mod.getVersion(), coreReqVersion) >= 0) {
					coreModules.remove(moduleId);
				} else {
					log.debug("Module: " + moduleId + " is a core module and is started, but its version: "
					        + mod.getVersion() + " is not within the required version: " + coreReqVersion);
				}
			}
		}
		
		// any module ids left in the list are not started
		if (coreModules.size() > 0) {
			throw new OpenmrsCoreModuleException(coreModules);
		}
	}
	
	/**
	 * Uses the runtime properties to determine if the core modules should be enforced or not.
	 *
	 * @return true if the core modules list can be ignored.
	 */
	public static boolean ignoreCoreModules() {
		String ignoreCoreModules = Context.getRuntimeProperties().getProperty(ModuleConstants.IGNORE_CORE_MODULES_PROPERTY,
		    "false");
		return Boolean.parseBoolean(ignoreCoreModules);
	}
	
	/**
	 * Returns all modules that are marked as mandatory. Currently this means there is a
	 * &lt;moduleid&gt;.mandatory=true global property.
	 *
	 * @return list of modules ids for mandatory modules
	 * <strong>Should</strong> return mandatory module ids
	 */
	public static List<String> getMandatoryModules() {
		
		List<String> mandatoryModuleIds = new ArrayList<>();
		
		try {
			List<GlobalProperty> props = Context.getAdministrationService().getGlobalPropertiesBySuffix(".mandatory");
			
			for (GlobalProperty prop : props) {
				if ("true".equalsIgnoreCase(prop.getPropertyValue())) {
					mandatoryModuleIds.add(prop.getProperty().replace(".mandatory", ""));
				}
			}
		}
		catch (Exception e) {
			log.warn("Unable to get the mandatory module list", e);
		}
		
		return mandatoryModuleIds;
	}
	
	/**
	 * <pre>
	 * Gets the module that should handle a path. The path you pass in should be a module id (in
	 * path format, i.e. /ui/springmvc, not ui.springmvc) followed by a resource. Something like
	 * the following:
	 *   /ui/springmvc/css/ui.css
	 *
	 * The first running module out of the following would be returned:
	 *   ui.springmvc.css
	 *   ui.springmvc
	 *   ui
	 * </pre>
	 *
	 * @param path
	 * @return the running module that matches the most of the given path
	 * <strong>Should</strong> handle ui springmvc css ui dot css when ui dot springmvc module is running
	 * <strong>Should</strong> handle ui springmvc css ui dot css when ui module is running
	 * <strong>Should</strong> return null for ui springmvc css ui dot css when no relevant module is running
	 */
	public static Module getModuleForPath(String path) {
		int ind = path.lastIndexOf('/');
		if (ind <= 0) {
			throw new IllegalArgumentException(
			        "Input must be /moduleId/resource. Input needs a / after the first character: " + path);
		}
		String moduleId = path.startsWith("/") ? path.substring(1, ind) : path.substring(0, ind);
		moduleId = moduleId.replace('/', '.');
		// iterate over progressively shorter module ids
		while (true) {
			Module mod = ModuleFactory.getStartedModuleById(moduleId);
			if (mod != null) {
				return mod;
			}
			// try the next shorter module id
			ind = moduleId.lastIndexOf('.');
			if (ind < 0) {
				break;
			}
			moduleId = moduleId.substring(0, ind);
		}
		return null;
	}
	
	/**
	 * Takes a global path and returns the local path within the specified module. For example
	 * calling this method with the path "/ui/springmvc/css/ui.css" and the ui.springmvc module, you
	 * would get "/css/ui.css".
	 *
	 * @param module
	 * @param path
	 * @return local path
	 * <strong>Should</strong> handle ui springmvc css ui dot css example
	 */
	public static String getPathForResource(Module module, String path) {
		if (path.startsWith("/")) {
			path = path.substring(1);
		}
		return path.substring(module.getModuleIdAsPath().length());
	}
	
	/**
	 * This loops over all FILES in this jar to get the package names. If there is an empty
	 * directory in this jar it is not returned as a providedPackage.
	 *
	 * @param file jar file to look into
	 * @return list of strings of package names in this jar
	 */
	public static Collection<String> getPackagesFromFile(File file) {
		
		// End early if we're given a non jar file
		if (!file.getName().endsWith(".jar")) {
			return Collections.emptySet();
		}
		
		Set<String> packagesProvided = new HashSet<>();
		
		JarFile jar = null;
		try {
			jar = new JarFile(file);
			
			Enumeration<JarEntry> jarEntries = jar.entries();
			while (jarEntries.hasMoreElements()) {
				JarEntry jarEntry = jarEntries.nextElement();
				if (jarEntry.isDirectory()) {
					// skip over directory entries, we only care about files
					continue;
				}
				String name = jarEntry.getName();
				
				// Skip over some folders in the jar/omod
				if (name.startsWith("lib") || name.startsWith("META-INF") || name.startsWith("web/module")) {
					continue;
				}
				
				Integer indexOfLastSlash = name.lastIndexOf("/");
				if (indexOfLastSlash <= 0) {
					continue;
				}
				String packageName = name.substring(0, indexOfLastSlash);
				
				packageName = packageName.replaceAll("/", ".");
				
				if (packagesProvided.add(packageName) && log.isTraceEnabled()) {
					log.trace("Adding module's jarentry with package: " + packageName);
				}
			}
			
			jar.close();
		}
		catch (IOException e) {
			log.error("Error while reading file: " + file.getAbsolutePath(), e);
		}
		finally {
			if (jar != null) {
				try {
					jar.close();
				}
				catch (IOException e) {
					// Ignore quietly
				}
			}
		}
		
		return packagesProvided;
	}
	
	/**
	 * Get a resource as from the module's api jar. Api jar should be in the omod's lib folder.
	 * 
	 * @param jarFile omod file loaded as jar
	 * @param moduleId id of the module
	 * @param version version of the module
	 * @param resource name of a resource from the api jar
	 * @return resource as an input stream or <code>null</code> if resource cannot be loaded
	 * <strong>Should</strong> load file from api as input stream
	 * <strong>Should</strong> return null if api is not found
	 * <strong>Should</strong> return null if file is not found in api
	 */
	public static InputStream getResourceFromApi(JarFile jarFile, String moduleId, String version, String resource) {
		String apiLocation = "lib/" + moduleId + "-api-" + version + ".jar";
		return getResourceFromInnerJar(jarFile, apiLocation, resource);
	}
	
	/**
	 * Load resource from a jar inside a jar.
	 * 
	 * @param outerJarFile jar file that contains a jar file
	 * @param innerJarFileLocation inner jar file location relative to the outer jar
	 * @param resource path to a resource relative to the inner jar
	 * @return resource from the inner jar as an input stream or <code>null</code> if resource cannot be loaded
	 */
	private static InputStream getResourceFromInnerJar(JarFile outerJarFile, String innerJarFileLocation, String resource) {
		File tempFile = null;
		FileOutputStream tempOut = null;
		JarFile innerJarFile = null;
		InputStream innerInputStream = null;
		try {
			tempFile = File.createTempFile("tempFile", "jar");
			tempOut = new FileOutputStream(tempFile);
			ZipEntry innerJarFileEntry = outerJarFile.getEntry(innerJarFileLocation);
			if (innerJarFileEntry != null) {
				IOUtils.copy(outerJarFile.getInputStream(innerJarFileEntry), tempOut);
				innerJarFile = new JarFile(tempFile);
				ZipEntry targetEntry = innerJarFile.getEntry(resource);
				if (targetEntry != null) {
					// clone InputStream to make it work after the innerJarFile is closed
					innerInputStream = innerJarFile.getInputStream(targetEntry);
					byte[] byteArray = IOUtils.toByteArray(innerInputStream);
					return new ByteArrayInputStream(byteArray);
				}
			}
		}
		catch (IOException e) {
			log.error("Unable to get '" + resource + "' from '" + innerJarFileLocation + "' of '" + outerJarFile.getName()
			        + "'", e);
		}
		finally {
			IOUtils.closeQuietly(tempOut);
			IOUtils.closeQuietly(innerInputStream);
			// close inner jar file before attempting to delete temporary file
			try {
				if (innerJarFile != null) {
					innerJarFile.close();
				}
			}
			catch (IOException e) {
				log.warn("Unable to close inner jarfile: " + innerJarFile, e);
			}
			// delete temporary file
			if (tempFile != null && !tempFile.delete()) {
				log.warn("Could not delete temporary jarfile: " + tempFile);
			}
		}
		return null;
	}
	
	/**
	 * Gets the root folder of a module's sources during development
	 * 
	 * @param moduleId the module id
	 * @return the module's development folder is specified, else null
	 */
	public static File getDevelopmentDirectory(String moduleId) {
		String directory = System.getProperty(moduleId + ".development.directory");
		if (StringUtils.isNotBlank(directory)) {
			return new File(directory);
		}
		
		return null;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs;
import java.util.Date;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.openmrs.customdatatype.CustomDatatype;
import org.openmrs.customdatatype.CustomDatatypeUtil;
import org.openmrs.customdatatype.CustomValueDescriptor;
import org.openmrs.customdatatype.SingleCustomValue;
/**
 * Global properties are simple key-value pairs persisted in the database GPs can be thought of as
 * something similar to environment variables used in operating systems.
 */
@Audited
public class GlobalProperty extends BaseOpenmrsObject implements CustomValueDescriptor, SingleCustomValue<GlobalProperty> {
	
	private static final long serialVersionUID = 1L;
	
	private String property = "";
	
	private String propertyValue = "";
	
	private transient Object typedValue;
	
	// if true, indicates that setValue has been called, and we need to invoke CustomDatatype's save
	private boolean dirty = false;
	
	private String description = "";
	
	private String datatypeClassname;
	
	private String datatypeConfig;
	
	private String preferredHandlerClassname;
	
	private String handlerConfig;
	
	private User changedBy;
	
	private Date dateChanged;
	
	private Privilege viewPrivilege;
	
	private Privilege editPrivilege;
	
	private Privilege deletePrivilege;
	
	
	/**
	 * Default empty constructor
	 */
	public GlobalProperty() {
	}
	
	/**
	 * Constructor defining the key for this GP
	 *
	 * @param property key to name the property
	 */
	public GlobalProperty(String property) {
		this.property = property;
	}
	
	/**
	 * Constructor defining the key and value of this GP
	 *
	 * @param property key to name the property
	 * @param value value to give to the property
	 */
	public GlobalProperty(String property, String value) {
		this(property);
		this.propertyValue = value;
	}
	
	/**
	 * Constructor defining key/value/description for this GP
	 *
	 * @param property key to name the property
	 * @param value value to give to the property
	 * @param description description of how this property is used
	 */
	public GlobalProperty(String property, String value, String description) {
		this(property, value);
		this.description = description;
	}
	
	/**
	 * Constructor defining key/value/description/customDatatype/datatypeConfig
	 *
	 * @param property
	 * @param value
	 * @param description
	 * @param datatypeClass
	 * @param datatypeConfig
	 *
	 * @since 1.9
	 */
	public GlobalProperty(String property, String value, String description,
	    Class<? extends CustomDatatype<?>> datatypeClass, String datatypeConfig) {
		this(property, value, description);
		this.datatypeClassname = datatypeClass.getName();
		this.datatypeConfig = datatypeConfig;
	}
	
	/**
	 * @return Returns the property.
	 */
	public String getProperty() {
		return property;
	}
	
	/**
	 * @param property The property to set.
	 */
	public void setProperty(String property) {
		this.property = property;
	}
	
	/**
	 * @return Returns the propertyValue.
	 */
	public String getPropertyValue() {
		return propertyValue;
	}
	
	/**
	 * @param propertyValue The propertyValue to set.
	 */
	public void setPropertyValue(String propertyValue) {
		this.propertyValue = propertyValue;
	}
	
	/**
	 * @return the description
	 */
	public String getDescription() {
		return description;
	}
	
	/**
	 * @param description the description to set
	 */
	public void setDescription(String description) {
		this.description = description;
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#getId()
	 */
	@Override
	public Integer getId() {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#setId(java.lang.Integer)
	 */
	@Override
	public void setId(Integer id) {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * @see org.openmrs.customdatatype.CustomValueDescriptor#getDatatypeClassname()
	 * @since 1.9
	 */
	@Override
	public String getDatatypeClassname() {
		return datatypeClassname;
	}
	
	/**
	 * @param datatypeClassname the datatypeClassname to set
	 * @since 1.9
	 */
	public void setDatatypeClassname(String datatypeClassname) {
		this.datatypeClassname = datatypeClassname;
	}
	
	/**
	 * @see org.openmrs.customdatatype.CustomValueDescriptor#getDatatypeConfig()
	 * @since 1.9
	 */
	@Override
	public String getDatatypeConfig() {
		return datatypeConfig;
	}
	
	/**
	 * @param datatypeConfig the datatypeConfig to set
	 * @since 1.9
	 */
	public void setDatatypeConfig(String datatypeConfig) {
		this.datatypeConfig = datatypeConfig;
	}
	
	/**
	 * @see org.openmrs.customdatatype.CustomValueDescriptor#getPreferredHandlerClassname()
	 * @since 1.9
	 */
	@Override
	public String getPreferredHandlerClassname() {
		return preferredHandlerClassname;
	}
	
	/**
	 * @param preferredHandlerClassname the preferredHandlerClassname to set
	 * @since 1.9
	 */
	public void setPreferredHandlerClassname(String preferredHandlerClassname) {
		this.preferredHandlerClassname = preferredHandlerClassname;
	}
	
	/**
	 * @see org.openmrs.customdatatype.CustomValueDescriptor#getHandlerConfig()
	 * @since 1.9
	 */
	@Override
	public String getHandlerConfig() {
		return handlerConfig;
	}
	
	/**
	 * @param handlerConfig the handlerConfig to set
	 * @since 1.9
	 */
	public void setHandlerConfig(String handlerConfig) {
		this.handlerConfig = handlerConfig;
	}
	
	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return "property: " + getProperty() + " value: " + getPropertyValue();
	}
	
	/**
	 * @see org.openmrs.customdatatype.SingleCustomValue#getDescriptor()
	 *
	 * @since 1.9
	 */
	@Override
	public GlobalProperty getDescriptor() {
		return this;
	}
	
	/**
	 * @see org.openmrs.customdatatype.SingleCustomValue#getValueReference()
	 *
	 * @since 1.9
	 */
	@Override
	public String getValueReference() {
		return getPropertyValue();
	}
	
	/**
	 * @see org.openmrs.customdatatype.SingleCustomValue#setValueReferenceInternal(java.lang.String)
	 *
	 * @since 1.9
	 */
	@Override
	public void setValueReferenceInternal(String valueToPersist) {
		setPropertyValue(valueToPersist);
	}
	
	/**
	 * @see org.openmrs.customdatatype.SingleCustomValue#getValue()
	 *
	 * @since 1.9
	 */
	@Override
	public Object getValue() {
		if (typedValue == null) {
			typedValue = CustomDatatypeUtil.getDatatypeOrDefault(this).fromReferenceString(getValueReference());
		}
		return typedValue;
	}
	
	/**
	 * @see org.openmrs.customdatatype.SingleCustomValue#setValue(java.lang.Object)
	 *
	 * @since 1.9
	 */
	@Override
	public <T> void setValue(T typedValue){
		this.typedValue = typedValue;
		dirty = true;
	}
	
	/**
	 * @see org.openmrs.customdatatype.SingleCustomValue#isDirty()
	 *
	 * @deprecated as of 2.0, use {@link #getDirty()}
	 */
	@Deprecated
	@JsonIgnore
	@Override
	public boolean isDirty() {
		return getDirty();
	}
	
	public boolean getDirty() {
		return dirty;
	}
	
	/**
	 * @return Returns the changedBy.
	 */
	public User getChangedBy() {
		return changedBy;
	}
	
	/**
	 * @param changedBy The user that changed this object
	 */
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	
	/**
	 * @return Returns the date this object was changed
	 */
	public Date getDateChanged() {
		return dateChanged;
	}
	
	/**
	 * @param dateChanged The date this object was changed
	 */
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	/**
	 * Gets privilege which can view this globalProperty
	 * @return the viewPrivilege the privilege instance
	 * 
	 * @since 2.7.0
	 */
	public Privilege getViewPrivilege() {
		return viewPrivilege;
	}
	/**
	 * Sets privilege which can view this globalProperty
	 * @param viewPrivilege the viewPrivilege to set
	 *                      
	 * @since 2.7.0
	 */
	public void setViewPrivilege(Privilege viewPrivilege) {
		this.viewPrivilege = viewPrivilege;
	}
	/**
	 * Gets privilege which can edit this globalProperty
	 * @return the editPrivilege the privilege instance
	 * 
	 * @since 2.7.0
	 */
	public Privilege getEditPrivilege() {
		return editPrivilege;
	}
	/**
	 * Sets privilege which can edit this globalProperty
	 * @param editPrivilege the editPrivilege to set
	 *                      
	 * @since 2.7.0
	 */
	public void setEditPrivilege(Privilege editPrivilege) {
		this.editPrivilege = editPrivilege;
	}
	/**
	 * Get privilege which can delete this globalProperty
	 * @return the deletePrivilege the privilege instance
	 *
	 * @since 2.7.0
	 */
	public Privilege getDeletePrivilege() {
		return deletePrivilege;
	}
	/**
	 * Sets privilege which can delete this globalProperty
	 * @param deletePrivilege the deletePrivilege to set
	 *
	 * @since 2.7.0
	 */
	public void setDeletePrivilege(Privilege deletePrivilege) {
		this.deletePrivilege = deletePrivilege;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs;
import org.hibernate.envers.Audited;
/**
 * Privilege
 * 
 * @version 1.0
 */
@Audited
public class Privilege extends BaseChangeableOpenmrsMetadata {
	
	public static final long serialVersionUID = 312L;
	
	// Fields
	
	private String privilege;
	
	// Constructors
	
	/** default constructor */
	public Privilege() {
	}
	
	/** constructor with id */
	public Privilege(String privilege) {
		this.privilege = privilege;
	}
	
	public Privilege(String privilege, String description) {
		this.privilege = privilege;
		setDescription(description);
	}
	
	// Property accessors
	
	/**
	 * @return Returns the privilege.
	 */
	public String getPrivilege() {
		return privilege;
	}
	
	/**
	 * @param privilege The privilege to set.
	 */
	public void setPrivilege(String privilege) {
		this.privilege = privilege;
	}
	
	@Override
	public String getName() {
		return this.getPrivilege();
	}
	
	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return this.privilege;
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#getId()
	 */
	@Override
	public Integer getId() {
		throw new UnsupportedOperationException();
		
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#setId(java.lang.Integer)
	 */
	@Override
	public void setId(Integer id) {
		throw new UnsupportedOperationException();
		
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api.context;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.stream.Collectors;
import org.apache.commons.collections.CollectionUtils;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.APIAuthenticationException;
import org.openmrs.api.APIException;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.db.ContextDAO;
import org.openmrs.module.DaemonToken;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleException;
import org.openmrs.module.ModuleFactory;
import org.openmrs.scheduler.Task;
import org.openmrs.scheduler.timer.TimerSchedulerTask;
import org.openmrs.util.OpenmrsSecurityManager;
import org.openmrs.util.OpenmrsThreadPoolHolder;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
/**
 * This class allows certain tasks to run with elevated privileges. Primary use is scheduling and
 * module startup when there is no user to authenticate as.
 */
public final class Daemon {
	
	/**
	 * The uuid defined for the daemon user object
	 */
	static final String DAEMON_USER_UUID = "A4F30A1B-5EB9-11DF-A648-37A07F9C90FB";
	
	private static final ThreadLocal<Boolean> isDaemonThread = new ThreadLocal<>();
	
	private static final ThreadLocal<User> daemonThreadUser = new ThreadLocal<>();
	
	/**
	 * private constructor to override the default constructor to prevent it from being instantiated.
	 */
	private Daemon() {
	}
	
	/**
	 * @see #startModule(Module, boolean, AbstractRefreshableApplicationContext)
	 */
	public static Module startModule(Module module) throws ModuleException {
		return startModule(module, false, null);
	}
	
	/**
	 * This method should not be called directly. The {@link ModuleFactory#startModule(Module)}
	 * method uses this to start the given module in a new thread that is authenticated as the
	 * daemon user. <br>
	 * If a non-null application context is passed in, it gets refreshed to make the module's
	 * services available
	 *
	 * @param module the module to start
	 * @param isOpenmrsStartup Specifies whether this module is being started at application startup
	 *            or not
	 * @param applicationContext the spring application context instance to refresh
	 * @return the module returned from {@link ModuleFactory#startModuleInternal(Module)}
	 */
	public static Module startModule(final Module module, final boolean isOpenmrsStartup,
	        final AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (callerClass != Daemon.class && callerClass != ModuleFactory.class) {
			throw new APIException("Module.factory.only", new Object[] { callerClass.getName() });
		}
		
		Future<Module> moduleStartFuture = runInDaemonThreadInternal(() -> ModuleFactory.startModuleInternal(module, isOpenmrsStartup, applicationContext));
		
		// wait for the "startModule" thread to finish
		try {
			return moduleStartFuture.get();
		}
		catch (InterruptedException e) {
			// ignore
		} catch (ExecutionException e) {
			if (e.getCause() instanceof ModuleException) {
				throw (ModuleException) e.getCause();
			} else {
				throw new ModuleException("Unable to start module " + module.getName(), e);
			}
		}
		return module;
	}
	/**
	 * This method should not be called directly, only {@link ContextDAO#createUser(User, String, List)} can
	 * legally invoke this method.
	 * 
	 * @param user A new user to be created.
	 * @param password The password to set for the new user.
	 * @param roleNames A list of role names to fetch the roles to add to the user.
	 * @return The newly created user
	 * 
	 * <strong>Should</strong> only allow the creation of new users, not the edition of existing ones
	 * 
	 * @since 2.3.0
	 */
	public static User createUser(User user, String password, List<String> roleNames) throws Exception {
		// quick check to make sure we're only being called by ourselves
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (!ContextDAO.class.isAssignableFrom(callerClass)) {
			throw new APIException("Context.DAO.only", new Object[] { callerClass.getName() });
		}
		// create a new thread and execute that task in it
		Future<User> userFuture = runInDaemonThreadInternal(() -> {
			if ((user.getId() != null && Context.getUserService().getUser(user.getId()) != null) || Context.getUserService().getUserByUuid(user.getUuid()) != null || Context.getUserService().getUserByUsername(user.getUsername()) != null || (user.getEmail() != null && Context.getUserService().getUserByUsernameOrEmail(user.getEmail()) != null) ) {
				throw new APIException("User.creating.already.exists", new Object[] { user.getDisplayString() });
			}
			if (!CollectionUtils.isEmpty(roleNames)) {
				List<Role> roles = roleNames.stream().map(roleName -> Context.getUserService().getRole(roleName)).collect(Collectors.toList());
				roles.forEach(user::addRole);
			}
			return Context.getUserService().createUser(user, password);
		});
		// wait for the 'create user' thread to finish
		try {
			return userFuture.get();
		}
		catch (InterruptedException e) {
			// ignore
		}
		catch (ExecutionException e) {
			if (e.getCause() instanceof Exception) {
				throw (Exception) e.getCause();
			} else {
				throw new RuntimeException(e.getCause());
			}
		}
		return null;
	}	
	
	/**
	 * Executes the given task in a new thread that is authenticated as the daemon user. <br>
	 * <br>
	 * This can only be called from {@link TimerSchedulerTask} during actual task execution
	 *
	 * @param task the task to run
	 * <strong>Should</strong> not be called from other methods other than TimerSchedulerTask
	 * <strong>Should</strong> not throw error if called from a TimerSchedulerTask class
	 */
	public static void executeScheduledTask(final Task task) throws Exception {
		// quick check to make sure we're only being called by ourselves
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (!TimerSchedulerTask.class.isAssignableFrom(callerClass)) {
			throw new APIException("Scheduler.timer.task.only", new Object[] { callerClass.getName() });
		}
		
		Future<?> scheduleTaskFuture = runInDaemonThreadInternal(() -> TimerSchedulerTask.execute(task));
		
		// wait for the "executeTaskThread" thread to finish
		try {
			scheduleTaskFuture.get();
		}
		catch (InterruptedException e) {
			// ignore
		} catch (ExecutionException e) {
			if (e.getCause() instanceof Exception) {
				throw (Exception) e.getCause();
			} else {
				throw new RuntimeException(e.getCause());
			}
		}
	}
	
	/**
	 * Call this method if you are inside a Daemon thread (for example in a Module activator or a
	 * scheduled task) and you want to start up a new parallel Daemon thread. You may only call this
	 * method from a Daemon thread.
	 *
	 * @param runnable what to run in a new thread
	 * @return the newly spawned {@link Thread}
	 * @deprecated As of 2.7.0, consider using {@link #runNewDaemonTask(Runnable)} instead
	 */
	@Deprecated
	public static Thread runInNewDaemonThread(final Runnable runnable) {
		// make sure we're already in a daemon thread
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		// the previous implementation ensured that Thread.start() was called before this function returned
		// since we cannot guarantee that the executor will run the thread when `execute()` is called, we need another
		// mechanism to ensure the submitted Runnable was actually started.
		final CountDownLatch countDownLatch = new CountDownLatch(1);
		
		// we should consider making DaemonThread public, so the caller can access returnedObject and exceptionThrown
		DaemonThread thread = new DaemonThread() {
			
			@Override
			public void run() {
				isDaemonThread.set(true);
				try {
					Context.openSession();
					countDownLatch.countDown();
					//Suppressing sonar issue "squid:S1217"
					//We intentionally do not start a new thread yet, rather wrap the run call in a session.
					runnable.run();
				}
				finally {
					try {
						Context.closeSession();
					} finally {
						isDaemonThread.remove();
						daemonThreadUser.remove();
					}
				}
			}
		};
		
		OpenmrsThreadPoolHolder.threadExecutor.execute(thread);
		// do not return until the thread is actually started to emulate the previous behaviour
		try {
			countDownLatch.await();
		} catch (InterruptedException ignored) {
		}
		return thread;
	}
	/**
	 * Call this method if you are inside a Daemon thread (for example in a Module activator or a
	 * scheduled task) and you want to start up a new parallel Daemon thread. You may only call this
	 * method from a Daemon thread.
	 *
	 * @param callable what to run in a new thread
	 * @return a future that completes when the task is done;
	 * @since 2.7.0
	 */
	@SuppressWarnings({"squid:S1217", "unused"})
	public static <T> Future<T> runInNewDaemonThread(final Callable<T> callable) {
		// make sure we're already in a daemon thread
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		return runInDaemonThreadInternal(callable);
	}
	/**
	 * Call this method if you are inside a Daemon thread (for example in a Module activator or a
	 * scheduled task) and you want to start up a new parallel Daemon thread. You may only call this
	 * method from a Daemon thread.
	 *
	 * @param runnable what to run in a new thread
	 * @return a future that completes when the task is done;
	 * @since 2.7.0
	 */
	@SuppressWarnings({"squid:S1217", "unused"})
	public static Future<?> runNewDaemonTask(final Runnable runnable) {
		// make sure we're already in a daemon thread
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		
		return runInDaemonThreadInternal(runnable);
	}
	
	/**
	 * @return true if the current thread was started by this class and so is a daemon thread that
	 *         has all privileges
	 * @see Context#hasPrivilege(String)
	 */
	public static boolean isDaemonThread() {
		Boolean b = isDaemonThread.get();
		if (b == null || !b) {
			// Allow functions in Daemon and WebDaemon to be treated as a DaemonThread
			Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(1);
			return callerClass.equals(Daemon.class) || callerClass.getName().equals("org.openmrs.web.WebDaemon");
		} else {
			return true;
		}
	}
	
	/**
	 * Calls the {@link OpenmrsService#onStartup()} method, as a daemon, for an instance
	 * implementing the {@link OpenmrsService} interface.
	 *
	 * @param service instance implementing the {@link OpenmrsService} interface.
	 * @since 1.9
	 */
	public static void runStartupForService(final OpenmrsService service) throws ModuleException {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (callerClass != ServiceContext.class) {
			throw new APIException("Service.context.only", new Object[] { callerClass.getName() });
		}
		
		Future<?> future = runInDaemonThreadInternal(service::onStartup);
		
		// wait for the "onStartup" thread to finish
		try {
			future.get();
		}
		catch (InterruptedException e) {
			// ignore
		}
		catch (ExecutionException e) {
			if (e.getCause() instanceof ModuleException) {
				throw (ModuleException) e.getCause();
			} else {
				throw new ModuleException("Unable to run onStartup() method of service {}", service.getClass().getSimpleName(), e);
			}
		}
	}
	
	/**
	 * Executes the given runnable in a new thread that is authenticated as the daemon user.
	 *
	 * @param runnable an object implementing the {@link Runnable} interface.
	 * @param token the token required to run code as the daemon user
	 * @return the newly spawned {@link Thread}
	 * @since 1.9.2
	 * @deprecated Since 2.7.0 use {@link #runInDaemonThreadWithoutResult(Runnable, DaemonToken)} instead
	 */
	@Deprecated
	@SuppressWarnings({"squid:S1217", "unused"})
	public static Thread runInDaemonThread(final Runnable runnable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token " + token);
		}
		
		DaemonThread thread = new DaemonThread() {
			@Override
			public void run() {
				isDaemonThread.set(true);
				try {
					Context.openSession();
					//Suppressing sonar issue "squid:S1217"
					//We intentionally do not start a new thread yet, rather wrap the run call in a session.
					runnable.run();
				}
				finally {
					try {
						Context.closeSession();
					} finally {
						isDaemonThread.remove();
						daemonThreadUser.remove();
					}
				}
			}
		};
		OpenmrsThreadPoolHolder.threadExecutor.execute(thread);
		return thread;
	}
	/**
	 * Executes the given runnable in a new thread that is authenticated as the daemon user.
	 *
	 * @param callable an object implementing the {@link Callable<T>} interface to be run
	 * @param token the token required to run code as the daemon user
	 * @return the newly spawned {@link Thread}
	 * @since 2.7.0
	 */
	@SuppressWarnings({"squid:S1217", "unused"})
	public static <T> Future<T> runInDaemonThread(final Callable<T> callable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token");
		}
		
		return runInDaemonThreadInternal(callable);
	}
	/**
	 * Executes the given runnable in a new thread that is authenticated as the daemon user.
	 *
	 * @param runnable an object implementing the {@link Runnable} interface to be run
	 * @param token the token required to run code as the daemon user
	 * @return the newly spawned {@link Thread}
	 * @since 2.7.0
	 */
	@SuppressWarnings("squid:S1217")
	public static Future<?> runInDaemonThreadWithoutResult(final Runnable runnable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token");
		}
		return runInDaemonThreadInternal(runnable);
	}
	
	/**
	 * Executes the given runnable in a new thread that is authenticated as the daemon user and wait
	 * for the thread to finish.
	 *
	 * @param runnable an object implementing the {@link Runnable} interface.
	 * @param token the token required to run code as the daemon user
	 * @since 2.7.0
	 */
	public static void runInDaemonThreadAndWait(final Runnable runnable, DaemonToken token) {
		Future<?> daemonThread = runInDaemonThreadWithoutResult(runnable, token);
		
		try {
			daemonThread.get();
		}
		catch (InterruptedException | ExecutionException e) {
			// Ignored
		}
	}
	
	private static <T> Future<T> runInDaemonThreadInternal(Callable<T> callable) {
		return OpenmrsThreadPoolHolder.threadExecutor.submit(() -> {
			isDaemonThread.set(true);
			try {
				Context.openSession();
				return callable.call();
			}
			finally {
				try {
					Context.closeSession();
				} finally {
					isDaemonThread.remove();
					daemonThreadUser.remove();
				}
			}
		});
	}
	
	private static Future<?> runInDaemonThreadInternal(Runnable runnable) {
		// for Threads, we used to guarantee that Thread.start() was called before the function returned
		// since we cannot guarantee that the executor actually started executing the thread, we use a CountDownLatch
		// to emulate this behaviour when the user submits a Thread. Other runnables are unaffected.
		CountDownLatch countDownLatch = getCountDownLatch(runnable instanceof Thread);
		Future<?> result = OpenmrsThreadPoolHolder.threadExecutor.submit(() -> {
			isDaemonThread.set(true);
			try {
				Context.openSession();
				countDownLatch.countDown();
				runnable.run();
			}
			finally {
				try {
					Context.closeSession();
				} finally {
					isDaemonThread.remove();
					daemonThreadUser.remove();
				}
			}
		});
		
		try {
			countDownLatch.await();
		} catch (InterruptedException ignored) {}
		
		return result;
	}
	private static CountDownLatch getCountDownLatch(boolean isThread) {
		return isThread ? new CountDownLatch(1) : new CountDownLatch(0);
	}
	/**
	 * Thread class used by the {@link Daemon#startModule(Module)} and
	 * {@link Daemon#executeScheduledTask(Task)} methods so that the returned object and the
	 * exception thrown can be returned to calling class
	 */
	protected static class DaemonThread extends Thread {
		
		/**
		 * The object returned from the method called in {@link #run()}
		 */
		protected Object returnedObject = null;
		
		/**
		 * The exception thrown (if any) by the method called in {@link #run()}
		 */
		protected Exception exceptionThrown = null;
		
		/**
		 * Gets the exception thrown (if any) by the method called in {@link #run()}
		 *
		 * @return the thrown exception (if any).
		 */
		public Exception getExceptionThrown() {
			return exceptionThrown;
		}
	}
	
	/**
	 * Checks whether user is Daemon.
	 * However, this is not the preferred method for checking to see if the current thread is a daemon thread,
	 * 				rather use {@link #isDaemonThread()}.
	 * isDaemonThread is preferred for checking to see if you are in that thread or if the current thread is daemon.
	 *
	 * @param user user whom we are checking if daemon
	 * @return true if user is Daemon
	 */
	public static boolean isDaemonUser(User user) {
		return DAEMON_USER_UUID.equals(user.getUuid());
	}
	
	/**
	 * @return the current thread daemon user or null if not assigned
	 * @since 2.0.0, 1.12.0, 1.11.6, 1.10.4, 1.9.11
	 */
	public static User getDaemonThreadUser() {
		if (isDaemonThread()) {
			User user = daemonThreadUser.get();
			if (user == null) {
				user = Context.getContextDAO().getUserByUuid(DAEMON_USER_UUID);
				daemonThreadUser.set(user);
			}
			return user;
		} else {
			return null;
		}
	}
	public static String getDaemonUserUuid() {
		return DAEMON_USER_UUID;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module.web.filter;
import java.io.Serializable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
/**
 * This class captures all of the information needed to create and initialize a Filter included in a
 * Module. This object is initialized from an xml element that has the following syntax. Expected
 * XML Format:
 * 
 * <pre>
 * 	&lt;filter&gt;
 * 		&lt;filter-name&gt;MyFilterName&lt;/filter-name&gt;
 * 		&lt;filter-class&gt;Fully qualified classname of the Filter class&lt;/filter-class&gt;
 * 		&lt;init-param&gt;
 * 			&lt;param-name&gt;filterParameterName1&lt;/param-name&gt;
 * 			&lt;param-value&gt;filterParameterValue1&lt;/param-value&gt;
 * 		&lt;/init-param&gt;
 * 	&lt;/filter&gt;
 * </pre>
 */
public class ModuleFilterDefinition implements Serializable {
	
	public static final long serialVersionUID = 1;
	
	private static final Logger log = LoggerFactory.getLogger(ModuleFilterDefinition.class);
	
	// Properties
	private Module module;
	
	private String filterName;
	
	private String filterClass;
	
	private Map<String, String> initParameters = new HashMap<>();
	
	/**
	 * Default constructor, requires a Module
	 * 
	 * @param module - The Module to use to construct this {@link ModuleFilterDefinition}
	 */
	public ModuleFilterDefinition(Module module) {
		this.module = module;
	}
	
	/**
	 * @return - The {@link Module} that registered this FilterDefinition
	 */
	public Module getModule() {
		return module;
	}
	
	/**
	 * @param module the {@link Module} to set
	 */
	public void setModule(Module module) {
		this.module = module;
	}
	
	/**
	 * @return - the name of the Filter
	 */
	public String getFilterName() {
		return filterName;
	}
	
	/**
	 * @param filterName the name of the filter
	 */
	public void setFilterName(String filterName) {
		this.filterName = filterName;
	}
	
	/**
	 * @return - the class name of the filter
	 */
	public String getFilterClass() {
		return filterClass;
	}
	
	/**
	 * @param filterClass the class name of the filter
	 */
	public void setFilterClass(String filterClass) {
		this.filterClass = filterClass;
	}
	
	/**
	 * @return - A map of parameters to use to initialize the filter
	 */
	public Map<String, String> getInitParameters() {
		return initParameters;
	}
	
	/**
	 * #param - A map of parameters to use to initialize the filter
	 */
	public void setInitParameters(Map<String, String> initParameters) {
		this.initParameters = initParameters;
	}
	
	/**
	 * Adds a Parameter that should be passed in to initialize this Filter
	 * 
	 * @param parameterName - The name of the parameter
	 * @param parameterValue - The value of the parameter
	 */
	public void addInitParameter(String parameterName, String parameterValue) {
		this.initParameters.put(parameterName, parameterValue);
	}
	
	// Static methods
	
	/**
	 * Static method to parse through a Module's configuration file and return a List of
	 * ModuleFilterDefinition objects for which there are configuration elements. Expected XML
	 * Format:
	 * 
	 * <pre>
	 * 	&lt;filter&gt;
	 * 		&lt;filter-name&gt;MyFilterName&lt;/filter-name&gt;
	 * 		&lt;filter-class&gt;Fully qualified classname of the Filter class&lt;/filter-class&gt;
	 * 		&lt;init-param&gt;
	 * 			&lt;param-name&gt;filterParameterName1&lt;/param-name&gt;
	 * 			&lt;param-value&gt;filterParameterValue1&lt;/param-value&gt;
	 * 		&lt;/init-param&gt;
	 * 	&lt;/filter&gt;
	 * </pre>
	 * 
	 * @param module - The {@link Module} for which to retrieve filter the defined
	 *            {@link ModuleFilterDefinition}s
	 * @return List of {@link ModuleFilterDefinition}s that have been defined for the passed
	 *         {@link Module}
	 */
	public static List<ModuleFilterDefinition> retrieveFilterDefinitions(Module module)  {
		List<ModuleFilterDefinition> filters = new ArrayList<>();
		
		try {
			Element rootNode = module.getConfig().getDocumentElement();
			NodeList filterNodes = rootNode.getElementsByTagName("filter");
			if (filterNodes.getLength() > 0) {
				for (int i = 0; i < filterNodes.getLength(); i++) {
					ModuleFilterDefinition filter = new ModuleFilterDefinition(module);
					Node node = filterNodes.item(i);
					NodeList configNodes = node.getChildNodes();
					for (int j = 0; j < configNodes.getLength(); j++) {
						Node configNode = configNodes.item(j);
						switch (configNode.getNodeName()) {
							case "filter-name":
								filter.setFilterName(configNode.getTextContent().trim());
								break;
							case "filter-class":
								filter.setFilterClass(configNode.getTextContent().trim());
								break;
							case "init-param":
								NodeList paramNodes = configNode.getChildNodes();
								String paramName = "";
								String paramValue = "";
								for (int k = 0; k < paramNodes.getLength(); k++) {
									Node paramNode = paramNodes.item(k);
									if ("param-name".equals(paramNode.getNodeName())) {
										paramName = paramNode.getTextContent().trim();
									} else if ("param-value".equals(paramNode.getNodeName())) {
										paramValue = paramNode.getTextContent().trim();
									}
								}
								filter.addInitParameter(paramName, paramValue);
								break;
						}
					}
					filters.add(filter);
				}
			}
		}
		catch (Exception e) {
			throw new ModuleException("Unable to parse filters in module configuration.", e);
		}
		
		log.debug("Retrieved {} filters for {}: {}", filters.size(), module, filters);
		return filters;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLStreamHandlerFactory;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.CodeSource;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.api.APIException;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * Standard implementation of module class loader. <br>
 * Code adapted from the Java Plug-in Framework (JPF) - LGPL - Copyright (C)<br>
 * 2004-2006 Dmitry Olshansky
 */
public class ModuleClassLoader extends URLClassLoader {
	
	private static final Logger log = LoggerFactory.getLogger(ModuleClassLoader.class);
	
	private final Module module;
	
	private Module[] requiredModules;
	
	private Module[] awareOfModules;
	
	private Map<URI, File> libraryCache;
	
	private boolean probeParentLoaderLast = true;
	
	private Set<String> providedPackages = new LinkedHashSet<>();
	
	private boolean disposed = false;
	
	
	/**
	 * @param module Module
	 * @param urls resources "managed" by this class loader
	 * @param parent parent class loader
	 * @param factory URL stream handler factory
	 * @see URLClassLoader#URLClassLoader(java.net.URL[], java.lang.ClassLoader,
	 *      java.net.URLStreamHandlerFactory)
	 */
	protected ModuleClassLoader(final Module module, final List<URL> urls, final ClassLoader parent,
	    final URLStreamHandlerFactory factory) {
		super(urls.toArray(new URL[urls.size()]), parent, factory);
		
		if (parent instanceof OpenmrsClassLoader) {
			throw new IllegalArgumentException("Parent must not be OpenmrsClassLoader nor null");
		} else if (parent instanceof ModuleClassLoader) {
			throw new IllegalArgumentException("Parent must not be ModuleClassLoader");
		}
		
		log.debug("URLs length: {}", urls.size());
		this.module = module;
		requiredModules = collectRequiredModuleImports(module);
		awareOfModules = collectAwareOfModuleImports(module);
		libraryCache = new WeakHashMap<>();
	}
	
	/**
	 * @param module the <code>Module</code> to load
	 * @param urls <code>List&lt;URL&gt;</code> of the resources "managed" by this class loader
	 * @param parent parent <code>ClassLoader</code>
	 * @see URLClassLoader#URLClassLoader(java.net.URL[], java.lang.ClassLoader)
	 */
	protected ModuleClassLoader(final Module module, final List<URL> urls, final ClassLoader parent) {
		this(module, urls, parent, null);
		
		File devDir = ModuleUtil.getDevelopmentDirectory(module.getModuleId());
		if (devDir != null) {
			File[] fileList = devDir.listFiles();
			if (fileList == null) {
				return;
			}
			for (File file : fileList) {
				if (!file.isDirectory()) {
					continue;
				}
				File dir = Paths.get(devDir.getAbsolutePath(), file.getName(), "target", "classes").toFile();
				if (dir.exists()) {
					Collection<File> files = FileUtils.listFiles(dir, new String[] { "class" }, true);
					addClassFilePackages(files, dir.getAbsolutePath().length() + 1);
				}
			}
		} else {
			for (URL url : urls) {
				providedPackages.addAll(ModuleUtil.getPackagesFromFile(OpenmrsUtil.url2file(url)));
			}
		}
	}
	
	private void addClassFilePackages(Collection<File> files, int dirLength) {
		for (File file : files) {
			String name = file.getAbsolutePath().substring(dirLength);
			Integer indexOfLastSlash = name.lastIndexOf(File.separator);
			if (indexOfLastSlash > 0) {
				String packageName = name.substring(0, indexOfLastSlash);
				packageName = packageName.replace(File.separator, ".");
				providedPackages.add(packageName);
				
			}
		}
	}
	
	/**
	 * @param module the <code>Module</code> to load
	 * @param urls <code>List&lt;URL&gt;</code> of thee resources "managed" by this class loader
	 * @see URLClassLoader#URLClassLoader(java.net.URL[])
	 */
	protected ModuleClassLoader(final Module module, final List<URL> urls) {
		this(module, urls, null);
	}
	
	/**
	 * Creates class instance configured to load classes and resources for given module.
	 *
	 * @param module the <code>Module</code> to load
	 * @param parent parent <code>ClassLoader</code>
	 */
	public ModuleClassLoader(final Module module, final ClassLoader parent) {
		this(module, getUrls(module), parent);
	}
	
	/**
	 * @return returns this classloader's module
	 */
	public Module getModule() {
		return module;
	}
	
	public boolean isDisposed() {
		return disposed;
	}
	
	/**
	 * Get the base class url of the given <code>cls</code>. Used for checking against system class
	 * loads vs classloader loads
	 *
	 * @param cls Class name
	 * @return URL to the class
	 */
	private static URL getClassBaseUrl(final Class<?> cls) {
		ProtectionDomain pd = cls.getProtectionDomain();
		
		if (pd != null) {
			CodeSource cs = pd.getCodeSource();
			if (cs != null) {
				return cs.getLocation();
			}
			
		}
		
		return null;
	}
	
	/**
	 * Get all urls for all files in the given <code>module</code>
	 *
	 * @param module Module in which to look
	 * @return List&lt;URL&gt; of all urls found (and cached) in the module
	 */
	private static List<URL> getUrls(final Module module) {
		List<URL> result = new LinkedList<>();
		
		//if in dev mode, add development folder to the classpath
		List<String> devFolderNames = new ArrayList<>();
		File devDir = ModuleUtil.getDevelopmentDirectory(module.getModuleId());
		try {
			if (devDir != null) {
				File[] fileList = devDir.listFiles();
				if (fileList != null) {
					for (File file : fileList) {
						if (!file.isDirectory()) {
							continue;
						}
						File dir = Paths.get(devDir.getAbsolutePath(), file.getName(), "target", "classes").toFile();
						if (dir.exists()) {
							result.add(dir.toURI().toURL());
							devFolderNames.add(file.getName());
						}
					}
				}
			}
		}
		catch (MalformedURLException ex) {
			log.error("Failed to add development folder to the classpath", ex);
		}
		
		File tmpModuleDir = getLibCacheFolderForModule(module);
		
		//add module jar to classpath only if we are not in dev mode
		if (devDir == null) {
			File tmpModuleJar = new File(tmpModuleDir, module.getModuleId() + ".jar");
			
			if (!tmpModuleJar.exists()) {
				try {
					tmpModuleJar.createNewFile();
				}
				catch (IOException io) {
					log.warn("Unable to create tmpModuleFile", io);
				}
			}
			
			// copy the module jar into that temporary folder
			FileInputStream in = null;
			FileOutputStream out = null;
			try {
				in = new FileInputStream(module.getFile());
				out = new FileOutputStream(tmpModuleJar);
				OpenmrsUtil.copyFile(in, out);
			}
			catch (IOException io) {
				log.warn("Unable to copy tmpModuleFile", io);
			}
			finally {
				try {
					in.close();
				}
				catch (Exception e) { /* pass */}
				try {
					out.close();
				}
				catch (Exception e) { /* pass */}
			}
			
			// add the module jar as a url in the classpath of the classloader
			URL moduleFileURL;
			try {
				moduleFileURL = ModuleUtil.file2url(tmpModuleJar);
				result.add(moduleFileURL);
			}
			catch (MalformedURLException e) {
				log.warn("Unable to add files from module to URL list: " + module.getModuleId(), e);
			}
		}
		
		// add each defined jar in the /lib folder, add as a url in the classpath of the classloader
		try {
			log.debug("Expanding /lib folder in module");
			
			ModuleUtil.expandJar(module.getFile(), tmpModuleDir, "lib", true);
			File libdir = new File(tmpModuleDir, "lib");
			
			if (libdir != null && libdir.exists()) {
				Map<String, String> startedRelatedModules = new HashMap<>();
				for (Module requiredModule : collectRequiredModuleImports(module)) {
					startedRelatedModules.put(requiredModule.getModuleId(), requiredModule.getVersion());
				}
				for (Module awareOfModule : collectAwareOfModuleImports(module)) {
					startedRelatedModules.put(awareOfModule.getModuleId(), awareOfModule.getVersion());
				}
				
				// recursively get files
				Collection<File> files = FileUtils.listFiles(libdir, new String[] { "jar" }, true);
				for (File file : files) {
					
					//if in dev mode, do not put the module source jar files in the class path
					if (devDir != null) {
						boolean jarForDevFolder = false;
						for (String folderName : devFolderNames) {
							if (file.getName().startsWith(module.getModuleId() + "-" + folderName + "-")) {
								//e.g uiframework-api-3.3-SNAPSHOT.jar, webservices.rest-omod-common-2.14-SNAPSHOT.jar
								//webservices.rest-omod-1.11-2.14-SNAPSHOT.jar, webservices.rest-omod-1.10-2.14-SNAPSHOT.jar, etc
								jarForDevFolder = true;
								break;
							}
						}
						
						if (jarForDevFolder) {
							continue;
						}
					}
					
					URL fileUrl = ModuleUtil.file2url(file);
					
					boolean include = shouldResourceBeIncluded(module, fileUrl, OpenmrsConstants.OPENMRS_VERSION_SHORT,
					    startedRelatedModules);
					
					if (include) {
						log.debug("Including file in classpath: {}", fileUrl);
						result.add(fileUrl);
					} else {
						log.debug("Excluding file from classpath: {}", fileUrl);
					}
				}
			}
		}
		catch (MalformedURLException e) {
			log.warn("Error while adding module 'lib' folder to URL result list");
		}
		catch (IOException io) {
			log.warn("Error while expanding lib folder", io);
		}
		
		// add each xml document to the url list
		
		return result;
	}
	
	/**
	 * Determines whether or not the given resource should be available on the classpath based on
	 * OpenMRS version and/or modules' version. It uses the conditionalResources section specified
	 * in config.xml. Resources that are not mentioned as conditional resources are included by
	 * default. All conditions for a conditional resource to be included must match.
	 *
	 * @param module
	 * @param fileUrl
	 * @return true if it should be included <strong>Should</strong> return true if file matches and
	 *         openmrs version matches <strong>Should</strong> return false if file matches but
	 *         openmrs version does not <strong>Should</strong> return true if file does not match
	 *         and openmrs version does not match <strong>Should</strong> return true if file
	 *         matches and module version matches <strong>Should</strong> return false if file
	 *         matches and module version does not match <strong>Should</strong> return false if
	 *         file matches and openmrs version matches but module version does not match
	 *         <strong>Should</strong> return false if file matches and module not found
	 *         <strong>Should</strong> return true if file does not match and module version does
	 *         not match
	 */
	static boolean shouldResourceBeIncluded(Module module, URL fileUrl, String openmrsVersion,
	        Map<String, String> startedRelatedModules) {
		//all resources are included by default
		boolean include = true;
		
		for (ModuleConditionalResource conditionalResource : module.getConditionalResources()) {
			if (isMatchingConditionalResource(module, fileUrl, conditionalResource)) {
				//if a resource matches a path of contidionalResource then it must meet all conditions
				include = false;
				
				//openmrsPlatformVersion is optional
				if (StringUtils.isNotBlank(conditionalResource.getOpenmrsPlatformVersion())) {
					include = ModuleUtil.matchRequiredVersions(openmrsVersion,
					    conditionalResource.getOpenmrsPlatformVersion());
					
					if (!include) {
						return false;
					}
				}
				
				//modules are optional
				if (conditionalResource.getModules() != null) {
					for (ModuleConditionalResource.ModuleAndVersion conditionalModuleResource : conditionalResource
					        .getModules()) {
						if ("!".equals(conditionalModuleResource.getVersion())) {
							include = !ModuleFactory.isModuleStarted(conditionalModuleResource.getModuleId());
							if (!include) {
								return false;
							}
						} else {
							String moduleVersion = startedRelatedModules.get(conditionalModuleResource.getModuleId());
							if (moduleVersion != null) {
								include = ModuleUtil.matchRequiredVersions(moduleVersion,
								    conditionalModuleResource.getVersion());
								
								if (!include) {
									return false;
								}
							}
						}
					}
					
				}
			}
		}
		
		return include;
	}
	
	static boolean isMatchingConditionalResource(Module module, URL fileUrl, ModuleConditionalResource conditionalResource) {
		FileSystem fileSystem = FileSystems.getDefault();
		if (ModuleUtil.matchRequiredVersions(module.getConfigVersion(), "2.0")) {
			return fileSystem.getPathMatcher(String.format("glob:**/%s", preprocessGlobPattern(conditionalResource.getPath())))
				.matches(Paths.get(fileUrl.getPath()));
		}
		return fileUrl.getPath().matches(".*" + conditionalResource.getPath() + "$");
	}
	private static String preprocessGlobPattern(String globPattern) {
		if (globPattern == null || globPattern.isEmpty()) {
			return "";
		}
		globPattern = globPattern.replace("\\", "/");
		globPattern = globPattern.replaceAll("//+", "/");
		// Remove "file:" prefix if present
		if (globPattern.startsWith("file:/")) {
			globPattern = globPattern.substring(5);
		}
		
		// Remove drive letter if present (e.g., C:/)
		if (globPattern.matches("^[a-zA-Z]:/.*")) {
			globPattern = globPattern.substring(2);
		}
		
		if (globPattern.startsWith("/")) {
			globPattern = globPattern.substring(1);
		}
		return globPattern;
	}
	
	/**
	 * Get the library cache folder for the given module. Each module has a different cache folder
	 * to ease cleanup when unloading a module while openmrs is running
	 *
	 * @param module Module which the cache will be used for
	 * @return File directory where the files will be placed
	 */
	public static File getLibCacheFolderForModule(Module module) {
		File tmpModuleDir = new File(OpenmrsClassLoader.getLibCacheFolder(), module.getModuleId());
		
		// each module gets its own folder named /moduleId/
		if (!tmpModuleDir.exists()) {
			tmpModuleDir.mkdir();
			tmpModuleDir.deleteOnExit();
		}
		return tmpModuleDir;
	}
	
	/**
	 * Get all urls for the given <code>module</code> that are not already in the
	 * <code>existingUrls</code>
	 *
	 * @param module Module in which to get urls
	 * @param existingUrls Array of URLs to skip
	 * @return List&lt;URL&gt; of new unique urls
	 * @see #getUrls(Module)
	 */
	private static List<URL> getUrls(final Module module, final URL[] existingUrls) {
		List<URL> urls = Arrays.asList(existingUrls);
		List<URL> result = new LinkedList<>();
		for (URL url : getUrls(module)) {
			if (!urls.contains(url)) {
				result.add(url);
			}
		}
		return result;
	}
	
	/**
	 * Get and cache the imports for this module. The imports should just be the modules that set as
	 * "required" by this module
	 */
	protected static Module[] collectRequiredModuleImports(Module module) {
		// collect imported modules (exclude duplicates)
		//<module ID, Module>
		Map<String, Module> publicImportsMap = new WeakHashMap<>();
		
		for (String moduleId : ModuleConstants.CORE_MODULES.keySet()) {
			Module coreModule = ModuleFactory.getModuleById(moduleId);
			
			if (coreModule == null && !ModuleUtil.ignoreCoreModules()) {
				log.error("Unable to find an openmrs core loaded module with id: " + moduleId);
				throw new APIException("Module.error.shouldNotBeHere", (Object[]) null);
			}
			
			// if this is already the classloader for one of the core modules, don't put it on the import list
			if (coreModule != null && !moduleId.equals(module.getModuleId())) {
				publicImportsMap.put(moduleId, coreModule);
			}
		}
		
		for (String requiredPackage : module.getRequiredModules()) {
			Module requiredModule = ModuleFactory.getModuleByPackage(requiredPackage);
			if (ModuleFactory.isModuleStarted(requiredModule)) {
				publicImportsMap.put(requiredModule.getModuleId(), requiredModule);
			}
		}
		return publicImportsMap.values().toArray(new Module[publicImportsMap.size()]);
		
	}
	
	/**
	 * Get and cache the imports for this module. The imports should just be the modules that set as
	 * "aware of" by this module
	 */
	protected static Module[] collectAwareOfModuleImports(Module module) {
		// collect imported modules (exclude duplicates)
		//<module ID, Module>
		Map<String, Module> publicImportsMap = new WeakHashMap<>();
		
		for (String awareOfPackage : module.getAwareOfModules()) {
			Module awareOfModule = ModuleFactory.getModuleByPackage(awareOfPackage);
			if (ModuleFactory.isModuleStarted(awareOfModule)) {
				publicImportsMap.put(awareOfModule.getModuleId(), awareOfModule);
			}
		}
		return publicImportsMap.values().toArray(new Module[publicImportsMap.size()]);
		
	}
	
	/**
	 * @see org.openmrs.module.ModuleClassLoader#modulesSetChanged()
	 */
	protected void modulesSetChanged() {
		List<URL> newUrls = getUrls(getModule(), getURLs());
		for (URL u : newUrls) {
			addURL(u);
		}
		
		if (log.isDebugEnabled()) {
			StringBuilder buf = new StringBuilder();
			buf.append("New code URL's populated for module ").append(getModule()).append(":\r\n");
			for (URL u : newUrls) {
				buf.append("\t");
				buf.append(u);
				buf.append("\r\n");
			}
			log.debug(buf.toString());
		}
		requiredModules = collectRequiredModuleImports(getModule());
		awareOfModules = collectAwareOfModuleImports(getModule());
		libraryCache.entrySet().removeIf(uriFileEntry -> uriFileEntry.getValue() == null);
	}
	
	/**
	 * @see org.openmrs.module.ModuleFactory#stopModule(Module, boolean)
	 */
	public void dispose() {
		log.debug("Disposing of ModuleClassLoader: {}", this);
		for (File file : libraryCache.values()) {
			file.delete();
		}
		
		libraryCache.clear();
		requiredModules = null;
		awareOfModules = null;
		disposed = true;
	}
	
	/**
	 * Allow the probe parent loader last variable to be set. Usually this is set to true to allow
	 * modules to override and create their own classes
	 *
	 * @param value boolean true/false whether or not to look at the parent classloader last
	 */
	public void setProbeParentLoaderLast(final boolean value) {
		probeParentLoaderLast = value;
	}
	
	/**
	 * @see java.lang.ClassLoader#loadClass(java.lang.String, boolean)
	 */
	@Override
	protected Class<?> loadClass(final String name, final boolean resolve) throws ClassNotFoundException {
		// Check if the class has already been loaded by this class loader
		Class<?> result = findLoadedClass(name);
		if (result == null) {
			if (probeParentLoaderLast) {
				try {
					result = loadClass(name, resolve, this, null);
				}
				catch (ClassNotFoundException cnfe) {
					// Continue trying...
				}
				
				if (result == null && getParent() != null) {
					result = getParent().loadClass(name);
				}
			} else {
				try {
					if (getParent() != null) {
						result = getParent().loadClass(name);
					}
				}
				catch (ClassNotFoundException cnfe) {
					// Continue trying...
				}
				
				if (result == null) {
					result = loadClass(name, resolve, this, null);
				}
			}
		}
		
		if (resolve) {
			resolveClass(result);
		}
		
		return result;
	}
	
	/**
	 * Custom loadClass implementation to allow for loading from a given ModuleClassLoader and skip
	 * the modules that have been tried already
	 * 
	 * @param name String path and name of the class to load
	 * @param resolve boolean whether or not to resolve this class before returning
	 * @param requestor ModuleClassLoader with which to try loading
	 * @param seenModules Set&lt;String&gt; moduleIds that have been tried already
	 * @return Class that has been loaded
	 * @throws ClassNotFoundException if no class found
	 */
	protected synchronized Class<?> loadClass(final String name, final boolean resolve, final ModuleClassLoader requestor,
	        Set<String> seenModules) throws ClassNotFoundException {
		
		if (log.isTraceEnabled()) {
			log.trace("Loading " + name + " " + getModule() + ", seenModules: " + seenModules + ", requestor: " + requestor
			        + ", resolve? " + resolve);
			StringBuilder output = new StringBuilder();
			for (StackTraceElement element : Thread.currentThread().getStackTrace()) {
				if (element.getClassName().contains("openmrs")) {
					output.append("+ ");
				}
				output.append(element);
				output.append("\n");
			}
			log.trace("Stacktrace: " + output.toString());
		}
		
		// Check if we already tried this class loader
		if ((seenModules != null) && seenModules.contains(getModule().getModuleId())) {
			throw new ClassNotFoundException("Can't load class " + name + " from module " + getModule().getModuleId()
			        + ". It has been tried before.");
		}
		
		// Make sure the module is started
		if ((this != requestor) && !ModuleFactory.isModuleStarted(getModule())) {
			String msg = "Can't load class " + name + ", because module " + getModule().getModuleId()
			        + " is not yet started.";
			log.warn(msg);
			
			throw new ClassNotFoundException(msg);
		}
		
		// Check if the class has already been loaded by this class loader
		Class<?> result = findLoadedClass(name);
		
		// Try loading the class with this class loader 
		if (result == null) {
			try {
				result = findClass(name);
			}
			catch (ClassNotFoundException e) {
				// Continue trying...
			}
		}
		
		// We were able to "find" a class
		if (result != null) {
			checkClassVisibility(result, requestor);
			
			return result;
		}
		
		// Look through this module's imports to see if the class
		// can be loaded from them.
		
		if (seenModules == null) {
			seenModules = new HashSet<>();
		}
		
		// Add this module to the list of modules we've tried already
		seenModules.add(getModule().getModuleId());
		
		List<Module> importedModules = new ArrayList<>();
		if (requiredModules != null) {
			Collections.addAll(importedModules, requiredModules);
		}
		if (awareOfModules != null) {
			Collections.addAll(importedModules, awareOfModules);
		}
		
		for (Module importedModule : importedModules) {
			if (seenModules.contains(importedModule.getModuleId())) {
				continue;
			}
			
			ModuleClassLoader moduleClassLoader = ModuleFactory.getModuleClassLoader(importedModule);
			
			// Module class loader may be null if module has not been started yet
			if (moduleClassLoader != null) {
				try {
					result = moduleClassLoader.loadClass(name, resolve, requestor, seenModules);
					
					return result;
				}
				catch (ClassNotFoundException e) {
					// Continue trying...
				}
			}
		}
		
		throw new ClassNotFoundException(name);
	}
	
	/**
	 * Checking the given class's visibility in this module
	 *
	 * @param cls Class to check
	 * @param requestor ModuleClassLoader to check against
	 * @throws ClassNotFoundException
	 */
	protected void checkClassVisibility(final Class<?> cls, final ModuleClassLoader requestor)
	        throws ClassNotFoundException {
		
		if (this == requestor) {
			return;
		}
		
		URL lib = getClassBaseUrl(cls);
		
		if (lib == null) {
			// cls is a system class
			return;
		}
		
		ClassLoader loader = cls.getClassLoader();
		
		if (!(loader instanceof ModuleClassLoader)) {
			return;
		}
		
		if (loader != this) {
			((ModuleClassLoader) loader).checkClassVisibility(cls, requestor);
		}
	}
	
	/**
	 * @see java.lang.ClassLoader#findLibrary(java.lang.String)
	 */
	@Override
	protected String findLibrary(final String name) {
		if ((name == null) || "".equals(name.trim())) {
			return null;
		}
		
		if (log.isTraceEnabled()) {
			log.trace("findLibrary(String): name=" + name + ", this=" + this);
		}
		String libname = System.mapLibraryName(name);
		String result = null;
		
		if (log.isTraceEnabled()) {
			log.trace(
			    "findLibrary(String): name=" + name + ", libname=" + libname + ", result=" + result + ", this=" + this);
		}
		
		return result;
	}
	
	/**
	 * Saves the given library in the openmrs cache. This prevents locking of jars/files by servlet
	 * container
	 *
	 * @param libUrl URL to the library/jar file
	 * @param libname name of the jar that will be the name of the cached file
	 * @return file that is now copied and cached
	 */
	protected File cacheLibrary(final URL libUrl, final String libname) {
		File cacheFolder = OpenmrsClassLoader.getLibCacheFolder();
		
		URI libUri;
		try {
			libUri = libUrl.toURI();
		}
		catch (URISyntaxException e) {
			throw new IllegalArgumentException(libUrl.getPath() + " is not a valid URI", e);
		}
		
		if (libraryCache.containsKey(libUri)) {
			return libraryCache.get(libUri);
		}
		
		File result;
		try {
			if (cacheFolder == null) {
				throw new IOException("can't initialize libraries cache folder");
			}
			
			// create the directory to hold the jar's files
			File libCacheModuleFolder = new File(cacheFolder, getModule().getModuleId());
			
			// error while creating the file
			if (!libCacheModuleFolder.exists() && !libCacheModuleFolder.mkdirs()) {
				throw new IOException("can't create cache folder " + libCacheModuleFolder);
			}
			
			// directory within the specific folder within the cache
			result = new File(libCacheModuleFolder, libname);
			
			// copy the file over to the cache
			InputStream in = OpenmrsUtil.getResourceInputStream(libUrl);
			try {
				FileOutputStream fileOut = new FileOutputStream(result);
				OutputStream out = new BufferedOutputStream(fileOut);
				try {
					OpenmrsUtil.copyFile(in, out);
				}
				finally {
					try {
						out.close();
					}
					catch (Exception e) { /* pass */}
					try {
						fileOut.close();
					}
					catch (Exception e) {}
				}
			}
			finally {
				try {
					in.close();
				}
				catch (Exception e) { /* pass */}
			}
			
			// save a link to the cached file
			libraryCache.put(libUri, result);
			
			log.debug("library {} successfully cached from URL {} and saved to local file {}", libname, libUrl, result);
			
		}
		catch (IOException ioe) {
			log.error("can't cache library " + libname + " from URL " + libUrl, ioe);
			libraryCache.put(libUri, null);
			result = null;
		}
		
		return result;
	}
	
	/**
	 * If a resource is found within a jar, that jar URL is converted to a temporary file and a URL
	 * to that is returned
	 *
	 * @see java.lang.ClassLoader#findResource(java.lang.String)
	 */
	@Override
	public URL findResource(final String name) {
		URL result = findResource(name, this, null);
		
		return expandIfNecessary(result);
	}
	
	/**
	 * @see java.lang.ClassLoader#findResources(java.lang.String)
	 */
	@Override
	public Enumeration<URL> findResources(final String name) throws IOException {
		List<URL> result = new LinkedList<>();
		findResources(result, name, this, null);
		
		// expand all of the "jar" urls
		for (URL url : result) {
			url = expandIfNecessary(url);
		}
		
		return Collections.enumeration(result);
	}
	
	/**
	 * Find a resource (image, file, etc) in the module structure
	 *
	 * @param name String path and name of the file
	 * @param requestor ModuleClassLoader in which to look
	 * @param seenModules Set&lt;String&gt; modules that have been checked already
	 * @return URL to resource
	 * @see #findResource(String)
	 */
	protected URL findResource(final String name, final ModuleClassLoader requestor, Set<String> seenModules) {
		if (log.isTraceEnabled() && name != null && name.contains("starter")) {
			if (seenModules != null) {
				log.trace("seenModules.size: " + seenModules.size());
			}
			log.trace("name: " + name);
			for (URL url : getURLs()) {
				log.trace("url: " + url);
			}
		}
		
		if ((seenModules != null) && seenModules.contains(getModule().getModuleId())) {
			return null;
		}
		
		URL result = super.findResource(name);
		// found resource in this module class path
		if (result != null) {
			if (isResourceVisible(name, result, requestor)) {
				return result;
			}
			log.debug("Resource is not visible");
			return null;
		}
		
		if (seenModules == null) {
			seenModules = new HashSet<>();
		}
		
		seenModules.add(getModule().getModuleId());
		
		if (requiredModules != null) {
			for (Module publicImport : requiredModules) {
				if (seenModules.contains(publicImport.getModuleId())) {
					continue;
				}
				ModuleClassLoader mcl = ModuleFactory.getModuleClassLoader(publicImport);
				
				if (mcl != null) {
					result = mcl.findResource(name, requestor, seenModules);
				}
				
				if (result != null) {
					// found resource in required module
					return result;
				}
			}
		}
		
		//look through the aware of modules.
		for (Module publicImport : awareOfModules) {
			if (seenModules.contains(publicImport.getModuleId())) {
				continue;
			}
			
			ModuleClassLoader mcl = ModuleFactory.getModuleClassLoader(publicImport);
			
			if (mcl != null) {
				result = mcl.findResource(name, requestor, seenModules);
			}
			
			if (result != null) {
				// found resource in aware of module
				return result;
			}
		}
		
		return result;
	}
	
	/**
	 * Find all occurrences of a resource (image, file, etc) in the module structure
	 *
	 * @param result URL of the file found
	 * @param name String path and name of the file to find
	 * @param requestor ModuleClassLoader in which to start
	 * @param seenModules Set&lt;String&gt; moduleIds that have been checked already
	 * @throws IOException
	 * @see #findResources(String)
	 * @see #findResource(String, ModuleClassLoader, Set)
	 */
	protected void findResources(final List<URL> result, final String name, final ModuleClassLoader requestor,
	        Set<String> seenModules) throws IOException {
		if ((seenModules != null) && seenModules.contains(getModule().getModuleId())) {
			return;
		}
		for (Enumeration<URL> enm = super.findResources(name); enm.hasMoreElements();) {
			URL url = enm.nextElement();
			if (isResourceVisible(name, url, requestor)) {
				result.add(url);
			}
		}
		
		if (seenModules == null) {
			seenModules = new HashSet<>();
		}
		seenModules.add(getModule().getModuleId());
		if (requiredModules != null) {
			for (Module publicImport : requiredModules) {
				if (seenModules.contains(publicImport.getModuleId())) {
					continue;
				}
				
				ModuleClassLoader mcl = ModuleFactory.getModuleClassLoader(publicImport);
				
				if (mcl != null) {
					mcl.findResources(result, name, requestor, seenModules);
				}
			}
		}
		
		//look through the aware of modules.
		for (Module publicImport : awareOfModules) {
			if (seenModules.contains(publicImport.getModuleId())) {
				continue;
			}
			
			ModuleClassLoader mcl = ModuleFactory.getModuleClassLoader(publicImport);
			
			if (mcl != null) {
				mcl.findResources(result, name, requestor, seenModules);
			}
		}
	}
	
	/**
	 * Check if the given resource (image, file, etc) is visible by this classloader
	 *
	 * @param name String path and name to check
	 * @param url URL of the library file
	 * @param requestor ModuleClassLoader in which to look
	 * @return true/false whether this resource is visibile by this classloader
	 */
	protected boolean isResourceVisible(final String name, final URL url, final ModuleClassLoader requestor) {
		if (this == requestor) {
			return true;
		}
		try {
			String file = url.getFile();
			new URL(url.getProtocol(), url.getHost(), file.substring(0, file.length() - name.length()));
		}
		catch (MalformedURLException mue) {
			log.error("can't get resource library URL", mue);
			return false;
		}
		
		return true;
	}
	
	/**
	 * Expands the URL into the temporary folder if the URL points to a resource inside of a jar
	 * file
	 *
	 * @param result
	 * @return URL to the expanded result or null if an error occurred
	 */
	private URL expandIfNecessary(URL result) {
		if (result == null || !"jar".equals(result.getProtocol())) {
			return result;
		}
		
		File tmpFolder = getLibCacheFolderForModule(module);
		
		return OpenmrsClassLoader.expandURL(result, tmpFolder);
	}
	
	/**
	 * Contains all class packages provided by the module, including those contained in jars.
	 * <p>
	 * It is used by {@link OpenmrsClassLoader#loadClass(String, boolean)} and in particular
	 * {@link ModuleFactory#getModuleClassLoadersForPackage(String)} to quickly find possible
	 * loaders for the given class. Although it takes some time to extract all provided packages
	 * from a module, it pays off when loading classes. It is much faster to query a map of packages
	 * than iterating over all class loaders to find which one to use.
	 * 
	 * @return the provided packages
	 */
	public Set<String> getProvidedPackages() {
		return providedPackages;
	}
	
	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return "{ModuleClassLoader: uid=" + System.identityHashCode(this) + "; " + module + "}";
	}
	
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api.impl;
import java.io.UnsupportedEncodingException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.ConceptSource;
import org.openmrs.GlobalProperty;
import org.openmrs.ImplementationId;
import org.openmrs.OpenmrsData;
import org.openmrs.OpenmrsMetadata;
import org.openmrs.OpenmrsObject;
import org.openmrs.Privilege;
import org.openmrs.User;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.EventListeners;
import org.openmrs.api.GlobalPropertyListener;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.AdministrationDAO;
import org.openmrs.customdatatype.CustomDatatype;
import org.openmrs.customdatatype.CustomDatatypeUtil;
import org.openmrs.customdatatype.CustomValueDescriptor;
import org.openmrs.customdatatype.Customizable;
import org.openmrs.customdatatype.SingleCustomValue;
import org.openmrs.layout.LayoutSupport;
import org.openmrs.layout.LayoutTemplate;
import org.openmrs.messagesource.PresentationMessage;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.ModuleUtil;
import org.openmrs.obs.ComplexData;
import org.openmrs.person.PersonMergeLogData;
import org.openmrs.util.HttpClient;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.Errors;
/**
 * Default implementation of the administration services. This class should not be used on its own.
 * The current OpenMRS implementation should be fetched from the Context
 * 
 * @see org.openmrs.api.AdministrationService
 * @see org.openmrs.api.context.Context
 */
@Transactional
public class AdministrationServiceImpl extends BaseOpenmrsService implements AdministrationService, GlobalPropertyListener {
	
	private static final Logger log = LoggerFactory.getLogger(AdministrationServiceImpl.class);
	protected AdministrationDAO dao;
	
	private EventListeners eventListeners;
	
	/**
	 * An always up-to-date collection of the allowed locales.
	 */
	private GlobalLocaleList globalLocaleList;
	
	private HttpClient implementationIdHttpClient;
	
	/**
	 * Default empty constructor
	 */
	public AdministrationServiceImpl() {
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#setAdministrationDAO(org.openmrs.api.db.AdministrationDAO)
	 */
	@Override
	public void setAdministrationDAO(AdministrationDAO dao) {
		this.dao = dao;
	}
	
	public void setEventListeners(EventListeners eventListeners) {
		this.eventListeners = eventListeners;
	}
		
	/**
	 * Static-ish variable used to cache the system variables. This is not static so that every time
	 * a module is loaded or removed the variable is destroyed (along with the administration
	 * service) and recreated the next time it is called
	 */
	protected SortedMap<String, String> systemVariables = null;
	
	/**
	 * Set of locales which can be used to present messages in the user interface. Created lazily as
	 * needed by {@link #getAllowedLocales()}.
	 */
	private Set<Locale> presentationLocales;
	
	/**
	 * @see org.openmrs.api.AdministrationService#getSystemVariables()
	 */
	@Override
	@Transactional(readOnly = true)
	public SortedMap<String, String> getSystemVariables() throws APIException {
		if (systemVariables == null) {
			systemVariables = new TreeMap<>();
			
			// Added the server's fully qualified domain name
			try {
				systemVariables.put("OPENMRS_HOSTNAME", InetAddress.getLocalHost().getCanonicalHostName());
			}
			catch (UnknownHostException e) {
				systemVariables.put("OPENMRS_HOSTNAME", "Unknown host: " + e.getMessage());
			}
			systemVariables.put("OPENMRS_VERSION", String.valueOf(OpenmrsConstants.OPENMRS_VERSION));
			systemVariables.put("DATABASE_NAME", OpenmrsConstants.DATABASE_NAME);
			systemVariables.put("DATABASE_BUSINESS_NAME", OpenmrsConstants.DATABASE_BUSINESS_NAME);
			systemVariables.put("OBSCURE_PATIENTS", String.valueOf(OpenmrsConstants.OBSCURE_PATIENTS));
			systemVariables.put("OBSCURE_PATIENTS_FAMILY_NAME", OpenmrsConstants.OBSCURE_PATIENTS_FAMILY_NAME);
			systemVariables.put("OBSCURE_PATIENTS_GIVEN_NAME", OpenmrsConstants.OBSCURE_PATIENTS_GIVEN_NAME);
			systemVariables.put("OBSCURE_PATIENTS_MIDDLE_NAME", OpenmrsConstants.OBSCURE_PATIENTS_MIDDLE_NAME);
			systemVariables.put("MODULE_REPOSITORY_PATH", ModuleUtil.getModuleRepository().getAbsolutePath());
			systemVariables.put("OPERATING_SYSTEM_KEY", String.valueOf(OpenmrsConstants.OPERATING_SYSTEM_KEY));
			systemVariables.put("OPERATING_SYSTEM", String.valueOf(OpenmrsConstants.OPERATING_SYSTEM));
		}
		
		return systemVariables;
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getGlobalProperty(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public String getGlobalProperty(String propertyName) throws APIException {
		// This method should not have any authorization check
		if (propertyName == null) {
			return null;
		}
		
		GlobalProperty gp = dao.getGlobalPropertyObject(propertyName);
		if (gp != null) {
			if (canViewGlobalProperty(gp)) {
				return gp.getPropertyValue();
			} else {
				throw new APIException("GlobalProperty.error.privilege.required.view", new Object[] {
					gp.getViewPrivilege().getPrivilege(), propertyName });
			}
		} else {
			return null;
		}
	}
	
	private boolean canViewGlobalProperty(GlobalProperty property) {
		if (property.getViewPrivilege() == null) {
			return true;
		}
		
		return Context.getAuthenticatedUser().hasPrivilege(property.getViewPrivilege().getPrivilege());
	}
	
	private boolean canDeleteGlobalProperty(GlobalProperty property) {
		if (property.getDeletePrivilege() == null) {
			return true;
		}
		
		return Context.getAuthenticatedUser().hasPrivilege(property.getDeletePrivilege().getPrivilege());
	}
	
	private boolean canEditGlobalProperty(GlobalProperty property) {
		if (property.getEditPrivilege() == null) {
			return true;
		}
		
		return Context.getAuthenticatedUser().hasPrivilege(property.getEditPrivilege().getPrivilege());
	}
	
	private List<GlobalProperty> filterGlobalPropertiesByViewPrivilege(List<GlobalProperty> properties) {
		if (properties != null) {
			for (Iterator<GlobalProperty> iterator = properties.iterator(); iterator.hasNext();) {
				GlobalProperty property = iterator.next();
				Privilege vp = property.getViewPrivilege();
				if (vp != null && !Context.getAuthenticatedUser().hasPrivilege(vp.getPrivilege())) {
					iterator.remove();
				}
			}
		}
		return properties;
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getGlobalProperty(java.lang.String,
	 *      java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public String getGlobalProperty(String propertyName, String defaultValue) throws APIException {
		String s = Context.getAdministrationService().getGlobalProperty(propertyName);
		if (s == null) {
			return defaultValue;
		}
		return s;
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getGlobalPropertyObject(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public GlobalProperty getGlobalPropertyObject(String propertyName) {
		GlobalProperty gp = dao.getGlobalPropertyObject(propertyName);
		if (gp != null) {
			if (canViewGlobalProperty(gp)) {
				return gp;
			} else {
				throw new APIException("GlobalProperty.error.privilege.required.view", new Object[] {
					gp.getViewPrivilege().getPrivilege(), propertyName });
			}
		} else {
			return null;
		}
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#setGlobalProperty(java.lang.String,
	 *      java.lang.String)
	 */
	@Override
	public void setGlobalProperty(String propertyName, String propertyValue) throws APIException {
		GlobalProperty gp = Context.getAdministrationService().getGlobalPropertyObject(propertyName);
		if (gp == null) {
			gp = new GlobalProperty();
			gp.setProperty(propertyName);
		}
		gp.setPropertyValue(propertyValue);
		Context.getAdministrationService().saveGlobalProperty(gp);
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#updateGlobalProperty(java.lang.String,
	 *      java.lang.String)
	 */
	@Override
	public void updateGlobalProperty(String propertyName, String propertyValue) throws IllegalStateException {
		GlobalProperty gp = Context.getAdministrationService().getGlobalPropertyObject(propertyName);
		if (gp == null) {
			throw new IllegalStateException("Global property with the given propertyName does not exist" + propertyName);
		}
		
		if (!canEditGlobalProperty(gp)) {
			throw new APIException("GlobalProperty.error.privilege.required.edit", new Object[] {
				gp.getEditPrivilege().getPrivilege(), propertyName });
		}
		
		gp.setPropertyValue(propertyValue);
		dao.saveGlobalProperty(gp);
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getAllGlobalProperties()
	 */
	@Override
	@Transactional(readOnly = true)
	public List<GlobalProperty> getAllGlobalProperties() throws APIException {
		return filterGlobalPropertiesByViewPrivilege(dao.getAllGlobalProperties());
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getGlobalPropertiesByPrefix(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<GlobalProperty> getGlobalPropertiesByPrefix(String prefix) {
		return filterGlobalPropertiesByViewPrivilege(dao.getGlobalPropertiesByPrefix(prefix));
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getGlobalPropertiesBySuffix(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<GlobalProperty> getGlobalPropertiesBySuffix(String suffix) {
		return filterGlobalPropertiesByViewPrivilege(dao.getGlobalPropertiesBySuffix(suffix));
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#purgeGlobalProperty(org.openmrs.GlobalProperty)
	 */
	@Override
	public void purgeGlobalProperty(GlobalProperty globalProperty) throws APIException {
		if (!canDeleteGlobalProperty(globalProperty)) {
			throw new APIException("GlobalProperty.error.privilege.required.purge", new Object[] {
				globalProperty.getDeletePrivilege().getPrivilege(), globalProperty.getProperty() });
		}
		
		notifyGlobalPropertyDelete(globalProperty.getProperty());
		dao.deleteGlobalProperty(globalProperty);
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#saveGlobalProperties(java.util.List)
	 */
	@Override
	@CacheEvict(value = "userSearchLocales", allEntries = true)
	public List<GlobalProperty> saveGlobalProperties(List<GlobalProperty> props) throws APIException {
		log.debug("saving a list of global properties");
		
		// add all of the new properties
		for (GlobalProperty prop : props) {
			if (prop.getProperty() != null && prop.getProperty().length() > 0) {
				Context.getAdministrationService().saveGlobalProperty(prop);
			}
		}
		
		return props;
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#saveGlobalProperty(org.openmrs.GlobalProperty)
	 */
	@Override
	@CacheEvict(value = "userSearchLocales", allEntries = true)
	public GlobalProperty saveGlobalProperty(GlobalProperty gp) throws APIException {
		if (!canEditGlobalProperty(gp)) {
			throw new APIException("GlobalProperty.error.privilege.required.edit", new Object[] {
				gp.getEditPrivilege().getPrivilege(), gp.getProperty() });
		}
		
		// only try to save it if the global property has a key
		if (gp.getProperty() != null && gp.getProperty().length() > 0) {
			if (gp.getProperty().equals(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST)) {
				if (gp.getPropertyValue() != null) {
					List<Locale> localeList = new ArrayList<>();
					
					for (String localeString : gp.getPropertyValue().split(",")) {
						localeList.add(LocaleUtility.fromSpecification(localeString.trim()));
					}
					if (!localeList.contains(LocaleUtility.getDefaultLocale())) {
						gp.setPropertyValue(StringUtils.join(getAllowedLocales(), ", "));
						throw new APIException(Context.getMessageSourceService().getMessage(
						    "general.locale.localeListNotIncludingDefaultLocale",
						    new Object[] { LocaleUtility.getDefaultLocale() }, null));
					}
				}
			} else if (gp.getProperty().equals(OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE)
						&& gp.getPropertyValue() != null) {
			
					List<Locale> localeList = getAllowedLocales();
					
					if (!localeList.contains(LocaleUtility.fromSpecification(gp.getPropertyValue().trim()))) {
						String value = gp.getPropertyValue();
						gp.setPropertyValue(LocaleUtility.getDefaultLocale().toString());
						throw new APIException((Context.getMessageSourceService().getMessage(
						    "general.locale.defaultNotInAllowedLocalesList", new Object[] { value }, null)));
					}
			}
			
			CustomDatatypeUtil.saveIfDirty(gp);
			dao.saveGlobalProperty(gp);
			notifyGlobalPropertyChange(gp);
			return gp;
		}
		
		return gp;
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#executeSQL(java.lang.String, boolean)
	 */
	@Override
	public List<List<Object>> executeSQL(String sql, boolean selectOnly) throws APIException {
		if (sql == null || "".equals(sql.trim())) {
			return null;
		}
		
		return dao.executeSQL(sql, selectOnly);
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#addGlobalPropertyListener(GlobalPropertyListener)
	 */
	@Override
	public void addGlobalPropertyListener(GlobalPropertyListener listener) {
		eventListeners.getGlobalPropertyListeners().add(listener);
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#removeGlobalPropertyListener(GlobalPropertyListener)
	 */
	@Override
	public void removeGlobalPropertyListener(GlobalPropertyListener listener) {
		eventListeners.getGlobalPropertyListeners().remove(listener);
	}
	
	/**
	 * Calls global property listeners registered for this create/change
	 * 
	 * @param gp
	 */
	private void notifyGlobalPropertyChange(GlobalProperty gp) {
		for (GlobalPropertyListener listener : eventListeners.getGlobalPropertyListeners()) {
			if (listener.supportsPropertyName(gp.getProperty())) {
				listener.globalPropertyChanged(gp);
			}
		}
	}
	
	/**
	 * Calls global property listeners registered for this delete
	 * 
	 * @param propertyName
	 */
	private void notifyGlobalPropertyDelete(String propertyName) {
		for (GlobalPropertyListener listener : eventListeners.getGlobalPropertyListeners()) {
			if (listener.supportsPropertyName(propertyName)) {
				listener.globalPropertyDeleted(propertyName);
			}
		}
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getImplementationId()
	 */
	@Override
	@Transactional(readOnly = true)
	public ImplementationId getImplementationId() throws APIException {
		String property = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_IMPLEMENTATION_ID);
		
		// fail early if no gp has been defined yet
		if (property == null) {
			return null;
		}
		
		try {
			return Context.getSerializationService().getDefaultSerializer().deserialize(property, ImplementationId.class);
		}
		catch (Exception e) {
			log.debug("Error while getting implementation id", e);
		}
		
		return null;
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#setImplementationId(org.openmrs.ImplementationId)
	 */
	@Override
	public void setImplementationId(ImplementationId implementationId) throws APIException {
		
		if (implementationId == null) {
			return;
		}
		
		// check the validity of this implementation id with the server
		String description = implementationId.getDescription();
		try {
			// check that source id is valid
			description = checkImplementationIdValidity(implementationId.getImplementationId(), description,
			    implementationId.getPassphrase());
			
			// save the server's description back to this concept source object
			implementationId.setDescription(description);
			
			boolean foundMatchingSource = false;
			// loop over the concept sources to make sure one exists for this hl7Code/implementationId
			List<ConceptSource> sources = Context.getConceptService().getAllConceptSources(false);
			if (sources != null) {
				for (ConceptSource source : sources) {
					if (implementationId.getImplementationId().equals(source.getHl7Code())) {
						foundMatchingSource = true;
					}
				}
			}
			
			// if no ConceptSource currently exists with this implementationId, save this implId
			// as a new ConceptSource
			if (!foundMatchingSource) {
				ConceptSource newConceptSource = new ConceptSource();
				newConceptSource.setName(implementationId.getName());
				newConceptSource.setDescription(implementationId.getDescription());
				newConceptSource.setHl7Code(implementationId.getImplementationId());
				if (Context.getAuthenticatedUser() == null) {
					// (hackish)
					newConceptSource.setCreator(new User(1)); // fake the user because no one is logged in
				}
				Context.getConceptService().saveConceptSource(newConceptSource);
			}
			
			// serialize and save the ImplementationId to the global properties table
			String value = Context.getSerializationService().getDefaultSerializer().serialize(implementationId);
			Context.getAdministrationService().saveGlobalProperty(
			    new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_IMPLEMENTATION_ID, value));
		}
		catch (APIException e) {
			throw e;
		}
		catch (Exception e) {
			// pass any other exceptions on up the train
			throw new APIException(e);
		}
		finally {
			// save an empty concept source to the database when something fails?
		}
	}
	
	/**
	 * Checks the remote server for this exact implementation id. Returns the description if 1)
	 * there is no implementation id or 2) there is a implementation id and this passphrase matches
	 * it. In the case of 1), this implementation id and passphrase are saved to the remote server's
	 * database
	 * 
	 * @param implementationId
	 * @param description
	 * @param passphrase
	 * @return the stored description on the remote server
	 * @throws APIException
	 * @throws UnsupportedEncodingException
	 */
	private String checkImplementationIdValidity(String implementationId, String description, String passphrase)
	        throws APIException {
		
		if (StringUtils.isEmpty(implementationId)) {
			throw new APIException("cannot.be.empty", new Object[] { "implementationid" });
		}
		if (StringUtils.isEmpty(description)) {
			throw new APIException("cannot.be.empty", new Object[] { "description" });
		}
		if (StringUtils.isEmpty(passphrase)) {
			throw new APIException("cannot.be.empty", new Object[] { "passphrase" });
		}
		
		// set up the data map to post to the openmrs server
		Map<String, String> data = new HashMap<>();
		data.put("implementationId", implementationId);
		data.put("description", description);
		data.put("passphrase", passphrase);
		
		String response = implementationIdHttpClient.post(data);
		response = response.trim();
		
		if ("".equals(response)) {
			String ms = Context.getMessageSourceService().getMessage("ImplementationId.connectionError",
			    new String[] { implementationId }, Context.getLocale());
			throw new APIException(ms);
		}
		
		log.debug("Response: {}", response);
		
		if (response.startsWith("Success")) {
			response = response.replace("Success", "");
			return response.trim();
		}
		
		String ms = Context.getMessageSourceService().getMessage("ImplementationId.invalidIdorPassphrase",
		    new String[] { description }, Context.getLocale());
		throw new APIException(ms);
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getAllowedLocales()
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Locale> getAllowedLocales() {
		// lazy-load the global locale list and initialize with current global property value
		if (globalLocaleList == null) {
			globalLocaleList = new GlobalLocaleList();
			Context.getAdministrationService().addGlobalPropertyListener(globalLocaleList);
		}
		
		Set<Locale> allowedLocales = globalLocaleList.getAllowedLocales();
		
		// update the GlobalLocaleList.allowedLocales by faking a global property change
		if (allowedLocales == null) {
			// use a default language of "english" if they have cleared this GP for some reason
			String currentPropertyValue = Context.getAdministrationService().getGlobalProperty(
			    OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, LocaleUtility.getDefaultLocale().toString());
			GlobalProperty allowedLocalesProperty = new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST,
			        currentPropertyValue);
			globalLocaleList.globalPropertyChanged(allowedLocalesProperty);
			allowedLocales = globalLocaleList.getAllowedLocales();
		}
		
		// allowedLocales is guaranteed to not be null at this point
		return new ArrayList<>(allowedLocales);
	}
	
	/**
	 * Used by spring to set the GlobalLocaleList on this implementation
	 * 
	 * @param gll the GlobalLocaleList object that is registered to the GlobalPropertyListeners as
	 *            well
	 */
	public void setGlobalLocaleList(GlobalLocaleList gll) {
		globalLocaleList = gll;
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getPresentationLocales()
	 */
	@Override
	@Transactional(readOnly = true)
	public Set<Locale> getPresentationLocales() {
		if (presentationLocales == null) {
			presentationLocales = new LinkedHashSet<>();
			Collection<Locale> messageLocales = Context.getMessageSourceService().getLocales();
			List<Locale> allowedLocales = getAllowedLocales();
			
			for (Locale locale : allowedLocales) {
				// if no country is specified all countries with this language will be added
				if (StringUtils.isEmpty(locale.getCountry())) {
					List<Locale> localsWithSameLanguage = new ArrayList<>();
					for (Locale possibleLocale : messageLocales) {
						if (locale.getLanguage().equals(possibleLocale.getLanguage())
						        && !StringUtils.isEmpty(possibleLocale.getCountry())) {
							localsWithSameLanguage.add(possibleLocale);
						}
					}
					
					// if there are country locales we add those only
					if (!localsWithSameLanguage.isEmpty()) {
						presentationLocales.addAll(localsWithSameLanguage);
					} else {
						// if there are no country locales we add possibleLocale which has country as ""
						// e.g: if 'es' locale has no country based entries es_CL etc. we show default 'es'
						if (messageLocales.contains(locale)) {
							presentationLocales.add(locale);
						}
					}
				} else {
					// if locales list contains exact <language,country> pair add it
					if (messageLocales.contains(locale)) {
						presentationLocales.add(locale);
					} else {
						// if no such entry add possibleLocale with country ""
						// e.g: we specify es_CL but it is not in list so we add es locale here
						for (Locale possibleLocale : messageLocales) {
							if (locale.getLanguage().equals(possibleLocale.getLanguage())
							        && StringUtils.isEmpty(possibleLocale.getCountry())) {
								presentationLocales.add(possibleLocale);
							}
						}
					}
				}
			}
		}
		return presentationLocales;
	}
	
	/**
	 * @see org.openmrs.api.GlobalPropertyListener#globalPropertyChanged(org.openmrs.GlobalProperty)
	 */
	@Override
	public void globalPropertyChanged(GlobalProperty newValue) {
		if (newValue.getProperty().equals(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST)) {
			// reset the calculated locale values
			presentationLocales = null;
		}
	}
	
	/**
	 * @see org.openmrs.api.GlobalPropertyListener#globalPropertyDeleted(java.lang.String)
	 */
	@Override
	public void globalPropertyDeleted(String propertyName) {
		// TODO Auto-generated method stub
		
	}
	
	/**
	 * @see org.openmrs.api.GlobalPropertyListener#supportsPropertyName(java.lang.String)
	 */
	@Override
	public boolean supportsPropertyName(String propertyName) {
		return propertyName.equals(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST);
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getGlobalPropertyByUuid(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public GlobalProperty getGlobalPropertyByUuid(String uuid) {
		GlobalProperty gp =  dao.getGlobalPropertyByUuid(uuid);
		if (gp == null) {
			return null;
		} else if (canViewGlobalProperty(gp)) {
			return gp;
		} else {
			throw new APIException("GlobalProperty.error.privilege.required.view", new Object[] {
				gp.getViewPrivilege().getPrivilege(), gp.getProperty() });
		}
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getGlobalPropertyValue(java.lang.String,
	 *      java.lang.Object)
	 */
	@Override
	@SuppressWarnings("unchecked")
	public <T> T getGlobalPropertyValue(String propertyName, T defaultValue) throws APIException {
		if (defaultValue == null) {
			throw new IllegalArgumentException("The defaultValue argument cannot be null");
		}
		
		String propVal = Context.getAdministrationService().getGlobalProperty(propertyName);
		if (StringUtils.isEmpty(propVal)) {
			return defaultValue;
		}
		
		try {
			return (T) defaultValue.getClass().getDeclaredConstructor(String.class).newInstance(propVal);
		}
		catch (InstantiationException e) {
			throw new APIException("is.not.able.instantiated", new Object[] { defaultValue.getClass().getName(), propVal },
			        e);
		}
		catch (NoSuchMethodException e) {
			throw new APIException("does.not.have.string.constructor", new Object[] { defaultValue.getClass().getName() }, e);
		}
		catch (Exception e) {
			log.error("Unable to turn value '" + propVal + "' into type " + defaultValue.getClass().getName(), e);
			return defaultValue;
		}
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#getSystemInformation()
	 */
	@Override
	@Transactional(readOnly = true)
	public Map<String, Map<String, String>> getSystemInformation() throws APIException {
		Map<String, Map<String, String>> systemInfoMap = new LinkedHashMap<>();
		
		systemInfoMap.put("SystemInfo.title.openmrsInformation", new LinkedHashMap<String, String>() {
			
			private static final long serialVersionUID = 1L;
			
			{
				put("SystemInfo.OpenMRSInstallation.systemDate", new SimpleDateFormat("yyyy-MM-dd").format(Calendar
				        .getInstance().getTime()));
				put("SystemInfo.OpenMRSInstallation.systemTime", new SimpleDateFormat("HH:mm:ss").format(Calendar
				        .getInstance().getTime()));
				put("SystemInfo.OpenMRSInstallation.openmrsVersion", OpenmrsConstants.OPENMRS_VERSION);
				try {
					put("SystemInfo.hostname", InetAddress.getLocalHost().getCanonicalHostName());
				}
				catch (UnknownHostException e) {
					put("SystemInfo.hostname", "Unknown host: " + e.getMessage());
				}
			}
		});
		
		systemInfoMap.put("SystemInfo.title.javaRuntimeEnvironmentInformation", new LinkedHashMap<String, String>() {
			
			Properties properties = System.getProperties();
			
			private static final long serialVersionUID = 1L;
			
			{
				put("SystemInfo.JavaRuntimeEnv.operatingSystem", properties.getProperty("os.name"));
				put("SystemInfo.JavaRuntimeEnv.operatingSystemArch", properties.getProperty("os.arch"));
				put("SystemInfo.JavaRuntimeEnv.operatingSystemVersion", properties.getProperty("os.version"));
				put("SystemInfo.JavaRuntimeEnv.javaVersion", properties.getProperty("java.version"));
				put("SystemInfo.JavaRuntimeEnv.javaVendor", properties.getProperty("java.vendor"));
				put("SystemInfo.JavaRuntimeEnv.jvmVersion", properties.getProperty("java.vm.version"));
				put("SystemInfo.JavaRuntimeEnv.jvmVendor", properties.getProperty("java.vm.vendor"));
				put("SystemInfo.JavaRuntimeEnv.javaRuntimeName", properties.getProperty("java.runtime.name"));
				put("SystemInfo.JavaRuntimeEnv.javaRuntimeVersion", properties.getProperty("java.runtime.version"));
				put("SystemInfo.JavaRuntimeEnv.userName", properties.getProperty("user.name"));
				put("SystemInfo.JavaRuntimeEnv.systemLanguage", properties.getProperty("user.language"));
				put("SystemInfo.JavaRuntimeEnv.systemTimezone", properties.getProperty("user.timezone"));
				put("SystemInfo.JavaRuntimeEnv.fileSystemEncoding", properties.getProperty("sun.jnu.encoding"));
				put("SystemInfo.JavaRuntimeEnv.userDirectory", properties.getProperty("user.dir"));
				put("SystemInfo.JavaRuntimeEnv.tempDirectory", properties.getProperty("java.io.tmpdir"));
			}
		});
		
		systemInfoMap.put("SystemInfo.title.memoryInformation", new LinkedHashMap<String, String>() {
			
			private static final long serialVersionUID = 1L;
			
			Runtime runtime = Runtime.getRuntime();
			
			{
				put("SystemInfo.Memory.totalMemory", convertToMegaBytes(runtime.totalMemory()));
				put("SystemInfo.Memory.freeMemory", convertToMegaBytes(runtime.freeMemory()));
				put("SystemInfo.Memory.maximumHeapSize", convertToMegaBytes(runtime.maxMemory()));
				
			}
		});
		
		systemInfoMap.put("SystemInfo.title.dataBaseInformation", new LinkedHashMap<String, String>() {
			
			Properties properties = Context.getRuntimeProperties();
			
			private static final long serialVersionUID = 1L;
			
			{
				put("SystemInfo.Database.name", OpenmrsConstants.DATABASE_NAME);
				put("SystemInfo.Database.connectionURL", properties.getProperty("connection.url"));
				put("SystemInfo.Database.userName", properties.getProperty("connection.username"));
				put("SystemInfo.Database.driver", properties.getProperty("hibernate.connection.driver_class"));
				put("SystemInfo.Database.dialect", properties.getProperty("hibernate.dialect"));
				
			}
		});
		
		systemInfoMap.put("SystemInfo.title.moduleInformation", new LinkedHashMap<String, String>() {
			
			private static final long serialVersionUID = 1L;
			
			{
				put("SystemInfo.Module.repositoryPath", ModuleUtil.getModuleRepository().getAbsolutePath());
				Collection<Module> loadedModules = ModuleFactory.getLoadedModules();
				for (Module module : loadedModules) {
					String moduleInfo = module.getVersion() + " "
					        + (module.isStarted() ? "" : Context.getMessageSourceService().getMessage("Module.notStarted"));
					put(module.getName(), moduleInfo);
				}
			}
		});
		
		return systemInfoMap;
	}
	
	/**
	 * @param bytes to be converted into mega bytes
	 * @return memory in mega bytes
	 */
	private String convertToMegaBytes(long bytes) {
		final int ONE_KILO_BYTE = 1024;
		return String.valueOf(bytes / ONE_KILO_BYTE / ONE_KILO_BYTE) + " MB";
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#purgeGlobalProperties(java.util.List)
	 */
	@Override
	public void purgeGlobalProperties(List<GlobalProperty> globalProperties) throws APIException {
		for (GlobalProperty globalProperty : globalProperties) {
			Context.getAdministrationService().purgeGlobalProperty(globalProperty);
		}
	}
	
	/**
	 * @see AdministrationService#getMaximumPropertyLength(Class, String)
	 */
	@Override
	@Transactional(readOnly = true)
	public int getMaximumPropertyLength(Class<? extends OpenmrsObject> aClass, String fieldName) {
		return dao.getMaximumPropertyLength(aClass, fieldName);
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#validate(java.lang.Object, Errors)
	 */
	@Override
	@Transactional(readOnly = true)
	public void validate(Object object, Errors errors) throws APIException {
		if (object == null) {
			throw new APIException("error.null", (Object[]) null);
		}
		dao.validate(object, errors);
	}
	@Override
	@Cacheable(value = "userSearchLocales")
	public List<Locale> getSearchLocales(Locale currentLocale, User user) throws APIException {
		Set<Locale> locales = new LinkedHashSet<>();
		locales.add(currentLocale); //the currently used full locale
		locales.add(new Locale(currentLocale.getLanguage()));
		if (user != null) {
			List<Locale> proficientLocales = user.getProficientLocales();
			if (proficientLocales != null) {
				locales.addAll(proficientLocales);
			}
		}
		
		//limit locales to only allowed locales
		List<Locale> allowedLocales = Context.getAdministrationService().getAllowedLocales();
		if (allowedLocales != null) {
			Set<Locale> retainLocales = new HashSet<>();
			
			for (Locale allowedLocale : allowedLocales) {
				retainLocales.add(allowedLocale);
				retainLocales.add(new Locale(allowedLocale.getLanguage()));
			}
			
			locales.retainAll(retainLocales);
		}
		
		return new ArrayList<>(locales);
	}
	/**
	 * @see AdministrationService#getSearchLocales()
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Locale> getSearchLocales(){
		//call it via interface, so cache interceptor is invoked
		return Context.getAdministrationService().getSearchLocales(Context.getLocale(), Context.getAuthenticatedUser());
	}
	
	@Override
	public void setImplementationIdHttpClient(HttpClient implementationIdHttpClient) {
		this.implementationIdHttpClient = implementationIdHttpClient;
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#isDatabaseStringComparisonCaseSensitive()
	 */
	@Override
	public boolean isDatabaseStringComparisonCaseSensitive() {
		return dao.isDatabaseStringComparisonCaseSensitive();
	}
	
	/**
	 * @see org.openmrs.api.AdministrationService#updatePostgresSequence()
	 */
	@Override
	public void updatePostgresSequence() {
		dao.updatePostgresSequence();
	}
	@Override
	public List<String> getSerializerWhitelistTypes() {
		List<String> whitelistTypes = new ArrayList<>();
		List<Class<?>> hierarchyTypes = getSerializerDefaultWhitelistHierarchyTypes();
		for (Class<?> hierarchyType: hierarchyTypes) {
			whitelistTypes.add(GP_SERIALIZER_WHITELIST_HIERARCHY_TYPES_PREFIX + hierarchyType.getName());
		}
		List<GlobalProperty> gpTypes = getGlobalPropertiesBySuffix(
			AdministrationService.GP_SUFFIX_SERIALIZER_WHITELIST_TYPES);
		for (GlobalProperty gpType: gpTypes) {
			String[] types = gpType.getPropertyValue().split(",");
			for (String type: types) {
				if(!StringUtils.isBlank(type)) {
					whitelistTypes.add(type.trim());
				}
			}
		}
		return whitelistTypes;
	}
	public static List<Class<?>> getSerializerDefaultWhitelistHierarchyTypes() {
		List<Class<?>> types = Arrays.asList(OpenmrsObject.class, OpenmrsMetadata.class, OpenmrsData.class, 
			CustomDatatype.class, SingleCustomValue.class, CustomValueDescriptor.class, Customizable.class,
			LayoutTemplate.class, LayoutSupport.class, ComplexData.class, PresentationMessage.class,
			PersonMergeLogData.class);
		return types;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api.db.hibernate;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import org.hibernate.HibernateException;
import org.hibernate.Interceptor;
import org.hibernate.boot.Metadata;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.integrator.spi.Integrator;
import org.hibernate.service.spi.SessionFactoryServiceRegistry;
import org.openmrs.api.context.Context;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.hibernate5.LocalSessionFactoryBean;
public class HibernateSessionFactoryBean extends LocalSessionFactoryBean implements Integrator {
	
	private static final Logger log = LoggerFactory.getLogger(HibernateSessionFactoryBean.class);
	
	protected Set<String> mappingResources = new HashSet<>();
	
	/**
	 * @since 1.9.2, 1.10
	 */
	protected Set<String> packagesToScan = new HashSet<>();
	
	// @since 1.6.3, 1.7.2, 1.8.0, 1.9
	protected ChainingInterceptor chainingInterceptor = new ChainingInterceptor();
	
	// @since 1.6.3, 1.7.2, 1.8.0, 1.9
	// This will be sorted on keys before being used
	@Autowired(required = false)
	public Map<String, Interceptor> interceptors = new HashMap<>();
	
	private Metadata metadata;
	
	/**
	 * Collect the mapping resources for future use because the mappingResources object is defined
	 * as 'private' instead of 'protected'
	 */
	@Override
	public void setMappingResources(String... mappingResources) {
		Collections.addAll(this.mappingResources, mappingResources);
		
		super.setMappingResources(this.mappingResources.toArray(new String[] {}));
	}
	
	/**
	 * Collect packages to scan that are set in core and for tests in modules.
	 * <p>
	 * It adds to the set instead of overwriting it with each call.
	 */
	@Override
	public void setPackagesToScan(String... packagesToScan) {
		this.packagesToScan.addAll(Arrays.asList(packagesToScan));
		
		super.setPackagesToScan(this.packagesToScan.toArray(new String[0]));
	}
	
	public Set<String> getModuleMappingResources() {
		for (Module mod : ModuleFactory.getStartedModules()) {
			mappingResources.addAll(mod.getMappingFiles());
		}
		return mappingResources;
	}
	
	/**
	 * Gets packages with mapped classes from all modules.
	 *
	 * @return the set of packages with mapped classes
	 * @since 1.9.2, 1.10
	 */
	public Set<String> getModulePackagesWithMappedClasses() {
		Set<String> packages = new HashSet<>();
		for (Module module : ModuleFactory.getStartedModules()) {
			packages.addAll(module.getPackagesWithMappedClasses());
		}
		return packages;
	}
	
	/**
	 * Overridden to populate mappings from modules.
	 */
	@Override
	public void afterPropertiesSet() throws IOException {
		log.debug("Configuring hibernate sessionFactory properties");
		Properties config = getHibernateProperties();
		
		Properties moduleProperties = Context.getConfigProperties();
		
		// override or initialize config properties with module-provided ones
		for (Map.Entry<Object, Object> entry : moduleProperties.entrySet()) {
			Object key = entry.getKey();
			String prop = (String) key;
			String value = (String) entry.getValue();
			log.trace("Setting module property: " + prop + ":" + value);
			config.setProperty(prop, value);
			if (!prop.startsWith("hibernate")) {
				config.setProperty("hibernate." + prop, value);
			}
		}
		
		Properties properties = Context.getRuntimeProperties();
		
		// loop over runtime properties and override each in the configuration
		for (Map.Entry<Object, Object> entry : properties.entrySet()) {
			Object key = entry.getKey();
			String prop = (String) key;
			String value = (String) entry.getValue();
			log.trace("Setting property: " + prop + ":" + value);
			config.setProperty(prop, value);
			if (!prop.startsWith("hibernate")) {
				config.setProperty("hibernate." + prop, value);
			}
		}
		
		// load in the default hibernate properties
		try {
			InputStream propertyStream = getClass().getResourceAsStream("/hibernate.default.properties");
			Properties props = new Properties();
			
			OpenmrsUtil.loadProperties(props, propertyStream);
			propertyStream.close();
			
			// Only load in the default properties if they don't exist
			for (Entry<Object, Object> prop : props.entrySet()) {
				if (!config.containsKey(prop.getKey())) {
					config.put(prop.getKey(), prop.getValue());
				}
			}
			
		}
		catch (IOException e) {
			log.error(MarkerFactory.getMarker("FATAL"), "Unable to load default hibernate properties", e);
		}
		
		log.debug("Replacing variables in hibernate properties");
		final String applicationDataDirectory = OpenmrsUtil.getApplicationDataDirectory();
		for (Entry<Object, Object> entry : config.entrySet()) {
			String value = (String) entry.getValue();
			
			value = value.replace("%APPLICATION_DATA_DIRECTORY%", applicationDataDirectory);
			entry.setValue(value);
		}
		
		log.debug("Setting global Hibernate Session Interceptor for SessionFactory, Interceptor: " + chainingInterceptor);
		
		// make sure all autowired interceptors are put onto our chaining interceptor
		// sort on the keys so that the devs/modules have some sort of control over the order of the interceptors 
		List<String> keys = new ArrayList<>(interceptors.keySet());
		Collections.sort(keys);
		for (String key : keys) {
			chainingInterceptor.addInterceptor(interceptors.get(key));
		}
		
		setEntityInterceptor(chainingInterceptor);
		
		//Adding each module's mapping file to the list of mapping resources
		setMappingResources(getModuleMappingResources().toArray(new String[0]));
		
		setPackagesToScan(getModulePackagesWithMappedClasses().toArray(new String[0]));
		
		setHibernateIntegrators(this);
		
		super.afterPropertiesSet();
	}
	
	/**
	 * @see org.springframework.orm.hibernate3.LocalSessionFactoryBean#destroy()
	 */
	@Override
	public void destroy() throws HibernateException {
		try {
			super.destroy();
		}
		catch (IllegalStateException e) {
			// ignore errors sometimes thrown by the CacheManager trying to shut down twice
			// see net.sf.ehcache.CacheManager#removeShutdownHook()
		}
	}
	@Override
	public void integrate(Metadata metadata, SessionFactoryImplementor sessionFactory,
			SessionFactoryServiceRegistry serviceRegistry) {
		this.metadata = metadata;
	}
	@Override
	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
		
	}
	/**
	 * @since 2.4
	 */
	public Metadata getMetadata() {
		return metadata;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.messagesource.impl;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import org.openmrs.messagesource.MutableMessageSource;
import org.openmrs.messagesource.PresentationMessage;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleClassLoader;
import org.openmrs.module.ModuleFactory;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;
/**
 * ResourceBundleMessageSource extends ReloadableResourceBundleMessageSource to provide the
 * additional features of a MutableMessageSource.
 */
public class MutableResourceBundleMessageSource extends ReloadableResourceBundleMessageSource implements MutableMessageSource {
	private static final Logger log = LoggerFactory.getLogger(MutableResourceBundleMessageSource.class);
	
	/**
	 * Local reference to basenames used to search for properties files.
	 */
	private String[] basenames = new String[0];
	
	private int cacheMilliseconds = -1;
	
	private long lastCached = System.currentTimeMillis();
	
	/** Cached list of available locales. */
	private Collection<Locale> locales;
	
	/**
	 * @see org.openmrs.messagesource.MessageSourceService#getLocales()
	 */
	@Override
	public Collection<Locale> getLocales() {
		long now = System.currentTimeMillis();
		if (locales == null || cacheMilliseconds <= 0 || now - cacheMilliseconds > lastCached) {
			locales = findLocales();
			lastCached = now;
		}
		
		return locales;
	}
	
	@Override
	public void setCacheSeconds(int cacheSeconds) {
		this.cacheMilliseconds = cacheSeconds * 1000;
		super.setCacheSeconds(cacheSeconds);
	}
	
	/**
	 * This method looks at the current property files and deduces what locales are available from
	 * those
	 *
	 * @see #getLocales()
	 * @see #findPropertiesFiles()
	 */
	private Collection<Locale> findLocales() {
		Collection<Locale> foundLocales = new HashSet<>();
		
		for (Resource propertiesFile : findPropertiesFiles()) {
			String filename = propertiesFile.getFilename();
			
			Locale parsedLocale = parseLocaleFrom(filename);
			
			foundLocales.add(parsedLocale);
			
		}
		
		if (foundLocales.isEmpty()) {
			log.warn("no locales found.");
		}
		return foundLocales;
	}
	
	/**
	 * Utility method for deriving a locale from a filename, presumed to have an embedded locale
	 * specification near the end. For instance messages_it.properties if the filename is
	 * messages.properties, the Locale is presumed to be the default set for Java
	 *
	 * @param filename the name to parse
	 * @return Locale derived from the given string
	 */
	private Locale parseLocaleFrom(String filename) {
		Locale parsedLocale;
		
		// trim off leading basename
		filename = filename.substring("messages".length());
		
		// trim off extension
		String localespec = filename.substring(0, filename.indexOf('.'));
		
		if ("".equals(localespec)) {
			parsedLocale = Locale.getDefault();
		} else {
			localespec = localespec.substring(1); // trim off leading '_'
			parsedLocale = LocaleUtility.fromSpecification(localespec);
		}
		return parsedLocale;
	}
	
	/**
	 * Returns all available messages.
	 *
	 * @see org.openmrs.messagesource.MessageSourceService#getPresentations()
	 */
	@Override
	public Collection<PresentationMessage> getPresentations() {
		Collection<PresentationMessage> presentations = new ArrayList<>();
		
		for (Resource propertiesFile : findPropertiesFiles()) {
			Locale currentLocale = parseLocaleFrom(propertiesFile.getFilename());
			Properties props = new Properties();
			try {
				OpenmrsUtil.loadProperties(props, propertiesFile.getInputStream());
				for (Map.Entry<Object, Object> property : props.entrySet()) {
					presentations.add(new PresentationMessage(property.getKey().toString(), currentLocale, property
					        .getValue().toString(), ""));
				}
			}
			catch (Exception e) {
				// skip over errors in loading a single file
				log.error("Unable to load properties from file: " + propertiesFile.getFilename(), e);
			}
		}
		return presentations;
	}
	
	/**
	 * Override to obtain a local reference to the basenames.
	 *
	 * @see org.springframework.context.support.ReloadableResourceBundleMessageSource#setBasename(java.lang.String)
	 */
	@Override
	public void setBasename(String basename) {
		super.setBasename(basename);
		this.basenames = new String[] { basename };
	}
	
	/**
	 * Override to obtain a local reference to the basenames.
	 *
	 * @see org.springframework.context.support.ReloadableResourceBundleMessageSource#setBasenames(java.lang.String[])
	 */
	@Override
	public void setBasenames(String... basenames) {
		if (basenames == null) {
			this.basenames = new String[0];
		} else {
			this.basenames = Arrays.copyOf(basenames, basenames.length);
		}
		
		//add module file urls to basenames used for locating message properties files
		Collection<Module> modules = ModuleFactory.getStartedModules();
		if (!modules.isEmpty()) {
			String[] names =  new String[this.basenames.length + modules.size()];
			System.arraycopy(this.basenames, 0, names, 0, this.basenames.length);
			int index = this.basenames.length;
			for (Module module : modules) {
				names[index] = "jar:file:" + module.getFile().getAbsolutePath() + "!/messages";
				index++;
			}
			
			basenames = names;
		}
		
		super.setBasenames(basenames);
	}
	
	/**
	 * @see org.openmrs.messagesource.MutableMessageSource#addPresentation(org.openmrs.messagesource.PresentationMessage)
	 */
	@Override
	public void addPresentation(PresentationMessage message) {
		Resource propertyFile = findPropertiesFileFor(message.getCode());
		if (propertyFile != null) {
			Properties props = new Properties();
			try {
				OpenmrsUtil.loadProperties(props, propertyFile.getInputStream());
				props.setProperty(message.getCode(), message.getMessage());
				
				//TODO properties files are now in api jar files which cannot be modified. TRUNK-4097
				//We should therefore remove this method implementation or stop claiming that we are a mutable resource
				//OpenmrsUtil.storeProperties(props, propertyFile.getInputStream(), "OpenMRS Application Messages");
			}
			catch (Exception e) {
				log.error("Error generated", e);
			}
		}
	}
	
	/**
	 * @see org.openmrs.messagesource.MutableMessageSource#removePresentation(org.openmrs.messagesource.PresentationMessage)
	 */
	@Override
	public void removePresentation(PresentationMessage message) {
		Resource propertyFile = findPropertiesFileFor(message.getCode());
		if (propertyFile != null) {
			Properties props = new Properties();
			try {
				OpenmrsUtil.loadProperties(props, propertyFile.getInputStream());
				props.remove(message.getCode());
				
				//TODO properties files are now in api jar files which cannot be modified. TRUNK-4097
				//We should therefore remove this method implementation or stop claiming that we are a mutable resource
				//OpenmrsUtil.storeProperties(props, propertyFile, PROPERTIES_FILE_COMMENT);
			}
			catch (Exception e) {
				log.error("Error generated", e);
			}
		}
	}
	
	/**
	 * Convenience method to scan the available properties files, looking for the one that has a
	 * definition for the given code.
	 *
	 * @param code
	 * @return the file which defines the code, or null if not found
	 */
	private Resource findPropertiesFileFor(String code) {
		Properties props = new Properties();
		Resource foundFile = null;
		
		for (Resource propertiesFile : findPropertiesFiles()) {
			props.clear();
			try {
				OpenmrsUtil.loadProperties(props, propertiesFile.getInputStream());
			}
			catch (Exception e) {
				log.error("Error generated", e);
			}
			if (props.containsKey(code)) {
				foundFile = propertiesFile;
				break;
			}
		}
		return foundFile;
	}
	
	/**
	 * Searches the filesystem for message properties files. ABKTODO: consider caching this, rather
	 * than searching every time
	 *
	 * @return an array of property file names
	 */
	private Resource[] findPropertiesFiles() {
		Set<Resource> resourceSet = new HashSet<>();
		try {
			String pattern = "classpath*:messages*.properties";
			ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver(OpenmrsClassLoader.getInstance());
			Resource[] propertiesFiles = resourceResolver.getResources(pattern);
			Collections.addAll(resourceSet, propertiesFiles);
			
			for (ModuleClassLoader moduleClassLoader : ModuleFactory.getModuleClassLoaders()) {
				resourceResolver = new PathMatchingResourcePatternResolver(moduleClassLoader);
				propertiesFiles = resourceResolver.getResources(pattern);
				Collections.addAll(resourceSet, propertiesFiles);
			}
		}
		catch (IOException e) {
			log.error("Error generated", e);
		}
		if (log.isWarnEnabled() && (resourceSet.isEmpty())) {
			log.warn("No properties files found.");
		}
		return resourceSet.toArray(new Resource[resourceSet.size()]);
	}
	
	/**
	 * @see org.openmrs.messagesource.MutableMessageSource#merge(MutableMessageSource, boolean)
	 */
	@Override
	public void merge(MutableMessageSource fromSource, boolean overwrite) {
		
		// collect all existing properties
		Resource[] propertiesFiles = findPropertiesFiles();
		Map<Locale, List<Resource>> localeToFilesMap = new HashMap<>();
		Map<Resource, Properties> fileToPropertiesMap = new HashMap<>();
		
		for (Resource propertiesFile : propertiesFiles) {
			Properties props = new Properties();
			Locale propsLocale = parseLocaleFrom(propertiesFile.getFilename());
			List<Resource> propList = localeToFilesMap.computeIfAbsent(propsLocale, k -> new ArrayList<>());
			propList.add(propertiesFile);
			
			try {
				OpenmrsUtil.loadProperties(props, propertiesFile.getInputStream());
				fileToPropertiesMap.put(propertiesFile, props);
			}
			catch (Exception e) {
				// skip over errors in loading a single file
				log.error("Unable to load properties from file: " + propertiesFile.getFilename(), e);
			}
		}
		
		// merge in the new properties
		for (PresentationMessage message : fromSource.getPresentations()) {
			Locale messageLocale = message.getLocale();
			
			List<Resource> filelist = localeToFilesMap.get(messageLocale);
			if (filelist != null) {
				Properties propertyDestination = null;
				boolean propExists = false;
				for (Resource propertiesFile : filelist) {
					Properties possibleDestination = fileToPropertiesMap.get(propertiesFile);
					
					if (possibleDestination.containsKey(message.getCode())) {
						propertyDestination = possibleDestination;
						propExists = true;
						break;
					} else if (propertyDestination == null) {
						propertyDestination = possibleDestination;
					}
				}
				if (!propExists || overwrite) {
					propertyDestination.put(message.getCode(), message.getMessage());
				}
				
			}
			
			message.getCode();
		}
	}
	
	/**
	 * @see org.openmrs.messagesource.MutableMessageSource#getPresentation(java.lang.String,
	 *      java.util.Locale)
	 */
	@Override
	public PresentationMessage getPresentation(String key, Locale forLocale) {
		// TODO Auto-generated method stub
		return null;
	}
	
	/**
	 * @see org.openmrs.messagesource.MutableMessageSource#getPresentationsInLocale(java.util.Locale)
	 */
	@Override
	public Collection<PresentationMessage> getPresentationsInLocale(Locale locale) {
		// TODO Auto-generated method stub
		return null;
	}
	
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module.web;
import java.io.IOException;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Map;
import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class ModuleServlet extends HttpServlet {
	
	private static final long serialVersionUID = 1239820102030303L;
	
	private static final Logger log = LoggerFactory.getLogger(ModuleServlet.class);
	
	@Override
	protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		log.debug("In service method for module servlet: " + request.getPathInfo());
		String servletName = request.getPathInfo();
		int end = servletName.indexOf("/", 1);
		
		String moduleId = null;
		if (end > 0) {
			moduleId = servletName.substring(1, end);
		}
		
		log.debug("ModuleId: " + moduleId);
		Module mod = ModuleFactory.getModuleById(moduleId);
		 
		// where in the path to start trimming
		int start = 1;
		if (mod != null) {
			log.debug("Module with id " + moduleId + " found.  Looking for servlet name after " + moduleId + " in url path");
			start = moduleId.length() + 2;
			// this skips over the moduleId that is in the path
		}
		
		end = servletName.indexOf("/", start);
		if (end == -1 || end > servletName.length()) {
			end = servletName.length();
		}
		servletName = servletName.substring(start, end);
		
		log.debug("Servlet name: " + servletName);
		
		HttpServlet servlet = WebModuleUtil.getServlet(servletName);
		
		if (servlet == null) {
			log.warn("No servlet with name: " + servletName + " was found");
			response.setStatus(HttpServletResponse.SC_NOT_FOUND);
			return;
		}
		
		servlet.service(request, response);
	}
	/**
	 * Internal implementation of the ServletConfig interface, to be passed to module servlets when
	 * they are first loaded
	 */
	public static class SimpleServletConfig implements ServletConfig {
		
		private String name;
		
		private ServletContext servletContext;
		private final Map<String, String> initParameters;
		public SimpleServletConfig(String name, ServletContext servletContext, Map<String, String> initParameters) {
			this.name = name;
			this.servletContext = servletContext;
			this.initParameters = initParameters;
		}
		
		@Override
		public String getServletName() {
			return name;
		}
		
		@Override
		public ServletContext getServletContext() {
			return servletContext;
		}
		
		// not implemented in a module's config.xml yet
		@Override
		public String getInitParameter(String paramName) {
			return initParameters.get(paramName);
		}
		@Override
		public Enumeration<String> getInitParameterNames() {
			return Collections.enumeration(initParameters.keySet());
		}
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module.web;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringReader;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Deque;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Pattern;
import javax.servlet.Filter;
import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleException;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.ModuleUtil;
import org.openmrs.module.web.filter.ModuleFilterConfig;
import org.openmrs.module.web.filter.ModuleFilterDefinition;
import org.openmrs.module.web.filter.ModuleFilterMapping;
import org.openmrs.scheduler.SchedulerException;
import org.openmrs.scheduler.SchedulerService;
import org.openmrs.scheduler.TaskDefinition;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.web.DispatcherServlet;
import org.openmrs.web.StaticDispatcherServlet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.context.support.WebApplicationContextUtils;
import org.springframework.web.context.support.XmlWebApplicationContext;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
public class WebModuleUtil {
	private WebModuleUtil() {
	}
	
	private static final Logger log = LoggerFactory.getLogger(WebModuleUtil.class);
	
	private static final Lock SERVLET_LOCK = new ReentrantLock();
	
	private static final Lock FILTERS_LOCK = new ReentrantLock();
	
	// caches all modules' mapped servlets
	private static final Map<String, HttpServlet> MODULE_SERVLETS = new HashMap<>();
	
	// caches all modules filters and filter-mappings
	private static final Map<Module, Collection<Filter>> MODULE_FILTERS = new HashMap<>();
	
	private static final Map<String, Filter> MODULE_FILTERS_BY_NAME = new HashMap<>();
	
	private static final Deque<ModuleFilterMapping> MODULE_FILTER_MAPPINGS = new ArrayDeque<>();
	
	private static DispatcherServlet dispatcherServlet = null;
	
	private static StaticDispatcherServlet staticDispatcherServlet = null;
	
	/**
	 * Performs the webapp specific startup needs for modules Normal startup is done in
	 * {@link ModuleFactory#startModule(Module)} If delayContextRefresh is true, the spring context
	 * is not rerun. This will save a lot of time, but it also means that the calling method is
	 * responsible for restarting the context if necessary (the calling method will also have to
	 * call {@link #loadServlets(Module, ServletContext)} and
	 * {@link #loadFilters(Module, ServletContext)}).<br>
	 * <br>
	 * If delayContextRefresh is true and this module should have caused a context refresh, a true
	 * value is returned. Otherwise, false is returned
	 *
	 * @param mod Module to start
	 * @param servletContext the current ServletContext
	 * @param delayContextRefresh true/false whether or not to do the context refresh
	 * @return boolean whether or not the spring context need to be refreshed
	 */
	public static boolean startModule(Module mod, ServletContext servletContext, boolean delayContextRefresh) {
		
		log.debug("trying to start module {}", mod);
		
		// only try and start this module if the api started it without a
		// problem.
		if (ModuleFactory.isModuleStarted(mod) && !mod.hasStartupError()) {
			
			String realPath = getRealPath(servletContext);
			
			if (realPath == null) {
				realPath = System.getProperty("user.dir");
			}
			
			File webInf = new File(realPath + "/WEB-INF".replace("/", File.separator));
			if (!webInf.exists()) {
				webInf.mkdir();
			}
			
			// flag to tell whether we added any xml/dwr/etc changes that necessitate a refresh
			// of the web application context
			boolean moduleNeedsContextRefresh = false;
			
			// copy the html files into the webapp (from /web/module/ in the module)
			// also looks for a spring context file. If found, schedules spring to be restarted
			JarFile jarFile = null;
			OutputStream outStream = null;
			InputStream inStream = null;
			try {
				File modFile = mod.getFile();
				jarFile = new JarFile(modFile);
				Enumeration<JarEntry> entries = jarFile.entries();
				
				while (entries.hasMoreElements()) {
					JarEntry entry = entries.nextElement();
					String name = entry.getName();
					if (Paths.get(name).startsWith("..")) {
						throw new UnsupportedOperationException("Attempted to write file '" + name + "' rejected as it attempts to write outside the chosen directory. This may be the result of a zip-slip style attack.");
					}
					
					log.debug("Entry name: {}", name);
					if (name.startsWith("web/module/")) {
						// trim out the starting path of "web/module/"
						String filepath = name.substring(11);
						
						StringBuilder absPath = new StringBuilder(realPath + "/WEB-INF");
						
						// If this is within the tag file directory, copy it into /WEB-INF/tags/module/moduleId/...
						if (filepath.startsWith("tags/")) {
							filepath = filepath.substring(5);
							absPath.append("/tags/module/");
						}
						// Otherwise, copy it into /WEB-INF/view/module/moduleId/...
						else {
							absPath.append("/view/module/");
						}
						
						// if a module id has a . in it, we should treat that as a /, i.e. files in the module
						// ui.springmvc should go in folder names like .../ui/springmvc/...
						absPath.append(mod.getModuleIdAsPath()).append("/").append(filepath);
						log.debug("Moving file from: {} to {}", name, absPath);
						
						// get the output file
						File outFile = new File(absPath.toString().replace("/", File.separator));
						if (entry.isDirectory()) {
							if (!outFile.exists()) {
								outFile.mkdirs();
							}
						} else {
							// make the parent directories in case it doesn't exist
							File parentDir = outFile.getParentFile();
							if (!parentDir.exists()) {
								parentDir.mkdirs();
							}
							
							// copy the contents over to the webapp for non directories
							outStream = new FileOutputStream(outFile, false);
							inStream = jarFile.getInputStream(entry);
							OpenmrsUtil.copyFile(inStream, outStream);
						}
					} else if ("moduleApplicationContext.xml".equals(name) || "webModuleApplicationContext.xml".equals(name)) {
						moduleNeedsContextRefresh = true;
					} else if (name.equals(mod.getModuleId() + "Context.xml")) {
						String msg = "DEPRECATED: '" + name
						        + "' should be named 'moduleApplicationContext.xml' now. Please update/upgrade. ";
						throw new ModuleException(msg, mod.getModuleId());
					}
				}
			}
			catch (IOException io) {
				log.warn("Unable to copy files from module " + mod.getModuleId() + " to the web layer", io);
			}
			finally {
				if (jarFile != null) {
					try {
						jarFile.close();
					}
					catch (IOException io) {
						log.warn("Couldn't close jar file: " + jarFile.getName(), io);
					}
				}
				if (inStream != null) {
					try {
						inStream.close();
					}
					catch (IOException io) {
						log.warn("Couldn't close InputStream: " + io);
					}
				}
				if (outStream != null) {
					try {
						outStream.close();
					}
					catch (IOException io) {
						log.warn("Couldn't close OutputStream: " + io);
					}
				}
			}
			
			// find and add the dwr code to the dwr-modules.xml file (if defined)
			InputStream inputStream = null;
			try {
				Document config = mod.getConfig();
				Element root = config.getDocumentElement();
				if (root.getElementsByTagName("dwr").getLength() > 0) {
					
					// get the dwr-module.xml file that we're appending our code to
					File f = new File(realPath + "/WEB-INF/dwr-modules.xml".replace("/", File.separator));
					
					// testing if file exists
					if (!f.exists()) {
						// if it does not -> needs to be created
						createDwrModulesXml(realPath);
					}
					
					inputStream = new FileInputStream(f);
					Document dwrmodulexml = getDWRModuleXML(inputStream, realPath);
					Element outputRoot = dwrmodulexml.getDocumentElement();
					
					// loop over all of the children of the "dwr" tag
					Node node = root.getElementsByTagName("dwr").item(0);
					Node current = node.getFirstChild();
					
					while (current != null) {
						if ("allow".equals(current.getNodeName()) || "signatures".equals(current.getNodeName())
						        || "init".equals(current.getNodeName())) {
							((Element) current).setAttribute("moduleId", mod.getModuleId());
							outputRoot.appendChild(dwrmodulexml.importNode(current, true));
						}
						
						current = current.getNextSibling();
					}
					
					moduleNeedsContextRefresh = true;
					
					// save the dwr-modules.xml file.
					OpenmrsUtil.saveDocument(dwrmodulexml, f);
				}
			}
			catch (FileNotFoundException e) {
				throw new ModuleException(realPath + "/WEB-INF/dwr-modules.xml file doesn't exist.", e);
			}
			finally {
				if (inputStream != null) {
					try {
						inputStream.close();
					}
					catch (IOException io) {
						log.error("Error while closing input stream", io);
					}
				}
			}
			
			// mark to delete the entire module web directory on exit
			// this will usually only be used when an improper shutdown has occurred.
			String folderPath = realPath + "/WEB-INF/view/module/" + mod.getModuleIdAsPath();
			File outFile = new File(folderPath.replace("/", File.separator));
			outFile.deleteOnExit();
			
			// additional checks on module needing a context refresh
			if (!moduleNeedsContextRefresh && mod.getAdvicePoints() != null && !mod.getAdvicePoints().isEmpty()) {
				
				// AOP advice points are only loaded during the context refresh now.
				// if the context hasn't been marked to be refreshed yet, mark it
				// now if this module defines some advice
				moduleNeedsContextRefresh = true;
				
			}
			
			// refresh the spring web context to get the just-created xml
			// files into it (if we copied an xml file)
			if (moduleNeedsContextRefresh && !delayContextRefresh) {
				log.debug("Refreshing context for module {}", mod);
				
				try {
					refreshWAC(servletContext, false, mod);
					log.debug("Done Refreshing WAC");
				}
				catch (Exception e) {
					String msg = "Unable to refresh the WebApplicationContext";
					mod.setStartupErrorMessage(msg, e);
					
					if (log.isWarnEnabled()) {
						log.warn(msg + " for module: " + mod.getModuleId(), e);
					}
					
					try {
						stopModule(mod, servletContext, true);
						ModuleFactory.stopModule(mod, true, true); //remove jar from classloader play
					}
					catch (Exception e2) {
						// exception expected with most modules here
						if (log.isWarnEnabled()) {
							log.warn("Error while stopping a module that had an error on refreshWAC", e2);
						}
					}
					
					// try starting the application context again
					refreshWAC(servletContext, false, mod);
					
					notifySuperUsersAboutModuleFailure(mod);
				}
				
			}
			
			if (!delayContextRefresh && ModuleFactory.isModuleStarted(mod)) {
				// only loading the servlets/filters if spring is refreshed because one
				// might depend on files being available in spring
				// if the caller wanted to delay the refresh then they are responsible for
				// calling these two methods on the module
				
				// find and cache the module's servlets
				//(only if the module started successfully previously)
				log.debug("Loading servlets and filters for module {}", mod);
				servletContext.setAttribute(OpenmrsJspServlet.OPENMRS_TLD_SCAN_NEEDED, true);
				loadServlets(mod, servletContext);
				loadFilters(mod, servletContext);
			}
			
			// return true if the module needs a context refresh and we didn't do it here
			return (moduleNeedsContextRefresh && delayContextRefresh);
			
		}
		
		// we aren't processing this module, so a context refresh is not necessary
		return false;
	}
	
	/** Stops all tasks started by given module
	 * @param mod
	 */
	private static void stopTasks(Module mod) {
		SchedulerService schedulerService;
		try {
			schedulerService = Context.getSchedulerService();
		} catch (NullPointerException | APIException e) {
			// if we got here, the scheduler has already been shut down, so there's no work to do
			return;
		}
		
		String modulePackageName = mod.getPackageName();
		for (TaskDefinition task : schedulerService.getRegisteredTasks()) {
			
			String taskClass = task.getTaskClass();
			if (isModulePackageNameInTaskClass(modulePackageName, taskClass)) {
				try {
					schedulerService.shutdownTask(task);
				}
				catch (SchedulerException e) {
					log.error("Couldn't stop task:" + task + " for module: " + mod);
				}
			}
		}
	}
	
	/**
	 * Checks if module package name is in task class name
	 * @param modulePackageName the package name of module
	 * @param taskClass the class of given task
	 * @return true if task and module are in the same package
	 * <strong>Should</strong> return false for different package names
	 * <strong>Should</strong> return false if module has longer package name
	 * <strong>Should</strong> properly match subpackages
	 * <strong>Should</strong> return false for empty package names
	 */
	public static boolean isModulePackageNameInTaskClass(String modulePackageName, String taskClass) {
		return modulePackageName.length() <= taskClass.length()
		        && taskClass.matches(Pattern.quote(modulePackageName) + "(\\..*)+");
	}
	
	/**
	 * Send an Alert to all super users that the given module did not start successfully.
	 *
	 * @param mod The Module that failed
	 */
	private static void notifySuperUsersAboutModuleFailure(Module mod) {
		try {
			// Add the privileges necessary for notifySuperUsers
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
			Context.addProxyPrivilege(PrivilegeConstants.GET_USERS);
			
			// Send an alert to all administrators
			Context.getAlertService().notifySuperUsers("Module.startupError.notification.message", null, mod.getName());
		}
		finally {
			// Remove added privileges
			Context.removeProxyPrivilege(PrivilegeConstants.GET_USERS);
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
		}
	}
	
	/**
	 * This method will find and cache this module's servlets (so that it doesn't have to look them
	 * up every time)
	 *
	 * @param mod
	 * @param servletContext the servlet context
	 */
	public static void loadServlets(Module mod, ServletContext servletContext) {
		Element rootNode = mod.getConfig().getDocumentElement();
		NodeList servletTags = rootNode.getElementsByTagName("servlet");
		
		for (int i = 0; i < servletTags.getLength(); i++) {
			Node node = servletTags.item(i);
			NodeList childNodes = node.getChildNodes();
			String name = "", className = "";
			Map<String, String> initParams = new HashMap<>();
			for (int j = 0; j < childNodes.getLength(); j++) {
				Node childNode = childNodes.item(j);
				if ("servlet-name".equals(childNode.getNodeName())) {
					if (childNode.getTextContent() != null) {
						name = childNode.getTextContent().trim();
					}
				} else if ("servlet-class".equals(childNode.getNodeName()) && childNode.getTextContent() != null) {
					className = childNode.getTextContent().trim();
				} else if ("init-param".equals(childNode.getNodeName())) {
					NodeList initParamChildren = childNode.getChildNodes();
					String paramName = null, paramValue = null;
					for (int k = 0; k < initParamChildren.getLength(); k++) {
						Node initParamChild = initParamChildren.item(k);
						if ("param-name".equals(initParamChild.getNodeName()) && initParamChild.getTextContent() != null) {
							paramName = initParamChild.getTextContent().trim();
						} else if ("param-value".equals(initParamChild.getNodeName()) && initParamChild.getTextContent() != null) {
							paramValue = initParamChild.getTextContent().trim();
						}
					}
					if (paramName != null && paramValue != null) {
						initParams.put(paramName, paramValue);
					}
				}
			}
			if (name.length() == 0 || className.length() == 0) {
				log.warn("both 'servlet-name' and 'servlet-class' are required for the 'servlet' tag. Given '" + name
				        + "' and '" + className + "' for module " + mod.getName());
				continue;
			}
			
			HttpServlet httpServlet;
			try {
				httpServlet = (HttpServlet) ModuleFactory.getModuleClassLoader(mod).loadClass(className).newInstance();
			}
			catch (ClassCastException e) {
				log.warn("Class {} from module {} is not a valid HttpServlet", className, mod, e);
				continue;
			}
			catch (ClassNotFoundException e) {
				log.warn("Class {} not found for servlet {} from module {}", className, name, mod, e);
				continue;
			}
			catch (IllegalAccessException e) {
				log.warn("Class {} cannot be accessed for servlet {} from module {}", className, name, mod, e);
				continue;
			}
			catch (InstantiationException e) {
				log.warn("Class {} cannot be instantiated for servlet {} from module {}", className, name, mod, e);
				continue;
			}
			
			try {
				log.debug("Initializing {} servlet. - {}.", name, httpServlet);
				ServletConfig servletConfig = new ModuleServlet.SimpleServletConfig(name, servletContext, initParams);
				httpServlet.init(servletConfig);
			}
			catch (Exception e) {
				log.warn("Unable to initialize servlet {}", name, e);
				throw new ModuleException("Unable to initialize servlet " + name, mod.getModuleId(), e);
			}
			
			// don't allow modules to overwrite servlets of other modules.
			HttpServlet otherServletUsingSameName = MODULE_SERVLETS.get(name);
			if (otherServletUsingSameName != null) {
				String otherServletName = otherServletUsingSameName.getClass().getName();
				throw new ModuleException("A servlet mapping with name " + name + " is already in use and pointing at: "
				        + otherServletName + " from another installed module and this module is trying"
				        + " to use that same name.  Either the module attempting to be installed (" + mod
				        + ") will not work or the other one will not.  Please consult the developers of these two"
				        + " modules to sort this out.");
			}
			
			log.debug("Caching the {} servlet.", name);
			
			SERVLET_LOCK.lock();
			try {
				MODULE_SERVLETS.put(name, httpServlet);
			} finally {
				SERVLET_LOCK.unlock();
			}
		}
	}
	
	/**
	 * Remove the servlets defined for this module
	 *
	 * @param mod the module that is being stopped that needs its servlets removed
	 */
	public static void unloadServlets(Module mod) {
		Element rootNode = mod.getConfig().getDocumentElement();
		NodeList servletTags = rootNode.getElementsByTagName("servlet");
		
		for (int i = 0; i < servletTags.getLength(); i++) {
			Node node = servletTags.item(i);
			NodeList childNodes = node.getChildNodes();
			String name;
			for (int j = 0; j < childNodes.getLength(); j++) {
				Node childNode = childNodes.item(j);
				if ("servlet-name".equals(childNode.getNodeName()) && childNode.getTextContent() != null) {
					name = childNode.getTextContent().trim();
					
					HttpServlet servlet;
					SERVLET_LOCK.lock();
					try {
						servlet = MODULE_SERVLETS.get(name);
					} finally {
						SERVLET_LOCK.unlock();
					}
					
					if (servlet != null) {
						// shut down the servlet
						servlet.destroy();
					}
					
					SERVLET_LOCK.lock();
					try {
						MODULE_SERVLETS.remove(name);
					} finally {
						SERVLET_LOCK.unlock();
					}
				}
			}
		}
	}
	
	/**
	 * This method will initialize and store this module's filters
	 *
	 * @param module - The Module to load and register Filters
	 * @param servletContext - The servletContext within which this method is called
	 */
	public static void loadFilters(Module module, ServletContext servletContext) {
		
		// Load Filters
		Map<String, Filter> filters = new LinkedHashMap<>();
		
		Map<String, Filter> existingFilters;
		FILTERS_LOCK.lock();
		try {
			existingFilters = new HashMap<>(MODULE_FILTERS_BY_NAME);
		} finally {
			FILTERS_LOCK.unlock();
		}
		
		for (ModuleFilterDefinition def : ModuleFilterDefinition.retrieveFilterDefinitions(module)) {
			String name = def.getFilterName();
			String className = def.getFilterClass();
			
			if (existingFilters.containsKey(name)) {
				throw new ModuleException("A filter with the name " + name + " is already in use and pointing at: "
					+ existingFilters.get(name).getClass().getName()
					+ " from another installed module and this module is trying"
					+ " to use that same name.  Either the module attempting to be installed (" + module
					+ ") will not work or the other one will not.  Please consult the developers of these two"
					+ " modules to sort this out.");
			}
			
			ModuleFilterConfig config = ModuleFilterConfig.getInstance(def, servletContext);
			
			Filter filter;
			try {
				filter = (Filter) ModuleFactory.getModuleClassLoader(module).loadClass(className).newInstance();
			}
			catch (ClassCastException e) {
				log.warn("Class {} from module {} is not a valid Filter", className, module, e);
				continue;
			}
			catch (ClassNotFoundException e) {
				log.warn("Class {} not found for servlet {} from module {}", className, name, module, e);
				continue;
			}
			catch (IllegalAccessException e) {
				log.warn("Class {} cannot be accessed for servlet {} from module {}", className, name, module, e);
				continue;
			}
			catch (InstantiationException e) {
				log.warn("Class {} cannot be instantiated for servlet {} from module {}", className, name, module, e);
				continue;
			}
			
			try {
				log.debug("Initializing {} filter. - {}.", name, filter);
				filter.init(config);
			}
			catch (Exception e) {
				log.warn("Unable to initialize servlet {}", name, e);
				throw new ModuleException("Unable to initialize servlet " + name, module.getModuleId(), e);
			}
			
			filters.put(name, filter);
		}
		FILTERS_LOCK.lock();
		try {
			MODULE_FILTERS.put(module, filters.values());
			MODULE_FILTERS_BY_NAME.putAll(filters);
			log.debug("Module {} successfully loaded {} filters.", module, filters.size());
			
			// Load Filter Mappings
			Deque<ModuleFilterMapping> modMappings = ModuleFilterMapping.retrieveFilterMappings(module);
			
			// IMPORTANT: Filter load order
			// retrieveFilterMappings will return the list of filters in the order they occur in the config.xml file
			// here we add them to the *front* of the filter mappings
			modMappings.descendingIterator().forEachRemaining(MODULE_FILTER_MAPPINGS::addFirst);
			
			log.debug("Module {} successfully loaded {} filter mappings.", module, modMappings.size());
		} finally {
			FILTERS_LOCK.unlock();
		}
	}
	
	/**
	 * This method will destroy and remove all filters that were registered by the passed
	 * {@link Module}
	 *
	 * @param module - The Module for which you want to remove and destroy filters.
	 */
	public static void unloadFilters(Module module) {
		
		// Unload Filter Mappings
		for (Iterator<ModuleFilterMapping> mapIter = MODULE_FILTER_MAPPINGS.iterator(); mapIter.hasNext();) {
			ModuleFilterMapping mapping = mapIter.next();
			if (module.equals(mapping.getModule())) {
				mapIter.remove();
				log.debug("Removed ModuleFilterMapping: " + mapping);
			}
		}
		
		// unload Filters
		Collection<Filter> filters = MODULE_FILTERS.get(module);
		if (filters != null) {
			try {
				for (Filter f : filters) {
					f.destroy();
				}
			}
			catch (Exception e) {
				log.warn("An error occurred while trying to destroy and remove module Filter.", e);
			}
			
			log.debug("Module: " + module.getModuleId() + " successfully unloaded " + filters.size() + " filters.");
			MODULE_FILTERS.remove(module);
			MODULE_FILTERS_BY_NAME.values().removeIf(filters::contains);
		}
	}
	
	/**
	 * This method will return all Filters that have been registered a module
	 *
	 * @return A Collection of {@link Filter}s that have been registered by a module
	 */
	public static Collection<Filter> getFilters() {
		return MODULE_FILTERS_BY_NAME.values();
	}
	
	/**
	 * This method will return all Filter Mappings that have been registered by a module
	 *
	 * @return A Collection of all {@link ModuleFilterMapping}s that have been registered by a
	 *         Module
	 */
	public static Collection<ModuleFilterMapping> getFilterMappings() {
		return new ArrayList<>(MODULE_FILTER_MAPPINGS);
	}
	
	/**
	 * Return List of Filters that have been loaded through Modules that have mappings that pass for
	 * the passed request
	 *
	 * @param request - The request to check for matching {@link Filter}s
	 * @return List of all {@link Filter}s that have filter mappings that match the passed request
	 */
	public static List<Filter> getFiltersForRequest(ServletRequest request) {
		
		List<Filter> filters = new ArrayList<>();
		if (request != null) {
			HttpServletRequest httpRequest = (HttpServletRequest) request;
			String requestPath = httpRequest.getRequestURI();
			
			if (requestPath != null) {
				if (requestPath.startsWith(httpRequest.getContextPath())) {
					requestPath = requestPath.substring(httpRequest.getContextPath().length());
				}
				for (ModuleFilterMapping filterMapping : WebModuleUtil.getFilterMappings()) {
					if (ModuleFilterMapping.filterMappingPasses(filterMapping, requestPath)) {
						Filter passedFilter = MODULE_FILTERS_BY_NAME.get(filterMapping.getFilterName());
						if (passedFilter != null) {
							filters.add(passedFilter);
						} else {
							log.warn("Unable to retrieve filter that has a name of " + filterMapping.getFilterName()
							        + " in filter mapping.");
						}
					}
				}
			}
		}
		return filters;
	}
	
	/**
	 * @param inputStream
	 * @param realPath
	 * @return
	 */
	private static Document getDWRModuleXML(InputStream inputStream, String realPath) {
		Document dwrmodulexml;
		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder db = dbf.newDocumentBuilder();
			// When asked to resolve external entities (such as a DTD) we return an InputSource
			// with no data at the end, causing the parser to ignore the DTD.
			db.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader("")));
			dwrmodulexml = db.parse(inputStream);
		}
		catch (Exception e) {
			throw new ModuleException("Error parsing dwr-modules.xml file", e);
		}
		
		return dwrmodulexml;
	}
	
	/**
	 * Reverses all activities done by startModule(org.openmrs.module.Module) Normal stop/shutdown
	 * is done by ModuleFactory
	 */
	public static void shutdownModules(ServletContext servletContext) {
		
		String realPath = getRealPath(servletContext);
		
		// clear the module messages
		String messagesPath = realPath + "/WEB-INF/";
		File folder = new File(messagesPath.replace("/", File.separator));
		
		File[] files = folder.listFiles();
		if (folder.exists() && files != null) {
			Properties emptyProperties = new Properties();
			for (File f : files) {
				if (f.getName().startsWith("module_messages")) {
					OpenmrsUtil.storeProperties(emptyProperties, f, "");
				}
			}
		}
		
		// call web shutdown for each module
		for (Module mod : ModuleFactory.getLoadedModules()) {
			stopModule(mod, servletContext, true);
		}
		
	}
	
	/**
	 * Reverses all visible activities done by startModule(org.openmrs.module.Module)
	 *
	 * @param mod
	 * @param servletContext
	 */
	public static void stopModule(Module mod, ServletContext servletContext) {
		stopModule(mod, servletContext, false);
	}
	
	/**
	 * Reverses all visible activities done by startModule(org.openmrs.module.Module)
	 *
	 * @param mod
	 * @param servletContext
	 * @param skipRefresh
	 */
	public static void stopModule(Module mod, ServletContext servletContext, boolean skipRefresh) {
		
		String moduleId = mod.getModuleId();
		String modulePackage = mod.getPackageName();
		
		// stop all dependent modules
		for (Module dependentModule : ModuleFactory.getStartedModules()) {
			if (!dependentModule.equals(mod) && dependentModule.getRequiredModules().contains(modulePackage)) {
				stopModule(dependentModule, servletContext, skipRefresh);
			}
		}
		
		String realPath = getRealPath(servletContext);
		
		// delete the web files from the webapp
		String absPath = realPath + "/WEB-INF/view/module/" + moduleId;
		File moduleWebFolder = new File(absPath.replace("/", File.separator));
		if (moduleWebFolder.exists()) {
			try {
				OpenmrsUtil.deleteDirectory(moduleWebFolder);
			}
			catch (IOException io) {
				log.warn("Couldn't delete: " + moduleWebFolder.getAbsolutePath(), io);
			}
		}
		
		// (not) deleting module message properties
		
		// remove the module's servlets
		unloadServlets(mod);
		
		// remove the module's filters and filter mappings
		unloadFilters(mod);
		
		// stop all tasks associated with mod
		stopTasks(mod);
		
		// remove this module's entries in the dwr xml file
		InputStream inputStream = null;
		try {
			Document config = mod.getConfig();
			Element root = config.getDocumentElement();
			// if they defined any xml element
			if (root.getElementsByTagName("dwr").getLength() > 0) {
				
				// get the dwr-module.xml file that we're appending our code to
				File f = new File(realPath + "/WEB-INF/dwr-modules.xml".replace("/", File.separator));
				
				// testing if file exists
				if (!f.exists()) {
					// if it does not -> needs to be created
					createDwrModulesXml(realPath);
				}
				
				inputStream = new FileInputStream(f);
				Document dwrmodulexml = getDWRModuleXML(inputStream, realPath);
				Element outputRoot = dwrmodulexml.getDocumentElement();
				
				// loop over all of the children of the "dwr" tag
				// and remove all "allow" and "signature" tags that have the
				// same moduleId attr as the module being stopped
				NodeList nodeList = outputRoot.getChildNodes();
				int i = 0;
				while (i < nodeList.getLength()) {
					Node current = nodeList.item(i);
					if ("allow".equals(current.getNodeName()) || "signatures".equals(current.getNodeName())) {
						NamedNodeMap attrs = current.getAttributes();
						Node attr = attrs.getNamedItem("moduleId");
						if (attr != null && moduleId.equals(attr.getNodeValue())) {
							outputRoot.removeChild(current);
						} else {
							i++;
						}
					} else {
						i++;
					}
				}
				
				// save the dwr-modules.xml file.
				OpenmrsUtil.saveDocument(dwrmodulexml, f);
			}
		}
		catch (FileNotFoundException e) {
			throw new ModuleException(realPath + "/WEB-INF/dwr-modules.xml file doesn't exist.", e);
		}
		finally {
			if (inputStream != null) {
				try {
					inputStream.close();
				}
				catch (IOException io) {
					log.error("Error while closing input stream", io);
				}
			}
		}
		
		if (!skipRefresh) {	
			refreshWAC(servletContext, false, null);
		}
		
	}
	
	/**
	 * Stops, closes, and refreshes the Spring context for the given <code>servletContext</code>
	 *
	 * @param servletContext
	 * @param isOpenmrsStartup if this refresh is being done at application startup
	 * @param startedModule the module that was just started and waiting on the context refresh
	 * @return The newly refreshed webApplicationContext
	 */
	public static XmlWebApplicationContext refreshWAC(ServletContext servletContext, boolean isOpenmrsStartup,
	        Module startedModule) {
		XmlWebApplicationContext wac = (XmlWebApplicationContext) WebApplicationContextUtils
		        .getWebApplicationContext(servletContext);
		log.debug("Refreshing web application Context of class: {}", wac.getClass().getName());
		
		if (dispatcherServlet != null) {
			dispatcherServlet.stopAndCloseApplicationContext();
		}
		
		if (staticDispatcherServlet != null) {
			staticDispatcherServlet.stopAndCloseApplicationContext();
		}
		
		XmlWebApplicationContext newAppContext = (XmlWebApplicationContext) ModuleUtil.refreshApplicationContext(wac,
		    isOpenmrsStartup, startedModule);
		
		try {
			// must "refresh" the spring dispatcherservlet as well to add in
			//the new handlerMappings
			if (dispatcherServlet != null) {
				dispatcherServlet.reInitFrameworkServlet();
			}
			
			if (staticDispatcherServlet != null) {
				staticDispatcherServlet.refreshApplicationContext();
			}
		}
		catch (ServletException se) {
			log.warn("Caught a servlet exception while refreshing the dispatcher servlet", se);
		}
		
		return newAppContext;
	}
	
	/**
	 * Save the dispatcher servlet for use later (reinitializing things)
	 *
	 * @param ds
	 */
	public static void setDispatcherServlet(DispatcherServlet ds) {
		log.debug("Setting dispatcher servlet: " + ds);
		dispatcherServlet = ds;
	}
	
	/**
	 * Save the static content dispatcher servlet for use later when refreshing spring
	 *
	 * @param ds
	 */
	public static void setStaticDispatcherServlet(StaticDispatcherServlet ds) {
		log.debug("Setting dispatcher servlet for static content: " + ds);
		staticDispatcherServlet = ds;
	}
	
	/**
	 * Finds the servlet defined by the servlet name
	 *
	 * @param servletName the name of the servlet out of the path
	 * @return the current servlet or null if none defined
	 */
	public static HttpServlet getServlet(String servletName) {
		return MODULE_SERVLETS.get(servletName);
	}
	
	/**
	 * Retrieves a path to a folder that stores web files of a module. <br>
	 * (path-to-openmrs/WEB-INF/view/module/moduleid)
	 *
	 * @param moduleId module id (e.g., "basicmodule")
	 * @return a path to a folder that stores web files or null if not in a web environment
	 * <strong>Should</strong> return the correct module folder
	 * <strong>Should</strong> return null if the dispatcher servlet is not yet set
	 * <strong>Should</strong> return the correct module folder if real path has a trailing slash
	 */
	public static String getModuleWebFolder(String moduleId) {
		if (dispatcherServlet == null) {
			throw new ModuleException("Dispatcher servlet must be present in the web environment");
		}
		
		String moduleFolder = "WEB-INF/view/module/";
		String realPath = dispatcherServlet.getServletContext().getRealPath("");
		String moduleWebFolder;
		
		//RealPath may contain '/' on Windows when running tests with the mocked servlet context
		if (realPath.endsWith(File.separator) || realPath.endsWith("/")) {
			moduleWebFolder = realPath + moduleFolder;
		} else {
			moduleWebFolder = realPath + "/" + moduleFolder;
		}
		
		moduleWebFolder += moduleId;
		
		return moduleWebFolder.replace("/", File.separator);
	}
	
	public static void createDwrModulesXml(String realPath) {
		
		try {
			
			DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
			
			// root elements
			Document doc = docBuilder.newDocument();
			Element rootElement = doc.createElement("dwr");
			doc.appendChild(rootElement);
			
			// write the content into xml file
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			Transformer transformer = transformerFactory.newTransformer();
			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(realPath
			        + "/WEB-INF/dwr-modules.xml".replace("/", File.separator)));
			
			transformer.transform(source, result);
			
		}
		catch (ParserConfigurationException pce) {
			log.error("Failed to parse document", pce);
		}
		catch (TransformerException tfe) {
			log.error("Failed to transorm xml source", tfe);
		}
	}
	public static String getRealPath(ServletContext servletContext) {
		return servletContext.getRealPath("");
	}
	
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.web;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.web.WebModuleUtil;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.web.filter.initialization.InitializationFilter;
import org.openmrs.web.filter.update.UpdateFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeansException;
import org.springframework.web.context.support.XmlWebApplicationContext;
/**
 * This class is only used to get access to the DispatcherServlet. <br>
 * <br>
 * After creation, this object is saved to WebUtil for later use. When Spring's
 * webApplicationContext is refreshed, the DispatcherServlet needs to be refreshed too.
 * 
 * @see #reInitFrameworkServlet()
 */
public class DispatcherServlet extends org.springframework.web.servlet.DispatcherServlet {
	
	private static final long serialVersionUID = -6925172744402818729L;
	
	private static final Logger log = LoggerFactory.getLogger(DispatcherServlet.class);
	
	/**
	 * @see org.springframework.web.servlet.FrameworkServlet#initFrameworkServlet()
	 */
	@Override
	protected void initFrameworkServlet() throws ServletException, BeansException {
		// refresh the application context to look for module xml config files as well
		
		Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
		
		log.debug("Framework being initialized");
		WebModuleUtil.setDispatcherServlet(this);
		
		super.initFrameworkServlet();
	}
	
	/**
	 * Called by the ModuleUtil after adding in a new module. This needs to be called because the
	 * new mappings and advice that a new module adds in are cached by Spring's DispatcherServlet.
	 * This method will reload that cache.
	 * 
	 * @throws ServletException
	 */
	public void reInitFrameworkServlet() throws ServletException {
		log.debug("Framework being REinitialized");
		Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
		((XmlWebApplicationContext) getWebApplicationContext()).setClassLoader(OpenmrsClassLoader.getInstance());
		
		init();
		
		// the spring context gets reset by the framework servlet, so we need to 
		// reload the advice points that were lost when refreshing Spring
		for (Module module : ModuleFactory.getStartedModules()) {
			ModuleFactory.loadAdvice(module);
		}
	}
	
	/**
	 * @see javax.servlet.GenericServlet#init(javax.servlet.ServletConfig)
	 */
	@Override
	public void init(ServletConfig config) throws ServletException {
		super.init(config);
		
		// hacky way to know if one of the startup filters needs to be run
		if (UpdateFilter.updatesRequired() && !DatabaseUpdater.allowAutoUpdate()) {
			log.info("DB updates are required, the update wizard must be run");
		}
		if (InitializationFilter.initializationRequired()) {
			log.info("Runtime properties were not found or the database is empty, so initialization is required");
		}
	}
	
	/**
	 * Stops and closes the application context created by this dispatcher servlet.
	 */
	public void stopAndCloseApplicationContext() {
		try {
			XmlWebApplicationContext ctx = (XmlWebApplicationContext) getWebApplicationContext();
			ctx.stop();
			ctx.close();
		}
		catch (Exception e) {
			log.error("Exception while stopping and closing dispatcherServlet context: ", e);
		}
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module.web;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleUtil;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class ModuleResourcesServlet extends HttpServlet {
	
	private static final String MODULE_PATH = "/WEB-INF/view/module/";
	
	private static final long serialVersionUID = 1239820102030344L;
	
	private static final Logger log = LoggerFactory.getLogger(ModuleResourcesServlet.class);
	
	/**
	 * Used for caching purposes
	 *
	 * @see javax.servlet.http.HttpServlet#getLastModified(javax.servlet.http.HttpServletRequest)
	 */
	@Override
	protected long getLastModified(HttpServletRequest req) {
		File f = getFile(req);
		
		if (f == null) {
			return super.getLastModified(req);
		}
		
		return f.lastModified();
	}
	
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		log.debug("In service method for module servlet: " + request.getPathInfo());
		
		File f = getFile(request);
		if (f == null) {
			response.setStatus(HttpServletResponse.SC_NOT_FOUND);
			return;
		}
		
		response.setDateHeader("Last-Modified", f.lastModified());
		response.setContentLength(Long.valueOf(f.length()).intValue());
		String mimeType = getServletContext().getMimeType(f.getName());
		response.setContentType(mimeType);
		
		FileInputStream is = new FileInputStream(f);
		try {
			OpenmrsUtil.copyFile(is, response.getOutputStream());
		}
		finally {
			OpenmrsUtil.closeStream(is);
		}
	}
	
	/**
	 * Turns the given request/path into a File object
	 *
	 * @param request the current http request
	 * @return the file being requested or null if not found
	 */
	protected File getFile(HttpServletRequest request) {
		
		String path = request.getPathInfo();
		
		Module module = ModuleUtil.getModuleForPath(path);
		if (module == null) {
			log.warn("No module handles the path: " + path);
			return null;
		}
		
		String relativePath = ModuleUtil.getPathForResource(module, path);
		String realPath = getServletContext().getRealPath("") + MODULE_PATH + module.getModuleIdAsPath() + "/resources"
		        + relativePath;
		
		//if in dev mode, load resources from the development directory
		File devDir = ModuleUtil.getDevelopmentDirectory(module.getModuleId());
		if (devDir != null) {
			realPath = devDir.getAbsolutePath() + "/omod/target/classes/web/module/resources" + relativePath;
		}
		
		realPath = realPath.replace("/", File.separator);
		
		File f = new File(realPath);
		if (!f.exists()) {
			log.warn("No file with path '" + realPath + "' exists for module '" + module.getModuleId() + "'");
			return null;
		}
		
		return f;
	}
	
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.web;
import org.apache.logging.log4j.LogManager;
import org.openmrs.api.context.Context;
import org.openmrs.logging.OpenmrsLoggingUtil;
import org.openmrs.module.MandatoryModuleException;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.ModuleMustStartException;
import org.openmrs.module.OpenmrsCoreModuleException;
import org.openmrs.module.web.OpenmrsJspServlet;
import org.openmrs.module.web.WebModuleUtil;
import org.openmrs.scheduler.SchedulerUtil;
import org.openmrs.util.DatabaseUpdateException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.MemoryLeakUtil;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.web.filter.initialization.DatabaseDetective;
import org.openmrs.web.filter.initialization.InitializationFilter;
import org.openmrs.web.filter.update.UpdateFilter;
import org.owasp.csrfguard.CsrfGuard;
import org.owasp.csrfguard.CsrfGuardServletContextListener;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;
import org.springframework.beans.factory.BeanCreationException;
import org.springframework.util.StringUtils;
import org.springframework.web.context.ContextLoader;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.XmlWebApplicationContext;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.ServletException;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.StringReader;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Driver;
import java.sql.DriverManager;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
/**
 * Our Listener class performs the basic starting functions for our webapp. Basic needs for starting
 * the API: 1) Get the runtime properties 2) Start Spring 3) Start the OpenMRS APi (via
 * Context.startup) Basic startup needs specific to the web layer: 1) Do the web startup of the
 * modules 2) Copy the custom look/images/messages over into the web layer
 */
public final class Listener extends ContextLoader implements ServletContextListener, HttpSessionListener {
	
	private static final org.slf4j.Logger log = LoggerFactory.getLogger(Listener.class);
	
	private static boolean runtimePropertiesFound = false;
	
	private static Throwable errorAtStartup = null;
	
	private static boolean setupNeeded = false;
	
	private static boolean openmrsStarted = false;
	
	/**
	 * Boolean flag set on webapp startup marking whether there is a runtime properties file or not.
	 * If there is not, then the {@link InitializationFilter} takes over any openmrs url and
	 * redirects to the {@link WebConstants#SETUP_PAGE_URL}
	 *
	 * @return true/false whether an openmrs runtime properties file is defined
	 */
	public static boolean runtimePropertiesFound() {
		return runtimePropertiesFound;
	}
	
	/**
	 * Boolean flag set by the {@link #contextInitialized(ServletContextEvent)} method if an error
	 * occurred when trying to start up. The StartupErrorFilter displays the error to the admin
	 *
	 * @return true/false if an error occurred when starting up
	 */
	public static boolean errorOccurredAtStartup() {
		return errorAtStartup != null;
	}
	
	/**
	 * Boolean flag that tells if we need to run the database setup wizard.
	 *
	 * @return true if setup is needed, else false.
	 */
	public static boolean isSetupNeeded() {
		return setupNeeded;
	}
	
	/**
	 * Boolean flag that tells if OpenMRS is started and ready to handle requests via REST.
	 *
	 * @return true if started, else false.
	 */
	public static boolean isOpenmrsStarted() {
		return openmrsStarted;
	}
	
	/**
	 * Get the error thrown at startup
	 *
	 * @return get the error thrown at startup
	 */
	public static Throwable getErrorAtStartup() {
		return errorAtStartup;
	}
	
	public static void setRuntimePropertiesFound(boolean runtimePropertiesFound) {
		Listener.runtimePropertiesFound = runtimePropertiesFound;
	}
	
	public static void setErrorAtStartup(Throwable errorAtStartup) {
		Listener.errorAtStartup = errorAtStartup;
	}
	/**
	 * This gets all Spring components that implement HttpSessionListener 
	 * and passes the HttpSession event to them whenever an HttpSession is created
	 * @see HttpSessionListener#sessionCreated(HttpSessionEvent) 
	 */
	@Override
	public void sessionCreated(HttpSessionEvent se) {
		for (HttpSessionListener listener : getHttpSessionListeners()) {
			listener.sessionCreated(se);
		}
	}
	/**
	 * 	This gets all Spring components that implement HttpSessionListener 
	 * 	and passes the HttpSession event to them whenever an HttpSession is destroyed
	 * @see HttpSessionListener#sessionDestroyed(HttpSessionEvent)
	 */
	@Override
	public void sessionDestroyed(HttpSessionEvent se) {
		for (HttpSessionListener listener : getHttpSessionListeners()) {
			listener.sessionDestroyed(se);
		}
	}
	/**
	 * 	This retrieves all Spring components that implement HttpSessionListener
	 * 	If an exception is thrown trying to retrieve these beans from the Context, a warning is logged
	 * @see HttpSessionListener#sessionDestroyed(HttpSessionEvent)
	 */
	private List<HttpSessionListener> getHttpSessionListeners() {
		List<HttpSessionListener> httpSessionListeners = Collections.emptyList();
		
		if (openmrsStarted) {
			try {
				httpSessionListeners = Context.getRegisteredComponents(HttpSessionListener.class);
			}
			catch (Exception e) {
				log.warn("An error occurred trying to retrieve HttpSessionListener beans from the context", e);
			}
		}
		
		return httpSessionListeners;
	}
	/**
	 * This method is called when the servlet context is initialized(when the Web Application is
	 * deployed). You can initialize servlet context related data here.
	 *
	 * @param event
	 */
	@Override
	public void contextInitialized(ServletContextEvent event) {
		log.debug("Starting the OpenMRS webapp");
		
		try {
			// validate the current JVM version
			OpenmrsUtil.validateJavaVersion();
			
			ServletContext servletContext = event.getServletContext();
			
			// pulled from web.xml.
			loadConstants(servletContext);
			
			// erase things in the dwr file
			clearDWRFile(servletContext);
			
			setApplicationDataDirectory(servletContext);
			
			
			// Try to get the runtime properties
			Properties props = getRuntimeProperties();
			if (props != null) {
				// the user has defined a runtime properties file
				setRuntimePropertiesFound(true);
				// set props to the context so that they can be
				// used during sessionFactory creation
				Context.setRuntimeProperties(props);
				
				String appDataRuntimeProperty = props
				        .getProperty(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_RUNTIME_PROPERTY, null);
				if (StringUtils.hasLength(appDataRuntimeProperty)) {
					OpenmrsUtil.setApplicationDataDirectory(null);
				}
				
				//ensure that we always log the runtime properties file that we are using
				//since openmrs is just booting, the log levels are not yet set. TRUNK-4835
				OpenmrsLoggingUtil.applyLogLevel(getClass().toString(), "INFO");
				log.info("Using runtime properties file: {}",
				         OpenmrsUtil.getRuntimePropertiesFilePathName(WebConstants.WEBAPP_NAME));
			}
			loadCsrfGuardProperties(servletContext);
			
			Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
			
			if (!setupNeeded()) {
				// must be done after the runtime properties are
				// found but before the database update is done
				copyCustomizationIntoWebapp(servletContext, props);
				
				/**
				 * This logic is from ContextLoader.initWebApplicationContext. Copied here instead
				 * of calling that so that the context is not cached and hence not garbage collected
				 */
				XmlWebApplicationContext context = (XmlWebApplicationContext) createWebApplicationContext(servletContext);
				configureAndRefreshWebApplicationContext(context, servletContext);
				servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);
				
				WebDaemon.startOpenmrs(event.getServletContext());
			} else {
				setupNeeded = true;
			}
			
		}
		catch (Exception e) {
			setErrorAtStartup(e);
			log.error(MarkerFactory.getMarker("FATAL"), "Failed to obtain JDBC connection", e);
		}
	}
	private void loadCsrfGuardProperties(ServletContext servletContext) throws IOException {
		File csrfGuardFile = new File(OpenmrsUtil.getApplicationDataDirectory(), "csrfguard.properties");
		Properties csrfGuardProperties = new Properties();
		if (csrfGuardFile.exists()) {
			try (InputStream csrfGuardInputStream = Files.newInputStream(csrfGuardFile.toPath())) {
				csrfGuardProperties.load(csrfGuardInputStream);
			}
			catch (Exception e) {
				log.error("Error loading csrfguard.properties file at " + csrfGuardFile.getAbsolutePath(), e);
				throw e;
			}
		}
		else {
			String fileName = servletContext.getRealPath("/WEB-INF/csrfguard.properties");
			try (InputStream csrfGuardInputStream = Files.newInputStream(Paths.get(fileName))) {
				csrfGuardProperties.load(csrfGuardInputStream);
			}
			catch (Exception e) {
				log.error("Error loading csrfguard.properties file at " +  fileName, e);
				throw e;
			}
		}
		
		Properties runtimeProperties = getRuntimeProperties();
		if (runtimeProperties != null) {
			runtimeProperties.stringPropertyNames().forEach(property -> {
				if (property.startsWith("org.owasp.csrfguard")) {
					csrfGuardProperties.setProperty(property, runtimeProperties.getProperty(property));
				}
			});	
		}
		
		CsrfGuard.load(csrfGuardProperties);
		
		try {
			//CSRFGuard by default loads properties using CsrfGuardServletContextListener
			//which sets the servlet context path to be used during variable substitution of
			//%servletContext% in the properties file.
			Field field = CsrfGuardServletContextListener.class.getDeclaredField("servletContext");
			field.setAccessible(true);
			field.set(null, servletContext.getContextPath());
		}
		catch (Exception ex) {
			log.error("Failed to set the CSRFGuard servlet context", ex);
		}
	}
	
	/**
	 * This method knows about all the filters that openmrs uses for setup. Currently those are the
	 * {@link InitializationFilter} and the {@link UpdateFilter}. If either of these have to do
	 * something, openmrs won't start in this Listener.
	 *
	 * @return true if one of the filters needs to take some action
	 */
	private boolean setupNeeded() throws Exception {
		if (!runtimePropertiesFound) {
			return true;
		}
		
		DatabaseDetective databaseDetective = new DatabaseDetective();
		if (databaseDetective.isDatabaseEmpty(OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME))) {
			return true;
		}
		
		return DatabaseUpdater.updatesRequired() && !DatabaseUpdater.allowAutoUpdate();
	}
	
	/**
	 * Do the work of starting openmrs.
	 *
	 * @param servletContext
	 * @throws ServletException
	 */
	public static void startOpenmrs(ServletContext servletContext) throws ServletException {
		openmrsStarted = false;
		// start openmrs
		try {
			// load bundled modules that are packaged into the webapp
			Listener.loadBundledModules(servletContext);
			
			Context.startup(getRuntimeProperties());
		}
		catch (DatabaseUpdateException | InputRequiredException updateEx) {
			throw new ServletException("Should not be here because updates were run previously", updateEx);
		}
		catch (MandatoryModuleException mandatoryModEx) {
			throw new ServletException(mandatoryModEx);
		}
		catch (OpenmrsCoreModuleException coreModEx) {
			// don't wrap this error in a ServletException because we want to deal with it differently
			// in the StartupErrorFilter class
			throw coreModEx;
		}
		
		// TODO catch openmrs errors here and drop the user back out to the setup screen
		
		try {
			
			// web load modules
			Listener.performWebStartOfModules(servletContext);
			
			// start the scheduled tasks
			SchedulerUtil.startup(getRuntimeProperties());
		}
		catch (Exception t) {
			Context.shutdown();
			WebModuleUtil.shutdownModules(servletContext);
			throw new ServletException(t);
		}
		finally {
			Context.closeSession();
		}
		openmrsStarted = true;
	}
	
	/**
	 * Load the openmrs constants with values from web.xml init parameters
	 *
	 * @param servletContext startup context (web.xml)
	 */
	private void loadConstants(ServletContext servletContext) {
		WebConstants.BUILD_TIMESTAMP = servletContext.getInitParameter("build.timestamp");
		WebConstants.WEBAPP_NAME = getContextPath(servletContext);
		WebConstants.MODULE_REPOSITORY_URL = servletContext.getInitParameter("module.repository.url");
		
		if (!"openmrs".equalsIgnoreCase(WebConstants.WEBAPP_NAME)) {
			OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY = WebConstants.WEBAPP_NAME
			        + "_APPLICATION_DATA_DIRECTORY";
		}
	}
	
	private void setApplicationDataDirectory(ServletContext servletContext) {
		// note: the below value will be overridden after reading the runtime properties if the
		// "application_data_directory" runtime property is set
		String appDataDir = servletContext.getInitParameter("application.data.directory");
		if (StringUtils.hasLength(appDataDir)) {
			OpenmrsUtil.setApplicationDataDirectory(appDataDir);
		} else if (!"openmrs".equalsIgnoreCase(WebConstants.WEBAPP_NAME)) {
			OpenmrsUtil.setApplicationDataDirectory(
			    Paths.get(OpenmrsUtil.getApplicationDataDirectory(), WebConstants.WEBAPP_NAME).toString());
		}
	}
	
	/**
	 * @return current contextPath of this webapp without initial slash
	 */
	private String getContextPath(ServletContext servletContext) {
		// Get the context path without the request.
		String contextPath = servletContext.getContextPath();
		
		// trim off initial slash if it exists
		if (contextPath.startsWith("/")) {
			contextPath = contextPath.substring(1);
		}
		
		return contextPath;
	}
	
	/**
	 * Convenience method to empty out the dwr-modules.xml file to fix any errors that might have
	 * occurred in it when loading or unloading modules.
	 *
	 * @param servletContext
	 */
	private void clearDWRFile(ServletContext servletContext) {
		File dwrFile = Paths.get(servletContext.getRealPath(""), "WEB-INF", "dwr-modules.xml").toFile();
		
		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder db = dbf.newDocumentBuilder();
			// When asked to resolve external entities (such as a DTD) we return an InputSource
			// with no data at the end, causing the parser to ignore the DTD.
			db.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader("")));
			Document doc = db.parse(dwrFile);
			Element elem = doc.getDocumentElement();
			elem.setTextContent("");
			OpenmrsUtil.saveDocument(doc, dwrFile);
		}
		catch (Exception e) {
			// got here because the dwr-modules.xml file is empty for some reason.  This might
			// happen because the servlet container (i.e. tomcat) crashes when first loading this file
			log.debug("Error clearing dwr-modules.xml", e);
			dwrFile.delete();
			OutputStreamWriter writer = null;
			try {
				writer = new OutputStreamWriter(new FileOutputStream(dwrFile), StandardCharsets.UTF_8);
				writer.write(
				    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE dwr PUBLIC \"-//GetAhead Limited//DTD Direct Web Remoting 2.0//EN\" \"http://directwebremoting.org/schema/dwr20.dtd\">\n<dwr></dwr>");
			}
			catch (IOException io) {
				log.error(
				    "Unable to clear out the " + dwrFile.getAbsolutePath() + " file.  Please redeploy the openmrs war file",
				    io);
			}
			finally {
				if (writer != null) {
					try {
						writer.close();
					}
					catch (IOException io) {
						log.warn("Couldn't close Writer: " + io);
					}
				}
			}
		}
	}
	
	/**
	 * Copy the customization scripts over into the webapp
	 *
	 * @param servletContext
	 */
	private void copyCustomizationIntoWebapp(ServletContext servletContext, Properties props) {
		String realPath = servletContext.getRealPath("");
		// TODO centralize map to WebConstants?
		Map<String, String> custom = new HashMap<>();
		custom.put("custom.template.dir", "/WEB-INF/template");
		custom.put("custom.index.jsp.file", "/WEB-INF/view/index.jsp");
		custom.put("custom.login.jsp.file", "/WEB-INF/view/login.jsp");
		custom.put("custom.patientDashboardForm.jsp.file", "/WEB-INF/view/patientDashboardForm.jsp");
		custom.put("custom.images.dir", "/images");
		custom.put("custom.style.css.file", "/style.css");
		custom.put("custom.messages", "/WEB-INF/custom_messages.properties");
		custom.put("custom.messages_fr", "/WEB-INF/custom_messages_fr.properties");
		custom.put("custom.messages_es", "/WEB-INF/custom_messages_es.properties");
		custom.put("custom.messages_de", "/WEB-INF/custom_messages_de.properties");
		
		for (Map.Entry<String, String> entry : custom.entrySet()) {
			String prop = entry.getKey();
			String webappPath = entry.getValue();
			String userOverridePath = props.getProperty(prop);
			// if they defined the variable
			if (userOverridePath != null) {
				String absolutePath = realPath + webappPath;
				File file = new File(userOverridePath);
				
				// if they got the path correct
				// also, if file does not start with a "." (hidden files, like SVN files)
				if (file.exists() && !userOverridePath.startsWith(".")) {
					log.debug("Overriding file: " + absolutePath);
					log.debug("Overriding file with: " + userOverridePath);
					if (file.isDirectory()) {
						File[] files = file.listFiles();
						if (files != null) {
							for (File f : files) {
								userOverridePath = f.getAbsolutePath();
								if (!f.getName().startsWith(".")) {
									String tmpAbsolutePath = absolutePath + "/" + f.getName();
									if (!copyFile(userOverridePath, tmpAbsolutePath)) {
										log.warn("Unable to copy file in folder defined by runtime property: " + prop);
										log.warn("Your source directory (or a file in it) '" + userOverridePath
													+ " cannot be loaded or destination '" + tmpAbsolutePath + "' cannot be found");
									}
								}
							}
						}
					} else {
						// file is not a directory
						if (!copyFile(userOverridePath, absolutePath)) {
							log.warn("Unable to copy file defined by runtime property: " + prop);
							log.warn("Your source file '" + userOverridePath + " cannot be loaded or destination '"
							        + absolutePath + "' cannot be found");
						}
					}
				}
			}
			
		}
	}
	
	/**
	 * Copies file pointed to by <code>fromPath</code> to <code>toPath</code>
	 *
	 * @param fromPath
	 * @param toPath
	 * @return true/false whether the copy was a success
	 */
	private boolean copyFile(String fromPath, String toPath) {
		FileInputStream inputStream = null;
		FileOutputStream outputStream = null;
		try {
			inputStream = new FileInputStream(fromPath);
			outputStream = new FileOutputStream(toPath);
			OpenmrsUtil.copyFile(inputStream, outputStream);
		}
		catch (IOException io) {
			return false;
		}
		finally {
			try {
				if (inputStream != null) {
					inputStream.close();
				}
			}
			catch (IOException io) {
				log.warn("Unable to close input stream", io);
			}
			try {
				if (outputStream != null) {
					outputStream.close();
				}
			}
			catch (IOException io) {
				log.warn("Unable to close input stream", io);
			}
		}
		return true;
	}
	
	/**
	 * Load the pre-packaged modules from web/WEB-INF/bundledModules. <br>
	 * <br>
	 * This method assumes that the api startup() and WebModuleUtil.startup() will be called later
	 * for modules that loaded here
	 *
	 * @param servletContext the current servlet context for the webapp
	 */
	public static void loadBundledModules(ServletContext servletContext) {
		File folder = Paths.get(servletContext.getRealPath(""), "WEB-INF", "bundledModules").toFile();
		
		if (!folder.exists()) {
			log.warn("Bundled module folder doesn't exist: " + folder.getAbsolutePath());
			return;
		}
		if (!folder.isDirectory()) {
			log.warn("Bundled module folder isn't really a directory: " + folder.getAbsolutePath());
			return;
		}
		
		// loop over the modules and load the modules that we can
		File[] files = folder.listFiles();
		if (files != null) {
			for (File f : files) {
				if (!f.getName().startsWith(".")) { // ignore .svn folder and the like
					try {
						Module mod = ModuleFactory.loadModule(f);
						log.debug("Loaded bundled module: " + mod + " successfully");
					}
					catch (Exception e) {
						log.warn("Error while trying to load bundled module " + f.getName() + "", e);
					}
				}
			}
		}
	}
	
	/**
	 * Called when the webapp is shut down properly Must call Context.shutdown() and then shutdown
	 * all the web layers of the modules
	 *
	 * @see org.springframework.web.context.ContextLoaderListener#contextDestroyed(javax.servlet.ServletContextEvent)
	 */
	@SuppressWarnings("squid:S1215")
	@Override
	public void contextDestroyed(ServletContextEvent event) {
		
		try {
			openmrsStarted = false;
			Context.openSession();
			
			Context.shutdown();
			
			WebModuleUtil.shutdownModules(event.getServletContext());
			
		}
		catch (Exception e) {
			// don't print the unhelpful "contextDAO is null" message
			if (!"contextDAO is null".equals(e.getMessage())) {
				// not using log.error here so it can be garbage collected
				System.out.println("Listener.contextDestroyed: Error while shutting down openmrs: ");
				log.error("Listener.contextDestroyed: Error while shutting down openmrs: ", e);
			}
		}
		finally {
			if ("true".equalsIgnoreCase(System.getProperty("FUNCTIONAL_TEST_MODE"))) {
				//Delete the temporary file created for functional testing and shutdown the mysql daemon
				String filename = WebConstants.WEBAPP_NAME + "-test-runtime.properties";
				File file = new File(OpenmrsUtil.getApplicationDataDirectory(), filename);
				System.out.println(filename + " delete=" + file.delete());
				
			}
			// remove the user context that we set earlier
			Context.closeSession();
		}
		try {
			for (Enumeration<Driver> e = DriverManager.getDrivers(); e.hasMoreElements();) {
				Driver driver = e.nextElement();
				ClassLoader classLoader = driver.getClass().getClassLoader();
				// only unload drivers for this webapp
				if (classLoader == null || classLoader == getClass().getClassLoader()) {
					DriverManager.deregisterDriver(driver);
				} else {
					System.err.println("Didn't remove driver class: " + driver.getClass() + " with classloader of: "
					        + driver.getClass().getClassLoader());
				}
			}
		}
		catch (Exception e) {
			System.err.println("Listener.contextDestroyed: Failed to cleanup drivers in webapp");
			log.error("Listener.contextDestroyed: Failed to cleanup drivers in webapp", e);
		}
		
		MemoryLeakUtil.shutdownMysqlCancellationTimer();
		
		OpenmrsClassLoader.onShutdown();
		
		LogManager.shutdown();
		
		// just to make things nice and clean.
		// Suppressing sonar issue squid:S1215
		System.gc();
		System.gc();
	}
	
	/**
	 * Finds and loads the runtime properties
	 *
	 * @return Properties
	 * @see OpenmrsUtil#getRuntimeProperties(String)
	 */
	public static Properties getRuntimeProperties() {
		return OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME);
	}
	
	/**
	 * Call WebModuleUtil.startModule on each started module
	 *
	 * @param servletContext
	 * @throws ModuleMustStartException if the context cannot restart due to a
	 *             {@link MandatoryModuleException} or {@link OpenmrsCoreModuleException}
	 */
	public static void performWebStartOfModules(ServletContext servletContext) throws ModuleMustStartException, Exception {
		List<Module> startedModules = new ArrayList<>(ModuleFactory.getStartedModules());
		performWebStartOfModules(startedModules, servletContext);
	}
	
	public static void performWebStartOfModules(Collection<Module> startedModules, ServletContext servletContext)
	        throws ModuleMustStartException, Exception {
		
		boolean someModuleNeedsARefresh = false;
		for (Module mod : startedModules) {
			try {
				boolean thisModuleCausesRefresh = WebModuleUtil.startModule(mod, servletContext,
				    /* delayContextRefresh */true);
				someModuleNeedsARefresh = someModuleNeedsARefresh || thisModuleCausesRefresh;
			}
			catch (Exception e) {
				mod.setStartupErrorMessage("Unable to start module", e);
			}
		}
		
		if (someModuleNeedsARefresh) {
			try {
				WebModuleUtil.refreshWAC(servletContext, true, null);
			}
			catch (ModuleMustStartException | BeanCreationException ex) {
				// pass this up to the calling method so that openmrs loading stops
				throw ex;
			}
			catch (Exception e) {
				Throwable rootCause = getActualRootCause(e, true);
				if (rootCause != null) {
					log.error(MarkerFactory.getMarker("FATAL"),
					    "Unable to refresh the spring application context.  Root Cause was:", rootCause);
				} else {
					log.error(MarkerFactory.getMarker("FATAL"),
					    "nable to refresh the spring application context. Unloading all modules,  Error was:", e);
				}
				
				try {
					WebModuleUtil.shutdownModules(servletContext);
					for (Module mod : ModuleFactory.getLoadedModules()) {// use loadedModules to avoid a concurrentmodificationexception
						if (!mod.isCoreModule() && !mod.isMandatory()) {
							try {
								ModuleFactory.stopModule(mod, true, true);
							}
							catch (Exception t3) {
								// just keep going if we get an error shutting down.  was probably caused by the module
								// that actually got us to this point!
								log.trace("Unable to shutdown module:" + mod, t3);
							}
						}
					}
					WebModuleUtil.refreshWAC(servletContext, true, null);
				}
				catch (MandatoryModuleException ex) {
					// pass this up to the calling method so that openmrs loading stops
					throw new MandatoryModuleException(ex.getModuleId(), "Got an error while starting a mandatory module: "
					        + e.getMessage() + ". Check the server logs for more information");
				}
				catch (Exception t2) {
					// a mandatory or core module is causing spring to fail to start up.  We don't want those
					// stopped so we must report this error to the higher authorities
					log.warn("caught another error: ", t2);
					throw t2;
				}
			}
		}
		
		// because we delayed the refresh, we need to load+start all servlets and filters now
		// (this is to protect servlets/filters that depend on their module's spring xml config being available)
		for (Module mod : ModuleFactory.getStartedModulesInOrder()) {
			WebModuleUtil.loadServlets(mod, servletContext);
			WebModuleUtil.loadFilters(mod, servletContext);
		}
		servletContext.setAttribute(OpenmrsJspServlet.OPENMRS_TLD_SCAN_NEEDED, true);
	}
	
	/**
	 * Convenience method that recursively attempts to pull the root case from a Throwable
	 *
	 * @param t the Throwable object
	 * @param isOriginalError specifies if the passed in Throwable is the original Exception that
	 *            was thrown
	 * @return the root cause if any was found
	 */
	private static Throwable getActualRootCause(Throwable t, boolean isOriginalError) {
		if (t.getCause() != null) {
			return getActualRootCause(t.getCause(), false);
		}
		
		if (!isOriginalError) {
			return t;
		}
		
		return null;
	}
	
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.module;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.util.List;
import java.util.ArrayList;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.jar.JarFile;
import java.util.zip.ZipEntry;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
/**
 * This class will parse an xml sql diff file
 *
 * @version 1.0
 */
public class SqlDiffFileParser {
	private SqlDiffFileParser() {
	}
	
	private static final Logger log = LoggerFactory.getLogger(SqlDiffFileParser.class);
	
	private static final String SQLDIFF_CHANGELOG_FILENAME = "sqldiff.xml";
	
	/**
	 * Get the diff map. Return a sorted map&lt;version, sql statements&gt;
	 *
	 * @return SortedMap&lt;String, String&gt;
	 * @throws ModuleException
	 */
	public static SortedMap<String, String> getSqlDiffs(Module module) throws ModuleException {
		if (module == null) {
			throw new ModuleException("Module cannot be null");
		}
		
		SortedMap<String, String> map = new TreeMap<>(new VersionComparator());
		
		InputStream diffStream;
		
		// get the diff stream
		JarFile jarfile = null;
		try {
			try {
				jarfile = new JarFile(module.getFile());
			}
			catch (IOException e) {
				throw new ModuleException("Unable to get jar file", module.getName(), e);
			}
			
			diffStream = ModuleUtil.getResourceFromApi(jarfile, module.getModuleId(), module.getVersion(),
			    SQLDIFF_CHANGELOG_FILENAME);
			if (diffStream == null) {
				// Try the old way. Loading from the root of the omod
				ZipEntry diffEntry = jarfile.getEntry(SQLDIFF_CHANGELOG_FILENAME);
				if (diffEntry == null) {
					log.debug("No sqldiff.xml found for module: " + module.getName());
					return map;
				} else {
					try {
						diffStream = jarfile.getInputStream(diffEntry);
					}
					catch (IOException e) {
						throw new ModuleException("Unable to get sql diff file stream", module.getName(), e);
					}
				}
			}
			
			try {
				// turn the diff stream into an xml document
				Document diffDoc;
				try {
					DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
					DocumentBuilder db = dbf.newDocumentBuilder();
					// When asked to resolve external entities (such as a DTD) we return an InputSource
					// with no data at the end, causing the parser to ignore the DTD.
					db.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader("")));
					diffDoc = db.parse(diffStream);
				}
				catch (Exception e) {
					throw new ModuleException("Error parsing diff sqldiff.xml file", module.getName(), e);
				}
				
				Element rootNode = diffDoc.getDocumentElement();
				
				String diffVersion = rootNode.getAttribute("version");
				
				if (!validConfigVersions().contains(diffVersion)) {
					throw new ModuleException("Invalid config version: " + diffVersion, module.getModuleId());
				}
				
				NodeList diffNodes = getDiffNodes(rootNode, diffVersion);
				
				if (diffNodes != null && diffNodes.getLength() > 0) {
					int i = 0;
					while (i < diffNodes.getLength()) {
						Element el = (Element) diffNodes.item(i++);
						String version = getElement(el, diffVersion, "version");
						String sql = getElement(el, diffVersion, "sql");
						map.put(version, sql);
					}
				}
			}
			catch (ModuleException e) {
				if (diffStream != null) {
					try {
						diffStream.close();
					}
					catch (IOException io) {
						log.error("Error while closing config stream for module: " + module.getModuleId(), io);
					}
				}
				
				// rethrow the moduleException
				throw e;
			}
			
		}
		finally {
			try {
				if (jarfile != null) {
					jarfile.close();
				}
			}
			catch (IOException e) {
				log.warn("Unable to close jarfile: " + jarfile.getName());
			}
		}
		return map;
	}
	
	/**
	 * Generic method to get a module tag
	 *
	 * @param element
	 * @param version
	 * @param tag
	 * @return
	 */
	private static String getElement(Element element, String version, String tag) {
		if (element.getElementsByTagName(tag).getLength() > 0) {
			return element.getElementsByTagName(tag).item(0).getTextContent();
		}
		return "";
	}
	
	/**
	 * List of the valid sqldiff versions
	 *
	 * @return
	 */
	private static List<String> validConfigVersions() {
		List<String> versions = new ArrayList<>();
		versions.add("1.0");
		return versions;
	}
	
	/**
	 * Finds the nodes that contain diff information
	 *
	 * @param element
	 * @param version
	 * @return
	 */
	private static NodeList getDiffNodes(Element element, String version) {
		NodeList diffNodes = null;
		
		if ("1.0".equals(version)) {
			diffNodes = element.getElementsByTagName("diff");
		}
		
		return diffNodes;
	}
	
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.annotation;
import java.io.IOException;
import java.util.Map;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.ModuleUtil;
import org.openmrs.util.OpenmrsConstants;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;
import org.springframework.core.type.filter.TypeFilter;
/**
 * Prevents creating a bean if profile is not matched. It returns true if a bean should not be created.
 */
public class OpenmrsProfileExcludeFilter implements TypeFilter {
	/**
	 * @param metadataReader
	 * @param metadataReaderFactory
	 * @return whether this filter matches
	 * @throws IOException
	 *
	 * <strong>Should</strong> not include bean for openmrs from 1_6 to 1_7
	 * <strong>Should</strong> include bean for openmrs 1_10 and later
	 * <strong>Should</strong> not include bean for openmrs 1_8 and later if module missing
	 * <strong>Should</strong> include bean for openmrs 1_8 and later
	 */
	@Override
	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
		Map<String, Object> openmrsProfileAttributes = metadataReader.getAnnotationMetadata().getAnnotationAttributes(
				"org.openmrs.annotation.OpenmrsProfile");
		if (openmrsProfileAttributes != null) {
			return !matchOpenmrsProfileAttributes(openmrsProfileAttributes);
		} else {
			//do not exclude
			return false;
		}
	}
	public boolean matchOpenmrsProfileAttributes(Map<String, Object> openmrsProfile) {
		Object openmrsPlatformVersion = openmrsProfile.get("openmrsPlatformVersion");
		if (StringUtils.isBlank((String) openmrsPlatformVersion)) {
			//Left for backwards compatibility
			openmrsPlatformVersion = openmrsProfile.get("openmrsVersion");
		}
		if (StringUtils.isNotBlank((String) openmrsPlatformVersion)
				&& !ModuleUtil.matchRequiredVersions(OpenmrsConstants.OPENMRS_VERSION_SHORT, (String) openmrsPlatformVersion)) {
			return false;
		}
		String[] modules = (String[]) openmrsProfile.get("modules");
		for (String moduleAndVersion : modules) {
			if ("!".equals(moduleAndVersion.substring(0, 1))) {
				if (ModuleFactory.isModuleStarted(moduleAndVersion.substring(1))) {
					return false;
				}
			}
			else {
				String[] splitModuleAndVersion = moduleAndVersion.split(":");
				String moduleId = splitModuleAndVersion[0];
				String moduleVersion = splitModuleAndVersion[1];
				boolean moduleMatched = false;
				for (Module module : ModuleFactory.getStartedModules()) {
					if (module.getModuleId().equals(moduleId)
							&& ModuleUtil.matchRequiredVersions(module.getVersion(), moduleVersion)) {
						moduleMatched = true;
						break;
					}
				}
				if (!moduleMatched) {
					return false;
				}
			}
		}
		return true;
	}
}