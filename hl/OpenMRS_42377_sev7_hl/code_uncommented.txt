package org.openmrs.web;
import java.text.NumberFormat;
import java.util.Date;
import org.openmrs.Cohort;
import org.openmrs.Concept;
import org.openmrs.ConceptAnswer;
import org.openmrs.ConceptAttributeType;
import org.openmrs.ConceptClass;
import org.openmrs.ConceptDatatype;
import org.openmrs.ConceptMapType;
import org.openmrs.ConceptName;
import org.openmrs.ConceptNumeric;
import org.openmrs.ConceptReferenceTerm;
import org.openmrs.ConceptSource;
import org.openmrs.Drug;
import org.openmrs.Encounter;
import org.openmrs.Form;
import org.openmrs.Location;
import org.openmrs.LocationAttributeType;
import org.openmrs.LocationTag;
import org.openmrs.Order;
import org.openmrs.Patient;
import org.openmrs.PatientIdentifierType;
import org.openmrs.Person;
import org.openmrs.PersonAttribute;
import org.openmrs.PersonAttributeType;
import org.openmrs.Privilege;
import org.openmrs.Program;
import org.openmrs.ProgramWorkflow;
import org.openmrs.ProgramWorkflowState;
import org.openmrs.Provider;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.Visit;
import org.openmrs.VisitType;
import org.openmrs.api.context.Context;
import org.openmrs.propertyeditor.CohortEditor;
import org.openmrs.propertyeditor.ConceptAnswerEditor;
import org.openmrs.propertyeditor.ConceptAttributeTypeEditor;
import org.openmrs.propertyeditor.ConceptClassEditor;
import org.openmrs.propertyeditor.ConceptDatatypeEditor;
import org.openmrs.propertyeditor.ConceptEditor;
import org.openmrs.propertyeditor.ConceptMapTypeEditor;
import org.openmrs.propertyeditor.ConceptNameEditor;
import org.openmrs.propertyeditor.ConceptNumericEditor;
import org.openmrs.propertyeditor.ConceptReferenceTermEditor;
import org.openmrs.propertyeditor.ConceptSourceEditor;
import org.openmrs.propertyeditor.DateOrDatetimeEditor;
import org.openmrs.propertyeditor.DrugEditor;
import org.openmrs.propertyeditor.EncounterEditor;
import org.openmrs.propertyeditor.FormEditor;
import org.openmrs.propertyeditor.LocationAttributeTypeEditor;
import org.openmrs.propertyeditor.LocationEditor;
import org.openmrs.propertyeditor.LocationTagEditor;
import org.openmrs.propertyeditor.OrderEditor;
import org.openmrs.propertyeditor.PatientEditor;
import org.openmrs.propertyeditor.PatientIdentifierTypeEditor;
import org.openmrs.propertyeditor.PersonAttributeEditor;
import org.openmrs.propertyeditor.PersonAttributeTypeEditor;
import org.openmrs.propertyeditor.PersonEditor;
import org.openmrs.propertyeditor.PrivilegeEditor;
import org.openmrs.propertyeditor.ProgramEditor;
import org.openmrs.propertyeditor.ProgramWorkflowEditor;
import org.openmrs.propertyeditor.ProgramWorkflowStateEditor;
import org.openmrs.propertyeditor.ProviderEditor;
import org.openmrs.propertyeditor.RoleEditor;
import org.openmrs.propertyeditor.UserEditor;
import org.openmrs.propertyeditor.VisitEditor;
import org.openmrs.propertyeditor.VisitTypeEditor;
import org.springframework.beans.propertyeditors.CustomNumberEditor;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.support.WebBindingInitializer;
public class OpenmrsBindingInitializer implements WebBindingInitializer {
	@Override
	public void initBinder(WebDataBinder wdb) {
		wdb.registerCustomEditor(Cohort.class, new CohortEditor());
		wdb.registerCustomEditor(Concept.class, new ConceptEditor());
		wdb.registerCustomEditor(ConceptAnswer.class, new ConceptAnswerEditor());
		wdb.registerCustomEditor(ConceptClass.class, new ConceptClassEditor());
		wdb.registerCustomEditor(ConceptDatatype.class, new ConceptDatatypeEditor());
		wdb.registerCustomEditor(ConceptName.class, new ConceptNameEditor());
		wdb.registerCustomEditor(ConceptNumeric.class, new ConceptNumericEditor());
		wdb.registerCustomEditor(ConceptSource.class, new ConceptSourceEditor());
		wdb.registerCustomEditor(Drug.class, new DrugEditor());
		wdb.registerCustomEditor(Encounter.class, new EncounterEditor());
		wdb.registerCustomEditor(Form.class, new FormEditor());
		wdb.registerCustomEditor(Location.class, new LocationEditor());
		wdb.registerCustomEditor(LocationTag.class, new LocationTagEditor());
		wdb.registerCustomEditor(LocationAttributeType.class, new LocationAttributeTypeEditor());
		wdb.registerCustomEditor(Order.class, new OrderEditor());
		wdb.registerCustomEditor(Patient.class, new PatientEditor());
		wdb.registerCustomEditor(PatientIdentifierType.class, new PatientIdentifierTypeEditor());
		wdb.registerCustomEditor(PersonAttribute.class, new PersonAttributeEditor());
		wdb.registerCustomEditor(PersonAttributeType.class, new PersonAttributeTypeEditor());
		wdb.registerCustomEditor(Person.class, new PersonEditor());
		wdb.registerCustomEditor(Privilege.class, new PrivilegeEditor());
		wdb.registerCustomEditor(Program.class, new ProgramEditor());
		wdb.registerCustomEditor(ProgramWorkflow.class, new ProgramWorkflowEditor());
		wdb.registerCustomEditor(ProgramWorkflowState.class, new ProgramWorkflowStateEditor());
		wdb.registerCustomEditor(Provider.class, new ProviderEditor());
		wdb.registerCustomEditor(Role.class, new RoleEditor());
		wdb.registerCustomEditor(User.class, new UserEditor());
		wdb.registerCustomEditor(java.lang.Integer.class, new CustomNumberEditor(java.lang.Integer.class, NumberFormat
		        .getInstance(Context.getLocale()), true));
		wdb.registerCustomEditor(Date.class, new DateOrDatetimeEditor());
		wdb.registerCustomEditor(PatientIdentifierType.class, new PatientIdentifierTypeEditor());
		wdb.registerCustomEditor(ConceptMapType.class, new ConceptMapTypeEditor());
		wdb.registerCustomEditor(ConceptSource.class, new ConceptSourceEditor());
		wdb.registerCustomEditor(ConceptReferenceTerm.class, new ConceptReferenceTermEditor());
		wdb.registerCustomEditor(ConceptAttributeType.class, new ConceptAttributeTypeEditor());
		wdb.registerCustomEditor(VisitType.class, new VisitTypeEditor());
		wdb.registerCustomEditor(Visit.class, new VisitEditor());
	}
}
package org.openmrs;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Date;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import javax.persistence.Access;
import javax.persistence.AccessType;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OrderBy;
import javax.persistence.Table;
import org.hibernate.annotations.BatchSize;
import org.hibernate.annotations.Cascade;
import org.hibernate.envers.Audited;
import org.openmrs.annotation.AllowDirectAccess;
import org.openmrs.annotation.DisableHandlers;
import org.openmrs.api.context.Context;
import org.openmrs.api.handler.VoidHandler;
@Entity
@Table(name = "encounter")
@BatchSize(size = 25)
@Audited
public class Encounter extends BaseChangeableOpenmrsData {
	public static final long serialVersionUID = 2L;
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "encounter_id")
	private Integer encounterId;
	@Column(name = "encounter_datetime", nullable = false, length = 19)
	private Date encounterDatetime;
	@ManyToOne(optional = false)
	@JoinColumn(name = "patient_id")
	private Patient patient;
	@ManyToOne
	@JoinColumn(name = "location_id")
	private Location location;
	@ManyToOne
	@JoinColumn(name = "form_id")
	private Form form;
	@ManyToOne(optional = false)
	@JoinColumn(name = "encounter_type")
	private EncounterType encounterType;
	@OneToMany(mappedBy = "encounter")
	private Set<Order> orders;
	@OneToMany(mappedBy = "encounter")
	private Set<Diagnosis> diagnoses;
	@OneToMany(mappedBy = "encounter")
	private Set<Condition> conditions;
	@OneToMany(mappedBy = "encounter")
	@Access(AccessType.FIELD)
	@OrderBy("concept_id")
	@BatchSize(size = 25)
	@AllowDirectAccess
	private Set<Obs> obs;
	@ManyToOne
	@Cascade(org.hibernate.annotations.CascadeType.SAVE_UPDATE)
	@JoinColumn(name = "visit_id")
	private Visit visit;
	@OneToMany(mappedBy = "encounter", cascade = CascadeType.ALL)
	@OrderBy("provider_id")
	@DisableHandlers(handlerTypes = { VoidHandler.class })
	private Set<EncounterProvider> encounterProviders = new LinkedHashSet<>();
	@OneToMany(mappedBy = "encounter")
	private Set<Allergy> allergies;
	public Encounter() {
	}
	public Encounter(Integer encounterId) {
		this.encounterId = encounterId;
	}
	public Date getEncounterDatetime() {
		return encounterDatetime;
	}
	public void setEncounterDatetime(Date encounterDatetime) {
		this.encounterDatetime = encounterDatetime;
	}
	public Integer getEncounterId() {
		return encounterId;
	}
	public void setEncounterId(Integer encounterId) {
		this.encounterId = encounterId;
	}
	public EncounterType getEncounterType() {
		return encounterType;
	}
	public void setEncounterType(EncounterType encounterType) {
		this.encounterType = encounterType;
	}
	public Location getLocation() {
		return location;
	}
	public void setLocation(Location location) {
		this.location = location;
	}
	public Set<Obs> getObs() {
		Set<Obs> ret = new LinkedHashSet<>();
		if (this.obs != null) {
			for (Obs o : this.obs) {
				ret.addAll(getObsLeaves(o));
			}
		}
		return ret;
	}
	private List<Obs> getObsLeaves(Obs obsParent) {
		List<Obs> leaves = new ArrayList<>();
		if (obsParent.hasGroupMembers()) {
			for (Obs child : obsParent.getGroupMembers()) {
				if (!child.getVoided()) {
					if (!child.isObsGrouping()) {
						leaves.add(child);
					} else {
						leaves.addAll(getObsLeaves(child));
					}
				}
			}
		} else if (!obsParent.getVoided()) {
			leaves.add(obsParent);
		}
		return leaves;
	}
	private Set<Obs> getFlattenedObsLeaves(Obs obsParent, boolean includedVoided) {
		Set<Obs> leaves = new LinkedHashSet<>();
		if (includedVoided || (!obsParent.getVoided())) {
			leaves.add(obsParent);
			if (obsParent.hasGroupMembers()) {
				for (Obs child : obsParent.getGroupMembers(includedVoided)) {
					leaves.addAll(getFlattenedObsLeaves(child, includedVoided));
				}
			}
		}
		return leaves;
	}
	public Set<Obs> getAllObs(boolean includeVoided) {
		if (includeVoided && obs != null) {
			return obs;
		}
		Set<Obs> ret = new LinkedHashSet<>();
		if (this.obs != null) {
			ret = this.obs.stream().filter(o -> includeVoided || !o.getVoided()).collect(Collectors.toSet());
		}
		return ret;
	}
	public Set<Obs> getAllObs() {
		return getAllObs(false);
	}
	public Set<Obs> getAllFlattenedObs(boolean includeVoided) {
		Set<Obs> ret = new LinkedHashSet<>();
		if (this.obs != null) {
			for (Obs o : this.obs) {
				if (includeVoided || (!o.getVoided())) {
					ret.addAll(getFlattenedObsLeaves(o, includeVoided));
				}
			}
		}
		return ret;
	}
	public Set<Obs> getObsAtTopLevel(boolean includeVoided) {
		return getAllObs(includeVoided).stream().filter(o -> o.getObsGroup() == null)
		        .collect(Collectors.toCollection(LinkedHashSet::new));
	}
	public void setObs(Set<Obs> obs) {
		this.obs = obs;
	}
	public void addObs(Obs observation) {
		if (obs == null) {
			obs = new LinkedHashSet<>();
		}
		if (observation != null) {
			obs.add(observation);
			Deque<Obs> obsToUpdate = new ArrayDeque<>();
			obsToUpdate.add(observation);
			Set<Obs> seenIt = new LinkedHashSet<>();
			while (!obsToUpdate.isEmpty()) {
				Obs o = obsToUpdate.removeFirst();
				if (o == null || seenIt.contains(o)) {
					continue;
				}
				seenIt.add(o);
				o.setEncounter(this);
				if (o.getObsDatetime() == null) {
					o.setObsDatetime(getEncounterDatetime());
				}
				if (o.getPerson() == null) {
					o.setPerson(getPatient());
				}
				if (o.getLocation() == null) {
					o.setLocation(getLocation());
				}
				if (o.getGroupMembers(true) != null) {
					obsToUpdate.addAll(o.getGroupMembers());
				}
			}
		}
	}
	public void removeObs(Obs observation) {
		if (obs != null) {
			obs.remove(observation);
		}
	}
	public Set<Order> getOrders() {
		if (orders == null) {
			orders = new LinkedHashSet<>();
		}
		return orders;
	}
	public void setOrders(Set<Order> orders) {
		this.orders = orders;
	}
	public void addOrder(Order order) {
		if (order != null) {
			order.setEncounter(this);
			getOrders().add(order);
		}
	}
	public void removeOrder(Order order) {
		if (orders != null) {
			orders.remove(order);
		}
	}
	public Patient getPatient() {
		return patient;
	}
	public void setPatient(Patient patient) {
		this.patient = patient;
	}
	public Set<Diagnosis> getDiagnoses() {
		if (diagnoses == null) {
			diagnoses = new LinkedHashSet<>();
		}
		return diagnoses;
	}
	public void setDiagnoses(Set<Diagnosis> diagnoses) {
		this.diagnoses = diagnoses;
	}
	public Set<Condition> getConditions() {
		return getConditions(false);
	}
	public Set<Condition> getConditions(boolean includeVoided) {
		return Optional.ofNullable(conditions).orElse(new LinkedHashSet<>())
			.stream().filter(c -> includeVoided || !c.getVoided()).collect(Collectors.toSet());
	}
	public void setConditions(Set<Condition> conditions) {
		this.conditions = conditions;
	}
	public void addCondition(Condition condition) {
		if (conditions == null) {
			conditions = new LinkedHashSet<>();
		}
		if (condition != null) {
			condition.setEncounter(this);
			conditions.add(condition);
		}
	}
	public void removeCondition(Condition condition) {
		Optional.ofNullable(conditions).orElse(new LinkedHashSet<>()).stream().filter(c -> !c.getVoided() && c.equals(condition)).forEach(c -> {
			c.setVoided(true);
			c.setDateVoided(new Date());
			c.setVoidReason("Voided by the API");
			c.setVoidedBy(Context.getAuthenticatedUser());
		});
	}
	public Set<EncounterProvider> getEncounterProviders() {
		return encounterProviders;
	}
	public void setEncounterProviders(Set<EncounterProvider> encounterProviders) {
		this.encounterProviders = encounterProviders;
	}
	public Set<EncounterProvider> getActiveEncounterProviders() {
		Set<EncounterProvider> activeProviders = new LinkedHashSet<>();
		Set<EncounterProvider> providers = getEncounterProviders();
		if (providers != null && !providers.isEmpty()) {
			activeProviders = providers.stream().filter(p -> !p.getVoided()).collect(Collectors.toSet());
		}
		return activeProviders;
	}
	public Form getForm() {
		return form;
	}
	public void setForm(Form form) {
		this.form = form;
	}
	@Override
	public String toString() {
		String ret = "";
		ret += encounterId == null ? "(no ID) " : encounterId.toString() + " ";
		ret += this.getEncounterDatetime() == null ? "(no Date) " : this.getEncounterDatetime().toString() + " ";
		ret += this.getEncounterType() == null ? "(no Type) " : this.getEncounterType().getName() + " ";
		ret += this.getLocation() == null ? "(no Location) " : this.getLocation().getName() + " ";
		ret += this.getPatient() == null ? "(no Patient) " : this.getPatient().getPatientId().toString() + " ";
		ret += this.getForm() == null ? "(no Form) " : this.getForm().getName() + " ";
		ret += "num Obs: " + this.getObsAtTopLevel(false) + " ";
		ret += "num Orders: " + this.getOrders().size() + " ";
		return "Encounter: [" + ret + "]";
	}
	@Override
	public Integer getId() {
		return getEncounterId();
	}
	@Override
	public void setId(Integer id) {
		setEncounterId(id);
	}
	public Visit getVisit() {
		return visit;
	}
	public void setVisit(Visit visit) {
		this.visit = visit;
	}
	public Map<EncounterRole, Set<Provider>> getProvidersByRoles() {
		return getProvidersByRoles(false);
	}
	public Map<EncounterRole, Set<Provider>> getProvidersByRoles(boolean includeVoided) {
		return encounterProviders
		        .stream()
		        .filter(ep -> includeVoided || !ep.getVoided())
		        .collect(
		            Collectors.groupingBy(EncounterProvider::getEncounterRole,
		                Collectors.mapping(EncounterProvider::getProvider, Collectors.toSet())));
	}
	public Set<Provider> getProvidersByRole(EncounterRole role) {
		return getProvidersByRole(role, false);
	}
	public Set<Provider> getProvidersByRole(EncounterRole role, boolean includeVoided) {
		return encounterProviders.stream()
		        .filter(ep -> ep.getEncounterRole().equals(role) && (includeVoided || !ep.getVoided()))
		        .map(EncounterProvider::getProvider).collect(Collectors.toSet());
	}
	public void addProvider(EncounterRole role, Provider provider) {
		for (EncounterProvider ep : encounterProviders) {
			if (ep.getEncounterRole().equals(role) && ep.getProvider().equals(provider) && !ep.getVoided()) {
				return;
			}
		}
		EncounterProvider encounterProvider = new EncounterProvider();
		encounterProvider.setEncounter(this);
		encounterProvider.setEncounterRole(role);
		encounterProvider.setProvider(provider);
		encounterProvider.setDateCreated(new Date());
		encounterProvider.setCreator(Context.getAuthenticatedUser());
		encounterProviders.add(encounterProvider);
	}
	public void setProvider(EncounterRole role, Provider provider) {
		boolean hasProvider = false;
		for (EncounterProvider encounterProvider : encounterProviders) {
			if (encounterProvider.getEncounterRole().equals(role)) {
				if (!encounterProvider.getProvider().equals(provider)) {
					encounterProvider.setVoided(true);
					encounterProvider.setDateVoided(new Date());
					encounterProvider.setVoidedBy(Context.getAuthenticatedUser());
				} else if (!encounterProvider.getVoided()) {
					hasProvider = true;
				}
			}
		}
		if (!hasProvider) {
			addProvider(role, provider);
		}
	}
	public void removeProvider(EncounterRole role, Provider provider) {
		for (EncounterProvider encounterProvider : encounterProviders) {
			if (encounterProvider.getEncounterRole().equals(role) && encounterProvider.getProvider().equals(provider)
			        && !encounterProvider.getVoided()) {
				encounterProvider.setVoided(true);
				encounterProvider.setDateVoided(new Date());
				encounterProvider.setVoidedBy(Context.getAuthenticatedUser());
				return;
			}
		}
	}
	public Encounter copyAndAssignToAnotherPatient(Patient patient) {
		Encounter target = new Encounter();
		target.setChangedBy(getChangedBy());
		target.setCreator(getCreator());
		target.setDateChanged(getDateChanged());
		target.setDateCreated(getDateCreated());
		target.setDateVoided(getDateVoided());
		target.setVoided(getVoided());
		target.setVoidedBy(getVoidedBy());
		target.setVoidReason(getVoidReason());
		target.setEncounterDatetime(getEncounterDatetime());
		target.setEncounterType(getEncounterType());
		target.setForm(getForm());
		target.setLocation(getLocation());
		target.setPatient(patient);
		for (EncounterProvider encounterProvider : getEncounterProviders()) {
			EncounterProvider encounterProviderCopy = encounterProvider.copy();
			encounterProviderCopy.setEncounter(target);
			target.getEncounterProviders().add(encounterProviderCopy);
		}
		Context.getEncounterService().saveEncounter(target);
		for (Obs obs : getAllObs()) {
			Obs obsCopy = Obs.newInstance(obs);
			obsCopy.setEncounter(target);
			obsCopy.setPerson(patient);
			target.addObs(obsCopy);
		}
		return target;
	}
	public List<OrderGroup> getOrderGroups() {
		Map<String, OrderGroup> orderGroups = new HashMap<>();
		for (Order order : orders) {
			if (order.getOrderGroup() != null) {
				orderGroups.computeIfAbsent(order.getOrderGroup().getUuid(), k -> order.getOrderGroup());
				order.getOrderGroup().addOrder(order, null);
			}
		}
		return new ArrayList<>(orderGroups.values());
	}
	public List<Order> getOrdersWithoutOrderGroups() {
		return orders.stream().filter(o -> o.getOrderGroup() == null).collect(Collectors.toList());
	}
	public Boolean hasDiagnosis(Diagnosis diagnosis) {
		for (Diagnosis diagnosis1 : getDiagnoses()) {
			if (diagnosis.equals(diagnosis1)) {
				return true;
			}
		}
		return false;
	}
	public Set<Allergy> getAllergies() {
		return getAllergies(false);
	}
	public Set<Allergy> getAllergies(boolean includeVoided) {
		return Optional.ofNullable(allergies).orElse(new LinkedHashSet<>())
			.stream().filter(c -> includeVoided || !c.getVoided()).collect(Collectors.toSet());
	}
	public void setAllergies(Set<Allergy> allergies) {
		this.allergies = allergies;
	}
	public void addAllergy(Allergy allergy) {
		if (allergies == null) {
			allergies = new LinkedHashSet<>();
		}
		if (allergy != null) {
			allergy.setEncounter(this);
			allergies.add(allergy);
		}
	}
	public void removeAllergy(Allergy allergy) {
		Optional.ofNullable(allergies).orElse(new LinkedHashSet<>()).stream().filter(c -> !c.getVoided() && c.equals(allergy)).forEach(c -> {
			c.setVoided(true);
			c.setDateVoided(new Date());
			c.setVoidReason("Voided by the API");
			c.setVoidedBy(Context.getAuthenticatedUser());
		});
	}
}
package org.openmrs.api.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Cohort;
import org.openmrs.Encounter;
import org.openmrs.EncounterRole;
import org.openmrs.EncounterType;
import org.openmrs.Form;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.Order;
import org.openmrs.OrderGroup;
import org.openmrs.Patient;
import org.openmrs.Privilege;
import org.openmrs.Provider;
import org.openmrs.User;
import org.openmrs.Visit;
import org.openmrs.VisitType;
import org.openmrs.api.APIException;
import org.openmrs.api.DiagnosisService;
import org.openmrs.api.EncounterService;
import org.openmrs.api.EncounterTypeLockedException;
import org.openmrs.api.ObsService;
import org.openmrs.api.OrderService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.EncounterDAO;
import org.openmrs.api.handler.EncounterVisitHandler;
import org.openmrs.parameter.EncounterSearchCriteria;
import org.openmrs.parameter.EncounterSearchCriteriaBuilder;
import org.openmrs.util.HandlerUtil;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.springframework.transaction.annotation.Transactional;
@Transactional
public class EncounterServiceImpl extends BaseOpenmrsService implements EncounterService {
	private EncounterDAO dao;
	@Override
	public void setEncounterDAO(EncounterDAO dao) {
		this.dao = dao;
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByPatient(String query, boolean includeVoided) throws APIException {
		if (query == null) {
			throw new IllegalArgumentException("The 'query' parameter is required and cannot be null");
		}
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncounters(query, null, null, null, includeVoided), null);
	}
	@Override
	public Encounter saveEncounter(Encounter encounter) throws APIException {
		failIfDeniedToEdit(encounter);
		createVisitForNewEncounter(encounter);
		boolean isNewEncounter = requirePrivilege(encounter);
		Patient p = encounter.getPatient();
		Date originalDate;
		Location originalLocation = null;
		if (!isNewEncounter) {
			originalDate = dao.getSavedEncounterDatetime(encounter);
			if (encounter.getLocation() != null) {
				originalLocation = dao.getSavedEncounterLocation(encounter);
			}
			Date newDate = encounter.getEncounterDatetime();
			Location newLocation = encounter.getLocation();
			for (Obs obs : encounter.getAllFlattenedObs(true)) {
				if (OpenmrsUtil.compare(originalDate, newDate) != 0
				        && OpenmrsUtil.compare(obs.getObsDatetime(), originalDate) == 0) {
					obs.setObsDatetime(newDate);
				}
				if (!OpenmrsUtil.nullSafeEquals(newLocation, originalLocation) && obs.getLocation().equals(originalLocation)) {
					obs.setLocation(newLocation);
				}
				if (!obs.getPerson().getPersonId().equals(p.getPatientId())) {
					obs.setPerson(p);
				}
			}
		}
		for (Order o : encounter.getOrders()) {
			if (!p.equals(o.getPatient())) {
				o.setPatient(p);
			}
		}
		dao.saveEncounter(encounter);
		for (OrderGroup orderGroup : encounter.getOrderGroups()) {
			Context.getOrderService().saveOrderGroup(orderGroup);
		}
		for (Order o : encounter.getOrdersWithoutOrderGroups()) {
			if (o.getOrderId() == null) {
				Context.getOrderService().saveOrder(o, null);
			}
		}
		String changeMessage = Context.getMessageSourceService().getMessage("Obs.void.reason.default");
		ObsService os = Context.getObsService();
		List<Obs> obsToRemove = new ArrayList<>();
		List<Obs> obsToAdd = new ArrayList<>();
		for (Obs o : encounter.getObsAtTopLevel(true)) {
			if (o.getId() == null) {
				os.saveObs(o, null);
			} else {
				Obs newObs = os.saveObs(o, changeMessage);
				obsToRemove.add(o);
				obsToAdd.add(os.getObs(o.getId()));
				obsToAdd.add(newObs);
			}
		}
		removeGivenObsAndTheirGroupMembersFromEncounter(obsToRemove, encounter);
		addGivenObsAndTheirGroupMembersToEncounter(obsToAdd, encounter);
		encounter.getConditions().forEach(Context.getConditionService()::saveCondition);
		encounter.getAllergies().forEach(Context.getPatientService()::saveAllergy);
		encounter.getDiagnoses().stream().forEach(diagnosis -> {
			diagnosis.setPatient(p);
			diagnosis.setEncounter(encounter);
		});
		encounter.getDiagnoses().forEach(Context.getDiagnosisService()::save);
		return encounter;
	}
	private void failIfDeniedToEdit(Encounter encounter) throws APIException {
		if (!canEditEncounter(encounter, null)) {
			throw new APIException("Encounter.error.privilege.required.edit", new Object[] { encounter.getEncounterType()
			        .getEditPrivilege() });
		}
	}
	private void createVisitForNewEncounter(Encounter encounter) {
		if (encounter.getEncounterId() == null) {
			EncounterVisitHandler encounterVisitHandler = Context.getEncounterService().getActiveEncounterVisitHandler();
			if (encounterVisitHandler != null) {
				encounterVisitHandler.beforeCreateEncounter(encounter);
				if (encounter.getVisit() != null && encounter.getVisit().getVisitId() == null) {
					Context.getVisitService().saveVisit(encounter.getVisit());
				}
			}
		}
	}
	private boolean requirePrivilege(Encounter encounter) {
		boolean isNewEncounter = false;
		if (encounter.getEncounterId() == null) {
			isNewEncounter = true;
			Context.requirePrivilege(PrivilegeConstants.ADD_ENCOUNTERS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_ENCOUNTERS);
		}
		return isNewEncounter;
	}
	private void removeGivenObsAndTheirGroupMembersFromEncounter(Collection<Obs> obsToRemove, Encounter encounter) {
		for (Obs o : obsToRemove) {
			encounter.removeObs(o);
			Set<Obs> groupMembers = o.getGroupMembers(true);
			if (CollectionUtils.isNotEmpty(groupMembers)) {
				removeGivenObsAndTheirGroupMembersFromEncounter(groupMembers, encounter);
			}
		}
	}
	private void addGivenObsAndTheirGroupMembersToEncounter(Collection<Obs> obsToAdd, Encounter encounter) {
		for (Obs o : obsToAdd) {
			encounter.addObs(o);
			Set<Obs> groupMembers = o.getGroupMembers(true);
			if (CollectionUtils.isNotEmpty(groupMembers)) {
				addGivenObsAndTheirGroupMembersToEncounter(groupMembers, encounter);
			}
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Encounter getEncounter(Integer encounterId) throws APIException {
		Encounter encounter = dao.getEncounter(encounterId);
		if (encounter == null) {
			return null;
		} else if (canViewEncounter(encounter, null)) {
			return encounter;
		} else {
			throw new APIException("Encounter.error.privilege.required.view", new Object[] { encounter.getEncounterType()
			        .getViewPrivilege() });
		}
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByPatient(Patient patient) throws APIException {
		if (patient == null) {
			throw new IllegalArgumentException("The 'patient' parameter is requred and cannot be null");
		}
		EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setPatient(patient)
		        .setIncludeVoided(false).createEncounterSearchCriteria();
		return Context.getEncounterService().getEncounters(encounterSearchCriteria);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByPatient(String query) throws APIException {
		return Context.getEncounterService().filterEncountersByViewPermissions(getEncountersByPatient(query, false), null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByPatientId(Integer patientId) throws APIException {
		if (patientId == null) {
			throw new IllegalArgumentException("The 'patientId' parameter is requred and cannot be null");
		}
		return Context.getEncounterService()
		        .filterEncountersByViewPermissions(dao.getEncountersByPatientId(patientId), null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByPatientIdentifier(String identifier) throws APIException {
		if (identifier == null) {
			throw new IllegalArgumentException("The 'identifier' parameter is required and cannot be null");
		}
		List<Encounter> encs = new ArrayList<>();
		for (Patient p : Context.getPatientService().getPatients(identifier, null, null, false)) {
			encs.addAll(Context.getEncounterService().getEncountersByPatientId(p.getPatientId()));
		}
		return Context.getEncounterService().filterEncountersByViewPermissions(encs, null);
	}
	@Deprecated
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncounters(Patient who, Location loc, Date fromDate, Date toDate,
	                                     Collection<Form> enteredViaForms, Collection<EncounterType> encounterTypes,
	                                     Collection<Provider> providers, Collection<VisitType> visitTypes,
	                                     Collection<Visit> visits, boolean includeVoided) {
		EncounterSearchCriteriaBuilder encounterSearchCriteriaBuilder = new EncounterSearchCriteriaBuilder().setPatient(who)
		        .setLocation(loc).setFromDate(fromDate).setToDate(toDate).setEnteredViaForms(enteredViaForms)
		        .setEncounterTypes(encounterTypes).setProviders(providers).setVisitTypes(visitTypes).setVisits(visits)
		        .setIncludeVoided(includeVoided);
		return getEncounters(encounterSearchCriteriaBuilder.createEncounterSearchCriteria());
	}
	@Override
	public List<Encounter> getEncounters(EncounterSearchCriteria encounterSearchCriteria) {
		return Context.getEncounterService().filterEncountersByViewPermissions(dao.getEncounters(encounterSearchCriteria),
		    null);
	}
	@Override
	public Encounter voidEncounter(Encounter encounter, String reason) {
		if (!canEditEncounter(encounter, null)) {
			throw new APIException("Encounter.error.privilege.required.void", new Object[] { encounter.getEncounterType()
			        .getEditPrivilege() });
		}
		if (reason == null) {
			throw new IllegalArgumentException("The argument 'reason' is required and so cannot be null");
		}
		ObsService os = Context.getObsService();
		for (Obs o : encounter.getObsAtTopLevel(false)) {
			if (!o.getVoided()) {
				os.voidObs(o, reason);
			}
		}
		OrderService orderService = Context.getOrderService();
		for (Order o : encounter.getOrders()) {
			orderService.voidOrder(o, reason);
		}
		encounter.setVoided(true);
		encounter.setVoidedBy(Context.getAuthenticatedUser());
		if (encounter.getDateVoided() == null) {
			encounter.setDateVoided(new Date());
		}
		encounter.setVoidReason(reason);
		Context.getEncounterService().saveEncounter(encounter);
		return encounter;
	}
	@Override
	public Encounter unvoidEncounter(Encounter encounter) throws APIException {
		if (!canEditEncounter(encounter, null)) {
			throw new APIException("Encounter.error.privilege.required.unvoid", new Object[] { encounter.getEncounterType()
			        .getEditPrivilege() });
		}
		String voidReason = encounter.getVoidReason();
		if (voidReason == null) {
			voidReason = "";
		}
		ObsService os = Context.getObsService();
		for (Obs o : encounter.getObsAtTopLevel(true)) {
			if (voidReason.equals(o.getVoidReason())) {
				os.unvoidObs(o);
			}
		}
		OrderService orderService = Context.getOrderService();
		for (Order o : encounter.getOrders()) {
			if (voidReason.equals(o.getVoidReason())) {
				orderService.unvoidOrder(o);
			}
		}
		encounter.setVoided(false);
		encounter.setVoidedBy(null);
		encounter.setDateVoided(null);
		encounter.setVoidReason(null);
		Context.getEncounterService().saveEncounter(encounter);
		return encounter;
	}
	@Override
	public void purgeEncounter(Encounter encounter) throws APIException {
		if (!canEditEncounter(encounter, null)) {
			throw new APIException("Encounter.error.privilege.required.purge", new Object[] { encounter.getEncounterType()
			        .getEditPrivilege() });
		}
		dao.deleteEncounter(encounter);
	}
	@Override
	public void purgeEncounter(Encounter encounter, boolean cascade) throws APIException {
		if (!canEditEncounter(encounter, null)) {
			throw new APIException("Encounter.error.privilege.required.purge", new Object[] { encounter.getEncounterType()
			        .getEditPrivilege() });
		}
		if (cascade) {
			ObsService obsService = Context.getObsService();
			List<Encounter> justThisEncounter = new ArrayList<>();
			justThisEncounter.add(encounter);
			List<Obs> observations = new ArrayList<>(
					obsService.getObservations(null, justThisEncounter, null, null, null, null, null, null,
							null, null, null, true));
			for (Obs o : observations) {
				obsService.purgeObs(o);
			}
			Set<Order> orders = encounter.getOrders();
			for (Order o : orders) {
				Context.getOrderService().purgeOrder(o);
			}
		}
		Context.getEncounterService().purgeEncounter(encounter);
	}
	@Override
	public EncounterType saveEncounterType(EncounterType encounterType) {
		Context.getEncounterService().checkIfEncounterTypesAreLocked();
		dao.saveEncounterType(encounterType);
		return encounterType;
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterType getEncounterType(Integer encounterTypeId) throws APIException {
		return dao.getEncounterType(encounterTypeId);
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterType getEncounterType(String name) throws APIException {
		return dao.getEncounterType(name);
	}
	@Override
	@Transactional(readOnly = true)
	public List<EncounterType> getAllEncounterTypes() throws APIException {
		return dao.getAllEncounterTypes(true);
	}
	@Override
	@Transactional(readOnly = true)
	public List<EncounterType> getAllEncounterTypes(boolean includeRetired) throws APIException {
		return dao.getAllEncounterTypes(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public List<EncounterType> findEncounterTypes(String name) throws APIException {
		return dao.findEncounterTypes(name);
	}
	@Override
	public EncounterType retireEncounterType(EncounterType encounterType, String reason) throws APIException {
		if (reason == null) {
			throw new IllegalArgumentException("The 'reason' for retiring is required");
		}
		Context.getEncounterService().checkIfEncounterTypesAreLocked();
		encounterType.setRetired(true);
		encounterType.setRetireReason(reason);
		return Context.getEncounterService().saveEncounterType(encounterType);
	}
	@Override
	public EncounterType unretireEncounterType(EncounterType encounterType) throws APIException {
		Context.getEncounterService().checkIfEncounterTypesAreLocked();
		encounterType.setRetired(false);
		return Context.getEncounterService().saveEncounterType(encounterType);
	}
	@Override
	public void purgeEncounterType(EncounterType encounterType) throws APIException {
		Context.getEncounterService().checkIfEncounterTypesAreLocked();
		dao.deleteEncounterType(encounterType);
	}
	@Override
	@Transactional(readOnly = true)
	public Encounter getEncounterByUuid(String uuid) throws APIException {
		return dao.getEncounterByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterType getEncounterTypeByUuid(String uuid) throws APIException {
		return dao.getEncounterTypeByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public Map<Integer, List<Encounter>> getAllEncounters(Cohort patients) {
		return dao.getAllEncounters(patients);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncounters(String query, Integer start, Integer length, boolean includeVoided)
	    throws APIException {
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncounters(query, null, start, length, includeVoided), null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncounters(String query, Integer patientId, Integer start, Integer length,
	                                     boolean includeVoided) throws APIException {
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncounters(query, patientId, start, length, includeVoided), null);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfEncounters(String query, boolean includeVoided) {
		return OpenmrsUtil.convertToInteger(dao.getCountOfEncounters(query, null, includeVoided));
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByVisit(Visit visit, boolean includeVoided) {
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncountersByVisit(visit, includeVoided), null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<EncounterVisitHandler> getEncounterVisitHandlers() {
		return HandlerUtil.getHandlersForType(EncounterVisitHandler.class, null);
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterVisitHandler getActiveEncounterVisitHandler() throws APIException {
		String handlerGlobalValue = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GP_VISIT_ASSIGNMENT_HANDLER, null);
		if (StringUtils.isBlank(handlerGlobalValue)) {
			return null;
		}
		EncounterVisitHandler handler;
		String namePrefix = OpenmrsConstants.REGISTERED_COMPONENT_NAME_PREFIX;
		if (handlerGlobalValue.startsWith(namePrefix)) {
			String beanName = handlerGlobalValue.substring(namePrefix.length());
			handler = Context.getRegisteredComponent(beanName, EncounterVisitHandler.class);
		} else {
			Object instance;
			try {
				instance = OpenmrsClassLoader.getInstance().loadClass(handlerGlobalValue).newInstance();
			}
			catch (Exception ex) {
				throw new APIException("failed.instantiate.assignment.handler", new Object[] { handlerGlobalValue }, ex);
			}
			if (instance instanceof EncounterVisitHandler) {
				handler = (EncounterVisitHandler) instance;
			} else {
				throw new APIException("assignment.handler.should.implement.EncounterVisitHandler", (Object[]) null);
			}
		}
		return handler;
	}
	@Override
	public EncounterRole saveEncounterRole(EncounterRole encounterRole) throws APIException {
		dao.saveEncounterRole(encounterRole);
		return encounterRole;
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterRole getEncounterRole(Integer encounterRoleId) throws APIException {
		return dao.getEncounterRole(encounterRoleId);
	}
	@Override
	public void purgeEncounterRole(EncounterRole encounterRole) throws APIException {
		dao.deleteEncounterRole(encounterRole);
	}
	@Override
	@Transactional(readOnly = true)
	public List<EncounterRole> getAllEncounterRoles(boolean includeRetired) {
		return dao.getAllEncounterRoles(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterRole getEncounterRoleByUuid(String uuid) throws APIException {
		return dao.getEncounterRoleByUuid(uuid);
	}
	@Override
	public EncounterRole getEncounterRoleByName(String name) {
		return dao.getEncounterRoleByName(name);
	}
	@Override
	public EncounterRole retireEncounterRole(EncounterRole encounterRole, String reason) throws APIException {
		if (reason == null) {
			throw new IllegalArgumentException("The 'reason' for retiring is required");
		}
		return Context.getEncounterService().saveEncounterRole(encounterRole);
	}
	@Override
	public EncounterRole unretireEncounterRole(EncounterRole encounterRole) throws APIException {
		return Context.getEncounterService().saveEncounterRole(encounterRole);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersNotAssignedToAnyVisit(Patient patient) throws APIException {
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncountersNotAssignedToAnyVisit(patient), null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByVisitsAndPatient(Patient patient, boolean includeVoided, String query,
	                                                       Integer start, Integer length) throws APIException {
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncountersByVisitsAndPatient(patient, includeVoided, query, start, length), null);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getEncountersByVisitsAndPatientCount(Patient patient, boolean includeVoided, String query)
	    throws APIException {
		return dao.getEncountersByVisitsAndPatientCount(patient, includeVoided, query);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> filterEncountersByViewPermissions(List<Encounter> encounters, User user) {
		if (encounters != null) {
			if (user == null) {
				user = Context.getAuthenticatedUser();
			}
			for (Iterator<Encounter> iterator = encounters.iterator(); iterator.hasNext();) {
				Encounter encounter = iterator.next();
				EncounterType et = encounter.getEncounterType();
				if (et != null && !userHasEncounterPrivilege(et.getViewPrivilege(), user)) {
					iterator.remove();
				}
			}
		}
		return encounters;
	}
	@Override
	@Transactional(readOnly = true)
	public boolean canViewAllEncounterTypes(User subject) {
		boolean canView = Boolean.TRUE;
		for (EncounterType et : Context.getEncounterService().getAllEncounterTypes()) {
			if (!userHasEncounterPrivilege(et.getViewPrivilege(), subject)) {
				canView = Boolean.FALSE;
				break;
			}
		}
		return canView;
	}
	@Override
	@Transactional(readOnly = true)
	public boolean canEditAllEncounterTypes(User subject) {
		boolean canEdit = Boolean.TRUE;
		for (EncounterType et : Context.getEncounterService().getAllEncounterTypes()) {
			if (!userHasEncounterPrivilege(et.getEditPrivilege(), subject)) {
				canEdit = Boolean.FALSE;
				break;
			}
		}
		return canEdit;
	}
	@Override
	public boolean canEditEncounter(Encounter encounter, User user) {
		if (encounter == null) {
			throw new IllegalArgumentException("The encounter argument can not be null");
		}
		if (encounter.getEncounterType() == null) {
			return Boolean.TRUE;
		}
		if (user == null) {
			user = Context.getAuthenticatedUser();
		}
		return userHasEncounterPrivilege(encounter.getEncounterType().getEditPrivilege(), user);
	}
	@Override
	public boolean canViewEncounter(Encounter encounter, User user) {
		if (encounter == null) {
			throw new IllegalArgumentException("The encounter argument can not be null");
		}
		if (encounter.getEncounterType() == null) {
			return Boolean.TRUE;
		}
		if (user == null) {
			user = Context.getAuthenticatedUser();
		}
		return userHasEncounterPrivilege(encounter.getEncounterType().getViewPrivilege(), user);
	}
	private boolean userHasEncounterPrivilege(Privilege privilege, User user) {
		if (privilege == null) {
			return true;
		}
		return user.hasPrivilege(privilege.getPrivilege());
	}
	@Override
	@Transactional(readOnly = true)
	public void checkIfEncounterTypesAreLocked() {
		String locked = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_ENCOUNTER_TYPES_LOCKED, "false");
		if (Boolean.valueOf(locked)) {
			throw new EncounterTypeLockedException();
		}
	}
	@Override
	public List<EncounterRole> getEncounterRolesByName(String name) {
		return dao.getEncounterRolesByName(name);
	}
	@Override
	public Encounter transferEncounter(Encounter encounter, Patient patient) {
		Encounter encounterCopy = encounter.copyAndAssignToAnotherPatient(patient);
		voidEncounter(encounter, "transfer to patient: id = " + patient.getId());
		Visit visit = encounter.getVisit();
		if (visit != null && visit.getEncounters().size() == 1) {
			Context.getVisitService().voidVisit(visit, "Visit does not contain non-voided encounters");
		}
		return saveEncounter(encounterCopy);
	}
}
package org.openmrs;
import org.hibernate.envers.Audited;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@Audited
public class Provider extends BaseCustomizableMetadata<ProviderAttribute> {
	private static final Logger log = LoggerFactory.getLogger(Provider.class);
	private Integer providerId;
	private Person person;
	private String identifier;
	private Concept role;
	private Concept speciality;
	public Provider() {
	}
	public Provider(Integer providerId) {
		this.providerId = providerId;
	}
	@Override
	public Integer getId() {
		return getProviderId();
	}
	@Override
	public void setId(Integer id) {
		setProviderId(id);
	}
	public void setProviderId(Integer providerId) {
		this.providerId = providerId;
	}
	public Integer getProviderId() {
		return providerId;
	}
	public void setPerson(Person person) {
		this.person = person;
	}
	public Person getPerson() {
		return person;
	}
	public void setIdentifier(String identifier) {
		this.identifier = identifier;
	}
	public String getIdentifier() {
		return identifier;
	}
	public void setRole(Concept role) {
		this.role = role;
	}
	public Concept getRole() {
		return role;
	}
	public void setSpeciality(Concept speciality) {
		this.speciality = speciality;
	}
	public Concept getSpeciality() {
		return speciality;
	}
	@Override
	public String toString() {
		String provider = String.valueOf(providerId) + " providerName:" + ((person != null) ? person.getNames() : "");
		return "[Provider: providerId:" + provider + " ]";
	}
	@Override
	public String getName() {
		if (getPerson() != null && getPerson().getPersonName() != null) {
			return getPerson().getPersonName().getFullName();
		} else {
			log.warn("We no longer support providers who are not linked to person. Set the name on the linked person");
			return null;
		}
	}
}
package org.openmrs;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Set;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.envers.Audited;
import org.openmrs.annotation.AllowDirectAccess;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.hibernate.HibernateUtil;
import org.openmrs.obs.ComplexData;
import org.openmrs.obs.ComplexObsHandler;
import org.openmrs.util.Format;
import org.openmrs.util.Format.FORMAT_TYPE;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@Audited
public class Obs extends BaseFormRecordableOpenmrsData {
	public enum Interpretation {
		NORMAL, ABNORMAL, CRITICALLY_ABNORMAL, NEGATIVE, POSITIVE, CRITICALLY_LOW, LOW, HIGH, CRITICALLY_HIGH, VERY_SUSCEPTIBLE, SUSCEPTIBLE, INTERMEDIATE, RESISTANT, SIGNIFICANT_CHANGE_DOWN, SIGNIFICANT_CHANGE_UP, OFF_SCALE_LOW, OFF_SCALE_HIGH
	}
	public enum Status {
		PRELIMINARY, FINAL, AMENDED
	}
	private static final String DATE_TIME_PATTERN = "yyyy-MM-dd HH:mm";
	private static final String TIME_PATTERN = "HH:mm";
	private static final String DATE_PATTERN = "yyyy-MM-dd";
	public static final long serialVersionUID = 112342333L;
	private static final Logger log = LoggerFactory.getLogger(Obs.class);
	protected Integer obsId;
	protected Concept concept;
	protected Date obsDatetime;
	protected String accessionNumber;
	protected Obs obsGroup;
	@AllowDirectAccess
	protected Set<Obs> groupMembers;
	protected Concept valueCoded;
	protected ConceptName valueCodedName;
	protected Drug valueDrug;
	protected Integer valueGroupId;
	protected Date valueDatetime;
	protected Double valueNumeric;
	protected String valueModifier;
	protected String valueText;
	protected String valueComplex;
	protected transient ComplexData complexData;
	protected String comment;
	protected transient Integer personId;
	protected Person person;
	protected Order order;
	protected Location location;
	protected Encounter encounter;
	private Obs previousVersion;
	private Boolean dirty = Boolean.FALSE;
	private Interpretation interpretation;
	private Status status = Status.FINAL;
	private ObsReferenceRange referenceRange;
	public Obs() {
	}
	public Obs(Person person, Concept question, Date obsDatetime, Location location) {
		this.person = person;
		if (person != null) {
			this.personId = person.getPersonId();
		}
		this.concept = question;
		this.obsDatetime = obsDatetime;
		this.location = location;
	}
	public Obs(Integer obsId) {
		this.obsId = obsId;
	}
	public static Obs newInstance(Obs obsToCopy) {
		Obs newObs = new Obs(obsToCopy.getPerson(), obsToCopy.getConcept(), obsToCopy.getObsDatetime(),
		        obsToCopy.getLocation());
		newObs.setObsGroup(obsToCopy.getObsGroup());
		newObs.setAccessionNumber(obsToCopy.getAccessionNumber());
		newObs.setValueCoded(obsToCopy.getValueCoded());
		newObs.setValueDrug(obsToCopy.getValueDrug());
		newObs.setValueGroupId(obsToCopy.getValueGroupId());
		newObs.setValueDatetime(obsToCopy.getValueDatetime());
		newObs.setValueNumeric(obsToCopy.getValueNumeric());
		newObs.setValueModifier(obsToCopy.getValueModifier());
		newObs.setValueText(obsToCopy.getValueText());
		newObs.setComment(obsToCopy.getComment());
		newObs.setEncounter(obsToCopy.getEncounter());
		newObs.setCreator(obsToCopy.getCreator());
		newObs.setDateCreated(obsToCopy.getDateCreated());
		newObs.setVoided(obsToCopy.getVoided());
		newObs.setVoidedBy(obsToCopy.getVoidedBy());
		newObs.setDateVoided(obsToCopy.getDateVoided());
		newObs.setVoidReason(obsToCopy.getVoidReason());
		newObs.setStatus(obsToCopy.getStatus());
		newObs.setInterpretation(obsToCopy.getInterpretation());
		newObs.setOrder(obsToCopy.getOrder());
		newObs.setValueComplex(obsToCopy.getValueComplex());
		newObs.setComplexData(obsToCopy.getComplexData());
		newObs.setFormField(obsToCopy.getFormFieldNamespace(), obsToCopy.getFormFieldPath());
		if (obsToCopy.hasGroupMembers(true)) {
			for (Obs member : obsToCopy.getGroupMembers(true)) {
				if (member.getObsId() == null) {
					newObs.addGroupMember(member);
				} else {
					Obs newMember = Obs.newInstance(member);
					newMember.setPreviousVersion(member);
					newObs.addGroupMember(newMember);
				}
			}
		}
		return newObs;
	}
	public String getComment() {
		return comment;
	}
	public void setComment(String comment) {
		markAsDirty(this.comment, comment);
		this.comment = comment;
	}
	public Concept getConcept() {
		return concept;
	}
	public void setConcept(Concept concept) {
		markAsDirty(this.concept, concept);
		this.concept = concept;
	}
	public ConceptDescription getConceptDescription() {
		if (getConcept() == null) {
			return null;
		}
		return concept.getDescription();
	}
	public Encounter getEncounter() {
		return encounter;
	}
	public void setEncounter(Encounter encounter) {
		markAsDirty(this.encounter, encounter);
		this.encounter = encounter;
	}
	public Location getLocation() {
		return location;
	}
	public void setLocation(Location location) {
		markAsDirty(this.location, location);
		this.location = location;
	}
	public Date getObsDatetime() {
		return obsDatetime;
	}
	public void setObsDatetime(Date obsDatetime) {
		markAsDirty(this.obsDatetime, obsDatetime);
		this.obsDatetime = obsDatetime;
	}
	public Obs getObsGroup() {
		return obsGroup;
	}
	public void setObsGroup(Obs obsGroup) {
		markAsDirty(this.obsGroup, obsGroup);
		this.obsGroup = obsGroup;
	}
	public boolean isObsGrouping() {
		return hasGroupMembers(true);
	}
	public boolean hasGroupMembers() {
		return hasGroupMembers(false);
	}
	public boolean hasGroupMembers(boolean includeVoided) {
		return !org.springframework.util.CollectionUtils.isEmpty(getGroupMembers(includeVoided));
	}
	public Set<Obs> getGroupMembers() {
		return getGroupMembers(false);
	}
	public Set<Obs> getGroupMembers(boolean includeVoided) {
		if (includeVoided) {
			return groupMembers;
		}
		if (groupMembers == null) {
			return null;
		}
		Set<Obs> nonVoided = new LinkedHashSet<>(groupMembers);
		nonVoided.removeIf(BaseOpenmrsData::getVoided);
		return nonVoided;
	}
	public void setGroupMembers(Set<Obs> groupMembers) {
		this.groupMembers = groupMembers;
	}
	public void addGroupMember(Obs member) {
		if (member == null) {
			return;
		}
		if (getGroupMembers() == null) {
			groupMembers = new HashSet<>();
		}
		if (member.equals(this)) {
			throw new APIException("Obs.error.groupCannotHaveItselfAsAMentor", new Object[] { this, member });
		}
		member.setObsGroup(this);
		groupMembers.add(member);
	}
	public void removeGroupMember(Obs member) {
		if (member == null || getGroupMembers() == null) {
			return;
		}
		if (groupMembers.remove(member)) {
			member.setObsGroup(null);
		}
	}
	public Set<Obs> getRelatedObservations() {
		Set<Obs> ret = new HashSet<>();
		if (this.isObsGrouping()) {
			ret.addAll(this.getGroupMembers());
			Obs parentObs = this;
			while (parentObs.getObsGroup() != null) {
				for (Obs obsSibling : parentObs.getObsGroup().getGroupMembers()) {
					if (!obsSibling.isObsGrouping()) {
						ret.add(obsSibling);
					}
				}
				parentObs = parentObs.getObsGroup();
			}
		} else if (this.getObsGroup() != null) {
			for (Obs obsSibling : this.getObsGroup().getGroupMembers()) {
				if (!obsSibling.isObsGrouping()) {
					ret.add(obsSibling);
				}
			}
		}
		return ret;
	}
	public Integer getObsId() {
		return obsId;
	}
	public void setObsId(Integer obsId) {
		this.obsId = obsId;
	}
	public Order getOrder() {
		return order;
	}
	public void setOrder(Order order) {
		markAsDirty(this.order, order);
		this.order = order;
	}
	public Integer getPersonId() {
		return personId;
	}
	protected void setPersonId(Integer personId) {
		markAsDirty(this.personId, personId);
		this.personId = personId;
	}
	public Person getPerson() {
		return person;
	}
	public void setPerson(Person person) {
		markAsDirty(this.person, person);
		this.person = person;
		if (person != null) {
			setPersonId(person.getPersonId());
		}
	}
	public void setValueBoolean(Boolean valueBoolean) {
		if (getConcept() != null && getConcept().getDatatype() != null && getConcept().getDatatype().isBoolean()) {
			if (valueBoolean != null) {
				setValueCoded(valueBoolean ? Context.getConceptService().getTrueConcept() : Context.getConceptService()
				        .getFalseConcept());
			} else {
				setValueCoded(null);
			}
		}
	}
	public Boolean getValueAsBoolean() {
		if (getValueCoded() != null) {
			if (getValueCoded().equals(Context.getConceptService().getTrueConcept())) {
				return Boolean.TRUE;
			} else if (getValueCoded().equals(Context.getConceptService().getFalseConcept())) {
				return Boolean.FALSE;
			}
		} else if (getValueNumeric() != null) {
			if (getValueNumeric() == 1) {
				return Boolean.TRUE;
			} else if (getValueNumeric() == 0) {
				return Boolean.FALSE;
			}
		}
		return null;
	}
	public Boolean getValueBoolean() {
		if (getConcept() != null && valueCoded != null && getConcept().getDatatype().isBoolean()) {
			Concept trueConcept = Context.getConceptService().getTrueConcept();
			return trueConcept != null && valueCoded.getId().equals(trueConcept.getId());
		}
		return null;
	}
	public Concept getValueCoded() {
		return valueCoded;
	}
	public void setValueCoded(Concept valueCoded) {
		markAsDirty(this.valueCoded, valueCoded);
		this.valueCoded = valueCoded;
	}
	public ConceptName getValueCodedName() {
		return valueCodedName;
	}
	public void setValueCodedName(ConceptName valueCodedName) {
		markAsDirty(this.valueCodedName, valueCodedName);
		this.valueCodedName = valueCodedName;
	}
	public Drug getValueDrug() {
		return valueDrug;
	}
	public void setValueDrug(Drug valueDrug) {
		markAsDirty(this.valueDrug, valueDrug);
		this.valueDrug = valueDrug;
	}
	public Date getValueDatetime() {
		return valueDatetime;
	}
	public void setValueDatetime(Date valueDatetime) {
		markAsDirty(this.valueDatetime, valueDatetime);
		this.valueDatetime = valueDatetime;
	}
	public Date getValueDate() {
		return valueDatetime;
	}
	public void setValueDate(Date valueDate) {
		markAsDirty(this.valueDatetime, valueDate);
		this.valueDatetime = valueDate;
	}
	public Date getValueTime() {
		return valueDatetime;
	}
	public void setValueTime(Date valueTime) {
		markAsDirty(this.valueDatetime, valueTime);
		this.valueDatetime = valueTime;
	}
	public Integer getValueGroupId() {
		return valueGroupId;
	}
	public void setValueGroupId(Integer valueGroupId) {
		markAsDirty(this.valueGroupId, valueGroupId);
		this.valueGroupId = valueGroupId;
	}
	public String getValueModifier() {
		return valueModifier;
	}
	public void setValueModifier(String valueModifier) {
		markAsDirty(this.valueModifier, valueModifier);
		this.valueModifier = valueModifier;
	}
	public Double getValueNumeric() {
		return valueNumeric;
	}
	public void setValueNumeric(Double valueNumeric) {
		markAsDirty(this.valueNumeric, valueNumeric);
		this.valueNumeric = valueNumeric;
	}
	public String getValueText() {
		return valueText;
	}
	public void setValueText(String valueText) {
		markAsDirty(this.valueText, valueText);
		this.valueText = valueText;
	}
	public boolean isComplex() {
		if (getConcept() != null) {
			return getConcept().isComplex();
		}
		return false;
	}
	public String getValueComplex() {
		return this.valueComplex;
	}
	public void setValueComplex(String valueComplex) {
		markAsDirty(this.valueComplex, valueComplex);
		this.valueComplex = valueComplex;
	}
	public void setComplexData(ComplexData complexData) {
		markAsDirty(this.complexData, complexData);
		this.complexData = complexData;
	}
	public ComplexData getComplexData() {
		return this.complexData;
	}
	public String getAccessionNumber() {
		return accessionNumber;
	}
	public void setAccessionNumber(String accessionNumber) {
		markAsDirty(this.accessionNumber, accessionNumber);
		this.accessionNumber = accessionNumber;
	}
	public String getValueAsString(Locale locale) {
		NumberFormat nf = NumberFormat.getNumberInstance(locale);
		DecimalFormat df = (DecimalFormat) nf;
		df.applyPattern("#0.0#####");
		if (getConcept() != null) {
			String abbrev = getConcept().getDatatype().getHl7Abbreviation();
			if ("BIT".equals(abbrev)) {
				return getValueAsBoolean() == null ? "" : getValueAsBoolean().toString();
			} else if ("CWE".equals(abbrev)) {
				if (getValueCoded() == null) {
					return "";
				}
				if (getValueDrug() != null) {
					return getValueDrug().getFullName(locale);
				} else {
					ConceptName codedName = getValueCodedName();
					if (codedName != null) {
						return getValueCoded().getName(locale, false).getName();
					} else {
						ConceptName fallbackName = getValueCoded().getName();
						if (fallbackName != null) {
							return fallbackName.getName();
						} else {
							return "";
						}
					}
				}
			} else if ("NM".equals(abbrev) || "SN".equals(abbrev)) {
				if (getValueNumeric() == null) {
					return "";
				} else {
					Concept deproxiedConcept = HibernateUtil.getRealObjectFromProxy(getConcept());
					if (deproxiedConcept instanceof ConceptNumeric) {
						ConceptNumeric cn = (ConceptNumeric) deproxiedConcept;
						if (!cn.getAllowDecimal()) {
							double d = getValueNumeric();
							int i = (int) d;
							return Integer.toString(i);
						} else {
							df.format(getValueNumeric());
						}
					}
				}
			} else if ("DT".equals(abbrev)) {
				DateFormat dateFormat = new SimpleDateFormat(DATE_PATTERN);
				return (getValueDatetime() == null ? "" : dateFormat.format(getValueDatetime()));
			} else if ("TM".equals(abbrev)) {
				return (getValueDatetime() == null ? "" : Format.format(getValueDatetime(), locale, FORMAT_TYPE.TIME));
			} else if ("TS".equals(abbrev)) {
				return (getValueDatetime() == null ? "" : Format.format(getValueDatetime(), locale, FORMAT_TYPE.TIMESTAMP));
			} else if ("ST".equals(abbrev)) {
				return getValueText();
			} else if ("ED".equals(abbrev) && getValueComplex() != null) {
				String[] valuesComplex = getValueComplex().split("\\|");
				for (String value : valuesComplex) {
					if (StringUtils.isNotEmpty(value)) {
						return value.trim();
					}
				}
			}
		}
		if (getValueNumeric() != null) {
			return df.format(getValueNumeric());
		} else if (getValueCoded() != null) {
			if (getValueDrug() != null) {
				return getValueDrug().getFullName(locale);
			} else {
				ConceptName valudeCodedName = getValueCodedName();
				if (valudeCodedName != null) {
					return valudeCodedName.getName();
				} else {
					return "";
				}
			}
		} else if (getValueDatetime() != null) {
			return Format.format(getValueDatetime(), locale, FORMAT_TYPE.DATE);
		} else if (getValueText() != null) {
			return getValueText();
		} else if (hasGroupMembers()) {
			StringBuilder sb = new StringBuilder();
			for (Obs groupMember : getGroupMembers()) {
				if (sb.length() > 0) {
					sb.append(", ");
				}
				sb.append(groupMember.getValueAsString(locale));
			}
			return sb.toString();
		}
		if (getValueComplex() != null) {
			String[] valuesComplex = getValueComplex().split("\\|");
			for (String value : valuesComplex) {
				if (StringUtils.isNotEmpty(value)) {
					return value.trim();
				}
			}
		}
		return "";
	}
	public void setValueAsString(String s) throws ParseException {
		log.debug("getConcept() == {}", getConcept());
		if (getConcept() != null && !StringUtils.isBlank(s)) {
			String abbrev = getConcept().getDatatype().getHl7Abbreviation();
			if ("BIT".equals(abbrev)) {
				setValueBoolean(Boolean.valueOf(s));
			} else if ("CWE".equals(abbrev)) {
				throw new RuntimeException("Not Yet Implemented");
			} else if ("NM".equals(abbrev) || "SN".equals(abbrev)) {
				setValueNumeric(Double.valueOf(s));
			} else if ("DT".equals(abbrev)) {
				DateFormat dateFormat = new SimpleDateFormat(DATE_PATTERN);
				setValueDatetime(dateFormat.parse(s));
			} else if ("TM".equals(abbrev)) {
				DateFormat timeFormat = new SimpleDateFormat(TIME_PATTERN);
				setValueDatetime(timeFormat.parse(s));
			} else if ("TS".equals(abbrev)) {
				DateFormat datetimeFormat = new SimpleDateFormat(DATE_TIME_PATTERN);
				setValueDatetime(datetimeFormat.parse(s));
			} else if ("ST".equals(abbrev)) {
				setValueText(s);
			} else {
				throw new RuntimeException("Don't know how to handle " + abbrev + " for concept: " + getConcept().getName().getName());
			}
		} else {
			throw new RuntimeException("concept is null for " + this);
		}
	}
	@Override
	public String toString() {
		if (obsId == null) {
			return "obs id is null";
		}
		return "Obs #" + obsId.toString();
	}
	@Override
	public Integer getId() {
		return getObsId();
	}
	@Override
	public void setId(Integer id) {
		setObsId(id);
	}
	public Obs getPreviousVersion() {
		return previousVersion;
	}
	public void setPreviousVersion(Obs previousVersion) {
		markAsDirty(this.previousVersion, previousVersion);
		this.previousVersion = previousVersion;
	}
	public Boolean hasPreviousVersion() {
		return getPreviousVersion() != null;
	}
	@Override
	public void setCreator(User creator) {
		markAsDirty(getCreator(), creator);
		super.setCreator(creator);
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		markAsDirty(getDateCreated(), dateCreated);
		super.setDateCreated(dateCreated);
	}
	@Override
	public void setFormField(String namespace, String formFieldPath) {
		String oldValue = formNamespaceAndPath;
		super.setFormField(namespace, formFieldPath);
		markAsDirty(oldValue, formNamespaceAndPath);
	}
	public boolean isDirty() {
		return dirty;
	}
	protected void markAsDirty(Object oldValue, Object newValue) {
		if (!isDirty() && obsId != null && !OpenmrsUtil.nullSafeEquals(oldValue, newValue)) {
			dirty = true;
		}
	}
	public Interpretation getInterpretation() {
		return interpretation;
	}
	public void setInterpretation(Interpretation interpretation) {
		markAsDirty(this.interpretation, interpretation);
		this.interpretation = interpretation;
	}
	public Status getStatus() {
		return status;
	}
	public void setStatus(Status status) {
		markAsDirty(this.status, status);
		this.status = status;
	}
	public ObsReferenceRange getReferenceRange() {
		return referenceRange;
	}
	public void setReferenceRange(ObsReferenceRange referenceRange) {
		this.referenceRange = referenceRange;
	}
}
package org.openmrs;
import java.util.Date;
import javax.persistence.Column;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.MappedSuperclass;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.Field;
@MappedSuperclass
@Audited
public abstract class BaseOpenmrsData extends BaseOpenmrsObject implements OpenmrsData {
	@ManyToOne(optional = false)
	@JoinColumn(name = "creator", updatable = false)
	protected User creator;
	@Column(name = "date_created", nullable = false, updatable = false)
	private Date dateCreated;
	@ManyToOne
	@JoinColumn(name = "changed_by")
	private User changedBy;
	@Column(name = "date_changed")
	private Date dateChanged;
	@Column(name = "voided", nullable = false)
	@Field
	private Boolean voided = Boolean.FALSE;
	@Column(name = "date_voided")
	private Date dateVoided;
	@ManyToOne
	@JoinColumn(name = "voided_by")
	private User voidedBy;
	@Column(name = "void_reason", length = 255)
	private String voidReason;
	public BaseOpenmrsData() {
	}
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
	@Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	@Override
	@Deprecated
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	@Deprecated
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	@Override
	@Deprecated
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	@Deprecated
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	@Override
	@Deprecated
	@JsonIgnore
	public Boolean isVoided() {
		return getVoided();
	}
	@Override
	public Boolean getVoided() {
		return voided;
	}
	@Override
	public void setVoided(Boolean voided) {
		this.voided = voided;
	}
	@Override
	public Date getDateVoided() {
		return dateVoided;
	}
	@Override
	public void setDateVoided(Date dateVoided) {
		this.dateVoided = dateVoided;
	}
	@Override
	public User getVoidedBy() {
		return voidedBy;
	}
	@Override
	public void setVoidedBy(User voidedBy) {
		this.voidedBy = voidedBy;
	}
	@Override
	public String getVoidReason() {
		return voidReason;
	}
	@Override
	public void setVoidReason(String voidReason) {
		this.voidReason = voidReason;
	}
}
package org.openmrs.propertyeditor;
import org.openmrs.Order;
import org.openmrs.api.context.Context;
public class OrderEditor extends OpenmrsPropertyEditor<Order> {
	@Override
	protected Order getObjectById(Integer id) {
		return Context.getOrderService().getOrder(id);
	}
	@Override
	protected Order getObjectByUuid(String uuid) {
		return Context.getOrderService().getOrderByUuid(uuid);
	}
}
package org.openmrs;
import org.hibernate.envers.Audited;
import org.openmrs.api.APIException;
import org.openmrs.api.db.hibernate.HibernateUtil;
import org.openmrs.order.OrderUtil;
import org.openmrs.util.OpenmrsUtil;
import java.util.Date;
@Audited
public class Order extends BaseCustomizableData<OrderAttribute> implements FormRecordable {
	public static final long serialVersionUID = 4334343L;
	public enum Urgency {
		ROUTINE,
		STAT,
		ON_SCHEDULED_DATE
	}
	public enum Action {
		NEW,
		REVISE,
		DISCONTINUE,
		RENEW
	}
	public enum FulfillerStatus {
		RECEIVED,
		IN_PROGRESS,
		EXCEPTION,
		ON_HOLD,
		DECLINED,
		COMPLETED
	}
	private Integer orderId;
	private Patient patient;
	private OrderType orderType;
	private Concept concept;
	private String instructions;
	private Date dateActivated;
	private Date autoExpireDate;
	private Encounter encounter;
	private Provider orderer;
	private Date dateStopped;
	private Concept orderReason;
	private String accessionNumber;
	private String orderReasonNonCoded;
	private Urgency urgency = Urgency.ROUTINE;
	private String orderNumber;
	private String commentToFulfiller;
	private CareSetting careSetting;
	private Date scheduledDate;
	private String formNamespaceAndPath;
	private Double sortWeight;
	private Order previousOrder;
	private Action action = Action.NEW;
	private OrderGroup orderGroup;
	private FulfillerStatus fulfillerStatus;
	private String fulfillerComment;
	public Order() {
	}
	public Order(Integer orderId) {
		this.orderId = orderId;
	}
	public Order copy() {
		return copyHelper(new Order());
	}
	protected Order copyHelper(Order target) {
		target.setPatient(getPatient());
		target.setOrderType(getOrderType());
		target.setConcept(getConcept());
		target.setInstructions(getInstructions());
		target.setDateActivated(getDateActivated());
		target.setAutoExpireDate(getAutoExpireDate());
		target.setEncounter(getEncounter());
		target.setOrderer(getOrderer());
		target.setCreator(getCreator());
		target.setDateCreated(getDateCreated());
		target.dateStopped = getDateStopped();
		target.setOrderReason(getOrderReason());
		target.setOrderReasonNonCoded(getOrderReasonNonCoded());
		target.setAccessionNumber(getAccessionNumber());
		target.setVoided(getVoided());
		target.setVoidedBy(getVoidedBy());
		target.setDateVoided(getDateVoided());
		target.setVoidReason(getVoidReason());
		target.setUrgency(getUrgency());
		target.setCommentToFulfiller(getCommentToFulfiller());
		target.previousOrder = getPreviousOrder();
		target.action = getAction();
		target.orderNumber = getOrderNumber();
		target.setCareSetting(getCareSetting());
		target.setChangedBy(getChangedBy());
		target.setDateChanged(getDateChanged());
		target.setScheduledDate(getScheduledDate());
		target.setOrderGroup(getOrderGroup());
		target.setSortWeight(getSortWeight());
		target.setFulfillerComment(getFulfillerComment());
		target.setFulfillerStatus(getFulfillerStatus());
		target.setFormNamespaceAndPath(getFormNamespaceAndPath());
		return target;
	}
	public Date getAutoExpireDate() {
		return autoExpireDate;
	}
	public void setAutoExpireDate(Date autoExpireDate) {
		this.autoExpireDate = autoExpireDate;
	}
	public Concept getConcept() {
		return concept;
	}
	public void setConcept(Concept concept) {
		this.concept = concept;
	}
	public Date getScheduledDate() {
		return scheduledDate;
	}
	public void setScheduledDate(Date scheduledDate) {
		this.scheduledDate = scheduledDate;
	}
	public Date getDateStopped() {
		return dateStopped;
	}
	public Concept getOrderReason() {
		return orderReason;
	}
	public void setOrderReason(Concept orderReason) {
		this.orderReason = orderReason;
	}
	public Encounter getEncounter() {
		return encounter;
	}
	public void setEncounter(Encounter encounter) {
		this.encounter = encounter;
	}
	public String getInstructions() {
		return instructions;
	}
	public void setInstructions(String instructions) {
		this.instructions = instructions;
	}
	public String getAccessionNumber() {
		return accessionNumber;
	}
	public void setAccessionNumber(String accessionNumber) {
		this.accessionNumber = accessionNumber;
	}
	public Provider getOrderer() {
		return orderer;
	}
	public void setOrderer(Provider orderer) {
		this.orderer = orderer;
	}
	public Integer getOrderId() {
		return orderId;
	}
	public void setOrderId(Integer orderId) {
		this.orderId = orderId;
	}
	public Date getDateActivated() {
		return dateActivated;
	}
	public void setDateActivated(Date dateActivated) {
		this.dateActivated = dateActivated;
	}
	public String getOrderReasonNonCoded() {
		return orderReasonNonCoded;
	}
	public void setOrderReasonNonCoded(String orderReasonNonCoded) {
		this.orderReasonNonCoded = orderReasonNonCoded;
	}
	public String getCommentToFulfiller() {
		return commentToFulfiller;
	}
	public void setCommentToFulfiller(String commentToFulfiller) {
		this.commentToFulfiller = commentToFulfiller;
	}
	public boolean isActivated() {
		return isActivated(new Date());
	}
	public boolean isActivated(Date checkDate) {
		if (dateActivated == null) {
			return false;
		}
		if (checkDate == null) {
			checkDate = new Date();
		}
		return OpenmrsUtil.compare(dateActivated, checkDate) <= 0;
	}
	public boolean isActive() {
		return isActive(new Date());
	}
	public boolean isActive(Date aCheckDate) {
		if (getVoided() || action == Action.DISCONTINUE) {
			return false;
		}
		Date checkDate = aCheckDate == null ? new Date() : aCheckDate;
		return isActivated(checkDate) && !isDiscontinued(checkDate) && !isExpired(checkDate);
	}
	public boolean isStarted() {
		return isStarted(new Date());
	}
	public boolean isStarted(Date aCheckDate) {
		if (getVoided()) {
			return false;
		}
		if (getEffectiveStartDate() == null) {
			return false;
		}
		Date checkDate = aCheckDate == null ? new Date() : aCheckDate;
		return !checkDate.before(getEffectiveStartDate());
	}
	public boolean isDiscontinued(Date aCheckDate) {
		if (dateStopped != null && autoExpireDate != null && dateStopped.after(autoExpireDate)) {
			throw new APIException("Order.error.invalidDateStoppedAndAutoExpireDate", (Object[]) null);
		}
		if (getVoided()) {
			return false;
		}
		Date checkDate = aCheckDate == null ? new Date() : aCheckDate;
		if (!isActivated(checkDate) || dateStopped == null) {
			return false;
		}
		return checkDate.after(dateStopped);
	}
	public boolean isExpired() {
		return isExpired(new Date());
	}
	public boolean isExpired(Date aCheckDate) {
		if (dateStopped != null && autoExpireDate != null && dateStopped.after(autoExpireDate)) {
			throw new APIException("Order.error.invalidDateStoppedAndAutoExpireDate", (Object[]) null);
		}
		if (getVoided()) {
			return false;
		}
		Date checkDate = aCheckDate == null ? new Date() : aCheckDate;
		if (!isActivated(checkDate)) {
			return false;
		}
		if (isDiscontinued(checkDate) || autoExpireDate == null) {
			return false;
		}
		return checkDate.after(autoExpireDate);
	}
	public boolean isDiscontinuedRightNow() {
		return isDiscontinued(new Date());
	}
	public Patient getPatient() {
		return patient;
	}
	public void setPatient(Patient patient) {
		this.patient = patient;
	}
	@Override
	public Integer getId() {
		return getOrderId();
	}
	@Override
	public String toString() {
		String prefix = Action.DISCONTINUE == getAction() ? "DC " : "";
		return prefix + "Order. orderId: " + orderId + " patient: " + patient + " concept: " + concept + " care setting: "
		        + careSetting;
	}
	@Override
	public void setId(Integer id) {
		setOrderId(id);
	}
	public Urgency getUrgency() {
		return urgency;
	}
	public void setUrgency(Urgency urgency) {
		this.urgency = urgency;
	}
	public String getOrderNumber() {
		return orderNumber;
	}
	public Order getPreviousOrder() {
		return HibernateUtil.getRealObjectFromProxy(previousOrder);
	}
	public void setPreviousOrder(Order previousOrder) {
		this.previousOrder = previousOrder;
	}
	public Action getAction() {
		return action;
	}
	public void setAction(Action action) {
		this.action = action;
	}
	public CareSetting getCareSetting() {
		return careSetting;
	}
	public void setCareSetting(CareSetting careSetting) {
		this.careSetting = careSetting;
	}
	public OrderType getOrderType() {
		return orderType;
	}
	public void setOrderType(OrderType orderType) {
		this.orderType = orderType;
	}
	public Order cloneForDiscontinuing() {
		Order newOrder = new Order();
		newOrder.setCareSetting(getCareSetting());
		newOrder.setConcept(getConcept());
		newOrder.setAction(Action.DISCONTINUE);
		newOrder.setPreviousOrder(this);
		newOrder.setPatient(getPatient());
		newOrder.setOrderType(getOrderType());
		return newOrder;
	}
	public Order cloneForRevision() {
		return cloneForRevisionHelper(new Order());
	}
	protected Order cloneForRevisionHelper(Order target) {
		if (getAction() == Action.DISCONTINUE) {
			target.setAction(Action.DISCONTINUE);
			target.setPreviousOrder(getPreviousOrder());
			target.setDateActivated(getDateActivated());
		} else {
			target.setAction(Action.REVISE);
			target.setPreviousOrder(this);
			target.setAutoExpireDate(getAutoExpireDate());
		}
		target.setCareSetting(getCareSetting());
		target.setConcept(getConcept());
		target.setPatient(getPatient());
		target.setOrderType(getOrderType());
		target.setScheduledDate(getScheduledDate());
		target.setInstructions(getInstructions());
		target.setUrgency(getUrgency());
		target.setCommentToFulfiller(getCommentToFulfiller());
		target.setOrderReason(getOrderReason());
		target.setOrderReasonNonCoded(getOrderReasonNonCoded());
		target.setOrderGroup(getOrderGroup());
		target.setSortWeight(getSortWeight());
		target.setFulfillerStatus(getFulfillerStatus());
		target.setFulfillerComment(getFulfillerComment());
		target.setFormNamespaceAndPath(getFormNamespaceAndPath());
		return target;
	}
	public boolean isType(OrderType orderType) {
		return OrderUtil.isType(orderType, this.orderType);
	}
	public boolean hasSameOrderableAs(Order otherOrder) {
		if (otherOrder == null) {
			return false;
		}
		return OpenmrsUtil.nullSafeEquals(this.getConcept(), otherOrder.getConcept());
	}
	public Date getEffectiveStartDate() {
		return this.urgency == Urgency.ON_SCHEDULED_DATE ? this.getScheduledDate() : this.getDateActivated();
	}
	public Date getEffectiveStopDate() {
		return this.getDateStopped() != null ? this.getDateStopped() : this.getAutoExpireDate();
	}
	public OrderGroup getOrderGroup() {
		return orderGroup;
	}
	public void setOrderGroup(OrderGroup orderGroup) {
		this.orderGroup = orderGroup;
	}
	public Double getSortWeight() {
		return sortWeight;
	}
	public void setSortWeight(Double sortWeight) {
		this.sortWeight = sortWeight;
	}
	public FulfillerStatus getFulfillerStatus() {
		return fulfillerStatus;
	}
	public void setFulfillerStatus(FulfillerStatus fulfillerStatus) {
		this.fulfillerStatus = fulfillerStatus;
	}
	public String getFulfillerComment() {
		return fulfillerComment;
	}
	public void setFulfillerComment(String fulfillerComment) {
		this.fulfillerComment = fulfillerComment;		
	}
	public String getFormNamespaceAndPath() {
		return formNamespaceAndPath;
	}
	public void setFormNamespaceAndPath(String formNamespaceAndPath) {
		this.formNamespaceAndPath = formNamespaceAndPath;
	}
	@Override
	public String getFormFieldNamespace() {
		return BaseFormRecordableOpenmrsData.getFormFieldNamespace(formNamespaceAndPath);
	}
	@Override
	public String getFormFieldPath() {
		return BaseFormRecordableOpenmrsData.getFormFieldPath(formNamespaceAndPath);
	}
	@Override
	public void setFormField(String namespace, String formFieldPath) {
		formNamespaceAndPath = BaseFormRecordableOpenmrsData.getFormNamespaceAndPath(namespace, formFieldPath);
	}
}
package org.openmrs;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import org.hibernate.envers.Audited;
import org.openmrs.api.APIException;
@Audited
public class OrderGroup extends BaseCustomizableData<OrderGroupAttribute> {
	public static final long serialVersionUID = 72232L;
	private Integer orderGroupId;
	private Patient patient;
	private Encounter encounter;
	private List<Order> orders;
	private OrderSet orderSet;
	private OrderGroup parentOrderGroup;
	private Concept orderGroupReason;
	private OrderGroup previousOrderGroup;
	private Set<OrderGroup> nestedOrderGroups;
	public Integer getOrderGroupId() {
		return orderGroupId;
	}
	public void setOrderGroupId(Integer orderGroupId) {
		this.orderGroupId = orderGroupId;
	}
	public Patient getPatient() {
		return patient;
	}
	public void setPatient(Patient patient) {
		this.patient = patient;
	}
	public Encounter getEncounter() {
		return encounter;
	}
	public void setEncounter(Encounter encounter) {
		this.encounter = encounter;
	}
	public List<Order> getOrders() {
		if (orders == null) {
			orders = new ArrayList<>();
		}
		return orders;
	}
	public void setOrders(List<Order> orders) {
		this.orders = orders;
	}
	public void addOrder(Order order) {
		this.addOrder(order, null);
	}
	public void addOrders(List<Order> orders) {
		for (Order order : orders) {
			addOrder(order);
		}
	}
	public void addOrder(Order order, Integer position) {
		if (order == null || getOrders().contains(order)) {
			return;
		}
                order.setOrderGroup(this);  
		Integer listIndex = findListIndexForGivenPosition(position);
		getOrders().add(listIndex, order);
		if (order.getSortWeight() == null) {
			order.setSortWeight(findSortWeight(listIndex));
		}
	}
	private Integer findListIndexForGivenPosition(Integer position) {
		Integer size = getOrders().size();
		if (position != null) {
			if (position < 0 && position >= (-1 - size)) {
				position = position + size + 1;
			} else if (position > size) {
				throw new APIException("Cannot add a member which is out of range of the list");
			}
		} else {
			position = size;
		}
		return position;
	}
	private double findSortWeight(int index) {
		int size = getOrders().size();
		if (size == 1) {
			return 10.0;
		}
		if (index == 0) {
			return getOrders().get(1).getSortWeight() / 2;
		}
		if (index == size - 1) {
			return getOrders().get(index - 1).getSortWeight() + 10.0;
		}
		return (getOrders().get(index - 1).getSortWeight() + getOrders().get(index + 1).getSortWeight()) / 2;
	}
	public OrderSet getOrderSet() {
		return orderSet;
	}
	public void setOrderSet(OrderSet orderSet) {
		this.orderSet = orderSet;
	}
	@Override
	public Integer getId() {
		return getOrderGroupId();
	}
	@Override
	public void setId(Integer id) {
		setOrderGroupId(id);
	}
	public OrderGroup getParentOrderGroup() {
		return parentOrderGroup;
	}
	public void setParentOrderGroup(OrderGroup parentOrderGroup) {
		this.parentOrderGroup = parentOrderGroup;
	}
	public Concept getOrderGroupReason() {
		return orderGroupReason;
	}
	public void setOrderGroupReason(Concept orderGroupReason) {
		this.orderGroupReason = orderGroupReason;
	}
	public OrderGroup getPreviousOrderGroup() {
		return previousOrderGroup;
	}
	public void setPreviousOrderGroup(OrderGroup previousOrderGroup) {
		this.previousOrderGroup = previousOrderGroup;
	}
	public Set<OrderGroup> getNestedOrderGroups() {
		return this.nestedOrderGroups;
	}
	public void setNestedOrderGroups(Set<OrderGroup> nestedOrderGroups) {
		this.nestedOrderGroups = nestedOrderGroups;
	}
}
package org.openmrs.util;
import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Random;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import javax.activation.MimetypesFileTypeMap;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Cohort;
import org.openmrs.Concept;
import org.openmrs.ConceptNumeric;
import org.openmrs.ConceptReferenceRange;
import org.openmrs.Drug;
import org.openmrs.EncounterType;
import org.openmrs.Form;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.PersonAttributeType;
import org.openmrs.Program;
import org.openmrs.ProgramWorkflowState;
import org.openmrs.User;
import org.openmrs.annotation.AddOnStartup;
import org.openmrs.annotation.HasAddOnStartupPrivileges;
import org.openmrs.annotation.Logging;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.ConceptService;
import org.openmrs.api.InvalidCharactersPasswordException;
import org.openmrs.api.PasswordException;
import org.openmrs.api.ShortPasswordException;
import org.openmrs.api.WeakPasswordException;
import org.openmrs.api.context.Context;
import org.openmrs.logging.OpenmrsLoggingUtil;
import org.openmrs.module.ModuleException;
import org.openmrs.module.ModuleFactory;
import org.openmrs.propertyeditor.CohortEditor;
import org.openmrs.propertyeditor.ConceptEditor;
import org.openmrs.propertyeditor.DrugEditor;
import org.openmrs.propertyeditor.EncounterTypeEditor;
import org.openmrs.propertyeditor.FormEditor;
import org.openmrs.propertyeditor.LocationEditor;
import org.openmrs.propertyeditor.PersonAttributeTypeEditor;
import org.openmrs.propertyeditor.ProgramEditor;
import org.openmrs.propertyeditor.ProgramWorkflowStateEditor;
import org.openmrs.validator.ObsValidator;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;
import org.springframework.beans.propertyeditors.CustomDateEditor;
import org.springframework.context.NoSuchMessageException;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
public class OpenmrsUtil {
	private OpenmrsUtil() {
	}
	private static volatile MimetypesFileTypeMap mimetypesFileTypeMap = null;
	private static org.slf4j.Logger log = LoggerFactory.getLogger(OpenmrsUtil.class);
	private static Map<Locale, SimpleDateFormat> dateFormatCache = new HashMap<>();
	private static Map<Locale, SimpleDateFormat> timeFormatCache = new HashMap<>();
	public static <E> Collection<Collection<E>> compareLists(Collection<E> origList, Collection<E> newList) {	
		Collection<Collection<E>> returnList = new ArrayList<>();
		Collection<E> toAdd = new LinkedList<>();
		Collection<E> toDel = new LinkedList<>();
		for (E currentNewListObj : newList) {
			boolean foundInList = false;
			for (E currentOrigListObj : origList) {
				if (currentNewListObj.equals(currentOrigListObj)) {
					foundInList = true;
					origList.remove(currentOrigListObj);
					break;
				}
			}
			if (!foundInList) {
				toAdd.add(currentNewListObj);
			}
			toDel = origList;
		}
		returnList.add(toAdd);
		returnList.add(toDel);
		return returnList;
	}
	public static boolean isStringInArray(String str, String[] arr) {
		if (str != null && arr != null) {
			for (String anArr : arr) {
				if (str.equals(anArr)) {
					return true;
				}
			}
		}
		return false;
	}
	public static Boolean isInNormalNumericRange(Float value, ConceptNumeric concept) {
		if (concept.getHiNormal() == null || concept.getLowNormal() == null) {
			return false;
		}
		return (value <= concept.getHiNormal() && value >= concept.getLowNormal());
	}
	public static Boolean isInCriticalNumericRange(Float value, ConceptNumeric concept) {
		if (concept.getHiCritical() == null || concept.getLowCritical() == null) {
			return false;
		}
		return (value <= concept.getHiCritical() && value >= concept.getLowCritical());
	}
	public static Boolean isInAbsoluteNumericRange(Float value, ConceptNumeric concept) {
		if (concept.getHiAbsolute() == null || concept.getLowAbsolute() == null) {
			return false;
		}
		return (value <= concept.getHiAbsolute() && value >= concept.getLowAbsolute());
	}
	public static Boolean isValidNumericValue(Float value, ConceptNumeric concept) {
		if (concept.getHiAbsolute() == null || concept.getLowAbsolute() == null) {
			return true;
		}
		return (value <= concept.getHiAbsolute() && value >= concept.getLowAbsolute());
	}
	public static String getFileAsString(File file) throws IOException {
		StringBuilder fileData = new StringBuilder(1000);
		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8));
		char[] buf = new char[1024];
		int numRead;
		while ((numRead = reader.read(buf)) != -1) {
			String readData = String.valueOf(buf, 0, numRead);
			fileData.append(readData);
			buf = new char[1024];
		}
		reader.close();
		return fileData.toString();
	}
	public static byte[] getFileAsBytes(File file) throws IOException {
		FileInputStream fileInputStream = null;
		try {
			fileInputStream = new FileInputStream(file);
			byte[] b = new byte[fileInputStream.available()];
			fileInputStream.read(b);
			return b;
		}
		catch (Exception e) {
			log.error("Unable to get file as byte array", e);
		}
		finally {
			if (fileInputStream != null) {
				try {
					fileInputStream.close();
				}
				catch (IOException io) {
					log.warn("Couldn't close fileInputStream: " + io);
				}
			}
		}
		return null;
	}
	public static void copyFile(InputStream inputStream, OutputStream outputStream) throws IOException {
		if (inputStream == null || outputStream == null) {
			if (outputStream != null) {
				IOUtils.closeQuietly(outputStream);
			}
			return;
		}
		try {
			IOUtils.copy(inputStream, outputStream);
		}
		finally {
			IOUtils.closeQuietly(outputStream);
		}
	}
	public static String getFileMimeType(File file) {
		if (mimetypesFileTypeMap == null) {
			synchronized (OpenmrsUtil.class) {
				mimetypesFileTypeMap = new MimetypesFileTypeMap();
			}
		}
		return mimetypesFileTypeMap.getContentType(file);
	}
	public static boolean folderContains(File folder, String filename) {
		if (folder == null) {
			return false;
		}
		if (!folder.isDirectory()) {
			return false;
		}
		File[] files = folder.listFiles();
		if (files == null) {
			return false;
		}
		for (File f : files) {
			if (f.getName().equals(filename)) {
				return true;
			}
		}
		return false;
	}
	public static Map<String, String> getCorePrivileges() {
		Map<String, String> corePrivileges = new HashMap<>();
		Set<Class<?>> classes = OpenmrsClassScanner.getInstance().getClassesWithAnnotation(HasAddOnStartupPrivileges.class);
		for (Class cls : classes) {
			Field[] flds = cls.getDeclaredFields();
			for (Field fld : flds) {
				String fieldValue = null;
				AddOnStartup privilegeAnnotation = fld.getAnnotation(AddOnStartup.class);
				if (null == privilegeAnnotation) {
					continue;
				}
				if (!privilegeAnnotation.core()) {
					continue;
				}
				try {
					fieldValue = (String) fld.get(null);
				}
				catch (IllegalAccessException e) {
					log.error("Field is inaccessible.", e);
				}
				corePrivileges.put(fieldValue, privilegeAnnotation.description());
			}
		}
		for (org.openmrs.Privilege privilege : ModuleFactory.getPrivileges()) {
			corePrivileges.put(privilege.getPrivilege(), privilege.getDescription());
		}
		return corePrivileges;
	}
	public static Map<String, String> getCoreRoles() {
		Map<String, String> roles = new HashMap<>();
		Field[] flds = RoleConstants.class.getDeclaredFields();
		for (Field fld : flds) {
			String fieldValue = null;
			AddOnStartup roleAnnotation = fld.getAnnotation(AddOnStartup.class);
			if (null == roleAnnotation) {
				continue;
			}
			if (!roleAnnotation.core()) {
				continue;
			}
			try {
				fieldValue = (String) fld.get(null);
			}
			catch (IllegalAccessException e) {
				log.error("Field is inaccessible.", e);
			}
			roles.put(fieldValue, roleAnnotation.description());
		}
		return roles;
	}
	public static void startup(Properties p) {
		String val = p.getProperty("obscure_patients", null);
		if (val != null && "true".equalsIgnoreCase(val)) {
			OpenmrsConstants.OBSCURE_PATIENTS = true;
		}
		val = p.getProperty("obscure_patients.family_name", null);
		if (val != null) {
			OpenmrsConstants.OBSCURE_PATIENTS_FAMILY_NAME = val;
		}
		val = p.getProperty("obscure_patients.given_name", null);
		if (val != null) {
			OpenmrsConstants.OBSCURE_PATIENTS_GIVEN_NAME = val;
		}
		val = p.getProperty("obscure_patients.middle_name", null);
		if (val != null) {
			OpenmrsConstants.OBSCURE_PATIENTS_MIDDLE_NAME = val;
		}
		val = p.getProperty("connection.database_name", null);
		if (val == null) {
			val = p.getProperty("connection.url", null);
			if (val != null) {
				try {
					int endIndex = val.lastIndexOf("?");
					if (endIndex == -1) {
						endIndex = val.length();
					}
					int startIndex = val.lastIndexOf("/", endIndex);
					val = val.substring(startIndex + 1, endIndex);
					OpenmrsConstants.DATABASE_NAME = val;
				}
				catch (Exception e) {
					log.error(MarkerFactory.getMarker("FATAL"), "Database name cannot be configured from 'connection.url' ."
					        + "Either supply 'connection.database_name' or correct the url",
					    e);
				}
			}
		}
		val = p.getProperty("connection.database_business_name", null);
		if (val == null) {
			val = OpenmrsConstants.DATABASE_NAME;
		}
		OpenmrsConstants.DATABASE_BUSINESS_NAME = val;
	}
	@Deprecated
	public static MemoryAppender getMemoryAppender() {
		return new MemoryAppender(OpenmrsLoggingUtil.getMemoryAppender());
	}
	@Logging(ignore = true)
	@Deprecated
	public static void applyLogLevels() {
		OpenmrsLoggingUtil.applyLogLevels();
	}
	@Deprecated
	public static void setupLogAppenders() {
		OpenmrsLoggingUtil.reloadLoggingConfiguration();
	}
	@Deprecated
	public static void applyLogLevel(String logClass, String logLevel) {
		OpenmrsLoggingUtil.applyLogLevel(logClass, logLevel);
	}
	public static Map<String, String> parseParameterList(String paramList) {
		Map<String, String> ret = new HashMap<>();
		if (paramList != null && paramList.length() > 0) {
			String[] args = paramList.split("\\|");
			for (String s : args) {
				int ind = s.indexOf('=');
				if (ind <= 0) {
					throw new IllegalArgumentException(
					        "Misformed argument in dynamic page specification string: '" + s + "' is not 'key=value'.");
				}
				String name = s.substring(0, ind);
				String value = s.substring(ind + 1);
				ret.put(name, value);
			}
		}
		return ret;
	}
	public static <Arg1, Arg2 extends Arg1> boolean nullSafeEquals(Arg1 d1, Arg2 d2) {
		if (d1 == null) {
			return d2 == null;
		} else if (d2 == null) {
			return false;
		}
		return (d1 instanceof Date && d2 instanceof Date) ? compare((Date) d1, (Date) d2) == 0 : d1.equals(d2);
	}
	public static int compare(Date d1, Date d2) {
		if (d1 instanceof Timestamp && d2 instanceof Timestamp) {
			return d1.compareTo(d2);
		}
		if (d1 instanceof Timestamp) {
			d1 = new Date(d1.getTime());
		}
		if (d2 instanceof Timestamp) {
			d2 = new Date(d2.getTime());
		}
		return d1.compareTo(d2);
	}
	public static int compareWithNullAsEarliest(Date d1, Date d2) {
		if (d1 == null && d2 == null) {
			return 0;
		}
		if (d1 == null) {
			return -1;
		} else if (d2 == null) {
			return 1;
		} else {
			return compare(d1, d2);
		}
	}
	public static int compareWithNullAsLatest(Date d1, Date d2) {
		if (d1 == null && d2 == null) {
			return 0;
		}
		if (d1 == null) {
			return 1;
		} else if (d2 == null) {
			return -1;
		} else {
			return compare(d1, d2);
		}
	}
	public static <E extends Comparable<E>> int compareWithNullAsLowest(E c1, E c2) {
		if (c1 == null && c2 == null) {
			return 0;
		}
		if (c1 == null) {
			return -1;
		} else if (c2 == null) {
			return 1;
		} else {
			return c1.compareTo(c2);
		}
	}
	public static <E extends Comparable<E>> int compareWithNullAsGreatest(E c1, E c2) {
		if (c1 == null && c2 == null) {
			return 0;
		}
		if (c1 == null) {
			return 1;
		} else if (c2 == null) {
			return -1;
		} else {
			return c1.compareTo(c2);
		}
	}
	@Deprecated
	public static <E> String join(Collection<E> c, String separator) {
		if (c == null) {
			return "";
		}
		StringBuilder ret = new StringBuilder();
		for (Iterator<E> i = c.iterator(); i.hasNext();) {
			ret.append(i.next());
			if (i.hasNext()) {
				ret.append(separator);
			}
		}
		return ret.toString();
	}
	public static Set<Concept> conceptSetHelper(String descriptor) {
		Set<Concept> ret = new HashSet<>();
		if (descriptor == null || descriptor.length() == 0) {
			return ret;
		}
		ConceptService cs = Context.getConceptService();
		for (StringTokenizer st = new StringTokenizer(descriptor, "|"); st.hasMoreTokens();) {
			String s = st.nextToken().trim();
			boolean isSet = s.startsWith("set:");
			if (isSet) {
				s = s.substring(4).trim();
			}
			Concept c = null;
			if (s.startsWith("name:")) {
				String name = s.substring(5).trim();
				c = cs.getConceptByName(name);
			} else {
				try {
					c = cs.getConcept(Integer.valueOf(s.trim()));
				}
				catch (Exception ex) {}
			}
			if (c != null) {
				if (isSet) {
					List<Concept> inSet = cs.getConceptsByConceptSet(c);
					ret.addAll(inSet);
				} else {
					ret.add(c);
				}
			}
		}
		return ret;
	}
	public static List<Concept> delimitedStringToConceptList(String delimitedString, String delimiter) {
		List<Concept> ret = null;
		if (delimitedString != null) {
			String[] tokens = delimitedString.split(delimiter);
			for (String token : tokens) {
				Integer conceptId;
				try {
					conceptId = Integer.valueOf(token);
				}
				catch (NumberFormatException nfe) {
					conceptId = null;
				}
				Concept c;
				if (conceptId != null) {
					c = Context.getConceptService().getConcept(conceptId);
				} else {
					c = Context.getConceptService().getConceptByName(token);
				}
				if (c != null) {
					if (ret == null) {
						ret = new ArrayList<>();
					}
					ret.add(c);
				}
			}
		}
		return ret;
	}
	public static Map<String, Concept> delimitedStringToConceptMap(String delimitedString, String delimiter) {
		Map<String, Concept> ret = null;
		if (delimitedString != null) {
			String[] tokens = delimitedString.split(delimiter);
			for (String token : tokens) {
				Concept c = Context.getConceptService().getConcept(token);
				if (c != null) {
					if (ret == null) {
						ret = new HashMap<>();
					}
					ret.put(token, c);
				}
			}
		}
		return ret;
	}
	public static List<Concept> conceptListHelper(String descriptor) {
		Set<Concept> ret = new LinkedHashSet<>();
		if (descriptor == null || descriptor.length() == 0) {
			return Collections.emptyList();
		}
		ConceptService cs = Context.getConceptService();
		for (StringTokenizer st = new StringTokenizer(descriptor, "|"); st.hasMoreTokens();) {
			String s = st.nextToken().trim();
			boolean isSet = s.startsWith("set:");
			if (isSet) {
				s = s.substring(4).trim();
			}
			Concept c = null;
			if (s.startsWith("name:")) {
				String name = s.substring(5).trim();
				c = cs.getConceptByName(name);
			} else {
				try {
					c = cs.getConcept(Integer.valueOf(s.trim()));
				}
				catch (Exception ex) {}
			}
			if (c != null) {
				if (isSet) {
					List<Concept> inSet = cs.getConceptsByConceptSet(c);
					ret.addAll(inSet);
				} else {
					ret.add(c);
				}
			}
		}
		return new ArrayList<>(ret);
	}
	public static Date getLastMomentOfDay(Date day) {
		Calendar calender = Calendar.getInstance();
		calender.setTime(day);
		calender.set(Calendar.HOUR_OF_DAY, 23);
		calender.set(Calendar.MINUTE, 59);
		calender.set(Calendar.SECOND, 59);
		calender.set(Calendar.MILLISECOND, 999);
		return calender.getTime();
	}
	public static Date firstSecondOfDay(Date date) {
		if (date == null) {
			return null;
		}
		Calendar c = Calendar.getInstance();
		c.setTime(date);
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		c.set(Calendar.MILLISECOND, 0);
		return c.getTime();
	}
	public static Date safeDate(Date d1) {
		return new Date(d1.getTime());
	}
	public static boolean deleteDirectory(File dir) throws IOException {
		if (!dir.exists() || !dir.isDirectory()) {
			throw new IOException("Could not delete directory '" + dir.getAbsolutePath() + "' (not a directory)");
		}
		log.debug("Deleting directory {}", dir.getAbsolutePath());
		File[] fileList = dir.listFiles();
		if (fileList == null) {
			return false;
		}
		for (File f : fileList) {
			if (f.isDirectory()) {
				deleteDirectory(f);
			}
			boolean success = f.delete();
			if (log.isDebugEnabled()) {
				log.debug("   deleting " + f.getName() + " : " + (success ? "ok" : "failed"));
			}
			if (!success) {
				f.deleteOnExit();
			}
		}
		boolean success = dir.delete();
		if (!success) {
			log.warn("   ...could not remove directory: " + dir.getAbsolutePath());
			dir.deleteOnExit();
		}
		if (success && log.isDebugEnabled()) {
			log.debug("   ...and directory itself");
		}
		return success;
	}
	public static File url2file(final URL url) {
		if (url == null || !"file".equalsIgnoreCase(url.getProtocol())) {
			return null;
		}
		return new File(url.getFile().replaceAll("%20", " "));
	}
	public static InputStream getResourceInputStream(final URL url) throws IOException {
		File file = url2file(url);
		if (file != null) {
			return new BufferedInputStream(new FileInputStream(file));
		}
		if (!"jar".equalsIgnoreCase(url.getProtocol())) {
			return url.openStream();
		}
		String urlStr = url.toExternalForm();
		if (urlStr.endsWith("!/")) {
			throw new FileNotFoundException(url.toExternalForm());
		}
		int p = urlStr.indexOf("!/");
		if (p == -1) {
			throw new MalformedURLException(url.toExternalForm());
		}
		String path = urlStr.substring(p + 2);
		file = url2file(new URL(urlStr.substring(4, p)));
		if (file == null) {
			return url.openStream();
		}
		try (JarFile jarFile = new JarFile(file)) {
			ZipEntry entry = jarFile.getEntry(path);
			if (entry == null) {
				throw new FileNotFoundException(url.toExternalForm());
			}
			try (InputStream in = jarFile.getInputStream(entry)) {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				copyFile(in, out);
				return new ByteArrayInputStream(out.toByteArray());
			}
		}
	}
	public static String getApplicationDataDirectory() {
		return getApplicationDataDirectoryAsFile().toString();
	}
	public static File getApplicationDataDirectoryAsFile() {
		String filepath = null;
		final String openmrsDir = "OpenMRS";
		String systemProperty = System.getProperty(OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY);
		if (StringUtils.isNotBlank(systemProperty)) {
			filepath = systemProperty;
		} else {
			String runtimeProperty = Context.getRuntimeProperties()
				.getProperty(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_RUNTIME_PROPERTY, null);
			if (StringUtils.isNotBlank(runtimeProperty)) {
				filepath = runtimeProperty;
			}
		}
		if (filepath == null) {
			if (OpenmrsConstants.UNIX_BASED_OPERATING_SYSTEM) {
				filepath = Paths.get(System.getProperty("user.home"), "." + openmrsDir).toString();
				if (!canWrite(new File(filepath))) {
					log.warn("Unable to write to users home dir, fallback to: "
						+ OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_UNIX);
					filepath = Paths.get(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_UNIX, openmrsDir).toString();
				}
			} else {
				filepath = Paths.get(System.getProperty("user.home"), "Application Data", "OpenMRS").toString();
				if (!new File(filepath).exists()) {
					filepath = Paths.get(System.getenv("appdata"), "OpenMRS").toString();
				}
				if (!canWrite(new File(filepath))) {
					log.warn("Unable to write to users home dir, fallback to: "
						+ OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_WIN);
					filepath = OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_WIN + File.separator + openmrsDir;
				}
			}
			filepath = filepath + File.separator;
		}
		File folder = new File(filepath);
		if (!folder.exists()) {
			folder.mkdirs();
		}
		return folder;
	}
	public static void setApplicationDataDirectory(String path) {
		if (StringUtils.isBlank(path)) {
			System.clearProperty(OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY);
		} else {
			System.setProperty(OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY, path);
		}
	}
	private static boolean canWrite(File folder) {
		try {
			if (!folder.exists()) {
				folder.mkdirs();
			}
			return folder.canWrite();
		}
		catch (SecurityException ex) {
		}
		return false;
	}
	@Deprecated
	public static String getOpenmrsLogLocation() {
		return OpenmrsLoggingUtil.getOpenmrsLogLocation();
	}
	public static void validateJavaVersion() {
		if (System.getProperty("java.version").matches("1\\.[0-7]\\.(.*)")) {
			throw new APIException(
				"OpenMRS " + OpenmrsConstants.OPENMRS_VERSION_SHORT + " requires Java 8 and above, but is running under " + 
					System.getProperty("java.version"));
		}
	}
	public static File getDirectoryInApplicationDataDirectory(String folderName) throws APIException {
		File folder = new File(folderName);
		if (!folder.isAbsolute()) {
			folder = new File(getApplicationDataDirectoryAsFile(), folderName);
		}
		if (!folder.exists()) {
			log.warn("'" + folder.getAbsolutePath() + "' doesn't exist.  Creating directories now.");
			folder.mkdirs();
		}
		if (!folder.isDirectory()) {
			throw new APIException("should.be.directory", new Object[] { folder.getAbsolutePath() });
		}
		return folder;
	}
	public static void saveDocument(Document doc, File outFile) {
		OutputStream outStream = null;
		try {
			outStream = new FileOutputStream(outFile);
			TransformerFactory tFactory = TransformerFactory.newInstance();
			Transformer transformer = tFactory.newTransformer();
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			DocumentType doctype = doc.getDoctype();
			if (doctype != null) {
				transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctype.getPublicId());
				transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctype.getSystemId());
			}
			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(outStream);
			transformer.transform(source, result);
		}
		catch (TransformerException e) {
			throw new ModuleException("Error while saving dwrmodulexml back to dwr-modules.xml", e);
		}
		catch (FileNotFoundException e) {
			throw new ModuleException(outFile.getAbsolutePath() + " file doesn't exist.", e);
		}
		finally {
			try {
				if (outStream != null) {
					outStream.close();
				}
			}
			catch (Exception e) {
				log.warn("Unable to close outstream", e);
			}
		}
	}
	public static List<Integer> delimitedStringToIntegerList(String delimitedString, String delimiter) {
		List<Integer> ret = new ArrayList<>();
		String[] tokens = delimitedString.split(delimiter);
		for (String token : tokens) {
			token = token.trim();
			if (token.length() != 0) {
				ret.add(Integer.valueOf(token));
			}
		}
		return ret;
	}
	public static boolean stringStartsWith(String str, String[] prefixes) {
		for (String prefix : prefixes) {
			if (StringUtils.startsWith(str, prefix)) {
				return true;
			}
		}
		return false;
	}
	public static boolean isConceptInList(Concept concept, List<Concept> list) {
		boolean ret = false;
		if (concept != null && list != null) {
			for (Concept c : list) {
				if (c.equals(concept)) {
					ret = true;
					break;
				}
			}
		}
		return ret;
	}
	public static Date fromDateHelper(Date comparisonDate, Integer withinLastDays, Integer withinLastMonths,
	        Integer untilDaysAgo, Integer untilMonthsAgo, Date sinceDate, Date untilDate) {
		Date ret = null;
		if (withinLastDays != null || withinLastMonths != null) {
			Calendar gc = Calendar.getInstance();
			gc.setTime(comparisonDate != null ? comparisonDate : new Date());
			if (withinLastDays != null) {
				gc.add(Calendar.DAY_OF_MONTH, -withinLastDays);
			}
			if (withinLastMonths != null) {
				gc.add(Calendar.MONTH, -withinLastMonths);
			}
			ret = gc.getTime();
		}
		if (sinceDate != null && (ret == null || sinceDate.after(ret))) {
			ret = sinceDate;
		}
		return ret;
	}
	public static Date toDateHelper(Date comparisonDate, Integer withinLastDays, Integer withinLastMonths,
	        Integer untilDaysAgo, Integer untilMonthsAgo, Date sinceDate, Date untilDate) {
		Date ret = null;
		if (untilDaysAgo != null || untilMonthsAgo != null) {
			Calendar gc = Calendar.getInstance();
			gc.setTime(comparisonDate != null ? comparisonDate : new Date());
			if (untilDaysAgo != null) {
				gc.add(Calendar.DAY_OF_MONTH, -untilDaysAgo);
			}
			if (untilMonthsAgo != null) {
				gc.add(Calendar.MONTH, -untilMonthsAgo);
			}
			ret = gc.getTime();
		}
		if (untilDate != null && (ret == null || untilDate.before(ret))) {
			ret = untilDate;
		}
		return ret;
	}
	public static <T> boolean containsAny(Collection<T> collection, Collection<T> elements) {
		for (T obj : elements) {
			if (collection.contains(obj)) {
				return true;
			}
		}
		return false;
	}
	public static <K, V> void addToSetMap(Map<K, Set<V>> map, K key, V obj) {
		Set<V> set = map.computeIfAbsent(key, k -> new HashSet<>());
		set.add(obj);
	}
	public static <K, V> void addToListMap(Map<K, List<V>> map, K key, V obj) {
		List<V> list = map.computeIfAbsent(key, k -> new ArrayList<>());
		list.add(obj);
	}
	public static SimpleDateFormat getDateFormat(Locale locale) {
		if (dateFormatCache.containsKey(locale)) {
			return (SimpleDateFormat) dateFormatCache.get(locale).clone();
		}
		SimpleDateFormat sdf = new OpenmrsDateFormat((SimpleDateFormat) DateFormat.getDateInstance(DateFormat.SHORT, locale),
		        locale);
		String pattern = sdf.toPattern();
		if (!pattern.contains("yyyy")) {
			String regex = "yy";
			if (!pattern.contains("yy")) {
				regex = "y";
			}
			pattern = pattern.replaceFirst(regex, "yyyy");
			sdf.applyPattern(pattern);
		}
		if (!pattern.contains("MM")) {
			pattern = pattern.replaceFirst("M", "MM");
			sdf.applyPattern(pattern);
		}
		if (!pattern.contains("dd")) {
			pattern = pattern.replaceFirst("d", "dd");
			sdf.applyPattern(pattern);
		}
		dateFormatCache.put(locale, sdf);
		return (SimpleDateFormat) sdf.clone();
	}
	public static SimpleDateFormat getTimeFormat(Locale locale) {
		if (timeFormatCache.containsKey(locale)) {
			return (SimpleDateFormat) timeFormatCache.get(locale).clone();
		}
		SimpleDateFormat sdf = (SimpleDateFormat) DateFormat.getTimeInstance(DateFormat.SHORT, locale);
		String pattern = sdf.toPattern();
		if (!(pattern.contains("hh") || pattern.contains("HH"))) {
			pattern = pattern.replaceFirst("h", "hh").replaceFirst("H", "HH");
			sdf.applyPattern(pattern);
		}
		timeFormatCache.put(locale, sdf);
		return (SimpleDateFormat) sdf.clone();
	}
	public static SimpleDateFormat getDateTimeFormat(Locale locale) {
		SimpleDateFormat dateFormat;
		SimpleDateFormat timeFormat;
		dateFormat = getDateFormat(locale);
		timeFormat = getTimeFormat(locale);
		String pattern = dateFormat.toPattern() + " " + timeFormat.toPattern();
		SimpleDateFormat sdf = new SimpleDateFormat();
		sdf.applyPattern(pattern);
		return sdf;
	}
	@SuppressWarnings("unchecked")
	public static Object parse(String string, Class clazz) {
		try {
			Method valueOfMethod = null;
			try {
				valueOfMethod = clazz.getMethod("valueOf", String.class);
			}
			catch (NoSuchMethodException ex) {}
			if (valueOfMethod != null) {
				return valueOfMethod.invoke(null, string);
			} else if (clazz.isEnum()) {
				List<Enum> constants = Arrays.asList((Enum[]) clazz.getEnumConstants());
				for (Enum e : constants) {
					if (e.toString().equals(string)) {
						return e;
					}
				}
				throw new IllegalArgumentException(string + " is not a legal value of enum class " + clazz);
			} else if (String.class.equals(clazz)) {
				return string;
			} else if (Location.class.equals(clazz)) {
				try {
					Integer.parseInt(string);
					LocationEditor ed = new LocationEditor();
					ed.setAsText(string);
					return ed.getValue();
				}
				catch (NumberFormatException ex) {
					return Context.getLocationService().getLocation(string);
				}
			} else if (Concept.class.equals(clazz)) {
				ConceptEditor ed = new ConceptEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Program.class.equals(clazz)) {
				ProgramEditor ed = new ProgramEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (ProgramWorkflowState.class.equals(clazz)) {
				ProgramWorkflowStateEditor ed = new ProgramWorkflowStateEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (EncounterType.class.equals(clazz)) {
				EncounterTypeEditor ed = new EncounterTypeEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Form.class.equals(clazz)) {
				FormEditor ed = new FormEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Drug.class.equals(clazz)) {
				DrugEditor ed = new DrugEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (PersonAttributeType.class.equals(clazz)) {
				PersonAttributeTypeEditor ed = new PersonAttributeTypeEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Cohort.class.equals(clazz)) {
				CohortEditor ed = new CohortEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Date.class.equals(clazz)) {
				CustomDateEditor ed = new CustomDateEditor(Context.getDateFormat(), true, 10);
				ed.setAsText(string);
				return ed.getValue();
			} else if (Object.class.equals(clazz)) {
				return string;
			} else {
				throw new IllegalArgumentException("Don't know how to handle class: " + clazz);
			}
		}
		catch (Exception ex) {
			log.error("error converting \"" + string + "\" to " + clazz, ex);
			throw new IllegalArgumentException(ex);
		}
	}
	public static boolean collectionContains(Collection<?> objects, Object obj) {
		if (obj == null || objects == null) {
			return false;
		}
		for (Object o : objects) {
			if (o != null && o.equals(obj)) {
				return true;
			}
		}
		return false;
	}
	public static File getOutFile(File dir, Date date, User user) {
		Random gen = new Random();
		File outFile;
		do {
			DateFormat dateFormat = new SimpleDateFormat("yyyy.MM.dd-HHmm-ssSSS");
			if (date == null) {
				date = new Date();
			}
			StringBuilder filename = new StringBuilder();
			filename.append(dateFormat.format(date));
			if (user != null) {
				filename.append("-");
				filename.append(user.getUserId());
				filename.append("-");
			}
			filename.append(gen.nextInt() * 10000);
			filename.append(".xml");
			outFile = new File(dir, filename.toString());
			date = null;
		} while (outFile.exists());
		return outFile;
	}
	public static String generateUid(Integer size) {
		Random gen = new Random();
		StringBuilder sb = new StringBuilder(size);
		for (int i = 0; i < size; i++) {
			int ch = gen.nextInt() * 62;
			if (ch < 10) {
				sb.append(ch);
			} else if (ch < 36) {
				sb.append((char) (ch - 10 + 'a'));
			} else {
				sb.append((char) (ch - 36 + 'A'));
			}
		}
		return sb.toString();
	}
	public static String generateUid() {
		return generateUid(20);
	}
	public static void storeProperties(Properties properties, File file, String comment) {
		OutputStream outStream = null;
		try {
			outStream = new FileOutputStream(file, true);
			storeProperties(properties, outStream, comment);
		}
		catch (IOException ex) {
			log.error("Unable to create file " + file.getAbsolutePath() + " in storeProperties routine.");
		}
		finally {
			try {
				if (outStream != null) {
					outStream.close();
				}
			}
			catch (IOException ioe) {
			}
		}
	}
	public static void storeProperties(Properties properties, OutputStream outStream, String comment) {
		try {
			Charset utf8 = StandardCharsets.UTF_8;
			properties.store(new OutputStreamWriter(outStream, utf8), comment);
		}
		catch (FileNotFoundException fnfe) {
			log.error("target file not found" + fnfe);
		}
		catch (UnsupportedEncodingException ex) { 
			log.error("unsupported encoding error hit" + ex);
		}
		catch (IOException ioex) {
			log.error("IO exception encountered trying to append to properties file" + ioex);
		}
	}
	public static void loadProperties(Properties props, InputStream inputStream) {
		InputStreamReader reader = null;
		try {
			reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);
			props.load(reader);
		}
		catch (FileNotFoundException fnfe) {
			log.error("Unable to find properties file" + fnfe);
		}
		catch (UnsupportedEncodingException uee) {
			log.error("Unsupported encoding used in properties file" + uee);
		}
		catch (IOException ioe) {
			log.error("Unable to read properties from properties file" + ioe);
		}
		finally {
			try {
				if (reader != null) {
					reader.close();
				}
			}
			catch (IOException ioe) {
				log.error("Unable to close properties file " + ioe);
			}
		}
	}
	public static void loadProperties(Properties props, File propertyFile) {
		try {
			loadProperties(props, new FileInputStream(propertyFile));
		}
		catch (FileNotFoundException fnfe) {
			log.error("Unable to find properties file" + fnfe);
		}
	}
	public static String getMessage(String code, Object... args) {
		Locale l = Context.getLocale();
		try {
			String translation = Context.getMessageSourceService().getMessage(code, args, l);
			if (translation != null) {
				return translation;
			}
		}
		catch (NoSuchMessageException e) {
			log.warn("Message code <" + code + "> not found for locale " + l);
		}
		catch (APIException apiEx) {
			log.debug("Unable to get code: " + code, apiEx);
			return code;
		}
		return code;
	}
	public static void validatePassword(String username, String password, String systemId) throws PasswordException {
		String userGp = "true";
		String lengthGp = "8";
		String caseGp = "true";
		String digitGp = "true";
		String nonDigitGp = "true";
		String regexGp = null;
		AdministrationService svc = null;
		try {
			svc = Context.getAdministrationService();
		}
		catch (APIException apiEx) {
			log.debug("Unable to get global properties", apiEx);
		}
		if (svc != null && Context.isSessionOpen()) {
			userGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_CANNOT_MATCH_USERNAME_OR_SYSTEMID, userGp);
			lengthGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_MINIMUM_LENGTH, lengthGp);
			caseGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_REQUIRES_UPPER_AND_LOWER_CASE, caseGp);
			digitGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_REQUIRES_DIGIT, digitGp);
			nonDigitGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_REQUIRES_NON_DIGIT, nonDigitGp);
			regexGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_CUSTOM_REGEX, regexGp);
		}
		if (password == null) {
			throw new WeakPasswordException();
		}
		if ("true".equals(userGp) && (password.equals(username) || password.equals(systemId))) {
			throw new WeakPasswordException();
		}
		if (StringUtils.isNotEmpty(lengthGp)) {
			try {
				int minLength = Integer.parseInt(lengthGp);
				if (password.length() < minLength) {
					throw new ShortPasswordException(getMessage("error.password.length", lengthGp));
				}
			}
			catch (NumberFormatException nfe) {
				log.warn(
				    "Error in global property <" + OpenmrsConstants.GP_PASSWORD_MINIMUM_LENGTH + "> must be an Integer");
			}
		}
		if ("true".equals(caseGp) && !containsUpperAndLowerCase(password)) {
			throw new InvalidCharactersPasswordException(getMessage("error.password.requireMixedCase"));
		}
		if ("true".equals(digitGp) && !containsDigit(password)) {
			throw new InvalidCharactersPasswordException(getMessage("error.password.requireNumber"));
		}
		if ("true".equals(nonDigitGp) && containsOnlyDigits(password)) {
			throw new InvalidCharactersPasswordException(getMessage("error.password.requireLetter"));
		}
		if (StringUtils.isNotEmpty(regexGp)) {
			try {
				Pattern pattern = Pattern.compile(regexGp);
				Matcher matcher = pattern.matcher(password);
				if (!matcher.matches()) {
					throw new InvalidCharactersPasswordException(getMessage("error.password.different"));
				}
			}
			catch (PatternSyntaxException pse) {
				log.warn("Invalid regex of " + regexGp + " defined in global property <"
				        + OpenmrsConstants.GP_PASSWORD_CUSTOM_REGEX + ">.");
			}
		}
	}
	public static boolean containsUpperAndLowerCase(String test) {
		if (test != null) {
			Pattern pattern = Pattern.compile("^(?=.*?[A-Z])(?=.*?[a-z])[\\w|\\W]*$");
			Matcher matcher = pattern.matcher(test);
			return matcher.matches();
		}
		return false;
	}
	public static boolean containsOnlyDigits(String test) {
		if (test != null) {
			for (char c : test.toCharArray()) {
				if (!Character.isDigit(c)) {
					return false;
				}
			}
		}
		return StringUtils.isNotEmpty(test);
	}
	public static boolean containsDigit(String test) {
		if (test != null) {
			for (char c : test.toCharArray()) {
				if (Character.isDigit(c)) {
					return true;
				}
			}
		}
		return false;
	}
	public static void closeStream(Closeable closableStream) {
		if (closableStream != null) {
			try {
				closableStream.close();
			}
			catch (IOException io) {
				log.trace("Error occurred while closing stream", io);
			}
		}
	}
	public static String shortenedStackTrace(String stackTrace) {
		if (stackTrace == null) {
			return null;
		}
		List<String> results = new ArrayList<>();
		final Pattern exclude = Pattern.compile("(org.springframework.|java.lang.reflect.Method.invoke|sun.reflect.)");
		boolean found = false;
		for (String line : stackTrace.split("\n")) {
			Matcher m = exclude.matcher(line);
			if (m.find()) {
				found = true;
			} else {
				if (found) {
					found = false;
					results.add("\tat [ignored] ...");
				}
				results.add(line);
			}
		}
		return StringUtils.join(results, "\n");
	}
	public static Properties getRuntimeProperties(String applicationName) {
		if (applicationName == null) {
			applicationName = "openmrs";
		}
		String pathName;
		pathName = getRuntimePropertiesFilePathName(applicationName);
		FileInputStream propertyStream = null;
		try {
			if (pathName != null) {
				propertyStream = new FileInputStream(pathName);
			}
		}
		catch (FileNotFoundException e) {
			log.warn("Unable to find a runtime properties file at " + new File(pathName).getAbsolutePath());
		}
		try {
			if (propertyStream == null) {
				throw new IOException("Could not find a runtime properties file named " + pathName
				        + " in the OpenMRS application data directory, or the current directory");
			}
			Properties props = new Properties();
			OpenmrsUtil.loadProperties(props, propertyStream);
			propertyStream.close();
			log.info("Using runtime properties file: " + pathName);
			return props;
		}
		catch (Exception ex) {
			log.info("Got an error while attempting to load the runtime properties", ex);
			log.warn(
			    "Unable to find a runtime properties file. Initial setup is needed. View the webapp to run the setup wizard.");
			return null;
		}
	}
	public static boolean isTestMode() {
		return "true".equalsIgnoreCase(System.getProperty("FUNCTIONAL_TEST_MODE"));
	}
	public static String getRuntimePropertiesFilePathName(String applicationName) {
		if (applicationName == null) {
			applicationName = "openmrs";
		}
		String defaultFileName = applicationName + "-runtime.properties";
		String fileNameInTestMode = getRuntimePropertiesFileNameInTestMode();
		String pathName = fileNameInTestMode != null ? fileNameInTestMode : defaultFileName;
		log.debug("Attempting to look for properties file in current directory: " + pathName);
		if (new File(pathName).exists()) {
			return pathName;
		} else {
			log.warn("Unable to find a runtime properties file at " + new File(pathName).getAbsolutePath());
		}
		String envVarName = applicationName.toUpperCase() + "_RUNTIME_PROPERTIES_FILE";
		String envFileName = System.getenv(envVarName);
		if (envFileName != null) {
			log.debug("Atempting to look for runtime properties from: " + pathName);
			if (new File(envFileName).exists()) {
				return envFileName;
			} else {
				log.warn("Unable to find properties file with path: " + pathName + ". (derived from environment variable "
				        + envVarName + ")");
			}
		} else {
			log.info("Couldn't find an environment variable named " + envVarName);
			if (log.isDebugEnabled()) {
				log.debug("Available environment variables are named: " + System.getenv().keySet());
			}
		}
		File file = new File(getApplicationDataDirectory(), pathName);
		pathName = file.getAbsolutePath();
		log.debug("Attempting to look for property file from: " + pathName);
		if (file.exists()) {
			return pathName;
		} else {
			log.warn("Unable to find properties file: " + pathName);
		}
		return null;
	}
	public static String getRuntimePropertiesFileNameInTestMode() {
		String filename = null;
		if (isTestMode()) {
			log.info("In functional testing mode. Ignoring the existing runtime properties file");
			filename = getOpenMRSVersionInTestMode() + "-test-runtime.properties";
		}
		return filename;
	}
	public static String getOpenMRSVersionInTestMode() {
		return System.getProperty("OPENMRS_VERSION", "openmrs");
	}
	public static boolean nullSafeEqualsIgnoreCase(String s1, String s2) {
		if (s1 == null) {
			return s2 == null;
		} else if (s2 == null) {
			return false;
		}
		return s1.equalsIgnoreCase(s2);
	}
	public static Integer convertToInteger(Long longValue) {
		if (longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE) {
			throw new IllegalArgumentException(longValue + " cannot be cast to Integer without changing its value.");
		}
		return longValue.intValue();
	}
	public static boolean isYesterday(Date date) {
		if (date == null) {
			return false;
		}
		Calendar c1 = Calendar.getInstance();
		c1.add(Calendar.DAY_OF_YEAR, -1); 
		Calendar c2 = Calendar.getInstance();
		c2.setTime(date);
		return (c1.get(Calendar.ERA) == c2.get(Calendar.ERA) && c1.get(Calendar.YEAR) == c2.get(Calendar.YEAR)
		        && c1.get(Calendar.DAY_OF_YEAR) == c2.get(Calendar.DAY_OF_YEAR));
	}
	public static Set<String> getDeclaredFields(Class<?> clazz) {
		return Arrays.stream(clazz.getDeclaredFields()).map(Field::getName).collect(Collectors.toSet());
	}
	public static String isValidNumericValue(Float value, Concept concept, Obs obs) {
		ConceptReferenceRange conceptReferenceRange = new ObsValidator().getReferenceRange(concept, obs);
		if (conceptReferenceRange == null) {
			return "";
		}
		if ((conceptReferenceRange.getHiAbsolute() != null && conceptReferenceRange.getHiAbsolute() < value) ||
			(conceptReferenceRange.getLowAbsolute() != null && conceptReferenceRange.getLowAbsolute() > value)) {
			return String.format("Expected value between %s and %s", conceptReferenceRange.getLowAbsolute(), conceptReferenceRange.getHiAbsolute());
		} else {
			return "";
		}
	}
}
package org.openmrs.api;
import org.openmrs.OrderAttribute;
import org.openmrs.OrderAttributeType;
import org.openmrs.Provider;
import org.openmrs.Visit;
import org.openmrs.OrderGroup;
import org.openmrs.OrderGroupAttribute;
import org.openmrs.OrderGroupAttributeType;
import org.openmrs.Order;
import org.openmrs.Patient;
import org.openmrs.CareSetting;
import org.openmrs.OrderType;
import org.openmrs.Concept;
import org.openmrs.ConceptClass;
import org.openmrs.Encounter;
import org.openmrs.OrderFrequency;
import org.openmrs.annotation.Authorized;
import org.openmrs.api.db.OrderDAO;
import org.openmrs.parameter.OrderSearchCriteria;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.PrivilegeConstants;
import java.util.Date;
import java.util.List;
import java.util.Locale;
public interface OrderService extends OpenmrsService {
	public static final String PARALLEL_ORDERS = "PARALLEL_ORDERS";
	public void setOrderDAO(OrderDAO dao);
	@Authorized({ PrivilegeConstants.EDIT_ORDERS, PrivilegeConstants.ADD_ORDERS })
	public Order saveOrder(Order order, OrderContext orderContext) throws APIException;
	@Authorized({ PrivilegeConstants.EDIT_ORDERS, PrivilegeConstants.ADD_ORDERS })
	public Order saveRetrospectiveOrder(Order order, OrderContext orderContext);
	@Authorized(PrivilegeConstants.PURGE_ORDERS)
	public void purgeOrder(Order order) throws APIException;
	@Authorized(PrivilegeConstants.PURGE_ORDERS)
	public void purgeOrder(Order order, boolean cascade) throws APIException;
	@Authorized(PrivilegeConstants.DELETE_ORDERS)
	public Order voidOrder(Order order, String voidReason) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public Order getOrder(Integer orderId) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public Order getOrderByUuid(String uuid) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public Order getDiscontinuationOrder(Order order) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public Order getRevisionOrder(Order order) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public List<Order> getOrders(Patient patient, CareSetting careSetting, OrderType orderType, boolean includeVoided);
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public List<Order> getAllOrdersByPatient(Patient patient);
	@Authorized( { PrivilegeConstants.GET_ORDERS })
	public List<Order> getOrders(OrderSearchCriteria orderSearchCriteria);
	@Authorized(PrivilegeConstants.DELETE_ORDERS)
	public Order unvoidOrder(Order order) throws APIException;
	@Authorized(PrivilegeConstants.EDIT_ORDERS)
	public Order updateOrderFulfillerStatus(Order order, Order.FulfillerStatus orderFulfillerStatus, String fullFillerComment);
	@Authorized(PrivilegeConstants.EDIT_ORDERS)
	public Order updateOrderFulfillerStatus(Order order, Order.FulfillerStatus orderFulfillerStatus, String fullFillerComment, String accessionNumber);
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public Order getOrderByOrderNumber(String orderNumber);
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public List<Order> getOrderHistoryByConcept(Patient patient, Concept concept);
	@Authorized(PrivilegeConstants.ADD_ORDERS)
	public Long getNextOrderNumberSeedSequenceValue();
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public List<Order> getOrderHistoryByOrderNumber(String orderNumber);
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public List<Order> getActiveOrders(Patient patient, OrderType orderType, CareSetting careSetting, Date asOfDate);
	@Authorized(PrivilegeConstants.GET_CARE_SETTINGS)
	public CareSetting getCareSetting(Integer careSettingId);
	@Authorized(PrivilegeConstants.GET_CARE_SETTINGS)
	public CareSetting getCareSettingByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CARE_SETTINGS)
	public CareSetting getCareSettingByName(String name);
	@Authorized(PrivilegeConstants.GET_CARE_SETTINGS)
	public List<CareSetting> getCareSettings(boolean includeRetired);
	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
	public OrderType getOrderTypeByName(String orderTypeName);
	@Authorized(PrivilegeConstants.GET_ORDER_FREQUENCIES)
	public OrderFrequency getOrderFrequency(Integer orderFrequencyId);
	@Authorized(PrivilegeConstants.GET_ORDER_FREQUENCIES)
	public OrderFrequency getOrderFrequencyByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_ORDER_FREQUENCIES)
	public OrderFrequency getOrderFrequencyByConcept(Concept concept);
	@Authorized(PrivilegeConstants.GET_ORDER_FREQUENCIES)
	public List<OrderFrequency> getOrderFrequencies(boolean includeRetired);
	@Authorized(PrivilegeConstants.GET_ORDER_FREQUENCIES)
	public List<OrderFrequency> getOrderFrequencies(String searchPhrase, Locale locale, boolean exactLocale,
	        boolean includeRetired);
	@Authorized({ PrivilegeConstants.ADD_ORDERS, PrivilegeConstants.EDIT_ORDERS })
	public Order discontinueOrder(Order orderToDiscontinue, Concept reasonCoded, Date discontinueDate, Provider orderer,
	        Encounter encounter);
	@Authorized({ PrivilegeConstants.ADD_ORDERS, PrivilegeConstants.EDIT_ORDERS })
	public Order discontinueOrder(Order orderToDiscontinue, String reasonNonCoded, Date discontinueDate, Provider orderer,
	        Encounter encounter);
	@Authorized(PrivilegeConstants.MANAGE_ORDER_FREQUENCIES)
	public OrderFrequency saveOrderFrequency(OrderFrequency orderFrequency) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_ORDER_FREQUENCIES)
	public OrderFrequency retireOrderFrequency(OrderFrequency orderFrequency, String reason);
	@Authorized(PrivilegeConstants.MANAGE_ORDER_FREQUENCIES)
	public OrderFrequency unretireOrderFrequency(OrderFrequency orderFrequency);
	@Authorized(PrivilegeConstants.PURGE_ORDER_FREQUENCIES)
	public void purgeOrderFrequency(OrderFrequency orderFrequency) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
	public OrderType getOrderType(Integer orderTypeId);
	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
	public OrderType getOrderTypeByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
	public List<OrderType> getOrderTypes(boolean includeRetired);
	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
	public OrderType saveOrderType(OrderType orderType);
	@Authorized(PrivilegeConstants.PURGE_ORDER_TYPES)
	public void purgeOrderType(OrderType orderType) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
	public OrderType retireOrderType(OrderType orderType, String reason);
	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
	public OrderType unretireOrderType(OrderType orderType);
	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
	public List<OrderType> getSubtypes(OrderType orderType, boolean includeRetired);
	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
	public OrderType getOrderTypeByConceptClass(ConceptClass conceptClass);
	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
	public OrderType getOrderTypeByConcept(Concept concept);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getDrugRoutes();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getDrugDosingUnits();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getDrugDispensingUnits();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getDurationUnits();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getTestSpecimenSources();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getNonCodedDrugConcept();
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public OrderGroup getOrderGroupByUuid(String uuid) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public OrderGroup getOrderGroup(Integer orderGroupId) throws APIException;
	@Authorized({ PrivilegeConstants.EDIT_ORDERS, PrivilegeConstants.ADD_ORDERS })
	public OrderGroup saveOrderGroup(OrderGroup orderGroup) throws APIException;
	@Authorized({ PrivilegeConstants.EDIT_ORDERS, PrivilegeConstants.ADD_ORDERS })
	public  OrderGroup saveOrderGroup(OrderGroup orderGroup, OrderContext orderContext) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public List<OrderGroup> getOrderGroupsByPatient(Patient patient) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public List<OrderGroup> getOrderGroupsByEncounter(Encounter encounter) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	 List<OrderGroupAttributeType> getAllOrderGroupAttributeTypes() throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	OrderGroupAttributeType getOrderGroupAttributeType(Integer orderGroupAttributeTypeId) throws APIException;
	OrderGroupAttributeType getOrderGroupAttributeTypeByUuid(String uuid) throws APIException;
    @Authorized({PrivilegeConstants.EDIT_ORDERS,PrivilegeConstants.ADD_ORDERS})
	OrderGroupAttributeType saveOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
	OrderGroupAttributeType retireOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType, String reason) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
	OrderGroupAttributeType unretireOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType) throws APIException;
    @Authorized(PrivilegeConstants.PURGE_ORDERS)
	void purgeOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType) throws APIException;
    @Authorized(PrivilegeConstants.GET_ORDERS)
	OrderGroupAttributeType getOrderGroupAttributeTypeByName(String orderGroupAttributeTypeName) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	OrderGroupAttribute getOrderGroupAttributeByUuid(String uuid) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	List<OrderAttributeType> getAllOrderAttributeTypes() throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	OrderAttributeType getOrderAttributeTypeById(Integer orderAttributeTypeId) throws APIException;
	OrderAttributeType getOrderAttributeTypeByUuid(String uuid) throws APIException;
	@Authorized({PrivilegeConstants.EDIT_ORDERS,PrivilegeConstants.ADD_ORDERS})
	OrderAttributeType saveOrderAttributeType(OrderAttributeType orderAttributeType) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
	OrderAttributeType retireOrderAttributeType(OrderAttributeType orderAttributeType, String reason) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
	OrderAttributeType unretireOrderAttributeType(OrderAttributeType orderAttributeType) throws APIException;
	@Authorized(PrivilegeConstants.PURGE_ORDERS)
	void purgeOrderAttributeType(OrderAttributeType orderAttributeType) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	OrderAttributeType getOrderAttributeTypeByName(String orderAttributeTypeName) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	OrderAttribute getOrderAttributeByUuid(String uuid) throws APIException;
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public List<Order> getActiveOrders(Patient patient, Visit visit, OrderType orderType, CareSetting careSetting,
			Date asOfDate);
	@Authorized(PrivilegeConstants.GET_ORDERS)
	public List<Order> getOrders(Patient patient, Visit visit, CareSetting careSetting, OrderType orderType,
			boolean includeVoided);
}
package org.openmrs;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.envers.Audited;
import org.openmrs.api.APIException;
import javax.persistence.Column;
import javax.persistence.MappedSuperclass;
@MappedSuperclass
@Audited
public abstract class BaseFormRecordableOpenmrsData extends BaseChangeableOpenmrsData implements FormRecordable {
	private static final long serialVersionUID = 1L;
	protected static final String FORM_NAMESPACE_PATH_SEPARATOR = "^";
	protected static final int FORM_NAMESPACE_PATH_MAX_LENGTH = 255;
	@Column(name = "form_namespace_and_path")
	protected String formNamespaceAndPath;
	@Override
	public String getFormFieldNamespace() {
		return BaseFormRecordableOpenmrsData.getFormFieldNamespace(formNamespaceAndPath);
	}
	@Override
	public String getFormFieldPath() {
		return BaseFormRecordableOpenmrsData.getFormFieldPath(formNamespaceAndPath);
	}
	@Override
	public void setFormField(String namespace, String formFieldPath) {
		formNamespaceAndPath = BaseFormRecordableOpenmrsData.getFormNamespaceAndPath(namespace, formFieldPath);
	}
	public String getFormNamespaceAndPath() {
		return formNamespaceAndPath;
	}
	public void setFormNamespaceAndPath(String formNamespaceAndPath) {
		this.formNamespaceAndPath = formNamespaceAndPath;
	}
	public static String getFormFieldNamespace(String formNamespaceAndPath) {
		if (StringUtils.isNotBlank(formNamespaceAndPath)) {
			if (formNamespaceAndPath.startsWith(FORM_NAMESPACE_PATH_SEPARATOR)) {
				return null;
			}
			return formNamespaceAndPath.substring(0, formNamespaceAndPath.indexOf(FORM_NAMESPACE_PATH_SEPARATOR));
		}
		return formNamespaceAndPath;
	}
	public static String getFormFieldPath(String formNamespaceAndPath) {
		if (StringUtils.isNotBlank(formNamespaceAndPath)) {
			if (formNamespaceAndPath.endsWith(FORM_NAMESPACE_PATH_SEPARATOR)) {
				return null;
			}
			return formNamespaceAndPath.substring(formNamespaceAndPath.indexOf(FORM_NAMESPACE_PATH_SEPARATOR) + 1);
		}
		return formNamespaceAndPath;
	}
	public static String getFormNamespaceAndPath(String namespace, String formFieldPath) {
		if (namespace == null && formFieldPath == null) {
			return null;
		}
		String nsAndPathTemp = "";
		if (StringUtils.isNotBlank(namespace) && StringUtils.isNotBlank(formFieldPath)) {
			nsAndPathTemp = namespace + FORM_NAMESPACE_PATH_SEPARATOR + formFieldPath;
		} else if (StringUtils.isNotBlank(namespace)) {
			nsAndPathTemp = namespace + FORM_NAMESPACE_PATH_SEPARATOR;
		} else if (StringUtils.isNotBlank(formFieldPath)) {
			nsAndPathTemp = FORM_NAMESPACE_PATH_SEPARATOR + formFieldPath;
		}
		if (nsAndPathTemp.length() > FORM_NAMESPACE_PATH_MAX_LENGTH) {
			throw new APIException("BaseFormRecordableOpenmrsData.namespaceAndPathTooLong", (Object[]) null);
		}
		if (StringUtils.countMatches(nsAndPathTemp, FORM_NAMESPACE_PATH_SEPARATOR) > 1) {
			throw new APIException("BaseFormRecordableOpenmrsData.namespaceAndPathNotContainSeparator", (Object[]) null);
		}
		return nsAndPathTemp;
	}
}
package org.openmrs.api;
import org.openmrs.api.context.Context;
public class APIException extends RuntimeException {
	public static final long serialVersionUID = 12121212L;
	public APIException() {
	}
	public APIException(String message) {
		super(message);
	}
	public APIException(String message, Throwable cause) {
		super(message, cause);
	}
	public APIException(Throwable cause) {
		super(cause);
	}
	public APIException(String messageKey, Object[] parameters) {
		super(Context.getMessageSourceService().getMessage(messageKey, parameters, Context.getLocale()));
	}
	public APIException(String messageKey, Object[] parameters, Throwable cause) {
		super(Context.getMessageSourceService().getMessage(messageKey, parameters, Context.getLocale()), cause);
	}
}
package org.openmrs;
import static org.openmrs.Order.Action.DISCONTINUE;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.envers.Audited;
import org.openmrs.util.OpenmrsUtil;
@Audited
public class DrugOrder extends Order {
	public static final long serialVersionUID = 72232L;
	private Double dose;
	private Concept doseUnits;
	private OrderFrequency frequency;
	private Boolean asNeeded = false;
	private Double quantity;
	private Concept quantityUnits;
	private Drug drug;
	private String asNeededCondition;
	private Class<? extends DosingInstructions> dosingType = SimpleDosingInstructions.class;
	private Integer numRefills;
	private String dosingInstructions;
	private Integer duration;
	private Concept durationUnits;
	private Concept route;
	private String brandName;
	private Boolean dispenseAsWritten = Boolean.FALSE;
	private String drugNonCoded;
	public DrugOrder() {
	}
	public DrugOrder(Integer orderId) {
		this.setOrderId(orderId);
	}
	@Override
	public DrugOrder copy() {
		return copyHelper(new DrugOrder());
	}
	protected DrugOrder copyHelper(DrugOrder target) {
		super.copyHelper(target);
		target.setDose(getDose());
		target.setDoseUnits(getDoseUnits());
		target.setFrequency(getFrequency());
		target.setAsNeeded(getAsNeeded());
		target.setAsNeededCondition(getAsNeededCondition());
		target.setQuantity(getQuantity());
		target.setQuantityUnits(getQuantityUnits());
		target.setDrug(getDrug());
		target.setDosingType(getDosingType());
		target.setDosingInstructions(getDosingInstructions());
		target.setDuration(getDuration());
		target.setDurationUnits(getDurationUnits());
		target.setNumRefills(getNumRefills());
		target.setRoute(getRoute());
		target.setBrandName(getBrandName());
		target.setDispenseAsWritten(getDispenseAsWritten());
		target.setDrugNonCoded(getDrugNonCoded());
		return target;
	}
	public boolean isDrugOrder() {
		return true;
	}
	public Concept getDoseUnits() {
		return this.doseUnits;
	}
	public void setDoseUnits(Concept doseUnits) {
		this.doseUnits = doseUnits;
	}
	public OrderFrequency getFrequency() {
		return this.frequency;
	}
	public void setFrequency(OrderFrequency frequency) {
		this.frequency = frequency;
	}
	public Boolean getAsNeeded() {
		return asNeeded;
	}
	public void setAsNeeded(Boolean asNeeded) {
		this.asNeeded = asNeeded;
	}
	public Double getQuantity() {
		return this.quantity;
	}
	public void setQuantity(Double quantity) {
		this.quantity = quantity;
	}
	public Concept getQuantityUnits() {
		return quantityUnits;
	}
	public void setQuantityUnits(Concept quantityUnits) {
		this.quantityUnits = quantityUnits;
	}
	public Drug getDrug() {
		return this.drug;
	}
	public void setDrug(Drug drug) {
		this.drug = drug;
		if (drug != null && getConcept() == null) {
			setConcept(drug.getConcept());
		}
	}
	public String getAsNeededCondition() {
		return asNeededCondition;
	}
	public void setAsNeededCondition(String asNeededCondition) {
		this.asNeededCondition = asNeededCondition;
	}
	public Concept getRoute() {
		return route;
	}
	public void setRoute(Concept route) {
		this.route = route;
	}
	public void setDose(Double dose) {
		this.dose = dose;
	}
	public Double getDose() {
		return dose;
	}
	public Class<? extends DosingInstructions> getDosingType() {
		return dosingType;
	}
	public void setDosingType(Class<? extends DosingInstructions> dosingType) {
		this.dosingType = dosingType;
	}
	public DosingInstructions getDosingInstructionsInstance() {
		try {
			DosingInstructions instructions = getDosingType().newInstance();
			return instructions.getDosingInstructions(this);
		}
		catch (InstantiationException | IllegalAccessException e) {
			throw new IllegalStateException(e);
		}
	}
	public Integer getNumRefills() {
		return numRefills;
	}
	public void setNumRefills(Integer numRefills) {
		this.numRefills = numRefills;
	}
	public void setDosingInstructions(String dosingInstructions) {
		this.dosingInstructions = dosingInstructions;
	}
	public String getDosingInstructions() {
		return this.dosingInstructions;
	}
	public Integer getDuration() {
		return duration;
	}
	public void setDuration(Integer duration) {
		this.duration = duration;
	}
	public Concept getDurationUnits() {
		return durationUnits;
	}
	public void setDurationUnits(Concept durationUnits) {
		this.durationUnits = durationUnits;
	}
	public String getBrandName() {
		return brandName;
	}
	public void setBrandName(String brandName) {
		this.brandName = brandName;
	}
	public Boolean getDispenseAsWritten() {
		return dispenseAsWritten;
	}
	public void setDispenseAsWritten(Boolean dispenseAsWritten) {
		this.dispenseAsWritten = dispenseAsWritten;
	}
	@Override
	public DrugOrder cloneForDiscontinuing() {
		DrugOrder newOrder = new DrugOrder();
		newOrder.setCareSetting(getCareSetting());
		newOrder.setConcept(getConcept());
		newOrder.setAction(DISCONTINUE);
		newOrder.setPreviousOrder(this);
		newOrder.setPatient(getPatient());
		newOrder.setDrug(getDrug());
		newOrder.setOrderType(getOrderType());
		newOrder.setDrugNonCoded(getDrugNonCoded());
		return newOrder;
	}
	@Override
	public DrugOrder cloneForRevision() {
		return cloneForRevisionHelper(new DrugOrder());
	}
	protected DrugOrder cloneForRevisionHelper(DrugOrder target) {
		super.cloneForRevisionHelper(target);
		target.setDose(getDose());
		target.setDoseUnits(getDoseUnits());
		target.setFrequency(getFrequency());
		target.setAsNeeded(getAsNeeded());
		target.setAsNeededCondition(getAsNeededCondition());
		target.setQuantity(getQuantity());
		target.setQuantityUnits(getQuantityUnits());
		target.setDrug(getDrug());
		target.setDosingType(getDosingType());
		target.setDosingInstructions(getDosingInstructions());
		target.setDuration(getDuration());
		target.setDurationUnits(getDurationUnits());
		target.setRoute(getRoute());
		target.setNumRefills(getNumRefills());
		target.setBrandName(getBrandName());
		target.setDispenseAsWritten(getDispenseAsWritten());
		target.setDrugNonCoded(getDrugNonCoded());
		return target;
	}
	public void setAutoExpireDateBasedOnDuration() {
		if (DISCONTINUE != getAction() && getAutoExpireDate() == null) {
			setAutoExpireDate(getDosingInstructionsInstance().getAutoExpireDate(this));
		}
	}
	@Override
	public String toString() {
		String prefix = DISCONTINUE == getAction() ? "DC " : "";
		return prefix + "DrugOrder(" + getDose() + getDoseUnits() + " of "
		        + (isNonCodedDrug() ? getDrugNonCoded() : (getDrug() != null ? getDrug().getName() : "[no drug]")) + " from " + getDateActivated() + " to "
		        + (isDiscontinuedRightNow() ? getDateStopped() : getAutoExpireDate()) + ")";
	}
	public void setDosing(DosingInstructions di) {
		di.setDosingInstructions(this);
	}
	@Override
	public boolean hasSameOrderableAs(Order otherOrder) {
        if (!super.hasSameOrderableAs(otherOrder)) {
            return false;
        }
        if (!(otherOrder instanceof DrugOrder)) {
            return false;
        }
        DrugOrder otherDrugOrder = (DrugOrder) otherOrder;
        if (isNonCodedDrug() || otherDrugOrder.isNonCodedDrug()) {
            return OpenmrsUtil.nullSafeEqualsIgnoreCase(this.getDrugNonCoded(), otherDrugOrder.getDrugNonCoded());
        }
        return OpenmrsUtil.nullSafeEquals(this.getDrug(), otherDrugOrder.getDrug());
    }
	public String getDrugNonCoded() {
		return drugNonCoded;
	}
	public void setDrugNonCoded(String drugNonCoded) {
		this.drugNonCoded = StringUtils.isNotBlank(drugNonCoded) ? drugNonCoded.trim() : drugNonCoded;
	}
	public boolean isNonCodedDrug() {
		return StringUtils.isNotBlank(this.drugNonCoded);
	}
}
package org.openmrs;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.ContainedIn;
import org.hibernate.search.annotations.DocumentId;
import org.hibernate.search.annotations.Field;
import org.hibernate.search.annotations.FullTextFilterDef;
import org.hibernate.search.annotations.FullTextFilterDefs;
import org.hibernate.search.annotations.IndexedEmbedded;
import org.openmrs.annotation.AllowDirectAccess;
import org.openmrs.api.APIException;
import org.openmrs.api.ConceptNameType;
import org.openmrs.api.ConceptService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.hibernate.search.TermsFilterFactory;
import org.openmrs.customdatatype.CustomValueDescriptor;
import org.openmrs.customdatatype.Customizable;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.ObjectUtils;
@FullTextFilterDefs( { @FullTextFilterDef(name = "termsFilterFactory", impl = TermsFilterFactory.class) })
@Audited
public class Concept extends BaseOpenmrsObject implements Auditable, Retireable, Serializable, Attributable<Concept>,Customizable<ConceptAttribute> {
	public static final long serialVersionUID = 57332L;
	private static final Logger log = LoggerFactory.getLogger(Concept.class);
	private static final String CONCEPT_NAME_LOCALE_NULL = "Concept.name.locale.null";
	@DocumentId
	private Integer conceptId;
	@Field
	private Boolean retired = false;
	private User retiredBy;
	private Date dateRetired;
	private String retireReason;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private ConceptDatatype datatype;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private ConceptClass conceptClass;
	private Boolean set = false;
	private String version;
	private User creator;
	private Date dateCreated;
	private User changedBy;
	private Date dateChanged;
	@AllowDirectAccess
	@ContainedIn
	private Collection<ConceptName> names;
	@AllowDirectAccess
	private Collection<ConceptAnswer> answers;
	private Collection<ConceptSet> conceptSets;
	private Collection<ConceptDescription> descriptions;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private Collection<ConceptMap> conceptMappings;
	private Map<Locale, List<ConceptName>> compatibleCache;
	private Set<ConceptAttribute> attributes = new LinkedHashSet<>();
	public Concept() {
		names = new HashSet<>();
		answers = new HashSet<>();
		conceptSets = new TreeSet<>();
		descriptions = new HashSet<>();
		conceptMappings = new HashSet<>();
	}
	public Concept(Integer conceptId) {
		this();
		this.conceptId = conceptId;
	}
	public Collection<ConceptAnswer> getAnswers() {
		if (answers == null) {
			answers = new HashSet<>();
		}
		return answers;
	}
	public Collection<ConceptAnswer> getAnswers(boolean includeRetired) {
		if (includeRetired) {
			return getAnswers();
		} else {
			return getAnswers().stream()
					.filter(a -> !a.getAnswerConcept().getRetired())
					.collect(Collectors.toSet());
		}
	}
	public void setAnswers(Collection<ConceptAnswer> answers) {
		this.answers = answers;
	}
	public void addAnswer(ConceptAnswer conceptAnswer) {
		if (conceptAnswer != null) {
			if (!getAnswers().contains(conceptAnswer)) {
				conceptAnswer.setConcept(this);
				getAnswers().add(conceptAnswer);
			}
			if ((conceptAnswer.getSortWeight() == null) || (conceptAnswer.getSortWeight() <= 0)) {
				ConceptAnswer a = Collections.max(answers);
				Double sortWeight = (a == null) ? 1d : ((a.getSortWeight() == null) ? 1d : a.getSortWeight() + 1d);
				conceptAnswer.setSortWeight(sortWeight);
			}
		}
	}
	public boolean removeAnswer(ConceptAnswer conceptAnswer) {
		return getAnswers().remove(conceptAnswer);
	}
	@Override
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	public ConceptClass getConceptClass() {
		return conceptClass;
	}
	public void setConceptClass(ConceptClass conceptClass) {
		this.conceptClass = conceptClass;
	}
	@Deprecated
	@JsonIgnore
	public Boolean isSet() {
		return getSet();
	}
	public void setSet(Boolean set) {
		this.set = set;
	}
	public Boolean getSet() {
		return set;
	}
	public ConceptDatatype getDatatype() {
		return datatype;
	}
	public void setDatatype(ConceptDatatype conceptDatatype) {
		this.datatype = conceptDatatype;
	}
	public Integer getConceptId() {
		return conceptId;
	}
	public void setConceptId(Integer conceptId) {
		this.conceptId = conceptId;
	}
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
	@Override
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	@Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	public void setPreferredName(ConceptName preferredName) {
		if (preferredName == null || preferredName.getVoided() || preferredName.isIndexTerm()) {
			throw new APIException("Concept.error.preferredName.null", (Object[]) null);
		} else if (preferredName.getLocale() == null) {
			throw new APIException(CONCEPT_NAME_LOCALE_NULL, (Object[]) null);
		}
		ConceptName oldPreferredName = getPreferredName(preferredName.getLocale(), true);
		if (oldPreferredName != null) {
			oldPreferredName.setLocalePreferred(false);
		}
		preferredName.setLocalePreferred(true);
		if (preferredName.getConceptNameId() == null || !getNames().contains(preferredName)) {
			addName(preferredName);
		}
	}
	public ConceptName findNameTaggedWith(ConceptNameTag conceptNameTag) {
		ConceptName taggedName = null;
		for (ConceptName possibleName : getNames()) {
			if (possibleName.hasTag(conceptNameTag)) {
				taggedName = possibleName;
				break;
			}
		}
		return taggedName;
	}
	public ConceptName getName(Locale locale) {
		return getName(locale, false);
	}
	public ConceptName getName() {
		if (getNames().isEmpty()) {
			log.debug("there are no names defined for: {}", conceptId);
			return null;
		}
		for (Locale currentLocale : LocaleUtility.getLocalesInOrder()) {
			ConceptName preferredName = getPreferredName(currentLocale);
			if (preferredName != null) {
				return preferredName;
			}
			ConceptName fullySpecifiedName = getFullySpecifiedName(currentLocale);
			if (fullySpecifiedName != null) {
				return fullySpecifiedName;
			}
			if (!StringUtils.isBlank(currentLocale.getCountry()) || !StringUtils.isBlank(currentLocale.getVariant())) {
				Locale broaderLocale = new Locale(currentLocale.getLanguage());
				ConceptName prefNameInBroaderLoc = getPreferredName(broaderLocale);
				if (prefNameInBroaderLoc != null) {
					return prefNameInBroaderLoc;
				}
				ConceptName fullySpecNameInBroaderLoc = getFullySpecifiedName(broaderLocale);
				if (fullySpecNameInBroaderLoc != null) {
					return fullySpecNameInBroaderLoc;
				}
			}
		}
		for (ConceptName cn : getNames()) {
			if (cn.isFullySpecifiedName()) {
				return cn;
			}
		}
		if (!getSynonyms().isEmpty()) {
			return getSynonyms().iterator().next();
		}
		return null;
	}
	public boolean hasName(String name, Locale locale) {
		if (name == null) {
			return false;
		}
		Collection<ConceptName> currentNames;
		if (locale == null) {
			currentNames = getNames();
		} else {
			currentNames = getNames(locale);
		}
		for (ConceptName currentName : currentNames) {
			if (name.equalsIgnoreCase(currentName.getName())) {
				return true;
			}
		}
		return false;
	}
	public ConceptName getName(Locale locale, ConceptNameType ofType, ConceptNameTag havingTag) {
		Collection<ConceptName> namesInLocale = getNames(locale);
		if (!namesInLocale.isEmpty()) {
			List<ConceptName> matches = namesInLocale.stream().filter(
				c->(ofType==null || ofType.equals(c.getConceptNameType())) && (havingTag==null || c.hasTag(havingTag))
			).collect(Collectors.toList());
			if (matches.size() == 1) {
				return matches.get(0);
			} else if (matches.size() > 1) {
				for (ConceptName match : matches) {
					if (match.getLocalePreferred()) {
						return match;
					}
				}
				return matches.get(0);
			}
		}
		Locale parent = new Locale(locale.getLanguage());
		if (!parent.equals(locale)) {
			return getName(parent, ofType, havingTag);
		} else {
			return null;
		}
	}
	public ConceptName getName(Locale locale, boolean exact) {
		if (getNames().isEmpty()) {
			log.debug("there are no names defined for: {}", conceptId);
			return null;
		}
		log.debug("Getting conceptName for locale: {}", locale);
		ConceptName exactName = getNameInLocale(locale);
		if (exactName != null) {
			return exactName;
		}
		if (!exact) {
			Locale broaderLocale = new Locale(locale.getLanguage());
			ConceptName name = getNameInLocale(broaderLocale);
			return name != null ? name : getName();
		}
		return null;
	}
	private ConceptName getNameInLocale(Locale locale) {
		ConceptName preferredName = getPreferredName(locale);
		if (preferredName != null) {
			return preferredName;
		}
		ConceptName fullySpecifiedName = getFullySpecifiedName(locale);
		if (fullySpecifiedName != null) {
			return fullySpecifiedName;
		} else if (!getSynonyms(locale).isEmpty()) {
			return getSynonyms(locale).iterator().next();
		}
		return null;
	}
	public ConceptName getPreferredName(Locale forLocale) {
		return getPreferredName(forLocale, false);
	}
	public ConceptName getPreferredName(Locale forLocale, Boolean exact) {
		if (log.isDebugEnabled()) {
			log.debug("Getting preferred conceptName for locale: " + forLocale);
		}
		if (forLocale == null) {
			log.warn("Locale cannot be null");
			return null;
		}
		for (ConceptName nameInLocale : getNames(forLocale)) {
			if (ObjectUtils.nullSafeEquals(nameInLocale.getLocalePreferred(), true)) {
				return nameInLocale;
			}
		}
		if (exact) {
			return null;
		} else {
			ConceptName bestMatch = null;
			for (ConceptName nameInLocale : getPartiallyCompatibleNames(forLocale)) {
				if (ObjectUtils.nullSafeEquals(nameInLocale.getLocalePreferred(), true)) {
					Locale nameLocale = nameInLocale.getLocale();
					if (forLocale.getLanguage().equals(nameLocale.getLanguage())) {
						return nameInLocale;
					} else {
						bestMatch = nameInLocale;
					}
				}
			}
			if (bestMatch != null) {
				return bestMatch;
			}
			return getFullySpecifiedName(forLocale);
		}
	}
	public ConceptName getFullySpecifiedName(Locale locale) {
		if (locale != null && !getNames(locale).isEmpty()) {
			for (ConceptName conceptName : getNames(locale)) {
				if (ObjectUtils.nullSafeEquals(conceptName.isFullySpecifiedName(), true)) {
					return conceptName;
				}
			}
			ConceptName bestMatch = null;
			for (ConceptName conceptName : getPartiallyCompatibleNames(locale)) {
				if (ObjectUtils.nullSafeEquals(conceptName.isFullySpecifiedName(), true)) {
					Locale nameLocale = conceptName.getLocale();
					if (locale.getLanguage().equals(nameLocale.getLanguage())) {
						return conceptName;
					}
					bestMatch = conceptName;
				}
			}
			return bestMatch;
		}
		return null;
	}
	public Collection<ConceptName> getNames(Locale locale) {
		return getNames().stream()
				.filter(n -> n.getLocale().equals(locale))
				.collect(Collectors.toSet());
	}
	private Collection<ConceptName> getPartiallyCompatibleNames(Locale locale) {
		String language = locale.getLanguage();
		String country = locale.getCountry();
		return getNames().stream()
				.filter(n -> language.equals(n.getLocale().getLanguage()) || 
							StringUtils.isNotBlank(country) && country.equals(n.getLocale().getCountry()))
				.collect(Collectors.toSet());
	}
	public List<ConceptName> getCompatibleNames(Locale desiredLocale) {
		List<ConceptName> compatibleNames = null;
		if (compatibleCache == null) {
			compatibleCache = new HashMap<>();
		} else {
			compatibleNames = compatibleCache.get(desiredLocale);
		}
		if (compatibleNames == null) {
			compatibleNames = new ArrayList<>();
			for (ConceptName possibleName : getNames()) {
				if (LocaleUtility.areCompatible(possibleName.getLocale(), desiredLocale)) {
					compatibleNames.add(possibleName);
				}
			}
			compatibleCache.put(desiredLocale, compatibleNames);
		}
		return compatibleNames;
	}
	public void setFullySpecifiedName(ConceptName fullySpecifiedName) {
		if (fullySpecifiedName == null || fullySpecifiedName.getLocale() == null) {
			throw new APIException(CONCEPT_NAME_LOCALE_NULL, (Object[]) null);
		} else if (fullySpecifiedName.getVoided()) {
			throw new APIException("Concept.error.fullySpecifiedName.null", (Object[]) null);
		}
		ConceptName oldFullySpecifiedName = getFullySpecifiedName(fullySpecifiedName.getLocale());
		if (oldFullySpecifiedName != null) {
			oldFullySpecifiedName.setConceptNameType(null);
		}
		fullySpecifiedName.setConceptNameType(ConceptNameType.FULLY_SPECIFIED);
		if (fullySpecifiedName.getConceptNameId() == null || !getNames().contains(fullySpecifiedName)) {
			addName(fullySpecifiedName);
		}
	}
	public void setShortName(ConceptName shortName) {
		if (shortName != null) {
			if (shortName.getLocale() == null) {
				throw new APIException(CONCEPT_NAME_LOCALE_NULL, (Object[]) null);
			}
			ConceptName oldShortName = getShortNameInLocale(shortName.getLocale());
			if (oldShortName != null) {
				oldShortName.setConceptNameType(null);
			}
			shortName.setConceptNameType(ConceptNameType.SHORT);
			if (StringUtils.isNotBlank(shortName.getName())
			        && (shortName.getConceptNameId() == null || !getNames().contains(shortName))) {
				addName(shortName);
			}
		} else {
			throw new APIException("Concept.error.shortName.null", (Object[]) null);
		}
	}
	public ConceptName getShortNameInLocale(Locale locale) {
		ConceptName bestMatch = null;
		if (locale != null && !getShortNames().isEmpty()) {
			for (ConceptName shortName : getShortNames()) {
				Locale nameLocale = shortName.getLocale();
				if (nameLocale.equals(locale)) {
					return shortName;
				}
				if (OpenmrsUtil.nullSafeEquals(locale.getLanguage(), nameLocale.getLanguage())) {
					bestMatch = shortName;
				} else if (bestMatch == null && StringUtils.isNotBlank(locale.getCountry())
				        && locale.getCountry().equals(nameLocale.getCountry())) {
					bestMatch = shortName;
				}
			}
		}
		return bestMatch;
	}
	public Collection<ConceptName> getShortNames() {
		List<ConceptName> shortNames = new ArrayList<>();
		if (getNames().isEmpty()) {
			if (log.isDebugEnabled()) {
				log.debug("The Concept with id: " + conceptId + " has no names");
			}
		} else {
			shortNames = getNames().stream()
							.filter(ConceptName::isShort)
							.collect(Collectors.toList());
		}
		return shortNames;
	}
	public ConceptName getShortestName(Locale locale, Boolean exact) {
		if (log.isDebugEnabled()) {
			log.debug("Getting shortest conceptName for locale: " + locale);
		}
		ConceptName shortNameInLocale = getShortNameInLocale(locale);
		if (shortNameInLocale != null) {
			return shortNameInLocale;
		}
		ConceptName shortestNameForLocale = null;
		ConceptName shortestNameForConcept = null;
		if (locale != null) {
			for (ConceptName possibleName : getNames()) {
				if (possibleName.getLocale().equals(locale)
				        && ((shortestNameForLocale == null) || (possibleName.getName().length() < shortestNameForLocale
				                .getName().length()))) {
					shortestNameForLocale = possibleName;
				}
				if ((shortestNameForConcept == null)
				        || (possibleName.getName().length() < shortestNameForConcept.getName().length())) {
					shortestNameForConcept = possibleName;
				}
			}
		}
		if (exact) {
			if (shortestNameForLocale == null) {
				log.warn("No short concept name found for concept id " + conceptId + " for locale "
				        + locale.getDisplayName());
			}
			return shortestNameForLocale;
		}
		return shortestNameForConcept;
	}
	public boolean isNamed(String name) {
		return getNames().stream().anyMatch(cn -> name.equals(cn.getName()));
	}
	public Collection<ConceptName> getIndexTerms() {
		return getNames().stream()
				.filter(ConceptName::isIndexTerm)
				.collect(Collectors.toSet());		
	}
	public Collection<ConceptName> getIndexTermsForLocale(Locale locale) {
		return getIndexTerms().stream()
				.filter(n -> n.getLocale().equals(locale))
		        .collect(Collectors.toList());
	}
	public Collection<ConceptName> getNames() {
		return getNames(false);
	}
	public Collection<ConceptName> getNames(boolean includeVoided) {
		if (names == null) {
			names = new HashSet<>();
		}
		return names.stream()
				.filter(n -> includeVoided || !n.getVoided())
				.collect(Collectors.toSet());
	}
	public void setNames(Collection<ConceptName> names) {
		this.names = names;
	}
	public void addName(ConceptName conceptName) {
		if (conceptName != null) {
			conceptName.setConcept(this);
			if (names == null) {
				names = new HashSet<>();
			}
			if (!names.contains(conceptName)) {
				if (getNames().isEmpty()
				        && !ConceptNameType.FULLY_SPECIFIED.equals(conceptName.getConceptNameType())) {
					conceptName.setConceptNameType(ConceptNameType.FULLY_SPECIFIED);
				} else {
					if (conceptName.isPreferred() && !conceptName.isIndexTerm() && conceptName.getLocale() != null) {
						ConceptName prefName = getPreferredName(conceptName.getLocale(), true);
						if (prefName != null) {
							prefName.setLocalePreferred(false);
						}
					}
					if (conceptName.isFullySpecifiedName() && conceptName.getLocale() != null) {
						ConceptName fullySpecName = getFullySpecifiedName(conceptName.getLocale());
						if (fullySpecName != null) {
							fullySpecName.setConceptNameType(null);
						}
					} else if (conceptName.isShort() && conceptName.getLocale() != null) {
						ConceptName shortName = getShortNameInLocale(conceptName.getLocale());
						if (shortName != null) {
							shortName.setConceptNameType(null);
						}
					}
				}
				names.add(conceptName);
				if (compatibleCache != null) {
					compatibleCache.clear();
				}
			}
		}
	}
	public boolean removeName(ConceptName conceptName) {
		if (names != null) {
			return names.remove(conceptName);
		} else {
			return false;
		}
	}
	public ConceptDescription getDescription() {
		return getDescription(Context.getLocale());
	}
	public ConceptDescription getDescription(Locale locale) {
		return getDescription(locale, false);
	}
	public ConceptDescription getDescription(Locale locale, boolean exact) {
		log.debug("Getting ConceptDescription for locale: " + locale);
		ConceptDescription foundDescription = null;
		if (locale == null) {
			locale = LocaleUtility.getDefaultLocale();
		}
		Locale desiredLocale = locale;
		ConceptDescription defaultDescription = null;
		for (ConceptDescription availableDescription : getDescriptions()) {
			Locale availableLocale = availableDescription.getLocale();
			if (availableLocale.equals(desiredLocale)) {
				foundDescription = availableDescription;
				break;
			}
			if (!exact && LocaleUtility.areCompatible(availableLocale, desiredLocale)) {
				foundDescription = availableDescription;
			}
			if (availableLocale.equals(LocaleUtility.getDefaultLocale())) {
				defaultDescription = availableDescription;
			}
		}
		if (foundDescription == null) {
			if (exact) {
				log.debug("No concept description found for concept id " + conceptId + " for locale "
				        + desiredLocale.toString());
			} else {
				if (defaultDescription == null) {
					log.debug("No concept description found for default locale for concept id " + conceptId);
				} else {
					foundDescription = defaultDescription;
				}
			}
		}
		return foundDescription;
	}
	@Override
	public User getRetiredBy() {
		return retiredBy;
	}
	@Override
	public void setRetiredBy(User retiredBy) {
		this.retiredBy = retiredBy;
	}
	@Override
	public Date getDateRetired() {
		return dateRetired;
	}
	@Override
	public void setDateRetired(Date dateRetired) {
		this.dateRetired = dateRetired;
	}
	@Override
	public String getRetireReason() {
		return retireReason;
	}
	@Override
	public void setRetireReason(String retireReason) {
		this.retireReason = retireReason;
	}
	public Collection<ConceptDescription> getDescriptions() {
		if (descriptions == null) {
			descriptions = new HashSet<>();
		}
		return descriptions;
	}
	public void setDescriptions(Collection<ConceptDescription> descriptions) {
		this.descriptions = descriptions;
	}
	public void addDescription(ConceptDescription description) {
		if (description != null && StringUtils.isNotBlank(description.getDescription()) && !descriptions.contains(description)) {
			description.setConcept(this);
			descriptions.add(description);
		}
	}
	public boolean removeDescription(ConceptDescription description) {
		return descriptions.remove(description);
	}
	@Override
	@Deprecated
	@JsonIgnore
	public Boolean isRetired() {
		return getRetired();
	}
	@Override
	public Boolean getRetired() {
		return retired;
	}
	@Override
	public void setRetired(Boolean retired) {
		this.retired = retired;
	}
	public Collection<ConceptName> getSynonyms(Locale locale) {
		List<ConceptName> syns = new ArrayList<>();
		ConceptName preferredConceptName = null;
		for (ConceptName possibleSynonymInLoc : getSynonyms()) {
			if (locale.equals(possibleSynonymInLoc.getLocale())) {
				if (possibleSynonymInLoc.isPreferred()) {
					preferredConceptName = possibleSynonymInLoc;
				} else {
					syns.add(possibleSynonymInLoc);
				}
			}
		}
		if (preferredConceptName != null) {
			syns.add(0, preferredConceptName);
		}
		log.debug("returning: " + syns);
		return syns;
	}
	public Collection<ConceptName> getSynonyms() {
		return getNames().stream()
				.filter(ConceptName::isSynonym)
				.collect(Collectors.toSet());
	}
	public String getVersion() {
		return version;
	}
	public void setVersion(String version) {
		this.version = version;
	}
	public Collection<ConceptSet> getConceptSets() {
		return conceptSets;
	}
	public void setConceptSets(Collection<ConceptSet> conceptSets) {
		this.conceptSets = conceptSets;
	}
	public boolean isNumeric() {
		return false;
	}
	public Collection<ConceptMap> getConceptMappings() {
		if (conceptMappings == null) {
			conceptMappings = new HashSet<>();
		}
		return conceptMappings;
	}
	public void setConceptMappings(Collection<ConceptMap> conceptMappings) {
		this.conceptMappings = conceptMappings;
	}
	public void addConceptMapping(ConceptMap newConceptMap) {
		if (newConceptMap != null) {
			newConceptMap.setConcept(this);
		}
		if (newConceptMap != null && !getConceptMappings().contains(newConceptMap)) {
			if (newConceptMap.getConceptMapType() == null) {
				newConceptMap.setConceptMapType(Context.getConceptService().getDefaultConceptMapType());
			}
			getConceptMappings().add(newConceptMap);
		}
	}
	public boolean isComplex() {
		return false;
	}
	public boolean removeConceptMapping(ConceptMap conceptMap) {
		return getConceptMappings().remove(conceptMap);
	}
	@Override
	public String toString() {
		return "Concept #" + conceptId;
	}
	@Override
	@Deprecated
	public List<Concept> findPossibleValues(String searchText) {
		List<Concept> concepts = new ArrayList<>();
		try {
			for (ConceptSearchResult searchResult : Context.getConceptService().getConcepts(searchText,
			    Collections.singletonList(Context.getLocale()), false, null, null, null, null, null, null, null)) {
				concepts.add(searchResult.getConcept());
			}
		}
		catch (Exception e) {
		}
		return concepts;
	}
	@Override
	@Deprecated
	public List<Concept> getPossibleValues() {
		try {
			return Context.getConceptService().getConceptsByName("");
		}
		catch (Exception e) {
		}
		return Collections.emptyList();
	}
	@Override
	public Concept hydrate(String reference) {
		try {
			return Context.getConceptService().getConceptByReference(reference);
		}
		catch (Exception e) {
		}
		return null;
	}
	@Override
	public String serialize() {
		if (this.getConceptId() == null) {
			return "";
		}
		return "" + this.getConceptId();
	}
	@Override
	public String getDisplayString() {
		if (getName() == null) {
			return toString();
		} else {
			return getName().getName();
		}
	}
	public Set<Locale> getAllConceptNameLocales() {
		if (getNames().isEmpty()) {
			if (log.isDebugEnabled()) {
				log.debug("The Concept with id: " + conceptId + " has no names");
			}
			return null;
		}
		Set<Locale> locales = new HashSet<>();
		for (ConceptName cn : getNames()) {
			locales.add(cn.getLocale());
		}
		return locales;
	}
	@Override
	public Integer getId() {
		return getConceptId();
	}
	@Override
	public void setId(Integer id) {
		setConceptId(id);
	}
	private List<ConceptSet> getSortedConceptSets() {
		List<ConceptSet> cs = new ArrayList<>();
		if (conceptSets != null) {
			cs.addAll(conceptSets);
			Collections.sort(cs);
		}
		return cs;
	}
	public List<Concept> getSetMembers() {
		List<Concept> conceptMembers = new ArrayList<>();
		Collection<ConceptSet> sortedConceptSet = getSortedConceptSets();
		for (ConceptSet conceptSet : sortedConceptSet) {
			conceptMembers.add(conceptSet.getConcept());
		}
		return Collections.unmodifiableList(conceptMembers);
	}
	public List<Concept> getSetMembers(boolean includeRetired) {
		if (includeRetired) {
			return getSetMembers();
		} else {
			return getSetMembers().stream()
				.filter(a -> !a.getRetired())
				.collect(Collectors.toList());
		}
	}
	public void addSetMember(Concept setMember) {
		addSetMember(setMember, -1);
	}
	public void addSetMember(Concept setMember, int index) {
		List<ConceptSet> sortedConceptSets = getSortedConceptSets();
		int setsSize = sortedConceptSets.size();
		double weight = 990.0;
		for (ConceptSet conceptSet : sortedConceptSets) {
			weight += 10.0;
			conceptSet.setSortWeight(weight);
		}
		if (sortedConceptSets.isEmpty()) {
			weight = 1000.0;
		} else if (index == -1 || index >= setsSize) {
			weight = sortedConceptSets.get(setsSize - 1).getSortWeight() + 10.0;
		} else if (index == 0) {
			weight = sortedConceptSets.get(0).getSortWeight() - 10.0;
		} else {
			double prevSortWeight = sortedConceptSets.get(index - 1).getSortWeight();
			double nextSortWeight = sortedConceptSets.get(index).getSortWeight();
			weight = (prevSortWeight + nextSortWeight) / 2;
		}
		ConceptSet conceptSet = new ConceptSet(setMember, weight);
		conceptSet.setConceptSet(this);
		conceptSets.add(conceptSet);
	}
	@Override
	public Set<ConceptAttribute> getAttributes() {
		if (attributes == null) {
			attributes = new LinkedHashSet<>();
		}
		return attributes;
	}
	@Override
	public Collection<ConceptAttribute> getActiveAttributes() {
		return getAttributes().stream()
				.filter(attr -> !attr.getVoided())
				.collect(Collectors.toList());
	}
	@Override
	public List<ConceptAttribute> getActiveAttributes(CustomValueDescriptor ofType) {
		return getAttributes().stream()
				.filter(attr -> attr.getAttributeType().equals(ofType) && !attr.getVoided())
				.collect(Collectors.toList());
	}
	public void setAttributes(Set<ConceptAttribute> attributes) {
		this.attributes = attributes;
	}
	@Override
	public void addAttribute(ConceptAttribute attribute) {
		getAttributes().add(attribute);
		attribute.setOwner(this);
	}
}
package org.openmrs;
import org.openmrs.api.APIException;
import org.springframework.validation.Errors;
import org.springframework.validation.ValidationUtils;
import java.util.Locale;
public class SimpleDosingInstructions extends BaseDosingInstructions {
	private Double dose;
	private Concept doseUnits;
	private Concept route;
	private OrderFrequency frequency;
	private Integer duration;
	private Concept durationUnits;
	private Boolean asNeeded;
	private String asNeededCondition;
	private String administrationInstructions;
	@Override
	public String getDosingInstructionsAsString(Locale locale) {
		StringBuilder dosingInstructions = new StringBuilder();
		dosingInstructions.append(this.dose);
		dosingInstructions.append(" ");
		dosingInstructions.append(this.doseUnits.getName(locale).getName());
		dosingInstructions.append(" ");
		dosingInstructions.append(this.route.getName(locale).getName());
		dosingInstructions.append(" ");
		dosingInstructions.append(this.frequency);
		if (duration != null) {
			dosingInstructions.append(" ");
			dosingInstructions.append(this.duration);
			dosingInstructions.append(" ");
			dosingInstructions.append(this.durationUnits.getName(locale).getName());
		}
		if (this.asNeeded) {
			dosingInstructions.append(" ");
			dosingInstructions.append("PRN");
			if (this.asNeededCondition != null) {
				dosingInstructions.append(" ");
				dosingInstructions.append(this.asNeededCondition);
			}
		}
		if (this.administrationInstructions != null) {
			dosingInstructions.append(" ");
			dosingInstructions.append(this.administrationInstructions);
		}
		return dosingInstructions.toString();
	}
	@Override
	public void setDosingInstructions(DrugOrder order) {
		order.setDosingType(this.getClass());
		order.setDose(this.dose);
		order.setDoseUnits(this.doseUnits);
		order.setRoute(this.route);
		order.setFrequency(this.frequency);
		order.setDuration(this.duration);
		order.setDurationUnits(this.durationUnits);
		order.setAsNeeded(this.asNeeded);
		order.setAsNeededCondition(this.asNeededCondition);
		order.setDosingInstructions(this.administrationInstructions);
	}
	@Override
	public DosingInstructions getDosingInstructions(DrugOrder order) {
		if (!order.getDosingType().equals(this.getClass())) {
			throw new APIException("DrugOrder.error.dosingTypeIsMismatched", new Object[] { this.getClass().getName(),
			        order.getDosingType() });
		}
		SimpleDosingInstructions simpleDosingInstructions = new SimpleDosingInstructions();
		simpleDosingInstructions.setDose(order.getDose());
		simpleDosingInstructions.setDoseUnits(order.getDoseUnits());
		simpleDosingInstructions.setRoute(order.getRoute());
		simpleDosingInstructions.setFrequency(order.getFrequency());
		simpleDosingInstructions.setDuration(order.getDuration());
		simpleDosingInstructions.setDurationUnits(order.getDurationUnits());
		simpleDosingInstructions.setAsNeeded(order.getAsNeeded());
		simpleDosingInstructions.setAsNeededCondition(order.getAsNeededCondition());
		simpleDosingInstructions.setAdministrationInstructions(order.getDosingInstructions());
		return simpleDosingInstructions;
	}
	@Override
	public void validate(DrugOrder order, Errors errors) {
		ValidationUtils.rejectIfEmpty(errors, "dose", "DrugOrder.error.doseIsNullForDosingTypeSimple");
		ValidationUtils.rejectIfEmpty(errors, "doseUnits", "DrugOrder.error.doseUnitsIsNullForDosingTypeSimple");
		ValidationUtils.rejectIfEmpty(errors, "route", "DrugOrder.error.routeIsNullForDosingTypeSimple");
		ValidationUtils.rejectIfEmpty(errors, "frequency", "DrugOrder.error.frequencyIsNullForDosingTypeSimple");
		if (order.getAutoExpireDate() == null && order.getDurationUnits() != null
		        && Duration.getCode(order.getDurationUnits()) == null) {
			errors.rejectValue("durationUnits", "DrugOrder.error.durationUnitsNotMappedToSnomedCtDurationCode");
		}
	}
	public Double getDose() {
		return dose;
	}
	public void setDose(Double dose) {
		this.dose = dose;
	}
	public Concept getDoseUnits() {
		return doseUnits;
	}
	public void setDoseUnits(Concept doseUnits) {
		this.doseUnits = doseUnits;
	}
	public Concept getRoute() {
		return route;
	}
	public void setRoute(Concept route) {
		this.route = route;
	}
	public OrderFrequency getFrequency() {
		return frequency;
	}
	public void setFrequency(OrderFrequency frequency) {
		this.frequency = frequency;
	}
	public Integer getDuration() {
		return duration;
	}
	public void setDuration(Integer duration) {
		this.duration = duration;
	}
	public Concept getDurationUnits() {
		return durationUnits;
	}
	public void setDurationUnits(Concept durationUnits) {
		this.durationUnits = durationUnits;
	}
	public Boolean getAsNeeded() {
		return asNeeded;
	}
	public void setAsNeeded(Boolean asNeeded) {
		this.asNeeded = asNeeded;
	}
	public String getAsNeededCondition() {
		return asNeededCondition;
	}
	public void setAsNeededCondition(String asNeededCondition) {
		this.asNeededCondition = asNeededCondition;
	}
	public String getAdministrationInstructions() {
		return administrationInstructions;
	}
	public void setAdministrationInstructions(String administrationInstructions) {
		this.administrationInstructions = administrationInstructions;
	}
}
package org.openmrs.api.db.hibernate;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.LockOptions;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.openmrs.Concept;
import org.openmrs.CareSetting;
import org.openmrs.ConceptClass;
import org.openmrs.ConceptName;
import org.openmrs.Encounter;
import org.openmrs.GlobalProperty;
import org.openmrs.Order;
import org.openmrs.OrderAttribute;
import org.openmrs.OrderAttributeType;
import org.openmrs.OrderFrequency;
import org.openmrs.OrderGroup;
import org.openmrs.OrderGroupAttribute;
import org.openmrs.OrderGroupAttributeType;
import org.openmrs.OrderType;
import org.openmrs.Patient;
import org.openmrs.api.APIException;
import org.openmrs.api.db.DAOException;
import org.openmrs.api.db.OrderDAO;
import org.openmrs.parameter.OrderSearchCriteria;
import org.openmrs.User;
import org.openmrs.Visit;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.persistence.FlushModeType;
import javax.persistence.Query;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Join;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.metamodel.Attribute;
import javax.persistence.metamodel.EntityType;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Set;
public class HibernateOrderDAO implements OrderDAO {
	private static final Logger log = LoggerFactory.getLogger(HibernateOrderDAO.class);
	private SessionFactory sessionFactory;
	public HibernateOrderDAO() {
	}
	public void setSessionFactory(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;
	}
	@Override
	public Order saveOrder(Order order) throws DAOException {
		sessionFactory.getCurrentSession().saveOrUpdate(order);
		return order;
	}
	@Override
	public void deleteOrder(Order order) throws DAOException {
		sessionFactory.getCurrentSession().delete(order);
	}
	@Override
	public Order getOrder(Integer orderId) throws DAOException {
		log.debug("getting order #{}", orderId);
		return sessionFactory.getCurrentSession().get(Order.class, orderId);
	}
	@Override
	public List<Order> getOrders(OrderType orderType, List<Patient> patients, List<Concept> concepts, List<User> orderers, List<Encounter> encounters) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Order> cq = cb.createQuery(Order.class);
		Root<Order> root = cq.from(Order.class);
		List<Predicate> predicates = new ArrayList<>();
		if (orderType != null) {
			predicates.add(cb.equal(root.get("orderType"), orderType));
		}
		if (!patients.isEmpty()) {
			predicates.add(root.get("patient").in(patients));
		}
		if (!concepts.isEmpty()) {
			predicates.add(root.get("concept").in(concepts));
		}
		if (!orderers.isEmpty()) {
			predicates.add(root.get("orderer").in(orderers));
		}
		if (!encounters.isEmpty()) {
			predicates.add(root.get("encounter").in(encounters));
		}
		cq.where(predicates.toArray(new Predicate[]{}));
		cq.orderBy(cb.desc(root.get("dateActivated")));
		return session.createQuery(cq).getResultList();
	}
	@Override
	public List<Order> getOrders(OrderSearchCriteria searchCriteria) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Order> cq = cb.createQuery(Order.class);
		Root<Order> root = cq.from(Order.class);
		List<Predicate> predicates = new ArrayList<>();
		if (searchCriteria.getPatient() != null && searchCriteria.getPatient().getPatientId() != null) {
			predicates.add(cb.equal(root.get("patient"), searchCriteria.getPatient()));
		}
		if (searchCriteria.getCareSetting() != null && searchCriteria.getCareSetting().getId() != null) {
			predicates.add(cb.equal(root.get("careSetting"), searchCriteria.getCareSetting()));
		}
		if (searchCriteria.getConcepts() != null && !searchCriteria.getConcepts().isEmpty()) {
			predicates.add(root.get("concept").in(searchCriteria.getConcepts()));
		}
		if (searchCriteria.getOrderTypes() != null && !searchCriteria.getOrderTypes().isEmpty()) {
			predicates.add(root.get("orderType").in(searchCriteria.getOrderTypes()));
		}
		if (searchCriteria.getOrderNumber() != null) {
			predicates.add(cb.equal(cb.lower(root.get("orderNumber")), searchCriteria.getOrderNumber().toLowerCase()));
		}
		if (searchCriteria.getAccessionNumber() != null) {
			predicates.add(cb.equal(cb.lower(root.get("accessionNumber")), searchCriteria.getAccessionNumber().toLowerCase()));
		}
		if (searchCriteria.getVisit() != null && searchCriteria.getVisit().getVisitId() != null) {
			predicates.add(cb.equal(root.get("encounter").get("visit"), searchCriteria.getVisit()));
		}
		if (searchCriteria.getActivatedOnOrBeforeDate() != null) {
			Calendar cal = Calendar.getInstance();
			cal.setTime(searchCriteria.getActivatedOnOrBeforeDate());
			predicates.add(cb.lessThanOrEqualTo(root.get("dateActivated"), OpenmrsUtil.getLastMomentOfDay(cal.getTime())));
		}
		if (searchCriteria.getActivatedOnOrAfterDate() != null) {
			Calendar cal = Calendar.getInstance();
			cal.setTime(searchCriteria.getActivatedOnOrAfterDate());
			predicates.add(cb.greaterThanOrEqualTo(root.get("dateActivated"), OpenmrsUtil.firstSecondOfDay(cal.getTime())));
		}
		if (searchCriteria.isStopped()) {
			predicates.add(cb.isNotNull(root.get("dateStopped")));
		}
		if (searchCriteria.getAutoExpireOnOrBeforeDate() != null) {
			Calendar cal = Calendar.getInstance();
			cal.setTime(searchCriteria.getAutoExpireOnOrBeforeDate());
			predicates.add(cb.lessThanOrEqualTo(root.get("autoExpireDate"), OpenmrsUtil.getLastMomentOfDay(cal.getTime())));
		}
		if (searchCriteria.getAction() != null) {
			predicates.add(cb.equal(root.get("action"), searchCriteria.getAction()));
		}
		if (searchCriteria.getExcludeDiscontinueOrders()) {
			predicates.add(cb.or(
				cb.notEqual(root.get("action"), Order.Action.DISCONTINUE),
				cb.isNull(root.get("action"))));
		}
		Predicate fulfillerStatusExpr = null;
		if (searchCriteria.getFulfillerStatus() != null) {
			fulfillerStatusExpr = cb.equal(root.get("fulfillerStatus"), searchCriteria.getFulfillerStatus());
		}
		Predicate fulfillerStatusCriteria = null;
		if (searchCriteria.getIncludeNullFulfillerStatus() != null ) {
			if (searchCriteria.getIncludeNullFulfillerStatus()) {
				fulfillerStatusCriteria = cb.isNull(root.get("fulfillerStatus"));
			} else {
				fulfillerStatusCriteria = cb.isNotNull(root.get("fulfillerStatus"));
			}
		}
		if (fulfillerStatusExpr != null && fulfillerStatusCriteria != null) {
			predicates.add(cb.or(fulfillerStatusExpr, fulfillerStatusCriteria));
		} else if (fulfillerStatusExpr != null) {
			predicates.add(fulfillerStatusExpr);
		} else if ( fulfillerStatusCriteria != null ){
			predicates.add(fulfillerStatusCriteria);
		}
		if (searchCriteria.getExcludeCanceledAndExpired()) {
			Calendar cal = Calendar.getInstance();
			predicates.add(cb.or(
				cb.isNull(root.get("autoExpireDate")),
				cb.greaterThan(root.get("autoExpireDate"), cal.getTime())));
			predicates.add(cb.or(
				cb.isNull(root.get("dateStopped")),
				cb.greaterThan(root.get("dateStopped"), cal.getTime())));
		}
		if (searchCriteria.getCanceledOrExpiredOnOrBeforeDate() != null) {
			Calendar cal = Calendar.getInstance();
			cal.setTime(searchCriteria.getCanceledOrExpiredOnOrBeforeDate());
			predicates.add(cb.or(
				cb.and(cb.isNotNull(root.get("dateStopped")), cb.lessThanOrEqualTo(root.get("dateStopped"), OpenmrsUtil.getLastMomentOfDay(cal.getTime()))),
				cb.and(cb.isNotNull(root.get("autoExpireDate")), cb.lessThanOrEqualTo(root.get("autoExpireDate"), OpenmrsUtil.getLastMomentOfDay(cal.getTime())))));
		}
		if (!searchCriteria.getIncludeVoided()) {
			predicates.add(cb.isFalse(root.get("voided")));
		}
		cq.where(predicates.toArray(new Predicate[]{}));
		cq.orderBy(cb.desc(root.get("dateActivated")));
		return session.createQuery(cq).getResultList();
	}
	@Override
	public List<Order> getOrders(Patient patient, CareSetting careSetting, List<OrderType> orderTypes, boolean includeVoided,
	        boolean includeDiscontinuationOrders) {
		return this.getOrders(patient, null, careSetting, orderTypes, includeVoided, includeDiscontinuationOrders);
	}
	@Override
	public List<Order> getOrders(Patient patient, Visit visit, CareSetting careSetting, List<OrderType> orderTypes, boolean includeVoided,
	        boolean includeDiscontinuationOrders) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Order> cq = cb.createQuery(Order.class);
		Root<Order> root = cq.from(Order.class);
		List<Predicate> predicates = createOrderCriteria(cb, root, patient, visit, careSetting, orderTypes, includeVoided, includeDiscontinuationOrders);
		cq.where(predicates.toArray(new Predicate[]{}));
		return session.createQuery(cq).getResultList();
	}
	@Override
	public Order getOrderByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, Order.class, uuid);
	}
	@Override
	public Order getDiscontinuationOrder(Order order) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Order> cq = cb.createQuery(Order.class);
		Root<Order> root = cq.from(Order.class);
		cq.where(
			cb.equal(root.get("previousOrder"), order),
			cb.equal(root.get("action"), Order.Action.DISCONTINUE),
			cb.isFalse(root.get("voided"))
		);
		return session.createQuery(cq).uniqueResult();
	}
	@Override
	public Order getRevisionOrder(Order order) throws APIException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Order> cq = cb.createQuery(Order.class);
		Root<Order> root = cq.from(Order.class);
		cq.where(
			cb.equal(root.get("previousOrder"), order),
			cb.equal(root.get("action"), Order.Action.REVISE),
			cb.isFalse(root.get("voided"))
		);
		return session.createQuery(cq).uniqueResult();
	}
	@Override
	public List<Object[]> getOrderFromDatabase(Order order, boolean isOrderADrugOrder) throws APIException {
		String sql = "SELECT patient_id, care_setting, concept_id FROM orders WHERE order_id = :orderId";
		if (isOrderADrugOrder) {
			sql = " SELECT o.patient_id, o.care_setting, o.concept_id, d.drug_inventory_id "
			        + " FROM orders o, drug_order d WHERE o.order_id = d.order_id AND o.order_id = :orderId";
		}
		Query query = sessionFactory.getCurrentSession().createSQLQuery(sql);
		query.setParameter("orderId", order.getOrderId());
		query.setFlushMode(FlushModeType.COMMIT);
		return query.getResultList();
	}
	@Override
	public OrderGroup saveOrderGroup(OrderGroup orderGroup) throws DAOException {
		sessionFactory.getCurrentSession().saveOrUpdate(orderGroup);
		return orderGroup;
	}
	@Override
	public OrderGroup getOrderGroupByUuid(String uuid) throws DAOException {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, OrderGroup.class, uuid);
	}
	@Override
	public OrderGroup getOrderGroupById(Integer orderGroupId) throws DAOException {
		return sessionFactory.getCurrentSession().get(OrderGroup.class, orderGroupId);
	}
	@Override
	public void deleteObsThatReference(Order order) {
		if (order != null) {
			sessionFactory.getCurrentSession().createQuery("delete Obs where order = :order").setParameter("order", order)
			        .executeUpdate();
		}
	}
	@Override
	public Order getOrderByOrderNumber(String orderNumber) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Order> cq = cb.createQuery(Order.class);
		Root<Order> root = cq.from(Order.class);
		cq.where(cb.equal(root.get("orderNumber"), orderNumber));
		return session.createQuery(cq).uniqueResult();
	}
	@Override
	public Long getNextOrderNumberSeedSequenceValue() {
		GlobalProperty globalProperty = sessionFactory.getCurrentSession().get(GlobalProperty.class,
		    OpenmrsConstants.GP_NEXT_ORDER_NUMBER_SEED, LockOptions.UPGRADE);
		if (globalProperty == null) {
			throw new APIException("GlobalProperty.missing", new Object[] { OpenmrsConstants.GP_NEXT_ORDER_NUMBER_SEED });
		}
		String gpTextValue = globalProperty.getPropertyValue();
		if (StringUtils.isBlank(gpTextValue)) {
			throw new APIException("GlobalProperty.invalid.value",
			        new Object[] { OpenmrsConstants.GP_NEXT_ORDER_NUMBER_SEED });
		}
		Long gpNumericValue;
		try {
			gpNumericValue = Long.parseLong(gpTextValue);
		}
		catch (NumberFormatException ex) {
			throw new APIException("GlobalProperty.invalid.value",
			        new Object[] { OpenmrsConstants.GP_NEXT_ORDER_NUMBER_SEED });
		}
		globalProperty.setPropertyValue(String.valueOf(gpNumericValue + 1));
		sessionFactory.getCurrentSession().save(globalProperty);
		return gpNumericValue;
	}
	@Override
	public List<Order> getActiveOrders(Patient patient, List<OrderType> orderTypes, CareSetting careSetting, Date asOfDate) {
		return this.getActiveOrders(patient, null, orderTypes, careSetting, asOfDate);
	}
	@Override
	public List<Order> getActiveOrders(Patient patient, Visit visit, List<OrderType> orderTypes, CareSetting careSetting, Date asOfDate) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Order> cq = cb.createQuery(Order.class);
		Root<Order> root = cq.from(Order.class);
		List<Predicate> predicates = createOrderCriteria(cb, root, patient, visit, careSetting, orderTypes, false, false);
		predicates.add(cb.lessThanOrEqualTo(root.get("dateActivated"), asOfDate));
		Predicate dateStoppedAndAutoExpDateCondition = cb.or(
			cb.and(cb.isNull(root.get("dateStopped")), cb.isNull(root.get("autoExpireDate"))),
			cb.and(cb.isNull(root.get("dateStopped")), cb.greaterThanOrEqualTo(root.get("autoExpireDate"), asOfDate)),
			cb.greaterThanOrEqualTo(root.get("dateStopped"), asOfDate)
		);
		predicates.add(dateStoppedAndAutoExpDateCondition);
		cq.where(predicates.toArray(new Predicate[]{}));
		return session.createQuery(cq).getResultList();
	}
	private List<Predicate> createOrderCriteria(CriteriaBuilder cb, Root<Order> root, Patient patient, Visit visit,
	        CareSetting careSetting, List<OrderType> orderTypes, boolean includeVoided,
	        boolean includeDiscontinuationOrders) {
		List<Predicate> predicates = new ArrayList<>();
		if (patient != null) {
			predicates.add(cb.equal(root.get("patient"), patient));
		}
		if (visit != null) {
			predicates.add(cb.equal(root.get("encounter").get("visit"), visit));
		}
		if (careSetting != null) {
			predicates.add(cb.equal(root.get("careSetting"), careSetting));
		}
		if (orderTypes != null && !orderTypes.isEmpty()) {
			predicates.add(root.get("orderType").in(orderTypes));
		}
		if (!includeVoided) {
			predicates.add(cb.isFalse(root.get("voided")));
		}
		if (!includeDiscontinuationOrders) {
			predicates.add(cb.notEqual(root.get("action"), Order.Action.DISCONTINUE));
		}
		return predicates;
	}
	@Override
	public CareSetting getCareSetting(Integer careSettingId) {
		return sessionFactory.getCurrentSession().get(CareSetting.class, careSettingId);
	}
	@Override
	public CareSetting getCareSettingByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, CareSetting.class, uuid);
	}
	@Override
	public CareSetting getCareSettingByName(String name) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<CareSetting> cq = cb.createQuery(CareSetting.class);
		Root<CareSetting> root = cq.from(CareSetting.class);
		cq.where(cb.like(cb.lower(root.get("name")), name.toLowerCase()));
		return session.createQuery(cq).uniqueResult();
	}
	@Override
	public List<CareSetting> getCareSettings(boolean includeRetired) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<CareSetting> cq = cb.createQuery(CareSetting.class);
		Root<CareSetting> root = cq.from(CareSetting.class);
		if (!includeRetired) {
			cq.where(cb.isFalse(root.get("retired")));
		}
		return session.createQuery(cq).getResultList();
	}
	@Override
	public OrderType getOrderTypeByName(String orderTypeName) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderType> cq = cb.createQuery(OrderType.class);
		Root<OrderType> root = cq.from(OrderType.class);
		cq.where(cb.equal(root.get("name"), orderTypeName));
		return session.createQuery(cq).uniqueResult();
	}
	@Override
	public OrderFrequency getOrderFrequency(Integer orderFrequencyId) {
		return sessionFactory.getCurrentSession().get(OrderFrequency.class, orderFrequencyId);
	}
	@Override
	public OrderFrequency getOrderFrequencyByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, OrderFrequency.class, uuid);
	}
	@Override
	public List<OrderFrequency> getOrderFrequencies(boolean includeRetired) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderFrequency> cq = cb.createQuery(OrderFrequency.class);
		Root<OrderFrequency> root = cq.from(OrderFrequency.class);
		if (!includeRetired) {
			cq.where(cb.isFalse(root.get("retired")));
		}
		return session.createQuery(cq).getResultList();
	}
	@Override
	public List<OrderFrequency> getOrderFrequencies(String searchPhrase, Locale locale, boolean exactLocale,
	        boolean includeRetired) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderFrequency> cq = cb.createQuery(OrderFrequency.class);
		Root<OrderFrequency> root = cq.from(OrderFrequency.class);
		Join<OrderFrequency, Concept> conceptJoin = root.join("concept");
		Join<Concept, ConceptName> conceptNameJoin = conceptJoin.join("names");
		List<Predicate> predicates = new ArrayList<>();
		Predicate searchPhrasePredicate = cb.like(cb.lower(conceptNameJoin.get("name")), MatchMode.ANYWHERE.toLowerCasePattern(searchPhrase));
		predicates.add(searchPhrasePredicate);
		if (locale != null) {
			List<Locale> locales = new ArrayList<>(2);
			locales.add(locale);
			if (!exactLocale && StringUtils.isNotBlank(locale.getCountry())) {
				locales.add(new Locale(locale.getLanguage()));
			}
			predicates.add(conceptNameJoin.get("locale").in(locales));
		}
		if (!includeRetired) {
			predicates.add(cb.isFalse(root.get("retired")));
		}
		cq.where(predicates.toArray(new Predicate[]{})).distinct(true);
		return session.createQuery(cq).list();
	}
	@Override
	public OrderFrequency saveOrderFrequency(OrderFrequency orderFrequency) {
		sessionFactory.getCurrentSession().saveOrUpdate(orderFrequency);
		return orderFrequency;
	}
	@Override
	public void purgeOrderFrequency(OrderFrequency orderFrequency) {
		sessionFactory.getCurrentSession().delete(orderFrequency);
	}
	@Override
	public boolean isOrderFrequencyInUse(OrderFrequency orderFrequency) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		Set<EntityType<?>> entities = sessionFactory.getMetamodel().getEntities();
		for (EntityType<?> entityTpe : entities) {
			Class<?> entityClass = entityTpe.getJavaType();
			if (Order.class.equals(entityClass)) {
				continue;
			}
			if (!Order.class.isAssignableFrom(entityClass)) {
				continue;
			}
			for (Attribute<?,?> attribute : entityTpe.getDeclaredAttributes()) {
				if (attribute.getJavaType().equals(OrderFrequency.class)) {
					CriteriaQuery<?> cq = cb.createQuery(entityClass);
					Root<?> root = cq.from(entityClass);
					cq.where(cb.equal(root.get(attribute.getName()), orderFrequency));
					cq.distinct(true);
					Query query = session.createQuery(cq);
					query.setMaxResults(1);
					if (!query.getResultList().isEmpty()) {
						return true;
					}
				}
			}
		}
		return false;
	}
	@Override
	public OrderFrequency getOrderFrequencyByConcept(Concept concept) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderFrequency> cq = cb.createQuery(OrderFrequency.class);
		Root<OrderFrequency> root = cq.from(OrderFrequency.class);
		cq.where(cb.equal(root.get("concept"), concept));
		return session.createQuery(cq).uniqueResult();
	}
	@Override
	public OrderType getOrderType(Integer orderTypeId) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderType> cq = cb.createQuery(OrderType.class);
		Root<OrderType> root = cq.from(OrderType.class);
		cq.where(cb.equal(root.get("orderTypeId"), orderTypeId));
		return session.createQuery(cq).uniqueResult();
	}
	@Override
	public OrderType getOrderTypeByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, OrderType.class, uuid);
	}
	@Override
	public List<OrderType> getOrderTypes(boolean includeRetired) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderType> cq = cb.createQuery(OrderType.class);
		Root<OrderType> root = cq.from(OrderType.class);
		if (!includeRetired) {
			cq.where(cb.isFalse(root.get("retired")));
		}
		return session.createQuery(cq).getResultList();
	}
	@Override
	public OrderType getOrderTypeByConceptClass(ConceptClass conceptClass) {
		return (OrderType) sessionFactory.getCurrentSession().createQuery(
		    "from OrderType where :conceptClass in elements(conceptClasses)").setParameter("conceptClass", conceptClass)
		        .uniqueResult();
	}
	@Override
	public OrderType saveOrderType(OrderType orderType) {
		sessionFactory.getCurrentSession().saveOrUpdate(orderType);
		return orderType;
	}
	@Override
	public void purgeOrderType(OrderType orderType) {
		sessionFactory.getCurrentSession().delete(orderType);
	}
	@Override
	public List<OrderType> getOrderSubtypes(OrderType orderType, boolean includeRetired) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderType> cq = cb.createQuery(OrderType.class);
		Root<OrderType> root = cq.from(OrderType.class);
		List<Predicate> predicates = new ArrayList<>();
		if (!includeRetired) {
			predicates.add(cb.isFalse(root.get("retired")));
		}
		predicates.add(cb.equal(root.get("parent"), orderType));
		cq.where(predicates.toArray(new Predicate[]{}));
		return session.createQuery(cq).getResultList();
	}
	@Override
	public boolean isOrderTypeInUse(OrderType orderType) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Order> cq = cb.createQuery(Order.class);
		Root<Order> root = cq.from(Order.class);
		cq.where(cb.equal(root.get("orderType"), orderType));
		return !session.createQuery(cq).getResultList().isEmpty();
	}
	@Override
	public List<OrderGroup> getOrderGroupsByPatient(Patient patient) {
		if (patient == null) {
			throw new APIException("Patient cannot be null");
		}
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderGroup> cq = cb.createQuery(OrderGroup.class);
		Root<OrderGroup> root = cq.from(OrderGroup.class);
		cq.where(cb.equal(root.get("patient"), patient));
		return session.createQuery(cq).getResultList();
	}
	@Override
	public List<OrderGroup> getOrderGroupsByEncounter(Encounter encounter) {
		if (encounter == null) {
			throw new APIException("Encounter cannot be null");
		}
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderGroup> cq = cb.createQuery(OrderGroup.class);
		Root<OrderGroup> root = cq.from(OrderGroup.class);
		cq.where(cb.equal(root.get("encounter"), encounter));
		return session.createQuery(cq).getResultList();
	}
	@Override
	public List<OrderGroupAttributeType> getAllOrderGroupAttributeTypes() {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderGroupAttributeType> cq = cb.createQuery(OrderGroupAttributeType.class);
		cq.from(OrderGroupAttributeType.class);
		return session.createQuery(cq).getResultList();
	}
	@Override
	public OrderGroupAttributeType getOrderGroupAttributeType(Integer orderGroupAttributeTypeId) throws DAOException{
		return sessionFactory.getCurrentSession().get(OrderGroupAttributeType.class, orderGroupAttributeTypeId);
	}
	@Override
	public OrderGroupAttributeType getOrderGroupAttributeTypeByUuid(String uuid) throws DAOException{
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, OrderGroupAttributeType.class, uuid);
	}
	@Override
	public OrderGroupAttributeType saveOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType)throws DAOException {
		sessionFactory.getCurrentSession().saveOrUpdate(orderGroupAttributeType);
		return orderGroupAttributeType;
	}
	@Override
	public void deleteOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType) throws DAOException{
		sessionFactory.getCurrentSession().delete(orderGroupAttributeType);
	}
	@Override
	public OrderGroupAttribute getOrderGroupAttributeByUuid(String uuid)  throws DAOException{
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, OrderGroupAttribute.class, uuid);
	}
	@Override
	public OrderGroupAttributeType getOrderGroupAttributeTypeByName(String name) throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderGroupAttributeType> cq = cb.createQuery(OrderGroupAttributeType.class);
		Root<OrderGroupAttributeType> root = cq.from(OrderGroupAttributeType.class);
		cq.where(cb.equal(root.get("name"), name));
		return session.createQuery(cq).uniqueResult();
	}
	@Override
	public OrderAttribute getOrderAttributeByUuid(String uuid) throws DAOException {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, OrderAttribute.class, uuid);
	}
	@Override
	public List<OrderAttributeType> getAllOrderAttributeTypes() throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderAttributeType> cq = cb.createQuery(OrderAttributeType.class);
		cq.from(OrderAttributeType.class);
		return session.createQuery(cq).getResultList();
	}
	@Override
	public OrderAttributeType getOrderAttributeTypeById(Integer orderAttributeTypeId) throws DAOException {
		return sessionFactory.getCurrentSession().get(OrderAttributeType.class, orderAttributeTypeId);
	}
	@Override
	public OrderAttributeType getOrderAttributeTypeByUuid(String uuid) throws DAOException {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, OrderAttributeType.class, uuid);
	}
	@Override
	public OrderAttributeType saveOrderAttributeType(OrderAttributeType orderAttributeType) throws DAOException {
		sessionFactory.getCurrentSession().saveOrUpdate(orderAttributeType);
		return orderAttributeType;
	}
	@Override
	public void deleteOrderAttributeType(OrderAttributeType orderAttributeType) throws DAOException {
		sessionFactory.getCurrentSession().delete(orderAttributeType);
	}
	@Override
	public OrderAttributeType getOrderAttributeTypeByName(String name) throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<OrderAttributeType> cq = cb.createQuery(OrderAttributeType.class);
		Root<OrderAttributeType> root = cq.from(OrderAttributeType.class);
		cq.where(cb.equal(root.get("name"), name));
		return session.createQuery(cq).uniqueResult();
	}
}
package org.openmrs;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.annotations.GenericGenerator;
import org.hibernate.annotations.Parameter;
import org.hibernate.envers.Audited;
import org.openmrs.annotation.Independent;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Set;
@Entity
@Table(name = "order_type")
@Audited
public class OrderType extends BaseChangeableOpenmrsMetadata {
	public static final long serialVersionUID = 23232L;
	public static final String DRUG_ORDER_TYPE_UUID = "131168f4-15f5-102d-96e4-000c29c2a5d7";
	public static final String TEST_ORDER_TYPE_UUID = "52a447d3-a64a-11e3-9aeb-50e549534c5e";
	public static final String REFERRAL_ORDER_TYPE_UUID = "f1b63696-2b6c-11ec-8d3d-0242ac130003";
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "order_type_id_seq")
	@GenericGenerator(
		name = "order_type_id_seq",
		strategy = "native",
		parameters = @Parameter(name = "sequence", value = "order_type_order_type_id_seq")
	)
	@Column(name = "order_type_id", nullable = false)
	private Integer orderTypeId;
	@Column(name = "java_class_name", nullable = false)
	private String javaClassName;
	@ManyToOne
	@JoinColumn(name = "parent")
	private OrderType parent;
	@Independent
	@ManyToMany
	@JoinTable(
		name = "order_type_class_map", 
		joinColumns = @JoinColumn(name = "order_type_id"), 
		inverseJoinColumns = @JoinColumn(name = "concept_class_id"), 
		uniqueConstraints = @UniqueConstraint(columnNames = {"order_type_id", "concept_class_id"})
	)
	private Set<ConceptClass> conceptClasses;
	public OrderType() {
	}
	public OrderType(Integer orderTypeId) {
		this.orderTypeId = orderTypeId;
	}
	public OrderType(String name, String description, String javaClassName) {
		setName(name);
		setDescription(description);
		setJavaClassName(javaClassName);
	}
	public Integer getOrderTypeId() {
		return orderTypeId;
	}
	public void setOrderTypeId(Integer orderTypeId) {
		this.orderTypeId = orderTypeId;
	}
	@Override
	public Integer getId() {
		return getOrderTypeId();
	}
	@Override
	public void setId(Integer id) {
		setOrderTypeId(id);
	}
	public String getJavaClassName() {
		return javaClassName;
	}
	public void setJavaClassName(String javaClassName) {
		this.javaClassName = javaClassName;
	}
	public OrderType getParent() {
		return parent;
	}
	public void setParent(OrderType parent) {
		this.parent = parent;
	}
	public Set<ConceptClass> getConceptClasses() {
		if (conceptClasses == null) {
			conceptClasses = new LinkedHashSet<>();
		}
		return conceptClasses;
	}
	public void setConceptClasses(Set<ConceptClass> conceptClasses) {
		this.conceptClasses = conceptClasses;
	}
	public Class getJavaClass() {
		try {
			return Context.loadClass(javaClassName);
		}
		catch (ClassNotFoundException e) {
			throw new APIException("OrderType.failed.load.class", new Object[] { javaClassName }, e);
		}
	}
	public void addConceptClass(ConceptClass conceptClass) {
		getConceptClasses().add(conceptClass);
	}
	@Override
	public String toString() {
		if (StringUtils.isNotBlank(getName())) {
			return getName();
		}
		return super.toString();
	}
}
package org.openmrs.api.db.hibernate;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Join;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Subquery;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.Hibernate;
import org.hibernate.ScrollMode;
import org.hibernate.ScrollableResults;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.dialect.Dialect;
import org.hibernate.dialect.HSQLDialect;
import org.hibernate.dialect.PostgreSQL82Dialect;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.proxy.HibernateProxy;
import org.openmrs.Location;
import org.openmrs.LocationAttribute;
import org.openmrs.api.db.DAOException;
import org.openmrs.attribute.AttributeType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class HibernateUtil {
	private HibernateUtil() {
	}
	private static final Logger log = LoggerFactory.getLogger(HibernateUtil.class);
	private static Dialect dialect = null;
	private static Boolean isHSQLDialect = null;
	private static Boolean isPostgreSQLDialect = null;
	public static boolean isHSQLDialect(SessionFactory sessionFactory) {
		if (isHSQLDialect == null) {
			isHSQLDialect = HSQLDialect.class.getName().equals(getDialect(sessionFactory).getClass().getName());
		}
		return isHSQLDialect;
	}
	public static boolean isPostgreSQLDialect(SessionFactory sessionFactory) {
		if (isPostgreSQLDialect == null) {
			isPostgreSQLDialect = PostgreSQL82Dialect.class.getName()
			        .equals(getDialect(sessionFactory).getClass().getName());
		}
		return isPostgreSQLDialect;
	}
	public static Dialect getDialect(SessionFactory sessionFactory) {
		if (dialect != null) {
			return dialect;
		}
		SessionFactoryImplementor implementor = (SessionFactoryImplementor) sessionFactory;
		dialect = implementor.getDialect();
		log.debug("Getting dialect for session: {}", dialect);
		return dialect;
	}
	public static String escapeSqlWildcards(final String oldString, SessionFactory sessionFactory) {
		return sessionFactory.getCurrentSession().doReturningWork(connection -> escapeSqlWildcards(oldString, connection));
	}
	public static String escapeSqlWildcards(String oldString, Connection connection) {
		if (!StringUtils.isBlank(oldString)) {
			String escapeCharacter = "";
			try {
				escapeCharacter = connection.getMetaData().getSearchStringEscape();
			}
			catch (SQLException e) {
				log.warn("Error generated", e);
			}
			return StringUtils.replaceEach(oldString, new String[] { "%", "_", "*", "'" }, new String[] {
			        escapeCharacter + "%", escapeCharacter + "_", escapeCharacter + "*", "''" });
		} else {
			return oldString;
		}
	}
	public static <AT extends AttributeType> List<Predicate> getAttributePredicate(CriteriaBuilder cb,
	        Root<Location> locationRoot, Map<AT, String> serializedAttributeValues) {
		List<Predicate> predicates = new ArrayList<>();
		for (Map.Entry<AT, String> entry : serializedAttributeValues.entrySet()) {
			Subquery<Integer> subquery = cb.createQuery().subquery(Integer.class);
			Root<Location> locationSubRoot = subquery.from(Location.class);
			Join<Location, LocationAttribute> attributeJoin = locationSubRoot.join("attributes");
			Predicate[] attributePredicates = new Predicate[] { cb.equal(attributeJoin.get("attributeType"), entry.getKey()),
			        cb.equal(attributeJoin.get("valueReference"), entry.getValue()),
			        cb.isFalse(attributeJoin.get("voided")) };
			subquery.select(locationSubRoot.get("locationId")).where(attributePredicates);
			predicates.add(cb.in(locationRoot.get("locationId")).value(subquery));
		}
		return predicates;
	}
	public static <T> T getRealObjectFromProxy(T persistentObject) {
		if (persistentObject == null) {
			return null;
		}
		if (persistentObject instanceof HibernateProxy) {
			Hibernate.initialize(persistentObject);
			persistentObject = (T) ((HibernateProxy) persistentObject).getHibernateLazyInitializer().getImplementation();
		}
		return persistentObject;
	}
	public static <T> T getUniqueEntityByUUID(SessionFactory sessionFactory, Class<T> entityClass, String uuid) throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<T> query = cb.createQuery(entityClass);
		Root<T> root = query.from(entityClass);
		query.where(cb.equal(root.get("uuid"), uuid));
		return session.createQuery(query).uniqueResult();
	}
	public static <T> ScrollableResults getScrollableResult(SessionFactory sessionFactory, Class<T> type, int fetchSize) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();
		CriteriaQuery<T> criteriaQuery = criteriaBuilder.createQuery(type);
		Root<T> root = criteriaQuery.from(type);
		criteriaQuery.select(root);
		return session.createQuery(criteriaQuery)
			.setFetchSize(fetchSize)
			.scroll(ScrollMode.FORWARD_ONLY);
	}
}
package org.openmrs;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.ContainedIn;
@Audited
public class Patient extends Person {
	public static final long serialVersionUID = 93123L;
	private Integer patientId;
	private String allergyStatus = Allergies.UNKNOWN;
	@ContainedIn
	private Set<PatientIdentifier> identifiers;
	public Patient() {
		setPatient(true);
	}
	public Patient(Person person) {
		super(person);
		if (person != null) {
			this.patientId = person.getPersonId();
			if (person.getUuid() != null) {
				this.setUuid(person.getUuid());
			}
		}
		setPatient(true);
	}
	public Patient(Integer patientId) {
		super(patientId);
		this.patientId = patientId;
		setPatient(true);
	}
	public Patient(Patient patient) {
		super(patient);
		this.patientId = patient.getPatientId();
		this.allergyStatus = patient.getAllergyStatus();
		Set<PatientIdentifier> newIdentifiers = new TreeSet<>();
		for (PatientIdentifier pid : patient.getIdentifiers()) {
			PatientIdentifier identifierClone = (PatientIdentifier) pid.clone();
			identifierClone.setPatient(this);
			newIdentifiers.add(identifierClone);
		}
		this.identifiers = newIdentifiers;
	}
	public Integer getPatientId() {
		if (this.patientId == null) {
			this.patientId = getPersonId();
		}
		return this.patientId;
	}
	public void setPatientId(Integer patientId) {
		super.setPersonId(patientId);
		this.patientId = patientId;
	}
	public String getAllergyStatus() {
		return this.allergyStatus;
	}
	public void setAllergyStatus(String allergyStatus) {
		this.allergyStatus = allergyStatus;
	}
	@Override
	public void setPersonId(Integer personId) {
		super.setPersonId(personId);
		this.patientId = personId;
	}
	public Set<PatientIdentifier> getIdentifiers() {
		if (identifiers == null) {
			identifiers = new TreeSet<>();
		}
		return this.identifiers;
	}
	public void setIdentifiers(Set<PatientIdentifier> identifiers) {
		this.identifiers = identifiers;
	}
	public void addIdentifiers(Collection<PatientIdentifier> patientIdentifiers) {
		for (PatientIdentifier identifier : patientIdentifiers) {
			addIdentifier(identifier);
		}
	}
	public void addIdentifier(PatientIdentifier patientIdentifier) {
		if (patientIdentifier != null) {
			patientIdentifier.setPatient(this);
			for (PatientIdentifier currentId : getActiveIdentifiers()) {
				if (currentId.equalsContent(patientIdentifier)) {
					return;
				}
			}
		}
		getIdentifiers().add(patientIdentifier);
	}
	public void removeIdentifier(PatientIdentifier patientIdentifier) {
		if (patientIdentifier != null) {
			getIdentifiers().remove(patientIdentifier);
		}
	}
	public PatientIdentifier getPatientIdentifier() {
		if (!getIdentifiers().isEmpty()) {
			for (PatientIdentifier id : getIdentifiers()) {
				if (id.getPreferred() && !id.getVoided()) {
					return id;
				}
			}
			for (PatientIdentifier id : getIdentifiers()) {
				if (!id.getVoided()) {
					return id;
				}
			}
			return null;
		}
		return null;
	}
	public PatientIdentifier getPatientIdentifier(PatientIdentifierType pit) {
		if (!getIdentifiers().isEmpty()) {
			for (PatientIdentifier id : getIdentifiers()) {
				if (id.getPreferred() && !id.getVoided() && pit.equals(id.getIdentifierType())) {
					return id;
				}
			}
			for (PatientIdentifier id : getIdentifiers()) {
				if (!id.getVoided() && pit.equals(id.getIdentifierType())) {
					return id;
				}
			}
			return null;
		}
		return null;
	}
	public PatientIdentifier getPatientIdentifier(Integer identifierTypeId) {
		if (!getIdentifiers().isEmpty()) {
			for (PatientIdentifier id : getIdentifiers()) {
				if (id.getPreferred() && !id.getVoided()
				        && identifierTypeId.equals(id.getIdentifierType().getPatientIdentifierTypeId())) {
					return id;
				}
			}
			for (PatientIdentifier id : getIdentifiers()) {
				if (!id.getVoided() && identifierTypeId.equals(id.getIdentifierType().getPatientIdentifierTypeId())) {
					return id;
				}
			}
			return null;
		}
		return null;
	}
	public PatientIdentifier getPatientIdentifier(String identifierTypeName) {
		if (!getIdentifiers().isEmpty()) {
			for (PatientIdentifier id : getIdentifiers()) {
				if (id.getPreferred() && !id.getVoided() && identifierTypeName.equals(id.getIdentifierType().getName())) {
					return id;
				}
			}
			for (PatientIdentifier id : getIdentifiers()) {
				if (!id.getVoided() && identifierTypeName.equals(id.getIdentifierType().getName())) {
					return id;
				}
			}
			return null;
		}
		return null;
	}
	public List<PatientIdentifier> getActiveIdentifiers() {
		List<PatientIdentifier> ids = new ArrayList<>();
		List<PatientIdentifier> nonPreferred = new LinkedList<>();
		for (PatientIdentifier pi : getIdentifiers()) {
			if (!pi.getVoided()) {
				if (pi.getPreferred()) {
					ids.add(pi);
				} else {
					nonPreferred.add(pi);
				}
			}
		}
		ids.addAll(nonPreferred);
		return ids;
	}
	public List<PatientIdentifier> getPatientIdentifiers(PatientIdentifierType pit) {
		List<PatientIdentifier> ids = new ArrayList<>();
		for (PatientIdentifier pi : getIdentifiers()) {
			if (!pi.getVoided() && pit.equals(pi.getIdentifierType())) {
				ids.add(pi);
			}
		}
		return ids;
	}
	@Override
	public String toString() {
		return "Patient#" + patientId;
	}
	@Override
	public Integer getId() {
		return getPatientId();
	}
	@Override
	public void setId(Integer id) {
		setPatientId(id);
	}
	public Person getPerson() {
		return this;
	}
}
package org.openmrs.api.handler;
import java.util.Date;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Cohort;
import org.openmrs.Encounter;
import org.openmrs.Obs;
import org.openmrs.Order;
import org.openmrs.Patient;
import org.openmrs.User;
import org.openmrs.Voidable;
import org.openmrs.annotation.Handler;
import org.openmrs.aop.RequiredDataAdvice;
@Handler(supports = { Patient.class, Encounter.class, Obs.class, Cohort.class, Order.class }, order = 1 )
public class RequireVoidReasonVoidHandler implements VoidHandler<Voidable> {
	@Override
	public void handle(Voidable voidableObject, User voidingUser, Date voidedDate, String voidReason) {
		if (StringUtils.isBlank(voidReason)) {
			throw new IllegalArgumentException("The 'reason' argument is required");
		}
	}
}
package org.openmrs.api.db;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import org.openmrs.CareSetting;
import org.openmrs.Order;
import org.openmrs.Encounter;
import org.openmrs.Concept;
import org.openmrs.ConceptClass;
import org.openmrs.OrderAttribute;
import org.openmrs.OrderAttributeType;
import org.openmrs.OrderGroup;
import org.openmrs.OrderType;
import org.openmrs.OrderGroupAttribute;
import org.openmrs.OrderGroupAttributeType;
import org.openmrs.Patient;
import org.openmrs.User;
import org.openmrs.Visit;
import org.openmrs.OrderFrequency;
import org.openmrs.api.APIException;
import org.openmrs.parameter.OrderSearchCriteria;
public interface OrderDAO {
	public Order saveOrder(Order order) throws DAOException;
	public void deleteOrder(Order order) throws DAOException;
	public Order getOrder(Integer orderId) throws DAOException;
	public List<Order> getOrders(OrderType orderType, List<Patient> patients, List<Concept> concepts, List<User> orderers,
	        List<Encounter> encounters);
	public List<Order> getOrders(Patient patient, CareSetting careSetting, List<OrderType> orderTypes,
	        boolean includeVoided, boolean includeDiscontinuationOrders);
	public List<Order> getOrders(OrderSearchCriteria orderSearchCriteria);
	public Order getOrderByUuid(String uuid);
	public void deleteObsThatReference(Order order);
	public Order getOrderByOrderNumber(String orderNumber);
	public Long getNextOrderNumberSeedSequenceValue();
	public List<Order> getActiveOrders(Patient patient, List<OrderType> orderTypes, CareSetting careSetting, Date asOfDate);
	public CareSetting getCareSetting(Integer careSettingId);
	public CareSetting getCareSettingByUuid(String uuid);
	public CareSetting getCareSettingByName(String name);
	public List<CareSetting> getCareSettings(boolean includeRetired);
	public OrderType getOrderTypeByName(String orderTypeName);
	public OrderFrequency getOrderFrequency(Integer orderFrequencyId);
	public OrderFrequency getOrderFrequencyByUuid(String uuid);
	List<OrderFrequency> getOrderFrequencies(boolean includeRetired);
	public List<OrderFrequency> getOrderFrequencies(String searchPhrase, Locale locale, boolean exactLocale,
	        boolean includeRetired);
	public OrderFrequency saveOrderFrequency(OrderFrequency orderFrequency);
	public void purgeOrderFrequency(OrderFrequency orderFrequency);
	public boolean isOrderFrequencyInUse(OrderFrequency orderFrequency);
	public OrderFrequency getOrderFrequencyByConcept(Concept concept);
	public OrderType getOrderType(Integer orderTypeId);
	public OrderType getOrderTypeByUuid(String uuid);
	public List<OrderType> getOrderTypes(boolean includeRetired);
	public OrderType getOrderTypeByConceptClass(ConceptClass conceptClass);
	public OrderType saveOrderType(OrderType orderType);
	public void purgeOrderType(OrderType orderType);
	public List<OrderType> getOrderSubtypes(OrderType orderType, boolean includeRetired);
	public boolean isOrderTypeInUse(OrderType orderType);
	public Order getDiscontinuationOrder(Order order);
	public Order getRevisionOrder(Order order) throws APIException;
	public List<Object[]> getOrderFromDatabase(Order order, boolean isOrderADrugOrder) throws APIException;
	public OrderGroup saveOrderGroup(OrderGroup orderGroup) throws DAOException;
	public OrderGroup getOrderGroupByUuid(String uuid) throws DAOException;
	public OrderGroup getOrderGroupById(Integer orderGroupId) throws DAOException;
	public List<OrderGroup> getOrderGroupsByPatient(Patient patient) throws DAOException;
	public List<OrderGroup> getOrderGroupsByEncounter(Encounter encounter) throws DAOException;
	public OrderGroupAttribute getOrderGroupAttributeByUuid(String uuid) throws DAOException;
	public List<OrderGroupAttributeType> getAllOrderGroupAttributeTypes()throws DAOException;
	public OrderGroupAttributeType getOrderGroupAttributeType(Integer orderGroupAttributeTypeId)throws DAOException;
	public OrderGroupAttributeType getOrderGroupAttributeTypeByUuid(String uuid)throws DAOException;
	public OrderGroupAttributeType  saveOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType)throws DAOException;
	public  void deleteOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType)throws DAOException;
	public OrderGroupAttributeType getOrderGroupAttributeTypeByName(String name)throws DAOException;
	OrderAttribute getOrderAttributeByUuid(String uuid) throws DAOException;
	List<OrderAttributeType> getAllOrderAttributeTypes()throws DAOException;
	OrderAttributeType getOrderAttributeTypeById(Integer orderAttributeTypeId)throws DAOException;
	OrderAttributeType getOrderAttributeTypeByUuid(String uuid)throws DAOException;
	OrderAttributeType saveOrderAttributeType(OrderAttributeType orderAttributeType)throws DAOException;
	void deleteOrderAttributeType(OrderAttributeType orderAttributeType)throws DAOException;
	OrderAttributeType getOrderAttributeTypeByName(String name)throws DAOException;
	public List<Order> getActiveOrders(Patient patient, Visit visit, List<OrderType> orderTypes, CareSetting careSetting,
			Date asOfDate);
	public List<Order> getOrders(Patient patient, Visit visit, CareSetting careSetting, List<OrderType> orderTypes,
			boolean includeVoided, boolean includeDiscontinuationOrders);
}
package org.openmrs.parameter;
import org.openmrs.CareSetting;
import org.openmrs.Concept;
import org.openmrs.Order;
import org.openmrs.OrderType;
import org.openmrs.Patient;
import org.openmrs.Visit;
import java.util.Collection;
import java.util.Date;
public class OrderSearchCriteria {
	private final Patient patient;
	private final CareSetting careSetting;
	private final Collection<Concept> concepts;
	private final Collection<OrderType> orderTypes;
	private final Visit visit;
	private String accessionNumber;
	private String orderNumber;
	private final Date activatedOnOrBeforeDate;
	private final Date activatedOnOrAfterDate;
	private final Date autoExpireOnOrBeforeDate;
	private final boolean isStopped;
	private final Date canceledOrExpiredOnOrBeforeDate;
	private final Order.FulfillerStatus fulfillerStatus;
	private final Boolean includeNullFulfillerStatus;
	private final Order.Action action;
	private final boolean includeVoided;
	private final boolean excludeCanceledAndExpired;
	private final boolean excludeDiscontinueOrders;
	public OrderSearchCriteria(Patient patient, CareSetting careSetting, Collection<Concept> concepts,
			   Collection<OrderType> orderTypes, String accessionNumber, String orderNumber,
			   Date activatedOnOrBeforeDate, Date activatedOnOrAfterDate, boolean isStopped,
			   Date autoExpireOnOrBeforeDate,
			   Date canceledOrExpiredOnOrBeforeDate,
			   Order.Action action,
			   Order.FulfillerStatus fulfillerStatus,
			   Boolean includeNullFulfillerStatus,
			   boolean excludeCanceledAndExpired,
			   boolean excludeDiscontinueOrders,
			   boolean includeVoided) {
		this(patient, careSetting, concepts, orderTypes, null, null,
				activatedOnOrBeforeDate, activatedOnOrAfterDate, isStopped, autoExpireOnOrBeforeDate, canceledOrExpiredOnOrBeforeDate,
				action, fulfillerStatus, includeNullFulfillerStatus, excludeCanceledAndExpired, excludeDiscontinueOrders, includeVoided, null);
	}
	public OrderSearchCriteria(Patient patient, CareSetting careSetting, Collection<Concept> concepts,
							   Collection<OrderType> orderTypes, String accessionNumber, String orderNumber,
							   Date activatedOnOrBeforeDate, Date activatedOnOrAfterDate, boolean isStopped,
							   Date autoExpireOnOrBeforeDate,
							   Date canceledOrExpiredOnOrBeforeDate,
							   Order.Action action,
							   Order.FulfillerStatus fulfillerStatus,
							   Boolean includeNullFulfillerStatus,
							   boolean excludeCanceledAndExpired,
							   boolean excludeDiscontinueOrders,
							   boolean includeVoided,
							   Visit visit) {
		this.patient = patient;
		this.careSetting = careSetting;
		this.concepts = concepts;
		this.orderTypes = orderTypes;
		this.accessionNumber = accessionNumber;
		this.orderNumber = orderNumber;
		this.activatedOnOrBeforeDate = activatedOnOrBeforeDate;
		this.activatedOnOrAfterDate = activatedOnOrAfterDate;
		this.isStopped = isStopped;
		this.autoExpireOnOrBeforeDate = autoExpireOnOrBeforeDate;
		this.canceledOrExpiredOnOrBeforeDate = canceledOrExpiredOnOrBeforeDate;
		this.action = action;
		this.fulfillerStatus = fulfillerStatus;
		this.includeNullFulfillerStatus = includeNullFulfillerStatus;
		this.excludeCanceledAndExpired = excludeCanceledAndExpired;
		this.excludeDiscontinueOrders = excludeDiscontinueOrders;
		this.includeVoided = includeVoided;
		this.visit = visit;
	}
	@Deprecated
	public OrderSearchCriteria(Patient patient, CareSetting careSetting, Collection<Concept> concepts,
							   Collection<OrderType> orderTypes, Date activatedOnOrBeforeDate,
							   Date activatedOnOrAfterDate, boolean isStopped, Date autoExpireOnOrBeforeDate,
							   Date canceledOrExpiredOnOrBeforeDate,
							   Order.Action action,
							   Order.FulfillerStatus fulfillerStatus,
							   Boolean includeNullFulfillerStatus,
							   boolean excludeCanceledAndExpired,
							   boolean excludeDiscontinueOrders,
							   boolean includeVoided) {
		this(patient, careSetting, concepts, orderTypes, null, null,
			activatedOnOrBeforeDate, activatedOnOrAfterDate, isStopped, autoExpireOnOrBeforeDate, canceledOrExpiredOnOrBeforeDate,
			action, fulfillerStatus, includeNullFulfillerStatus, excludeCanceledAndExpired, excludeDiscontinueOrders, includeVoided);
	}
	public Patient getPatient() { return patient; }
	public CareSetting getCareSetting() { return careSetting; }
	public Collection<Concept> getConcepts() { return concepts; }
	public Collection<OrderType> getOrderTypes() { return orderTypes; }
	public Visit getVisit() { return visit; }
	public String getAccessionNumber() {
		return accessionNumber;
	}
	public String getOrderNumber() {
		return orderNumber;
	}
	public Date getActivatedOnOrBeforeDate() { return activatedOnOrBeforeDate; }
	public Date getActivatedOnOrAfterDate() { return activatedOnOrAfterDate; }
	public boolean isStopped() {
		return isStopped;
	}
	public Date getAutoExpireOnOrBeforeDate() {
		return autoExpireOnOrBeforeDate;
	}
	public Date getCanceledOrExpiredOnOrBeforeDate() {
		return canceledOrExpiredOnOrBeforeDate;
	}
	public Order.Action getAction() {
        return action;
    }
	public Order.FulfillerStatus getFulfillerStatus() {
		return fulfillerStatus;
	}
	public Boolean getIncludeNullFulfillerStatus() {
		return includeNullFulfillerStatus;
	}
	public boolean getExcludeCanceledAndExpired() {
		return excludeCanceledAndExpired;
	}
	public boolean getExcludeDiscontinueOrders() {
		return excludeDiscontinueOrders;
	}
	public boolean getIncludeVoided() { return includeVoided; }
}
package org.openmrs;
import org.hibernate.envers.Audited;
@Audited
public class CareSetting extends BaseChangeableOpenmrsMetadata {
	public enum CareSettingType {
		OUTPATIENT,
		INPATIENT
	}
	private Integer careSettingId;
	private CareSettingType careSettingType;
	public CareSetting() {
	}
	public CareSetting(String name, String description, CareSettingType careSettingType) {
		setName(name);
		setDescription(description);
		setCareSettingType(careSettingType);
	}
	public Integer getCareSettingId() {
		return careSettingId;
	}
	public void setCareSettingId(Integer careSettingId) {
		this.careSettingId = careSettingId;
	}
	public CareSettingType getCareSettingType() {
		return careSettingType;
	}
	public void setCareSettingType(CareSettingType careSettingType) {
		this.careSettingType = careSettingType;
	}
	@Override
	public Integer getId() {
		return getCareSettingId();
	}
	@Override
	public void setId(Integer id) {
		setCareSettingId(id);
	}
}
package org.openmrs;
import org.hibernate.envers.Audited;
import org.openmrs.attribute.AttributeType;
import org.openmrs.attribute.BaseAttributeType;
@Audited
public class OrderAttributeType extends BaseAttributeType<Order> implements AttributeType<Order> {
	private Integer orderAttributeTypeId;
	@Override
	public Integer getId() {
		return getOrderAttributeTypeId();
	}
	@Override
	public void setId(Integer id) {
		setOrderAttributeTypeId(id);
	}
	public Integer getOrderAttributeTypeId() {
		return orderAttributeTypeId;
	}
	public void setOrderAttributeTypeId(Integer orderAttributeTypeId) {
		this.orderAttributeTypeId = orderAttributeTypeId;
	}
}
package org.openmrs;
import org.hibernate.envers.Audited;
import org.openmrs.attribute.Attribute;
import org.openmrs.attribute.BaseAttribute;
@Audited
public class OrderAttribute extends BaseAttribute<OrderAttributeType, Order>
		implements Attribute<OrderAttributeType, Order> {
	private Integer orderAttributeId;
	public Order getOrder() {
		return getOwner();
	}
	public void setOrder(Order order) {
		setOwner(order);
	}
	@Override
	public Integer getId() {
		return getOrderAttributeId();
	}
	@Override
	public void setId(Integer id) {
		setOrderAttributeId(id);
	}
	public Integer getOrderAttributeId() {
		return orderAttributeId;
	}
	public void setOrderAttributeId(Integer orderAttributeId) {
		this.orderAttributeId = orderAttributeId;
	}
}
package org.openmrs.api.handler;
import java.util.Date;
import java.util.List;
import org.apache.commons.collections.CollectionUtils;
import org.openmrs.Encounter;
import org.openmrs.Order;
import org.openmrs.Patient;
import org.openmrs.User;
import org.openmrs.annotation.Handler;
import org.openmrs.aop.RequiredDataAdvice;
import org.openmrs.api.CohortService;
import org.openmrs.api.EncounterService;
import org.openmrs.api.OrderService;
import org.openmrs.api.context.Context;
import org.openmrs.parameter.EncounterSearchCriteria;
import org.openmrs.parameter.EncounterSearchCriteriaBuilder;
@Handler(supports = {Patient.class}, order = 50)
public class PatientDataUnvoidHandler implements UnvoidHandler<Patient> {
	@Override
	public void handle(Patient patient, User originalVoidingUser, Date origParentVoidedDate, String unused) {
		if (patient.getId() != null) {
			EncounterService es = Context.getEncounterService();
			EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder()
				.setPatient(patient)
				.setIncludeVoided(true)
				.createEncounterSearchCriteria();
			List<Encounter> encounters = es.getEncounters(encounterSearchCriteria);
			if (CollectionUtils.isNotEmpty(encounters)) {
				for (Encounter encounter : encounters) {
					if (encounter.getVoided() && encounter.getDateVoided().equals(origParentVoidedDate)
					        && encounter.getVoidedBy().equals(originalVoidingUser)) {
						es.unvoidEncounter(encounter);
					}
				}
			}
			OrderService os = Context.getOrderService();
			List<Order> orders = os.getAllOrdersByPatient(patient);
			if (CollectionUtils.isNotEmpty(orders)) {
				for (Order order : orders) {
					if (order.getVoided() && order.getDateVoided().equals(origParentVoidedDate)
					        && order.getVoidedBy().equals(originalVoidingUser)) {
						os.unvoidOrder(order);
					}
				}
			}
			CohortService cs = Context.getCohortService();
			cs.notifyPatientUnvoided(patient, originalVoidingUser, origParentVoidedDate);
		}
	}
}
package org.openmrs.order;
import org.openmrs.Order;
import org.openmrs.OrderType;
import org.openmrs.util.OpenmrsUtil;
public class OrderUtil {
	private OrderUtil() {
	}
	public static boolean isType(OrderType orderType1, OrderType orderType2) {
		if (orderType1 != null && orderType2 != null) {
			if (orderType2.equals(orderType1)) {
				return true;
			}
			OrderType parentType = orderType2.getParent();
			while (parentType != null) {
				if (parentType.equals(orderType1)) {
					return true;
				}
				parentType = parentType.getParent();
			}
		}
		return false;
	}
	public static boolean checkScheduleOverlap(Order order1, Order order2) {
		if (order2.getEffectiveStopDate() == null && order1.getEffectiveStopDate() == null) {
			return true;
		}
		if (order2.getEffectiveStopDate() == null) {
			return OpenmrsUtil.compare(order1.getEffectiveStopDate(), order2.getEffectiveStartDate()) > -1;
		}
		if (order1.getEffectiveStopDate() == null) {
			return (OpenmrsUtil.compare(order1.getEffectiveStartDate(), order2.getEffectiveStartDate()) > -1)
			        && (OpenmrsUtil.compare(order1.getEffectiveStartDate(), order2.getEffectiveStopDate()) < 1);
		}
		return (OpenmrsUtil.compare(order1.getEffectiveStartDate(), order2.getEffectiveStopDate()) < 1)
		        && (OpenmrsUtil.compare(order1.getEffectiveStopDate(), order2.getEffectiveStartDate()) > -1);
	}
}
package org.openmrs;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import org.openmrs.attribute.Attribute;
import org.openmrs.customdatatype.CustomValueDescriptor;
import org.openmrs.customdatatype.Customizable;
public abstract class BaseCustomizableData<A extends Attribute> extends BaseChangeableOpenmrsData implements Customizable<A> {
	private Set<A> attributes = new LinkedHashSet<>();
	@Override
	public Set<A> getAttributes() {
		return attributes;
	}
	public void setAttributes(Set<A> attributes) {
		this.attributes = attributes;
	}
	@Override
	public Collection<A> getActiveAttributes() {
		List<A> ret = new ArrayList<>();
		if (getAttributes() != null) {
			for (A attr : getAttributes()) {
				if (!attr.getVoided()) {
					ret.add(attr);
				}
			}
		}
		return ret;
	}
	@Override
	public List<A> getActiveAttributes(CustomValueDescriptor ofType) {
		List<A> ret = new ArrayList<>();
		if (getAttributes() != null) {
			for (A attr : getAttributes()) {
				if (attr.getAttributeType().equals(ofType) && !attr.getVoided()) {
					ret.add(attr);
				}
			}
		}
		return ret;
	}
	@Override
	public void addAttribute(A attribute) {
		if (getAttributes() == null) {
			setAttributes(new LinkedHashSet<>());
		}
		getAttributes().add(attribute);
		attribute.setOwner(this);
	}
	@SuppressWarnings("unchecked")
	public void setAttribute(A attribute) {
		if (getAttributes() == null) {
			addAttribute(attribute);
			return;
		}
		if (getActiveAttributes(attribute.getAttributeType()).size() == 1) {
			A existing = getActiveAttributes(attribute.getAttributeType()).get(0);
			if (!existing.getValue().equals(attribute.getValue())) {
				if (existing.getId() != null) {
					existing.setVoided(true);
				} else {
					getAttributes().remove(existing);
				}
				getAttributes().add(attribute);
				attribute.setOwner(this);
			}
			return;
		}
		for (A existing : getActiveAttributes(attribute.getAttributeType())) {
			if (existing.getAttributeType().equals(attribute.getAttributeType())) {
				if (existing.getId() != null) {
					existing.setVoided(true);
				} else {
					getAttributes().remove(existing);
				}
			}
		}
		getAttributes().add(attribute);
		attribute.setOwner(this);
	}
}
package org.openmrs.api.handler;
import java.util.Date;
import org.openmrs.Order;
import org.openmrs.User;
import org.openmrs.annotation.Handler;
import org.openmrs.aop.RequiredDataAdvice;
@Handler(supports = Order.class)
public class OrderSaveHandler implements SaveHandler<Order> {
	@Override
	public void handle(Order order, User creator, Date dateCreated, String other) {
		if (order.getPatient() == null && order.getEncounter() != null) {
			order.setPatient(order.getEncounter().getPatient());
		}
	}
}
package org.openmrs.api.db.hibernate;
import org.openmrs.Order;
import org.springframework.stereotype.Component;
@Component("immutableOrderInterceptor")
public class ImmutableOrderInterceptor extends ImmutableEntityInterceptor {
	private static final String[] MUTABLE_PROPERTY_NAMES = new String[] { "dateStopped", "voided", "dateVoided", "voidedBy",
	        "voidReason", "patient", "fulfillerStatus", "fulfillerComment", "accessionNumber"};
	@Override
	protected Class<?> getSupportedType() {
		return Order.class;
	}
	@Override
	protected String[] getMutablePropertyNames() {
		return MUTABLE_PROPERTY_NAMES;
	}
	@Override
	protected boolean ignoreVoidedOrRetiredObjects() {
		return true;
	}
}
package org.openmrs.util.databasechange;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.openmrs.Order;
import liquibase.change.custom.CustomTaskChange;
import liquibase.database.Database;
import liquibase.database.jvm.JdbcConnection;
import liquibase.exception.CustomChangeException;
import liquibase.exception.DatabaseException;
import liquibase.exception.SetupException;
import liquibase.exception.ValidationErrors;
import liquibase.resource.ResourceAccessor;
public class CreateDiscontinueOrders implements CustomTaskChange {
	@Override
	public void execute(Database database) throws CustomChangeException {
		JdbcConnection connection = (JdbcConnection) database.getConnection();
		try {
			List<DiscontinuedOrder> discontinuedOrders = getDiscontinuedOrders(connection);
			createDiscontinueOrders(connection, discontinuedOrders);
		}
		catch (SQLException | DatabaseException e) {
			throw new CustomChangeException(e);
		}
	}
	private void createDiscontinueOrders(JdbcConnection connection, List<DiscontinuedOrder> discontinuedOrders)
	        throws CustomChangeException, SQLException, DatabaseException {
		final int batchSize = 1000;
		int index = 0;
		PreparedStatement insertStatement = null;
		Boolean autoCommit = null;
		try {
			autoCommit = connection.getAutoCommit();
			connection.setAutoCommit(false);
			insertStatement = connection
			        .prepareStatement("Insert into orders(previous_order_id, concept_id, patient_id, encounter_id, "
			                + "creator, date_created, discontinued_reason, discontinued_reason_non_coded, "
			                + "uuid, order_action, orderer, order_number, order_type_id, start_date, auto_expire_date) "
			                + "values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
			for (DiscontinuedOrder discontinuedOrder : discontinuedOrders) {
				insertStatement.setInt(1, discontinuedOrder.previousOrderId);
				insertStatement.setInt(2, discontinuedOrder.conceptId);
				insertStatement.setInt(3, discontinuedOrder.patientId);
				setIntOrNull(insertStatement, 4, discontinuedOrder.encounterId);
				insertStatement.setInt(5, discontinuedOrder.discontinuedById);
				insertStatement.setDate(6, new Date(System.currentTimeMillis()));
				setIntOrNull(insertStatement, 7, discontinuedOrder.discontinuedReasonId);
				insertStatement.setString(8, discontinuedOrder.discontinuedReasonNonCoded);
				insertStatement.setString(9, UUID.randomUUID().toString());
				insertStatement.setString(10, Order.Action.DISCONTINUE.name());
				setIntOrNull(insertStatement, 11, discontinuedOrder.discontinuedById);
				insertStatement.setString(12, discontinuedOrder.orderNumber);
				insertStatement.setInt(13, discontinuedOrder.orderTypeId);
				insertStatement.setDate(14, discontinuedOrder.dateActivated);
				insertStatement.setDate(15, discontinuedOrder.dateActivated);
				insertStatement.addBatch();
				if (index % batchSize == 0) {
					insertStatement.executeBatch();
				}
				index++;
			}
			insertStatement.executeBatch();
			connection.commit();
		}
		catch (DatabaseException | SQLException e) {
			handleError(connection, e);
		}
		finally {
			if (autoCommit != null) {
				connection.setAutoCommit(autoCommit);
			}
			if (insertStatement != null) {
				insertStatement.close();
			}
		}
	}
	private void setIntOrNull(PreparedStatement statement, int index, Integer value) throws SQLException {
		if (value == null || value == 0) {
			statement.setNull(index, Types.INTEGER);
		} else {
			statement.setInt(index, value);
		}
	}
	private void handleError(JdbcConnection connection, Exception e) throws DatabaseException, CustomChangeException {
		connection.rollback();
		throw new CustomChangeException(e);
	}
	private List<DiscontinuedOrder> getDiscontinuedOrders(JdbcConnection connection) throws CustomChangeException,
	        SQLException {
		List<DiscontinuedOrder> dcOrders = new ArrayList<>();
		PreparedStatement statement = null;
		try {
			statement = connection.prepareStatement("select order_id, concept_id, patient_id, encounter_id, date_stopped, "
			        + "discontinued_by, discontinued_reason, discontinued_reason_non_coded, order_type_id "
			        + "from orders where discontinued = ?");
			statement.setBoolean(1, true);
			ResultSet rs = statement.executeQuery();
			while (rs.next()) {
				dcOrders.add(new DiscontinuedOrder(rs.getInt("order_id"), rs.getInt("concept_id"), rs.getInt("patient_id"),
				        rs.getInt("encounter_id"), rs.getInt("discontinued_by"), rs.getInt("discontinued_reason"), rs
				                .getString("discontinued_reason_non_coded"), rs.getDate("date_stopped"), rs
				                .getInt("order_type_id")));
			}
		}
		catch (SQLException | DatabaseException e) {
			throw new CustomChangeException(e);
		}
		finally {
			if (statement != null) {
				statement.close();
			}
		}
		return dcOrders;
	}
	@Override
	public String getConfirmationMessage() {
		return "Finished creating discontinue orders for discontinued orders";
	}
	@Override
	public void setUp() throws SetupException {
	}
	@Override
	public void setFileOpener(ResourceAccessor resourceAccessor) {
	}
	@Override
	public ValidationErrors validate(Database database) {
		return null;
	}
	private static class DiscontinuedOrder {
		public int orderId;
		public int conceptId;
		public int patientId;
		public int encounterId;
		public int discontinuedReasonId;
		public String discontinuedReasonNonCoded;
		public Date dateActivated;
		public int discontinuedById;
		public Date dateCreated;
		public int previousOrderId;
		public String orderNumber;
		public int orderTypeId;
		public Date date;
		private DiscontinuedOrder(int orderId, int conceptId, int patientId, int encounterId, int discontinuedById,
		    int discontinuedReasonId, String discontinuedReasonNonCoded, Date dateStopped, int orderTypeId) {
			this.orderId = orderId;
			this.previousOrderId = orderId;
			this.conceptId = conceptId;
			this.patientId = patientId;
			this.encounterId = encounterId;
			this.discontinuedReasonId = discontinuedReasonId;
			this.discontinuedReasonNonCoded = discontinuedReasonNonCoded;
			this.dateActivated = dateStopped;
			this.discontinuedById = discontinuedById;
			this.dateCreated = dateStopped;
			this.orderNumber = String.valueOf(orderId).concat("-DC");
			this.orderTypeId = orderTypeId;
		}
	}
}
package org.openmrs.api.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Allergen;
import org.openmrs.Allergies;
import org.openmrs.Allergy;
import org.openmrs.BaseOpenmrsMetadata;
import org.openmrs.Concept;
import org.openmrs.Encounter;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.Order;
import org.openmrs.Patient;
import org.openmrs.PatientIdentifier;
import org.openmrs.PatientIdentifierType;
import org.openmrs.PatientProgram;
import org.openmrs.Person;
import org.openmrs.PersonAddress;
import org.openmrs.PersonAttribute;
import org.openmrs.PersonName;
import org.openmrs.Relationship;
import org.openmrs.User;
import org.openmrs.Visit;
import org.openmrs.api.APIException;
import org.openmrs.api.BlankIdentifierException;
import org.openmrs.api.DuplicateIdentifierException;
import org.openmrs.api.EncounterService;
import org.openmrs.api.InsufficientIdentifiersException;
import org.openmrs.api.MissingRequiredIdentifierException;
import org.openmrs.api.ObsService;
import org.openmrs.api.PatientIdentifierException;
import org.openmrs.api.PatientIdentifierTypeLockedException;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.UserService;
import org.openmrs.api.VisitService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.PatientDAO;
import org.openmrs.api.db.hibernate.HibernateUtil;
import org.openmrs.parameter.EncounterSearchCriteria;
import org.openmrs.parameter.EncounterSearchCriteriaBuilder;
import org.openmrs.patient.IdentifierValidator;
import org.openmrs.patient.impl.LuhnIdentifierValidator;
import org.openmrs.person.PersonMergeLog;
import org.openmrs.person.PersonMergeLogData;
import org.openmrs.serialization.SerializationException;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.validator.PatientIdentifierValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;
@Transactional
public class PatientServiceImpl extends BaseOpenmrsService implements PatientService {
	private static final Logger log = LoggerFactory.getLogger(PatientServiceImpl.class);
	private PatientDAO dao;
	private static Map<Class<? extends IdentifierValidator>, IdentifierValidator> identifierValidators = null;
	@Override
	public void setPatientDAO(PatientDAO dao) {
		this.dao = dao;
	}
	@Override
	public void onShutdown() {
		setIdentifierValidators(null);
	}
	@Override
	public Patient savePatient(Patient patient) throws APIException {
		requireAppropriatePatientModificationPrivilege(patient);
		if (!patient.getVoided() && patient.getIdentifiers().size() == 1) {
			patient.getPatientIdentifier().setPreferred(true);
		}
		if (!patient.getVoided()) {
			checkPatientIdentifiers(patient);
		}
		setPreferredPatientIdentifier(patient);
		setPreferredPatientName(patient);
		setPreferredPatientAddress(patient);
		return dao.savePatient(patient);
	}
	private void requireAppropriatePatientModificationPrivilege(Patient patient) {
		if (patient.getPatientId() == null) {
			Context.requirePrivilege(PrivilegeConstants.ADD_PATIENTS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_PATIENTS);
		}
		if (patient.getVoided()) {
			Context.requirePrivilege(PrivilegeConstants.DELETE_PATIENTS);
		}
	}
	private void setPreferredPatientIdentifier(Patient patient) {
		PatientIdentifier preferredIdentifier = null;
		PatientIdentifier possiblePreferredId = patient.getPatientIdentifier();
		if (possiblePreferredId != null && possiblePreferredId.getPreferred() && !possiblePreferredId.getVoided()) {
			preferredIdentifier = possiblePreferredId;
		}
		for (PatientIdentifier id : patient.getIdentifiers()) {
			if (preferredIdentifier == null && !id.getVoided()) {
				id.setPreferred(true);
				preferredIdentifier = id;
				continue;
			}
			if (!id.equals(preferredIdentifier)) {
				id.setPreferred(false);
			}
		}
	}
	private void setPreferredPatientName(Patient patient) {
		PersonName preferredName = null;
		PersonName possiblePreferredName = patient.getPersonName();
		if (possiblePreferredName != null && possiblePreferredName.getPreferred() && !possiblePreferredName.getVoided()) {
			preferredName = possiblePreferredName;
		}
		for (PersonName name : patient.getNames()) {
			if (preferredName == null && !name.getVoided()) {
				name.setPreferred(true);
				preferredName = name;
				continue;
			}
			if (!name.equals(preferredName)) {
				name.setPreferred(false);
			}
		}
	}
	private void setPreferredPatientAddress(Patient patient) {
		PersonAddress preferredAddress = null;
		PersonAddress possiblePreferredAddress = patient.getPersonAddress();
		if (possiblePreferredAddress != null && possiblePreferredAddress.getPreferred()
				&& !possiblePreferredAddress.getVoided()) {
			preferredAddress = possiblePreferredAddress;
		}
		for (PersonAddress address : patient.getAddresses()) {
			if (preferredAddress == null && !address.getVoided()) {
				address.setPreferred(true);
				preferredAddress = address;
				continue;
			}
			if (!address.equals(preferredAddress)) {
				address.setPreferred(false);
			}
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatient(Integer patientId) throws APIException {
		return dao.getPatient(patientId);
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientOrPromotePerson(Integer patientOrPersonId) {
		Person person = Context.getPersonService().getPerson(patientOrPersonId);
		if (person == null) {
			return null;
		}
		person = HibernateUtil.getRealObjectFromProxy(person);
		if (person instanceof Patient) {
			return (Patient)person;
		}
		else {
			return new Patient(person);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getAllPatients() throws APIException {
		return Context.getPatientService().getAllPatients(false);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getAllPatients(boolean includeVoided) throws APIException {
		return dao.getAllPatients(includeVoided);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String name, String identifier, List<PatientIdentifierType> identifierTypes,
	        boolean matchIdentifierExactly) throws APIException {
		return Context.getPatientService().getPatients(name, identifier, identifierTypes, matchIdentifierExactly, 0, null);
	}
	@Override
	@Transactional(readOnly = true)
	public void checkPatientIdentifiers(Patient patient) throws PatientIdentifierException {
		if (!patient.getVoided() && patient.getActiveIdentifiers().isEmpty()) {
			throw new InsufficientIdentifiersException("At least one nonvoided Patient Identifier is required");
		}
		final List<PatientIdentifier> patientIdentifiers = new ArrayList<>(patient.getIdentifiers());
		final Set<String> uniqueIdentifiers = new HashSet<>();
		patientIdentifiers.stream()
			.filter(pi -> !pi.getVoided())
			.forEach(pi -> {
				try {
					PatientIdentifierValidator.validateIdentifier(pi);
				}
				catch (BlankIdentifierException bie) {
					patient.removeIdentifier(pi);
					throw bie;
				}
				String compareString = pi.getIdentifier() + " id type #: " + pi.getIdentifierType().getPatientIdentifierTypeId();
				if(! uniqueIdentifiers.add(compareString)) {
					throw new DuplicateIdentifierException("This patient has two identical identifiers of type "
							+ compareString, pi);
				}
			});
		checkForMissingRequiredIdentifiers(patientIdentifiers);
	}
	private void checkForMissingRequiredIdentifiers(List<PatientIdentifier> patientIdentifiers) {
		final Set<PatientIdentifierType> patientIdentifierTypes =
				patientIdentifiers.stream()
						.map(PatientIdentifier::getIdentifierType)
						.collect(Collectors.toSet());
		final List<PatientIdentifierType> requiredTypes = this.getPatientIdentifierTypes(null, null, true, null);
		final Set<String> missingRequiredTypeNames =
				requiredTypes.stream()
						.filter(requiredType -> !patientIdentifierTypes.contains(requiredType))
						.map(BaseOpenmrsMetadata::getName)
						.collect(Collectors.toSet());
		if(! missingRequiredTypeNames.isEmpty()) {
			throw new MissingRequiredIdentifierException(
					"Patient is missing the following required identifier(s): " + String.join(", ", missingRequiredTypeNames));
		}
	}
	@Override
	public Patient voidPatient(Patient patient, String reason) throws APIException {
		if (patient == null) {
			return null;
		}
		return dao.savePatient(patient);
	}
	@Override
	public Patient unvoidPatient(Patient patient) throws APIException {
		if (patient == null) {
			return null;
		}
		return Context.getPatientService().savePatient(patient);
	}
	@Override
	public void purgePatient(Patient patient) throws APIException {
		dao.deletePatient(patient);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifier> getPatientIdentifiers(String identifier,
	        List<PatientIdentifierType> patientIdentifierTypes, List<Location> locations, List<Patient> patients,
	        Boolean isPreferred) throws APIException {
		if (patientIdentifierTypes == null) {
			patientIdentifierTypes = new ArrayList<>();
		}
		if (locations == null) {
			locations = new ArrayList<>();
		}
		if (patients == null) {
			patients = new ArrayList<>();
		}
		return dao.getPatientIdentifiers(identifier, patientIdentifierTypes, locations, patients, isPreferred);
	}
	@Override
	public PatientIdentifierType savePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		return dao.savePatientIdentifierType(patientIdentifierType);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getAllPatientIdentifierTypes() throws APIException {
		return Context.getPatientService().getAllPatientIdentifierTypes(false);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getAllPatientIdentifierTypes(boolean includeRetired) throws APIException {
		return dao.getAllPatientIdentifierTypes(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getPatientIdentifierTypes(String name, String format, Boolean required,
	        Boolean hasCheckDigit) throws APIException {
		List<PatientIdentifierType> patientIdentifierTypes = dao.getPatientIdentifierTypes(name, format, required, hasCheckDigit);
		if (patientIdentifierTypes == null) {
			return new ArrayList<>();
		}
		return patientIdentifierTypes;
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierType(Integer patientIdentifierTypeId) throws APIException {
		return dao.getPatientIdentifierType(patientIdentifierTypeId);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierTypeByName(String name) throws APIException {
		List<PatientIdentifierType> types = getPatientIdentifierTypes(name, null, null, null);
		if (!types.isEmpty()) {
			return types.get(0);
		}
		return null;
	}
	@Override
	public PatientIdentifierType retirePatientIdentifierType(PatientIdentifierType patientIdentifierType, String reason)
	        throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		if (reason == null || reason.length() < 1) {
			throw new APIException("Patient.identifier.retire.reason", (Object[]) null);
		}
		patientIdentifierType.setRetired(true);
		patientIdentifierType.setRetiredBy(Context.getAuthenticatedUser());
		patientIdentifierType.setDateRetired(new Date());
		patientIdentifierType.setRetireReason(reason);
		return Context.getPatientService().savePatientIdentifierType(patientIdentifierType);
	}
	@Override
	public PatientIdentifierType unretirePatientIdentifierType(PatientIdentifierType patientIdentifierType)
	        throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		patientIdentifierType.setRetired(false);
		patientIdentifierType.setRetiredBy(null);
		patientIdentifierType.setDateRetired(null);
		patientIdentifierType.setRetireReason(null);
		return Context.getPatientService().savePatientIdentifierType(patientIdentifierType);
	}
	@Override
	public void purgePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		dao.deletePatientIdentifierType(patientIdentifierType);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query) throws APIException {
		return Context.getPatientService().getPatients(query, 0, null);
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientByExample(Patient patientToMatch) throws APIException {
		if (patientToMatch == null || patientToMatch.getPatientId() == null) {
			return null;
		}
		return Context.getPatientService().getPatient(patientToMatch.getPatientId());
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getDuplicatePatientsByAttributes(List<String> attributes) throws APIException {
		if (attributes == null || attributes.isEmpty()) {
			throw new APIException("Patient.no.attribute", (Object[]) null);
		}
		return dao.getDuplicatePatientsByAttributes(attributes);
	}
	private String relationshipHash(Relationship rel, Person primary) {
		boolean isA = rel.getPersonA().equals(primary);
		return rel.getRelationshipType().getRelationshipTypeId().toString() + (isA ? "A" : "B")
		        + (isA ? rel.getPersonB().getPersonId().toString() : rel.getPersonA().getPersonId().toString());
	}
	@Override
	public void mergePatients(Patient preferred, Patient notPreferred) throws APIException, SerializationException {
		log.debug("Merging patients: (preferred)" + preferred.getPatientId() + ", (notPreferred) "
		        + notPreferred.getPatientId());
		if (preferred.getPatientId().equals(notPreferred.getPatientId())) {
			log.debug("Merge operation cancelled: Cannot merge user" + preferred.getPatientId() + " to self");
			throw new APIException("Patient.merge.cancelled", new Object[] { preferred.getPatientId() });
		}
		requireNoActiveOrderOfSameType(preferred,notPreferred);
		PersonMergeLogData mergedData = new PersonMergeLogData();
		mergeVisits(preferred, notPreferred, mergedData);
		mergeEncounters(preferred, notPreferred, mergedData);
		mergeProgramEnrolments(preferred, notPreferred, mergedData);
		mergeRelationships(preferred, notPreferred, mergedData);
		mergeObservationsNotContainedInEncounters(preferred, notPreferred, mergedData);
		mergeIdentifiers(preferred, notPreferred, mergedData);
		mergeNames(preferred, notPreferred, mergedData);
		mergeAddresses(preferred, notPreferred, mergedData);
		mergePersonAttributes(preferred, notPreferred, mergedData);
		mergeGenderInformation(preferred, notPreferred, mergedData);
		mergeDateOfBirth(preferred, notPreferred, mergedData);
		mergeDateOfDeath(preferred, notPreferred, mergedData);
		Context.getPatientService().voidPatient(notPreferred, "Merged with patient #" + preferred.getPatientId());
		Context.getPersonService().voidPerson(notPreferred,
		    "The patient corresponding to this person has been voided and Merged with patient #" + preferred.getPatientId());
		changeUserAssociations(preferred, notPreferred, mergedData);
		savePatient(preferred);
		PersonMergeLog personMergeLog = new PersonMergeLog();
		personMergeLog.setWinner(preferred);
		personMergeLog.setLoser(notPreferred);
		personMergeLog.setPersonMergeLogData(mergedData);
		Context.getPersonService().savePersonMergeLog(personMergeLog);
	}
	private void requireNoActiveOrderOfSameType(Patient patient1, Patient patient2) {
		String messageKey = "Patient.merge.cannotHaveSameTypeActiveOrders";
		List<Order> ordersByPatient1 = Context.getOrderService().getAllOrdersByPatient(patient1);
		List<Order> ordersByPatient2 = Context.getOrderService().getAllOrdersByPatient(patient2);
		ordersByPatient1.forEach((Order order1) -> ordersByPatient2.forEach((Order order2) -> {
			if (order1.isActive() && order2.isActive() && order1.getOrderType().equals(order2.getOrderType())) {
				Object[] parameters = { patient1.getPatientId(), patient2.getPatientId(), order1.getOrderType() };
				String message = Context.getMessageSourceService().getMessage(messageKey, parameters,
						Context.getLocale());
				log.debug(message);
				throw new APIException(message);
			}
		}));
	}
	private void mergeProgramEnrolments(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		ProgramWorkflowService programService = Context.getProgramWorkflowService();
		for (PatientProgram pp : programService.getPatientPrograms(notPreferred, null, null, null, null, null, false)) {
			if (!pp.getVoided()) {
				pp.setPatient(preferred);
				log.debug("Moving patientProgram {} to {}", pp.getPatientProgramId(), preferred.getPatientId());
				PatientProgram persisted = programService.savePatientProgram(pp);
				mergedData.addMovedProgram(persisted.getUuid());
			}
		}
	}
	private void mergeVisits(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		VisitService visitService = Context.getVisitService();
		for (Visit visit : visitService.getVisitsByPatient(notPreferred, true, true)) {
			log.debug("Merging visit {} to {}", visit.getVisitId(), preferred.getPatientId());
			visit.setPatient(preferred);
			Visit persisted = visitService.saveVisit(visit);
			mergedData.addMovedVisit(persisted.getUuid());
		}
	}
	private void mergeEncounters(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		EncounterService es = Context.getEncounterService();
		EncounterSearchCriteria notPreferredPatientEncounterSearchCriteria = new EncounterSearchCriteriaBuilder()
				.setIncludeVoided(true)
				.setPatient(notPreferred)
				.createEncounterSearchCriteria();
		for (Encounter e : es.getEncounters(notPreferredPatientEncounterSearchCriteria)) {
			e.setPatient(preferred);
			log.debug("Merging encounter " + e.getEncounterId() + " to " + preferred.getPatientId());
			Encounter persisted = es.saveEncounter(e);
			mergedData.addMovedEncounter(persisted.getUuid());
		}
	}
	private void mergeRelationships(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		PersonService personService = Context.getPersonService();
		Set<String> existingRelationships = new HashSet<>();
		for (Relationship rel : personService.getRelationshipsByPerson(preferred)) {
			existingRelationships.add(relationshipHash(rel, preferred));
		}
		for (Relationship rel : personService.getRelationshipsByPerson(notPreferred)) {
			if (!rel.getVoided()) {
				boolean personAisPreferred = rel.getPersonA().equals(preferred);
				boolean personAisNotPreferred = rel.getPersonA().equals(notPreferred);
				boolean personBisPreferred = rel.getPersonB().equals(preferred);
				boolean personBisNotPreferred = rel.getPersonB().equals(notPreferred);
				String relHash = relationshipHash(rel, notPreferred);
				if ((personAisPreferred && personBisNotPreferred) || (personBisPreferred && personAisNotPreferred)) {
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged to person " + (personAisPreferred ? "A" : "B"));
				} else if (existingRelationships.contains(relHash)) {
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged and a relationship already exists");
				} else {
					Relationship tmpRel = rel.copy();
					if (personAisNotPreferred) {
						tmpRel.setPersonA(preferred);
					}
					if (personBisNotPreferred) {
						tmpRel.setPersonB(preferred);
					}
					log.debug("Copying relationship " + rel.getRelationshipId() + " to " + preferred.getPatientId());
					Relationship persisted = personService.saveRelationship(tmpRel);
					mergedData.addCreatedRelationship(persisted.getUuid());
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged, relationship copied to #" + tmpRel.getRelationshipId());
					existingRelationships.add(relHash);
				}
				mergedData.addVoidedRelationship(rel.getUuid());
			}
		}
	}
	private void mergeObservationsNotContainedInEncounters(Patient preferred, Patient notPreferred,
	        PersonMergeLogData mergedData) {
		ObsService obsService = Context.getObsService();
		for (Obs obs : obsService.getObservationsByPerson(notPreferred)) {
			if (obs.getEncounter() == null && !obs.getVoided()) {
				obs.setPerson(preferred);
				Obs persisted = obsService.saveObs(obs, "Merged from patient #" + notPreferred.getPatientId());
				mergedData.addMovedIndependentObservation(persisted.getUuid());
			}
		}
	}
	private void mergeIdentifiers(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		for (PatientIdentifier pi : notPreferred.getActiveIdentifiers()) {
			PatientIdentifier tmpIdentifier = new PatientIdentifier();
			tmpIdentifier.setIdentifier(pi.getIdentifier());
			tmpIdentifier.setIdentifierType(pi.getIdentifierType());
			tmpIdentifier.setLocation(pi.getLocation());
			tmpIdentifier.setPatient(preferred);
			boolean found = false;
			for (PatientIdentifier preferredIdentifier : preferred.getIdentifiers()) {
				if (preferredIdentifier.getIdentifier() != null
				        && preferredIdentifier.getIdentifier().equals(tmpIdentifier.getIdentifier())
				        && preferredIdentifier.getIdentifierType() != null
				        && preferredIdentifier.getIdentifierType().equals(tmpIdentifier.getIdentifierType())) {
					found = true;
				}
			}
			if (!found) {
				tmpIdentifier.setIdentifierType(pi.getIdentifierType());
				tmpIdentifier.setCreator(Context.getAuthenticatedUser());
				tmpIdentifier.setDateCreated(new Date());
				tmpIdentifier.setVoided(false);
				tmpIdentifier.setVoidedBy(null);
				tmpIdentifier.setVoidReason(null);
				tmpIdentifier.setUuid(UUID.randomUUID().toString());
				tmpIdentifier.setPreferred(false);
				preferred.addIdentifier(tmpIdentifier);
				mergedData.addCreatedIdentifier(tmpIdentifier.getUuid());
				log.debug("Merging identifier " + tmpIdentifier.getIdentifier() + " to " + preferred.getPatientId());
			}
		}
	}
	private void mergeDateOfDeath(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorDateOfDeath(preferred.getDeathDate());
		if (preferred.getDeathDate() == null) {
			preferred.setDeathDate(notPreferred.getDeathDate());
		}
		if (preferred.getCauseOfDeath() != null) {
			mergedData.setPriorCauseOfDeath(preferred.getCauseOfDeath().getUuid());
		}
		if (preferred.getCauseOfDeath() == null) {
			preferred.setCauseOfDeath(notPreferred.getCauseOfDeath());
		}
	}
	private void mergeDateOfBirth(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorDateOfBirth(preferred.getBirthdate());
		mergedData.setPriorDateOfBirthEstimated(preferred.getBirthdateEstimated());
		if (preferred.getBirthdate() == null || (preferred.getBirthdateEstimated() && !notPreferred.getBirthdateEstimated())) {
			preferred.setBirthdate(notPreferred.getBirthdate());
			preferred.setBirthdateEstimated(notPreferred.getBirthdateEstimated());
		}
	}
	private void mergePersonAttributes(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		for (PersonAttribute attr : notPreferred.getAttributes()) {
			if (!attr.getVoided()) {
				PersonAttribute tmpAttr = attr.copy();
				tmpAttr.setPerson(null);
				tmpAttr.setUuid(UUID.randomUUID().toString());
				preferred.addAttribute(tmpAttr);
				mergedData.addCreatedAttribute(tmpAttr.getUuid());
			}
		}
	}
	private void mergeGenderInformation(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorGender(preferred.getGender());
		if (!"M".equals(preferred.getGender()) && !"F".equals(preferred.getGender())) {
			preferred.setGender(notPreferred.getGender());
		}
	}
	private void mergeNames(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		for (PersonName newName : notPreferred.getNames()) {
			boolean containsName = false;
			for (PersonName currentName : preferred.getNames()) {
				containsName = currentName.equalsContent(newName);
				if (containsName) {
					break;
				}
			}
			if (!containsName) {
				PersonName tmpName = constructTemporaryName(newName);
				preferred.addName(tmpName);
				mergedData.addCreatedName(tmpName.getUuid());
				log.debug("Merging name " + newName.getGivenName() + " to " + preferred.getPatientId());
			}
		}
	}
	private PersonName constructTemporaryName(PersonName newName) {
		PersonName tmpName = PersonName.newInstance(newName);
		tmpName.setPersonNameId(null);
		tmpName.setVoided(false);
		tmpName.setVoidedBy(null);
		tmpName.setVoidReason(null);
		tmpName.setPreferred(false);
		tmpName.setUuid(UUID.randomUUID().toString());
		return tmpName;
	}
	private void mergeAddresses(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData)
	        throws SerializationException {
		for (PersonAddress newAddress : notPreferred.getAddresses()) {
			boolean containsAddress = false;
			for (PersonAddress currentAddress : preferred.getAddresses()) {
				containsAddress = currentAddress.equalsContent(newAddress);
				if (containsAddress) {
					break;
				}
			}
			if (!containsAddress) {
				PersonAddress tmpAddress = (PersonAddress) newAddress.clone();
				tmpAddress.setPersonAddressId(null);
				tmpAddress.setVoided(false);
				tmpAddress.setVoidedBy(null);
				tmpAddress.setVoidReason(null);
				tmpAddress.setPreferred(false); 
				tmpAddress.setUuid(UUID.randomUUID().toString());
				preferred.addAddress(tmpAddress);
				mergedData.addCreatedAddress(tmpAddress.getUuid());
				log.debug("Merging address " + newAddress.getPersonAddressId() + " to " + preferred.getPatientId());
			}
		}
		for (PersonAttribute attr : notPreferred.getAttributes()) {
			if (!attr.getVoided()) {
				PersonAttribute tmpAttr = attr.copy();
				tmpAttr.setPerson(null);
				tmpAttr.setUuid(UUID.randomUUID().toString());
				preferred.addAttribute(tmpAttr);
				mergedData.addCreatedAttribute(tmpAttr.getUuid());
			}
		}
		mergedData.setPriorGender(preferred.getGender());
		if (!"M".equals(preferred.getGender()) && !"F".equals(preferred.getGender())) {
			preferred.setGender(notPreferred.getGender());
		}
		mergedData.setPriorDateOfBirth(preferred.getBirthdate());
		mergedData.setPriorDateOfBirthEstimated(preferred.getBirthdateEstimated());
		if (preferred.getBirthdate() == null || (preferred.getBirthdateEstimated() && !notPreferred.getBirthdateEstimated())) {
			preferred.setBirthdate(notPreferred.getBirthdate());
			preferred.setBirthdateEstimated(notPreferred.getBirthdateEstimated());
		}
		mergedData.setPriorDateOfDeathEstimated(preferred.getDeathdateEstimated());
		if (preferred.getDeathdateEstimated() == null) {
			preferred.setDeathdateEstimated(notPreferred.getDeathdateEstimated());
		}
		mergedData.setPriorDateOfDeath(preferred.getDeathDate());
		if (preferred.getDeathDate() == null) {
			preferred.setDeathDate(notPreferred.getDeathDate());
		}
		if (preferred.getCauseOfDeath() != null) {
			mergedData.setPriorCauseOfDeath(preferred.getCauseOfDeath().getUuid());
		}
		if (preferred.getCauseOfDeath() == null) {
			preferred.setCauseOfDeath(notPreferred.getCauseOfDeath());
		}
		Context.getPatientService().voidPatient(notPreferred, "Merged with patient #" + preferred.getPatientId());
		Context.getPersonService().voidPerson(notPreferred,
		    "The patient corresponding to this person has been voided and Merged with patient #" + preferred.getPatientId());
		changeUserAssociations(preferred, notPreferred, mergedData);
		savePatient(preferred);
		PersonMergeLog personMergeLog = new PersonMergeLog();
		personMergeLog.setWinner(preferred);
		personMergeLog.setLoser(notPreferred);
		personMergeLog.setPersonMergeLogData(mergedData);
		Context.getPersonService().savePersonMergeLog(personMergeLog);
	}
	private void changeUserAssociations(Patient preferred, Person notPreferred, PersonMergeLogData mergedData) {
		UserService userService = Context.getUserService();
		List<User> users = userService.getUsersByPerson(notPreferred, true);
		for (User user : users) {
			user.setPerson(preferred);
			User persisted = userService.saveUser(user);
			if (mergedData != null) {
				mergedData.addMovedUser(persisted.getUuid());
			}
		}
	}
	public void exitFromCare(Patient patient, Date dateExited, Concept reasonForExit) throws APIException {
		if (patient == null) {
			throw new APIException("Patient.invalid.care", (Object[]) null);
		}
		if (dateExited == null) {
			throw new APIException("Patient.no.valid.dateExited", (Object[]) null);
		}
		if (reasonForExit == null) {
			throw new APIException("Patient.no.valid.reasonForExit", (Object[]) null);
		}
		saveReasonForExitObs(patient, dateExited, reasonForExit);
	}
	private void saveReasonForExitObs(Patient patient, Date exitDate, Concept cause) throws APIException {
		if (patient == null) {
			throw new APIException("Patient.null", (Object[]) null);
		}
		if (exitDate == null) {
			throw new APIException("Patient.exit.date.null", (Object[]) null);
		}
		if (cause == null) {
			throw new APIException("Patient.cause.null", (Object[]) null);
		}
		log.debug("Patient is exiting, so let's make sure there's an Obs for it");
		String codProp = Context.getAdministrationService().getGlobalProperty("concept.reasonExitedCare");
		Concept reasonForExit = Context.getConceptService().getConcept(codProp);
		if (reasonForExit != null) {
			List<Obs> obssExit = Context.getObsService().getObservationsByPersonAndConcept(patient, reasonForExit);
			if (obssExit != null) {
				if (obssExit.size() > 1) {
					log.error("Multiple reasons for exit (" + obssExit.size() + ")?  Shouldn't be...");
				} else {
					Obs obsExit;
					if (obssExit.size() == 1) {
						log.debug("Already has a reason for exit, so changing it");
						obsExit = obssExit.iterator().next();
					} else {
						log.debug("No reason for exit yet, let's create one.");
						obsExit = new Obs();
						obsExit.setPerson(patient);
						obsExit.setConcept(reasonForExit);
						Location loc = Context.getLocationService().getDefaultLocation();
						if (loc != null) {
							obsExit.setLocation(loc);
						} else {
							log.error("Could not find a suitable location for which to create this new Obs");
						}
					}
					if (obsExit != null) {
						obsExit.setValueCoded(cause);
						obsExit.setValueCodedName(cause.getName()); 
						obsExit.setObsDatetime(exitDate);
						Context.getObsService().saveObs(obsExit, "updated by PatientService.saveReasonForExit");
					}
				}
			}
		} else {
			log.debug("Reason for exit is null - should not have gotten here without throwing an error on the form.");
		}
	}
	@Override
	public void processDeath(Patient patient, Date dateDied, Concept causeOfDeath, String otherReason) throws APIException {
		if (patient != null && dateDied != null && causeOfDeath != null) {
			patient.setDead(true);
			patient.setDeathDate(dateDied);
			patient.setCauseOfDeath(causeOfDeath);
			this.savePatient(patient);
			saveCauseOfDeathObs(patient, dateDied, causeOfDeath, otherReason);
			String strPatientDied = Context.getAdministrationService().getGlobalProperty("concept.patientDied");
			Concept conceptPatientDied = Context.getConceptService().getConcept(strPatientDied);
			if (conceptPatientDied == null) {
				log.debug("ConceptPatientDied is null");
			}
			exitFromCare(patient, dateDied, conceptPatientDied);
		} else {
			if (patient == null) {
				throw new APIException("Patient.invalid.dead", (Object[]) null);
			}
			if (dateDied == null) {
				throw new APIException("Patient.no.valid.dateDied", (Object[]) null);
			}
			if (causeOfDeath == null) {
				throw new APIException("Patient.no.valid.causeOfDeath", (Object[]) null);
			}
		}
	}
	@Override
	public void saveCauseOfDeathObs(Patient patient, Date deathDate, Concept cause, String otherReason) throws APIException {
		if (patient == null) {
			throw new APIException("Patient.null", (Object[]) null);
		}
		if (deathDate == null) {
			throw new APIException("Patient.death.date.null", (Object[]) null);
		}
		if (cause == null) {
			throw new APIException("Patient.cause.null", (Object[]) null);
		}
		if (!patient.getDead()) {
			patient.setDead(true);
			patient.setDeathDate(deathDate);
			patient.setCauseOfDeath(cause);
		}
		log.debug("Patient is dead, so let's make sure there's an Obs for it");
		String codProp = Context.getAdministrationService().getGlobalProperty("concept.causeOfDeath");
		Concept causeOfDeath = Context.getConceptService().getConcept(codProp);
		if (causeOfDeath != null) {
			List<Obs> obssDeath = Context.getObsService().getObservationsByPersonAndConcept(patient, causeOfDeath);
			if (obssDeath != null) {
				if (obssDeath.size() > 1) {
					log.error("Multiple causes of death (" + obssDeath.size() + ")?  Shouldn't be...");
				} else {
					Obs obsDeath;
					if (obssDeath.size() == 1) {
						log.debug("Already has a cause of death, so changing it");
						obsDeath = obssDeath.iterator().next();
					} else {
						log.debug("No cause of death yet, let's create one.");
						obsDeath = new Obs();
						obsDeath.setPerson(patient);
						obsDeath.setConcept(causeOfDeath);
						Location location = Context.getLocationService().getDefaultLocation();
						if (location != null) {
							obsDeath.setLocation(location);
						} else {
							log.error("Could not find a suitable location for which to create this new Obs");
						}
					}
					Concept currCause = patient.getCauseOfDeath();
					if (currCause == null) {
						log.debug("Current cause is null, attempting to set to NONE");
						String noneConcept = Context.getAdministrationService().getGlobalProperty("concept.none");
						currCause = Context.getConceptService().getConcept(noneConcept);
					}
					if (currCause != null) {
						log.debug("Current cause is not null, setting to value_coded");
						obsDeath.setValueCoded(currCause);
						obsDeath.setValueCodedName(currCause.getName()); 
						Date dateDeath = patient.getDeathDate();
						if (dateDeath == null) {
							dateDeath = new Date();
						}
						obsDeath.setObsDatetime(dateDeath);
						String otherConcept = Context.getAdministrationService().getGlobalProperty("concept.otherNonCoded");
						Concept conceptOther = Context.getConceptService().getConcept(otherConcept);
						if (conceptOther != null) {
							if (conceptOther.equals(currCause)) {
								log.debug("Setting value_text as " + otherReason);
								obsDeath.setValueText(otherReason);
							} else {
								log.debug("New concept is NOT the OTHER concept, so setting to blank");
								obsDeath.setValueText("");
							}
						} else {
							log.debug("Don't seem to know about an OTHER concept, so deleting value_text");
							obsDeath.setValueText("");
						}
						Context.getObsService().saveObs(obsDeath, "updated by PatientService.saveCauseOfDeathObs");
					} else {
						log.debug("Current cause is still null - aborting mission");
					}
				}
			}
		} else {
			log.debug("Cause of death is null - should not have gotten here without throwing an error on the form.");
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientByUuid(String uuid) throws APIException {
		return dao.getPatientByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifier getPatientIdentifierByUuid(String uuid) throws APIException {
		return dao.getPatientIdentifierByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierTypeByUuid(String uuid) throws APIException {
		return dao.getPatientIdentifierTypeByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public IdentifierValidator getDefaultIdentifierValidator() {
		String defaultPIV = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR, "");
		try {
			return identifierValidators.get(Class.forName(defaultPIV));
		}
		catch (ClassNotFoundException e) {
			log.error("Global Property " + OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR
			        + " not set to an actual class.", e);
			return identifierValidators.get(LuhnIdentifierValidator.class);
		}
	}
	@Override
	public IdentifierValidator getIdentifierValidator(Class<IdentifierValidator> identifierValidator) {
		return identifierValidators.get(identifierValidator);
	}
	public Map<Class<? extends IdentifierValidator>, IdentifierValidator> getIdentifierValidators() {
		if (identifierValidators == null) {
			identifierValidators = new LinkedHashMap<>();
		}
		return identifierValidators;
	}
	public void setIdentifierValidators(Map<Class<? extends IdentifierValidator>, IdentifierValidator> identifierValidators) {
		if (identifierValidators == null) {
			PatientServiceImpl.setStaticIdentifierValidators(null);
			return;
		}
		for (Map.Entry<Class<? extends IdentifierValidator>, IdentifierValidator> entry : identifierValidators.entrySet()) {
			getIdentifierValidators().put(entry.getKey(), entry.getValue());
		}
	}
	private static void setStaticIdentifierValidators(
	        Map<Class<? extends IdentifierValidator>, IdentifierValidator> currentIdentifierValidators) {
		PatientServiceImpl.identifierValidators = currentIdentifierValidators;
	}
	@Override
	public Collection<IdentifierValidator> getAllIdentifierValidators() {
		return identifierValidators.values();
	}
	@Override
	@SuppressWarnings("unchecked")
	@Transactional(readOnly = true)
	public IdentifierValidator getIdentifierValidator(String pivClassName) {
		if (StringUtils.isBlank(pivClassName)) {
			return null;
		}
		try {
			return getIdentifierValidator((Class<IdentifierValidator>) Context.loadClass(pivClassName));
		}
		catch (ClassNotFoundException e) {
			throw new PatientIdentifierException("Could not find patient identifier validator " + pivClassName, e);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public boolean isIdentifierInUseByAnotherPatient(PatientIdentifier patientIdentifier) {
		return dao.isIdentifierInUseByAnotherPatient(patientIdentifier);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifier getPatientIdentifier(Integer patientIdentifierId) throws APIException {
		return dao.getPatientIdentifier(patientIdentifierId);
	}
	@Override
	public PatientIdentifier voidPatientIdentifier(PatientIdentifier patientIdentifier, String reason) throws APIException {
		if (patientIdentifier == null || StringUtils.isBlank(reason)) {
			throw new APIException("Patient.identifier.cannot.be.null", (Object[]) null);
		}
		return Context.getPatientService().savePatientIdentifier(patientIdentifier);
	}
	@Override
	public void mergePatients(Patient preferred, List<Patient> notPreferred) throws APIException, SerializationException {
		for (Patient nonPreferred : notPreferred) {
			mergePatients(preferred, nonPreferred);
		}
	}
	@Override
	public PatientIdentifier savePatientIdentifier(PatientIdentifier patientIdentifier) throws APIException {
		PatientIdentifierType.LocationBehavior locationBehavior = null;
		if (patientIdentifier != null) {
			locationBehavior = patientIdentifier.getIdentifierType().getLocationBehavior();
		}
		if (patientIdentifier == null
		        || patientIdentifier.getPatient() == null
		        || patientIdentifier.getIdentifierType() == null
		        || StringUtils.isBlank(patientIdentifier.getIdentifier())
		        || (locationBehavior == PatientIdentifierType.LocationBehavior.REQUIRED && patientIdentifier.getLocation() == null)) {
			throw new APIException("Patient.identifier.null", (Object[]) null);
		}
		if (patientIdentifier.getPatientIdentifierId() == null) {
			Context.requirePrivilege(PrivilegeConstants.ADD_PATIENT_IDENTIFIERS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_PATIENT_IDENTIFIERS);
		}
		return dao.savePatientIdentifier(patientIdentifier);
	}
	@Override
	public void purgePatientIdentifier(PatientIdentifier patientIdentifier) throws APIException {
		dao.deletePatientIdentifier(patientIdentifier);
	}
	@Override
	@Transactional(readOnly = true)
	public Allergies getAllergies(Patient patient) {
		if (patient == null) {
			throw new IllegalArgumentException("An existing (NOT NULL) patient is required to get allergies");
		}
		Allergies allergies = new Allergies();
		List<Allergy> allergyList = dao.getAllergies(patient);
		if (!allergyList.isEmpty()) {
			allergies.addAll(allergyList);
		} else {
			String status = dao.getAllergyStatus(patient);
			if (Allergies.NO_KNOWN_ALLERGIES.equals(status)) {
				allergies.confirmNoKnownAllergies();
			}
		}
		return allergies;
	}
	@Override
	public Allergies setAllergies(Patient patient, Allergies allergies) {
		List<Allergy> dbAllergyList = getAllergies(patient);
		for (Allergy originalAllergy : dbAllergyList) {
			if (allergies.contains(originalAllergy)) {
				Allergy potentiallyEditedAllergy = allergies.getAllergy(originalAllergy.getAllergyId());
				if (!potentiallyEditedAllergy.hasSameValues(originalAllergy)) {
					Allergy newAllergy = new Allergy();
					try {
						allergies.remove(potentiallyEditedAllergy);
						newAllergy.copy(potentiallyEditedAllergy);
						allergies.add(newAllergy);
						voidAllergy(originalAllergy);
					}
					catch (Exception ex) {
						throw new APIException("Failed to copy edited values", ex);
					}
				}
				continue;
			}
			voidAllergy(originalAllergy);
		}
		for (Allergy allergy : allergies) {
			if (allergy.getAllergyId() == null && allergy.getAllergen().getCodedAllergen() == null
			        && StringUtils.isNotBlank(allergy.getAllergen().getNonCodedAllergen())) {
				Concept otherNonCoded = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid());
				if (otherNonCoded == null) {
					throw new APIException("Can't find concept with uuid:" + Allergen.getOtherNonCodedConceptUuid());
				}
				allergy.getAllergen().setCodedAllergen(otherNonCoded);
			}
		}
		return dao.saveAllergies(patient, allergies);
	}
	private void voidAllergy(Allergy allergy) {
		allergy.setVoided(true);
		allergy.setVoidedBy(Context.getAuthenticatedUser());
		allergy.setDateVoided(new Date());
		allergy.setVoidReason("Voided by API");
		dao.saveAllergy(allergy);
	}
	@Override
	@Transactional(readOnly = true)
	public Allergy getAllergy(Integer allergyId) throws APIException {
		return dao.getAllergy(allergyId);
	}
	@Override
	@Transactional(readOnly = true)
	public Allergy getAllergyByUuid(String uuid) throws APIException {
		return dao.getAllergyByUuid(uuid);
	}
	@Override
	public void saveAllergy(Allergy allergy) throws APIException {
		dao.saveAllergy(allergy);
	}
	@Override
	public void removeAllergy(Allergy allergy, String reason) throws APIException {
		voidAllergy(allergy, reason);
	}
	@Override
	public void voidAllergy(Allergy allergy, String reason) throws APIException {
		allergy.setVoided(true);
		allergy.setVoidedBy(Context.getAuthenticatedUser());
		allergy.setDateVoided(new Date());
		allergy.setVoidReason(reason);
		dao.saveAllergy(allergy);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfPatients(String query) {
		int count = 0;
		if (StringUtils.isBlank(query)) {
			return count;
		}
		return OpenmrsUtil.convertToInteger(dao.getCountOfPatients(query));
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfPatients(String query, boolean includeVoided) {
		int count = 0;
		if (StringUtils.isBlank(query)) {
			return count;
		}
		return OpenmrsUtil.convertToInteger(dao.getCountOfPatients(query, includeVoided));
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query, Integer start, Integer length) throws APIException {
		List<Patient> patients = new ArrayList<>();
		if (StringUtils.isBlank(query)) {
			return patients;
		}
		return dao.getPatients(query, start, length);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query, boolean includeVoided, Integer start, Integer length) throws APIException {
		if (StringUtils.isBlank(query)) {
			return Collections.emptyList();
		}
		return dao.getPatients(query, includeVoided, start, length);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String name, String identifier, List<PatientIdentifierType> identifierTypes,
	        boolean matchIdentifierExactly, Integer start, Integer length) throws APIException {
		if(identifierTypes == null) {
			return dao.getPatients(name != null ? name : identifier, start, length);
		}
		else {
			return dao.getPatients(name != null ? name : identifier, identifierTypes, matchIdentifierExactly, start, length);
		}
	}
	@Override
	public void checkIfPatientIdentifierTypesAreLocked() {
		String locked = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_IDENTIFIER_TYPES_LOCKED, "false");
		if ("true".equalsIgnoreCase(locked)) {
			throw new PatientIdentifierTypeLockedException();
		}
	}
	public List<PatientIdentifier> getPatientIdentifiersByPatientProgram(PatientProgram patientProgram) {
		return dao.getPatientIdentifierByProgram(patientProgram);
	}
}
package org.openmrs.validator;
import java.util.Date;
import org.openmrs.DrugOrder;
import org.openmrs.Encounter;
import org.openmrs.Order;
import org.openmrs.OrderType;
import org.openmrs.annotation.Handler;
import org.springframework.validation.Errors;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;
@Handler(supports = { Order.class })
public class OrderValidator implements Validator {
	@Override
	public boolean supports(Class<?> c) {
		return Order.class.isAssignableFrom(c);
	}
	@Override
	public void validate(Object obj, Errors errors) {
		Order order = (Order) obj;
		if (order == null) {
			errors.reject("error.general");
		} else {
			ValidationUtils.rejectIfEmpty(errors, "voided", "error.null");
			if (!DrugOrder.class.isAssignableFrom(order.getClass())) {
				ValidationUtils.rejectIfEmpty(errors, "concept", "Concept.noConceptSelected");
			}
			ValidationUtils.rejectIfEmpty(errors, "patient", "error.null");
			ValidationUtils.rejectIfEmpty(errors, "encounter", "error.null");
			ValidationUtils.rejectIfEmpty(errors, "orderer", "error.null");
			ValidationUtils.rejectIfEmpty(errors, "urgency", "error.null");
			ValidationUtils.rejectIfEmpty(errors, "action", "error.null");
			validateSamePatientInOrderAndEncounter(order, errors);
			validateOrderTypeClass(order, errors);
			validateDateActivated(order, errors);
			validateScheduledDate(order, errors);
			ValidateUtil.validateFieldLengths(errors, obj.getClass(), "orderReasonNonCoded", "accessionNumber",
			    "commentToFulfiller", "voidReason");
			validateOrderGroupEncounter(order, errors);
			validateOrderGroupPatient(order, errors);
		}
	}
	private void validateOrderTypeClass(Order order, Errors errors) {
		OrderType orderType = order.getOrderType();
		if (orderType != null && !orderType.getJavaClass().isAssignableFrom(order.getClass())) {
			errors.rejectValue("orderType", "Order.error.orderTypeClassMismatchesOrderClass");
		}
	}
	private void validateDateActivated(Order order, Errors errors) {
		Date dateActivated = order.getDateActivated();
		if (dateActivated != null) {
			if (dateActivated.after(new Date())) {
				errors.rejectValue("dateActivated", "Order.error.dateActivatedInFuture");
				return;
			}
			Date dateStopped = order.getDateStopped();
			if (dateStopped != null && dateActivated.after(dateStopped)) {
				errors.rejectValue("dateActivated", "Order.error.dateActivatedAfterDiscontinuedDate");
				errors.rejectValue("dateStopped", "Order.error.dateActivatedAfterDiscontinuedDate");
			}
			Date autoExpireDate = order.getAutoExpireDate();
			if (autoExpireDate != null && dateActivated.after(autoExpireDate)) {
				errors.rejectValue("dateActivated", "Order.error.dateActivatedAfterAutoExpireDate");
				errors.rejectValue("autoExpireDate", "Order.error.dateActivatedAfterAutoExpireDate");
			}
			Encounter encounter = order.getEncounter();
			if (encounter != null && encounter.getEncounterDatetime() != null
			        && encounter.getEncounterDatetime().after(dateActivated)) {
				errors.rejectValue("dateActivated", "Order.error.encounterDatetimeAfterDateActivated");
			}
		}
	}
	private void validateSamePatientInOrderAndEncounter(Order order, Errors errors) {
		if (order.getEncounter() != null && order.getPatient() != null
				&& !order.getEncounter().getPatient().equals(order.getPatient())) {
			errors.rejectValue("encounter", "Order.error.encounterPatientMismatch");
		}
	}
	private void validateScheduledDate(Order order, Errors errors) {
		boolean isUrgencyOnScheduledDate = (order.getUrgency() != null && order.getUrgency().equals(
		    Order.Urgency.ON_SCHEDULED_DATE));
		if (order.getScheduledDate() != null && !isUrgencyOnScheduledDate) {
			errors.rejectValue("urgency", "Order.error.urgencyNotOnScheduledDate");
		}
		if (isUrgencyOnScheduledDate && order.getScheduledDate() == null) {
			errors.rejectValue("scheduledDate", "Order.error.scheduledDateNullForOnScheduledDateUrgency");
		}
	}
	private void validateOrderGroupEncounter(Order order, Errors errors) {
		if (order.getOrderGroup() != null && !(order.getEncounter().equals(order.getOrderGroup().getEncounter()))) {
			errors.rejectValue("encounter", "Order.error.orderEncounterAndOrderGroupEncounterMismatch");
		}
	}
	private void validateOrderGroupPatient(Order order, Errors errors) {
		if (order.getOrderGroup() != null && !(order.getPatient().equals(order.getOrderGroup().getPatient()))) {
			errors.rejectValue("patient", "Order.error.orderPatientAndOrderGroupPatientMismatch");
		}
	}
}
package org.openmrs;
public abstract class ServiceOrder extends Order {
	public enum Laterality {
		LEFT,
		RIGHT,
		BILATERAL
	}
	public static final long serialVersionUID = 1L;
	public Concept specimenSource;
	private Laterality laterality;
	private String clinicalHistory;
	private OrderFrequency frequency;
	private Integer numberOfRepeats;
	private Concept location;
	public ServiceOrder() {
	}
	protected ServiceOrder copyHelper(ServiceOrder target) {
		super.copyHelper(target);
		target.specimenSource = getSpecimenSource();
		target.laterality = getLaterality();
		target.clinicalHistory = getClinicalHistory();
		target.frequency = getFrequency();
		target.numberOfRepeats = getNumberOfRepeats();
		target.location = getLocation();
		return target;
	}
	public Concept getSpecimenSource() {
		return specimenSource;
	}
	public void setSpecimenSource(Concept specimenSource) {
		this.specimenSource = specimenSource;
	}
	public Laterality getLaterality() {
		return laterality;
	}
	public void setLaterality(ServiceOrder.Laterality laterality) {
		this.laterality = laterality;
	}
	public String getClinicalHistory() {
		return clinicalHistory;
	}
	public void setClinicalHistory(String clinicalHistory) {
		this.clinicalHistory = clinicalHistory;
	}
	public OrderFrequency getFrequency() {
		return frequency;
	}
	public void setFrequency(OrderFrequency frequency) {
		this.frequency = frequency;
	}
	public Integer getNumberOfRepeats() {
		return numberOfRepeats;
	}
	public void setNumberOfRepeats(Integer numberOfRepeats) {
		this.numberOfRepeats = numberOfRepeats;
	}
	public Concept getLocation() {
		return location;
	}
	public void setLocation(Concept location) {
		this.location = location;
	}
	protected ServiceOrder cloneForRevisionHelper(ServiceOrder target) {
		super.cloneForRevisionHelper(target);
		target.setSpecimenSource(getSpecimenSource());
		target.setLaterality(getLaterality());
		target.setClinicalHistory(getClinicalHistory());
		target.setFrequency(getFrequency());
		target.setNumberOfRepeats(getNumberOfRepeats());
		target.setLocation(getLocation());
		return target;
	}
	protected ServiceOrder cloneForDiscontinuingHelper(ServiceOrder target) {
		target.setCareSetting(getCareSetting());
		target.setConcept(getConcept());
		target.setAction(Action.DISCONTINUE);
		target.setPreviousOrder(this);
		target.setPatient(getPatient());
		target.setOrderType(getOrderType());
		return target;
	}
}
package org.openmrs.api.impl;
import org.apache.commons.lang3.time.DateUtils;
import org.hibernate.proxy.HibernateProxy;
import org.openmrs.CareSetting;
import org.openmrs.Concept;
import org.openmrs.ConceptClass;
import org.openmrs.Encounter;
import org.openmrs.DrugOrder;
import org.openmrs.Order;
import org.openmrs.OrderAttribute;
import org.openmrs.OrderAttributeType;
import org.openmrs.OrderFrequency;
import org.openmrs.OrderGroup;
import org.openmrs.OrderType;
import org.openmrs.GlobalProperty;
import org.openmrs.Patient;
import org.openmrs.Provider;
import org.openmrs.ReferralOrder;
import org.openmrs.Order.FulfillerStatus;
import org.openmrs.OrderGroupAttribute;
import org.openmrs.OrderGroupAttributeType;
import org.openmrs.TestOrder;
import org.openmrs.Visit;
import org.openmrs.api.APIException;
import org.openmrs.api.AmbiguousOrderException;
import org.openmrs.api.CannotDeleteObjectInUseException;
import org.openmrs.api.CannotStopDiscontinuationOrderException;
import org.openmrs.api.CannotStopInactiveOrderException;
import org.openmrs.api.CannotUnvoidOrderException;
import org.openmrs.api.CannotUpdateObjectInUseException;
import org.openmrs.api.EditedOrderDoesNotMatchPreviousException;
import org.openmrs.api.GlobalPropertyListener;
import org.openmrs.api.MissingRequiredPropertyException;
import org.openmrs.api.OrderContext;
import org.openmrs.api.OrderEntryException;
import org.openmrs.api.OrderNumberGenerator;
import org.openmrs.api.OrderService;
import org.openmrs.api.UnchangeableObjectException;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.OrderDAO;
import org.openmrs.customdatatype.CustomDatatypeUtil;
import org.openmrs.order.OrderUtil;
import org.openmrs.parameter.OrderSearchCriteria;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import static org.openmrs.Order.Action.DISCONTINUE;
import static org.openmrs.Order.Action.REVISE;
@Transactional
public class OrderServiceImpl extends BaseOpenmrsService implements OrderService, OrderNumberGenerator, GlobalPropertyListener {
	private static final Logger log = LoggerFactory.getLogger(OrderServiceImpl.class);
	private static final String ORDER_NUMBER_PREFIX = "ORD-";
	protected OrderDAO dao;
	private static OrderNumberGenerator orderNumberGenerator = null;
	public OrderServiceImpl() {
	}
	@Override
	public void setOrderDAO(OrderDAO dao) {
		this.dao = dao;
	}
	@Override
	public synchronized Order saveOrder(Order order, OrderContext orderContext) throws APIException {
		return saveOrder(order, orderContext, false);
	}
	@Override
	public OrderGroup saveOrderGroup(OrderGroup orderGroup) throws APIException {
		return saveOrderGroup(orderGroup, null);
	}
	@Override
	public OrderGroup saveOrderGroup(OrderGroup orderGroup, OrderContext orderContext) throws APIException {
		if (orderGroup.getId() == null) {
			orderGroup.setPatient(orderGroup.getEncounter().getPatient());
			CustomDatatypeUtil.saveAttributesIfNecessary(orderGroup);
			dao.saveOrderGroup(orderGroup);
		}
		List<Order> orders = orderGroup.getOrders();
		for (Order order : orders) {
			if (order.getId() == null) {
				order.setEncounter(orderGroup.getEncounter());
				Context.getOrderService().saveOrder(order, orderContext);
			}
		}
		Set<OrderGroup> nestedGroups = orderGroup.getNestedOrderGroups();
		if (nestedGroups != null) {
			for (OrderGroup nestedGroup : nestedGroups) {
				Context.getOrderService().saveOrderGroup(nestedGroup, orderContext);
			}
		}
		return orderGroup;
	}
	@Override
	public synchronized Order saveRetrospectiveOrder(Order order, OrderContext orderContext) {
		return saveOrder(order, orderContext, true);
	}
	private Order saveOrder(Order order, OrderContext orderContext, boolean isRetrospective) {
		failOnExistingOrder(order);
		ensureDateActivatedIsSet(order);
		ensureConceptIsSet(order);
		ensureDrugOrderAutoExpirationDateIsSet(order);
		ensureOrderTypeIsSet(order,orderContext);
		ensureCareSettingIsSet(order,orderContext);
		failOnOrderTypeMismatch(order);
		if (!isRetrospective) {
			Date dateActivated = order.getDateActivated();
			Date currentDate = new Date();
			isRetrospective = !dateActivated.after(currentDate) && !DateUtils.isSameDay(dateActivated, currentDate);
		}
		Order previousOrder = order.getPreviousOrder();
		if (REVISE == order.getAction()) {
			if (previousOrder == null) {
				throw new MissingRequiredPropertyException("Order.previous.required", (Object[]) null);
			}
			stopOrder(previousOrder, aMomentBefore(order.getDateActivated()), isRetrospective);
		} else if (DISCONTINUE == order.getAction()) {
			discontinueExistingOrdersIfNecessary(order, isRetrospective);
		}
		if (previousOrder != null) {
			if (!order.hasSameOrderableAs(previousOrder)) {
				throw new EditedOrderDoesNotMatchPreviousException("Order.orderable.doesnot.match");
			} else if (!order.getOrderType().equals(previousOrder.getOrderType())) {
				throw new EditedOrderDoesNotMatchPreviousException("Order.type.doesnot.match");
			} else if (!order.getCareSetting().equals(previousOrder.getCareSetting())) {
				throw new EditedOrderDoesNotMatchPreviousException("Order.care.setting.doesnot.match");
			} else if (!getActualType(order).equals(getActualType(previousOrder))) {
				throw new EditedOrderDoesNotMatchPreviousException("Order.class.doesnot.match");
			}
		}
		if (DISCONTINUE != order.getAction()) {
			Date asOfDate = new Date();
			if (isRetrospective) {
				asOfDate = order.getDateActivated();
			}
			List<Order> activeOrders = getActiveOrders(order.getPatient(), null, order.getCareSetting(), asOfDate);
			List<String> parallelOrders = Collections.emptyList();
			if (orderContext != null && orderContext.getAttribute(PARALLEL_ORDERS) != null) {
				parallelOrders = Arrays.asList((String[]) orderContext.getAttribute(PARALLEL_ORDERS));
			}
			for (Order activeOrder : activeOrders) {
				if (!parallelOrders.contains(activeOrder.getUuid())
				        && areDrugOrdersOfSameOrderableAndOverlappingSchedule(order, activeOrder)) {
					throw new AmbiguousOrderException("Order.cannot.have.more.than.one");
				}
			}
		}
		return saveOrderInternal(order, orderContext);
	}
	private void failOnExistingOrder(Order order) {
		if (order.getOrderId() != null) {
			throw new UnchangeableObjectException("Order.cannot.edit.existing");
		}
	}
	private void ensureDateActivatedIsSet(Order order) {
		if (order.getDateActivated() == null) {
			order.setDateActivated(new Date());
		}
	}
	private void ensureConceptIsSet(Order order) {
		Concept concept = order.getConcept();
		if (concept == null && isDrugOrder(order)) {
			DrugOrder drugOrder = (DrugOrder) order;
			if (drugOrder.getDrug() != null) {
				concept = drugOrder.getDrug().getConcept();
				drugOrder.setConcept(concept);
			}
		}
		if (concept == null) {
			throw new MissingRequiredPropertyException("Order.concept.required");
		}
	}
	private void ensureDrugOrderAutoExpirationDateIsSet(Order order) {
		if (isDrugOrder(order)) {
			((DrugOrder) order).setAutoExpireDateBasedOnDuration();
		}
	}
	private void ensureOrderTypeIsSet(Order order, OrderContext orderContext) {
		if (order.getOrderType() != null) {
			return;
		}
		OrderType orderType = null;
		if (orderContext != null) {
			orderType = orderContext.getOrderType();
		}
		if (orderType == null) {
			orderType = getOrderTypeByConcept(order.getConcept());
		}
		if (orderType == null && order instanceof DrugOrder) {
			orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.DRUG_ORDER_TYPE_UUID);
		}
		if (orderType == null && order instanceof TestOrder) {
			orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.TEST_ORDER_TYPE_UUID);
		}
		if (orderType == null && order instanceof ReferralOrder) {
			orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.REFERRAL_ORDER_TYPE_UUID);
		}
		if (orderType == null) {
			throw new OrderEntryException("Order.type.cannot.determine");
		}
		Order previousOrder = order.getPreviousOrder();
		if (previousOrder != null && !orderType.equals(previousOrder.getOrderType())) {
			throw new OrderEntryException("Order.type.does.not.match");
		}
		order.setOrderType(orderType);
	}
	private void ensureCareSettingIsSet(Order order, OrderContext orderContext) {
		if (order.getCareSetting() != null) {
			return;
		}
		CareSetting careSetting = null;
		if (orderContext != null) {
			careSetting = orderContext.getCareSetting();
		}
		Order previousOrder = order.getPreviousOrder();
		if (careSetting == null || (previousOrder != null && !careSetting.equals(previousOrder.getCareSetting()))) {
			throw new OrderEntryException("Order.care.cannot.determine");
		}
		order.setCareSetting(careSetting);
	}
	private void failOnOrderTypeMismatch(Order order) {
		if (!order.getOrderType().getJavaClass().isAssignableFrom(order.getClass())) {
			throw new OrderEntryException("Order.type.class.does.not.match", new Object[] {
					order.getOrderType().getJavaClass(), order.getClass().getName() });
		}
	}
	private boolean areDrugOrdersOfSameOrderableAndOverlappingSchedule(Order firstOrder, Order secondOrder) {
		return firstOrder.hasSameOrderableAs(secondOrder)
		        && !OpenmrsUtil.nullSafeEquals(firstOrder.getPreviousOrder(), secondOrder)
		        && OrderUtil.checkScheduleOverlap(firstOrder, secondOrder)
		        && firstOrder.getOrderType().equals(
		            Context.getOrderService().getOrderTypeByUuid(OrderType.DRUG_ORDER_TYPE_UUID));
	}
	private boolean isDrugOrder(Order order) {
		return DrugOrder.class.isAssignableFrom(getActualType(order));
	}
	private Date aMomentBefore(Date date) {
		return DateUtils.addSeconds(date, -1);
	}
	private Order saveOrderInternal(Order order, OrderContext orderContext) {
		if (order.getOrderId() == null) {
			setProperty(order, "orderNumber", getOrderNumberGenerator().getNewOrderNumber(orderContext));
			if (DISCONTINUE == order.getAction()) {
				order.setAutoExpireDate(order.getDateActivated());
			} else if (order.getAutoExpireDate() != null) {
				Calendar cal = Calendar.getInstance();
				cal.setTime(order.getAutoExpireDate());
				int hours = cal.get(Calendar.HOUR_OF_DAY);
				int minutes = cal.get(Calendar.MINUTE);
				int seconds = cal.get(Calendar.SECOND);
				cal.get(Calendar.MILLISECOND);
				if (hours == 0 && minutes == 0 && seconds == 0) {
					cal.set(Calendar.HOUR_OF_DAY, 23);
					cal.set(Calendar.MINUTE, 59);
					cal.set(Calendar.SECOND, 59);
					cal.set(Calendar.MILLISECOND, 0);
					order.setAutoExpireDate(cal.getTime());
				}
			}
		}
		return dao.saveOrder(order);
	}
	private void setProperty(Order order, String propertyName, Object value) {
		Boolean isAccessible = null;
		Field field = null;
		try {
			field = Order.class.getDeclaredField(propertyName);
			field.setAccessible(true);
			field.set(order, value);
		}
		catch (Exception e) {
			throw new APIException("Order.failed.set.property", new Object[] { propertyName, order }, e);
		}
		finally {
			if (field != null && isAccessible != null) {
				field.setAccessible(isAccessible);
			}
		}
	}
	private OrderNumberGenerator getOrderNumberGenerator() {
		if (orderNumberGenerator == null) {
			String generatorBeanId = Context.getAdministrationService().getGlobalProperty(
			    OpenmrsConstants.GP_ORDER_NUMBER_GENERATOR_BEAN_ID);
			if (StringUtils.hasText(generatorBeanId)) {
				orderNumberGenerator = Context.getRegisteredComponent(generatorBeanId, OrderNumberGenerator.class);
				log.info("Successfully set the configured order number generator");
			} else {
				orderNumberGenerator = this;
				log.info("Setting default order number generator");
			}
		}
		return orderNumberGenerator;
	}
	private void discontinueExistingOrdersIfNecessary(Order order, Boolean isRetrospective) {
		if (DISCONTINUE != order.getAction()) {
			return;
		}
		Order previousOrder = order.getPreviousOrder();
		if (previousOrder != null) {
			stopOrder(previousOrder, aMomentBefore(order.getDateActivated()), isRetrospective);
			return;
		}
		Date asOfDate = null;
		if (isRetrospective) {
			asOfDate = order.getDateActivated();
		}
		List<? extends Order> orders = getActiveOrders(order.getPatient(), order.getOrderType(), order.getCareSetting(),
		    asOfDate);
		boolean isDrugOrderAndHasADrug = isDrugOrder(order)
		        && (((DrugOrder) order).getDrug() != null || ((DrugOrder) order).isNonCodedDrug());
		Order orderToBeDiscontinued = null;
		for (Order activeOrder : orders) {
			if (!getActualType(order).equals(getActualType(activeOrder))) {
				continue;
			}
			if (isDrugOrderAndHasADrug) {
				Order existing = order.hasSameOrderableAs(activeOrder) ? activeOrder : null;
				if (existing != null) {
					if (orderToBeDiscontinued == null) {
						orderToBeDiscontinued = existing;
					} else {
						throw new AmbiguousOrderException("Order.discontinuing.ambiguous.orders");
					}
				}
			} else if (activeOrder.getConcept().equals(order.getConcept())) {
				if (orderToBeDiscontinued == null) {
					orderToBeDiscontinued = activeOrder;
				} else {
					throw new AmbiguousOrderException("Order.discontinuing.ambiguous.orders");
				}
			}
		}
		if (orderToBeDiscontinued != null) {
			order.setPreviousOrder(orderToBeDiscontinued);
			stopOrder(orderToBeDiscontinued, aMomentBefore(order.getDateActivated()), isRetrospective);
		}
	}
	private Class<?> getActualType(Object persistentObject) {
		Class<?> type = persistentObject.getClass();
		if (persistentObject instanceof HibernateProxy) {
			type = ((HibernateProxy) persistentObject).getHibernateLazyInitializer().getPersistentClass();
		}
		return type;
	}
	@Override
	public void purgeOrder(Order order) throws APIException {
		purgeOrder(order, false);
	}
	@Override
	public void purgeOrder(Order order, boolean cascade) throws APIException {
		if (cascade) {
			dao.deleteObsThatReference(order);
		}
		dao.deleteOrder(order);
	}
	@Override
	public Order voidOrder(Order order, String voidReason) throws APIException {
		if (!StringUtils.hasLength(voidReason)) {
			throw new IllegalArgumentException("voidReason cannot be empty or null");
		}
		Order previousOrder = order.getPreviousOrder();
		if (previousOrder != null && isDiscontinueOrReviseOrder(order)) {
			setProperty(previousOrder, "dateStopped", null);
		}
		return saveOrderInternal(order, null);
	}
	@Override
	public Order unvoidOrder(Order order) throws APIException {
		Order previousOrder = order.getPreviousOrder();
		if (previousOrder != null && isDiscontinueOrReviseOrder(order)) {
			if (!previousOrder.isActive()) {
				final String action = DISCONTINUE == order.getAction() ? "discontinuation" : "revision";
				throw new CannotUnvoidOrderException(action);
			}
			stopOrder(previousOrder, aMomentBefore(order.getDateActivated()), false);
		}
		return saveOrderInternal(order, null);
	}
	@Override
	public Order updateOrderFulfillerStatus(Order order, Order.FulfillerStatus orderFulfillerStatus, String fullFillerComment) {
		return updateOrderFulfillerStatus(order, orderFulfillerStatus, fullFillerComment, null);
	}
	@Override
	public Order updateOrderFulfillerStatus(Order order, FulfillerStatus orderFulfillerStatus, String fullFillerComment,
											String accessionNumber) {
		if (orderFulfillerStatus != null) {
			order.setFulfillerStatus(orderFulfillerStatus);
		}
		if (fullFillerComment != null) {
			order.setFulfillerComment(fullFillerComment);
		}
		if (accessionNumber != null) {
			order.setAccessionNumber(accessionNumber);
		}
		return saveOrderInternal(order, null);
	}
	@Override
	@Transactional(readOnly = true)
	public Order getOrder(Integer orderId) throws APIException {
		return dao.getOrder(orderId);
	}
	@Override
	public List<Order> getOrders(Patient patient, CareSetting careSetting, OrderType orderType, boolean includeVoided) {
		return this.getOrders(patient, null, careSetting, orderType, includeVoided);
	}
	@Override
	public List<Order> getOrders(Patient patient, Visit visit, CareSetting careSetting, OrderType orderType, boolean includeVoided) {
		if (patient == null) {
			throw new IllegalArgumentException("Patient is required");
		}
		if (careSetting == null) {
			throw new IllegalArgumentException("CareSetting is required");
		}
		List<OrderType> orderTypes = null;
		if (orderType != null) {
			orderTypes = new ArrayList<>();
			orderTypes.add(orderType);
			orderTypes.addAll(getSubtypes(orderType, true));
		}
		return dao.getOrders(patient, visit, careSetting, orderTypes, includeVoided, false);
	}
	@Override
	public List<Order> getAllOrdersByPatient(Patient patient) {
		if (patient == null) {
			throw new IllegalArgumentException("Patient is required");
		}
		return dao.getOrders(patient, null, null, true, true);
	}
	@Override
	public List<Order> getOrders(OrderSearchCriteria orderSearchCriteria) {
		return dao.getOrders(orderSearchCriteria);
	}
	@Override
	@Transactional(readOnly = true)
	public Order getOrderByUuid(String uuid) throws APIException {
		return dao.getOrderByUuid(uuid);
	}
	@Transactional(readOnly = true)
	@Override
	public Order getDiscontinuationOrder(Order order) throws APIException {
		return dao.getDiscontinuationOrder(order);
	}
	@Override
	public Order getRevisionOrder(Order order) throws APIException {
		return dao.getRevisionOrder(order);
	}
	@Override
	public String getNewOrderNumber(OrderContext orderContext) throws APIException {
		return ORDER_NUMBER_PREFIX + Context.getOrderService().getNextOrderNumberSeedSequenceValue();
	}
	@Override
	@Transactional(readOnly = true)
	public Order getOrderByOrderNumber(String orderNumber) {
		return dao.getOrderByOrderNumber(orderNumber);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Order> getOrderHistoryByConcept(Patient patient, Concept concept) {
		if (patient == null || concept == null) {
			throw new IllegalArgumentException("patient and concept are required");
		}
		List<Concept> concepts = new ArrayList<>();
		concepts.add(concept);
		List<Patient> patients = new ArrayList<>();
		patients.add(patient);
		return dao.getOrders(null, patients, concepts, new ArrayList<>(), new ArrayList<>());
	}
	@Override
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public synchronized Long getNextOrderNumberSeedSequenceValue() {
		return dao.getNextOrderNumberSeedSequenceValue();
	}
	@Override
	@Transactional(readOnly = true)
	public List<Order> getOrderHistoryByOrderNumber(String orderNumber) {
		List<Order> orders = new ArrayList<>();
		Order order = dao.getOrderByOrderNumber(orderNumber);
		while (order != null) {
			orders.add(order);
			order = order.getPreviousOrder();
		}
		return orders;
	}
	@Override
	@Transactional(readOnly = true)
	public List<Order> getActiveOrders(Patient patient, OrderType orderType, CareSetting careSetting, Date asOfDate) {
		return this.getActiveOrders(patient, null, orderType, careSetting, asOfDate);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Order> getActiveOrders(Patient patient, Visit visit, OrderType orderType, CareSetting careSetting, Date asOfDate) {
		if (patient == null) {
			throw new IllegalArgumentException("Patient is required when fetching active orders");
		}
		if (asOfDate == null) {
			asOfDate = new Date();
		}
		List<OrderType> orderTypes = null;
		if (orderType != null) {
			orderTypes = new ArrayList<>();
			orderTypes.add(orderType);
			orderTypes.addAll(getSubtypes(orderType, true));
		}
		return dao.getActiveOrders(patient, visit, orderTypes, careSetting, asOfDate);
	}
	@Override
	public CareSetting getCareSetting(Integer careSettingId) {
		return dao.getCareSetting(careSettingId);
	}
	@Override
	public CareSetting getCareSettingByUuid(String uuid) {
		return dao.getCareSettingByUuid(uuid);
	}
	@Override
	public CareSetting getCareSettingByName(String name) {
		return dao.getCareSettingByName(name);
	}
	@Override
	public List<CareSetting> getCareSettings(boolean includeRetired) {
		return dao.getCareSettings(includeRetired);
	}
	@Override
	public OrderType getOrderTypeByName(String orderTypeName) {
		return dao.getOrderTypeByName(orderTypeName);
	}
	@Override
	public OrderFrequency getOrderFrequency(Integer orderFrequencyId) {
		return dao.getOrderFrequency(orderFrequencyId);
	}
	@Override
	public OrderFrequency getOrderFrequencyByUuid(String uuid) {
		return dao.getOrderFrequencyByUuid(uuid);
	}
	@Override
	public List<OrderFrequency> getOrderFrequencies(boolean includeRetired) {
		return dao.getOrderFrequencies(includeRetired);
	}
	@Override
	public List<OrderFrequency> getOrderFrequencies(String searchPhrase, Locale locale, boolean exactLocale,
	                                                boolean includeRetired) {
		if (searchPhrase == null) {
			throw new IllegalArgumentException("searchPhrase is required");
		}
		return dao.getOrderFrequencies(searchPhrase, locale, exactLocale, includeRetired);
	}
	@Override
	public Order discontinueOrder(Order orderToDiscontinue, Concept reasonCoded, Date discontinueDate, Provider orderer,
	                              Encounter encounter) {
		if (discontinueDate == null) {
			discontinueDate = aMomentBefore(new Date());
		}
		stopOrder(orderToDiscontinue, discontinueDate, false);
		Order newOrder = orderToDiscontinue.cloneForDiscontinuing();
		newOrder.setOrderReason(reasonCoded);
		newOrder.setOrderer(orderer);
		newOrder.setEncounter(encounter);
		newOrder.setDateActivated(discontinueDate);
		return saveOrderInternal(newOrder, null);
	}
	@Override
	public Order discontinueOrder(Order orderToDiscontinue, String reasonNonCoded, Date discontinueDate, Provider orderer,
	                              Encounter encounter) {
		if (discontinueDate == null) {
			discontinueDate = aMomentBefore(new Date());
		}
		stopOrder(orderToDiscontinue, discontinueDate, false);
		Order newOrder = orderToDiscontinue.cloneForDiscontinuing();
		newOrder.setOrderReasonNonCoded(reasonNonCoded);
		newOrder.setOrderer(orderer);
		newOrder.setEncounter(encounter);
		newOrder.setDateActivated(discontinueDate);
		return saveOrderInternal(newOrder, null);
	}
	private boolean isDiscontinueOrReviseOrder(Order order) {
		return DISCONTINUE == order.getAction() || REVISE == order.getAction();
	}
	private void stopOrder(Order orderToStop, Date discontinueDate, boolean isRetrospective) {
		if (discontinueDate == null) {
			discontinueDate = new Date();
		}
		if (discontinueDate.after(new Date())) {
			throw new IllegalArgumentException("Discontinue date cannot be in the future");
		}
		if (DISCONTINUE == orderToStop.getAction()) {
			throw new CannotStopDiscontinuationOrderException();
		}
		if (isRetrospective && orderToStop.getDateStopped() != null) {
			throw new CannotStopInactiveOrderException();
		}
		if (!isRetrospective && !orderToStop.isActive()) {
			throw new CannotStopInactiveOrderException();
		} else if (isRetrospective && !orderToStop.isActive(discontinueDate)) {
			throw new CannotStopInactiveOrderException();
		}
		setProperty(orderToStop, "dateStopped", discontinueDate);
		saveOrderInternal(orderToStop, null);
	}
	@Override
	public OrderFrequency saveOrderFrequency(OrderFrequency orderFrequency) throws APIException {
		return dao.saveOrderFrequency(orderFrequency);
	}
	@Override
	public OrderFrequency retireOrderFrequency(OrderFrequency orderFrequency, String reason) {
		return dao.saveOrderFrequency(orderFrequency);
	}
	@Override
	public OrderFrequency unretireOrderFrequency(OrderFrequency orderFrequency) {
		return Context.getOrderService().saveOrderFrequency(orderFrequency);
	}
	@Override
	public void purgeOrderFrequency(OrderFrequency orderFrequency) {
		if (dao.isOrderFrequencyInUse(orderFrequency)) {
			throw new CannotDeleteObjectInUseException("Order.frequency.cannot.delete", (Object[]) null);
		}
		dao.purgeOrderFrequency(orderFrequency);
	}
	@Override
	@Transactional(readOnly = true)
	public OrderFrequency getOrderFrequencyByConcept(Concept concept) {
		return dao.getOrderFrequencyByConcept(concept);
	}
	@Override
	public boolean supportsPropertyName(String propertyName) {
		return OpenmrsConstants.GP_ORDER_NUMBER_GENERATOR_BEAN_ID.equals(propertyName);
	}
	@Override
	public void globalPropertyChanged(GlobalProperty newValue) {
		setOrderNumberGenerator(null);
	}
	@Override
	public void globalPropertyDeleted(String propertyName) {
		setOrderNumberGenerator(null);
	}
	private static void setOrderNumberGenerator(OrderNumberGenerator orderNumberGenerator) {
		OrderServiceImpl.orderNumberGenerator = orderNumberGenerator;
	}
	@Override
	@Transactional(readOnly = true)
	public OrderType getOrderType(Integer orderTypeId) {
		return dao.getOrderType(orderTypeId);
	}
	@Override
	@Transactional(readOnly = true)
	public OrderType getOrderTypeByUuid(String uuid) {
		return dao.getOrderTypeByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public List<OrderType> getOrderTypes(boolean includeRetired) {
		return dao.getOrderTypes(includeRetired);
	}
	@Override
	public OrderType saveOrderType(OrderType orderType) {
		return dao.saveOrderType(orderType);
	}
	@Override
	public void purgeOrderType(OrderType orderType) {
		if (dao.isOrderTypeInUse(orderType)) {
			throw new CannotDeleteObjectInUseException("Order.type.cannot.delete", (Object[]) null);
		}
		dao.purgeOrderType(orderType);
	}
	@Override
	public OrderType retireOrderType(OrderType orderType, String reason) {
		return saveOrderType(orderType);
	}
	@Override
	public OrderType unretireOrderType(OrderType orderType) {
		return saveOrderType(orderType);
	}
	@Override
	@Transactional(readOnly = true)
	public List<OrderType> getSubtypes(OrderType orderType, boolean includeRetired) {
		List<OrderType> allSubtypes = new ArrayList<>();
		List<OrderType> immediateAncestors = dao.getOrderSubtypes(orderType, includeRetired);
		while (!immediateAncestors.isEmpty()) {
			List<OrderType> ancestorsAtNextLevel = new ArrayList<>();
			for (OrderType type : immediateAncestors) {
				allSubtypes.add(type);
				ancestorsAtNextLevel.addAll(dao.getOrderSubtypes(type, includeRetired));
			}
			immediateAncestors = ancestorsAtNextLevel;
		}
		return allSubtypes;
	}
	@Override
	@Transactional(readOnly = true)
	public OrderType getOrderTypeByConceptClass(ConceptClass conceptClass) {
		return dao.getOrderTypeByConceptClass(conceptClass);
	}
	@Override
	@Transactional(readOnly = true)
	public OrderType getOrderTypeByConcept(Concept concept) {
		return Context.getOrderService().getOrderTypeByConceptClass(concept.getConceptClass());
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getDrugRoutes() {
		return getSetMembersOfConceptSetFromGP(OpenmrsConstants.GP_DRUG_ROUTES_CONCEPT_UUID);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getDrugDosingUnits() {
		return getSetMembersOfConceptSetFromGP(OpenmrsConstants.GP_DRUG_DOSING_UNITS_CONCEPT_UUID);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getDrugDispensingUnits() {
		List<Concept> dispensingUnits = new ArrayList<>(
				getSetMembersOfConceptSetFromGP(OpenmrsConstants.GP_DRUG_DISPENSING_UNITS_CONCEPT_UUID));
		for (Concept concept : getDrugDosingUnits()) {
			if (!dispensingUnits.contains(concept)) {
				dispensingUnits.add(concept);
			}
		}
		return dispensingUnits;
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getDurationUnits() {
		return getSetMembersOfConceptSetFromGP(OpenmrsConstants.GP_DURATION_UNITS_CONCEPT_UUID);
	}
	@Override
	public List<Concept> getTestSpecimenSources() {
		return getSetMembersOfConceptSetFromGP(OpenmrsConstants.GP_TEST_SPECIMEN_SOURCES_CONCEPT_UUID);
	}
	@Override
	public Concept getNonCodedDrugConcept() {
		String conceptUuid = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GP_DRUG_ORDER_DRUG_OTHER);
		if (StringUtils.hasText(conceptUuid)) {
			return Context.getConceptService().getConceptByUuid(conceptUuid);
		}
		return null;
	}
	@Override
	@Transactional(readOnly = true)
	public OrderGroup getOrderGroupByUuid(String uuid) throws APIException {
		return dao.getOrderGroupByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public OrderGroup getOrderGroup(Integer orderGroupId) throws APIException {
		return dao.getOrderGroupById(orderGroupId);
	}
	private List<Concept> getSetMembersOfConceptSetFromGP(String globalProperty) {
		String conceptUuid = Context.getAdministrationService().getGlobalProperty(globalProperty);
		Concept concept = Context.getConceptService().getConceptByUuid(conceptUuid);
		if (concept != null && concept.getSet()) {
			return concept.getSetMembers();
		}
		return Collections.emptyList();
	}
	@Override
	public List<OrderGroup> getOrderGroupsByPatient(Patient patient) throws APIException {
		return dao.getOrderGroupsByPatient(patient);
	}
	@Override
	public List<OrderGroup> getOrderGroupsByEncounter(Encounter encounter) throws APIException {
		return dao.getOrderGroupsByEncounter(encounter);
	}
	@Override
	@Transactional(readOnly = true)
	public List<OrderGroupAttributeType> getAllOrderGroupAttributeTypes() throws APIException {
		return dao.getAllOrderGroupAttributeTypes();
	}
	@Override
	@Transactional(readOnly = true)
	public OrderGroupAttributeType getOrderGroupAttributeType(Integer id) throws APIException {
		return dao.getOrderGroupAttributeType(id);
	}
	@Override
	@Transactional(readOnly = true)
	public OrderGroupAttributeType getOrderGroupAttributeTypeByUuid(String uuid)throws APIException {
		return dao.getOrderGroupAttributeTypeByUuid(uuid);
	}
	@Override
	public OrderGroupAttributeType saveOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType) throws APIException{
		return dao.saveOrderGroupAttributeType(orderGroupAttributeType);
	}
	@Override
	public OrderGroupAttributeType retireOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType, String reason)throws APIException {
		return Context.getOrderService().saveOrderGroupAttributeType(orderGroupAttributeType);
	}
	@Override
	public OrderGroupAttributeType unretireOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType)throws APIException {
		return Context.getOrderService().saveOrderGroupAttributeType(orderGroupAttributeType);
	}
	@Override
	public void purgeOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType) throws APIException{
		dao.deleteOrderGroupAttributeType(orderGroupAttributeType);
	}
	@Override
	@Transactional(readOnly = true)
	public OrderGroupAttributeType getOrderGroupAttributeTypeByName(String orderGroupAttributeTypeName)throws APIException {
		return dao.getOrderGroupAttributeTypeByName(orderGroupAttributeTypeName);
	}
	@Override
	@Transactional(readOnly = true)
	public OrderGroupAttribute getOrderGroupAttributeByUuid(String uuid)throws APIException {
		return dao.getOrderGroupAttributeByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public List<OrderAttributeType> getAllOrderAttributeTypes() throws APIException {
		return dao.getAllOrderAttributeTypes();
	}
	@Override
	@Transactional(readOnly = true)
	public OrderAttributeType getOrderAttributeTypeById(Integer id) throws APIException {
		return dao.getOrderAttributeTypeById(id);
	}
	@Override
	@Transactional(readOnly = true)
	public OrderAttributeType getOrderAttributeTypeByUuid(String uuid)throws APIException {
		return dao.getOrderAttributeTypeByUuid(uuid);
	}
	@Override
	public OrderAttributeType saveOrderAttributeType(OrderAttributeType orderAttributeType) throws APIException{
		return dao.saveOrderAttributeType(orderAttributeType);
	}
	@Override
	public OrderAttributeType retireOrderAttributeType(OrderAttributeType orderAttributeType, String reason)throws APIException {
		return Context.getOrderService().saveOrderAttributeType(orderAttributeType);
	}
	@Override
	public OrderAttributeType unretireOrderAttributeType(OrderAttributeType orderAttributeType)throws APIException {
		return Context.getOrderService().saveOrderAttributeType(orderAttributeType);
	}
	@Override
	public void purgeOrderAttributeType(OrderAttributeType orderAttributeType) throws APIException{
		dao.deleteOrderAttributeType(orderAttributeType);
	}
	@Override
	@Transactional(readOnly = true)
	public OrderAttributeType getOrderAttributeTypeByName(String orderAttributeTypeName)throws APIException {
		return dao.getOrderAttributeTypeByName(orderAttributeTypeName);
	}
	@Override
	@Transactional(readOnly = true)
	public OrderAttribute getOrderAttributeByUuid(String uuid)throws APIException {
		return dao.getOrderAttributeByUuid(uuid);
	}
}
package org.openmrs.parameter;
import org.openmrs.*;
import java.util.Collection;
import java.util.Date;
public class OrderSearchCriteriaBuilder {
	private Patient patient;
	private CareSetting careSetting;
	private Collection<Concept> concepts;
	private Collection<OrderType> orderTypes;
	private Visit visit;
	private String accessionNumber;
	private String orderNumber;
	private Date activatedOnOrBeforeDate;
	private Date activatedOnOrAfterDate;
	private boolean isStopped;
	private Date autoExpireOnOrBeforeDate;
	private Date canceledOrExpiredOnOrBeforeDate;
	private Order.Action action;
	private Order.FulfillerStatus fulfillerStatus;
	private Boolean includeNullFulfillerStatus;
	private boolean excludeCanceledAndExpired;
	private boolean excludeDiscontinueOrders;
	private boolean includeVoided;
	public OrderSearchCriteriaBuilder setPatient(Patient patient) {
		this.patient = patient;
		return (this);
	}
	public OrderSearchCriteriaBuilder setVisit(Visit visit) {
		this.visit = visit;
		return (this);
	}
	public OrderSearchCriteriaBuilder setCareSetting(CareSetting careSetting) {
		this.careSetting = careSetting;
		return (this);
	}
	public OrderSearchCriteriaBuilder setConcepts(Collection<Concept> concepts) {
		this.concepts = concepts;
		return (this);
	}
	public OrderSearchCriteriaBuilder setOrderTypes(Collection<OrderType> orderTypes) {
		this.orderTypes = orderTypes;
		return (this);
	}
	public OrderSearchCriteriaBuilder setAccessionNumber(String accessionNumber) {
		this.accessionNumber = accessionNumber;
		return (this);
	}
	public OrderSearchCriteriaBuilder setOrderNumber(String orderNumber) {
		this.orderNumber = orderNumber;
		return (this);
	}
	public OrderSearchCriteriaBuilder setActivatedOnOrBeforeDate(Date activatedOnOrBeforeDate) {
		this.activatedOnOrBeforeDate = activatedOnOrBeforeDate;
		return (this);
	}
	public OrderSearchCriteriaBuilder setActivatedOnOrAfterDate(Date activatedOnOrAfterDate) {
		this.activatedOnOrAfterDate = activatedOnOrAfterDate;
		return (this);
	}
	public OrderSearchCriteriaBuilder setIsStopped(boolean isStopped) {
		this.isStopped = isStopped;
		return (this);
	}
	public OrderSearchCriteriaBuilder setAutoExpireOnOrBeforeDate(Date autoExpireOnOrBeforeDate) {
		this.autoExpireOnOrBeforeDate = autoExpireOnOrBeforeDate;
		return (this);
	}
	public OrderSearchCriteriaBuilder setCanceledOrExpiredOnOrBeforeDate(Date canceledOrExpiredOnOrBeforeDate) {
		this.canceledOrExpiredOnOrBeforeDate = canceledOrExpiredOnOrBeforeDate;
		return (this);
	}
    public OrderSearchCriteriaBuilder setAction(Order.Action action) {
        this.action = action;
        return (this);
    }
	public OrderSearchCriteriaBuilder setFulfillerStatus(Order.FulfillerStatus fulfillerStatus) {
		this.fulfillerStatus = fulfillerStatus;
		return (this);
	}
	public OrderSearchCriteriaBuilder setIncludeNullFulfillerStatus(Boolean includeNullFulfillerStatus) {
		this.includeNullFulfillerStatus = includeNullFulfillerStatus;
		return (this);
	}
	public OrderSearchCriteriaBuilder setExcludeCanceledAndExpired(boolean excludeCanceledAndExpired) {
		this.excludeCanceledAndExpired = excludeCanceledAndExpired;
		return (this);
	}
	public OrderSearchCriteriaBuilder setExcludeDiscontinueOrders(boolean excludeDiscontinueOrders) {
		this.excludeDiscontinueOrders = excludeDiscontinueOrders;
		return (this);
	}
	public OrderSearchCriteriaBuilder setIncludeVoided(boolean includeVoided) {
		this.includeVoided = includeVoided;
		return (this);
	}
	public OrderSearchCriteria build() {
		return new OrderSearchCriteria(patient, careSetting, concepts, orderTypes, accessionNumber, orderNumber, activatedOnOrBeforeDate,  
			activatedOnOrAfterDate, isStopped, autoExpireOnOrBeforeDate, canceledOrExpiredOnOrBeforeDate,
				action, fulfillerStatus, includeNullFulfillerStatus, excludeCanceledAndExpired, excludeDiscontinueOrders, includeVoided, visit);
	}
}
package org.openmrs.validator;
import java.util.List;
import org.openmrs.CareSetting;
import org.openmrs.Concept;
import org.openmrs.DosingInstructions;
import org.openmrs.DrugOrder;
import org.openmrs.Duration;
import org.openmrs.Order;
import org.openmrs.annotation.Handler;
import org.openmrs.api.OrderService;
import org.openmrs.api.context.Context;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.springframework.validation.Errors;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;
@Handler(supports = { DrugOrder.class }, order = 50)
public class DrugOrderValidator extends OrderValidator implements Validator {
	@Override
	public boolean supports(Class<?> c) {
		return DrugOrder.class.isAssignableFrom(c);
	}
	@Override
	public void validate(Object obj, Errors errors) {
		super.validate(obj, errors);
		DrugOrder order = (DrugOrder) obj;
		if (order == null) {
			errors.reject("error.general");
		} else {
			ValidationUtils.rejectIfEmpty(errors, "asNeeded", "error.null");
			if (order.getAction() != Order.Action.DISCONTINUE) {
				ValidationUtils.rejectIfEmpty(errors, "dosingType", "error.null");
			}
			if (order.getDrug() == null || order.getDrug().getConcept() == null) {
				ValidationUtils.rejectIfEmpty(errors, "concept", "error.null");
			}
			if (order.getConcept() != null && order.getDrug() != null && order.getDrug().getConcept() != null
			        && !order.getDrug().getConcept().equals(order.getConcept())) {
				errors.rejectValue("drug", "error.general");
				errors.rejectValue("concept", "error.concept");
			}
			if (order.getAction() != Order.Action.DISCONTINUE && order.getDosingType() != null) {
				DosingInstructions dosingInstructions = order.getDosingInstructionsInstance();
				dosingInstructions.validate(order, errors);
			}
			validateFieldsForOutpatientCareSettingType(order, errors);
			validatePairedFields(order, errors);
			validateUnitsAreAmongAllowedConcepts(errors, order);
            validateForRequireDrug(errors, order);
			ValidateUtil.validateFieldLengths(errors, obj.getClass(), "asNeededCondition", "brandName");
		}
	}
	private void validateForRequireDrug(Errors errors, DrugOrder order) {
		boolean requireDrug = Context.getAdministrationService().getGlobalPropertyValue(
				OpenmrsConstants.GLOBAL_PROPERTY_DRUG_ORDER_REQUIRE_DRUG, false);
		OrderService orderService = Context.getOrderService();
		if(requireDrug){
			if(order.getConcept() != null && OpenmrsUtil.nullSafeEquals(orderService.getNonCodedDrugConcept(), order.getConcept())){
				if(order.getDrug() == null && !order.isNonCodedDrug()){
					errors.rejectValue("drugNonCoded", "DrugOrder.error.drugNonCodedIsRequired");
				}
				else if(order.getDrug() != null){
					errors.rejectValue("concept", "DrugOrder.error.onlyOneOfDrugOrNonCodedShouldBeSet");
				}
			}else{
				if(order.getDrug() == null && !order.isNonCodedDrug()){
					errors.rejectValue("drug", "DrugOrder.error.drugIsRequired");
				}
				else if(order.getDrug() != null && order.isNonCodedDrug()){
					errors.rejectValue("concept", "DrugOrder.error.onlyOneOfDrugOrNonCodedShouldBeSet");
				}
			}
		}
	}
	private void validateFieldsForOutpatientCareSettingType(DrugOrder order, Errors errors) {
		if (order.getAction() != Order.Action.DISCONTINUE && order.getCareSetting() != null
		        && order.getCareSetting().getCareSettingType().equals(CareSetting.CareSettingType.OUTPATIENT)) {
			boolean requireQuantity = Context.getAdministrationService().getGlobalPropertyValue(
				OpenmrsConstants.GLOBAL_PROPERTY_DRUG_ORDER_REQUIRE_OUTPATIENT_QUANTITY, true);
			if (requireQuantity) {
				ValidationUtils.rejectIfEmpty(errors, "quantity", "DrugOrder.error.quantityIsNullForOutPatient");
				ValidationUtils.rejectIfEmpty(errors, "numRefills", "DrugOrder.error.numRefillsIsNullForOutPatient");
			}
		}
	}
	private void validatePairedFields(DrugOrder order, Errors errors) {
		if (order.getDose() != null) {
			ValidationUtils.rejectIfEmpty(errors, "doseUnits", "DrugOrder.error.doseUnitsRequiredWithDose");
		}
		if (order.getQuantity() != null) {
			ValidationUtils.rejectIfEmpty(errors, "quantityUnits", "DrugOrder.error.quantityUnitsRequiredWithQuantity");
		}
		if (order.getDuration() != null) {
			ValidationUtils.rejectIfEmpty(errors, "durationUnits", "DrugOrder.error.durationUnitsRequiredWithDuration");
		}
	}
	private void validateUnitsAreAmongAllowedConcepts(Errors errors, DrugOrder order) {
		OrderService orderService = Context.getOrderService();
		if (order.getDoseUnits() != null) {
			List<Concept> drugDosingUnits = orderService.getDrugDosingUnits();
			if (!drugDosingUnits.contains(order.getDoseUnits())) {
				errors.rejectValue("doseUnits", "DrugOrder.error.notAmongAllowedConcepts");
			}
		}
		if (order.getQuantityUnits() != null) {
			List<Concept> drugDispensingUnits = orderService.getDrugDispensingUnits();
			if (!drugDispensingUnits.contains(order.getQuantityUnits())) {
				errors.rejectValue("quantityUnits", "DrugOrder.error.notAmongAllowedConcepts");
			}
		}
		if (order.getDurationUnits() != null) {
			List<Concept> drugDurationUnits = orderService.getDurationUnits();
			if (!drugDurationUnits.contains(order.getDurationUnits())) {
				errors.rejectValue("durationUnits", "DrugOrder.error.notAmongAllowedConcepts");
			}
			if (Duration.getCode(order.getDurationUnits()) == null) {
				errors.rejectValue("durationUnits", "DrugOrder.error.durationUnitsNotMappedToSnomedCtDurationCode");
			}
		}
		if (order.getRoute() != null) {
			List<Concept> routes = orderService.getDrugRoutes();
			if (!routes.contains(order.getRoute())) {
				errors.rejectValue("route", "DrugOrder.error.routeNotAmongAllowedConcepts");
			}
		}
	}
}