/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import static org.apiguardian.api.API.Status.INTERNAL;
/**
 * Abstract base class for the {@link NodeBase node implementation} to avoid default interface methods to be overridable
 * in inheritors.
 *
 * @author Michael J. Simons
 * @since 2021.1.0
 */
@API(status = INTERNAL, since = "2021.1.0")
abstract class AbstractNode extends AbstractPropertyContainer implements Node {
	@NotNull
	@Override
	public final Condition hasLabels(String... labelsToQuery) {
		return HasLabelCondition.create(this.getSymbolicName()
						.orElseThrow(() -> new IllegalStateException("Cannot query a node without a symbolic name.")),
				labelsToQuery);
	}
	@NotNull
	@Override
	public final Condition hasLabels(LabelExpression labels) {
		return new HasLabelExpressionCondition(this.getSymbolicName()
			.orElseThrow(() -> new IllegalStateException("Cannot query a node without a symbolic name.")),
			labels);
	}
	@NotNull
	@Override
	public final Condition isEqualTo(Node otherNode) {
		return this.getRequiredSymbolicName().isEqualTo(otherNode.getRequiredSymbolicName());
	}
	@NotNull
	@Override
	public final Condition isNotEqualTo(Node otherNode) {
		return this.getRequiredSymbolicName().isNotEqualTo(otherNode.getRequiredSymbolicName());
	}
	@NotNull
	@Override
	public final Condition isNull() {
		return this.getRequiredSymbolicName().isNull();
	}
	@NotNull
	@Override
	public final Condition isNotNull() {
		return this.getRequiredSymbolicName().isNotNull();
	}
	@NotNull
	@Override
	public final SortItem descending() {
		return this.getRequiredSymbolicName().descending();
	}
	@NotNull
	@Override
	public final SortItem ascending() {
		return this.getRequiredSymbolicName().ascending();
	}
	@NotNull
	@Override
	public final AliasedExpression as(String alias) {
		return this.getRequiredSymbolicName().as(alias);
	}
	@NotNull
	@Override
	@SuppressWarnings("deprecation") // IDEA is stupid.
	public final FunctionInvocation internalId() {
		return Functions.id(this);
	}
	@NotNull
	@Override
	@SuppressWarnings("deprecation")
	public final FunctionInvocation labels() {
		return Functions.labels(this);
	}
	@NotNull
	@Override
	public final Relationship relationshipTo(Node other, String... types) {
		return new InternalRelationshipImpl(null, this, Relationship.Direction.LTR, null, other, types);
	}
	@NotNull
	@Override
	public final Relationship relationshipFrom(Node other, String... types) {
		return new InternalRelationshipImpl(null, this, Relationship.Direction.RTL, null, other, types);
	}
	@NotNull
	@Override
	public final Relationship relationshipBetween(Node other, String... types) {
		return new InternalRelationshipImpl(null, this, Relationship.Direction.UNI, null, other, types);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
/**
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/NodePattern.html">NodePattern</a>.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface Node extends PatternElement, PropertyContainer, ExposesProperties<Node>, ExposesRelationships<Relationship> {
	/**
	 * @return The labels associated with this {@link Node}
	 */
	@NotNull @Contract(pure = true)
	List<NodeLabel> getLabels();
	/**
	 * Creates a copy of this node with a new symbolic name.
	 *
	 * @param newSymbolicName the new symbolic name.
	 * @return The new node.
	 */
	@NotNull @Contract(pure = true)
	Node named(String newSymbolicName);
	/**
	 * Creates a copy of this node with a new symbolic name.
	 *
	 * @param newSymbolicName the new symbolic name.
	 * @return The new node.
	 */
	@NotNull @Contract(pure = true)
	Node named(SymbolicName newSymbolicName);
	/**
	 * A condition that checks for the presence of labels on a node.
	 *
	 * @param labelsToQuery A list of labels to query
	 * @return A condition that checks whether this node has all the labels to query
	 */
	@NotNull @Contract(pure = true)
	Condition hasLabels(String... labelsToQuery);
	/**
	 * A condition that checks for the presence of a label expression on a node
	 * @since 2024.3.0
	 */
	@NotNull @Contract(pure = true)
	Condition hasLabels(LabelExpression labels);
	/**
	 * Creates a new condition whether this node is equal to {@literal otherNode}.
	 *
	 * @param otherNode The node to compare this node to.
	 * @return A condition.
	 */
	@NotNull @Contract(pure = true)
	Condition isEqualTo(Node otherNode);
	/**
	 * Creates a new condition whether this node is not equal to {@literal otherNode}.
	 *
	 * @param otherNode The node to compare this node to.
	 * @return A condition.
	 */
	@NotNull @Contract(pure = true)
	Condition isNotEqualTo(Node otherNode);
	/**
	 * Creates a new condition based on this node whether it is null.
	 *
	 * @return A condition.
	 */
	@NotNull @Contract(pure = true)
	Condition isNull();
	/**
	 * Creates a new condition based on this node whether it is not null.
	 *
	 * @return A condition.
	 */
	@NotNull @Contract(pure = true)
	Condition isNotNull();
	/**
	 * Creates a new sort item of this node in descending order.
	 *
	 * @return A sort item.
	 */
	@NotNull @Contract(pure = true)
	SortItem descending();
	/**
	 * Creates a new sort item of this node in ascending order.
	 *
	 * @return A sort item.
	 */
	@NotNull @Contract(pure = true)
	SortItem ascending();
	/**
	 * Creates an alias for this node.
	 *
	 * @param alias The alias to use.
	 * @return The aliased expression.
	 */
	@NotNull @Contract(pure = true)
	AliasedExpression as(String alias);
	/**
	 * @return A new function invocation returning the internal id of this node.
	 * @deprecated Use {@link #elementId}
	 */
	@NotNull @Contract(pure = true)
	@Deprecated(since = "2022.6.0")
	@SuppressWarnings({ "DeprecatedIsStillUsed", "squid:S1133" }) // The deprecation warning on any client code calling this is actually the point.
	FunctionInvocation internalId();
	/**
	 * @return A new function invocation returning the element id of this node.
	 * @since 2022.6.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default FunctionInvocation elementId() {
		return Functions.elementId(this);
	}
	/**
	 * @return A new function invocation returning the labels of this node.
	 */
	@NotNull @Contract(pure = true)
	FunctionInvocation labels();
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.EnumSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.StatementBuilder.BuildableMatchAndUpdate;
import org.neo4j.cypherdsl.core.StatementBuilder.BuildableOngoingMergeAction;
import org.neo4j.cypherdsl.core.StatementBuilder.OngoingMatchAndUpdate;
import org.neo4j.cypherdsl.core.StatementBuilder.OngoingMerge;
import org.neo4j.cypherdsl.core.StatementBuilder.OngoingReadingWithWhere;
import org.neo4j.cypherdsl.core.StatementBuilder.OngoingReadingWithoutWhere;
import org.neo4j.cypherdsl.core.StatementBuilder.OngoingUpdate;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.internal.ProcedureName;
import org.neo4j.cypherdsl.core.internal.YieldItems;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * @author Michael J. Simons
 * @author Gerrit Meier
 * @author Romain Rossi
 * @since 1.0
 */
@API(status = INTERNAL, since = "2021.2.1")
class DefaultStatementBuilder implements StatementBuilder,
	OngoingUpdate, OngoingMerge, OngoingReadingWithWhere, OngoingReadingWithoutWhere, OngoingMatchAndUpdate,
	BuildableMatchAndUpdate,
	BuildableOngoingMergeAction, ExposesSubqueryCall.BuildableSubquery, StatementBuilder.VoidCall, StatementBuilder.Terminal {
	/**
	 * Current list of reading or update clauses to be generated.
	 */
	private final List<Visitable> currentSinglePartElements = new ArrayList<>();
	/**
	 * The latest ongoing match.
	 */
	private MatchBuilder currentOngoingMatch;
	/**
	 * The latest ongoing update to be build
	 */
	private DefaultStatementWithUpdateBuilder currentOngoingUpdate;
	/**
	 * A list of already build withs.
	 */
	private final List<MultiPartElement> multiPartElements = new ArrayList<>();
	/**
	 * Default constructor. Builder can be pre-loaded with visitables.
	 *
	 * @param visitables A set of visitables. {@literal NULL} values will be skipped.
	 */
	DefaultStatementBuilder(Visitable... visitables) {
		addVisitables(visitables);
	}
	/**
	 * A copy constructor
	 * @param source The source
	 * @param visitables A set of additional visitables. {@literal NULL} values will be skipped.
	 */
	DefaultStatementBuilder(DefaultStatementBuilder source, Visitable... visitables) {
		this.currentSinglePartElements.addAll(source.currentSinglePartElements);
		this.currentOngoingMatch = source.currentOngoingMatch;
		this.currentOngoingUpdate = source.currentOngoingUpdate;
		this.multiPartElements.addAll(source.multiPartElements);
		addVisitables(visitables);
	}
	private void addVisitables(Visitable[] visitables) {
		for (Visitable visitable : visitables) {
			if (visitable != null) {
				this.currentSinglePartElements.add(visitable);
			}
		}
	}
	@NotNull
	@Override
	public final OngoingReadingWithoutWhere match(boolean optional, PatternElement... pattern) {
		Assertions.notNull(pattern, "Patterns to match are required.");
		Assertions.notEmpty(pattern, "At least one pattern to match is required.");
		this.closeCurrentOngoingMatch();
		this.currentOngoingMatch = new MatchBuilder(optional);
		this.currentOngoingMatch.patternList.addAll(Arrays.asList(pattern));
		return this;
	}
	@NotNull
	@Override
	public final OngoingUpdate create(PatternElement... pattern) {
		return update(UpdateType.CREATE, pattern);
	}
	@NotNull
	@Override
	public final OngoingUpdate create(Collection<? extends PatternElement> pattern) {
		return create(pattern.toArray(new PatternElement[] {}));
	}
	@NotNull
	@Override
	public final OngoingMerge merge(PatternElement... pattern) {
		return update(UpdateType.MERGE, pattern);
	}
	@NotNull
	@Override
	public final OngoingMergeAction onCreate() {
		return ongoingOnAfterMerge(MergeAction.Type.ON_CREATE);
	}
	@NotNull
	@Override
	public final OngoingMergeAction onMatch() {
		return ongoingOnAfterMerge(MergeAction.Type.ON_MATCH);
	}
	private OngoingMergeAction ongoingOnAfterMerge(MergeAction.Type type) {
		Assertions.notNull(this.currentOngoingUpdate, "MERGE must have been invoked before defining an event.");
		Assertions.isTrue(this.currentOngoingUpdate.builder instanceof SupportsActionsOnTheUpdatingClause,
			"MERGE must have been invoked before defining an event.");
		return new OngoingMergeAction() {
			@Override
			@SuppressWarnings("deprecation")
			public @NotNull BuildableOngoingMergeAction set(Node node, String... labels) {
				return this.set(Operations.set(node, labels));
			}
			@Override
			@SuppressWarnings("deprecation")
			public @NotNull BuildableOngoingMergeAction set(Node node, Collection<String> labels) {
				return this.set(Operations.set(node, labels.toArray(new String[0])));
			}
			@NotNull
			@Override
			public BuildableOngoingMergeAction mutate(Expression target, Expression properties) {
				((SupportsActionsOnTheUpdatingClause) DefaultStatementBuilder.this.currentOngoingUpdate.builder)
					.on(type, UpdateType.MUTATE, target, properties);
				return DefaultStatementBuilder.this;
			}
			@NotNull
			@Override
			public BuildableOngoingMergeAction set(Expression... expressions) {
				((SupportsActionsOnTheUpdatingClause) DefaultStatementBuilder.this.currentOngoingUpdate.builder)
					.on(type, UpdateType.SET, expressions);
				return DefaultStatementBuilder.this;
			}
			@NotNull
			@Override
			public BuildableOngoingMergeAction set(Collection<? extends Expression> expressions) {
				return set(expressions.toArray(new Expression[] {}));
			}
		};
	}
	@Override
	public final OngoingUnwind unwind(Expression expression) {
		closeCurrentOngoingMatch();
		return new DefaultOngoingUnwind(expression);
	}
	private DefaultStatementBuilder update(UpdateType updateType, Object[] pattern) {
		Assertions.notNull(pattern, "Patterns to create are required.");
		Assertions.notEmpty(pattern, "At least one pattern to create is required.");
		this.closeCurrentOngoingMatch();
		this.closeCurrentOngoingUpdate();
		if (pattern.getClass().getComponentType() == PatternElement.class) {
			this.currentOngoingUpdate = new DefaultStatementWithUpdateBuilder(updateType, (PatternElement[]) pattern);
		} else if (Expression.class.isAssignableFrom(pattern.getClass().getComponentType())) {
			this.currentOngoingUpdate = new DefaultStatementWithUpdateBuilder(updateType, (Expression[]) pattern);
		}
		return this;
	}
	@NotNull
	@Override
	public final OngoingReadingAndReturn returning(Collection<? extends Expression> elements) {
		return returning(false, false, elements);
	}
	@NotNull
	@Override
	public final OngoingReadingAndReturn returningDistinct(Collection<? extends Expression> elements) {
		return returning(false, true, elements);
	}
	@NotNull
	@Override
	public StatementBuilder.OngoingReadingAndReturn returningRaw(Expression rawExpression) {
		return new DefaultStatementWithReturnBuilder(rawExpression);
	}
	private OngoingReadingAndReturn returning(boolean raw, boolean distinct, Collection<? extends Expression> elements) {
		DefaultStatementWithReturnBuilder ongoingMatchAndReturn = new DefaultStatementWithReturnBuilder(raw, distinct);
		ongoingMatchAndReturn.addExpressions(elements);
		return ongoingMatchAndReturn;
	}
	@NotNull
	@Override
	public final OrderableOngoingReadingAndWithWithoutWhere with(Collection<IdentifiableElement> elements) {
		return with(false, elements);
	}
	@NotNull
	@Override
	public OrderableOngoingReadingAndWithWithoutWhere withDistinct(Collection<IdentifiableElement> elements) {
		return with(true, elements);
	}
	private OrderableOngoingReadingAndWithWithoutWhere with(boolean distinct, Collection<IdentifiableElement> elements) {
		DefaultStatementWithWithBuilder ongoingMatchAndWith = new DefaultStatementWithWithBuilder(distinct);
		ongoingMatchAndWith.addElements(elements);
		return ongoingMatchAndWith;
	}
	@NotNull
	@Override
	public final OngoingUpdate delete(Expression... expressions) {
		return update(UpdateType.DELETE, expressions);
	}
	@NotNull
	@Override
	public final OngoingUpdate delete(Collection<? extends Expression> expressions) {
		return delete(expressions.toArray(new Expression[] {}));
	}
	@NotNull
	@Override
	public final OngoingUpdate detachDelete(Expression... expressions) {
		return update(UpdateType.DETACH_DELETE, expressions);
	}
	@NotNull
	@Override
	public final OngoingUpdate detachDelete(Collection<? extends Expression> expressions) {
		return detachDelete(expressions.toArray(new Expression[] {}));
	}
	@NotNull
	@Override
	public final BuildableMatchAndUpdate set(Expression... expressions) {
		DefaultStatementWithUpdateBuilder result = new DefaultStatementWithUpdateBuilder(UpdateType.SET, expressions);
		this.closeCurrentOngoingUpdate();
		return result;
	}
	@NotNull
	@Override
	public final BuildableMatchAndUpdate set(Collection<? extends Expression> expressions) {
		return set(expressions.toArray(new Expression[] {}));
	}
	@NotNull
	@Override
	@SuppressWarnings("deprecation")
	public final BuildableMatchAndUpdate set(Node named, String... labels) {
		this.closeCurrentOngoingUpdate();
		return new DefaultStatementWithUpdateBuilder(UpdateType.SET, Operations.set(named, labels));
	}
	@NotNull
	@Override
	public final BuildableMatchAndUpdate set(Node named, Collection<String> labels) {
		return set(named, labels.toArray(new String[] {}));
	}
	@NotNull
	@Override
	@SuppressWarnings("deprecation")
	public final BuildableMatchAndUpdate mutate(Expression target, Expression properties) {
		DefaultStatementWithUpdateBuilder result = new DefaultStatementWithUpdateBuilder(UpdateType.MUTATE, Operations.mutate(target, properties));
		this.closeCurrentOngoingUpdate();
		return result;
	}
	@NotNull
	@Override
	public final BuildableMatchAndUpdate remove(Property... properties) {
		this.closeCurrentOngoingUpdate();
		return new DefaultStatementWithUpdateBuilder(UpdateType.REMOVE, properties);
	}
	@NotNull
	@Override
	public final BuildableMatchAndUpdate remove(Collection<Property> properties) {
		return remove(properties.toArray(new Property[] {}));
	}
	@NotNull
	@Override
	@SuppressWarnings("deprecation")
	public final BuildableMatchAndUpdate remove(Node named, String... labels) {
		this.closeCurrentOngoingUpdate();
		return new DefaultStatementWithUpdateBuilder(UpdateType.REMOVE, Operations.remove(named, labels));
	}
	@NotNull
	@Override
	public final BuildableMatchAndUpdate remove(Node named, Collection<String> labels) {
		return remove(named, labels.toArray(new String[] {}));
	}
	@NotNull
	@Override
	public final OngoingReadingWithWhere where(Condition newCondition) {
		this.currentOngoingMatch.conditionBuilder.where(newCondition);
		return this;
	}
	@NotNull
	@Override
	public final OngoingReadingWithWhere and(Condition additionalCondition) {
		this.currentOngoingMatch.conditionBuilder.and(additionalCondition);
		return this;
	}
	@NotNull
	@Override
	public final OngoingReadingWithWhere or(Condition additionalCondition) {
		this.currentOngoingMatch.conditionBuilder.or(additionalCondition);
		return this;
	}
	@NotNull
	@Override
	public Statement build() {
		return buildImpl(null);
	}
	protected final Statement buildImpl(Clause returnOrFinish) {
		SinglePartQuery singlePartQuery = SinglePartQuery.create(
			buildListOfVisitables(false), returnOrFinish);
		if (multiPartElements.isEmpty()) {
			return singlePartQuery;
		} else {
			return MultiPartQuery.create(multiPartElements, singlePartQuery);
		}
	}
	protected final List<Visitable> buildListOfVisitables(boolean clearAfter) {
		List<Visitable> visitables = new ArrayList<>(this.currentSinglePartElements);
		if (this.currentOngoingMatch != null) {
			visitables.add(this.currentOngoingMatch.buildMatch());
		}
		if (this.currentOngoingUpdate != null) {
			visitables.add(this.currentOngoingUpdate.builder.build());
		}
		if (clearAfter) {
			this.currentOngoingMatch = null;
			this.currentOngoingUpdate = null;
			this.currentSinglePartElements.clear();
		}
		return visitables;
	}
	@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
	protected final DefaultStatementBuilder addWith(Optional<With> optionalWith) {
		optionalWith.ifPresent(with -> multiPartElements.add(new MultiPartElement(buildListOfVisitables(true), with)));
		return this;
	}
	protected final void addUpdatingClause(UpdatingClause updatingClause) {
		// Close current match
		closeCurrentOngoingMatch();
		this.currentSinglePartElements.add(updatingClause);
	}
	@NotNull
	@Override
	public BuildableSubquery call(Statement statement, IdentifiableElement... imports) {
		this.closeCurrentOngoingMatch();
		this.closeCurrentOngoingUpdate();
		this.currentSinglePartElements.add(Subquery.call(statement, imports));
		return this;
	}
	@NotNull
	@Override
	public BuildableSubquery callRawCypher(String rawCypher, Object... args) {
		this.closeCurrentOngoingMatch();
		this.closeCurrentOngoingUpdate();
		this.currentSinglePartElements.add(Subquery.raw(rawCypher, args));
		return this;
	}
	@NotNull
	@Override
	public BuildableSubquery callInTransactions(Statement statement, Integer rows, IdentifiableElement... imports) {
		this.closeCurrentOngoingMatch();
		this.closeCurrentOngoingUpdate();
		this.currentSinglePartElements.add(Subquery.call(statement, imports).inTransactionsOf(rows));
		return this;
	}
	private void closeCurrentOngoingMatch() {
		if (this.currentOngoingMatch == null) {
			return;
		}
		this.currentSinglePartElements.add(this.currentOngoingMatch.buildMatch());
		this.currentOngoingMatch = null;
	}
	private void closeCurrentOngoingUpdate() {
		if (this.currentOngoingUpdate == null) {
			return;
		}
		this.currentSinglePartElements.add(this.currentOngoingUpdate.builder.build());
		this.currentOngoingUpdate = null;
	}
	@NotNull
	@Override
	public final Condition asCondition() {
		if (this.currentOngoingMatch == null || !this.currentSinglePartElements.isEmpty()) {
			throw new IllegalArgumentException("Only simple MATCH statements can be used as existential subqueries.");
		}
		return ExistentialSubquery.exists(this.currentOngoingMatch.buildMatch());
	}
	@NotNull
	@Override
	public final OngoingReadingWithoutWhere usingIndex(Property... properties) {
		this.currentOngoingMatch.hints.add(Hint.useIndexFor(false, properties));
		return this;
	}
	@NotNull
	@Override
	public final OngoingReadingWithoutWhere usingIndexSeek(Property... properties) {
		this.currentOngoingMatch.hints.add(Hint.useIndexFor(true, properties));
		return this;
	}
	@NotNull
	@Override
	public final OngoingReadingWithoutWhere usingScan(Node node) {
		this.currentOngoingMatch.hints.add(Hint.useScanFor(node));
		return this;
	}
	@NotNull
	@Override
	public final OngoingReadingWithoutWhere usingJoinOn(SymbolicName... names) {
		this.currentOngoingMatch.hints.add(Hint.useJoinOn(names));
		return this;
	}
	@Override
	public @NotNull ForeachSourceStep foreach(SymbolicName variable) {
		this.closeCurrentOngoingMatch();
		this.closeCurrentOngoingUpdate();
		return new ForeachBuilder(variable);
	}
	@Override
	public @NotNull Terminal finish() {
		return new DefaultStatementWithFinishBuilder();
	}
	final class ForeachBuilder implements ForeachSourceStep, ForeachUpdateStep {
		private final SymbolicName variable;
		private Expression list;
		ForeachBuilder(SymbolicName variable) {
			this.variable = variable;
		}
		@Override
		public ForeachUpdateStep in(@NotNull Expression newVariableList) {
			this.list = Objects.requireNonNull(newVariableList);
			return this;
		}
		@Override
		public OngoingUpdate apply(UpdatingClause... updatingClauses) {
			if (Arrays.stream(updatingClauses).anyMatch(Foreach.class::isInstance)) {
				throw new IllegalArgumentException("FOREACH clauses may not be nested");
			}
			DefaultStatementBuilder.this.addUpdatingClause(new Foreach(this.variable, this.list, Arrays.asList(updatingClauses)));
			return DefaultStatementBuilder.this;
		}
	}
	abstract static class ReturnListWrapper {
		protected final List<Expression> returnList = new ArrayList<>();
		protected final void addElements(Collection<IdentifiableElement> elements) {
			Assertions.notNull(elements, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSIONS_REQUIRED));
			var filteredElements = elements.stream().filter(Objects::nonNull).map(IdentifiableElement::asExpression).toList();
			Assertions.isTrue(!filteredElements.isEmpty(), Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_AT_LEAST_ONE_EXPRESSION_REQUIRED));
			this.returnList.addAll(filteredElements);
		}
		protected final void addExpressions(Collection<? extends Expression> expressions) {
			Assertions.notNull(expressions, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSIONS_REQUIRED));
			Assertions.isTrue(!expressions.isEmpty() && expressions.stream().noneMatch(Objects::isNull), Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_AT_LEAST_ONE_EXPRESSION_REQUIRED));
			this.returnList.addAll(expressions);
		}
	}
	protected class DefaultStatementWithReturnBuilder extends ReturnListWrapper
		implements OngoingReadingAndReturn, TerminalOngoingOrderDefinition, OngoingMatchAndReturnWithOrder {
		protected final OrderBuilder orderBuilder = new OrderBuilder();
		protected boolean rawReturn;
		protected boolean distinct;
		protected DefaultStatementWithReturnBuilder(Expression rawReturnExpression) {
			this.distinct = false;
			this.rawReturn = true;
			this.returnList.add(rawReturnExpression);
		}
		protected DefaultStatementWithReturnBuilder(boolean rawReturn, boolean distinct) {
			this.distinct = distinct;
			this.rawReturn = rawReturn;
		}
		@Override
		public Collection<Expression> getIdentifiableExpressions() {
			return extractIdentifiablesFromReturnList(returnList);
		}
		@NotNull
		@Override
		public final OngoingMatchAndReturnWithOrder orderBy(SortItem... sortItem) {
			orderBuilder.orderBy(sortItem);
			return this;
		}
		@NotNull
		@Override
		public final OngoingMatchAndReturnWithOrder orderBy(Collection<SortItem> sortItem) {
			return orderBy(sortItem.toArray(new SortItem[] {}));
		}
		@NotNull
		@Override
		public final TerminalOngoingOrderDefinition orderBy(@NotNull Expression expression) {
			orderBuilder.orderBy(expression);
			return this;
		}
		@NotNull
		@Override
		public final TerminalOngoingOrderDefinition and(@NotNull Expression expression) {
			orderBuilder.and(expression);
			return this;
		}
		@NotNull
		@Override
		public final DefaultStatementWithReturnBuilder descending() {
			orderBuilder.descending();
			return this;
		}
		@NotNull
		@Override
		public final DefaultStatementWithReturnBuilder ascending() {
			orderBuilder.ascending();
			return this;
		}
		@NotNull
		@Override
		public final OngoingReadingAndReturn skip(Number number) {
			return skip(number == null ? null : new NumberLiteral(number));
		}
		@NotNull
		@Override
		public final OngoingReadingAndReturn skip(Expression expression) {
			orderBuilder.skip(expression);
			return this;
		}
		@NotNull
		@Override
		public final OngoingReadingAndReturn limit(Number number) {
			return limit(number == null ? null : new NumberLiteral(number));
		}
		@NotNull
		@Override
		public final OngoingReadingAndReturn limit(Expression expression) {
			orderBuilder.limit(expression);
			return this;
		}
		@NotNull
		@Override
		public ResultStatement build() {
			Return returning = Return.create(rawReturn, distinct, returnList, orderBuilder);
			return (ResultStatement) DefaultStatementBuilder.this.buildImpl(returning);
		}
	}
	protected final class DefaultStatementWithFinishBuilder implements Terminal {
		@Override
		public @NotNull Statement build() {
			return (ResultStatement) DefaultStatementBuilder.this.buildImpl(Finish.create());
		}
	}
	/**
	 * Helper class aggregating a couple of interface, collecting conditions and returned objects.
	 */
	protected final class DefaultStatementWithWithBuilder extends ReturnListWrapper
		implements OngoingOrderDefinition, OrderableOngoingReadingAndWithWithoutWhere,
		OrderableOngoingReadingAndWithWithWhere, OngoingReadingAndWithWithWhereAndOrder, OngoingReadingAndWithWithSkip {
		private final ConditionBuilder conditionBuilder = new ConditionBuilder();
		private final OrderBuilder orderBuilder = new OrderBuilder();
		private final boolean distinct;
		private DefaultStatementWithWithBuilder(boolean distinct) {
			this.distinct = distinct;
		}
		private Optional<With> buildWith() {
			if (returnList.isEmpty()) {
				return Optional.empty();
			}
			ExpressionList returnItems = new ExpressionList(returnList);
			Where where = conditionBuilder.buildCondition().map(Where::new).orElse(null);
			Optional<With> returnedWith = Optional
				.of(new With(distinct, returnItems, orderBuilder.buildOrder().orElse(null), orderBuilder.getSkip(),
					orderBuilder.getLimit(), where));
			this.returnList.clear();
			this.orderBuilder.reset();
			return returnedWith;
		}
		@Override
		public Collection<Expression> getIdentifiableExpressions() {
			return extractIdentifiablesFromReturnList(returnList);
		}
		@NotNull
		@Override
		public OngoingReadingAndReturn returning(Collection<? extends Expression> expressions) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.returning(expressions);
		}
		@NotNull
		@Override
		public OngoingReadingAndReturn returningDistinct(Collection<? extends Expression> expressions) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.returningDistinct(expressions);
		}
		@NotNull
		@Override
		public OngoingReadingAndReturn returningRaw(Expression rawExpression) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.returningRaw(rawExpression);
		}
		@NotNull
		@Override
		public OngoingUpdate delete(Expression... expressions) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.delete(expressions);
		}
		@NotNull
		@Override
		public OngoingUpdate delete(Collection<? extends Expression> expressions) {
			return delete(expressions.toArray(new Expression[] {}));
		}
		@NotNull
		@Override
		public OngoingUpdate detachDelete(Expression... expressions) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.detachDelete(expressions);
		}
		@NotNull
		@Override
		public OngoingUpdate detachDelete(Collection<? extends Expression> expressions) {
			return detachDelete(expressions.toArray(new Expression[] {}));
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate set(Expression... expressions) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.set(expressions);
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate set(Collection<? extends Expression> expressions) {
			return set(expressions.toArray(new Expression[] {}));
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate set(Node node, String... labels) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.set(node, labels);
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate set(Node node, Collection<String> labels) {
			return set(node, labels.toArray(new String[] {}));
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate mutate(Expression target, Expression properties) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.mutate(target, properties);
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate remove(Node node, String... labels) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.remove(node, labels);
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate remove(Node node, Collection<String> labels) {
			return remove(node, labels.toArray(new String[] {}));
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate remove(Property... properties) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.remove(properties);
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate remove(Collection<Property> properties) {
			return remove(properties.toArray(new Property[] {}));
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithoutWhere with(Collection<IdentifiableElement> elements) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.with(elements);
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithoutWhere withDistinct(Collection<IdentifiableElement> elements) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.withDistinct(elements);
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithWhere where(@NotNull Condition newCondition) {
			conditionBuilder.where(newCondition);
			return this;
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithWhere and(Condition additionalCondition) {
			conditionBuilder.and(additionalCondition);
			return this;
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithWhere or(Condition additionalCondition) {
			conditionBuilder.or(additionalCondition);
			return this;
		}
		@NotNull
		@Override
		public OngoingReadingWithoutWhere match(boolean optional, PatternElement... pattern) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.match(optional, pattern);
		}
		@NotNull
		@Override
		public OngoingUpdate create(PatternElement... pattern) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.create(pattern);
		}
		@NotNull
		@Override
		public OngoingUpdate create(Collection<? extends PatternElement> pattern) {
			return create(pattern.toArray(new PatternElement[]{}));
		}
		@NotNull
		@Override
		public OngoingMerge merge(PatternElement... pattern) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.merge(pattern);
		}
		@Override
		public OngoingUnwind unwind(Expression expression) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.unwind(expression);
		}
		@NotNull
		@Override
		public BuildableSubquery call(Statement statement, IdentifiableElement... imports) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.call(statement, imports);
		}
		@Override
		public @NotNull BuildableSubquery callRawCypher(String rawCypher, Object... args) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.callRawCypher(rawCypher, args);
		}
		@NotNull
		@Override
		public BuildableSubquery callInTransactions(Statement statement, Integer rows, IdentifiableElement... imports) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.callInTransactions(statement, rows, imports);
		}
		@NotNull
		@Override
		public InQueryCallBuilder call(String... namespaceAndProcedure) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.call(namespaceAndProcedure);
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithWhere orderBy(SortItem... sortItem) {
			orderBuilder.orderBy(sortItem);
			return this;
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithWhere orderBy(Collection<SortItem> sortItem) {
			return orderBy(sortItem.toArray(new SortItem[] {}));
		}
		@NotNull
		@Override
		public OngoingOrderDefinition orderBy(@NotNull Expression expression) {
			orderBuilder.orderBy(expression);
			return this;
		}
		@NotNull
		@Override
		public OngoingOrderDefinition and(@NotNull Expression expression) {
			orderBuilder.and(expression);
			return this;
		}
		@NotNull
		@Override
		public OngoingReadingAndWithWithWhereAndOrder descending() {
			orderBuilder.descending();
			return this;
		}
		@NotNull
		@Override
		public OngoingReadingAndWithWithWhereAndOrder ascending() {
			orderBuilder.ascending();
			return this;
		}
		@NotNull
		@Override
		public OngoingReadingAndWithWithSkip skip(Number number) {
			return skip(number == null ? null : new NumberLiteral(number));
		}
		@NotNull
		@Override
		public OngoingReadingAndWithWithSkip skip(Expression expression) {
			orderBuilder.skip(expression);
			return this;
		}
		@NotNull
		@Override
		public OngoingReadingAndWith limit(Number number) {
			return limit(number == null ? null : new NumberLiteral(number));
		}
		@NotNull
		@Override
		public OngoingReadingAndWith limit(Expression expression) {
			orderBuilder.limit(expression);
			return this;
		}
		@Override
		@NotNull
		public LoadCSVStatementBuilder.OngoingLoadCSV loadCSV(URI from, boolean withHeaders) {
			DefaultStatementBuilder this0 = DefaultStatementBuilder.this.addWith(buildWith());
			return new DefaultLoadCSVStatementBuilder.PrepareLoadCSVStatementImpl(from, withHeaders, this0);
		}
		@Override
		public @NotNull ForeachSourceStep foreach(SymbolicName variable) {
			return DefaultStatementBuilder.this
				.addWith(buildWith())
				.foreach(variable);
		}
		@Override
		public @NotNull StatementBuilder.Terminal finish() {
			return DefaultStatementBuilder.this;
		}
	}
	/**
	 * A private enum for distinguishing updating clauses.
	 */
	enum UpdateType {
		DELETE, DETACH_DELETE, SET, MUTATE, REMOVE,
		CREATE, MERGE
	}
	private static final EnumSet<UpdateType> MERGE_OR_CREATE = EnumSet.of(UpdateType.CREATE, UpdateType.MERGE);
	private static final EnumSet<UpdateType> SET = EnumSet.of(UpdateType.SET, UpdateType.MUTATE);
	private interface UpdatingClauseBuilder {
		UpdatingClause build();
	}
	interface SupportsActionsOnTheUpdatingClause {
		SupportsActionsOnTheUpdatingClause on(MergeAction.Type type, UpdateType updateType, Expression... expressions);
	}
	/**
	 * Creates a builder for an UPDATE clause. The vargs is list of pattern or expressions.
	 * In case {@code updateType} is of {@link UpdateType#MERGE} or {@link UpdateType#CREATE} they will
	 * be treated as pattern, otherwise as expression.
	 *
	 * @param updateType           The update type to create
	 * @param patternOrExpressions A list of pattern or expression
	 * @param <T>                  The type of {@code patternOrExpressions}
	 * @return Ongoing builder
	 */
	@SafeVarargs
	@SuppressWarnings("varargs") // WTH IDEA?
	private static <T extends Visitable> UpdatingClauseBuilder getUpdatingClauseBuilder(
		UpdateType updateType, T... patternOrExpressions
	) {
		boolean mergeOrCreate = MERGE_OR_CREATE.contains(updateType);
		String message = mergeOrCreate ?
			"At least one pattern is required." :
			"At least one modifying expressions is required.";
		Assertions.notNull(patternOrExpressions, message);
		Assertions.notEmpty(patternOrExpressions, message);
		if (mergeOrCreate) {
			final List<PatternElement> patternElements = Arrays.stream(patternOrExpressions)
				.map(PatternElement.class::cast).toList();
			if (updateType == UpdateType.CREATE) {
				return new AbstractUpdatingClauseBuilder.CreateBuilder(patternElements);
			} else {
				return new AbstractUpdatingClauseBuilder.MergeBuilder(patternElements);
			}
		} else {
			List<Expression> expressions = Arrays.stream(patternOrExpressions).map(Expression.class::cast)
				.toList();
			ExpressionList expressionList = new ExpressionList(
				SET.contains(updateType) ? prepareSetExpressions(updateType, expressions) : expressions);
			return switch (updateType) {
				case DETACH_DELETE -> () -> new Delete(expressionList, true);
				case DELETE -> () -> new Delete(expressionList, false);
				case SET, MUTATE -> () -> new Set(expressionList);
				case REMOVE -> () -> new Remove(expressionList);
				default -> throw new IllegalArgumentException("Unsupported update type " + updateType);
			};
		}
	}
	/**
	 * Utility method to prepare a list of expression to work with the set clause.
	 *
	 * @param possibleSetOperations A mixed list of expressions (property and list operations)
	 * @return A reified list of expressions that all target properties
	 */
	@SuppressWarnings("deprecation")
	private static List<Expression> prepareSetExpressions(UpdateType updateType,
		List<Expression> possibleSetOperations) {
		List<Expression> propertyOperations = new ArrayList<>();
		List<Expression> listOfExpressions = new ArrayList<>();
		for (Expression possibleSetOperation : possibleSetOperations) {
			if (possibleSetOperation instanceof Operation) {
				propertyOperations.add(possibleSetOperation);
			} else {
				listOfExpressions.add(possibleSetOperation);
			}
		}
		if (listOfExpressions.size() % 2 != 0) {
			throw new IllegalArgumentException("The list of expression to set must be even.");
		}
		if (updateType == UpdateType.SET) {
			for (int i = 0; i < listOfExpressions.size(); i += 2) {
				propertyOperations.add(Operations.set(listOfExpressions.get(i), listOfExpressions.get(i + 1)));
			}
		} else if (updateType == UpdateType.MUTATE) {
			if (!(listOfExpressions.isEmpty() || propertyOperations.isEmpty())) {
				throw new IllegalArgumentException(
					"A mutating SET must be build through a single operation or through a pair of expression, not both.");
			}
			if (listOfExpressions.isEmpty()) {
				for (Expression operation : propertyOperations) {
					if (((Operation) operation).getOperator() != Operator.MUTATE) {
						throw new IllegalArgumentException(
							"Only property operations based on the " + Operator.MUTATE + " are supported inside a mutating SET.");
					}
				}
			} else {
				for (int i = 0; i < listOfExpressions.size(); i += 2) {
					Expression rhs = listOfExpressions.get(i + 1);
					if (rhs instanceof Parameter) {
						propertyOperations.add(Operations.mutate(listOfExpressions.get(i), rhs));
					} else if (rhs instanceof MapExpression mapExpression) {
						propertyOperations.add(Operations.mutate(listOfExpressions.get(i), mapExpression));
					} else {
						throw new IllegalArgumentException(
							"A mutating SET operation can only be used with a named parameter or a map expression.");
					}
				}
			}
		}
		if (updateType != UpdateType.REMOVE && propertyOperations.stream().anyMatch(e -> e instanceof Operation op && op.getOperator() == Operator.REMOVE_LABEL)) {
			throw new IllegalArgumentException("REMOVE operations are not supported in a SET clause");
		}
		return propertyOperations;
	}
	@NotNull
	private static Collection<Expression> extractIdentifiablesFromReturnList(List<Expression> returnList) {
		return returnList.stream()
			.filter(IdentifiableElement.class::isInstance)
			.map(IdentifiableElement.class::cast)
			.map(IdentifiableElement::asExpression)
			.collect(Collectors.toSet());
	}
	/**
	 * Infrastructure for building {@link UpdatingClause updating clauses}
	 *
	 * @param <T> The type of the updating clause
	 */
	private abstract static class AbstractUpdatingClauseBuilder<T extends UpdatingClause>
		implements UpdatingClauseBuilder {
		protected final List<PatternElement> patternElements;
		AbstractUpdatingClauseBuilder(List<PatternElement> patternElements) {
			this.patternElements = patternElements;
		}
		abstract Function<Pattern, T> getUpdatingClauseProvider();
		@Override
		public T build() {
			return getUpdatingClauseProvider().apply(Pattern.of(patternElements));
		}
		static class CreateBuilder extends AbstractUpdatingClauseBuilder<Create> {
			CreateBuilder(List<PatternElement> patternElements) {
				super(patternElements);
			}
			@Override Function<Pattern, Create> getUpdatingClauseProvider() {
				return Create::new;
			}
		}
		static class MergeBuilder extends AbstractUpdatingClauseBuilder<Merge> implements
			SupportsActionsOnTheUpdatingClause {
			private final List<MergeAction> mergeActions = new ArrayList<>();
			MergeBuilder(List<PatternElement> patternElements) {
				super(patternElements);
			}
			@Override
			Function<Pattern, Merge> getUpdatingClauseProvider() {
				return pattern -> new Merge(pattern, mergeActions);
			}
			@Override
			public SupportsActionsOnTheUpdatingClause on(MergeAction.Type type, UpdateType updateType,
				Expression... expressions) {
				ExpressionList expressionList = new ExpressionList(
					prepareSetExpressions(updateType, Arrays.asList(expressions)));
				this.mergeActions.add(MergeAction.of(type, new Set(expressionList)));
				return this;
			}
		}
	}
	protected final class DefaultStatementWithUpdateBuilder implements BuildableMatchAndUpdate {
		final UpdatingClauseBuilder builder;
		private DefaultStatementWithUpdateBuilder(UpdateType updateType, PatternElement... pattern) {
			this.builder = getUpdatingClauseBuilder(updateType, pattern);
		}
		private DefaultStatementWithUpdateBuilder(UpdateType updateType, Expression... expressions) {
			this.builder = getUpdatingClauseBuilder(updateType, expressions);
		}
		@NotNull
		@Override
		public OngoingReadingAndReturn returning(Collection<? extends Expression> expressions) {
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			DefaultStatementWithReturnBuilder delegate = new DefaultStatementWithReturnBuilder(false, false);
			delegate.addExpressions(expressions);
			return delegate;
		}
		@NotNull
		@Override
		public OngoingReadingAndReturn returningDistinct(Collection<? extends Expression> elements) {
			DefaultStatementWithReturnBuilder delegate = (DefaultStatementWithReturnBuilder) returning(elements);
			delegate.distinct = true;
			return delegate;
		}
		@NotNull
		@Override
		public OngoingReadingAndReturn returningRaw(Expression rawExpression) {
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return new DefaultStatementWithReturnBuilder(rawExpression);
		}
		@NotNull
		@Override
		public OngoingUpdate delete(Expression... deletedExpressions) {
			return delete(false, deletedExpressions);
		}
		@NotNull
		@Override
		public OngoingUpdate delete(Collection<? extends Expression> deletedExpressions) {
			return delete(deletedExpressions.toArray(new Expression[] {}));
		}
		@NotNull
		@Override
		public OngoingUpdate detachDelete(Expression... deletedExpressions) {
			return delete(true, deletedExpressions);
		}
		@NotNull
		@Override
		public OngoingUpdate detachDelete(Collection<? extends Expression> deletedExpressions) {
			return detachDelete(deletedExpressions.toArray(new Expression[] {}));
		}
		@NotNull
		@Override
		public OngoingMerge merge(PatternElement... pattern) {
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return DefaultStatementBuilder.this.merge(pattern);
		}
		private OngoingUpdate delete(boolean nextDetach, Expression... deletedExpressions) {
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return DefaultStatementBuilder.this
				.update(nextDetach ? UpdateType.DETACH_DELETE : UpdateType.DELETE, deletedExpressions);
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate set(Expression... keyValuePairs) {
			DefaultStatementWithUpdateBuilder result = DefaultStatementBuilder.this.new DefaultStatementWithUpdateBuilder(UpdateType.SET, keyValuePairs);
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return result;
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate set(Collection<? extends Expression> keyValuePairs) {
			return set(keyValuePairs.toArray(new Expression[] {}));
		}
		@NotNull
		@Override
		@SuppressWarnings("deprecation")
		public BuildableMatchAndUpdate set(Node node, String... labels) {
			DefaultStatementWithUpdateBuilder result = DefaultStatementBuilder.this.new DefaultStatementWithUpdateBuilder(
				UpdateType.SET, Operations.set(node, labels));
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return result;
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate set(Node node, Collection<String> labels) {
			return set(node, labels.toArray(new String[] {}));
		}
		@NotNull
		@Override
		@SuppressWarnings("deprecation")
		public BuildableMatchAndUpdate mutate(Expression target, Expression properties) {
			DefaultStatementWithUpdateBuilder result = DefaultStatementBuilder.this.new DefaultStatementWithUpdateBuilder(
				UpdateType.MUTATE, Operations.mutate(target, properties));
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return result;
		}
		@NotNull
		@Override
		@SuppressWarnings("deprecation")
		public BuildableMatchAndUpdate remove(Node node, String... labels) {
			DefaultStatementWithUpdateBuilder result = DefaultStatementBuilder.this.new DefaultStatementWithUpdateBuilder(UpdateType.REMOVE,
				Operations.set(node, labels));
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return result;
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate remove(Node node, Collection<String> labels) {
			return remove(node, labels.toArray(new String[] {}));
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate remove(Property... properties) {
			DefaultStatementWithUpdateBuilder result = DefaultStatementBuilder.this.new DefaultStatementWithUpdateBuilder(UpdateType.REMOVE, properties);
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return result;
		}
		@NotNull
		@Override
		public BuildableMatchAndUpdate remove(Collection<Property> properties) {
			return remove(properties.toArray(new Property[] {}));
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithoutWhere with(Collection<IdentifiableElement> returnedExpressions) {
			return this.with(false, returnedExpressions);
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithoutWhere withDistinct(Collection<IdentifiableElement> elements) {
			return this.with(true, elements);
		}
		@NotNull
		@Override
		public OngoingUpdate create(PatternElement... pattern) {
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return DefaultStatementBuilder.this.create(pattern);
		}
		@NotNull
		@Override
		public OngoingUpdate create(Collection<? extends PatternElement> pattern) {
			return create(pattern.toArray(new PatternElement[] {}));
		}
		private OrderableOngoingReadingAndWithWithoutWhere with(boolean distinct, Collection<IdentifiableElement> elements) {
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return DefaultStatementBuilder.this.with(distinct, elements);
		}
		@NotNull
		@Override
		public Statement build() {
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return DefaultStatementBuilder.this.buildImpl(null);
		}
		@Override
		public @NotNull ForeachSourceStep foreach(SymbolicName variable) {
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return DefaultStatementBuilder.this.foreach(variable);
		}
		@Override
		public @NotNull StatementBuilder.Terminal finish() {
			DefaultStatementBuilder.this.addUpdatingClause(builder.build());
			return new DefaultStatementWithFinishBuilder();
		}
	}
	// Static builder and support classes
	static final class MatchBuilder {
		private final List<PatternElement> patternList = new ArrayList<>();
		private final List<Hint> hints = new ArrayList<>();
		private final ConditionBuilder conditionBuilder = new ConditionBuilder();
		private final boolean optional;
		MatchBuilder(boolean optional) {
			this.optional = optional;
		}
		Match buildMatch() {
			return (Match) Clauses.match(optional, this.patternList, Where.from(conditionBuilder.buildCondition().orElse(null)), hints);
		}
	}
	final class DefaultOngoingUnwind implements OngoingUnwind {
		private final Expression expressionToUnwind;
		DefaultOngoingUnwind(Expression expressionToUnwind) {
			this.expressionToUnwind = expressionToUnwind;
		}
		@NotNull
		@Override
		public OngoingReading as(@NotNull String variable) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(new Unwind(expressionToUnwind, variable));
			return DefaultStatementBuilder.this;
		}
	}
	@NotNull
	@Override
	public InQueryCallBuilder call(String... namespaceAndProcedure) {
		Assertions.notEmpty(namespaceAndProcedure, "The procedure namespace and name must not be null or empty.");
		closeCurrentOngoingMatch();
		return new InQueryCallBuilder(ProcedureName.from(namespaceAndProcedure));
	}
	abstract static class AbstractCallBuilder {
		protected final ProcedureName procedureName;
		protected Expression[] arguments;
		protected final DefaultStatementBuilder.ConditionBuilder conditionBuilder = new DefaultStatementBuilder.ConditionBuilder();
		AbstractCallBuilder(ProcedureName procedureName) {
			this(procedureName, null);
		}
		AbstractCallBuilder(ProcedureName procedureName, Expression[] arguments) {
			this.procedureName = procedureName;
			this.arguments = arguments;
		}
		Arguments createArgumentList() {
			Arguments argumentsList = null;
			if (arguments != null && arguments.length > 0) {
				argumentsList = new Arguments(arguments);
			}
			return argumentsList;
		}
	}
	static final class StandaloneCallBuilder extends AbstractCallBuilder implements
		OngoingStandaloneCallWithoutArguments,
		OngoingStandaloneCallWithArguments {
		StandaloneCallBuilder(ProcedureName procedureName) {
			super(procedureName);
		}
		@NotNull
		@Override
		public StandaloneCallBuilder withArgs(Expression... arguments) {
			super.arguments = arguments;
			return this;
		}
		@NotNull
		public OngoingStandaloneCallWithReturnFields yield(Asterisk asterisk) {
			return new YieldingStandaloneCallBuilder(procedureName, arguments, asterisk);
		}
		@NotNull
		@Override
		public DefaultStatementBuilder.YieldingStandaloneCallBuilder yield(SymbolicName... resultFields) {
			return new YieldingStandaloneCallBuilder(procedureName, arguments, resultFields);
		}
		@NotNull
		@Override
		public DefaultStatementBuilder.YieldingStandaloneCallBuilder yield(AliasedExpression... aliasedResultFields) {
			return new YieldingStandaloneCallBuilder(procedureName,  arguments, aliasedResultFields);
		}
		@NotNull
		@Override
		public Expression asFunction(boolean distinct) {
			if (super.arguments == null || super.arguments.length == 0) {
				return FunctionInvocation.create(procedureName::getQualifiedName);
			}
			if (distinct) {
				return FunctionInvocation.createDistinct(procedureName::getQualifiedName, super.arguments);
			} else {
				return FunctionInvocation.create(procedureName::getQualifiedName, super.arguments);
			}
		}
		@Override
		public VoidCall withoutResults() {
			return new DefaultStatementBuilder(this.build());
		}
		@NotNull
		@Override
		public ProcedureCall build() {
			return ProcedureCallImpl.create(procedureName, createArgumentList(), null,
				conditionBuilder.buildCondition().map(Where::new).orElse(null));
		}
	}
	static final class YieldingStandaloneCallBuilder extends AbstractCallBuilder
		implements ExposesWhere<StatementBuilder.OngoingReadingWithWhere>, ExposesReturning, ExposesFinish, OngoingStandaloneCallWithReturnFields {
		private final YieldItems yieldItems;
		private DefaultStatementBuilder delegate;
		YieldingStandaloneCallBuilder(ProcedureName procedureName, Expression[] arguments, SymbolicName... resultFields) {
			super(procedureName, arguments);
			this.yieldItems = YieldItems.yieldAllOf(resultFields);
		}
		YieldingStandaloneCallBuilder(ProcedureName procedureName, Expression[] arguments, Asterisk asterisk) {
			super(procedureName, arguments);
			this.yieldItems = YieldItems.yieldAllOf(asterisk);
		}
		YieldingStandaloneCallBuilder(ProcedureName procedureName, Expression[] arguments, AliasedExpression... aliasedResultFields) {
			super(procedureName, arguments);
			this.yieldItems = YieldItems.yieldAllOf(aliasedResultFields);
		}
		@NotNull
		@Override
		public StatementBuilder.OngoingReadingAndReturn returning(Collection<? extends Expression> expressions) {
			return new DefaultStatementBuilder(this.buildCall()).returning(expressions);
		}
		@NotNull
		@Override
		public StatementBuilder.OngoingReadingAndReturn returningDistinct(Collection<? extends Expression> expressions) {
			return new DefaultStatementBuilder(this.buildCall()).returningDistinct(expressions);
		}
		@NotNull
		@Override
		public StatementBuilder.OngoingReadingAndReturn returningRaw(Expression rawExpression) {
			return new DefaultStatementBuilder(this.buildCall()).returningRaw(rawExpression);
		}
		@NotNull
		@Override
		public StatementBuilder.OngoingReadingWithWhere where(Condition newCondition) {
			conditionBuilder.where(newCondition);
			return new DefaultStatementBuilder(this.buildCall());
		}
		@NotNull
		@Override
		public StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(Collection<IdentifiableElement> elements) {
			return new DefaultStatementBuilder(this.buildCall()).with(elements);
		}
		@NotNull
		@Override
		public StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere withDistinct(Collection<IdentifiableElement> elements) {
			return new DefaultStatementBuilder(this.buildCall()).withDistinct(elements);
		}
		@NotNull
		@Override
		public BuildableSubquery call(Statement statement, IdentifiableElement... imports) {
			return new DefaultStatementBuilder(this.buildCall()).call(statement, imports);
		}
		@Override
		public @NotNull BuildableSubquery callRawCypher(String rawCypher, Object... args) {
			return new DefaultStatementBuilder(this.buildCall()).callRawCypher(rawCypher, args);
		}
		@NotNull
		@Override
		public BuildableSubquery callInTransactions(Statement statement, Integer rows, IdentifiableElement... imports) {
			return new DefaultStatementBuilder(this.buildCall()).callInTransactions(statement, rows, imports);
		}
		@NotNull
		@Override
		public Statement build() {
			if (this.delegate != null) {
				return this.delegate.build();
			}
			return ProcedureCallImpl.create(procedureName, createArgumentList(), yieldItems,
				conditionBuilder.buildCondition().map(Where::new).orElse(null));
		}
		Statement buildCall() {
			return build();
		}
		@NotNull
		@Override
		public  StatementBuilder.OngoingReadingWithoutWhere match(boolean optional, PatternElement... pattern) {
			return new DefaultStatementBuilder(this.buildCall()).match(optional, pattern);
		}
		@Override
		public ExposesAndThen<OngoingStandaloneCallWithReturnFields, Statement> andThen(Statement statement) {
			if (this.delegate == null) {
				this.delegate = new DefaultStatementBuilder(this.buildCall());
			}
			this.delegate.currentSinglePartElements.add(statement);
			return this;
		}
		@Override
		public @NotNull StatementBuilder.Terminal finish() {
			return new DefaultStatementBuilder(this.buildCall());
		}
	}
	final class InQueryCallBuilder extends AbstractCallBuilder implements
		OngoingInQueryCallWithoutArguments,
		OngoingInQueryCallWithArguments,
		OngoingInQueryCallWithReturnFields {
		private YieldItems yieldItems;
		InQueryCallBuilder(ProcedureName procedureName) {
			super(procedureName);
		}
		Statement buildCall() {
			return ProcedureCallImpl.create(procedureName, createArgumentList(), yieldItems,
				conditionBuilder.buildCondition().map(Where::new).orElse(null));
		}
		@NotNull
		@Override
		public InQueryCallBuilder withArgs(Expression... arguments) {
			super.arguments = arguments;
			return this;
		}
		@NotNull
		@Override
		public InQueryCallBuilder yield(SymbolicName... resultFields) {
			this.yieldItems = YieldItems.yieldAllOf(resultFields);
			return this;
		}
		@NotNull
		@Override
		public InQueryCallBuilder yield(AliasedExpression... aliasedResultFields) {
			this.yieldItems = YieldItems.yieldAllOf(aliasedResultFields);
			return this;
		}
		@NotNull
		@Override
		public OngoingReadingWithWhere where(Condition newCondition) {
			conditionBuilder.where(newCondition);
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this;
		}
		@NotNull
		@Override
		public OngoingReadingAndReturn returning(Collection<? extends Expression> expressions) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this.returning(expressions);
		}
		@NotNull
		@Override
		public OngoingReadingAndReturn returningDistinct(Collection<? extends Expression> expressions) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this.returningDistinct(expressions);
		}
		@NotNull
		@Override
		public OngoingReadingAndReturn returningRaw(Expression rawExpression) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this.returningRaw(rawExpression);
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithoutWhere with(Collection<IdentifiableElement> elements) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this.with(elements);
		}
		@NotNull
		@Override
		public OrderableOngoingReadingAndWithWithoutWhere withDistinct(Collection<IdentifiableElement> elements) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this.withDistinct(elements);
		}
		@NotNull
		@Override
		public BuildableSubquery call(Statement statement, IdentifiableElement... imports) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this.call(statement, imports);
		}
		@Override
		public @NotNull BuildableSubquery callRawCypher(String rawCypher, Object... args) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this.callRawCypher(rawCypher, args);
		}
		@NotNull
		@Override
		public BuildableSubquery callInTransactions(Statement statement, Integer rows, IdentifiableElement... imports) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this.callInTransactions(statement, rows, imports);
		}
		@NotNull
		@Override
		public
		StatementBuilder.OngoingReadingWithoutWhere match(boolean optional, PatternElement... pattern) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this.match(optional, pattern);
		}
		@Override
		public VoidCall withoutResults() {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this;
		}
		@Override
		public @NotNull ForeachSourceStep foreach(SymbolicName variable) {
			DefaultStatementBuilder.this.currentSinglePartElements.add(this.buildCall());
			return DefaultStatementBuilder.this.foreach(variable);
		}
		@Override
		public @NotNull StatementBuilder.Terminal finish() {
			return DefaultStatementBuilder.this;
		}
	}
	static final class ConditionBuilder {
		private Condition condition;
		void where(Condition newCondition) {
			Assertions.notNull(newCondition, "The new condition must not be null.");
			this.condition = newCondition;
		}
		void and(Condition additionalCondition) {
			this.condition = this.condition.and(additionalCondition);
		}
		void or(Condition additionalCondition) {
			this.condition = this.condition.or(additionalCondition);
		}
		private boolean hasCondition() {
			return this.condition != null && (!(this.condition instanceof CompoundCondition compoundCondition)
					|| compoundCondition.hasConditions());
		}
		Optional<Condition> buildCondition() {
			return hasCondition() ? Optional.of(this.condition) : Optional.empty();
		}
	}
	static final class OrderBuilder {
		final List<SortItem> sortItemList = new ArrayList<>();
		SortItem lastSortItem;
		Skip skip;
		Limit limit;
		void reset() {
			this.sortItemList.clear();
			this.lastSortItem = null;
			this.skip = null;
			this.limit = null;
		}
		void orderBy(SortItem... sortItem) {
			this.sortItemList.addAll(Arrays.asList(sortItem));
		}
		void orderBy(Collection<SortItem> sortItems) {
			if (sortItems != null) {
				this.sortItemList.addAll(sortItems);
			}
		}
		void orderBy(Expression expression) {
			this.lastSortItem = Cypher.sort(expression);
		}
		void and(Expression expression) {
			orderBy(expression);
		}
		void descending() {
			this.sortItemList.add(this.lastSortItem.descending());
			this.lastSortItem = null;
		}
		void ascending() {
			this.sortItemList.add(this.lastSortItem.ascending());
			this.lastSortItem = null;
		}
		void skip(Expression expression) {
			if (expression != null) {
				skip = Skip.create(expression);
			}
		}
		void limit(Expression expression) {
			if (expression != null) {
				limit = Limit.create(expression);
			}
		}
		Optional<Order> buildOrder() {
			if (lastSortItem != null) {
				sortItemList.add(lastSortItem);
			}
			Optional<Order> result = sortItemList.isEmpty() ? Optional.empty() : Optional.of(new Order(sortItemList));
			sortItemList.clear();
			lastSortItem = null;
			return result;
		}
		Skip getSkip() {
			return skip;
		}
		Limit getLimit() {
			return limit;
		}
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * An expression can be used in many places, i.e. in return statements, pattern elements etc.
 *
 * @author Michael J. Simons
 * @author Aakash Sorathiya
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface Expression extends Visitable, PropertyAccessor {
	/**
	 * Creates a condition that checks whether this {@code expression} includes all elements of {@code rhs}.
	 *
	 * @param rhs The other collection to compare to, must evaluate into a list during runtime.
	 * @return A new condition
	 * @since 2022.7.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition includesAll(Expression rhs) {
		return Conditions.includesAll(this, rhs);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} includes any element of {@code rhs}.
	 *
	 * @param rhs The other collection to compare to, must evaluate into a list during runtime.
	 * @return A new condition
	 * @since 2022.7.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition includesAny(Expression rhs) {
		return Conditions.includesAny(this, rhs);
	}
	/**
	 * Creates an expression with an alias. This expression does not track which or how many aliases have been created.
	 *
	 * @param alias The alias to use
	 * @return An aliased expression.
	 */
	@NotNull @Contract(pure = true)
	default AliasedExpression as(String alias) {
		Assertions.hasText(alias, "The alias may not be null or empty.");
		return new AliasedExpression(this, alias);
	}
	/**
	 * This creates a {@literal size(e)} expression from this expression. The Cypher output will semantically only be valid
	 * when this refers to a list
	 * (see <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size">size(list)</a>)
	 * or when the expression is a string
	 * (see <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-string">size() applied to string</a>).
	 * <p>
	 * Any other expression will produce Cypher that is either deprecated in Neo4j &ge; 4.4 or not supported at all.
	 *
	 * @return The size of this expression (Either the number of items in a list or the number of characters in a string expression).
	 * @since 2022.1.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Expression size() {
		return Functions.size(this);
	}
	/**
	 * Takes the {@link #size()} expresssions and compares it for equality with the parameter {@code expectedSize}. The
	 * same restrictions as with {@link #size()} apply.
	 * @param expectedSize The expected size
	 * @return A condition
	 * @see #size()
	 * @since 2022.1.0
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition hasSize(Expression expectedSize) {
		return Functions.size(this).isEqualTo(expectedSize);
	}
	/**
	 * Reuse an existing symbolic name to alias this expression
	 *
	 * @param alias A symbolic name
	 * @return An aliased expression.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	default AliasedExpression as(SymbolicName alias) {
		Assertions.notNull(alias, "The alias may not be null.");
		return as(alias.getValue());
	}
	/**
	 * Transform this expression into a condition.
	 *
	 * @return this expression as a condition. Will return the same instance if it is already a condition.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	default Condition asCondition() {
		return this instanceof Condition condition ? condition : new ExpressionCondition(this);
	}
	/**
	 * Creates a {@code lhs = rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isEqualTo(Expression rhs) {
		return Conditions.isEqualTo(this, rhs);
	}
	/**
	 * An alias for {@link #isEqualTo(Expression)}.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	default Condition eq(Expression rhs) {
		return isEqualTo(rhs);
	}
	/**
	 * Creates a {@code lhs <> rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNotEqualTo(Expression rhs) {
		return Conditions.isNotEqualTo(this, rhs);
	}
	/**
	 * An alias for {@link #isNotEqualTo(Expression)}.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	default Condition ne(Expression rhs) {
		return isNotEqualTo(rhs);
	}
	/**
	 * Creates a {@code lhs < rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition lt(Expression rhs) {
		return Conditions.lt(this, rhs);
	}
	/**
	 * Creates a {@code lhs <= rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition lte(Expression rhs) {
		return Conditions.lte(this, rhs);
	}
	/**
	 * Creates a {@code lhs > rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition gt(Expression rhs) {
		return Conditions.gt(this, rhs);
	}
	/**
	 * Creates a {@code lhs >= rhs} condition.
	 *
	 * @param rhs The right hand side of the condition
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition gte(Expression rhs) {
		return Conditions.gte(this, rhs);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} is {@literal true}.
	 *
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isTrue() {
		return Conditions.isEqualTo(this, Cypher.literalTrue());
	}
	/**
	 * Creates a condition that checks whether this {@code expression} is {@literal false}.
	 *
	 * @return A new condition
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isFalse() {
		return Conditions.isEqualTo(this, Cypher.literalFalse());
	}
	/**
	 * Creates a condition that checks whether this {@code expression} matches that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition matches(Expression expression) {
		return Conditions.matches(this, expression);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} matches the given {@code pattern}.
	 *
	 * @param pattern The pattern to match
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition matches(String pattern) {
		return Conditions.matches(this, Cypher.literalOf(pattern));
	}
	/**
	 * Creates a condition that checks whether this {@code expression} starts with that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition startsWith(Expression expression) {
		return Conditions.startsWith(this, expression);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} contains that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition contains(Expression expression) {
		return Conditions.contains(this, expression);
	}
	/**
	 * Creates a condition that checks whether this {@code expression} ends with that {@code expression}.
	 *
	 * @param expression The expression to match against. Must evaluate into a string during runtime.
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition endsWith(Expression expression) {
		return Conditions.endsWith(this, expression);
	}
	/**
	 * Creates an expression concatenating two string or list expressions.
	 *
	 * @param expression The expression to concat to this expression.
	 * @return A new expression.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation concat(Expression expression) {
		return Operations.concat(this, expression);
	}
	/**
	 * Creates a {@code +} operation of this (the augend) and the {@code addend}.
	 *
	 * @param addend The addend
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation add(Expression addend) {
		return Operations.add(this, addend);
	}
	/**
	 * Creates a {@code -} operation of this (the minuend) and the {@code subtrahend}.
	 *
	 * @param subtrahend The subtrahend
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation subtract(Expression subtrahend) {
		return Operations.subtract(this, subtrahend);
	}
	/**
	 * Creates a {@code *} operation of this (the multiplier) and the {@code multiplicand}.
	 *
	 * @param multiplicand The multiplicand
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation multiply(Expression multiplicand) {
		return Operations.multiply(this, multiplicand);
	}
	/**
	 * Creates a {@code /} operation of this (the divisor) and the {@code dividend}.
	 *
	 * @param dividend The dividend
	 * @return A new operation.
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation divide(Expression dividend) {
		return Operations.divide(this, dividend);
	}
	/**
	 * Returns the remainder of this value and the {@code dividend}.
	 *
	 * @param dividend The dividend
	 * @return A new operation.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation remainder(Expression dividend) {
		return Operations.remainder(this, dividend);
	}
	/**
	 * Returns the power of n of this value.
	 *
	 * @param n power to raise this {@code Expression} to.
	 * @return A new operation.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation pow(Expression n) {
		return Operations.pow(this, n);
	}
	/**
	 * Creates a {@code IS NULL} operation for this {@code expression}.
	 * The expression does not track the condition created here.
	 *
	 * @return A condition based on this expression that evaluates to true when this expression is null.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNull() {
		return Conditions.isNull(this);
	}
	/**
	 * Creates a {@code IS NOT NULL} operation for this {@code expression}.
	 * The expression does not track the condition created here.
	 *
	 * @return A condition based on this expression that evaluates to true when this expression is not null.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNotNull() {
		return Conditions.isNotNull(this);
	}
	/**
	 * Creates a {@code IN} operation for this expression and that {@code expression}.
	 * The expression does not track the condition created here.
	 *
	 * @param haystack The expression to search for this expression
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	default Condition in(Expression haystack) {
		return Comparison.create(this, Operator.IN, haystack);
	}
	/**
	 * Creates a condition that evaluates to true if this expression is empty.
	 *
	 * @return A new condition.
	 */
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isEmpty() {
		return Functions.size(this).isEqualTo(Cypher.literalOf(0L));
	}
	/**
	 * The property does not track the sort items created here.
	 *
	 * @return A sort item for this property in descending order
	 */
	@NotNull @Contract(pure = true)
	default SortItem descending() {
		return SortItem.create(this, SortItem.Direction.DESC);
	}
	/**
	 * The property does not track the sort items created here.
	 *
	 * @return A sort item for this property in ascending order
	 */
	@NotNull @Contract(pure = true)
	default SortItem ascending() {
		return SortItem.create(this, SortItem.Direction.ASC);
	}
	/**
	 * Creates a new sort item with the given direction.
	 *
	 * @param direction The direction to sort
	 * @return A new sort item.
	 * @since 2021.4.1
	 */
	@NotNull @Contract(pure = true)
	default SortItem sorted(SortItem.Direction direction) {
		return SortItem.create(this, direction);
	}
	@Override @NotNull
	default Property property(String... names) {
		return InternalPropertyImpl.create(this, names);
	}
	/**
	 * Creates a new {@link Property} associated with this property container. This property can be used as a lookup in
	 * other expressions. It does not add a value to the property.
	 * <p>
	 * The new {@link Property} object is a dynamic lookup, based on the {@code expression} passed to this method. The
	 * expression can be example another property, a function result or a Cypher parameter. A property defined in such a way will
	 * render as {@code p[expression]}.
	 * <p>
	 * Note: The property container does not track property creation and there is no possibility to enumerate all
	 * properties that have been created for this property container.
	 *
	 * @param lookup the expression that is evaluated to lookup this property.
	 * @return a new {@link Property} associated with this named container
	 * @since 2024.1.0
	 */
	@Override @NotNull
	default Property property(@NotNull Expression lookup) {
		return InternalPropertyImpl.create(this, lookup);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.internal;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.Aliased;
import org.neo4j.cypherdsl.core.AliasedExpression;
import org.neo4j.cypherdsl.core.Asterisk;
import org.neo4j.cypherdsl.core.Cypher;
import org.neo4j.cypherdsl.core.ExistentialSubquery;
import org.neo4j.cypherdsl.core.Expression;
import org.neo4j.cypherdsl.core.Foreach;
import org.neo4j.cypherdsl.core.FunctionInvocation;
import org.neo4j.cypherdsl.core.IdentifiableElement;
import org.neo4j.cypherdsl.core.MapProjection;
import org.neo4j.cypherdsl.core.Named;
import org.neo4j.cypherdsl.core.Order;
import org.neo4j.cypherdsl.core.PatternComprehension;
import org.neo4j.cypherdsl.core.PatternElement;
import org.neo4j.cypherdsl.core.ProcedureCall;
import org.neo4j.cypherdsl.core.Property;
import org.neo4j.cypherdsl.core.Return;
import org.neo4j.cypherdsl.core.Statement;
import org.neo4j.cypherdsl.core.Subquery;
import org.neo4j.cypherdsl.core.SubqueryExpression;
import org.neo4j.cypherdsl.core.SymbolicName;
import org.neo4j.cypherdsl.core.UnionPart;
import org.neo4j.cypherdsl.core.With;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * A strategy to keep track of {@link Named named variables} inside a scope.
 *
 * @author Michael J. Simons
 * @soundtrack Knorkator - The Schlechtst Of Knorkator
 * @since 2021.3.2
 */
@API(status = INTERNAL, since = "2021.3.2")
public final class ScopingStrategy {
	/**
	 * @return an empty scoping strategy, for internal use only.
	 */
	public static ScopingStrategy create() {
		return new ScopingStrategy();
	}
	/**
	 * @param onScopeEntered Event handlers to be called after entering local or implicit scope
	 * @param onScopeLeft    Event handlers to b called after leaving local or implicit scope
	 * @return an empty scoping strategy, for internal use only.
	 */
	public static ScopingStrategy create(List<BiConsumer<Visitable, Collection<IdentifiableElement>>> onScopeEntered, List<BiConsumer<Visitable, Collection<IdentifiableElement>>> onScopeLeft) {
		var strategy = create();
		strategy.onScopeEntered.addAll(onScopeEntered);
		strategy.onScopeLeft.addAll(onScopeLeft);
		return strategy;
	}
	/**
	 * Keeps track of named objects that have been already visited.
	 */
	private final Deque<Set<IdentifiableElement>> dequeOfVisitedNamed = new ArrayDeque<>();
	/**
	 * Some expressions have implicit scopes, we might not clear that after returning from inner statements or returns.
	 */
	private final Deque<Set<IdentifiableElement>> implicitScope = new ArrayDeque<>();
	private Set<IdentifiableElement> afterStatement = Collections.emptySet();
	private Visitable previous;
	private boolean inOrder = false;
	private boolean inProperty = false;
	private boolean inSubquery = false;
	private boolean inListFunctionPredicate = false;
	private final Deque<Set<String>> currentImports = new ArrayDeque<>();
	private final Deque<Set<String>> definedInSubquery = new ArrayDeque<>();
	private final List<BiConsumer<Visitable, Collection<IdentifiableElement>>> onScopeEntered = new ArrayList<>();
	private final List<BiConsumer<Visitable, Collection<IdentifiableElement>>> onScopeLeft = new ArrayList<>();
	/**
	 * A flag if we can skip aliasing. This is currently the case in exactly one scenario: A aliased expression passed
	 * to a map project. In that case, the alias is already defined by the key to use in the projected map, and we
	 * cannot define him in `AS xxx` fragment.
	 */
	private final Deque<Boolean> skipAliasing = new ArrayDeque<>();
	private ScopingStrategy() {
		this.dequeOfVisitedNamed.push(new LinkedHashSet<>());
	}
	/**
	 * Called when visiting a {@link Visitable}
	 *
	 * @param visitable Element to be checked for new scope
	 */
	public void doEnter(Visitable visitable) {
		// We don't want the identifiable in an order clause to be retained
		if (visitable instanceof Order) {
			this.inOrder = true;
		}
		if (visitable instanceof Property) {
			this.inProperty = true;
		}
		if (visitable instanceof Subquery subquery) {
			var with = subquery.importingWith();
			this.inSubquery = true;
			this.definedInSubquery.push(new LinkedHashSet<>());
			Set<String> imports = new LinkedHashSet<>();
			this.currentImports.push(imports);
			if (with != null) {
				with.getItems().stream()
					.filter(IdentifiableElement.class::isInstance)
					.map(IdentifiableElement.class::cast)
					.map(ScopingStrategy::extractIdentifier)
					.filter(Objects::nonNull)
					.forEach(imports::add);
			}
		}
		if (isListFunctionPredicate(visitable)) {
			this.inListFunctionPredicate = true;
		}
		if (visitable instanceof MapProjection) {
			this.skipAliasing.push(true);
		} else if (visitable instanceof SubqueryExpression) {
			this.skipAliasing.push(false);
		}
		boolean notify = false;
		Set<IdentifiableElement> scopeSeed = dequeOfVisitedNamed.isEmpty() ? Collections.emptySet() : dequeOfVisitedNamed.peek();
		if (hasLocalScope(visitable)) {
			notify = true;
			dequeOfVisitedNamed.push(new LinkedHashSet<>(scopeSeed));
		}
		if (hasImplicitScope(visitable)) {
			notify = true;
			implicitScope.push(new LinkedHashSet<>(scopeSeed));
		}
		if (notify) {
			scopeSeed.addAll(afterStatement);
			var importsAndScope = new LinkedHashSet<IdentifiableElement>();
			var current = this.currentImports.peek();
			if (current != null) {
				current.stream().map(Cypher::name).forEach(importsAndScope::add);
			}
			importsAndScope.addAll(scopeSeed);
			this.onScopeEntered.forEach(c -> c.accept(visitable, importsAndScope));
		}
	}
	public boolean isSkipAliasing() {
		return Optional.ofNullable(this.skipAliasing.peek()).orElse(false);
	}
	/**
	 * @param namedItem An item that might have been visited in the current scope
	 * @return {@literal true} if the named item has been visited in the current scope before
	 */
	public boolean hasVisitedBefore(Named namedItem) {
		if (!hasScope()) {
			return false;
		}
		Set<IdentifiableElement> scope = dequeOfVisitedNamed.peek();
		return hasVisitedInScope(scope, namedItem);
	}
	private boolean isListFunctionPredicate(Visitable visitable) {
		return visitable instanceof FunctionInvocation fi && Set.of("all", "any", "none", "single")
			.contains(fi.getFunctionName().toLowerCase(
				Locale.ROOT));
	}
	/**
	 * Called when leaving a {@link Visitable}
	 *
	 * @param visitable Element to be checked for a scope to be closed
	 */
	public void doLeave(Visitable visitable) {
		if (!hasScope()) {
			return;
		}
		if (visitable instanceof IdentifiableElement identifiableElement && !inOrder && (!inProperty || visitable instanceof Property)) {
			if (identifiableElement instanceof SymbolicName && inListFunctionPredicate) {
				this.inListFunctionPredicate = false;
			} else {
				dequeOfVisitedNamed.peek().add(identifiableElement);
				if (inSubquery) {
					var identifier = extractIdentifier(identifiableElement);
					if (identifier != null) {
						this.definedInSubquery.peek().add(identifier);
					}
				}
			}
		}
		if (isListFunctionPredicate(visitable)) {
			this.inListFunctionPredicate = false;
		}
		boolean notify = false;
		if (visitable instanceof Statement) {
			leaveStatement(visitable);
		} else if (hasLocalScope(visitable)) {
			notify = true;
			Set<IdentifiableElement> lastVisitedNames = this.dequeOfVisitedNamed.pop();
			if (visitable instanceof ExistentialSubquery) {
				this.afterStatement.retainAll(lastVisitedNames);
			}
		} else {
			clearPreviouslyVisitedNamed(visitable);
		}
		if (visitable instanceof Order) {
			this.inOrder = false;
		}
		if (visitable instanceof Property) {
			this.inProperty = false;
		}
		if (visitable instanceof Subquery) {
			this.inSubquery = false;
			this.currentImports.pop();
			this.definedInSubquery.pop();
		}
		if (visitable instanceof MapProjection || visitable instanceof SubqueryExpression) {
			this.skipAliasing.pop();
		}
		if (hasImplicitScope(visitable)) {
			notify = true;
			this.implicitScope.pop();
		}
		previous = visitable;
		if (notify) {
			Set<IdentifiableElement> retainedElements = new HashSet<>(afterStatement);
			this.onScopeLeft.forEach(c -> c.accept(visitable, retainedElements));
		}
	}
	/**
	 * Anything that might import variables from the outside, without using an explicit {@code WITH} clause.
	 *
	 * @param visitable the element to be checked whether it implicitly imports named elements.
	 * @return {@literal true} if named elements are imported
	 */
	private static boolean hasImplicitScope(Visitable visitable) {
		return visitable instanceof SubqueryExpression || visitable instanceof Statement.UnionQuery;
	}
	private void leaveStatement(Visitable visitable) {
		Set<IdentifiableElement> lastScope = this.dequeOfVisitedNamed.peek();
		// We keep properties only around when they have been actually returned
		if (previous instanceof UnionPart && afterStatement != null) {
			lastScope.stream().filter(i -> !(i instanceof Property))
				.forEach(afterStatement::add);
		} else if (!(previous instanceof Return || previous instanceof YieldItems)) {
			this.afterStatement = lastScope.stream().filter(i -> !(i instanceof Property))
				.collect(Collectors.toCollection(LinkedHashSet::new));
		} else {
			this.afterStatement = new LinkedHashSet<>(lastScope);
		}
		// A procedure call doesn't change scope.
		if (visitable instanceof ProcedureCall) {
			return;
		}
		lastScope.retainAll(Optional.ofNullable(this.implicitScope.peek()).orElseGet(Set::of));
	}
	private boolean hasScope() {
		return !this.dequeOfVisitedNamed.isEmpty();
	}
	private boolean hasVisitedInScope(Collection<IdentifiableElement> visited, Named needle) {
		return visited.contains(needle) || needle.getSymbolicName().isPresent() && visited.stream()
			.filter(byHasAName())
			.map(ScopingStrategy::extractIdentifier)
			.filter(Objects::nonNull)
			.anyMatch(identifiedBy(needle));
	}
	@NotNull
	private static Predicate<IdentifiableElement> byHasAName() {
		Predicate<IdentifiableElement> hasAName = Named.class::isInstance;
		hasAName = hasAName.or(AliasedExpression.class::isInstance);
		hasAName = hasAName.or(SymbolicName.class::isInstance);
		return hasAName;
	}
	/**
	 * Extracts an identifier from an {@link IdentifiableElement identifiable element}.
	 * @param i The identifiable element
	 * @return The identifier
	 */
	private static String extractIdentifier(IdentifiableElement i) {
		String value;
		if (i instanceof Named named) {
			value = named.getSymbolicName().map(SymbolicName::getValue).orElse(null);
		} else if (i instanceof Aliased aliased) {
			value = aliased.getAlias();
		} else if (i instanceof SymbolicName symbolicName) {
			value = symbolicName.getValue();
		} else {
			value = null;
		}
		return value;
	}
	@NotNull
	private Predicate<String> identifiedBy(Named needle) {
		return i -> {
			boolean result = i.equals(needle.getRequiredSymbolicName().getValue());
			if (result && inSubquery) {
				var imported = Optional.ofNullable(currentImports.peek()).orElseGet(Set::of).contains(i);
				return imported || this.definedInSubquery.peek().contains(i);
			}
			return result;
		};
	}
	private static boolean hasLocalScope(Visitable visitable) {
		return visitable instanceof PatternComprehension ||
			visitable instanceof Subquery ||
			visitable instanceof SubqueryExpression ||
			visitable instanceof Foreach;
	}
	private void clearPreviouslyVisitedNamed(Visitable visitable) {
		if (visitable instanceof With with) {
			clearPreviouslyVisitedAfterWith(with);
		} else if (visitable instanceof Return || visitable instanceof YieldItems) {
			clearPreviouslyVisitedAfterReturnish(visitable);
		}
	}
	private void clearPreviouslyVisitedAfterWith(With with) {
		// We need to clear the named cache after defining a with.
		// Everything not taken into the next step has to go.
		Set<IdentifiableElement> retain = new HashSet<>();
		Set<IdentifiableElement> visitedNamed = dequeOfVisitedNamed.peek();
		if (visitedNamed == null) {
			return;
		}
		with.accept(segment -> {
			if (segment instanceof SymbolicName symbolicName) {
				visitedNamed.stream()
					.filter(element -> {
						if (element instanceof Named named) {
							return named.getRequiredSymbolicName().equals(segment);
						} else if (element instanceof Aliased aliased) {
							return aliased.getAlias().equals((symbolicName).getValue());
						} else {
							return element.equals(segment);
						}
					})
					.forEach(retain::add);
			} else if (segment instanceof Asterisk) {
				retain.addAll(visitedNamed);
			}
		});
		retain.addAll(Optional.ofNullable(implicitScope.peek()).orElseGet(Set::of));
		visitedNamed.retainAll(retain);
	}
	private void clearPreviouslyVisitedAfterReturnish(Visitable returnish) {
		// Everything not returned has to go.
		Set<IdentifiableElement> retain = new HashSet<>();
		Set<IdentifiableElement> visitedNamed = dequeOfVisitedNamed.peek();
		returnish.accept(new Visitor() {
			int level = 0;
			Visitable entranceLevel1;
			@Override
			public void enter(Visitable segment) {
				if (entranceLevel1 == null && segment instanceof TypedSubtree) {
					entranceLevel1 = segment;
					return;
				}
				if (entranceLevel1 != null) {
					++level;
				}
				// Only collect things exactly one level into the list of returned items
				if (level == 1 && segment instanceof IdentifiableElement identifiableElement) {
					retain.add(identifiableElement);
				}
			}
			@Override
			public void leave(Visitable segment) {
				if (entranceLevel1 != null) {
					level = Math.max(0, level - 1);
					if (segment == entranceLevel1) {
						entranceLevel1 = null;
					}
				}
			}
		});
		retain.addAll(Optional.ofNullable(implicitScope.peek()).orElseGet(Set::of));
		if (visitedNamed != null) {
			visitedNamed.retainAll(retain);
		}
	}
	/**
	 * @return An unmodifiable collections with identifiables in the current scope
	 */
	public Collection<Expression> getIdentifiables() {
		if (!hasScope()) {
			return Collections.emptySet();
		}
		Predicate<IdentifiableElement> allNamedElementsHaveResolvedNames = e ->
			!(e instanceof Named named) || named.getSymbolicName().filter(s -> s.getValue() != null).isPresent();
		Set<IdentifiableElement> items = Optional.ofNullable(this.dequeOfVisitedNamed.peek())
			.filter(scope -> !scope.isEmpty())
			.orElse(afterStatement);
		return items
			.stream()
			.filter(allNamedElementsHaveResolvedNames)
			.map(IdentifiableElement::asExpression)
			.collect(Collectors.collectingAndThen(Collectors.toCollection(LinkedHashSet::new), Collections::unmodifiableSet));
	}
	public PatternElement lookup(Named node) {
		if (!hasScope() || node.getSymbolicName().isEmpty()) {
			return null;
		}
		var scope = dequeOfVisitedNamed.peek();
		var identifiedBy = identifiedBy(node);
		return scope.stream()
			.filter(byHasAName())
			.filter(PatternElement.class::isInstance)
			.filter(i -> {
				var identifier = extractIdentifier(i);
				return identifier != null && identifiedBy.test(identifier);
			})
			.map(PatternElement.class::cast)
			.findFirst()
			.orElse(null);
	}
	/**
	 * @return The set of current imports
	 */
	public Set<SymbolicName> getCurrentImports() {
		return Optional.ofNullable(this.currentImports.peek()).stream()
			.flatMap(v -> v.stream()
				.map(Cypher::name))
			.collect(Collectors.toSet());
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.ast;
/**
 * @author Michael J. Simons
 * @since 1.0
 */
@FunctionalInterface
public interface Visitor {
	/**
	 * Enter a {@link Visitable}. Not all visitables will obey to the result
	 *
	 * @param segment the segment to visit.
	 */
	void enter(Visitable segment);
	/**
	 * A method that is used to pass control to some extent from the visitor to the {@link Visitable}. Not all visitables
	 * react to this, and we don't give any guarantees about which will. This method has been mainly introduced in parallel
	 * to {@link #enter(Visitable)} so that existing external implementations of {@link Visitor visitors} won't break.
	 *
	 * @param segment the segment to visit.
	 * @return A result indicating whether visitation of child elements should continue or not.
	 * @since 2022.3.0
	 */
	default EnterResult enterWithResult(Visitable segment) {
		enter(segment);
		return EnterResult.CONTINUE;
	}
	/**
	 * Leave a {@link Visitable}.
	 *
	 * @param segment the visited segment.
	 */
	default void leave(Visitable segment) {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import static org.apiguardian.api.API.Status.STABLE;
import java.text.MessageFormat;
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * See
 * <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/FunctionInvocation.html">FunctionInvocation</a>
 *
 * @author Gerrit Meier
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public final class FunctionInvocation implements Expression {
	private static final MessageFormat MESSAGE_FMT_EXP_REQUIRED = new MessageFormat(
		Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_FOR_FUNCTION_REQUIRED));
	private static final MessageFormat MESSAGE_FMT_PATTERN_REQUIRED = new MessageFormat(
		Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_PATTERN_FOR_FUNCTION_REQUIRED));
	private static final MessageFormat MESSAGE_FMT_ARG_REQUIRED = new MessageFormat(
		Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_AT_LEAST_ONE_ARG_REQUIRED));
	/**
	 * Defines metadata for a function.
	 */
	@API(status = STABLE, since = "2020.1.0")
	public interface FunctionDefinition {
		/**
		 * @return the Cypher implementation name
		 */
		String getImplementationName();
		/**
		 * @return {@literal true} if this is an aggregating function
		 */
		default boolean isAggregate() {
			return Arrays.stream(BuiltInFunctions.Aggregates.values())
				.map(BuiltInFunctions.Aggregates::getImplementationName)
				.anyMatch(v -> v.equalsIgnoreCase(getImplementationName()));
		}
	}
	/**
	 * Creates a {@link FunctionInvocation} based on a simple definition without any arguments.
	 *
	 * @param definition The definition of a function
	 * @return The invocation (a valid expression)
	 * @since 2021.2.3
	 */
	public static FunctionInvocation create(FunctionDefinition definition) {
		return new FunctionInvocation(definition.getImplementationName());
	}
	/**
	 * Creates a {@link FunctionInvocation} based on a simple definition with arguments.
	 *
	 * @param definition  The definition of a function
	 * @param expressions The arguments to the function
	 * @return The invocation (a valid expression)
	 * @since 2021.2.3
	 */
	public static FunctionInvocation create(FunctionDefinition definition, Expression... expressions) {
		String message = MESSAGE_FMT_EXP_REQUIRED.format(new Object[] { definition.getImplementationName() });
		Assertions.notEmpty(expressions, message);
		Assertions.notNull(expressions[0], message);
		return new FunctionInvocation(definition.getImplementationName(), expressions);
	}
	/**
	 * Creates a {@link FunctionInvocation} based on a simple definition with arguments and adds the {@code distinct}
	 * operator to it. This is only supported with {@link FunctionDefinition#isAggregate()} returning {@literal true}.
	 *
	 * @param definition  The definition of a function
	 * @param expressions The arguments to the function
	 * @return The invocation (a valid expression)
	 * @since 2021.2.3
	 */
	public static FunctionInvocation createDistinct(FunctionDefinition definition, Expression... expressions) {
		Assertions
			.isTrue(definition.isAggregate(), Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_CORRECT_USAGE_OF_DISTINCT));
		String message = MESSAGE_FMT_EXP_REQUIRED.format(new Object[] { definition.getImplementationName() });
		Assertions.notEmpty(expressions, message);
		Assertions.notNull(expressions[0], message);
		Expression[] newExpressions = new Expression[expressions.length];
		newExpressions[0] = new DistinctExpression(expressions[0]);
		System.arraycopy(expressions, 1, newExpressions, 1, expressions.length - 1);
		return new FunctionInvocation(definition.getImplementationName(), newExpressions);
	}
	/**
	 * Creates a new function invocation for a pattern element.
	 *
	 * @param definition The definition of the function
	 * @param pattern    The argument to the function
	 * @return A function invocation
	 * @since 2021.2.3
	 */
	public static FunctionInvocation create(FunctionDefinition definition, PatternElement pattern) {
		String message = MESSAGE_FMT_PATTERN_REQUIRED.format(new Object[] { definition.getImplementationName() });
		Assertions.notNull(pattern, message);
		Predicate<FunctionDefinition> isShortestPath = d ->
			BuiltInFunctions.Scalars.SHORTEST_PATH.getImplementationName().equals(d.getImplementationName()) || "allShortestPaths".equals(d.getImplementationName());
		return new FunctionInvocation(definition.getImplementationName(),
			isShortestPath.test(definition) ? Pattern.of(List.of(pattern)) : new PatternExpressionImpl(pattern));
	}
	static FunctionInvocation create(FunctionDefinition definition, TypedSubtree<?> arguments) {
		Assertions.notNull(arguments,
			MESSAGE_FMT_ARG_REQUIRED.format(new Object[] { definition.getImplementationName() }));
		return new FunctionInvocation(definition.getImplementationName(), arguments);
	}
	private final String functionName;
	private final Visitable arguments;
	private FunctionInvocation(String functionName, Expression... arguments) {
		this.functionName = functionName;
		this.arguments = new ExpressionList(arguments);
	}
	private FunctionInvocation(String functionName, Visitable arguments) {
		this.functionName = functionName;
		this.arguments = arguments;
	}
	/**
	 * @return The name of this function.
	 */
	@API(status = INTERNAL)
	public String getFunctionName() {
		return functionName;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.arguments.accept(visitor);
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.renderer;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Optional;
import java.util.function.Function;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.Comparison;
import org.neo4j.cypherdsl.core.FunctionInvocation;
import org.neo4j.cypherdsl.core.Subquery;
import org.neo4j.cypherdsl.core.With;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * The dialect to be used when rendering a statement into Cypher.
 *
 * @author Michael J. Simons
 * @soundtrack Red Hot Chili Peppers - Unlimited Love
 * @since 2022.3.0
 */
@API(status = STABLE, since = "2022.3.0")
public enum Dialect {
	/**
	 * Neo4j 4.4 and earlier
	 */
	NEO4J_4,
	/**
	 * Neo4j 5
	 */
	NEO4J_5 {
		private final DefaultNeo4j5HandlerSupplier handlerSupplier = new DefaultNeo4j5HandlerSupplier();
		@Override
		@Nullable Class<? extends Visitor> getHandler(Visitable visitable) {
			return handlerSupplier.apply(visitable).orElseGet(() -> super.getHandler(visitable));
		}
	},
	/**
	 * Enhanced Neo4j 5 dialect that renders importing with statements for call subqueries as variable scoped subqueries.
	 * @since 2024.1.0
	 */
	NEO4J_5_23 {
		private final DefaultNeo4j5HandlerSupplier handlerSupplier = new DefaultNeo4j5HandlerSupplier();
		@Override
		@Nullable Class<? extends Visitor> getHandler(Visitable visitable) {
			return handlerSupplier.apply(visitable)
				.or(() -> {
					if (visitable instanceof Subquery || visitable instanceof With) {
						return Optional.of(Neo4j523SubqueryVisitor.class);
					}
					return Optional.empty();
				})
				.orElseGet(() -> super.getHandler(visitable));
		}
	};
	@Nullable Class<? extends Visitor> getHandler(Visitable visitable) {
		return null;
	}
	private static class DefaultNeo4j5HandlerSupplier
		implements Function<Visitable, Optional<Class<? extends Visitor>>> {
		@Override
		public Optional<Class<? extends Visitor>> apply(Visitable visitable) {
			if (visitable instanceof FunctionInvocation) {
				return Optional.of(Neo4j5FunctionInvocationVisitor.class);
			} else if (visitable instanceof Comparison) {
				return Optional.of(Neo4j5ComparisonVisitor.class);
			}
			return Optional.empty();
		}
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.renderer;
import java.util.concurrent.atomic.AtomicReference;
import org.neo4j.cypherdsl.build.annotations.RegisterForReflection;
import org.neo4j.cypherdsl.core.FunctionInvocation;
import org.neo4j.cypherdsl.core.NestedExpression;
import org.neo4j.cypherdsl.core.Property;
import org.neo4j.cypherdsl.core.ast.EnterResult;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.ast.VisitorWithResult;
/**
 * Some logic to rewrite a couple of functions for Neo4j 5, among them:
 * <ul>
 *     <li><pre>exists(n.prop)</pre></li>
 *     <li><pre>distance(p)</pre></li>
 * </ul>
 *
 * @author Michael J. Simons
 * @soundtrack Red Hot Chili Peppers - Unlimited Love
 * @since 2022.3.0
 */
@RegisterForReflection(allDeclaredConstructors = true) final class Neo4j5FunctionInvocationVisitor implements Visitor {
	private final DefaultVisitor delegate;
	Neo4j5FunctionInvocationVisitor(DefaultVisitor delegate) {
		this.delegate = delegate;
	}
	@Override
	public void enter(Visitable visitable) {
		FunctionInvocation functionInvocation = (FunctionInvocation) visitable;
		if ("distance".equals(functionInvocation.getFunctionName())) {
			delegate.builder.append("point.distance(");
		} else if ("elementId".equals(functionInvocation.getFunctionName())) {
			delegate.builder.append("elementId(");
		} else if (!isNPropExists(visitable)) {
			delegate.enter(functionInvocation);
		}
	}
	@Override
	public void leave(Visitable visitable) {
		FunctionInvocation functionInvocation = (FunctionInvocation) visitable;
		if (isNPropExists(visitable)) {
			delegate.builder.append(" IS NOT NULL");
		} else if ("elementId".equals(functionInvocation.getFunctionName())) {
			delegate.builder.append(")");
		} else {
			delegate.leave(functionInvocation);
		}
	}
	static boolean isNPropExists(Visitable visitable) {
		if (visitable instanceof NestedExpression) {
			AtomicReference<Visitable> capture = new AtomicReference<>();
			visitable.accept(new VisitorWithResult() {
				@Override
				public EnterResult enterWithResult(Visitable segment) {
					if (segment instanceof NestedExpression) { // The same object
						return EnterResult.CONTINUE;
					}
					return capture.compareAndSet(null, segment) ? EnterResult.SKIP_CHILDREN : EnterResult.CONTINUE;
				}
			});
			visitable = capture.get();
		}
		if (!(visitable instanceof FunctionInvocation functionInvocation)) {
			return false;
		}
		if ("exists".equals(functionInvocation.getFunctionName())) {
			SingleArgExtractor<Property> singleArgExtractor = new SingleArgExtractor<>(Property.class);
			functionInvocation.accept(singleArgExtractor);
			return singleArgExtractor.singleArg != null;
		}
		return false;
	}
	static class SingleArgExtractor<T> extends VisitorWithResult {
		final Class<T> expectedType;
		boolean insideArguments;
		int level = 0;
		T singleArg;
		SingleArgExtractor(Class<T> expectedType) {
			this.expectedType = expectedType;
		}
		@SuppressWarnings("unchecked")
		@Override
		public EnterResult enterWithResult(Visitable segment) {
			if (segment instanceof NestedExpression) {
				return EnterResult.CONTINUE;
			}
			if (++level == 2) {
				insideArguments = true;
			}
			if (insideArguments && level == 3 && expectedType.isInstance(segment)) {
				singleArg = singleArg == null ? (T) segment : null;
			}
			return EnterResult.CONTINUE;
		}
		@Override
		public void leave(Visitable segment) {
			insideArguments = level-- != 2;
		}
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
/**
 * A pattern is something that can be matched. It consists of one or more pattern elements. Those can be nodes or chains
 * of nodes and relationships.
 * <p>
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/Pattern.html">Pattern</a>.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = INTERNAL, since = "1.0")
final class Pattern extends TypedSubtree<PatternElement> {
	static Pattern of(PatternElement requiredPattern, PatternElement... patternElement) {
		List<PatternElement> elements;
		if (patternElement == null || patternElement.length == 0) {
			elements = List.of(requiredPattern);
		} else {
			elements = new ArrayList<>();
			elements.add(requiredPattern);
			elements.addAll(Arrays.asList(patternElement));
		}
		return Pattern.of(elements);
	}
	static Pattern of(Collection<? extends PatternElement> elements) {
		return new Pattern(elements.stream().map(PatternElement.class::cast).toList());
	}
	private Pattern(List<PatternElement> patternElements) {
		super(patternElements);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.Set;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * A set of operations.
 *
 * @author Michael J. Simons
 * @since 1.0
 * be accessible.
 */
final class Operations {
	private static final java.util.Set<Class<? extends Expression>> VALID_MUTATORS =
		Set.of(MapExpression.class, Parameter.class, MapProjection.class, SymbolicName.class, FunctionInvocation.class);
	/**
	 * Creates a unary minus operation.
	 *
	 * @param e The expression to which the unary minus should be applied. We don't check if it's a numeric expression,
	 *          but in hindsight to generate semantically correct Cypher, it's recommended that is one.
	 * @return An unary minus operation.
	 * @since 2021.2.3
	 */
	static Operation minus(Expression e) {
		return Operation.create(Operator.UNARY_MINUS, e);
	}
	/**
	 * Creates an unary plus operation.
	 *
	 * @param e The expression to which the unary plus should be applied. We don't check if it's a numeric expression,
	 *          but in hindsight to generate semantically correct Cypher, it's recommended that is one.
	 * @return An unary plus operation.
	 * @since 2021.2.3
	 */
	static Expression plus(Expression e) {
		return Operation.create(Operator.UNARY_PLUS, e);
	}
	static Operation concat(Expression op1, Expression op2) {
		return Operation.create(op1, Operator.CONCAT, op2);
	}
	static Operation add(Expression op1, Expression op2) {
		return Operation.create(op1, Operator.ADDITION, op2);
	}
	static Operation subtract(Expression op1, Expression op2) {
		return Operation.create(op1, Operator.SUBTRACTION, op2);
	}
	static Operation multiply(Expression op1, Expression op2) {
		return Operation.create(op1, Operator.MULTIPLICATION, op2);
	}
	static Operation divide(Expression op1, Expression op2) {
		return Operation.create(op1, Operator.DIVISION, op2);
	}
	static Operation remainder(Expression op1, Expression op2) {
		return Operation.create(op1, Operator.MODULO_DIVISION, op2);
	}
	static Operation pow(Expression op1, Expression op2) {
		return Operation.create(op1, Operator.EXPONENTIATION, op2);
	}
	/**
	 * Creates a {@code =} operation. The left hand side should resolve to a property or to something which has labels
	 * or types to modify and the right hand side should either be new properties or labels.
	 *
	 * @param target The target that should be modified
	 * @param value  The new value of the target
	 * @return A new operation.
	 * @since 2021.2.3
	 */
	static Operation set(Expression target, Expression value) {
		return Operation.create(target, Operator.SET, value);
	}
	/**
	 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
	 * of properties and the right hand side must be a map of new or updated properties
	 *
	 * @param target The target container that should be modified
	 * @param value  The new properties
	 * @return A new operation.
	 * @since 2020.1.5
	 */
	static Operation mutate(Expression target, MapExpression value) {
		return Operation.create(target, Operator.MUTATE, value);
	}
	/**
	 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
	 * of properties and the right hand side must be a map of new or updated properties
	 *
	 * @param target The target container that should be modified
	 * @param value  The new properties
	 * @return A new operation.
	 * @since 2020.1.5
	 */
	static Operation mutate(Expression target, Expression value) {
		Assertions.notNull(value, "New properties value must not be null");
		Assertions.isTrue(Property.class.isAssignableFrom(value.getClass()) || VALID_MUTATORS.contains(value.getClass()),
			"A property container can only be mutated by a map, or a parameter or property pointing to a map.");
		return Operation.create(target, Operator.MUTATE, value);
	}
	/**
	 * Creates an operation adding one or more labels from a given {@link Node node}.
	 *
	 * @param target The target of the new labels
	 * @param label  The labels to be added
	 * @return A set operation
	 * @since 2021.2.3
	 */
	static Operation set(Node target, String... label) {
		return Operation.create(target, Operator.SET_LABEL, label);
	}
	/**
	 * Creates an operation removing one or more labels from a given {@link Node node}.
	 *
	 * @param target The target of the remove operation
	 * @param label  The labels to be removed
	 * @return A remove operation
	 * @since 2021.2.3
	 */
	static Operation remove(Node target, String... label) {
		return Operation.create(target, Operator.REMOVE_LABEL, label);
	}
	/**
	 * Not to be instantiated.
	 */
	private Operations() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitable;
/**
 * See <a href="https://s3.amazonaws.com/artifacts.opencypher.org/M15/railroad/PatternElement.html">PatternElement</a>.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = STABLE, since = "1.0")
public interface PatternElement extends Visitable {
	/**
	 * Creates a new {@link PatternElement} which including an additional filter. Returns {@code this} pattern.
	 * when {@code predicate} is literal {@code null}.
	 * <p>
	 * The pattern might be a {@link Node node pattern} or a {@link RelationshipPattern relationship pattern}.
	 * <p>
	 * A {@code WHERE} on a pattern is only supported from Neo4j 5.0 onwards.
	 *
	 * @param predicate the predicate to filter on
	 * @return a new pattern element or this instance if the predicate to this method was literal {@code null}
	 * @throws UnsupportedOperationException In cases the underlying element does not support a {@code WHERE} clause
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0")
	@NotNull @Contract(pure = true)
	default PatternElement where(@Nullable Expression predicate) {
		throw new UnsupportedOperationException();
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.ast;
/**
 * Interface for implementations that accepts {@link Visitor visitors}.
 *
 * @author Michael Simons
 * @see Visitor
 * @since 1.0
 */
public interface Visitable {
	/**
	 * A helper method that presents the {@code visitor} to the {@code visitable} if the visitable is not null.
	 * Not meant to be overridden.
	 *
	 * @param visitable The visitable to visit if not null
	 * @param visitor   The visitor to use
	 */
	static void visitIfNotNull(Visitable visitable, Visitor visitor) {
		if (visitable != null) {
			visitable.accept(visitor);
		}
	}
	/**
	 * Accept a {@link Visitor} visiting this {@link Visitable} and its nested {@link Visitable}s if applicable.
	 *
	 * @param visitor the visitor to notify, must not be {@literal null}.
	 */
	default void accept(Visitor visitor) {
		visitor.enter(this);
		visitor.leave(this);
	}
	/**
	 * Most {@link Visitable visitables} will render themselves into a Cypher fragment preceded with the actual classname.
	 * The representation however is not cached - in contrast to the ones for full statements. Using {@code toString}
	 * is recommended for debugging purposes mainly, and not for production use.
	 * <p>
	 * The concrete classname has been prepended to help debugging and actually to discourage using fragments to build queries
	 * without explicitly rendering them, either as statement or going through the renderer on purpose.
	 *
	 * @return A string representation of this visitable formatted as {@literal Classname{cypher=value}}
	 */
	String toString();
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.List;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
/**
 * Represents a list of expressions. When visited, the expressions are treated as named expression if they have declared
 * a symbolic name as variable or as unnamed expression when nameless.
 * <p>
 * Not to be mixed up with the actual {@link ListExpression}, which itself is an expression.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
class ExpressionList extends TypedSubtree<Expression> {
	ExpressionList(List<Expression> returnItems) {
		super(returnItems);
	}
	ExpressionList(Expression... children) {
		super(children);
	}
	@Override
	@SuppressWarnings("deprecation")
	protected Visitable prepareVisit(Expression child) {
		return Expressions.nameOrExpression(child);
	}
	boolean isEmpty() {
		return super.children.isEmpty();
	}
	@Override
	protected List<Expression> getChildren() {
		return super.getChildren();
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.parser;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypher.internal.ast.factory.ASTFactory;
import org.neo4j.cypher.internal.ast.factory.ASTFactory.NULL;
import org.neo4j.cypher.internal.parser.common.ast.factory.AccessType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ActionType;
import org.neo4j.cypher.internal.parser.common.ast.factory.CallInTxsOnErrorBehaviourType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ConstraintType;
import org.neo4j.cypher.internal.parser.common.ast.factory.CreateIndexTypes;
import org.neo4j.cypher.internal.parser.common.ast.factory.HintIndexType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParameterType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserCypherTypeName;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserNormalForm;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserTrimSpecification;
import org.neo4j.cypher.internal.parser.common.ast.factory.ScopeType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ShowCommandFilterTypes;
import org.neo4j.cypher.internal.parser.common.ast.factory.SimpleEither;
import org.neo4j.cypherdsl.core.Case;
import org.neo4j.cypherdsl.core.Clause;
import org.neo4j.cypherdsl.core.Clauses;
import org.neo4j.cypherdsl.core.Cypher;
import org.neo4j.cypherdsl.core.ExposesRelationships;
import org.neo4j.cypherdsl.core.Expression;
import org.neo4j.cypherdsl.core.Finish;
import org.neo4j.cypherdsl.core.FunctionInvocation;
import org.neo4j.cypherdsl.core.Hint;
import org.neo4j.cypherdsl.core.KeyValueMapEntry;
import org.neo4j.cypherdsl.core.LabelExpression;
import org.neo4j.cypherdsl.core.MapExpression;
import org.neo4j.cypherdsl.core.MapProjection;
import org.neo4j.cypherdsl.core.MergeAction;
import org.neo4j.cypherdsl.core.NamedPath;
import org.neo4j.cypherdsl.core.Node;
import org.neo4j.cypherdsl.core.Operation;
import org.neo4j.cypherdsl.core.Parameter;
import org.neo4j.cypherdsl.core.PatternComprehension;
import org.neo4j.cypherdsl.core.PatternElement;
import org.neo4j.cypherdsl.core.Property;
import org.neo4j.cypherdsl.core.PropertyLookup;
import org.neo4j.cypherdsl.core.QuantifiedPathPattern;
import org.neo4j.cypherdsl.core.Relationship;
import org.neo4j.cypherdsl.core.RelationshipPattern;
import org.neo4j.cypherdsl.core.Return;
import org.neo4j.cypherdsl.core.Set;
import org.neo4j.cypherdsl.core.SortItem;
import org.neo4j.cypherdsl.core.Statement;
import org.neo4j.cypherdsl.core.StringLiteral;
import org.neo4j.cypherdsl.core.SymbolicName;
import org.neo4j.cypherdsl.core.Where;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
/**
 * An implementation of Neo4j's {@link ASTFactory} that creates Cypher-DSL AST elements that can be used for creating
 * conditions, patterns to match etc.
 *
 * @author Michael J. Simons
 * @since 2021.3.0
 */
@API(status = INTERNAL, since = "2021.3.0")
final class CypherDslASTFactory implements ASTFactory<
	Statements,
	Statement,
	Statement,
	Clause,
	Finish,
	Return,
	Expression,
	List<Expression>,
	SortItem,
	PatternElement,
	NodeAtom,
	PathAtom,
	PathLength,
	Clause,
	Expression,
	Expression,
	Expression,
	Hint,
	Expression,
	LabelExpression,
	Expression,
	Parameter<?>,
	Expression,
	Property,
	Expression,
	Clause,
	Statement,
	Statement,
	Statement,
	Clause,
	Where,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	InputPosition,
	EntityType,
	QuantifiedPathPattern.Quantifier,
	PatternAtom,
	DatabaseName,
	NULL,
	NULL,
	PatternElement> {
	private static CypherDslASTFactory instanceFromDefaultOptions;
	static CypherDslASTFactory getInstance(Options options) {
		CypherDslASTFactory instance;
		if (options != null && !options.areDefault()) {
			instance = new CypherDslASTFactory(options);
		} else {
			instance = instanceFromDefaultOptions;
			if (instance == null) {
				synchronized (CypherDslASTFactory.class) {
					instance = instanceFromDefaultOptions;
					if (instance == null) {
						instanceFromDefaultOptions = new CypherDslASTFactory(Optional.ofNullable(options).orElseGet(Options::defaultOptions));
						instance = instanceFromDefaultOptions;
					}
				}
			}
		}
		return instance;
	}
	private final Options options;
	private CypherDslASTFactory(Options options) {
		this.options = options;
	}
	private String[] computeFinalLabelList(LabelParsedEventType event, List<StringPos<InputPosition>> inputLabels) {
		return inputLabels == null ? new String[0] : this.options.getLabelFilter()
			.apply(event, inputLabels.stream().map(v -> v.string).toList())
			.toArray(new String[0]);
	}
	private Optional<String[]> computeFinalLabelList(LabelParsedEventType event, LabelExpression inputLabels) {
		if (inputLabels == null) {
			return Optional.of(new String[0]);
		}
		if (inputLabels.type() == LabelExpression.Type.COLON_CONJUNCTION || (inputLabels.type() == LabelExpression.Type.LEAF && inputLabels.value() != null)) {
			return Optional.of(this.options.getLabelFilter()
				.apply(event, inputLabels.value())
				.toArray(new String[0]));
		}
		return Optional.empty();
	}
	private String[] computeFinalTypeList(TypeParsedEventType event, LabelExpression inputTypes) {
		if (inputTypes == null) {
			return new String[0];
		}
		if ((inputTypes.negated() && inputTypes.value().size() > 1) || inputTypes.type() == LabelExpression.Type.CONJUNCTION) {
			throw new UnsupportedOperationException("Expressions for relationship types are not supported in Cypher-DSL");
		}
		List<String> types = new ArrayList<>();
		traverseTypeExpression(types, inputTypes);
		return this.options.getTypeFilter()
			.apply(event, types)
			.toArray(new String[0]);
	}
	void traverseTypeExpression(List<String> types, LabelExpression expression) {
		if (expression.type() == LabelExpression.Type.LEAF || expression.type() == LabelExpression.Type.COLON_DISJUNCTION) {
			types.addAll(expression.value());
		} else {
			traverseTypeExpression(types, expression.lhs());
			traverseTypeExpression(types, expression.rhs());
		}
	}
	static void isInstanceOf(Class<?> type, Object obj, String message) {
		if (type == null) {
			throw new IllegalArgumentException("Type to check against must not be null");
		}
		if (!type.isInstance(obj)) {
			throw new IllegalArgumentException(message);
		}
	}
	private static void notNull(Object object, String message) {
		if (object == null) {
			throw new IllegalArgumentException(message);
		}
	}
	private <T extends Expression> T applyCallbacksFor(ExpressionCreatedEventType type, T newExpression) {
		return applyCallbacksFor(type, List.of(newExpression)).get(0);
	}
	@SuppressWarnings("unchecked")
	private <T extends Expression> List<T> applyCallbacksFor(ExpressionCreatedEventType type, List<T> expressions) {
		var callbacks = this.options.getOnNewExpressionCallbacks().getOrDefault(type, List.of());
		if (callbacks.isEmpty()) {
			return expressions;
		}
		var chainedCallbacks = callbacks.stream().reduce(Function.identity(), Function::andThen);
		return expressions.stream().map(e -> (T) chainedCallbacks.apply(e)).toList();
	}
	@SuppressWarnings("unchecked")
	private <T extends Visitable> T applyCallbacksFor(InvocationCreatedEventType type, T newExpression) {
		var callbacks = this.options.getOnNewInvocationCallbacks().getOrDefault(type, List.of());
		if (callbacks.isEmpty()) {
			return newExpression;
		}
		Visitable result = newExpression;
		for (UnaryOperator<Visitable> callback : callbacks) {
			result = callback.apply(result);
		}
		return (T) result;
	}
	private static SymbolicName assertSymbolicName(@Nullable Expression v) {
		if (v == null) {
			return null;
		}
		isInstanceOf(SymbolicName.class, v,  "An invalid type has been generated where a SymbolicName was required. Generated type was " + v.getClass().getName());
		return (SymbolicName) v;
	}
	@Override
	public Statements statements(List<Statement> statements) {
		return new Statements(statements);
	}
	@Override
	public Statement newSingleQuery(InputPosition p, List<Clause> clauses) {
		return newSingleQuery(clauses);
	}
	@Override
	public Statement newSingleQuery(List<Clause> clauses) {
		return Statement.of(clauses);
	}
	@Override
	public Statement newUnion(InputPosition p, Statement lhs, Statement rhs, boolean all) {
		if (all) {
			return Cypher.unionAll(lhs, rhs);
		} else {
			return Cypher.union(lhs, rhs);
		}
	}
	@Override
	public Clause directUseClause(InputPosition p, DatabaseName databaseName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause functionUseClause(InputPosition p, Expression function) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Finish newFinishClause(InputPosition p) {
		return Finish.create();
	}
	public List<Expression> newReturnItems(InputPosition p, boolean returnAll, List<Expression> returnItems) {
		var finalReturnItems = returnItems;
		if (returnAll) {
			finalReturnItems = Stream.concat(Stream.of(Cypher.asterisk()), finalReturnItems.stream()).toList();
		}
		if (finalReturnItems.isEmpty()) {
			if (!returnAll) {
				throw new IllegalArgumentException("Cannot return nothing.");
			}
			finalReturnItems = Collections.singletonList(Cypher.asterisk());
		}
		return finalReturnItems;
	}
	@Override
	public Return newReturnClause(InputPosition p, boolean distinct, List<Expression> returnItems, List<SortItem> sortItems,
		InputPosition orderPos, Expression skip, InputPosition skipPosition, Expression limit,
		InputPosition limitPosition) {
		return options.getReturnClauseFactory().apply(new ReturnDefinition(distinct, returnItems, sortItems, skip, limit));
	}
	@Override
	public Expression newReturnItem(InputPosition p, Expression e, Expression v) {
		var s = assertSymbolicName(v);
		return applyCallbacksFor(ExpressionCreatedEventType.ON_RETURN_ITEM, e.as(s));
	}
	@Override
	public Expression newReturnItem(InputPosition p, Expression e, int eStartOffset, int eEndOffset) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_RETURN_ITEM, e);
	}
	@Override
	public SortItem orderDesc(InputPosition p, Expression e) {
		return e.descending();
	}
	@Override
	public SortItem orderAsc(InputPosition p, Expression e) {
		return e.ascending();
	}
	@Override
	public Clause withClause(InputPosition p, Return returnClause, Where where) {
		return Clauses.with(returnClause, where);
	}
	@Override
	public Clause matchClause(InputPosition p, boolean optional, NULL matchMode, List<PatternElement> patternElements, InputPosition patternPos, List<Hint> hints, Where whereIn) {
		var patternElementCallbacks = this.options.getOnNewPatternElementCallbacks().getOrDefault(PatternElementCreatedEventType.ON_MATCH, List.of());
		List<PatternElement> openForTransformation = new ArrayList<>();
		for (PatternElement patternElement : patternElements) {
			if (patternElement instanceof NodeAtom nodeAtom) {
				openForTransformation.add(nodeAtom.value());
			} else {
				openForTransformation.add(patternElement);
			}
		}
		var transformedPatternElements = transformIfPossible(patternElementCallbacks, openForTransformation);
		return options.getMatchClauseFactory().apply(new MatchDefinition(optional, transformedPatternElements, whereIn, hints));
	}
	private List<PatternElement> transformIfPossible(List<UnaryOperator<PatternElement>> callbacks,
		List<PatternElement> patternElements) {
		if (callbacks.isEmpty()) {
			return patternElements;
		}
		@SuppressWarnings("squid:S4276") // The function is needed due to the assigment below
		var transformer = Function.<PatternElement>identity();
		for (UnaryOperator<PatternElement> callback : callbacks) {
			transformer = transformer.andThen(callback);
		}
		return patternElements.stream().map(transformer)
			.filter(Objects::nonNull)
			.toList();
	}
	@Override
	public Hint usingIndexHint(InputPosition p, Expression v, String labelOrRelType, List<String> properties,
		boolean seekOnly, HintIndexType indexType) {
		// We build nodes here. As of now, the node isn't used anyway, but only the label
		// will be used down further the AST.
		// It is easier than introduce a new common abstraction of label and relationship type (probably
		// in line with the decision made for the parser)
		var node = Cypher.node(labelOrRelType).named(assertSymbolicName(v));
		return Hint.useIndexFor(seekOnly, properties.stream().map(node::property).toArray(Property[]::new));
	}
	@Override
	public Hint usingJoin(InputPosition p, List<Expression> joinVariables) {
		return Hint.useJoinOn(joinVariables.stream().map(CypherDslASTFactory::assertSymbolicName).toArray(SymbolicName[]::new));
	}
	@Override
	public Hint usingScan(InputPosition p, Expression v, String label) {
		var s = assertSymbolicName(v);
		// Same note applies as with usingIndexHint in regard to relationships
		return Hint.useScanFor(Cypher.node(label).named(s));
	}
	@Override
	public Clause createClause(InputPosition p, List<PatternElement> patternElements) {
		var callbacks = this.options.getOnNewPatternElementCallbacks().getOrDefault(PatternElementCreatedEventType.ON_CREATE, List.of());
		return Clauses.create(transformIfPossible(callbacks, patternElements.stream().map(v -> v instanceof NodeAtom n ? n.value() : v).toList()));
	}
	@Override
	public Clause insertClause(InputPosition p, List<PatternElement> patternElements) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause setClause(InputPosition p, List<Expression> setItems) {
		return Clauses.set(setItems);
	}
	@Override
	public Operation setProperty(Property property, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_PROPERTY, property.to(value));
	}
	@Override
	public Expression setDynamicProperty(Expression dynamicProperty, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_PROPERTY, Cypher.set(dynamicProperty, value));
	}
	@Override
	public Operation setVariable(Expression v, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_VARIABLE, Cypher.set(v, value));
	}
	@Override
	public Operation addAndSetVariable(Expression v, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_ADD_AND_SET_VARIABLE, Cypher.mutate(v, value));
	}
	@Override
	public Expression setLabels(Expression v, List<StringPos<InputPosition>> values, List<Expression> dynamicLabels, boolean containsIs) {
		var s = assertSymbolicName(v);
		var labels = computeFinalLabelList(LabelParsedEventType.ON_SET, values);
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_LABELS, Cypher.setLabel(Cypher.anyNode(s), labels));
	}
	@Override
	public Clause removeClause(InputPosition p, List<Expression> removeItems) {
		return Clauses.remove(removeItems);
	}
	@Override
	public Expression removeProperty(Property property) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_REMOVE_PROPERTY, property);
	}
	@Override
	public Expression removeDynamicProperty(Expression dynamicProperty) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_REMOVE_PROPERTY, dynamicProperty);
	}
	@Override
	public Expression removeLabels(Expression v, List<StringPos<InputPosition>> values,
		List<Expression> dynamicLabels, boolean containsIs) {
		var s = assertSymbolicName(v);
		var labels = computeFinalLabelList(LabelParsedEventType.ON_REMOVE, values);
		return applyCallbacksFor(ExpressionCreatedEventType.ON_REMOVE_LABELS, Cypher.removeLabel(Cypher.anyNode(s), labels));
	}
	@Override
	public Clause deleteClause(InputPosition p, boolean detach, List<Expression> expressions) {
		return Clauses.delete(detach, applyCallbacksFor(ExpressionCreatedEventType.ON_DELETE_ITEM, expressions));
	}
	@Override
	public Clause unwindClause(InputPosition p, Expression e, Expression v) {
		return Clauses.unwind(e, assertSymbolicName(v));
	}
	@Override
	public Clause mergeClause(InputPosition p, PatternElement patternElementIn, List<Clause> setClauses,
		List<MergeActionType> actionTypes, List<InputPosition> positions) {
		var patternElement = patternElementIn instanceof NodeAtom n ? n.value() : patternElementIn;
		var mergeActions = new ArrayList<MergeAction>();
		if (setClauses != null && !setClauses.isEmpty() && actionTypes != null && !actionTypes.isEmpty()) {
			var iteratorClauses = setClauses.iterator();
			var iteratorTypes = actionTypes.iterator();
			while (iteratorClauses.hasNext() && iteratorTypes.hasNext()) {
				var type = iteratorTypes.next();
				switch (type) {
					case OnCreate ->
						mergeActions.add(MergeAction.of(MergeAction.Type.ON_CREATE, (Set) iteratorClauses.next()));
					case OnMatch ->
						mergeActions.add(MergeAction.of(MergeAction.Type.ON_MATCH, (Set) iteratorClauses.next()));
					default -> throw new IllegalArgumentException("Unsupported MergeActionType: " + type);
				}
			}
		}
		var callbacks = this.options.getOnNewPatternElementCallbacks().getOrDefault(PatternElementCreatedEventType.ON_MERGE, List.of());
		return Clauses.merge(transformIfPossible(callbacks, List.of(patternElement)), mergeActions);
	}
	@Override
	public Clause callClause(InputPosition p, InputPosition namespacePosition, InputPosition procedureNamePosition,
		InputPosition procedureResultPosition, List<String> namespace, String name, List<Expression> arguments,
		boolean yieldAll, List<Expression> resultItems, Where where, boolean optional) {
		var intermediateResult = Clauses.callClause(namespace, name, arguments,
			yieldAll && resultItems == null ? List.of(Cypher.asterisk()) : resultItems, where);
		if (optional) {
			throw new IllegalArgumentException("Cannot render optional call clause");
		}
		return applyCallbacksFor(InvocationCreatedEventType.ON_CALL, intermediateResult);
	}
	@Override
	public Expression callResultItem(InputPosition p, String name, Expression alias) {
		var finalName = Cypher.name(name);
		if (alias != null) {
			return finalName.as(assertSymbolicName(alias));
		}
		return finalName;
	}
	@Override
	public PatternElement patternWithSelector(NULL aNull, PatternElement patternPart) {
		return null;
	}
	@Override
	public PatternElement namedPattern(Expression v, PatternElement patternElement) {
		return Cypher.path(assertSymbolicName(v)).definedBy(patternElement);
	}
	@Override
	public PatternElement shortestPathPattern(InputPosition p, PatternElement patternElement) {
		isInstanceOf(RelationshipPattern.class, patternElement,
			"Only relationship patterns are supported for the shortestPath function.");
		return new ExpressionAsPatternElementWrapper(
			FunctionInvocation.create(PatternElementFunctions.SHORTEST_PATH, patternElement));
	}
	@Override
	public PatternElement allShortestPathsPattern(InputPosition p, PatternElement patternElement) {
		isInstanceOf(RelationshipPattern.class, patternElement,
			"Only relationship patterns are supported for the allShortestPaths function.");
		return new ExpressionAsPatternElementWrapper(
			FunctionInvocation.create(PatternElementFunctions.ALL_SHORTEST_PATHS, patternElement));
	}
	@Override
	public PatternElement pathPattern(PatternElement patternElement) {
		return patternElement;
	}
	@Override
	public PatternElement insertPathPattern(List<PatternAtom> patternAtoms) {
		throw new UnsupportedOperationException();
	}
	static class PatternJuxtaposition extends TypedSubtree<PatternElement> implements PatternElement {
		PatternJuxtaposition(Collection<PatternElement> children) {
			super(children);
		}
		@Override
		public String separator() {
			return " ";
		}
	}
	static class PatternList extends TypedSubtree<PatternElement> implements PatternElement {
		PatternList(Collection<PatternElement> children) {
			super(children);
		}
	}
	@SuppressWarnings("squid:S3776") // Yep, it's complex
	@Override
	public PatternElement patternElement(List<PatternAtom> atoms) {
		if (atoms.isEmpty()) {
			throw new IllegalArgumentException(
				"Cannot create a PatternElement from an empty list of patterns.");
		}
		if (atoms.size() == 1 && atoms.get(0) instanceof ParenthesizedPathPatternAtom atom) {
			return atom.asPatternElement();
		}
		List<PatternElement> patternElements = new ArrayList<>();
		NodeAtom lastNodeAtom = null;
		PathAtom lastPathAtom = null;
		ExposesRelationships<?> relationshipPattern = null;
		List<PatternElement> patternList = null;
		for (PatternAtom atom : atoms) {
			if (atom instanceof ParenthesizedPathPatternAtom specificAtom) {
				if (lastNodeAtom != null) {
					patternElements.add(lastNodeAtom.value());
				}
				if (relationshipPattern != null) {
					patternElements.add((PatternElement) relationshipPattern);
				}
				if (patternList != null) {
					patternElements.add(new PatternList(patternList));
				}
				lastNodeAtom = null;
				lastPathAtom = null;
				relationshipPattern = null;
				patternList = null;
				patternElements.add(specificAtom.asPatternElement());
			} else if (atom instanceof NodeAtom nodeAtom) {
				if (relationshipPattern != null) {
					relationshipPattern = lastPathAtom.asRelationshipBetween(relationshipPattern, nodeAtom,
						options.isAlwaysCreateRelationshipsLTR());
				} else if (lastNodeAtom == null) {
					lastNodeAtom = nodeAtom;
				} else {
					relationshipPattern = lastNodeAtom.value();
					lastNodeAtom = null;
					// Will be added to the pattern elements either on the occurrence of a parenthesized pattern or
					// after iterating all atoms.
					relationshipPattern = lastPathAtom.asRelationshipBetween(relationshipPattern, nodeAtom,
						options.isAlwaysCreateRelationshipsLTR());
					if ((lastPathAtom.getDirection() == Relationship.Direction.RTL || patternList != null)
						&& options.isAlwaysCreateRelationshipsLTR()) {
						if (patternList == null) {
							patternList = new ArrayList<>();
						}
						patternList.add(((PatternElement) relationshipPattern));
						relationshipPattern = null;
						lastNodeAtom = nodeAtom;
					}
				}
			} else if (atom instanceof PathAtom pathAtom) {
				lastPathAtom = pathAtom;
			}
		}
		if (relationshipPattern == null && patternList != null && patternList.size() == 1 && patternList.get(0) instanceof RelationshipPattern singleListItem) {
			relationshipPattern = singleListItem;
			patternList = null;
		}
		if (relationshipPattern != null) {
			patternElements.add((PatternElement) relationshipPattern);
		} else if (patternList != null) {
			patternElements.add(new PatternList(patternList));
		} else if (lastNodeAtom != null) {
			patternElements.add(lastNodeAtom.value());
		}
		return patternElements.size() == 1 ? patternElements.get(0) : new PatternJuxtaposition(patternElements);
	}
	@Override
	public NULL anyPathSelector(String count, InputPosition countPosition, InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allPathSelector(InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL anyShortestPathSelector(String count, InputPosition countPosition, InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allShortestPathSelector(InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL shortestGroupsSelector(String count, InputPosition countPosition, InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NodeAtom nodePattern(InputPosition p, Expression v, LabelExpression labels, Expression properties, Expression predicate) {
		Node node;
		if (labels == null) {
			node = Cypher.anyNode();
		} else {
			var finalLabels = computeFinalLabelList(LabelParsedEventType.ON_NODE_PATTERN, labels);
			node = finalLabels.map(l -> {
				var primaryLabel = l[0];
				var additionalLabels = Arrays.stream(l).skip(1).toList();
				return Cypher.node(primaryLabel, additionalLabels);
			}).orElseGet(() -> Cypher.node(labels));
		}
		if (v != null) {
			node = node.named(assertSymbolicName(v));
		}
		if (properties != null) {
			node = node.withProperties((MapExpression) properties);
		}
		if (predicate != null) {
			node = (Node) node.where(predicate);
		}
		return new NodeAtom(node);
	}
	@Override
	public PathAtom relationshipPattern(InputPosition p, boolean left, boolean right, Expression v, LabelExpression relTypes, PathLength pathLength, Expression properties, Expression predicate) {
		return PathAtom.of(assertSymbolicName(v), pathLength, left, right,
			computeFinalTypeList(TypeParsedEventType.ON_RELATIONSHIP_PATTERN, relTypes), (MapExpression) properties,
			relTypes != null && relTypes.negated(), predicate);
	}
	@Override
	public PathLength pathLength(InputPosition p, InputPosition pMin, InputPosition pMax, String minLength,
		String maxLength) {
		return PathLength.of(minLength, maxLength);
	}
	@Override
	public QuantifiedPathPattern.Quantifier intervalPathQuantifier(InputPosition p, InputPosition posLowerBound, InputPosition posUpperBound, String lowerBound, String upperBound) {
		return QuantifiedPathPattern.interval(lowerBound == null ? null : Integer.parseInt(lowerBound), upperBound == null ? null : Integer.parseInt(upperBound));
	}
	@Override
	public QuantifiedPathPattern.Quantifier fixedPathQuantifier(InputPosition p, InputPosition valuePos, String value) {
		throw new UnsupportedOperationException();
	}
	@Override
	public QuantifiedPathPattern.Quantifier plusPathQuantifier(InputPosition p) {
		return QuantifiedPathPattern.plus();
	}
	@Override
	public QuantifiedPathPattern.Quantifier starPathQuantifier(InputPosition p) {
		return QuantifiedPathPattern.star();
	}
	@Override
	public NULL repeatableElements(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL differentRelationships(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public PatternAtom parenthesizedPathPattern(InputPosition p, PatternElement internalPattern, Expression where, QuantifiedPathPattern.Quantifier pathPatternQuantifier) {
		return new ParenthesizedPathPatternAtom((RelationshipPattern) internalPattern, pathPatternQuantifier, where);
	}
	@Override
	public PatternAtom quantifiedRelationship(PathAtom rel, QuantifiedPathPattern.Quantifier pathPatternQuantifier) {
		return rel.withQuantifier(pathPatternQuantifier);
	}
	@Override
	public Clause loadCsvClause(InputPosition p, boolean headers, Expression source, Expression v,
		String fieldTerminator) {
		isInstanceOf(StringLiteral.class, source, "Only string literals are supported as source for the LOAD CSV clause.");
		return Clauses.loadCSV(headers, (StringLiteral) source, assertSymbolicName(v), fieldTerminator);
	}
	@Override
	public Clause foreachClause(InputPosition p, Expression v, Expression list, List<Clause> objects) {
		return Clauses.forEach(assertSymbolicName(v), list, objects);
	}
	@Override
	public Clause subqueryClause(InputPosition p, Statement subquery, NULL inTransactions, boolean scopeAll,
		boolean hasScope, List<Expression> expressions, boolean optional) {
		if (optional) {
			throw new IllegalArgumentException("Cannot render optional subquery clause");
		}
		return Clauses.callClause(subquery);
	}
	@Override
	public NULL subqueryInTransactionsParams(InputPosition p, NULL batchParams, NULL concurrencyParams,
		NULL errorParams, NULL reportParams) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause yieldClause(InputPosition p, boolean returnAll, List<Expression> expressions,
		InputPosition returnItemsPosition, List<SortItem> orderBy, InputPosition orderPos, Expression skip,
		InputPosition skipPosition, Expression limit, InputPosition limitPosition, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showIndexClause(InputPosition p, ShowCommandFilterTypes indexType, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showConstraintClause(InputPosition p, ShowCommandFilterTypes constraintType, Where where,
		Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showProcedureClause(InputPosition p, boolean currentUser, String user, Where where,
		Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showFunctionClause(InputPosition p, ShowCommandFilterTypes functionType, boolean currentUser,
		String user, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement useGraph(Statement command, Clause useGraph) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showRoles(InputPosition p, boolean withUsers, boolean showAll, Clause yieldExpr,
		Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement grantRoles(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement revokeRoles(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createUser(InputPosition p, boolean replace, boolean ifNotExists,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Boolean suspended, DatabaseName homeDatabase,
		List<NULL> nulls, List<NULL> systemAuthAttributes) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropUser(InputPosition p, boolean ifExists,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement renameUser(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> fromUserName,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> toUserName, boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement setOwnPassword(InputPosition p, Expression currentPassword, Expression newPassword) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL auth(String provider, List<NULL> nulls, InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL authId(InputPosition s, Expression id) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL password(InputPosition p, Expression password, boolean encrypted) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL passwordChangeRequired(InputPosition p, boolean changeRequired) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterUser(InputPosition p, boolean ifExists,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Boolean suspended, DatabaseName homeDatabase,
		boolean removeHome, List<NULL> nulls, List<NULL> systemAuthAttributes, boolean removeAllAuth,
		List<Expression> removeAuths) {
		throw new UnsupportedOperationException();
	}
	@Override public Expression passwordExpression(Parameter<?> password) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression passwordExpression(InputPosition s, InputPosition e, String password) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showUsers(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where,
		boolean withAuth) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showCurrentUser(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showSupportedPrivileges(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showAllPrivileges(InputPosition p, boolean asCommand, boolean asRevoke, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showRolePrivileges(InputPosition p,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles, boolean asCommand, boolean asRevoke,
		Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showUserPrivileges(InputPosition p,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users, boolean asCommand, boolean asRevoke,
		Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement grantPrivilege(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		NULL privilege) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement denyPrivilege(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		NULL privilege) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement revokePrivilege(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		NULL privilege, boolean revokeGrant, boolean revokeDeny) {
		throw new UnsupportedOperationException();
	}
	@SuppressWarnings("HiddenField") // The database options are quite different options than ours ;)
	public Statement createDatabase(InputPosition p, boolean replace, DatabaseName databaseName, boolean ifNotExists,
		NULL aNull, SimpleEither<Map<String, Expression>, Parameter<?>> options,
		SimpleEither<Integer, Parameter<?>> topologyPrimaries,
		SimpleEither<Integer, Parameter<?>> topologySecondaries) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createCompositeDatabase(InputPosition p, boolean replace, DatabaseName compositeDatabaseName,
		boolean ifNotExists, SimpleEither<Map<String, Expression>, Parameter<?>> databaseOptions, NULL aNull) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropDatabase(InputPosition p, DatabaseName databaseName, boolean ifExists, boolean composite,
		boolean aliasAction, boolean dumpData, NULL wait) {
		throw new UnsupportedOperationException();
	}
	@SuppressWarnings("HiddenField") // The database options are quite different options than ours ;)
	@Override
	public Statement alterDatabase(InputPosition p, DatabaseName databaseName, boolean ifExists, AccessType accessType,
		SimpleEither<Integer, Parameter<?>> topologyPrimaries, SimpleEither<Integer, Parameter<?>> topologySecondaries,
		Map<String, Expression> options, java.util.Set<String> optionsToRemove, NULL aNull) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showDatabase(InputPosition p, NULL scope, Clause yieldExpr, Return returnWithoutGraph,
		Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement startDatabase(InputPosition p, DatabaseName databaseName, NULL wait) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement stopDatabase(InputPosition p, DatabaseName databaseName, NULL wait) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databaseScope(InputPosition p, DatabaseName databaseName, boolean isDefault, boolean isHome) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropAlias(InputPosition p, DatabaseName aliasName, boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showAliases(InputPosition p, DatabaseName aliasName, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public void addDeprecatedIdentifierUnicodeNotification(InputPosition p, Character character, String identifier) {
	}
	@Override
	public NULL wait(boolean wait, long seconds) {
		throw new UnsupportedOperationException();
	}
	@Override
	public DatabaseName databaseName(InputPosition p, List<String> names) {
		if (names.isEmpty()) {
			throw new IllegalArgumentException("No database name");
		}
		if (names.size() == 1) {
			return new DatabaseName(Cypher.literalOf(names.get(0)));
		}
		return new DatabaseName(Cypher.literalOf(names));
	}
	@Override
	public DatabaseName databaseName(Parameter<?> param) {
		return new DatabaseName(param);
	}
	@Override
	public Statement createLocalDatabaseAlias(InputPosition p, boolean replace, DatabaseName aliasName,
		DatabaseName targetName, boolean ifNotExists, SimpleEither<Map<String, Expression>, Parameter<?>> properties
	) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createRemoteDatabaseAlias(InputPosition p, boolean replace, DatabaseName aliasName,
		DatabaseName targetName, boolean ifNotExists, SimpleEither<String, Parameter<?>> url,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Expression password,
		SimpleEither<Map<String, Expression>, Parameter<?>> driverSettings,
		SimpleEither<Map<String, Expression>, Parameter<?>> properties) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterLocalDatabaseAlias(InputPosition p, DatabaseName aliasName, DatabaseName targetName,
		boolean ifExists, SimpleEither<Map<String, Expression>, Parameter<?>> properties
	) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterRemoteDatabaseAlias(InputPosition p, DatabaseName aliasName, DatabaseName targetName,
		boolean ifExists, SimpleEither<String, Parameter<?>> url,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Expression password,
		SimpleEither<Map<String, Expression>, Parameter<?>> driverSettings,
		SimpleEither<Map<String, Expression>, Parameter<?>> properties) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression newVariable(InputPosition p, String name) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_VARIABLE, Cypher.name(name));
	}
	@Override
	public Parameter<?> newParameter(InputPosition p, Expression v, ParameterType type) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_PARAMETER, parameterFromSymbolicName(v));
	}
	@Override
	public Parameter<?> newParameter(InputPosition p, String v, ParameterType type) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_PARAMETER, parameterFromSymbolicName(Cypher.name(v)));
	}
	@Override
	public Parameter<?> newSensitiveStringParameter(InputPosition p, Expression v) {
		throw new UnsupportedOperationException("The Cypher-DSL does not support sensitive parameters.");
	}
	@Override
	public Parameter<?> newSensitiveStringParameter(InputPosition p, String v) {
		throw new UnsupportedOperationException("The Cypher-DSL does not support sensitive parameters.");
	}
	@NotNull
	Parameter<?> parameterFromSymbolicName(Expression v) {
		var symbolicName = assertSymbolicName(v);
		if (symbolicName == null) {
			return Cypher.anonParameter(Cypher.literalNull());
		}
		var name = symbolicName.getValue();
		return options.getParameterValues().containsKey(name) ? Cypher.parameter(name, options.getParameterValues().get(name)) : Cypher.parameter(name);
	}
	@Override
	public Expression newDouble(InputPosition p, String image) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Double.parseDouble(image)));
	}
	@Override
	public Expression newDecimalInteger(InputPosition p, String image, boolean negated) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Long.parseUnsignedLong(image) * (negated ? -1 : 1)));
	}
	@Override public Expression newHexInteger(InputPosition p, String image, boolean negated) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Long.parseUnsignedLong(image.replaceFirst("(?i)0x", ""), 16) * (negated ? -1 : 1)));
	}
	@Override public Expression newOctalInteger(InputPosition p, String image, boolean negated) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Long.parseUnsignedLong(image.replaceFirst("(?i)0o", ""), 8) * (negated ? -1 : 1)));
	}
	@Override
	public Expression newString(InputPosition start, InputPosition end, String image) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(image));
	}
	@Override
	public Expression newTrueLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalTrue());
	}
	@Override
	public Expression newFalseLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalFalse());
	}
	@Override
	public Expression newInfinityLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, InfinityLiteral.INSTANCE);
	}
	@Override
	public Expression newNaNLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, NaNLiteral.INSTANCE);
	}
	@Override
	public Expression newNullLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalNull());
	}
	@Override
	public Expression listLiteral(InputPosition p, List<Expression> values) {
		return Cypher.listOf(values.toArray(new Expression[0]));
	}
	@Override
	public MapExpression mapLiteral(InputPosition p, List<StringPos<InputPosition>> keys, List<Expression> values) {
		Object[] keysAndValues = new Object[keys.size() * 2];
		int i = 0;
		Iterator<Expression> valueIterator = values.iterator();
		for (StringPos<InputPosition> key : keys) {
			keysAndValues[i++] = key.string;
			keysAndValues[i++] = valueIterator.next();
		}
		return options.isCreateSortedMaps() ? Cypher.sortedMapOf(keysAndValues) : Cypher.mapOf(keysAndValues);
	}
	@Override
	public Property property(Expression subject, StringPos<InputPosition> propertyKeyName) {
		return subject.property(propertyKeyName.string);
	}
	@Override
	public Expression or(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.asCondition().or(rhs.asCondition());
	}
	@Override
	public Expression xor(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.asCondition().xor(rhs.asCondition());
	}
	@Override
	public Expression and(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.asCondition().and(rhs.asCondition());
	}
	@Override
	public LabelExpression labelConjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return lhs.and(rhs);
	}
	@Override
	public LabelExpression labelDisjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return lhs.or(rhs);
	}
	@Override
	public LabelExpression labelNegation(InputPosition p, LabelExpression e, boolean containsIs) {
		return e.negate();
	}
	@Override
	public LabelExpression labelWildcard(InputPosition p, boolean containsIs) {
		throw new UnsupportedOperationException();
	}
	@Override
	public LabelExpression labelLeaf(InputPosition p, String e, EntityType entityType, boolean containsIs) {
		return new LabelExpression(e);
	}
	@Override
	public LabelExpression labelColonConjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return colonJunjction(lhs, rhs, LabelExpression.Type.COLON_CONJUNCTION);
	}
	@Override
	public LabelExpression labelColonDisjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return colonJunjction(lhs, rhs, LabelExpression.Type.COLON_DISJUNCTION);
	}
	@NotNull
	private static LabelExpression colonJunjction(LabelExpression lhs, LabelExpression rhs, LabelExpression.Type colonDisjunction) {
		List<String> value = new ArrayList<>();
		value.addAll(lhs.value());
		value.addAll(rhs.value());
		return new LabelExpression(colonDisjunction, false, value, null, null);
	}
	@Override
	public Expression labelExpressionPredicate(Expression subject, LabelExpression exp) {
		if (!(subject instanceof SymbolicName symbolicName)) {
			throw new IllegalArgumentException("Expected an symbolic name to create a label based expression predicate!");
		} else {
			List<String> values = new ArrayList<>();
			LabelExpression current = exp;
			while (current != null) {
				values.addAll(current.value());
				current = current.rhs();
			}
			return Cypher.hasLabelsOrType(symbolicName, values.toArray(String[]::new));
		}
	}
	@Override
	public Expression ands(List<Expression> exprs) {
		return exprs.stream().reduce(Cypher.noCondition(), (l, r) -> l.asCondition().and(r.asCondition()));
	}
	@Override
	public Expression not(InputPosition p, Expression e) {
		return e.asCondition().not();
	}
	@Override
	public Expression plus(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.add(rhs);
	}
	@Override
	public Expression minus(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.subtract(rhs);
	}
	@Override
	public Expression concatenate(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.concat(rhs);
	}
	@Override
	public Expression multiply(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.multiply(rhs);
	}
	@Override
	public Expression divide(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.divide(rhs);
	}
	@Override
	public Expression modulo(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.remainder(rhs);
	}
	@Override
	public Expression pow(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.pow(rhs);
	}
	@Override public Expression unaryPlus(Expression e) {
		return Cypher.plus(e);
	}
	@Override
	public Expression unaryPlus(InputPosition inputPosition, Expression expression) {
		return Cypher.plus(expression);
	}
	@Override
	public Expression unaryMinus(InputPosition inputPosition, Expression expression) {
		return Cypher.minus(expression);
	}
	@Override
	public Expression eq(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.eq(rhs);
	}
	@Override
	public Expression neq(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.ne(rhs);
	}
	@Override
	public Expression neq2(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.ne(rhs);
	}
	@Override
	public Expression lte(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.lte(rhs);
	}
	@Override
	public Expression gte(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.gte(rhs);
	}
	@Override
	public Expression lt(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.lt(rhs);
	}
	@Override
	public Expression gt(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.gt(rhs);
	}
	@Override
	public Expression regeq(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.matches(rhs);
	}
	@Override
	public Expression startsWith(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.startsWith(rhs);
	}
	@Override
	public Expression endsWith(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.endsWith(rhs);
	}
	@Override
	public Expression contains(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.contains(rhs);
	}
	@Override
	public Expression in(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.in(rhs);
	}
	@Override
	public Expression isNull(InputPosition p, Expression e) {
		return e.isNull();
	}
	@Override
	public Expression isNotNull(InputPosition p, Expression e) {
		return e.isNotNull();
	}
	@Override
	public Expression isTyped(InputPosition p, Expression e, ParserCypherTypeName typeName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression isNotTyped(InputPosition p, Expression e, ParserCypherTypeName typeName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression isNormalized(InputPosition p, Expression e, ParserNormalForm normalForm) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression isNotNormalized(InputPosition p, Expression e, ParserNormalForm normalForm) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression listLookup(Expression list, Expression index) {
		return Cypher.valueAt(list, index);
	}
	@Override
	public Expression listSlice(InputPosition p, Expression list, Expression start, Expression end) {
		return Cypher.subList(list, start, end);
	}
	@Override
	public Expression newCountStar(InputPosition p) {
		return Cypher.count(Cypher.asterisk());
	}
	@Override
	public Expression functionInvocation(InputPosition p, InputPosition functionNamePosition, List<String> namespace,
		String name, boolean distinct, List<Expression> arguments, boolean calledFromUseClause) {
		String[] parts = new String[namespace.size() + 1];
		for (int i = 0; i < namespace.size(); i++) {
			parts[i] = namespace.get(i);
		}
		parts[parts.length - 1] = name;
		var expression = Cypher.call(parts).withArgs(arguments.toArray(Expression[]::new)).asFunction(distinct);
		return applyCallbacksFor(InvocationCreatedEventType.ON_INVOCATION, expression);
	}
	@Override
	public Expression listComprehension(InputPosition p, Expression v, Expression list, Expression where,
		Expression projection) {
		var in = Cypher.listWith(assertSymbolicName(v)).in(list);
		if (where != null) {
			var ongoingComprehension = in.where(where.asCondition());
			if (projection != null) {
				return ongoingComprehension.returning(projection);
			}
			return ongoingComprehension.returning();
		}
		return in.returning(projection);
	}
	@Override
	public Expression patternComprehension(InputPosition p, InputPosition relationshipPatternPosition, Expression v, PatternElement patternElement,
		Expression where, Expression projection) {
		PatternComprehension.OngoingDefinitionWithoutReturn ongoingDefinitionWithPattern;
		if (patternElement instanceof RelationshipPattern relationshipPattern) {
			if (v != null) {
				ongoingDefinitionWithPattern = Cypher.listBasedOn(Cypher.path(assertSymbolicName(v)).definedBy(relationshipPattern));
			} else {
				ongoingDefinitionWithPattern = Cypher.listBasedOn(relationshipPattern);
			}
		} else if (patternElement instanceof NamedPath namedPath) {
			ongoingDefinitionWithPattern = Cypher.listBasedOn(namedPath);
		} else {
			throw new IllegalArgumentException(
				"Cannot build a pattern comprehension around " + patternElement.getClass().getSimpleName());
		}
		if (where != null) {
			ongoingDefinitionWithPattern = ((PatternComprehension.OngoingDefinitionWithPattern) ongoingDefinitionWithPattern)
				.where(where.asCondition());
		}
		return ongoingDefinitionWithPattern.returning(projection);
	}
	@Override
	public Expression reduceExpression(InputPosition p, Expression acc, Expression accExpr, Expression v,
		Expression list, Expression innerExpr) {
		var variable = assertSymbolicName(v);
		if (variable == null) {
			throw new IllegalArgumentException("A variable to be reduced must be present.");
		}
		return Cypher.reduce(variable)
			.in(list)
			.map(innerExpr)
			.accumulateOn(assertSymbolicName(acc))
			.withInitialValueOf(accExpr);
	}
	@Override
	public Expression allExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "all(...) requires a WHERE predicate");
		return Cypher.all(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression anyExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "any(...) requires a WHERE predicate");
		return Cypher.any(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression noneExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "none(...) requires a WHERE predicate");
		return Cypher.none(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression singleExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "single(...) requires a WHERE predicate");
		return Cypher.single(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression normalizeExpression(InputPosition p, Expression i, ParserNormalForm normalForm) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression trimFunction(InputPosition inputPosition, ParserTrimSpecification parserTrimSpecification,
		Expression expression, Expression expression1) {
		var call = switch (parserTrimSpecification) {
			case BOTH -> Cypher.call("trim");
			case LEADING -> Cypher.call("ltrim");
			case TRAILING -> Cypher.call("rtrim");
		};
		return call.withArgs(
				expression == null ? new Expression[] {expression1} : new Expression[] {expression1, expression})
			.asFunction();
	}
	@Override
	public Expression patternExpression(InputPosition p, PatternElement patternElement) {
		if (patternElement instanceof ExpressionAsPatternElementWrapper wrapper) {
			return wrapper.getExpression();
		}
		if (patternElement instanceof RelationshipPattern relationshipPattern) {
			return new PatternElementAsExpressionWrapper(relationshipPattern);
		}
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression existsExpression(InputPosition p, NULL matchMode, List<PatternElement> patternElements, Statement q, Where where) {
		if (q == null) {
			return Cypher.exists(patternElements, where);
		} else {
			return Cypher.exists(q);
		}
	}
	@Override
	public Expression countExpression(InputPosition p, NULL matchMode, List<PatternElement> patternElements, Statement q, Where where) {
		if (q == null) {
			return Cypher.count(patternElements, where);
		} else {
			return Cypher.count(q);
		}
	}
	@Override
	public Expression collectExpression(InputPosition inputPosition, Statement statement) {
		return Cypher.collect(statement);
	}
	@Override
	public Expression mapProjection(InputPosition p, Expression v, List<Expression> items) {
		return options.isCreateSortedMaps() ?
			MapProjection.sorted(assertSymbolicName(v), items.toArray(new Object[0])) :
			MapProjection.create(assertSymbolicName(v), items.toArray(new Object[0]));
	}
	@Override
	public Expression mapProjectionLiteralEntry(StringPos<InputPosition> property, Expression value) {
		return KeyValueMapEntry.create(property.string, value);
	}
	@Override
	public Expression mapProjectionProperty(StringPos<InputPosition> property) {
		return PropertyLookup.forName(property.string);
	}
	@Override
	public Expression mapProjectionVariable(Expression v) {
		return v;
	}
	@Override
	public Expression mapProjectionAll(InputPosition p) {
		return Cypher.asterisk();
	}
	@Override
	public Expression caseExpression(InputPosition p, Expression e, List<Expression> whens, List<Expression> thens,
		Expression elze) {
		if (whens != null && thens != null && whens.size() != thens.size()) {
			throw new IllegalArgumentException("Cannot combine lists of whens with a different sized list of thens.");
		}
		var aCase = Cypher.caseExpression(e);
		if (whens != null && thens != null) {
			var iteratorWhens = whens.iterator();
			var iteratorThens = thens.iterator();
			while (iteratorWhens.hasNext() && iteratorThens.hasNext()) {
				aCase = aCase.when(iteratorWhens.next()).then(iteratorThens.next());
			}
			if (elze != null) {
				return ((Case.CaseEnding) aCase).elseDefault(elze);
			}
			return aCase;
		}
		return aCase;
	}
	@Override
	public InputPosition inputPosition(int offset, int line, int column) {
		return new InputPosition(offset, line, column);
	}
	@Override
	public EntityType nodeType() {
		return EntityType.NODE;
	}
	@Override
	public EntityType relationshipType() {
		return EntityType.RELATIONSHIP;
	}
	@Override
	public EntityType nodeOrRelationshipType() {
		return EntityType.LOLWHAT;
	}
	@Override
	public Where whereClause(InputPosition p, Expression optionalWhere) {
		return Where.from(optionalWhere);
	}
	@Override
	public NULL subqueryInTransactionsBatchParameters(InputPosition p, Expression batchSize) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL subqueryInTransactionsConcurrencyParameters(InputPosition p, Expression concurrency) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL subqueryInTransactionsErrorParameters(InputPosition p, CallInTxsOnErrorBehaviourType onErrorBehaviour) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL subqueryInTransactionsReportParameters(InputPosition p, Expression v) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause orderBySkipLimitClause(InputPosition inputPosition, List<SortItem> list, InputPosition pos1,
		Expression expression, InputPosition pos2, Expression expression1, InputPosition pos3) {
		return null;
	}
	@Override
	public Clause showTransactionsClause(InputPosition p, SimpleEither<List<String>, Expression> ids, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause terminateTransactionsClause(InputPosition p, SimpleEither<List<String>, Expression> ids, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showSettingsClause(InputPosition p, SimpleEither<List<String>, Expression> names, Where where,
		Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause turnYieldToWith(Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createConstraint(InputPosition p, ConstraintType constraintType, boolean replace,
		boolean ifNotExists, SimpleEither<StringPos<InputPosition>, Parameter<?>> constraintName, Expression expression,
		StringPos<InputPosition> label, List<Property> properties, ParserCypherTypeName propertyType,
		SimpleEither<Map<String, Expression>, Parameter<?>> constraintOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropConstraint(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> name,
		boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createLookupIndex(InputPosition p, boolean replace, boolean ifNotExists, boolean isNode,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> indexName, Expression expression,
		StringPos<InputPosition> functionName, Expression functionParameter,
		SimpleEither<Map<String, Expression>, Parameter<?>> indexOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createIndex(InputPosition p, boolean replace, boolean ifNotExists, boolean isNode,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> indexName, Expression expression,
		StringPos<InputPosition> label, List<Property> properties,
		SimpleEither<Map<String, Expression>, Parameter<?>> indexOptions, CreateIndexTypes indexType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createFulltextIndex(InputPosition p, boolean replace, boolean ifNotExists, boolean isNode,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> indexName, Expression expression,
		List<StringPos<InputPosition>> labels, List<Property> properties,
		SimpleEither<Map<String, Expression>, Parameter<?>> indexOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropIndex(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> name,
		boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createRole(InputPosition p, boolean replace,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> roleName,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> fromRole, boolean ifNotExists, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropRole(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> roleName,
		boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement renameRole(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> fromRoleName,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> toRoleName, boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databasePrivilege(InputPosition p, NULL aNull, NULL aNull2, List<NULL> qualifier, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL dbmsPrivilege(InputPosition p, NULL aNull, List<NULL> qualifier, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL loadPrivilege(InputPosition inputPosition, SimpleEither<String, Parameter<?>> simpleEither,
		SimpleEither<String, Parameter<?>> simpleEither1, boolean b) {
		return null;
	}
	@Override
	public NULL graphPrivilege(InputPosition inputPosition, NULL aNull, NULL aNull2, NULL aNull3, List<NULL> qualifier, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL privilegeAction(ActionType action) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL propertiesResource(InputPosition p, List<String> property) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allPropertiesResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL labelsResource(InputPosition p, List<String> label) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allLabelsResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databaseResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL noResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL labelQualifier(InputPosition p, String label) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL relationshipQualifier(InputPosition p, String relationshipType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL elementQualifier(InputPosition p, String name) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allElementsQualifier(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL patternQualifier(List<NULL> list, Expression expression, Expression expression2) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allLabelsQualifier(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allRelationshipsQualifier(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> allQualifier() {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> allDatabasesQualifier() {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> userQualifier(List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> allUsersQualifier() {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> functionQualifier(InputPosition p, List<String> functions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> procedureQualifier(InputPosition p, List<String> procedures) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> settingQualifier(InputPosition inputPosition, List<String> list) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL graphScope(InputPosition inputPosition, List<DatabaseName> graphNames, ScopeType scopeType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databasePrivilegeScope(InputPosition inputPosition, List<DatabaseName> list, ScopeType scopeType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public LabelExpression dynamicLabelLeaf(InputPosition p, Expression e, EntityType entityType, boolean all,
		boolean containsIs) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement enableServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName, SimpleEither<Map<String, Expression>, Parameter<?>> serverOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName, SimpleEither<Map<String, Expression>, Parameter<?>> serverOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement renameServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName, SimpleEither<String, Parameter<?>> newName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showServers(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement deallocateServers(InputPosition p, boolean dryRun, List<SimpleEither<String, Parameter<?>>> serverNames) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement reallocateDatabases(InputPosition p, boolean dryRun) {
		throw new UnsupportedOperationException();
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Optional;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.FunctionInvocation.FunctionDefinition;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * Represents a named path. A named path can be either a {@link RelationshipPattern} that has been assigned to a variable
 * as in {@code p := (a)-->(b)}, a call to functions known to return paths or an existing, symbolic name that might come
 * from an arbitrary procedure returning path elements.
 * <br>
 * <b>Note</b>: We cannot check a value that has been yielded from a procedure upfront to verify that it is a named
 * path. This is up to the caller.
 *
 * @author Michael J. Simons
 * @soundtrack Freddie Mercury - Never Boring
 * @since 1.1
 */
@API(status = STABLE, since = "1.1")
public final class NamedPath implements PatternElement, Named {
	/**
	 * The name of this path expression.
	 */
	private final SymbolicName name;
	/**
	 * The pattern defining this path.
	 */
	private final Visitable optionalPattern;
	static OngoingDefinitionWithName named(String name) {
		return named(SymbolicName.of(name));
	}
	static OngoingDefinitionWithName named(SymbolicName name) {
		Assertions.notNull(name, "A name is required");
		return new Builder(name);
	}
	static OngoingShortestPathDefinitionWithName named(String name, FunctionDefinition algorithm) {
		return new ShortestPathBuilder(SymbolicName.of(name), algorithm);
	}
	static OngoingShortestPathDefinitionWithName named(SymbolicName name, FunctionDefinition algorithm) {
		Assertions.notNull(name, "A name is required");
		return new ShortestPathBuilder(name, algorithm);
	}
	/**
	 * Partial path that has a name ({@code p = }).
	 */
	public interface OngoingDefinitionWithName {
		/**
		 * Create a new named path based on a {@link PatternElement} single node.
		 * If a {@link NamedPath} will be provided, it will get used directly.
		 *
		 * @param patternElement The PatternElement to be used in named path.
		 * @return A named path.
		 */
		@NotNull @Contract(pure = true)
		NamedPath definedBy(PatternElement patternElement);
		/**
		 * Create a new named path that references a given, symbolic name. No checks are done if the referenced name
		 * actually points to a path.
		 *
		 * @return A named path.
		 * @since 2020.1.4
		 */
		@NotNull @Contract(pure = true)
		NamedPath get();
	}
	/**
	 * Partial path that has a name ({@code p = }) and is based on a graph algorithm function.
	 */
	public interface OngoingShortestPathDefinitionWithName {
		/**
		 * Create a new named path based on a single relationship.
		 *
		 * @param relationship The relationship to be passed to {@code shortestPath}.
		 * @return A named path.
		 */
		NamedPath definedBy(Relationship relationship);
	}
	private record Builder(SymbolicName name) implements OngoingDefinitionWithName {
		@NotNull
		@Override
		public NamedPath definedBy(PatternElement pattern) {
			if (pattern instanceof NamedPath namedPath) {
				return namedPath;
			}
			return new NamedPath(name, pattern);
		}
		@NotNull
		@Override
		public NamedPath get() {
			return new NamedPath(name);
		}
	}
	private record ShortestPathBuilder(
		SymbolicName name, FunctionDefinition algorithm) implements OngoingShortestPathDefinitionWithName {
		@Override
		public NamedPath definedBy(Relationship relationship) {
			return new NamedPath(name, FunctionInvocation.create(algorithm, relationship));
		}
	}
	private NamedPath(SymbolicName name) {
		this.name = name;
		this.optionalPattern = null;
	}
	private NamedPath(SymbolicName name, PatternElement optionalPattern) {
		this.name = name;
		this.optionalPattern = optionalPattern;
	}
	private NamedPath(SymbolicName name, FunctionInvocation algorithm) {
		this.name = name;
		this.optionalPattern = algorithm;
	}
	@Override
	@NotNull
	public Optional<SymbolicName> getSymbolicName() {
		return Optional.of(name);
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.name.accept(visitor);
		if (optionalPattern != null) {
			Operator.ASSIGMENT.accept(visitor);
			this.optionalPattern.accept(visitor);
		}
		visitor.leave(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.ast;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import org.apiguardian.api.API;
/**
 * This class helps to group items of the same type on the same level of the tree into a list structure that can be
 * recognized by visitors.
 *
 * @author Michael J. Simons
 * @param <T>    The children's type
 * @since 1.0
 */
@API(status = INTERNAL, since = "1.0")
public abstract class TypedSubtree<T extends Visitable> implements Visitable {
	/**
	 * The content of this typed subtree.
	 */
	protected final List<T> children;
	/**
	 * Creates a new typed subtree with the given content.
	 *
	 * @param children The content of this subtree.
	 */
	@SafeVarargs
	@SuppressWarnings("varargs")
	protected TypedSubtree(T... children) {
		this.children = Arrays.asList(children);
	}
	/**
	 * Creates a new typed subtree with the given content.
	 *
	 * @param children The content of this subtree.
	 */
	protected TypedSubtree(Collection<T> children) {
		this.children = new ArrayList<>(children);
	}
	@Override
	public final void accept(Visitor visitor) {
		visitor.enter(this);
		this.children.forEach(child -> prepareVisit(child).accept(visitor));
		visitor.leave(this);
	}
	/**
	 * A hook for interfere with the visitation of child elements.
	 *
	 * @param child The current child element
	 * @return The visitable that has been prepared
	 */
	protected Visitable prepareVisit(T child) {
		return child;
	}
	@API(status = INTERNAL)
	protected List<T> getChildren() {
		return children;
	}
	@API(status = INTERNAL)
	public String separator() {
		return ", ";
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.lang.reflect.Array;
import java.net.URI;
import java.time.Duration;
import java.time.Period;
import java.time.temporal.TemporalAccessor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.ResourceBundle;
import java.util.TimeZone;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ListComprehension.OngoingDefinitionWithVariable;
import org.neo4j.cypherdsl.core.Literal.UnsupportedLiteralException;
import org.neo4j.cypherdsl.core.PatternComprehension.OngoingDefinitionWithPattern;
import org.neo4j.cypherdsl.core.Statement.SingleQuery;
import org.neo4j.cypherdsl.core.Statement.UnionQuery;
import org.neo4j.cypherdsl.core.Statement.UseStatement;
import org.neo4j.cypherdsl.core.StatementBuilder.OngoingStandaloneCallWithoutArguments;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * The main entry point into the Cypher DSL.
 * The Cypher Builder API is intended for framework usage to produce Cypher statements required for database operations.
 *
 * @author Michael J. Simons
 * @author Gerrit Meier
 * @author Andreas Berger
 * @author Ali Ince
 * @since 1.0
 */
@SuppressWarnings("unused") @API(status = STABLE, since = "1.0")
public final class Cypher {
	static final ResourceBundle MESSAGES = ResourceBundle.getBundle("org.neo4j.cypherdsl.core.messages");
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, String... additionalLabels) {
		return new InternalNodeImpl(primaryLabel, additionalLabels);
	}
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, List<String> additionalLabels) {
		return new InternalNodeImpl(primaryLabel, additionalLabels.toArray(new String[] {}));
	}
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional. This method also takes a map of properties. This allows the returned node object to be used in a
	 * {@code MATCH} or {@code MERGE} statement.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param properties       The properties expected to exist on the node.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, MapExpression properties, String... additionalLabels) {
		return new InternalNodeImpl(null, primaryLabel, properties, additionalLabels);
	}
	/**
	 * Create a new Node representation with at least one label, the "primary" label. This is required. All other labels
	 * are optional. This method also takes a map of properties. This allows the returned node object to be used in a
	 * {@code MATCH} or {@code MERGE} statement.
	 *
	 * @param primaryLabel     The primary label this node is identified by.
	 * @param properties       The properties expected to exist on the node.
	 * @param additionalLabels Additional labels
	 * @return A new node representation
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, MapExpression properties, Collection<String> additionalLabels) {
		return node(primaryLabel, properties, additionalLabels.toArray(new String[] {}));
	}
	/**
	 * @return A node matching any node.
	 */
	@NotNull @Contract(pure = true)
	public static Node anyNode() {
		return new InternalNodeImpl();
	}
	/**
	 * @param labelExpression required expression
	 * @return A node matching a label expression
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	public static Node node(LabelExpression labelExpression) {
		return new InternalNodeImpl(Objects.requireNonNull(labelExpression), null);
	}
	/**
	 * @return The {@code *} wildcard literal.
	 */
	@NotNull @Contract(pure = true)
	public static Asterisk asterisk() {
		return Asterisk.INSTANCE;
	}
	/**
	 * @param symbolicName The new symbolic name
	 * @return A node matching any node with the symbolic the given {@code symbolicName}.
	 */
	@NotNull @Contract(pure = true)
	public static Node anyNode(String symbolicName) {
		return new InternalNodeImpl().named(symbolicName);
	}
	/**
	 * @param symbolicName The new symbolic name
	 * @return A node matching any node with the symbolic the given {@code symbolicName}.
	 */
	@NotNull @Contract(pure = true)
	public static Node anyNode(SymbolicName symbolicName) {
		return new InternalNodeImpl().named(symbolicName);
	}
	/**
	 * Dereferences a property for a symbolic name, most likely pointing to a property container like a node or a relationship.
	 *
	 * @param containerName The symbolic name of a property container
	 * @param names         The names of the properties to dereference. More than one name does create a nested property
	 *                      like {@code containerName.name1.name2}.
	 * @return A new property
	 */
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, String... names) {
		return property(name(containerName), names);
	}
	/**
	 * Dereferences a property for a symbolic name, most likely pointing to a property container like a node or a relationship.
	 *
	 * @param containerName The symbolic name of a property container
	 * @param names         The names of the properties to dereference. More than one name does create a nested property
	 *                      like {@code containerName.name1.name2}.
	 * @return A new property
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, Collection<String> names) {
		return property(name(containerName), names.toArray(new String[] {}));
	}
	/**
	 * Dereferences a property on a arbitrary expression.
	 *
	 * @param expression The expression that describes some sort of accessible map
	 * @param names      The names of the properties to dereference. More than one name does create a nested property
	 *                   like {@code expression.name1.name2}.
	 * @return A new property.
	 */
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, String... names) {
		return InternalPropertyImpl.create(expression, names);
	}
	/**
	 * Dereferences a property on a arbitrary expression.
	 *
	 * @param expression The expression that describes some sort of accessible map
	 * @param names      The names of the properties to dereference. More than one name does create a nested property
	 *                   like {@code expression.name1.name2}.
	 * @return A new property.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, Collection<String> names) {
		return property(expression, names.toArray(new String[] {}));
	}
	/**
	 * Creates a dynamic lookup of a property for a symbolic name, most likely pointing to a property container like a
	 * node or a relationship. A dynamic property will be rendered as {@code p[expression]}.
	 *
	 * @param containerName The symbolic name of a property container
	 * @param lookup        An expression to use as a dynamic lookup for properties of the container with the given name
	 * @return A new property
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, Expression lookup) {
		return property(name(containerName), lookup);
	}
	/**
	 * Creates a dynamic lookup of a property on a arbitrary expression. A dynamic property will be rendered as
	 * {@code p[expression]}.
	 *
	 * @param expression The expression that describes some sort of accessible map
	 * @param lookup     An expression to use as a dynamic lookup for properties of the container the expression resolved to
	 * @return A new property.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, Expression lookup) {
		return InternalPropertyImpl.create(expression, lookup);
	}
	/**
	 * Starts defining a named path by indicating a name.
	 *
	 * @param name The name of the new path
	 * @return An ongoing definition of a named path
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingDefinitionWithName path(String name) {
		return NamedPath.named(name);
	}
	/**
	 * Starts defining a named path by indicating a name.
	 *
	 * @param name The name of the new path
	 * @return An ongoing definition of a named path
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingDefinitionWithName path(SymbolicName name) {
		return NamedPath.named(name);
	}
	/**
	 * Starts defining a named path defined by the {@code shortestPath} between a relationship by indicating a name.
	 *
	 * @param name The name of the new shortestPath path
	 * @return An ongoing definition of a named path
	 * @since 1.1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingShortestPathDefinitionWithName shortestPath(String name) {
		return NamedPath.named(name, BuiltInFunctions.Scalars.SHORTEST_PATH);
	}
	/**
	 * Starts defining a named path defined by the {@code shortestPath} between a relationship by indicating a name.
	 *
	 * @param name The name of the new shortestPath path
	 * @return An ongoing definition of a named path
	 * @since 1.1.1
	 */
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingShortestPathDefinitionWithName shortestPath(SymbolicName name) {
		return NamedPath.named(name, BuiltInFunctions.Scalars.SHORTEST_PATH);
	}
	/**
	 * Creates a new symbolic name.
	 *
	 * @param value The value of the symbolic name
	 * @return A new symbolic name
	 */
	@NotNull @Contract(pure = true)
	public static SymbolicName name(String value) {
		return SymbolicName.of(value);
	}
	/**
	 * Creates a new parameter placeholder. Existing $-signs will be removed.
	 *
	 * @param name The name of the parameter, must not be null
	 * @return The new parameter
	 */
	@NotNull @Contract(pure = true)
	public static Parameter<Object> parameter(String name) {
		return Parameter.create(name);
	}
	/**
	 * Creates a new parameter with the given {@code name} and a value bound to it.
	 * The value can be retrieved from the final statement build.
	 *
	 * @param name  The name of the parameter, must not be null
	 * @param value The value of the parameter.
	 * @param <T>   Type of the new parameter
	 * @return The new parameter
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	public static <T> Parameter<T> parameter(String name, T value) {
		return Parameter.create(name, value);
	}
	/**
	 * Creates a new anonymous parameter with a value bound to it. The value can be retrieved from the final statement build.
	 * The name will be available as soon as the statement has been rendered.
	 *
	 * @param value The value of the parameter.
	 * @param <T>   Type of the new parameter
	 * @return The new parameter
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static <T> Parameter<T> anonParameter(T value) {
		return Parameter.anon(value);
	}
	/**
	 * Prepares an optional match statement.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere optionalMatch(PatternElement... pattern) {
		return Statement.builder().optionalMatch(pattern);
	}
	/**
	 * Prepares an optional match statement.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere optionalMatch(
		Collection<? extends PatternElement> pattern) {
		return optionalMatch(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(PatternElement... pattern) {
		return Statement.builder().match(pattern);
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param pattern The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(Collection<? extends PatternElement> pattern) {
		return match(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param optional A flag whether the {@code MATCH} clause includes the {@code OPTIONAL} keyword.
	 * @param pattern  The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2020.1.3
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(boolean optional, PatternElement... pattern) {
		return Statement.builder().match(optional, pattern);
	}
	/**
	 * Starts building a statement based on a match clause. Use {@link Cypher#node(String, String...)} and related to
	 * retrieve a node or a relationship, which both are pattern elements.
	 *
	 * @param optional A flag whether the {@code MATCH} clause includes the {@code OPTIONAL} keyword.
	 * @param pattern  The patterns to match
	 * @return An ongoing match that is used to specify an optional where and a required return clause
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(boolean optional,
		Collection<? extends PatternElement> pattern) {
		return match(optional, pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement based on a {@code CREATE} clause.
	 *
	 * @param pattern The patterns to create
	 * @return An ongoing {@code CREATE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUpdate create(PatternElement... pattern) {
		return Statement.builder().create(pattern);
	}
	/**
	 * Starts building a statement based on a {@code CREATE} clause.
	 *
	 * @param pattern The patterns to create
	 * @return An ongoing {@code CREATE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUpdate create(Collection<? extends PatternElement> pattern) {
		return create(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts a statement with a leading {@code WITH}. Those are useful for passing on lists of various type that
	 * can be unwound later on etc. A leading {@code WITH} obviously cannot be used with patterns and needs its
	 * arguments to have an alias.
	 *
	 * @param variables One ore more variables.
	 * @return An ongoing with clause.
	 * @since 2020.1.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(String... variables) {
		return Statement.builder().with(variables);
	}
	/**
	 * Starts a statement with a leading {@code WITH}. Those are useful for passing on lists of various type that
	 * can be unwound later on etc. A leading {@code WITH} cannot be used with patterns obviously and needs its
	 * arguments to have an alias.
	 *
	 * @param elements One ore more variables.
	 * @return An ongoing with clause.
	 * @since 2020.1.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(IdentifiableElement... elements) {
		return Statement.builder().with(elements);
	}
	/**
	 * Start building a new sub-query expression by importing variables into the scope with a {@literal WITH} clause.
	 *
	 * @param identifiableElements The identifiable elements to import
	 * @return A builder for creating the concrete sub-query
	 * @since 2023.9.0
	 */
	public static SubqueryExpressionBuilder subqueryWith(String... identifiableElements) {
		return subqueryWith(Arrays.stream(identifiableElements).map(SymbolicName::of).toArray(SymbolicName[]::new));
	}
	/**
	 * Start building a new sub-query expression by importing variables into the scope with a {@literal WITH} clause.
	 *
	 * @param identifiableElements The identifiable elements to import
	 * @return A builder for creating the concrete sub-query
	 * @since 2023.9.0
	 */
	public static SubqueryExpressionBuilder subqueryWith(IdentifiableElement... identifiableElements) {
		return Expressions.with(identifiableElements);
	}
	/**
	 * Starts a statement with a leading {@code WITH}. Those are useful for passing on lists of various type that
	 * can be unwound later on etc. A leading {@code WITH} cannot be used with patterns obviously and needs its
	 * arguments to have an alias.
	 * <p>
	 * This method takes both aliased and non-aliased expression. The later will produce only valid Cypher when used in
	 * combination with a correlated subquery via {@link Cypher#call(Statement)}.
	 *
	 * @param elements One ore more expressions.
	 * @return An ongoing with clause.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(
		Collection<IdentifiableElement> elements) {
		return Statement.builder().with(elements);
	}
	/**
	 * Starts building a statement based on a {@code MERGE} clause.
	 *
	 * @param pattern The patterns to merge
	 * @return An ongoing {@code MERGE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingMerge merge(PatternElement... pattern) {
		return Statement.builder().merge(pattern);
	}
	/**
	 * Starts building a statement based on a {@code MERGE} clause.
	 *
	 * @param pattern The patterns to merge
	 * @return An ongoing {@code MERGE} that can be used to specify {@code WITH} and {@code RETURNING} etc.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingMerge merge(Collection<? extends PatternElement> pattern) {
		return merge(pattern.toArray(new PatternElement[] {}));
	}
	/**
	 * Starts building a statement starting with an {@code UNWIND} clause. The expression needs to be an expression
	 * evaluating to a list, otherwise the query will fail.
	 *
	 * @param expression The expression to unwind
	 * @return An ongoing {@code UNWIND}.
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Expression expression) {
		return Statement.builder().unwind(expression);
	}
	/**
	 * Starts building a statement starting with an {@code UNWIND} clause. The expressions passed will be turned into a
	 * list expression
	 *
	 * @param expressions expressions to unwind
	 * @return a new instance of {@link StatementBuilder.OngoingUnwind}
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Expression... expressions) {
		return Statement.builder().unwind(Cypher.listOf(expressions));
	}
	/**
	 * Starts building a statement starting with an {@code UNWIND} clause. The expressions passed will be turned into a
	 * list expression
	 *
	 * @param expressions expressions to unwind
	 * @return a new instance of {@link StatementBuilder.OngoingUnwind}
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Collection<? extends Expression> expressions) {
		return unwind(expressions.toArray(new Expression[] {}));
	}
	/**
	 * Creates a new {@link SortItem} to be used as part of an {@link Order}.
	 *
	 * @param expression The expression by which things should be sorted
	 * @return A sort item, providing means to specify ascending or descending order
	 */
	@NotNull @Contract(pure = true)
	public static SortItem sort(Expression expression) {
		return SortItem.create(expression, null);
	}
	/**
	 * Creates a new {@link SortItem} to be used as part of an {@link Order}.
	 *
	 * @param expression The expression by which things should be sorted
	 * @param direction  The direction to sort by. Defaults to {@link SortItem.Direction#UNDEFINED}.
	 * @return A sort item
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static SortItem sort(Expression expression, SortItem.Direction direction) {
		return SortItem.create(expression, direction);
	}
	/**
	 * Creates a map of expression from a list of key/value pairs.
	 *
	 * @param keysAndValues A list of key and values. Must be an even number, with alternating {@link String} and {@link Expression}
	 * @return A new map expression.
	 */
	@NotNull @Contract(pure = true)
	public static MapExpression mapOf(Object... keysAndValues) {
		return MapExpression.create(false, keysAndValues);
	}
	/**
	 * Creates an alphabetically sorted map of expression from a list of key/value pairs.
	 *
	 * @param keysAndValues A list of key and values. Must be an even number, with alternating {@link String} and {@link Expression}
	 * @return A new map expression.
	 */
	@NotNull @Contract(pure = true)
	public static MapExpression sortedMapOf(Object... keysAndValues) {
		return MapExpression.create(true, keysAndValues);
	}
	/**
	 * Creates a map of expression from a Java Map.
	 *
	 * @param map A map to be turned into a MapExpression
	 * @return A new map expression.
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static MapExpression asExpression(Map<String, Object> map) {
		return MapExpression.create(map);
	}
	/**
	 * Creates a {@link ListExpression list-expression} from several expressions.
	 *
	 * @param expressions expressions to get combined into a list
	 * @return a new instance of {@link ListExpression}
	 */
	@NotNull @Contract(pure = true)
	public static ListExpression listOf(Expression... expressions) {
		return ListExpression.create(expressions);
	}
	/**
	 * Creates a {@link ListExpression list-expression} from several expressions.
	 *
	 * @param expressions expressions to get combined into a list
	 * @return a new instance of {@link ListExpression}
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static ListExpression listOf(Collection<? extends Expression> expressions) {
		return Cypher.listOf(expressions.toArray(new Expression[0]));
	}
	/**
	 * Creates a new {@link Literal Literal&lt;?&gt;} from the given {@code object}.
	 *
	 * @param object the object to represent.
	 * @param <T>    The type of the literal returned
	 * @return a new {@link Literal Literal&lt;?&gt;}.
	 * @throws UnsupportedLiteralException when the object cannot be represented as a literal
	 */
	@SuppressWarnings("unchecked")
	@NotNull @Contract(pure = true)
	public static <T> Literal<T> literalOf(Object object) {
		if (object == null) {
			return (Literal<T>) NullLiteral.INSTANCE;
		}
		if (object instanceof Literal<?>) {
			return (Literal<T>) object;
		}
		if (object instanceof CharSequence charSequence) {
			return (Literal<T>) new StringLiteral(charSequence);
		}
		if (object instanceof Character) {
			return (Literal<T>) new StringLiteral(String.valueOf(object));
		}
		if (object instanceof Number number) {
			return (Literal<T>) new NumberLiteral(number);
		}
		if (object instanceof TemporalAccessor temporalAccessor) {
			return (Literal<T>) new TemporalLiteral(temporalAccessor);
		}
		if (object instanceof Duration duration) {
			return (Literal<T>) DurationLiteral.of(duration);
		}
		if (object instanceof Period period) {
			return (Literal<T>) PeriodLiteral.of(period);
		}
		if (object instanceof Iterable || object.getClass().isArray()) {
			List<Literal<?>> elements = new ArrayList<>();
			Consumer<Object> handleElement = element -> {
				if (element instanceof Literal) {
					elements.add((Literal<?>) element);
				} else {
					try {
						elements.add(Cypher.literalOf(element));
					} catch (UnsupportedLiteralException e) {
						throw new UnsupportedLiteralException("Unsupported literal type in iterable.", element);
					}
				}
			};
			if (object.getClass().isArray()) {
				for (int i = 0; i < Array.getLength(object); i++) {
					handleElement.accept(Array.get(object, i));
				}
			} else {
				((Iterable<?>) object).forEach(handleElement);
			}
			ListLiteral listLiteral = new ListLiteral(elements);
			return (Literal<T>) listLiteral;
		}
		if (object instanceof Map) {
			Map<String, Literal<?>> map = new LinkedHashMap<>();
			BiConsumer<Object, Object> handleEntry = (key, value) -> {
				if (!(key instanceof CharSequence || key instanceof Character)) {
					throw new UnsupportedLiteralException(
						"Unsupported literal map key (not a string/char type).", key);
				}
				if (value instanceof Literal) {
					map.put(key.toString(), (Literal<?>) value);
				} else {
					try {
						map.put(key.toString(), Cypher.literalOf(value));
					} catch (UnsupportedLiteralException e) {
						throw new UnsupportedLiteralException("Unsupported literal type in map.", value);
					}
				}
			};
			((Map<?, ?>) object).forEach(handleEntry);
			MapLiteral mapLiteral = new MapLiteral(map);
			return (Literal<T>) mapLiteral;
		}
		if (object instanceof Boolean b) {
			return (Literal<T>) BooleanLiteral.of(b);
		}
		throw new UnsupportedLiteralException(object);
	}
	/**
	 * @return The {@literal true} literal.
	 */
	@NotNull @Contract(pure = true)
	public static Literal<Boolean> literalTrue() {
		return BooleanLiteral.TRUE;
	}
	/**
	 * @return The {@literal false} literal.
	 */
	@NotNull @Contract(pure = true)
	public static Literal<Boolean> literalFalse() {
		return BooleanLiteral.FALSE;
	}
	/**
	 * @return The {@literal null} literal.
	 */
	@NotNull @Contract(pure = true)
	public static Literal<Void> literalNull() {
		return NullLiteral.INSTANCE;
	}
	/**
	 * Creates a {@code UNION} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 */
	@NotNull @Contract(pure = true)
	public static UnionQuery union(Statement... statements) {
		return unionImpl(false, statements);
	}
	/**
	 * Creates a {@code UNION} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static UnionQuery union(Collection<Statement> statements) {
		return union(statements.toArray(new Statement[] {}));
	}
	/**
	 * Creates a {@code UNION ALL} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 */
	@NotNull @Contract(pure = true)
	public static Statement unionAll(Statement... statements) {
		return unionImpl(true, statements);
	}
	/**
	 * Creates a {@code UNION ALL} statement from several other statements. No checks are applied for matching return types.
	 *
	 * @param statements the statements to union.
	 * @return A union statement.
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static Statement unionAll(Collection<Statement> statements) {
		return unionAll(statements.toArray(new Statement[] {}));
	}
	/**
	 * A {@literal RETURN} statement without a previous match.
	 *
	 * @param expressions The elements to return
	 * @return A buildable statement
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returning(Expression... expressions) {
		return Statement.builder().returning(expressions);
	}
	/**
	 * A {@literal RETURN} statement without a previous match.
	 *
	 * @param expressions The expressions to return
	 * @return A buildable statement
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returning(Collection<? extends Expression> expressions) {
		return Statement.builder().returning(expressions);
	}
	/**
	 * Creates a list comprehension starting with a {@link Relationship} or a {@link RelationshipChain chain of relationships}.
	 *
	 * @param relationshipPattern The relationship pattern on which the new list comprehension is based on.
	 * @return An ongoing definition.
	 * @since 2020.0.0
	 */
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithPattern listBasedOn(RelationshipPattern relationshipPattern) {
		return PatternComprehension.basedOn(relationshipPattern);
	}
	/**
	 * Creates a list comprehension starting with a {@link NamedPath named path}.
	 *
	 * @param namedPath The named path on which the new list comprehension is based on.
	 * @return An ongoing definition.
	 * @since 2020.1.1
	 */
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithPattern listBasedOn(NamedPath namedPath) {
		return PatternComprehension.basedOn(namedPath);
	}
	/**
	 * Starts defining a {@link ListComprehension list comprehension}.
	 *
	 * @param variable The variable to which each element of the list is assigned.
	 * @return An ongoing definition of a list comprehension
	 * @since 1.0.1
	 */
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithVariable listWith(SymbolicName variable) {
		return ListComprehension.with(variable);
	}
	/**
	 * Escapes and quotes the {@code unquotedString} for safe usage in Neo4j-Browser and Shell.
	 *
	 * @param unquotedString An unquoted string
	 * @return A quoted string with special chars escaped.
	 */
	@NotNull @Contract(pure = true)
	public static String quote(String unquotedString) {
		return literalOf(unquotedString).asString();
	}
	/**
	 * @return generic case expression start
	 */
	@NotNull @Contract(pure = true)
	public static Case caseExpression() {
		return Case.create(null);
	}
	/**
	 * @param expression initial expression for the simple case statement
	 * @return simple case expression start
	 */
	@NotNull @Contract(pure = true)
	public static Case caseExpression(@Nullable Expression expression) {
		return Case.create(expression);
	}
	/**
	 * Starts defining a procedure call of the procedure with the given {@literal procedureName}. That
	 * procedure name might be fully qualified - that is, including a namespace - or just a simple name.
	 *
	 * @param procedureName The procedure name of the procedure to call. Might be fully qualified.
	 * @return An ongoing definition of a call
	 */
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(String procedureName) {
		Assertions.hasText(procedureName, "The procedure name must not be null or empty.");
		return call(procedureName.split("\\."));
	}
	/**
	 * Starts defining a procedure call of the procedure with the given qualified name.
	 *
	 * @param namespaceAndProcedure The procedure name of the procedure to call.
	 * @return An ongoing definition of a call
	 */
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(String... namespaceAndProcedure) {
		return Statement.call(namespaceAndProcedure);
	}
	/**
	 * Starts defining a procedure call of the procedure with the given qualified name.
	 *
	 * @param namespaceAndProcedure The procedure name of the procedure to call.
	 * @return An ongoing definition of a call
	 * @since 2021.2.2
	 */
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(Collection<String> namespaceAndProcedure) {
		return call(namespaceAndProcedure.toArray(new String[] {}));
	}
	/**
	 * Starts building a statement based on one subquery.
	 *
	 * @param subquery The statement representing the subquery
	 * @return A new ongoing read without any further conditions or returns.
	 * @neo4j.version 4.0.0
	 * @see ExposesSubqueryCall#call(Statement)
	 * @since 2020.1.2
	 */
	@Neo4jVersion(minimum = "4.0.0")
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere call(Statement subquery) {
		return Statement.builder().call(subquery);
	}
	/**
	 * Creates a closed range with given boundaries.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subList(Expression targetExpression, Integer start, Integer end) {
		return ListOperator.subList(targetExpression, Cypher.literalOf(start), Cypher.literalOf(end));
	}
	/**
	 * Creates a closed range with given boundaries.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subList(Expression targetExpression, Expression start, Expression end) {
		return ListOperator.subList(targetExpression, start, end);
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListFrom(Expression targetExpression, Integer start) {
		return ListOperator.subListFrom(targetExpression, Cypher.literalOf(start));
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param start            The inclusive start
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListFrom(Expression targetExpression, Expression start) {
		return ListOperator.subListFrom(targetExpression, start);
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListUntil(Expression targetExpression, Integer end) {
		return ListOperator.subListUntil(targetExpression, Cypher.literalOf(end));
	}
	/**
	 * Creates an open range starting at {@code start}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param end              The exclusive end
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static Expression subListUntil(Expression targetExpression, Expression end) {
		return ListOperator.subListUntil(targetExpression, end);
	}
	/**
	 * Creates a single valued range at {@code index}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param index            The index of the range
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static ListOperator valueAt(Expression targetExpression, Integer index) {
		return valueAt(targetExpression, Cypher.literalOf(index));
	}
	/**
	 * Creates a single valued range at {@code index}.
	 *
	 * @param targetExpression The target expression for the range
	 * @param index            The index of the range
	 * @return A range literal.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	public static ListOperator valueAt(Expression targetExpression, Expression index) {
		return ListOperator.valueAt(targetExpression, index);
	}
	/**
	 * Creates an expression from a raw string fragment. No validation is performed on it. If it is used as expression,
	 * you must make sure to define something that works as expression.
	 * <p>
	 * This method expects exactly one placeholder in the form of {@literal $E} for any argument passed with {@code mixedArgs}.
	 * <p>
	 * To use exactly the term {@literal $E} escape it like this: {@literal \$E}
	 *
	 * @param format    A raw Cypher string
	 * @param mixedArgs Args to the Cypher string
	 * @return An expression to reuse with the builder.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	public static Expression raw(String format, Object... mixedArgs) {
		return RawLiteral.create(format, mixedArgs);
	}
	/**
	 * Starts building a statement from a raw Cypher string that might also have arguments as supported through {@link Cypher#raw(String, Object...)}.
	 * Use this method as your own risk and be aware that no checks are done on the Cypher.
	 *
	 * @param rawCypher the raw Cypher statement to call
	 * @param args      optional args that replace placeholders in the {@code rawCypher}
	 * @return Ongoing sub-query definition based on the raw Cypher statement.
	 * @since 2024.2.0
	 */
	public static ExposesSubqueryCall.BuildableSubquery callRawCypher(String rawCypher, Object... args) {
		return Statement.builder().callRawCypher(rawCypher, args);
	}
	/**
	 * Creates a {@code RETURN} clause from a raw Cypher expression created via {@link Cypher#raw(String, Object...)}.
	 * The expression maybe aliased but it must resolve to a raw element
	 *
	 * @param rawExpression Must be a plain raw or an aliased raw expression. To eventually render as valid Cypher, it must
	 *                      contain the {@code RETURN} keyword.
	 * @return A match that can be build now
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returningRaw(Expression rawExpression) {
		return Statement.builder().returningRaw(rawExpression);
	}
	/**
	 * The foreign adapter factory. Can only be used when `com.querydsl:querydsl-core` is on the class path. The object
	 * won't be modified after initialisation.
	 */
	@SuppressWarnings("squid:S3077")
	private static volatile ForeignAdapterFactory foreignAdapterFactory;
	/**
	 * Provides access to the foreign DSL adapter. Please make sure you have the necessary runtime dependencies on the class path,
	 * otherwise you will see some kind of {@link ClassNotFoundException} along various classes related to the foreign DSL.
	 *
	 * @param expression The expression that should be adapted
	 * @param <FE>       The type of the expression
	 * @return A foreign adapter
	 * @throws IllegalArgumentException in case the object cannot be adapter
	 * @since 2021.1.0
	 */
	@NotNull @Contract(pure = true)
	public static <FE> ForeignAdapter<FE> adapt(FE expression) {
		ForeignAdapterFactory initializedForeignAdapterFactory = foreignAdapterFactory;
		if (initializedForeignAdapterFactory == null) {
			synchronized (Cypher.class) {
				initializedForeignAdapterFactory = foreignAdapterFactory;
				if (initializedForeignAdapterFactory == null) {
					foreignAdapterFactory = new ForeignAdapterFactory();
					initializedForeignAdapterFactory = foreignAdapterFactory;
				}
			}
		}
		return initializedForeignAdapterFactory.getAdapterFor(expression);
	}
	/**
	 * Starts building a {@code LOAD CSV} clause by using a periodic commit. The default rate of the database will be used.
	 *
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	public static ExposesLoadCSV usingPeriodicCommit() {
		return usingPeriodicCommit(null);
	}
	/**
	 * Starts building a {@code LOAD CSV} clause by using a periodic commit.
	 *
	 * @param rate The rate to be used. No checks are done on the rate, the database will verify valid values.
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	public static ExposesLoadCSV usingPeriodicCommit(@Nullable Integer rate) {
		return LoadCSVStatementBuilder.usingPeriodicCommit(rate);
	}
	/**
	 * Starts building a {@code LOAD CSV}. No headers are assumed.
	 *
	 * @param from The {@link URI} to load data from. Any uri that is resolvable by the database itself is valid.
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 * @since 2021.2.1
	 */
	public static LoadCSVStatementBuilder.OngoingLoadCSV loadCSV(URI from) {
		return loadCSV(from, false);
	}
	/**
	 * Starts building a {@code LOAD CSV}.
	 *
	 * @param from        The {@link URI} to load data from. Any uri that is resolvable by the database itself is valid.
	 * @param withHeaders Set to {@literal true} if the csv file contains header
	 * @return An ongoing definition of a {@code LOAD CSV} clause
	 */
	public static LoadCSVStatementBuilder.OngoingLoadCSV loadCSV(URI from, boolean withHeaders) {
		return LoadCSVStatementBuilder.loadCSV(from, withHeaders);
	}
	private static UnionQuery unionImpl(boolean unionAll, Statement... statements) {
		Assertions.isTrue(statements != null && statements.length >= 2, "At least two statements are required!");
		int i = 0;
		UnionQueryImpl existingUnionQuery = null;
		@SuppressWarnings("squid:S2259") // Really, we asserted it 4 lines above this one. Thank you, sonar.
		boolean isUnionQuery = statements[0] instanceof UnionQueryImpl;
		if (isUnionQuery) {
			existingUnionQuery = (UnionQueryImpl) statements[0];
			Assertions.isTrue(existingUnionQuery.isAll() == unionAll, "Cannot mix union and union all!");
			i = 1;
		}
		List<Statement> listOfQueries = new ArrayList<>();
		do {
			Assertions.isTrue(statements[i] instanceof SingleQuery || statements[i] instanceof ClausesBasedStatement,
				"Can only union single queries!");
			listOfQueries.add(statements[i]);
		} while (++i < statements.length);
		if (existingUnionQuery == null) {
			return UnionQueryImpl.create(unionAll, listOfQueries);
		} else {
			return existingUnionQuery.addAdditionalQueries(listOfQueries);
		}
	}
	/**
	 * Tries to format this expression into something human-readable. Not all expressions are supported
	 *
	 * @param expression An expression to format
	 * @return A human-readable string
	 * @throws IllegalArgumentException When the expression cannot be formatted
	 * @since 2021.3.2
	 */
	@SuppressWarnings("deprecation")
	public static String format(Expression expression) {
		return Expressions.format(expression);
	}
	/**
	 * Decorates the given statement by prepending a static {@literal USE} clause.
	 *
	 * @param target    The target. This might be a single database or a constituent of a composite database. This value
	 *                  will be escaped if necessary. If it contains a {@literal .}, both the first and second part will
	 *                  be escaped individually.
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.0.0
	 */
	public static UseStatement use(String target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Decorates the given statement by prepending a dynamic {@literal USE} clause. A dynamic {@literal USE} clause will
	 * utilize {@code graph.byName} to resolve the target database.
	 *
	 * @param target    A parameter that must resolve to a Cypher string.
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.0.0
	 */
	public static UseStatement use(Parameter<?> target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Decorates the given statement by prepending a dynamic {@literal USE} clause. A dynamic {@literal USE} clause will
	 * utilize {@code graph.byName} to resolve the target database.
	 *
	 * @param target    A string expression
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.0.0
	 */
	public static UseStatement use(StringLiteral target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Decorates the given statement by prepending a dynamic {@literal USE} clause. A dynamic {@literal USE} clause will
	 * utilize {@code graph.byName} to resolve the target database unless {@link Cypher#graphByName(Expression)} has
	 * already been used.
	 *
	 * @param target    The name of a variable pointing to the graph or constituent
	 * @param statement The statement to decorate
	 * @return The new buildable statement
	 * @since 2023.4.0
	 */
	public static UseStatement use(Expression target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} includes all elements present in {@code rhs}.
	 *
	 * @param lhs Argument that is tested whether it contains all values in {@code rhs} or not
	 * @param rhs The reference collection
	 * @return An "includesAll" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition includesAll(Expression lhs, Expression rhs) {
		return Conditions.includesAll(lhs, rhs);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} includes any element present in {@code rhs}.
	 *
	 * @param lhs Argument that is tested whether it contains any values in {@code rhs} or not
	 * @param rhs The reference collection
	 * @return A "not_includes" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition includesAny(Expression lhs, Expression rhs) {
		return Conditions.includesAny(lhs, rhs);
	}
	/**
	 * @param relationshipPattern The pattern being evaluated in a condition
	 * @return A new condition matching the given pattern
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition matching(RelationshipPattern relationshipPattern) {
		return Conditions.matching(relationshipPattern);
	}
	/**
	 * Creates a condition that matches if the right hand side is a regular expression that matches the the left hand side via
	 * {@code =~}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A "matches" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition matches(Expression lhs, Expression rhs) {
		return Conditions.matches(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if both expressions are equals according to {@code =}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "equals" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isEqualTo(Expression lhs, Expression rhs) {
		return Conditions.isEqualTo(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if both expressions are equals according to {@code <>}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "not equals" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isNotEqualTo(Expression lhs, Expression rhs) {
		return Conditions.isNotEqualTo(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is less than the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "less than" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition lt(Expression lhs, Expression rhs) {
		return Conditions.lt(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is less than or equal the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "less than or equal" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition lte(Expression lhs, Expression rhs) {
		return Conditions.lte(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is greater than or equal the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "greater than or equal" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition gte(Expression lhs, Expression rhs) {
		return Conditions.gte(lhs, rhs);
	}
	/**
	 * Creates a condition that matches if the left hand side is greater than the right hand side..
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return An "greater than" comparison
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition gt(Expression lhs, Expression rhs) {
		return Conditions.gt(lhs, rhs);
	}
	/**
	 * Negates the given condition.
	 *
	 * @param condition The condition to negate. Must not be null.
	 * @return The negated condition.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition not(@NotNull Condition condition) {
		return Conditions.not(condition);
	}
	/**
	 * Negates the given pattern element: The pattern must not matched to be included in the result.
	 *
	 * @param pattern The pattern to negate. Must not be null.
	 * @return A condition that evaluates to true when the pattern does not match.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition not(@NotNull RelationshipPattern pattern) {
		return Conditions.not(pattern);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} starts with the {@code rhs}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition startsWith(Expression lhs, Expression rhs) {
		return Conditions.startsWith(lhs, rhs);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} contains with the {@code rhs}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition contains(Expression lhs, Expression rhs) {
		return Conditions.contains(lhs, rhs);
	}
	/**
	 * Creates a condition that checks whether the {@code lhs} ends with the {@code rhs}.
	 *
	 * @param lhs The left hand side of the comparison
	 * @param rhs The right hand side of the comparison
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition endsWith(Expression lhs, Expression rhs) {
		return Conditions.endsWith(lhs, rhs);
	}
	/**
	 * Creates a placeholder condition which is not rendered in the final statement but is useful while chaining
	 * conditions together.
	 *
	 * @return A placeholder condition.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition noCondition() {
		return Conditions.noCondition();
	}
	/**
	 * Creates a condition that checks whether the {@code expression} is {@literal null}.
	 *
	 * @param expression The expression to check for {@literal null}
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isNull(Expression expression) {
		return Conditions.isNull(expression);
	}
	/**
	 * Creates a condition that checks whether the {@code expression} is not {@literal null}.
	 *
	 * @param expression The expression to check for {@literal null}
	 * @return A new condition.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isNotNull(Expression expression) {
		return Conditions.isNotNull(expression);
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code isEmpty()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-isempty">isEmpty</a>.
	 * <p>
	 * The argument {@code e} must refer to an expression that evaluates to a list for {@code isEmpty()} to work
	 *
	 * @param expression An expression referring to a list
	 * @return A function call for {@code isEmpty()} for a list
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isEmpty(Expression expression) {
		return Predicates.isEmpty(expression);
	}
	/**
	 * @return a condition that is always true.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isTrue() {
		return Conditions.isTrue();
	}
	/**
	 * @return a condition that is always false.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition isFalse() {
		return Conditions.isFalse();
	}
	/**
	 * @param symbolicName  Reference to the entity that should be checked for labels or types
	 * @param labelsOrTypes the list of labels or types to check for
	 * @return A condition that checks whether a node has a set of given labels or a relationship a set of given types.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition hasLabelsOrType(SymbolicName symbolicName, String... labelsOrTypes) {
		return Conditions.hasLabelsOrType(symbolicName, labelsOrTypes);
	}
	/**
	 * Creates a {@literal COUNT} sub-query expressions from at least one pattern.
	 *
	 * @param requiredPattern One pattern is required
	 * @param patternElement  Optional pattern
	 * @return The immutable {@link CountExpression}
	 * @since 2023.9.0
	 */
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(PatternElement requiredPattern, PatternElement... patternElement) {
		return Expressions.count(requiredPattern, patternElement);
	}
	/**
	 * Creates a {@literal COUNT} with an inner {@literal UNION} sub-query.
	 *
	 * @param union The union that will be the source of the {@literal COUNT} sub-query
	 * @return The immutable {@link CountExpression}
	 * @since 2023.9.0
	 */
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(UnionQuery union) {
		return Expressions.count(union);
	}
	/**
	 * Creates a {@literal COUNT} from a full statement, including  its filters and conditions. The statement may or may
	 * not have a {@literal RETURN} clause. It must however not contain any updates. While it would render syntactically
	 * correct Cypher, Neo4j does not support updates inside counting sub-queries.
	 *
	 * @param statement The statement to be passed to {@code count{}}
	 * @param imports   Optional imports to be used in the statement (will be imported with {@literal WITH})
	 * @return A counting sub-query.
	 * @since 2023.9.0
	 */
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(Statement statement, IdentifiableElement... imports) {
		return Expressions.count(statement, imports);
	}
	/**
	 * Creates a {@literal COUNT} expression based on a list of pattern
	 *
	 * @param pattern the list of patterns that shall be counted
	 * @param where   an optional where-clause
	 * @return a count expression.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static CountExpression count(List<PatternElement> pattern, @Nullable Where where) {
		return Expressions.count(pattern, where);
	}
	/**
	 * Creates a {@literal COLLECT} subquery from a statement, including  its filters and conditions. The statement must
	 * return exactly one column. It must however not contain any updates. While it would render syntactically
	 * correct Cypher, Neo4j does not support updates inside counting sub-queries.
	 *
	 * @param statement the statement to be passed to {@code COLLECT{}}
	 * @return a collecting sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	@NotNull public static Expression collect(Statement statement) {
		return Expressions.collect(statement);
	}
	/**
	 * @param expression Possibly named with a non-empty symbolic name.
	 * @return The name of the expression if the expression is named or the expression itself.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static <T extends Expression> Expression nameOrExpression(T expression) {
		return Expressions.nameOrExpression(expression);
	}
	@SuppressWarnings("deprecation")
	public static SymbolicName[] createSymbolicNames(String[] variables) {
		return Expressions.createSymbolicNames(variables);
	}
	@SuppressWarnings("deprecation")
	public static SymbolicName[] createSymbolicNames(Named[] variables) {
		return Expressions.createSymbolicNames(variables);
	}
	/**
	 * Creates a function invocation for {@code elementId{}}.
	 *
	 * @param node The node for which the element id should be retrieved
	 * @return A function call for {@code elementId()} on a node.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation elementId(
		@NotNull Node node) {
		return Functions.elementId(node);
	}
	/**
	 * Creates a function invocation for {@code elementId{}}.
	 *
	 * @param relationship The relationship for which the element id should be retrieved
	 * @return A function call for {@code elementId()} on a relationship.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation elementId(
		@NotNull Relationship relationship) {
		return Functions.elementId(relationship);
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param node The node which keys should be returned.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Node node) {
		return Functions.keys(node);
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param relationship The relationship which keys should be returned.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Relationship relationship) {
		return Functions.keys(relationship);
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param expression The expressions which keys should be returned. Must resolve to a node, relationship or map.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Expression expression) {
		return Functions.keys(expression);
	}
	/**
	 * Creates a function invocation for {@code labels{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-labels">labels</a>.
	 *
	 * @param node The node for which the labels should be retrieved
	 * @return A function call for {@code labels()} on a node.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation labels(@NotNull Node node) {
		return Functions.labels(node);
	}
	/**
	 * Creates a  function invocation for  {@code labels{}}.  The {@link SymbolicName  symbolic name} {@code  node} must
	 * point to a node. This can't be checked during compile time, so please make sure of that.
	 * <p>
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-labels">labels</a>.
	 *
	 * @param node The node for which the labels should be retrieved
	 * @return A function call for {@code labels()} on a node.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation labels(@NotNull SymbolicName node) {
		return Functions.labels(node);
	}
	/**
	 * Creates a function invocation for {@code type{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-type">type</a>.
	 *
	 * @param relationship The relationship for which the type should be retrieved
	 * @return A function call for {@code type()} on a relationship.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation type(@NotNull Relationship relationship) {
		return Functions.type(relationship);
	}
	/**
	 * Creates a  function invocation for  {@code type{}}. The {@link  SymbolicName symbolic name}  {@code relationship}
	 * must point to a relationship. This can't be checked during compile time, so please make sure of that.
	 * <p>
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-type">type</a>.
	 *
	 * @param relationship The relationship for which the type should be retrieved
	 * @return A function call for {@code type()} on a relationship.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation type(@NotNull SymbolicName relationship) {
		return Functions.type(relationship);
	}
	/**
	 * @param node The named node to be counted
	 * @return A function call for {@code count()} for one named node
	 * @see #count(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation count(@NotNull Node node) {
		return Functions.count(node);
	}
	/**
	 * Creates a function invocation for the {@code count()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count">count</a>.
	 *
	 * @param expression An expression describing the things to count.
	 * @return A function call for {@code count()} for an expression like {@link Cypher#asterisk()} etc.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation count(Expression expression) {
		return Functions.count(expression);
	}
	/**
	 * Creates a function invocation for a {@code count()} function with {@code DISTINCT} added.
	 *
	 * @param node The named node to be counted
	 * @return A function call for {@code count()} for one named node
	 * @see #countDistinct(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation countDistinct(@NotNull Node node) {
		return Functions.countDistinct(node);
	}
	/**
	 * Creates a function invocation for a {@code count()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count">count</a>.
	 *
	 * @param expression An expression describing the things to count.
	 * @return A function call for {@code count()} for an expression like {@link Cypher#asterisk()} etc.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation countDistinct(Expression expression) {
		return Functions.countDistinct(expression);
	}
	/**
	 * Creates a function invocation for {@code properties())} on nodes.
	 *
	 * @param node The node who's properties should be returned.
	 * @return A function call for {@code properties())}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(Node node) {
		return Functions.properties(node);
	}
	/**
	 * Creates a function invocation for {@code properties())} on relationships.
	 *
	 * @param relationship The relationship who's properties should be returned.
	 * @return A function call for {@code properties())}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(Relationship relationship) {
		return Functions.properties(relationship);
	}
	/**
	 * Creates a function invocation for {@code properties())} on maps.
	 *
	 * @param map The map who's properties should be returned.
	 * @return A function call for {@code properties())}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(MapExpression map) {
		return Functions.properties(map);
	}
	/**
	 * Creates a function invocation for the {@code coalesce()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-coalesce">coalesce</a>.
	 *
	 * @param expressions One or more expressions to be coalesced
	 * @return A function call for {@code coalesce}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation coalesce(Expression... expressions) {
		return Functions.coalesce(expressions);
	}
	/**
	 * Creates a function invocation for the {@code left()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-left">left</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @param length     desired length
	 * @return A function call for {@code left()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation left(Expression expression, Expression length) {
		return Functions.left(expression, length);
	}
	/**
	 * Creates a function invocation for the {@code ltrim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-ltrim">ltrim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code ltrim()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ltrim(@NotNull Expression expression) {
		return Functions.ltrim(expression);
	}
	/**
	 * Creates a function invocation for the {@code replace()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-ltrim">replace</a>.
	 *
	 * @param original An expression that returns a string
	 * @param search   An expression that specifies the string to be replaced in {@code original}.
	 * @param replace  An expression that specifies the replacement string.
	 * @return A function call for {@code replace()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation replace(Expression original, Expression search,
		Expression replace) {
		return Functions.replace(original, search, replace);
	}
	/**
	 * Creates a function invocation for the {@code reverse()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-reverse">reverse</a>.
	 *
	 * @param original An expression that returns a string
	 * @return A function call for {@code reverse()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation reverse(@NotNull Expression original) {
		return Functions.reverse(original);
	}
	/**
	 * Creates a function invocation for the {@code right()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-left">right</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @param length     desired length
	 * @return A function call for {@code right()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation right(Expression expression, Expression length) {
		return Functions.right(expression, length);
	}
	/**
	 * Creates a function invocation for the {@code rtrim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-rtrim">rtrim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code rtrim()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation rtrim(@NotNull Expression expression) {
		return Functions.rtrim(expression);
	}
	/**
	 * Creates a function invocation for the {@code substring()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-substring">rtrim</a>.
	 *
	 * @param original An expression resolving to a string
	 * @param start    An expression that returns a positive integer, denoting the position at which the substring will begin.
	 * @param length   An expression that returns a positive integer, denoting how many characters of original will be returned.
	 * @return A function call for {@code substring()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation substring(Expression original, Expression start,
		Expression length) {
		return Functions.substring(original, start, length);
	}
	/**
	 * Creates a function invocation for the {@code toLower()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toLower">toLower</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code toLower()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toLower(@NotNull Expression expression) {
		return Functions.toLower(expression);
	}
	/**
	 * Creates a function invocation for the {@code toUpper()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toUpper">toUpper</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code toLower()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toUpper(@NotNull Expression expression) {
		return Functions.toUpper(expression);
	}
	/**
	 * Creates a function invocation for the {@code trim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-trim">trim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code trim()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation trim(@NotNull Expression expression) {
		return Functions.trim(expression);
	}
	/**
	 * Creates a function invocation for the {@code split()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-split">split</a>.
	 *
	 * @param expression An expression resolving to a string that should be split
	 * @param delimiter  The delimiter on which to split
	 * @return A function call for {@code split()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation split(@NotNull Expression expression,
		@NotNull Expression delimiter) {
		return Functions.split(expression, delimiter);
	}
	/**
	 * Creates a function invocation for the {@code split()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-split">split</a>.
	 *
	 * @param expression An expression resolving to a string that should be split
	 * @param delimiter  The delimiter on which to split
	 * @return A function call for {@code split()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation split(@NotNull Expression expression,
		@NotNull String delimiter) {
		return Functions.split(expression, delimiter);
	}
	/**
	 * Creates a function invocation for the {@code size()} function. {@code size} can be applied to
	 * <ul>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size">a list</a></li>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-string">to a string</a></li>
	 * </ul>
	 *
	 * @param expression The expression who's size is to be returned
	 * @return A function call for {@code size()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation size(Expression expression) {
		return Functions.size(expression);
	}
	/**
	 * Creates a function invocation for the {@code size()} function. {@code size} can be applied to
	 * <ul>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-pattern-expression">to a pattern expression</a></li>
	 * </ul>
	 *
	 * @param pattern The pattern for which {@code size()} should be invoked.
	 * @return A function call for {@code size()} for a pattern
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation size(RelationshipPattern pattern) {
		return Functions.size(pattern);
	}
	/**
	 * Creates a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param expression The expression who's existence is to be evaluated
	 * @return A function call for {@code exists()} for one expression
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation exists(Expression expression) {
		return Functions.exists(expression);
	}
	/**
	 * Creates a function invocation for the {@code distance()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-distance">exists</a>.
	 * Both points need to be in the same coordinate system.
	 *
	 * @param point1 Point 1
	 * @param point2 Point 2
	 * @return A function call for {@code distance()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation distance(@NotNull Expression point1,
		@NotNull Expression point2) {
		return Functions.distance(point1, point2);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 *
	 * @param parameterMap The map of parameters for {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(MapExpression parameterMap) {
		return Functions.point(parameterMap);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 * <p>
	 * This generic expression variant is useful for referencing a point inside a parameter or another map.
	 *
	 * @param expression An expression resolving to a valid map of parameters for {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(Expression expression) {
		return Functions.point(expression);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 *
	 * @param parameter A parameter referencing a {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(Parameter<?> parameter) {
		return Functions.point(parameter);
	}
	/**
	 * Convenience method for creating a 2d cartesian point
	 *
	 * @param x The x coordinate
	 * @param y The y coordinate
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cartesian(double x, double y) {
		return Functions.cartesian(x, y);
	}
	/**
	 * Convenience method for creating a 2d coordinate in the WGS 84 coordinate system
	 *
	 * @param longitude The longitude
	 * @param latitude  The latitude
	 * @return A function call for {@code point()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation coordinate(double longitude, double latitude) {
		return Functions.coordinate(longitude, latitude);
	}
	/**
	 * Creates a function invocation for the {@code point.withinBBox} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-withinBBox">point.withinBBox</a>.
	 *
	 * @param point      The point to check
	 * @param lowerLeft  The lower left point of the bounding box (south-west coordinate)
	 * @param upperRight The upper right point of the bounding box (north-east coordinate)
	 * @return A function call for {@code point.withinBBox}
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static FunctionInvocation withinBBox(Expression point, Expression lowerLeft, Expression upperRight) {
		return Functions.withinBBox(point, lowerLeft, upperRight);
	}
	/**
	 * Creates a function invocation for the {@code avg()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg">avg</a>.
	 *
	 * @param expression The things to average
	 * @return A function call for {@code avg()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation avg(Expression expression) {
		return Functions.avg(expression);
	}
	/**
	 * Creates a function invocation for the {@code avg()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg">avg</a>.
	 *
	 * @param expression The things to average
	 * @return A function call for {@code avg()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation avgDistinct(Expression expression) {
		return Functions.avgDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function.
	 *
	 * @param variable The named thing to collect
	 * @return A function call for {@code collect()}
	 * @see #collect(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collect(@NotNull Named variable) {
		return Functions.collect(variable);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function with {@code DISTINCT} added.
	 *
	 * @param variable The named thing to collect
	 * @return A function call for {@code collect()}
	 * @see #collect(Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collectDistinct(@NotNull Named variable) {
		return Functions.collectDistinct(variable);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect">collect</a>.
	 *
	 * @param expression The things to collect
	 * @return A function call for {@code collect()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collect(Expression expression) {
		return Functions.collect(expression);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect">collect</a>.
	 *
	 * @param expression The things to collect
	 * @return A function call for {@code collect()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collectDistinct(Expression expression) {
		return Functions.collectDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code max()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max">max</a>.
	 *
	 * @param expression A list from which the maximum element value is returned
	 * @return A function call for {@code max()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation max(Expression expression) {
		return Functions.max(expression);
	}
	/**
	 * Creates a function invocation for the {@code max()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max">max</a>.
	 *
	 * @param expression A list from which the maximum element value is returned
	 * @return A function call for {@code max()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation maxDistinct(Expression expression) {
		return Functions.maxDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code min()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min">min</a>.
	 *
	 * @param expression A list from which the minimum element value is returned
	 * @return A function call for {@code min()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation min(Expression expression) {
		return Functions.min(expression);
	}
	/**
	 * Creates a function invocation for the {@code min()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min">min</a>.
	 *
	 * @param expression A list from which the minimum element value is returned
	 * @return A function call for {@code min()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation minDistinct(Expression expression) {
		return Functions.minDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code percentileCont()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont">percentileCont</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileCont()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileCont(Expression expression,
		Number percentile) {
		return Functions.percentileCont(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code percentileCont()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont">percentileCont</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileCont()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileContDistinct(Expression expression,
		Number percentile) {
		return Functions.percentileContDistinct(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code percentileDisc()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc">percentileDisc</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileDisc()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileDisc(Expression expression,
		Number percentile) {
		return Functions.percentileDisc(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code percentileDisc()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc">percentileDisc</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileDisc()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileDiscDistinct(Expression expression,
		Number percentile) {
		return Functions.percentileDiscDistinct(expression, percentile);
	}
	/**
	 * Creates a function invocation for the {@code stDev()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev">stDev</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDev()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDev(Expression expression) {
		return Functions.stDev(expression);
	}
	/**
	 * Creates a function invocation for the {@code stDev()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev">stDev</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDev()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevDistinct(Expression expression) {
		return Functions.stDevDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code stDevP()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp">stDevP</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDevP()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevP(Expression expression) {
		return Functions.stDevP(expression);
	}
	/**
	 * Creates a function invocation for the {@code stDevP()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp">stDevP</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDevP()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevPDistinct(Expression expression) {
		return Functions.stDevPDistinct(expression);
	}
	/**
	 * Creates a function invocation for the {@code sum()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum">sum</a>.
	 *
	 * @param expression An expression returning a set of numeric values
	 * @return A function call for {@code sum()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sum(Expression expression) {
		return Functions.sum(expression);
	}
	/**
	 * Creates a function invocation for the {@code sum()} function  with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum">sum</a>.
	 *
	 * @param expression An expression returning a set of numeric values
	 * @return A function call for {@code sum()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sumDistinct(Expression expression) {
		return Functions.sumDistinct(expression);
	}
	/**
	 * @param start the range's start
	 * @param end   the range's end
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(Integer start, Integer end) {
		return Functions.range(start, end);
	}
	/**
	 * @param start the range's start
	 * @param end   the range's end
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression, Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Expression start,
		@NotNull Expression end) {
		return Functions.range(start, end);
	}
	/**
	 * Creates a function invocation for the {@code range()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range">range</a>.
	 *
	 * @param start the range's start
	 * @param end   the range's end
	 * @param step  the range's step
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression, Expression)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Integer start, @NotNull Integer end,
		Integer step) {
		return Functions.range(start, end, step);
	}
	/**
	 * Creates a function invocation for the {@code range()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range">range</a>.
	 *
	 * @param start the range's start
	 * @param end   the range's end
	 * @param step  the range's step
	 * @return A function call for {@code range()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Expression start,
		@NotNull Expression end, Expression step) {
		return Functions.range(start, end, step);
	}
	/**
	 * Creates a function invocation for the {@code head()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-head">head</a>.
	 *
	 * @param expression A list from which the head element is returned
	 * @return A function call for {@code head()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation head(Expression expression) {
		return Functions.head(expression);
	}
	/**
	 * Creates a function invocation for the {@code last()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-last">last</a>.
	 *
	 * @param expression A list from which the last element is returned
	 * @return A function call for {@code last()}
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation last(Expression expression) {
		return Functions.last(expression);
	}
	/**
	 * Creates a function invocation for {@code nodes{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes">nodes</a>.
	 *
	 * @param path The path for which the number of nodes should be retrieved
	 * @return A function call for {@code nodes()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation nodes(@NotNull NamedPath path) {
		return Functions.nodes(path);
	}
	/**
	 * Creates a function invocation for {@code nodes{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes">nodes</a>.
	 *
	 * @param symbolicName The symbolic name of a path for which the number of nodes should be retrieved
	 * @return A function call for {@code nodes{}} on a path represented by a symbolic name.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation nodes(@NotNull SymbolicName symbolicName) {
		return Functions.nodes(symbolicName);
	}
	/**
	 * Creates a function invocation for {@code relationships{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-relationships">relationships</a>.
	 *
	 * @param path The path for which the relationships should be retrieved
	 * @return A function call for {@code relationships()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation relationships(@NotNull NamedPath path) {
		return Functions.relationships(path);
	}
	/**
	 * Creates a function invocation for {@code relationships{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-relationships">relationships</a>.
	 *
	 * @param symbolicName The symbolic name of a path for which the relationships should be retrieved
	 * @return A function call for {@code relationships()} on a path represented by a symbolic name.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation relationships(@NotNull SymbolicName symbolicName) {
		return Functions.relationships(symbolicName);
	}
	/**
	 * Creates a function invocation for {@code startNode{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-startnode">startNode</a>.
	 *
	 * @param relationship The relationship for which the start node be retrieved
	 * @return A function call for {@code startNode()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation startNode(@NotNull Relationship relationship) {
		return Functions.startNode(relationship);
	}
	/**
	 * Creates a function invocation for {@code endNode{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-endnode">endNode</a>.
	 *
	 * @param relationship The relationship for which the end node be retrieved
	 * @return A function call for {@code endNode()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation endNode(@NotNull Relationship relationship) {
		return Functions.endNode(relationship);
	}
	/**
	 * Creates a function invocation for {@code date()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This is the most simple form.
	 *
	 * @return A function call for {@code date()}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date() {
		return Functions.date();
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year  The year
	 * @param month The month
	 * @param day   The day
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation calendarDate(Integer year, Integer month,
		Integer day) {
		return Functions.calendarDate(year, month, day);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year      The year
	 * @param week      The optional week
	 * @param dayOfWeek The optional day of the week
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation weekDate(Integer year, Integer week,
		Integer dayOfWeek) {
		return Functions.weekDate(year, week, dayOfWeek);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year         The year
	 * @param quarter      The optional week
	 * @param dayOfQuarter The optional day of the week
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation quarterDate(Integer year, Integer quarter,
		Integer dayOfQuarter) {
		return Functions.quarterDate(year, quarter, dayOfQuarter);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year       The year
	 * @param ordinalDay The ordinal day of the year.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ordinalDate(Integer year, Integer ordinalDay) {
		return Functions.ordinalDate(year, ordinalDay);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code date({})}
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull MapExpression components) {
		return Functions.date(components);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This creates a date from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull String temporalValue) {
		return Functions.date(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This creates a date from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull Expression temporalValue) {
		return Functions.date(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 *
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime() {
		return Functions.datetime();
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull TimeZone timeZone) {
		return Functions.datetime(timeZone);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code datetime({})}
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull MapExpression components) {
		return Functions.datetime(components);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">datetime</a>.
	 * This creates a datetime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code datetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull String temporalValue) {
		return Functions.datetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">datetime</a>.
	 * This creates a datetime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull Expression temporalValue) {
		return Functions.datetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 *
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime() {
		return Functions.localdatetime();
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull TimeZone timeZone) {
		return Functions.localdatetime(timeZone);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code localdatetime({})}
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull MapExpression components) {
		return Functions.localdatetime(components);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This creates a localdatetime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull String temporalValue) {
		return Functions.localdatetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This creates a localdatetime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull Expression temporalValue) {
		return Functions.localdatetime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localtime</a>.
	 *
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime() {
		return Functions.localtime();
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull TimeZone timeZone) {
		return Functions.localtime(timeZone);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localtime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code localtime({})}
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull MapExpression components) {
		return Functions.localtime(components);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 * This creates a localtime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull String temporalValue) {
		return Functions.localtime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 * This creates a localtime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code localtime({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull Expression temporalValue) {
		return Functions.localtime(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 *
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time() {
		return Functions.time();
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull TimeZone timeZone) {
		return Functions.time(timeZone);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code time({})}
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull MapExpression components) {
		return Functions.time(components);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This creates a time from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull String temporalValue) {
		return Functions.time(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This creates a time from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code time({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull Expression temporalValue) {
		return Functions.time(temporalValue);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code duration({})}
	 * @return A function call for {@code duration({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull MapExpression components) {
		return Functions.duration(components);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This creates a duration from a string.
	 *
	 * @param temporalAmount A string representing a temporal amount.
	 * @return A function call for {@code duration({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull String temporalAmount) {
		return Functions.duration(temporalAmount);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This creates a duration from a string.
	 *
	 * @param temporalAmount An expression representing a temporal amount.
	 * @return A function call for {@code duration({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull Expression temporalAmount) {
		return Functions.duration(temporalAmount);
	}
	/**
	 * Creates a function invocation for {@code shortestPath({})}.
	 *
	 * @param relationship The relationship to be passed to {@code shortestPath}.
	 * @return A function call for {@code shortestPath({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation shortestPath(Relationship relationship) {
		return Functions.shortestPath(relationship);
	}
	/**
	 * Starts building a function invocation for {@code reduce({})}.
	 *
	 * @param variable The closure will have a variable introduced in its context. We decide here which variable to use.
	 * @return An ongoing definition for a function call to {@code reduce({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Reduction.OngoingDefinitionWithVariable reduce(
		@NotNull SymbolicName variable) {
		return Functions.reduce(variable);
	}
	/**
	 * Creates a function invocation for {@code abs({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-abs">abs</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code abs({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation abs(@NotNull Expression expression) {
		return Functions.abs(expression);
	}
	/**
	 * Creates a function invocation for {@code ceil({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-ceil">ceil</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code ceil({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ceil(@NotNull Expression expression) {
		return Functions.ceil(expression);
	}
	/**
	 * Creates a function invocation for {@code floor({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-floor">floor</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code floor({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation floor(@NotNull Expression expression) {
		return Functions.floor(expression);
	}
	/**
	 * Creates a function invocation for {@code rand({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-rand">rand</a>.
	 *
	 * @return A function call for {@code rand({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation rand() {
		return Functions.rand();
	}
	/**
	 * Creates a function invocation for {@code round({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-round">round</a>.
	 *
	 * @param value      The value to round
	 * @param expression Additional parameters, length must be 0, 1 or 2:
	 *                   First entry is the precision, second is the rounding mode
	 * @return A function call for {@code round({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation round(Expression value, Expression... expression) {
		return Functions.round(value, expression);
	}
	/**
	 * Creates a function invocation for {@code sign({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sign">sign</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sign({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sign(@NotNull Expression expression) {
		return Functions.sign(expression);
	}
	/**
	 * Creates a function invocation for {@code e({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-e">e</a>.
	 *
	 * @return A function call for {@code e({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation e() {
		return Functions.e();
	}
	/**
	 * Creates a function invocation for {@code exp({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-exp">exp</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code exp({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation exp(@NotNull Expression expression) {
		return Functions.exp(expression);
	}
	/**
	 * Creates a function invocation for {@code log({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-log">log</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code log({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation log(@NotNull Expression expression) {
		return Functions.log(expression);
	}
	/**
	 * Creates a function invocation for {@code log10({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-log10">log10</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code log10({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation log10(@NotNull Expression expression) {
		return Functions.log10(expression);
	}
	/**
	 * Creates a function invocation for {@code sqrt({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sqrt">sqrt</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sqrt({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sqrt(@NotNull Expression expression) {
		return Functions.sqrt(expression);
	}
	/**
	 * Creates a function invocation for {@code acos({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-acos">acos</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code acos({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation acos(@NotNull Expression expression) {
		return Functions.acos(expression);
	}
	/**
	 * Creates a function invocation for {@code asin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-asin">asin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code asin({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation asin(@NotNull Expression expression) {
		return Functions.asin(expression);
	}
	/**
	 * Creates a function invocation for {@code atan({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-atan">atan</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code atan({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation atan(@NotNull Expression expression) {
		return Functions.atan(expression);
	}
	/**
	 * Creates a function invocation for {@code atan2({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-atan2">atan2</a>.
	 *
	 * @param y the y value of a point
	 * @param x the x value of a point
	 * @return A function call for {@code atan2({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation atan2(@NotNull Expression y,
		@NotNull Expression x) {
		return Functions.atan2(y, x);
	}
	/**
	 * Creates a function invocation for {@code cos({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-cos">cos</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code cos({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cos(@NotNull Expression expression) {
		return Functions.cos(expression);
	}
	/**
	 * Creates a function invocation for {@code cot({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-cot">cot</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code cot({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cot(@NotNull Expression expression) {
		return Functions.cot(expression);
	}
	/**
	 * Creates a function invocation for {@code degrees({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-degrees">degrees</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code degrees({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation degrees(@NotNull Expression expression) {
		return Functions.degrees(expression);
	}
	/**
	 * Creates a function invocation for {@code haversin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-haversin">haversin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code haversin({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation haversin(@NotNull Expression expression) {
		return Functions.haversin(expression);
	}
	/**
	 * Creates a function invocation for {@code pi({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-pi">pi</a>.
	 *
	 * @return A function call for {@code pi({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation pi() {
		return Functions.pi();
	}
	/**
	 * Creates a function invocation for {@code radians({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-radians">radians</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code radians({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation radians(@NotNull Expression expression) {
		return Functions.radians(expression);
	}
	/**
	 * Creates a function invocation for {@code sin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sin">sin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sin({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sin(@NotNull Expression expression) {
		return Functions.sin(expression);
	}
	/**
	 * Creates a function invocation for {@code tan({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-tan">tan</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code tan({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation tan(@NotNull Expression expression) {
		return Functions.tan(expression);
	}
	/**
	 * Creates a function invocation for {@code toInteger({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tointeger">toInteger</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toInteger({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toInteger(@NotNull Expression expression) {
		return Functions.toInteger(expression);
	}
	/**
	 * Creates a function invocation for {@code toString({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-tostring">toString</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toString({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toString(@NotNull Expression expression) {
		return Functions.toString(expression);
	}
	/**
	 * Creates a function invocation for {@code toStringOrNull({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toStringOrNull">toStringOrNull</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toStringOrNull({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toStringOrNull(@NotNull Expression expression) {
		return Functions.toStringOrNull(expression);
	}
	/**
	 * Creates a function invocation for {@code toFloat({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tofloat">toFloat</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toFloat({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toFloat(@NotNull Expression expression) {
		return Functions.toFloat(expression);
	}
	/**
	 * Creates a function invocation for {@code toBoolean({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-toboolean">toBoolean</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toBoolean({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toBoolean(@NotNull Expression expression) {
		return Functions.toBoolean(expression);
	}
	/**
	 * Creates a function invocation for {@code linenumber({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code linenumber({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation linenumber() {
		return Functions.linenumber();
	}
	/**
	 * Creates a function invocation for {@code file({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code file({})}.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation file() {
		return Functions.file();
	}
	/**
	 * Creates a function invocation for {@code randomUUID({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code randomUUID({})}.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static FunctionInvocation randomUUID() {
		return Functions.randomUUID();
	}
	/**
	 * Creates a function invocation for {@code length()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-length">length</a>.
	 *
	 * @param path The path for which the length should be retrieved
	 * @return A function call for {@code length()} on a path.
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation length(@NotNull NamedPath path) {
		return Functions.length(path);
	}
	/**
	 * Creates a function invocation for {@code graph.names()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-names">graph.names</a>.
	 *
	 * @return A function call for {@code graph.names()}.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphNames() {
		return Functions.graphNames();
	}
	/**
	 * Creates a function invocation for {@code graph.propertiesByName()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-propertiesByName">graph.propertiesByName</a>.
	 *
	 * @param name The name of the graph
	 * @return A function call for {@code graph.propertiesByName()}.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphPropertiesByName(Expression name) {
		return Functions.graphPropertiesByName(name);
	}
	/**
	 * Creates a function invocation for {@code graph.byName()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-byname">graph.byName</a>.
	 *
	 * @param name The name of the graph
	 * @return A function call for {@code graph.byName()}.
	 * @since 2023.9.0
	 */
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphByName(
		Expression name) {
		return Functions.graphByName(name);
	}
	/**
	 * Create a new map projection with the given, mixed content
	 *
	 * @param name    The symbolic name of this project
	 * @param content The projected content
	 * @return A new map projection
	 * @since 2023.9.0
	 */
	public static MapProjection createProjection(SymbolicName name, Object... content) {
		return MapProjection.create(name, content);
	}
	/**
	 * Creates an unary minus operation.
	 *
	 * @param e The expression to which the unary minus should be applied. We don't check if it's a numeric expression,
	 *          but in hindsight to generate semantically correct Cypher, it's recommended that is one.
	 * @return An unary minus operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation minus(Expression e) {
		return Operations.minus(e);
	}
	/**
	 * Creates an unary plus operation.
	 *
	 * @param e The expression to which the unary plus should be applied. We don't check if it's a numeric expression,
	 *          but in hindsight to generate semantically correct Cypher, it's recommended that is one.
	 * @return An unary plus operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Expression plus(Expression e) {
		return Operations.plus(e);
	}
	@SuppressWarnings("deprecation")
	public static Operation concat(Expression op1, Expression op2) {
		return Operations.concat(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation add(Expression op1, Expression op2) {
		return Operations.add(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation subtract(Expression op1, Expression op2) {
		return Operations.subtract(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation multiply(Expression op1, Expression op2) {
		return Operations.multiply(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation divide(Expression op1, Expression op2) {
		return Operations.divide(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation remainder(Expression op1, Expression op2) {
		return Operations.remainder(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation pow(Expression op1, Expression op2) {
		return Operations.pow(op1, op2);
	}
	/**
	 * Creates a {@code =} operation. The left hand side should resolve to a property or to something which has labels
	 * or types to modify and the right hand side should either be new properties or labels.
	 *
	 * @param target The target that should be modified
	 * @param value  The new value of the target
	 * @return A new operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation set(Expression target, Expression value) {
		return Operations.set(target, value);
	}
	/**
	 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
	 * of properties and the right hand side must be a map of new or updated properties
	 *
	 * @param target The target container that should be modified
	 * @param value  The new properties
	 * @return A new operation.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation mutate(Expression target, MapExpression value) {
		return Operations.mutate(target, value);
	}
	/**
	 * Creates a {@code +=} operation. The left hand side must resolve to a container (either a node or a relationship)
	 * of properties and the right hand side must be a map of new or updated properties
	 *
	 * @param target The target container that should be modified
	 * @param value  The new properties
	 * @return A new operation.
	 * @since 2023.9.0
	 */
	public static Operation mutate(Expression target, Expression value) {
		return Operations.mutate(target, value);
	}
	/**
	 * Creates an operation adding one or more labels from a given {@link Node node}.
	 *
	 * @param target The target of the new labels
	 * @param label  The labels to be added
	 * @return A set operation
	 * @since 2023.9.0
	 */
	public static Operation setLabel(Node target, String... label) {
		return Operations.set(target, label);
	}
	/**
	 * Creates an operation removing one or more labels from a given {@link Node node}.
	 *
	 * @param target The target of the remove operation
	 * @param label  The labels to be removed
	 * @return A remove operation
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Operation removeLabel(Node target, String... label) {
		return Operations.remove(target, label);
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param property The property to be passed to {@code exists()}
	 * @return A function call for {@code exists()} for one property
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition exists(Property property) {
		return Predicates.exists(property);
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param pattern The pattern to be passed to {@code exists()}
	 * @return A function call for {@code exists()} for one pattern
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition exists(RelationshipPattern pattern) {
		return Predicates.exists(pattern);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a>. The statement may or  may not have  a {@literal  RETURN} clause. It  must however not  contain any
	 * updates. While it  would render syntactically correct  Cypher, Neo4j does not support  updates inside existential
	 * sub-queries.
	 *
	 * @param statement The statement to be passed to {@code exists{}}
	 * @param imports   Optional imports to be used in the statement (will be imported with {@literal WITH})
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(Statement statement, IdentifiableElement... imports) {
		return Predicates.exists(statement, imports);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns
	 *
	 * @param pattern the pattern that must exists
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(PatternElement pattern) {
		return Predicates.exists(pattern);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns
	 *
	 * @param pattern the list of patterns that must exists
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(List<PatternElement> pattern) {
		return Predicates.exists(pattern);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns and an optional {@link Where where-clause}.
	 *
	 * @param pattern the list of patterns that must exists
	 * @param where   an optional where-clause
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	@SuppressWarnings("deprecation")
	public static Condition exists(List<PatternElement> pattern, @Nullable Where where) {
		return Predicates.exists(pattern, where);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code all()} predicate function
	 * @see #all(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction all(String variable) {
		return Predicates.all(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code all()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code all()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction all(
		SymbolicName variable) {
		return Predicates.all(variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code any()} predicate function
	 * @see #any(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction any(String variable) {
		return Predicates.any(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code any()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-any">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code any()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction any(
		SymbolicName variable) {
		return Predicates.any(variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code none()} predicate function
	 * @see #none(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction none(String variable) {
		return Predicates.none(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code none()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-none">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code none()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction none(
		SymbolicName variable) {
		return Predicates.none(variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code single()} predicate function
	 * @see #single(SymbolicName)
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction single(String variable) {
		return Predicates.single(variable);
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code single()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-single">single</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code single()} predicate function
	 * @since 2023.9.0
	 */
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction single(
		SymbolicName variable) {
		return Predicates.single(variable);
	}
	/**
	 * Not to be instantiated.
	 */
	private Cypher() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
import org.neo4j.cypherdsl.core.annotations.CheckReturnValue;
/**
 * A typed subtree representing the arguments of a call to the {@code reduce()} function.
 *
 * @author Gerrit Meier
 * @author Michael J. Simons
 * @soundtrack Metallica - Metallica
 * @see Cypher#reduce(SymbolicName)
 * @since 2020.1.5
 */
@API(status = STABLE, since = "2020.1.5")
public final class Reduction extends TypedSubtree<Visitable> {
	/**
	 * Step 1: Define the variable of the reduction
	 *
	 * @param variable The closure will have a variable introduced in its context. We decide here which variable to use.
	 * @return An ongoing definition
	 */
	@NotNull @Contract(pure = true)
	static OngoingDefinitionWithVariable of(SymbolicName variable) {
		Assertions.notNull(variable, "A variable is required");
		return new Builder(variable);
	}
	private Reduction(Visitable... children) {
		super(children);
	}
	/**
	 * Step 2: Define the list
	 */
	public interface OngoingDefinitionWithVariable {
		/**
		 * @param list The list that is the subject of the reduction
		 * @return An ongoing definition
		 */
		@NotNull @CheckReturnValue
		OngoingDefinitionWithList in(Expression list);
	}
	/**
	 * Step 3: Define the map expression
	 */
	public interface OngoingDefinitionWithList {
		/**
		 * @param mapper This expression will run once per value in the list, and produce the result value.
		 * @return An ongoing definition
		 */
		@NotNull @CheckReturnValue
		OngoingDefinitionWithReducer map(Expression mapper);
	}
	/**
	 * Step 4a: Define the accumulator
	 */
	public interface OngoingDefinitionWithReducer {
		/**
		 * @param accumulator A variable that will hold the result and the partial results as the list is iterated.
		 * @return An ongoing definition
		 */
		@NotNull @CheckReturnValue
		OngoingDefinitionWithInitial accumulateOn(Expression accumulator);
	}
	/**
	 * Step 4b: Define the initial value
	 */
	public interface OngoingDefinitionWithInitial {
		/**
		 * @param initialValue An expression that runs once to give a starting value to the accumulator.
		 * @return An ongoing definition
		 */
		@NotNull @Contract(pure = true)
		FunctionInvocation withInitialValueOf(Expression initialValue);
	}
	private static class Builder
		implements OngoingDefinitionWithVariable, OngoingDefinitionWithList, OngoingDefinitionWithInitial,
		OngoingDefinitionWithReducer {
		private Expression accumulatorExpression;
		private final SymbolicName variable;
		private Expression listExpression;
		private Expression mapExpression;
		private Builder(SymbolicName variable) {
			this.variable = variable;
		}
		@Override
		public OngoingDefinitionWithList in(Expression list) {
			this.listExpression = list;
			return this;
		}
		@Override
		public OngoingDefinitionWithReducer map(Expression mapper) {
			this.mapExpression = mapper;
			return this;
		}
		@Override
		public OngoingDefinitionWithInitial accumulateOn(Expression accumulator) {
			this.accumulatorExpression = accumulator;
			return this;
		}
		@Override
		public FunctionInvocation withInitialValueOf(Expression initialValue) {
			Expression accumulatorAssignment = accumulatorExpression.isEqualTo(initialValue);
			ReductionPipeline reductionPipeline = new ReductionPipeline(variable, listExpression, mapExpression);
			Reduction reduction = new Reduction(accumulatorAssignment, reductionPipeline);
			return FunctionInvocation.create(BuiltInFunctions.Lists.REDUCE, reduction);
		}
	}
	private static final class ReductionPipeline implements Visitable {
		private final SymbolicName variable;
		private final Expression list;
		private final Expression expression;
		ReductionPipeline(SymbolicName variable, Expression list, Expression expression) {
			this.variable = variable;
			this.list = list;
			this.expression = expression;
		}
		@Override
		public void accept(Visitor visitor) {
			visitor.enter(this);
			this.variable.accept(visitor);
			Operator.IN.accept(visitor);
			this.list.accept(visitor);
			Operator.PIPE.accept(visitor);
			this.expression.accept(visitor);
			visitor.leave(this);
		}
		@Override
		public String toString() {
			return RendererBridge.render(this);
		}
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.List;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
final class PatternExpressionImpl implements PatternExpression, Visitable {
	private final Pattern pattern;
	PatternExpressionImpl(PatternElement patternElement) {
		this.pattern = Pattern.of(List.of(patternElement));
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.pattern.accept(visitor);
		visitor.leave(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * This wraps a function into a condition so that it can be used in a where clause. The function is supposed to return a
 * boolean value.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
@API(status = INTERNAL, since = "1.0")
final class BooleanFunctionCondition implements Condition {
	private final FunctionInvocation delegate;
	BooleanFunctionCondition(FunctionInvocation delegate) {
		this.delegate = delegate;
	}
	@Override
	public void accept(Visitor visitor) {
		delegate.accept(visitor);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.utils;
import java.util.Arrays;
import java.util.Objects;
import org.apiguardian.api.API;
/**
 * Assertions used throughout the Cypher-DSL. Mostly copied over from {@literal org.springframework.util.Assert}. Thanks
 * to the original authors: Keith Donald, Juergen Hoeller, Sam Brannen, Colin Sampaleanu and Rob Harrop.
 * Not supported for external use in any way.
 *
 * @since 2020.0.0
 */
@API(status = API.Status.INTERNAL, since = "2020.0.0")
public final class Assertions {
	/**
	 * Assert that the given String contains valid text content; that is, it must not
	 * be {@code null} and must contain at least one non-whitespace character.
	 * <pre class="code">Assert.hasText(name, "'name' must not be empty");</pre>
	 *
	 * @param text    the String to check
	 * @param message the exception message to use if the assertion fails
	 * @throws IllegalArgumentException if the text does not contain valid text content
	 */
	public static void hasText(String text, String message) {
		if (!Strings.hasText(text)) {
			throw new IllegalArgumentException(message);
		}
	}
	/**
	 * Assert a boolean expression, throwing an {@code IllegalArgumentException}
	 * if the expression evaluates to {@code false}.
	 * <pre class="code">Assert.isTrue(i &gt; 0, "The value must be greater than zero");</pre>
	 *
	 * @param expression a boolean expression
	 * @param message    the exception message to use if the assertion fails
	 * @throws IllegalArgumentException if {@code expression} is {@code false}
	 */
	public static void isTrue(boolean expression, String message) {
		if (!expression) {
			throw new IllegalArgumentException(message);
		}
	}
	/**
	 * Assert that an object is not {@code null}.
	 * <pre class="code">Assert.notNull(clazz, "The class must not be null");</pre>
	 *
	 * @param object  the object to check
	 * @param message the exception message to use if the assertion fails
	 * @throws IllegalArgumentException if the object is {@code null}
	 */
	public static void notNull(Object object, String message) {
		if (object == null) {
			throw new IllegalArgumentException(message);
		}
	}
	/**
	 * Assert that the provided object is an instance of the provided class.
	 * <pre class="code">Assert.instanceOf(Foo.class, foo, "Foo expected");</pre>
	 *
	 * @param type    the type to check against
	 * @param obj     the object to check
	 * @param message the exception message to use if the assertion fails
	 * @throws IllegalArgumentException if the object is not an instance of type
	 */
	public static void isInstanceOf(Class<?> type, Object obj, String message) {
		notNull(type, "Type to check against must not be null");
		if (!type.isInstance(obj)) {
			throw new IllegalArgumentException(message);
		}
	}
	/**
	 * Assert that an array contains elements; that is, it must not be
	 * {@code null} and must contain at least one element.
	 * <pre class="code">Assert.notEmpty(array, "The array must contain elements");</pre>
	 *
	 * @param array   the array to check
	 * @param message the exception message to use if the assertion fails
	 * @throws IllegalArgumentException if the object array is {@code null} or contains no elements
	 */
	public static void notEmpty(Object[] array, String message) {
		if (isEmpty(array)) {
			throw new IllegalArgumentException(message);
		}
	}
	private static boolean isEmpty(Object[] array) {
		return array == null || array.length == 0 || Arrays.stream(array).allMatch(Objects::isNull);
	}
	private Assertions() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.renderer.Configuration;
import org.neo4j.cypherdsl.core.renderer.Dialect;
import org.neo4j.cypherdsl.core.renderer.GeneralizedRenderer;
import org.neo4j.cypherdsl.core.renderer.Renderer;
/**
 * A bridge to the renderer as a single entry point from core to the renderer infrastructure.
 *
 * @author Michael J. Simons
 * @since 2023.1.0
 */
class RendererBridge {
	private static final Configuration CONFIGURATION = Configuration.newConfig()
		.withDialect(Dialect.NEO4J_5)
		.alwaysEscapeNames(false).build();
	static String render(Visitable visitable) {
		String name;
		Class<? extends Visitable> clazz = visitable.getClass();
		if (clazz.isAnonymousClass()) {
			name = clazz.getName();
		} else {
			name = clazz.getSimpleName();
		}
		return "%s{cypher=%s}".formatted(name, Renderer.getRenderer(CONFIGURATION, GeneralizedRenderer.class).render(visitable));
	}
	private RendererBridge() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.TimeZone;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Aggregates;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Lists;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Predicates;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Scalars;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Spatials;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Strings;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * Factory methods for creating instances of {@link FunctionInvocation functions}.
 *
 * @author Michael J. Simons
 * @author Gerrit Meier
 * @author Romain Rossi
 * @since 1.0
 */
final class Functions {
	/**
	 * Creates a function invocation for {@code id{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-id">id</a>.
	 *
	 * @param node The node for which the internal id should be retrieved
	 * @return A function call for {@code id()} on a node.
	 * @deprecated see {@link #elementId(Node)} for a replacement. Neo4j the database will remove support for {@code id(n)}
	 * at some point.
	 */
	@NotNull @Contract(pure = true)
	@Deprecated(since = "2023.3.0")
	@SuppressWarnings({ "squid:S1133" }) // Yes, I promise, this will be removed at some point, but not yet.
	static FunctionInvocation id(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Scalars.ID, node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code id{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-id">id</a>.
	 *
	 * @param relationship The relationship for which the internal id should be retrieved
	 * @return A function call for {@code id()} on a relationship.
	 * @deprecated see {@link #elementId(Relationship)} for a replacement. Neo4j the database will remove support for
	 * {@code id(n)} at some point.
	 */
	@NotNull @Contract(pure = true)
	@Deprecated(since = "2023.3.0")
	@SuppressWarnings({ "squid:S1133" }) // Yes, I promise, this will be removed at some point, but not yet.
	static FunctionInvocation id(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.ID, relationship.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code elementId{}}.
	 *
	 * @param node The node for which the element id should be retrieved
	 * @return A function call for {@code elementId()} on a node.
	 */
	@NotNull @Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation elementId(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Scalars.ELEMENT_ID, node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code elementId{}}.
	 *
	 * @param relationship The relationship for which the element id should be retrieved
	 * @return A function call for {@code elementId()} on a relationship.
	 */
	@NotNull @Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation elementId(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.ELEMENT_ID, relationship.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param node The node which keys should be returned.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation keys(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return keys(node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param relationship The relationship which keys should be returned.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation keys(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return keys(relationship.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code keys{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-keys">keys</a>.
	 *
	 * @param expression The expressions which keys should be returned. Must resolve to a node, relationship or map.
	 * @return A function call for {@code keys()} on an expression.
	 * @since 2021.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation keys(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		Expression param = expression instanceof Named named ? named.getRequiredSymbolicName() : expression;
		return FunctionInvocation.create(Lists.KEYS, param);
	}
	/**
	 * Creates a function invocation for {@code labels{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-labels">labels</a>.
	 *
	 * @param node The node for which the labels should be retrieved
	 * @return A function call for {@code labels()} on a node.
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation labels(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return labels(node.getRequiredSymbolicName());
	}
	/**
	 * Creates a  function invocation for  {@code labels{}}.  The {@link SymbolicName  symbolic name} {@code  node} must
	 * point to a node. This can't be checked during compile time, so please make sure of that.
	 * <p>
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-labels">labels</a>.
	 *
	 * @param node The node for which the labels should be retrieved
	 * @return A function call for {@code labels()} on a node.
	 * @since 2023.2.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation labels(@NotNull SymbolicName node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Lists.LABELS, node);
	}
	/**
	 * Creates a function invocation for {@code type{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-type">type</a>.
	 *
	 * @param relationship The relationship for which the type should be retrieved
	 * @return A function call for {@code type()} on a relationship.
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation type(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return type(relationship.getRequiredSymbolicName());
	}
	/**
	 * Creates a  function invocation for  {@code type{}}. The {@link  SymbolicName symbolic name}  {@code relationship}
	 * must point to a relationship. This can't be checked during compile time, so please make sure of that.
	 * <p>
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-type">type</a>.
	 *
	 * @param relationship The relationship for which the type should be retrieved
	 * @return A function call for {@code type()} on a relationship.
	 * @since 2023.2.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation type(@NotNull SymbolicName relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.TYPE, relationship);
	}
	/**
	 * @param node The named node to be counted
	 * @return A function call for {@code count()} for one named node
	 * @see #count(Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation count(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Aggregates.COUNT, node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for the {@code count()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count">count</a>.
	 *
	 * @param expression An expression describing the things to count.
	 * @return A function call for {@code count()} for an expression like {@link Cypher#asterisk()} etc.
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation count(Expression expression) {
		return FunctionInvocation.create(Aggregates.COUNT, expression);
	}
	/**
	 * Creates a function invocation for a {@code count()} function with {@code DISTINCT} added.
	 *
	 * @param node The named node to be counted
	 * @return A function call for {@code count()} for one named node
	 * @see #countDistinct(Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation countDistinct(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.createDistinct(Aggregates.COUNT, node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for a {@code count()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count">count</a>.
	 *
	 * @param expression An expression describing the things to count.
	 * @return A function call for {@code count()} for an expression like {@link Cypher#asterisk()} etc.
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation countDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.COUNT, expression);
	}
	/**
	 * Creates a function invocation for {@code properties())} on nodes.
	 *
	 * @param node The node who's properties should be returned.
	 * @return A function call for {@code properties())}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation properties(Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Scalars.PROPERTIES, node.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code properties())} on relationships.
	 *
	 * @param relationship The relationship who's properties should be returned.
	 * @return A function call for {@code properties())}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation properties(Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.PROPERTIES, relationship.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for {@code properties())} on maps.
	 *
	 * @param map The map who's properties should be returned.
	 * @return A function call for {@code properties())}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation properties(MapExpression map) {
		return FunctionInvocation.create(Scalars.PROPERTIES, map);
	}
	/**
	 * Creates a function invocation for the {@code coalesce()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-coalesce">coalesce</a>.
	 *
	 * @param expressions One or more expressions to be coalesced
	 * @return A function call for {@code coalesce}.
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation coalesce(Expression... expressions) {
		return FunctionInvocation.create(Scalars.COALESCE, expressions);
	}
	/**
	 * Creates a function invocation for the {@code left()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-left">left</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @param length     desired length
	 * @return A function call for {@code left()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation left(Expression expression, Expression length) {
		if (expression != null && length == null) {
			throw new IllegalArgumentException("length might not be null when the expression is not null");
		}
		return FunctionInvocation.create(Strings.LEFT,
			expressionOrNullLit(expression),
			expressionOrNullLit(length)
		);
	}
	/**
	 * Creates a function invocation for the {@code ltrim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-ltrim">ltrim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code ltrim()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation ltrim(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.LTRIM, expressionOrNullLit(expression));
	}
	/**
	 * Creates a function invocation for the {@code replace()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-ltrim">replace</a>.
	 *
	 * @param original An expression that returns a string
	 * @param search   An expression that specifies the string to be replaced in {@code original}.
	 * @param replace  An expression that specifies the replacement string.
	 * @return A function call for {@code replace()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation replace(Expression original, Expression search, Expression replace) {
		return FunctionInvocation.create(Strings.REPLACE, expressionOrNullLit(original), expressionOrNullLit(search),
			expressionOrNullLit(replace));
	}
	/**
	 * Creates a function invocation for the {@code reverse()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-reverse">reverse</a>.
	 *
	 * @param original An expression that returns a string
	 * @return A function call for {@code reverse()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation reverse(@NotNull Expression original) {
		Assertions.notNull(original, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.REVERSE, expressionOrNullLit(original));
	}
	/**
	 * Creates a function invocation for the {@code right()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-left">right</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @param length     desired length
	 * @return A function call for {@code right()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation right(Expression expression, Expression length) {
		if (expression != null && length == null) {
			throw new IllegalArgumentException("length might not be null when the expression is not null");
		}
		return FunctionInvocation.create(Strings.RIGHT,
			expressionOrNullLit(expression),
			expressionOrNullLit(length)
		);
	}
	/**
	 * Creates a function invocation for the {@code rtrim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-rtrim">rtrim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code rtrim()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation rtrim(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.RTRIM, expressionOrNullLit(expression));
	}
	/**
	 * Creates a function invocation for the {@code substring()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-substring">rtrim</a>.
	 *
	 * @param original An expression resolving to a string
	 * @param start    An expression that returns a positive integer, denoting the position at which the substring will begin.
	 * @param length   An expression that returns a positive integer, denoting how many characters of original will be returned.
	 * @return A function call for {@code substring()}
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation substring(Expression original, Expression start, Expression length) {
		Assertions.notNull(start, "start is required");
		if (length != null) {
			return FunctionInvocation.create(Strings.SUBSTRING, expressionOrNullLit(original), start, length);
		}
		return FunctionInvocation.create(Strings.SUBSTRING, expressionOrNullLit(original), start);
	}
	private static Expression expressionOrNullLit(Expression expression) {
		return expression == null ? Cypher.literalNull() : expression;
	}
	/**
	 * Creates a function invocation for the {@code toLower()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toLower">toLower</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code toLower()} for one expression
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toLower(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TO_LOWER, expressionOrNullLit(expression));
	}
	/**
	 * Creates a function invocation for the {@code toUpper()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toUpper">toUpper</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code toLower()} for one expression
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toUpper(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TO_UPPER, expressionOrNullLit(expression));
	}
	/**
	 * Creates a function invocation for the {@code trim()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-trim">trim</a>.
	 *
	 * @param expression An expression resolving to a string
	 * @return A function call for {@code trim()} for one expression
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation trim(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TRIM, expression);
	}
	/**
	 * Creates a function invocation for the {@code split()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-split">split</a>.
	 *
	 * @param expression An expression resolving to a string that should be split
	 * @param delimiter  The delimiter on which to split
	 * @return A function call for {@code split()}
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation split(@NotNull Expression expression, @NotNull Expression delimiter) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		Assertions.notNull(delimiter, "The delimiter is required.");
		return FunctionInvocation.create(Strings.SPLIT, expression, delimiter);
	}
	/**
	 * Creates a function invocation for the {@code split()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-split">split</a>.
	 *
	 * @param expression An expression resolving to a string that should be split
	 * @param delimiter  The delimiter on which to split
	 * @return A function call for {@code split()}
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation split(@NotNull Expression expression, @NotNull String delimiter) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		Assertions.notNull(delimiter, "The delimiter is required.");
		return split(expression, Cypher.literalOf(delimiter));
	}
	/**
	 * Creates a function invocation for the {@code size()} function. {@code size} can be applied to
	 * <ul>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size">a list</a></li>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-string">to a string</a></li>
	 * </ul>
	 *
	 * @param expression The expression who's size is to be returned
	 * @return A function call for {@code size()} for one expression
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation size(Expression expression) {
		return FunctionInvocation.create(Scalars.SIZE, expression);
	}
	/**
	 * Creates a function invocation for the {@code size()} function. {@code size} can be applied to
	 * <ul>
	 * <li><a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size-of-pattern-expression">to a pattern expression</a></li>
	 * </ul>
	 *
	 * @param pattern The pattern for which {@code size()} should be invoked.
	 * @return A function call for {@code size()} for a pattern
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation size(RelationshipPattern pattern) {
		return FunctionInvocation.create(Scalars.SIZE, pattern);
	}
	/**
	 * Creates a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param expression The expression who's existence is to be evaluated
	 * @return A function call for {@code exists()} for one expression
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation exists(Expression expression) {
		return FunctionInvocation.create(Predicates.EXISTS, expression);
	}
	/**
	 * Creates a function invocation for the {@code distance()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-distance">exists</a>.
	 * Both points need to be in the same coordinate system.
	 *
	 * @param point1 Point 1
	 * @param point2 Point 2
	 * @return A function call for {@code distance()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation distance(@NotNull Expression point1, @NotNull Expression point2) {
		Assertions.notNull(point1, "The distance function requires two points.");
		Assertions.notNull(point2, "The distance function requires two points.");
		return FunctionInvocation.create(Spatials.DISTANCE, point1, point2);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 *
	 * @param parameterMap The map of parameters for {@code point()}
	 * @return A function call for {@code point()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation point(MapExpression parameterMap) {
		return point((Expression) parameterMap);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 * <p>
	 * This generic expression variant is useful for referencing a point inside a parameter or another map.
	 *
	 * @param expression An expression resolving to a valid map of parameters for {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation point(Expression expression) {
		return FunctionInvocation.create(Spatials.POINT, expression);
	}
	/**
	 * Creates a function invocation for the {@code point()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-point">point</a>.
	 *
	 * @param parameter A parameter referencing a {@code point()}
	 * @return A function call for {@code point()}
	 * @since 2022.7.3
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation point(Parameter<?> parameter) {
		return FunctionInvocation.create(Spatials.POINT, parameter);
	}
	/**
	 * Convenience method for creating a 2d cartesian point
	 *
	 * @param x The x coordinate
	 * @param y The y coordinate
	 * @return A function call for {@code point()}
	 * @since 2022.7.3
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation cartesian(double x, double y) {
		return point(Cypher.mapOf("x", Cypher.literalOf(x), "y", Cypher.literalOf(y)));
	}
	/**
	 * Convenience method for creating a 2d coordinate in the WGS 84 coordinate system
	 *
	 * @param longitude The longitude
	 * @param latitude  The latitude
	 * @return A function call for {@code point()}
	 * @since 2022.7.3
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation coordinate(double longitude, double latitude) {
		return point(Cypher.mapOf("longitude", Cypher.literalOf(longitude), "latitude", Cypher.literalOf(latitude)));
	}
	/**
	 * Creates a function invocation for the {@code point.withinBBox} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/spatial/#functions-withinBBox">point.withinBBox</a>.
	 *
	 * @param point      The point to check
	 * @param lowerLeft  The lower left point of the bounding box (south-west coordinate)
	 * @param upperRight The upper right point of the bounding box (north-east coordinate)
	 * @return A function call for {@code point.withinBBox}
	 * @since 2022.7.3
	 */
	static FunctionInvocation withinBBox(Expression point, Expression lowerLeft, Expression upperRight) {
		return FunctionInvocation.create(() -> "point.withinBBox", point, lowerLeft, upperRight);
	}
	/**
	 * Creates a function invocation for the {@code avg()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg">avg</a>.
	 *
	 * @param expression The things to average
	 * @return A function call for {@code avg()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation avg(Expression expression) {
		return FunctionInvocation.create(Aggregates.AVG, expression);
	}
	/**
	 * Creates a function invocation for the {@code avg()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg">avg</a>.
	 *
	 * @param expression The things to average
	 * @return A function call for {@code avg()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation avgDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.AVG, expression);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function.
	 *
	 * @param variable The named thing to collect
	 * @return A function call for {@code collect()}
	 * @see #collect(Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation collect(@NotNull Named variable) {
		Assertions.notNull(variable, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_VARIABLE_REQUIRED));
		return FunctionInvocation.create(Aggregates.COLLECT, variable.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for the {@code collect()} function with {@code DISTINCT} added.
	 *
	 * @param variable The named thing to collect
	 * @return A function call for {@code collect()}
	 * @see #collect(Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation collectDistinct(@NotNull Named variable) {
		Assertions.notNull(variable, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_VARIABLE_REQUIRED));
		return FunctionInvocation.createDistinct(Aggregates.COLLECT, variable.getRequiredSymbolicName());
	}
	/**
	 * Creates a function invocation for the {@code collect()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect">collect</a>.
	 *
	 * @param expression The things to collect
	 * @return A function call for {@code collect()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation collect(Expression expression) {
		return FunctionInvocation.create(Aggregates.COLLECT, expression);
	}
	/**
	 * Creates a function invocation for the {@code collect()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect">collect</a>.
	 *
	 * @param expression The things to collect
	 * @return A function call for {@code collect()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation collectDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.COLLECT, expression);
	}
	/**
	 * Creates a function invocation for the {@code max()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max">max</a>.
	 *
	 * @param expression A list from which the maximum element value is returned
	 * @return A function call for {@code max()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation max(Expression expression) {
		return FunctionInvocation.create(Aggregates.MAX, expression);
	}
	/**
	 * Creates a function invocation for the {@code max()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max">max</a>.
	 *
	 * @param expression A list from which the maximum element value is returned
	 * @return A function call for {@code max()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation maxDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.MAX, expression);
	}
	/**
	 * Creates a function invocation for the {@code min()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min">min</a>.
	 *
	 * @param expression A list from which the minimum element value is returned
	 * @return A function call for {@code min()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation min(Expression expression) {
		return FunctionInvocation.create(Aggregates.MIN, expression);
	}
	/**
	 * Creates a function invocation for the {@code min()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min">min</a>.
	 *
	 * @param expression A list from which the minimum element value is returned
	 * @return A function call for {@code min()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation minDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.MIN, expression);
	}
	private static void assertPercentileArguments(Aggregates builtIn, Expression expression, Number percentile) {
		Assertions
			.notNull(expression, "The numeric expression for " + builtIn.getImplementationName() + " is required.");
		Assertions.notNull(percentile, "The percentile for " + builtIn.getImplementationName() + " is required.");
		final double p = percentile.doubleValue();
		Assertions.isTrue(p >= 0D && p <= 1D,
			"The percentile for " + builtIn.getImplementationName() + " must be between 0.0 and 1.0.");
	}
	/**
	 * Creates a function invocation for the {@code percentileCont()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont">percentileCont</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileCont()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileCont(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_CONT, expression, percentile);
		return FunctionInvocation.create(Aggregates.PERCENTILE_CONT, expression, new NumberLiteral(percentile));
	}
	/**
	 * Creates a function invocation for the {@code percentileCont()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont">percentileCont</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileCont()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileContDistinct(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_CONT, expression, percentile);
		return FunctionInvocation.createDistinct(Aggregates.PERCENTILE_CONT, expression, new NumberLiteral(percentile));
	}
	/**
	 * Creates a function invocation for the {@code percentileDisc()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc">percentileDisc</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileDisc()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileDisc(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_DISC, expression, percentile);
		return FunctionInvocation.create(Aggregates.PERCENTILE_DISC, expression, new NumberLiteral(percentile));
	}
	/**
	 * Creates a function invocation for the {@code percentileDisc()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc">percentileDisc</a>.
	 *
	 * @param expression A numeric expression
	 * @param percentile A numeric value between 0.0 and 1.0
	 * @return A function call for {@code percentileDisc()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileDiscDistinct(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_DISC, expression, percentile);
		return FunctionInvocation.createDistinct(Aggregates.PERCENTILE_DISC, expression, new NumberLiteral(percentile));
	}
	/**
	 * Creates a function invocation for the {@code stDev()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev">stDev</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDev()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDev(Expression expression) {
		return FunctionInvocation.create(Aggregates.ST_DEV, expression);
	}
	/**
	 * Creates a function invocation for the {@code stDev()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev">stDev</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDev()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDevDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.ST_DEV, expression);
	}
	/**
	 * Creates a function invocation for the {@code stDevP()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp">stDevP</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDevP()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDevP(Expression expression) {
		return FunctionInvocation.create(Aggregates.ST_DEV_P, expression);
	}
	/**
	 * Creates a function invocation for the {@code stDevP()} function with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp">stDevP</a>.
	 *
	 * @param expression A numeric expression
	 * @return A function call for {@code stDevP()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDevPDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.ST_DEV_P, expression);
	}
	/**
	 * Creates a function invocation for the {@code sum()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum">sum</a>.
	 *
	 * @param expression An expression returning a set of numeric values
	 * @return A function call for {@code sum()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation sum(Expression expression) {
		return FunctionInvocation.create(Aggregates.SUM, expression);
	}
	/**
	 * Creates a function invocation for the {@code sum()} function  with {@code DISTINCT} added.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum">sum</a>.
	 *
	 * @param expression An expression returning a set of numeric values
	 * @return A function call for {@code sum()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation sumDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.SUM, expression);
	}
	/**
	 * @param start the range's start
	 * @param end   the range's end
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(Integer start, Integer end) {
		return range(Cypher.literalOf(start), Cypher.literalOf(end));
	}
	/**
	 * @param start the range's start
	 * @param end   the range's end
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression, Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(@NotNull Expression start, @NotNull Expression end) {
		return range(start, end, null);
	}
	/**
	 * Creates a function invocation for the {@code range()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range">range</a>.
	 *
	 * @param start the range's start
	 * @param end   the range's end
	 * @param step  the range's step
	 * @return A function call for {@code range()}
	 * @see #range(Expression, Expression, Expression)
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(@NotNull Integer start, @NotNull Integer end, Integer step) {
		return range(Cypher.literalOf(start), Cypher.literalOf(end), Cypher.literalOf(step));
	}
	/**
	 * Creates a function invocation for the {@code range()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-range">range</a>.
	 *
	 * @param start the range's start
	 * @param end   the range's end
	 * @param step  the range's step
	 * @return A function call for {@code range()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(@NotNull Expression start, @NotNull Expression end, Expression step) {
		Assertions.notNull(start, "The expression for range is required.");
		Assertions.notNull(end, "The expression for range is required.");
		if (step == null) {
			return FunctionInvocation.create(Lists.RANGE, start, end);
		} else {
			return FunctionInvocation.create(Lists.RANGE, start, end, step);
		}
	}
	/**
	 * Creates a function invocation for the {@code head()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-head">head</a>.
	 *
	 * @param expression A list from which the head element is returned
	 * @return A function call for {@code head()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation head(Expression expression) {
		return FunctionInvocation.create(Scalars.HEAD, expression);
	}
	/**
	 * Creates a function invocation for the {@code last()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-last">last</a>.
	 *
	 * @param expression A list from which the last element is returned
	 * @return A function call for {@code last()}
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation last(Expression expression) {
		return FunctionInvocation.create(Scalars.LAST, expression);
	}
	/**
	 * Creates a function invocation for {@code nodes{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes">nodes</a>.
	 *
	 * @param path The path for which the number of nodes should be retrieved
	 * @return A function call for {@code nodes()} on a path.
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation nodes(@NotNull NamedPath path) {
		Assertions.notNull(path, "The path for nodes is required.");
		return FunctionInvocation.create(Lists.NODES,
			path.getSymbolicName().orElseThrow(() -> new IllegalArgumentException(
				Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NAMED_PATH_REQUIRED))));
	}
	/**
	 * Creates a function invocation for {@code nodes{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-nodes">nodes</a>.
	 *
	 * @param symbolicName The symbolic name of a path for which the number of nodes should be retrieved
	 * @return A function call for {@code nodes{}} on a path represented by a symbolic name.
	 * @since 2020.1.5
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation nodes(@NotNull SymbolicName symbolicName) {
		Assertions.notNull(symbolicName, "The symbolic name of the path for nodes is required.");
		return FunctionInvocation.create(Lists.NODES, symbolicName);
	}
	/**
	 * Creates a function invocation for {@code relationships{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-relationships">relationships</a>.
	 *
	 * @param path The path for which the relationships should be retrieved
	 * @return A function call for {@code relationships()} on a path.
	 * @since 2020.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation relationships(@NotNull NamedPath path) {
		Assertions.notNull(path, "The path for relationships is required.");
		return FunctionInvocation.create(Lists.RELATIONSHIPS,
			path.getSymbolicName().orElseThrow(() -> new IllegalArgumentException(
				Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NAMED_PATH_REQUIRED))));
	}
	/**
	 * Creates a function invocation for {@code relationships{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-relationships">relationships</a>.
	 *
	 * @param symbolicName The symbolic name of a path for which the relationships should be retrieved
	 * @return A function call for {@code relationships()} on a path represented by a symbolic name.
	 * @since 2020.1.5
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation relationships(@NotNull SymbolicName symbolicName) {
		Assertions.notNull(symbolicName, "The symbolic name of the path for relationships is required.");
		return FunctionInvocation.create(Lists.RELATIONSHIPS, symbolicName);
	}
	/**
	 * Creates a function invocation for {@code startNode{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-startnode">startNode</a>.
	 *
	 * @param relationship The relationship for which the start node be retrieved
	 * @return A function call for {@code startNode()} on a path.
	 * @since 2020.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation startNode(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, "The relationship for endNode is required.");
		return FunctionInvocation.create(Scalars.START_NODE,
			relationship.getSymbolicName()
				.orElseThrow(() -> new IllegalArgumentException("The relationship needs to be named!")));
	}
	/**
	 * Creates a function invocation for {@code endNode{}}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-endnode">endNode</a>.
	 *
	 * @param relationship The relationship for which the end node be retrieved
	 * @return A function call for {@code endNode()} on a path.
	 * @since 2020.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation endNode(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, "The relationship for endNode is required.");
		return FunctionInvocation.create(Scalars.END_NODE,
			relationship.getSymbolicName()
				.orElseThrow(() -> new IllegalArgumentException("The relationship needs to be named!")));
	}
	/**
	 * Creates a function invocation for {@code date()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This is the most simple form.
	 *
	 * @return A function call for {@code date()}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation date() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year  The year
	 * @param month The month
	 * @param day   The day
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation calendarDate(Integer year, Integer month, Integer day) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Assertions.notNull(month, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_MONTH_REQUIRED));
		Assertions.notNull(day, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_DAY_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher
			.mapOf("year", Cypher.literalOf(year), "month", Cypher.literalOf(month), "day", Cypher.literalOf(day)));
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year      The year
	 * @param week      The optional week
	 * @param dayOfWeek The optional day of the week
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation weekDate(Integer year, Integer week, Integer dayOfWeek) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Object[] parameters = new Object[2 + (week == null ? 0 : 2) + (dayOfWeek == null ? 0 : 2)];
		int i = 0;
		parameters[i++] = "year";
		parameters[i++] = Cypher.literalOf(year);
		if (week != null) {
			parameters[i++] = "week";
			parameters[i++] = Cypher.literalOf(week);
		}
		if (dayOfWeek != null) {
			if (week == null) {
				throw new IllegalArgumentException("week is required when using dayOfWeek.");
			}
			parameters[i++] = "dayOfWeek";
			parameters[i] = Cypher.literalOf(dayOfWeek);
		}
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.mapOf(parameters));
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year         The year
	 * @param quarter      The optional week
	 * @param dayOfQuarter The optional day of the week
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation quarterDate(Integer year, Integer quarter, Integer dayOfQuarter) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Object[] parameters = new Object[2 + (quarter == null ? 0 : 2) + (dayOfQuarter == null ? 0 : 2)];
		int i = 0;
		parameters[i++] = "year";
		parameters[i++] = Cypher.literalOf(year);
		if (quarter != null) {
			parameters[i++] = "quarter";
			parameters[i++] = Cypher.literalOf(quarter);
		}
		if (dayOfQuarter != null) {
			parameters[i++] = "dayOfQuarter";
			parameters[i] = Cypher.literalOf(dayOfQuarter);
		}
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.mapOf(parameters));
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 *
	 * @param year       The year
	 * @param ordinalDay The ordinal day of the year.
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation ordinalDate(Integer year, Integer ordinalDay) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Object[] parameters = new Object[2 + (ordinalDay == null ? 0 : 2)];
		int i = 0;
		parameters[i++] = "year";
		parameters[i++] = Cypher.literalOf(year);
		if (ordinalDay != null) {
			parameters[i++] = "ordinalDay";
			parameters[i] = Cypher.literalOf(ordinalDay);
		}
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.mapOf(parameters));
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code date({})}
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation date(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, components);
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This creates a date from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation date(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.literalOf(temporalValue));
	}
	/**
	 * Creates a function invocation for {@code date({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">date</a>.
	 * This creates a date from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation date(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, temporalValue);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 *
	 * @return A function call for {@code datetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code datetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.DATETIME, timezoneMapLiteralOf(timeZone));
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/datetime/">datetime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code datetime({})}
	 * @return A function call for {@code datetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME, components);
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">datetime</a>.
	 * This creates a datetime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code datetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME, Cypher.literalOf(temporalValue));
	}
	/**
	 * Creates a function invocation for {@code datetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/date/">datetime</a>.
	 * This creates a datetime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code date({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME, temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 *
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.LOCALDATETIME, timezoneMapLiteralOf(timeZone));
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code localdatetime({})}
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME, components);
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This creates a localdatetime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME, Cypher.literalOf(temporalValue));
	}
	/**
	 * Creates a function invocation for {@code localdatetime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localdatetime</a>.
	 * This creates a localdatetime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code localdatetime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME, temporalValue);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localtime</a>.
	 *
	 * @return A function call for {@code localtime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code localtime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.LOCALTIME, timezoneMapLiteralOf(timeZone));
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localdatetime/">localtime</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code localtime({})}
	 * @return A function call for {@code localtime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME, components);
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 * This creates a localtime from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code localtime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME, Cypher.literalOf(temporalValue));
	}
	/**
	 * Creates a function invocation for {@code localtime({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/localtime/">localtime</a>.
	 * This creates a localtime from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code localtime({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME, temporalValue);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 *
	 * @return A function call for {@code time({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation time() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 *
	 * @param timeZone The timezone to use when creating the temporal instance
	 * @return A function call for {@code time({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.TIME, timezoneMapLiteralOf(timeZone));
	}
	private static Expression timezoneMapLiteralOf(TimeZone timeZone) {
		return Cypher.mapOf("timezone", Cypher.literalOf(timeZone.getID()));
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code time({})}
	 * @return A function call for {@code time({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME, components);
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This creates a time from a string.
	 *
	 * @param temporalValue A string representing a temporal value.
	 * @return A function call for {@code time({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME, Cypher.literalOf(temporalValue));
	}
	/**
	 * Creates a function invocation for {@code time({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/time/">time</a>.
	 * This creates a time from a string.
	 *
	 * @param temporalValue An expression representing a temporal value.
	 * @return A function call for {@code time({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME, temporalValue);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This is the most generic form.
	 *
	 * @param components The map to pass to {@code duration({})}
	 * @return A function call for {@code duration({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation duration(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DURATION, components);
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This creates a duration from a string.
	 *
	 * @param temporalAmount A string representing a temporal amount.
	 * @return A function call for {@code duration({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation duration(@NotNull String temporalAmount) {
		Assertions.hasText(temporalAmount, "The temporalAmount is required.");
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DURATION, Cypher.literalOf(temporalAmount));
	}
	/**
	 * Creates a function invocation for {@code duration({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/temporal/duration/">duration</a>.
	 * This creates a duration from a string.
	 *
	 * @param temporalAmount An expression representing a temporal amount.
	 * @return A function call for {@code duration({})}.
	 * @since 2020.1.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation duration(@NotNull Expression temporalAmount) {
		Assertions.notNull(temporalAmount, "The temporalAmount is required.");
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DURATION, temporalAmount);
	}
	/**
	 * Creates a function invocation for {@code shortestPath({})}.
	 *
	 * @param relationship The relationship to be passed to {@code shortestPath}.
	 * @return A function call for {@code shortestPath({})}.
	 * @since 2020.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation shortestPath(Relationship relationship) {
		return FunctionInvocation.create(Scalars.SHORTEST_PATH, relationship);
	}
	/**
	 * Starts building a function invocation for {@code reduce({})}.
	 *
	 * @param variable The closure will have a variable introduced in its context. We decide here which variable to use.
	 * @return An ongoing definition for a function call to {@code reduce({})}.
	 * @since 2020.1.5
	 */
	@NotNull @Contract(pure = true)
	static Reduction.OngoingDefinitionWithVariable reduce(@NotNull SymbolicName variable) {
		return Reduction.of(variable);
	}
	/**
	 * Creates a function invocation for {@code abs({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-abs">abs</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code abs({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation abs(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ABS, expression);
	}
	/**
	 * Creates a function invocation for {@code ceil({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-ceil">ceil</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code ceil({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation ceil(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.CEIL, expression);
	}
	/**
	 * Creates a function invocation for {@code floor({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-floor">floor</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code floor({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation floor(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.FLOOR, expression);
	}
	/**
	 * Creates a function invocation for {@code rand({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-rand">rand</a>.
	 *
	 * @return A function call for {@code rand({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation rand() {
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.RAND);
	}
	/**
	 * Creates a function invocation for {@code round({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-round">round</a>.
	 *
	 * @param value      The value to round
	 * @param expression Additional parameters, length must be 0, 1 or 2:
	 *                   First entry is the precision, second is the rounding mode
	 * @return A function call for {@code round({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation round(Expression value, Expression... expression) {
		if (expression == null || expression.length == 0) {
			return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ROUND, value);
		} else if (expression.length == 1) {
			return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ROUND, value, expression[0]);
		} else if (expression.length == 2) {
			return FunctionInvocation
				.create(BuiltInFunctions.MathematicalFunctions.ROUND, value, expression[0], expression[1]);
		} else {
			throw new IllegalArgumentException(
				"round() must be called with 1, 2 or 3 arguments (value, value + precision or value + precision + rounding mode.");
		}
	}
	/**
	 * Creates a function invocation for {@code sign({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sign">sign</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sign({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation sign(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.SIGN, expression);
	}
	/**
	 * Creates a function invocation for {@code e({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-e">e</a>.
	 *
	 * @return A function call for {@code e({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation e() {
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.E);
	}
	/**
	 * Creates a function invocation for {@code exp({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-exp">exp</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code exp({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation exp(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.EXP, expression);
	}
	/**
	 * Creates a function invocation for {@code log({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-log">log</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code log({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation log(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.LOG, expression);
	}
	/**
	 * Creates a function invocation for {@code log10({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-log10">log10</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code log10({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation log10(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.LOG10, expression);
	}
	/**
	 * Creates a function invocation for {@code sqrt({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sqrt">sqrt</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sqrt({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation sqrt(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.SQRT, expression);
	}
	/**
	 * Creates a function invocation for {@code acos({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-acos">acos</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code acos({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation acos(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ACOS, expression);
	}
	/**
	 * Creates a function invocation for {@code asin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-asin">asin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code asin({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation asin(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ASIN, expression);
	}
	/**
	 * Creates a function invocation for {@code atan({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-atan">atan</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code atan({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation atan(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ATAN, expression);
	}
	/**
	 * Creates a function invocation for {@code atan2({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-atan2">atan2</a>.
	 *
	 * @param y the y value of a point
	 * @param x the x value of a point
	 * @return A function call for {@code atan2({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation atan2(@NotNull Expression y, @NotNull Expression x) {
		Assertions.notNull(y, "y is required.");
		Assertions.notNull(x, "x is required.");
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ATAN2, y, x);
	}
	/**
	 * Creates a function invocation for {@code cos({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-cos">cos</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code cos({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation cos(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.COS, expression);
	}
	/**
	 * Creates a function invocation for {@code cot({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-cot">cot</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code cot({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation cot(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.COT, expression);
	}
	/**
	 * Creates a function invocation for {@code degrees({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-degrees">degrees</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code degrees({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation degrees(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.DEGREES, expression);
	}
	/**
	 * Creates a function invocation for {@code haversin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-haversin">haversin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code haversin({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation haversin(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.HAVERSIN, expression);
	}
	/**
	 * Creates a function invocation for {@code pi({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-pi">pi</a>.
	 *
	 * @return A function call for {@code pi({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation pi() {
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.PI);
	}
	/**
	 * Creates a function invocation for {@code radians({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-radians">radians</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code radians({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation radians(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.RADIANS, expression);
	}
	/**
	 * Creates a function invocation for {@code sin({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-sin">sin</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code sin({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation sin(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.SIN, expression);
	}
	/**
	 * Creates a function invocation for {@code tan({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/mathematical-numeric/#functions-tan">tan</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code tan({})}.
	 * @since 2021.0.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation tan(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.TAN, expression);
	}
	/**
	 * Creates a function invocation for {@code toInteger({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tointeger">toInteger</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toInteger({})}.
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toInteger(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_INTEGER, expression);
	}
	/**
	 * Creates a function invocation for {@code toString({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-tostring">toString</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toString({})}.
	 * @since 2022.3.0
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toString(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_STRING, expression);
	}
	/**
	 * Creates a function invocation for {@code toStringOrNull({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/string/#functions-toStringOrNull">toStringOrNull</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toStringOrNull({})}.
	 * @since 2023.0.2
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toStringOrNull(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TO_STRING_OR_NULL, expressionOrNullLit(expression));
	}
	/**
	 * Creates a function invocation for {@code toFloat({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-tofloat">toFloat</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toFloat({})}.
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toFloat(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_FLOAT, expression);
	}
	/**
	 * Creates a function invocation for {@code toBoolean({})}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-toboolean">toBoolean</a>.
	 *
	 * @param expression The value to pass to the function.
	 * @return A function call for {@code toBoolean({})}.
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation toBoolean(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_BOOLEAN, expression);
	}
	/**
	 * Creates a function invocation for {@code linenumber({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code linenumber({})}.
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation linenumber() {
		return FunctionInvocation.create(() -> "linenumber");
	}
	/**
	 * Creates a function invocation for {@code file({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code file({})}.
	 * @since 2021.2.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation file() {
		return FunctionInvocation.create(() -> "file");
	}
	/**
	 * Creates a function invocation for {@code randomUUID({})}. Only applicable inside an {@code LOAD CSV} clause.
	 *
	 * @return A function call for {@code randomUUID({})}.
	 * @since 2022.2.1
	 */
	static FunctionInvocation randomUUID() {
		return FunctionInvocation.create(() -> "randomUUID");
	}
	/**
	 * Creates a function invocation for {@code length()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-length">length</a>.
	 *
	 * @param path The path for which the length should be retrieved
	 * @return A function call for {@code length()} on a path.
	 * @since 2023.0.1
	 */
	@NotNull @Contract(pure = true)
	static FunctionInvocation length(@NotNull NamedPath path) {
		Assertions.notNull(path, "The path for length is required.");
		return FunctionInvocation.create(Scalars.LENGTH,
			path.getSymbolicName().orElseThrow(() -> new IllegalArgumentException(
				Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NAMED_PATH_REQUIRED))));
	}
	/**
	 * Creates a function invocation for {@code graph.names()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-names">graph.names</a>.
	 *
	 * @return A function call for {@code graph.names()}.
	 * @since 2023.4.0
	 */
	@NotNull
	@Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation graphNames() {
		return FunctionInvocation.create(BuiltInFunctions.Graph.NAMES);
	}
	/**
	 * Creates a function invocation for {@code graph.propertiesByName()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-propertiesByName">graph.propertiesByName</a>.
	 *
	 * @param name The name of the graph
	 * @return A function call for {@code graph.propertiesByName()}.
	 * @since 2023.4.0
	 */
	@NotNull
	@Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation graphPropertiesByName(Expression name) {
		return FunctionInvocation.create(BuiltInFunctions.Graph.PROPERTIES_BY_NAME, name);
	}
	/**
	 * Creates a function invocation for {@code graph.byName()}.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/graph/#functions-graph-byname">graph.byName</a>.
	 *
	 * @param name The name of the graph
	 * @return A function call for {@code graph.byName()}.
	 * @since 2023.4.0
	 */
	@NotNull
	@Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation graphByName(Expression name) {
		return FunctionInvocation.create(BuiltInFunctions.Graph.BY_NAME, name);
	}
	private Functions() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.SchemaNamesBridge;
/**
 * The factory methods are on the concrete class, as they should not be exposed to the outside via the interface.
 *
 * @author Michael J. Simons
 * @since 2023.0.0
 */
record UseClauseImpl(Expression target, boolean dynamic) implements Use {
	static Use of(String target) {
		var components = target.split("\\.");
		Expression targetExpression;
		if (components.length == 1) {
			targetExpression = Cypher.raw(SchemaNamesBridge.sanitize(components[0], false).orElseThrow());
		} else {
			targetExpression = Cypher.raw(SchemaNamesBridge.sanitize(components[0], false)
				.flatMap(composite -> SchemaNamesBridge.sanitize(components[1], false).map(v -> composite + "." + v))
				.orElseThrow());
		}
		return new UseClauseImpl(targetExpression, false);
	}
	static Use of(Expression target) {
		return new UseClauseImpl(target, !(target instanceof FunctionInvocation fi) || !"graph.byName".equals(fi.getFunctionName()));
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		target.accept(visitor);
		visitor.leave(this);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core.renderer;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.build.annotations.RegisterForReflection;
import org.neo4j.cypherdsl.core.AliasedExpression;
import org.neo4j.cypherdsl.core.Case;
import org.neo4j.cypherdsl.core.CollectExpression;
import org.neo4j.cypherdsl.core.Condition;
import org.neo4j.cypherdsl.core.CountExpression;
import org.neo4j.cypherdsl.core.Create;
import org.neo4j.cypherdsl.core.Delete;
import org.neo4j.cypherdsl.core.ExistentialSubquery;
import org.neo4j.cypherdsl.core.Foreach;
import org.neo4j.cypherdsl.core.FunctionInvocation;
import org.neo4j.cypherdsl.core.Hint;
import org.neo4j.cypherdsl.core.InTransactions;
import org.neo4j.cypherdsl.core.KeyValueMapEntry;
import org.neo4j.cypherdsl.core.LabelExpression;
import org.neo4j.cypherdsl.core.Limit;
import org.neo4j.cypherdsl.core.ListComprehension;
import org.neo4j.cypherdsl.core.ListExpression;
import org.neo4j.cypherdsl.core.Literal;
import org.neo4j.cypherdsl.core.MapExpression;
import org.neo4j.cypherdsl.core.Match;
import org.neo4j.cypherdsl.core.Merge;
import org.neo4j.cypherdsl.core.MergeAction;
import org.neo4j.cypherdsl.core.Named;
import org.neo4j.cypherdsl.core.NestedExpression;
import org.neo4j.cypherdsl.core.Node;
import org.neo4j.cypherdsl.core.NodeLabel;
import org.neo4j.cypherdsl.core.Operation;
import org.neo4j.cypherdsl.core.Operator;
import org.neo4j.cypherdsl.core.Order;
import org.neo4j.cypherdsl.core.Parameter;
import org.neo4j.cypherdsl.core.PatternExpression;
import org.neo4j.cypherdsl.core.QuantifiedPathPattern;
import org.neo4j.cypherdsl.core.PatternComprehension;
import org.neo4j.cypherdsl.core.ProcedureCall;
import org.neo4j.cypherdsl.core.Properties;
import org.neo4j.cypherdsl.core.PropertyLookup;
import org.neo4j.cypherdsl.core.Relationship;
import org.neo4j.cypherdsl.core.Remove;
import org.neo4j.cypherdsl.core.Return;
import org.neo4j.cypherdsl.core.Set;
import org.neo4j.cypherdsl.core.Skip;
import org.neo4j.cypherdsl.core.SortItem;
import org.neo4j.cypherdsl.core.Subquery;
import org.neo4j.cypherdsl.core.SubqueryExpression;
import org.neo4j.cypherdsl.core.SymbolicName;
import org.neo4j.cypherdsl.core.UnionPart;
import org.neo4j.cypherdsl.core.Unwind;
import org.neo4j.cypherdsl.core.Use;
import org.neo4j.cypherdsl.core.Where;
import org.neo4j.cypherdsl.core.With;
import org.neo4j.cypherdsl.core.internal.NameResolvingStrategy;
import org.neo4j.cypherdsl.core.internal.SchemaNamesBridge;
import org.neo4j.cypherdsl.core.ast.ProvidesAffixes;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.CaseElse;
import org.neo4j.cypherdsl.core.internal.CaseWhenThen;
import org.neo4j.cypherdsl.core.internal.ConstantParameterHolder;
import org.neo4j.cypherdsl.core.internal.Distinct;
import org.neo4j.cypherdsl.core.internal.LoadCSV;
import org.neo4j.cypherdsl.core.internal.Namespace;
import org.neo4j.cypherdsl.core.internal.ProcedureName;
import org.neo4j.cypherdsl.core.internal.ReflectiveVisitor;
import org.neo4j.cypherdsl.core.internal.RelationshipLength;
import org.neo4j.cypherdsl.core.internal.RelationshipPatternCondition;
import org.neo4j.cypherdsl.core.internal.RelationshipTypes;
import org.neo4j.cypherdsl.core.internal.ScopingStrategy;
import org.neo4j.cypherdsl.core.StatementContext;
import org.neo4j.cypherdsl.core.internal.UsingPeriodicCommit;
import org.neo4j.cypherdsl.core.internal.YieldItems;
/**
 * This is  a simple (some would  call it naive) implementation  of a visitor to  the Cypher AST created  by the Cypher
 * builder based on the {@link ReflectiveVisitor reflective visitor}.
 * <p>
 * It takes care of separating elements of subtrees containing  the element type with a separator and provides pairs of
 * {@code enter} / {@code leave} for the structuring elements of the Cypher AST as needed.
 * <p>
 * This rendering  visitor is not  meant to be  used outside framework code,  and we don't  give any guarantees  on the
 * format being output apart from that it works within the constraints of SDN-RX respectively SDN 6 and later.
 *
 * @author Michael J. Simons
 * @author Gerrit Meier
 * @since 1.0
 */
@SuppressWarnings({ "unused", "squid:S1172" })
@RegisterForReflection
class DefaultVisitor extends ReflectiveVisitor implements RenderingVisitor {
	private static final EnumSet<Operator> SKIP_SPACES = EnumSet.of(Operator.EXPONENTIATION, Operator.UNARY_MINUS,
		Operator.UNARY_PLUS);
	/**
	 * Target of all rendering.
	 */
	protected final StringBuilder builder = new StringBuilder();
	record SeparatorAndSupplier(AtomicReference<String> seperator, Supplier<String> supplier) {
	}
	/**
	 * This keeps track on which level of the tree a separator is needed.
	 */
	private final Map<Integer, SeparatorAndSupplier> separatorOnLevel = new ConcurrentHashMap<>();
	/**
	 * Keeps track of scoped, named variables.
	 */
	private final ScopingStrategy scopingStrategy;
	/**
	 * A set of aliased expressions that already have been seen and for which an alias must be used on each following
	 * appearance.
	 */
	protected final java.util.Set<AliasedExpression> visitableToAliased = new HashSet<>();
	/**
	 * Keeps track if currently in an aliased expression so that the content can be skipped when already visited.
	 */
	private final Deque<AliasedExpression> currentAliasedElements = new ArrayDeque<>();
	/**
	 * A cache of delegates, avoiding unnecessary object creation.
	 */
	private final Map<Class<? extends Visitor>, Visitor> delegateCache = new ConcurrentHashMap<>();
	private final NameResolvingStrategy nameResolvingStrategy;
	private final boolean enforceSchema;
	private final Map<String, List<Configuration.RelationshipDefinition>> relationshipDefinitions;
	/**
	 * The current level in the tree of cypher elements.
	 */
	private int currentLevel = 0;
	/**
	 * Will be set to true when entering an already visited node.
	 */
	private boolean skipNodeContent = false;
	/**
	 * Will be set to true when entering an already visited relationship.
	 */
	private boolean skipRelationshipContent = false;
	/**
	 * Will be true when inside a {@link RelationshipPatternCondition}.
	 */
	private boolean inRelationshipCondition = false;
	private final Deque<Boolean> inPatternExpression = new ArrayDeque<>();
	/**
	 * Rendering parameters is not a config property due to some needs in Spring Data Neo4j: This needs to be configured
	 * per statement, not per config  there.
	 */
	private final boolean renderConstantsAsParameters;
	private final boolean alwaysEscapeNames;
	private final Dialect dialect;
	private boolean inEntity;
	private boolean inPropertyLookup;
	private Relationship.Direction directionOverride;
	DefaultVisitor(StatementContext statementContext) {
		this(statementContext, false);
	}
	DefaultVisitor(StatementContext statementContext, boolean renderConstantsAsParameters) {
		this(statementContext, renderConstantsAsParameters, Configuration.newConfig().alwaysEscapeNames(true).build());
	}
	DefaultVisitor(StatementContext statementContext, boolean renderConstantsAsParameters,
		Configuration configuration) {
		this.nameResolvingStrategy = configuration.isUseGeneratedNames() ?
			NameResolvingStrategy.useGeneratedNames(statementContext, configuration.getGeneratedNames()) :
			NameResolvingStrategy.useGivenNames(statementContext);
		this.scopingStrategy = ScopingStrategy.create(
			List.of(nameResolvingStrategy::enterScope),
			List.of(nameResolvingStrategy::leaveScope)
		);
		this.renderConstantsAsParameters = renderConstantsAsParameters;
		this.alwaysEscapeNames = configuration.isAlwaysEscapeNames();
		this.dialect = configuration.getDialect();
		this.enforceSchema = configuration.isEnforceSchema();
		this.relationshipDefinitions = configuration.getRelationshipDefinitions();
	}
	private void enableSeparator(int level, boolean on, Supplier<String> supplier) {
		if (on) {
			separatorOnLevel.put(level,
				new SeparatorAndSupplier(new AtomicReference<>(""), supplier == null ? () -> "" : supplier));
		} else {
			separatorOnLevel.remove(level);
		}
	}
	private Optional<SeparatorAndSupplier> separatorOnCurrentLevel() {
		return Optional.ofNullable(separatorOnLevel.get(currentLevel));
	}
	@Override
	protected boolean preEnter(Visitable visitable) {
		Visitable lastAliased = currentAliasedElements.peek();
		if (skipNodeContent || visitableToAliased.contains(lastAliased)) {
			return false;
		}
		if (visitable instanceof AliasedExpression aliasedExpression) {
			currentAliasedElements.push(aliasedExpression);
		}
		int nextLevel = ++currentLevel + 1;
		if (visitable instanceof TypedSubtree<?> ts) {
			enableSeparator(nextLevel, true, ts::separator);
		}
		separatorOnCurrentLevel().ifPresent(ref -> builder.append(ref.seperator().getAndSet("")));
		if (visitable instanceof ProvidesAffixes providesAffixes) {
			providesAffixes.getPrefix().ifPresent(this::doWithPrefix);
		}
		boolean doEnter = !skipNodeContent;
		if (doEnter) {
			scopingStrategy.doEnter(visitable);
		}
		return doEnter;
	}
	@Override
	protected final PreEnterResult getPreEnterResult(Visitable visitable) {
		boolean doEnter = preEnter(visitable);
		if (!doEnter) {
			return PreEnterResult.skip();
		}
		Class<? extends Visitor> handlerType = dialect.getHandler(visitable);
		if (handlerType != null) {
			Visitor handler = this.delegateCache.computeIfAbsent(handlerType, this::newHandler);
			return PreEnterResult.delegateTo(handler);
		}
		return PreEnterResult.doEnter();
	}
	private Visitor newHandler(Class<? extends Visitor> handlerType) {
		try {
			Constructor<? extends Visitor> ctor = handlerType.getDeclaredConstructor(DefaultVisitor.class);
			return ctor.newInstance(this);
		} catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
			throw new IllegalArgumentException(
				dialect.name() + " has defined an illegal handler not providing a constructor accepting a delegate.");
		}
	}
	@Override
	protected void postLeave(Visitable visitable) {
		scopingStrategy.doLeave(visitable);
		separatorOnCurrentLevel().ifPresent(ref -> ref.seperator().set(ref.supplier().get()));
		if (visitable instanceof ProvidesAffixes providesAffixes) {
			providesAffixes.getSuffix().ifPresent(this::doWithSuffix);
		}
		if (visitable instanceof TypedSubtree) {
			enableSeparator(currentLevel + 1, false, null);
		}
		if (currentAliasedElements.peek() == visitable) {
			currentAliasedElements.pop();
		}
		if (visitable instanceof AliasedExpression aliasedExpression) {
			visitableToAliased.add(aliasedExpression);
		}
		--currentLevel;
	}
	protected void doWithPrefix(String prefix) {
		this.builder.append(prefix);
	}
	protected void doWithSuffix(String suffix) {
		this.builder.append(suffix);
	}
	void enter(Match match) {
		if (match.isOptional()) {
			builder.append("OPTIONAL ");
		}
		builder.append("MATCH ");
	}
	void leave(Match match) {
		builder.append(" ");
	}
	void enter(Where where) {
		builder.append(" WHERE ");
	}
	void enter(Create create) {
		builder.append("CREATE ");
	}
	void leave(Create create) {
		builder.append(" ");
	}
	void enter(Merge merge) {
		builder.append("MERGE ");
	}
	void leave(Merge merge) {
		if (!merge.hasEvents()) { // The last SET will include this
			builder.append(" ");
		}
	}
	void enter(MergeAction onCreateOrMatchEvent) {
		switch (onCreateOrMatchEvent.getType()) {
			case ON_CREATE -> builder.append("ON CREATE");
			case ON_MATCH -> builder.append("ON MATCH");
		}
		builder.append(" ");
	}
	void enter(Condition condition) {
		inRelationshipCondition = condition instanceof RelationshipPatternCondition;
	}
	void leave(Condition condition) {
		inRelationshipCondition = false;
	}
	void enter(Distinct distinct) {
		builder.append("DISTINCT ");
	}
	boolean inReturn;
	void enter(Return returning) {
		inReturn = true;
		if (!returning.isRaw()) {
			builder.append("RETURN ");
		}
	}
	void leave(Return returning) {
		inReturn = false;
	}
	void enter(With with) {
		builder.append("WITH ");
	}
	void leave(With with) {
		builder.append(" ");
	}
	void enter(Delete delete) {
		if (delete.isDetach()) {
			builder.append("DETACH ");
		}
		builder.append("DELETE ");
	}
	void leave(Delete match) {
		builder.append(" ");
	}
	boolean inLastReturn() {
		return inReturn && !inSubquery;
	}
	void enter(AliasedExpression aliased) {
		if (this.visitableToAliased.contains(aliased)) {
			builder.append(escapeIfNecessary(nameResolvingStrategy.resolve(aliased, false, inLastReturn())));
		}
	}
	void leave(AliasedExpression aliased) {
		if (!(this.visitableToAliased.contains(aliased) || scopingStrategy.isSkipAliasing())) {
			builder.append(" AS ").append(escapeIfNecessary(nameResolvingStrategy.resolve(aliased, true, inLastReturn())));
		}
	}
	void enter(NestedExpression nested) {
		builder.append("(");
	}
	void leave(NestedExpression nested) {
		builder.append(")");
	}
	void enter(Order order) {
		builder.append(" ORDER BY ");
	}
	void enter(Skip skip) {
		builder.append(" SKIP ");
	}
	void enter(Limit limit) {
		builder.append(" LIMIT ");
	}
	void enter(SortItem.Direction direction) {
		builder
			.append(" ")
			.append(direction.getSymbol());
	}
	void enter(PropertyLookup propertyLookup) {
		inPropertyLookup = true;
		if (propertyLookup.isDynamicLookup()) {
			builder.append("[");
		} else {
			builder.append(".");
		}
	}
	void leave(PropertyLookup propertyLookup) {
		inPropertyLookup = false;
		if (propertyLookup.isDynamicLookup()) {
			builder.append("]");
		}
	}
	void enter(FunctionInvocation functionInvocation) {
		String functionName = functionInvocation.getFunctionName();
		if ("elementId".equals(functionName)) {
			functionName = "toString(id";
		}
		builder
			.append(functionName)
			.append("(");
	}
	void leave(FunctionInvocation functionInvocation) {
		String functionName = functionInvocation.getFunctionName();
		if ("elementId".equals(functionName)) {
			builder.append(")");
		}
		builder.append(")");
	}
	void enter(Operation operation) {
		if (operation.needsGrouping()) {
			builder.append("(");
		}
	}
	void enter(Operator operator) {
		Operator.Type type = operator.getType();
		if (type == Operator.Type.LABEL) {
			return;
		}
		boolean skipSpaces = SKIP_SPACES.contains(operator);
		if (type != Operator.Type.PREFIX && !skipSpaces) {
			builder.append(" ");
		}
		builder.append(operator.getRepresentation());
		if (type != Operator.Type.POSTFIX && !skipSpaces) {
			builder.append(" ");
		}
	}
	void leave(Operation operation) {
		if (operation.needsGrouping()) {
			builder.append(")");
		}
	}
	void enter(Literal<?> expression) {
		builder.append(expression.asString());
	}
	void enter(Node node) {
		builder.append("(");
		// This is only relevant for nodes in relationships.
		// Otherwise, all the labels would be rendered again.
		skipNodeContent = scopingStrategy.hasVisitedBefore(node);
		if (skipNodeContent) {
			builder.append(nameResolvingStrategy.resolve(
				node.getSymbolicName().orElseGet(node::getRequiredSymbolicName), true, false));
		}
		inEntity = true;
	}
	void leave(Node node) {
		builder.append(")");
		skipNodeContent = false;
		inEntity = false;
	}
	void enter(NodeLabel nodeLabel) {
		escapeName(nodeLabel.getValue()).ifPresent(label -> builder.append(Symbols.NODE_LABEL_START).append(label));
	}
	void enter(LabelExpression labelExpression) {
		builder.append(":");
		renderLabelExpression(labelExpression, null);
	}
	@SuppressWarnings("squid:S3776")
	void renderLabelExpression(LabelExpression l, LabelExpression.Type parent) {
		if (l == null) {
			return;
		}
		if (l.negated()) {
			builder.append("!");
		}
		var current = l.type();
		boolean close = false;
		if (current != LabelExpression.Type.LEAF) {
			close = (parent != null || l.negated()) && l.type() != parent;
			if (close && !l.negated() && (current == LabelExpression.Type.CONJUNCTION || parent == LabelExpression.Type.DISJUNCTION)) {
				close = false;
			}
		}
		if (close) {
			builder.append("(");
		}
		renderLabelExpression(l.lhs(), current);
		if (current == LabelExpression.Type.LEAF) {
			l.value().forEach(v ->
				escapeName(v).ifPresent(builder::append)
			);
		}  else {
			builder.append(current.getValue());
		}
		renderLabelExpression(l.rhs(), current);
		if (close) {
			builder.append(")");
		}
	}
	void enter(Properties properties) {
		builder.append(" ");
	}
	void enter(SymbolicName symbolicName) {
		if (!inRelationshipCondition || nameResolvingStrategy.isResolved(symbolicName)) {
			if (Boolean.TRUE.equals(inPatternExpression.peek()) && !scopingStrategy.hasVisitedBefore(new Named() {
				@Override
				public @NotNull Optional<SymbolicName> getSymbolicName() {
					return Optional.of(symbolicName);
				}
			})) {
				return;
			}
			builder.append(nameResolvingStrategy.resolve(symbolicName, inEntity, inPropertyLookup));
		}
	}
	void enter(PatternExpression p) {
		this.inPatternExpression.push(true);
	}
	void leave(PatternExpression p) {
		this.inPatternExpression.pop();
	}
	void enter(Relationship relationship) {
		skipRelationshipContent = scopingStrategy.hasVisitedBefore(relationship);
		if (enforceSchema && relationship.getDetails().getDirection() != Relationship.Direction.UNI) {
			directionOverride = computeDirectionOverride(relationship);
		}
	}
	/**
	 * Helper to retrieve a nodes label
	 *
	 * @param node the node
	 * @return A set of labels
	 */
	private java.util.Set<String> getLabels(Node node) {
		var nl = node.getLabels();
		if (nl.isEmpty()) {
			var patternElement = scopingStrategy.lookup(node);
			if (patternElement instanceof Node boundNode) {
				nl = boundNode.getLabels();
			}
		}
		return nl.stream().map(NodeLabel::getValue).collect(Collectors.toSet());
	}
	/**
	 * Computes an overwrite for enforcing a schema
	 * @param relationship the relationship to potentially override
	 * @return A new direction
	 */
	Relationship.Direction computeDirectionOverride(Relationship relationship) {
		var sourceLabels = getLabels(relationship.getLeft());
		var targetLabels = getLabels(relationship.getRight());
		var details = relationship.getDetails();
		// Bail out on equal labels
		if (sourceLabels.equals(targetLabels)) {
			return details.getDirection();
		}
		for (String type : details.getTypes()) {
			outer:
			if (relationshipDefinitions.containsKey(type)) {
				var knownRelationships = relationshipDefinitions.get(type).stream().toList();
				for (var knownRelationship : knownRelationships) {
					if (knownRelationship.selfReferential() && (sourceLabels.isEmpty() || targetLabels.isEmpty())) {
						break outer;
					}
					if (
						sourceLabels.contains(knownRelationship.targetLabel()) && (targetLabels.isEmpty() || targetLabels.contains(knownRelationship.sourceLabel())) ||
						targetLabels.contains(knownRelationship.sourceLabel()) && (sourceLabels.isEmpty() || sourceLabels.contains(knownRelationship.sourceLabel()))
					) {
						return Relationship.Direction.RTL;
					} else if (
						sourceLabels.contains(knownRelationship.sourceLabel()) && (targetLabels.isEmpty() || targetLabels.contains(knownRelationship.targetLabel())) ||
						targetLabels.contains(knownRelationship.targetLabel()) && (sourceLabels.isEmpty() || sourceLabels.contains(knownRelationship.sourceLabel()))
					) {
						return Relationship.Direction.LTR;
					}
				}
			}
			if (!sourceLabels.isEmpty() && !targetLabels.isEmpty()) {
				throw new SchemaEnforcementFailedException();
			}
		}
		if (details.getTypes().isEmpty()) {
			var knownRelationships = this.relationshipDefinitions.values().stream().flatMap(List::stream).toList();
			for (var knownRelationship : knownRelationships) {
				if (sourceLabels.contains(knownRelationship.targetLabel()) && targetLabels.contains(knownRelationship.sourceLabel())) {
					return Relationship.Direction.RTL;
				} else if (sourceLabels.contains(knownRelationship.sourceLabel()) && targetLabels.contains(knownRelationship.targetLabel())) {
					return Relationship.Direction.LTR;
				}
			}
		}
		return details.getDirection();
	}
	void enter(Relationship.Details details) {
		Relationship.Direction direction = Optional.ofNullable(directionOverride).orElseGet(details::getDirection);
		builder.append(direction.getSymbolLeft());
		if (details.hasContent()) {
			builder.append("[");
		}
		inEntity = true;
	}
	void enter(RelationshipTypes types) {
		if (skipRelationshipContent) {
			return;
		}
		builder
			.append(types.getValues().stream()
				.map(this::escapeName)
				.map(Optional::orElseThrow)
				.collect(Collectors.joining(Symbols.REL_TYP_SEPARATOR, Symbols.REL_TYPE_START, "")));
	}
	void enter(RelationshipLength length) {
		if (skipRelationshipContent) {
			return;
		}
		Integer minimum = length.getMinimum();
		Integer maximum = length.getMaximum();
		if (length.isUnbounded()) {
			builder.append("*");
			return;
		}
		if (minimum == null && maximum == null) {
			return;
		}
		builder.append("*");
		if (minimum != null) {
			builder.append(minimum);
		}
		builder.append("..");
		if (maximum != null) {
			builder.append(maximum);
		}
	}
	void leave(Relationship.Details details) {
		Relationship.Direction direction = Optional.ofNullable(directionOverride).orElseGet(details::getDirection);
		if (details.hasContent()) {
			builder.append("]");
		}
		builder.append(direction.getSymbolRight());
		inEntity = false;
	}
	void leave(Relationship relationship) {
		skipRelationshipContent = false;
		directionOverride = null;
	}
	void enter(Parameter<?> parameter) {
		Object value = parameter.getValue();
		if (value instanceof ConstantParameterHolder constantParameterHolder && !renderConstantsAsParameters) {
			builder.append(constantParameterHolder.asString());
		} else {
			builder.append("$").append(nameResolvingStrategy.resolve(parameter));
		}
	}
	void enter(MapExpression map) {
		builder.append("{");
	}
	void enter(KeyValueMapEntry map) {
		builder.append(escapeIfNecessary(map.getKey())).append(": ");
	}
	void leave(MapExpression map) {
		builder.append("}");
	}
	void enter(ListExpression list) {
		builder.append("[");
	}
	void leave(ListExpression list) {
		builder.append("]");
	}
	void enter(Unwind unwind) {
		builder.append("UNWIND ");
	}
	void leave(Unwind unwind) {
		builder
			.append(" ");
	}
	void enter(UnionPart unionPart) {
		builder.append(" UNION ");
		if (unionPart.isAll()) {
			builder.append("ALL ");
		}
	}
	void enter(Set set) {
		builder.append("SET ");
	}
	void leave(Set set) {
		builder.append(" ");
	}
	void enter(Remove remove) {
		builder.append("REMOVE ");
	}
	void leave(Remove remove) {
		builder.append(" ");
	}
	void enter(PatternComprehension patternComprehension) {
		builder.append("[");
	}
	void leave(PatternComprehension patternComprehension) {
		builder.append("]");
	}
	void enter(ListComprehension listComprehension) {
		builder.append("[");
	}
	void leave(ListComprehension listComprehension) {
		builder.append("]");
	}
	void enter(Case genericCase) {
		builder.append("CASE");
	}
	void enter(Case.SimpleCase simpleCase) {
		builder.append("CASE ");
	}
	void enter(CaseWhenThen caseWhenExpression) {
		builder.append(" WHEN ");
	}
	void leave(CaseWhenThen caseWhenExpression) {
		builder.append(" THEN ");
	}
	void enter(CaseElse caseElseExpression) {
		builder.append(" ELSE ");
	}
	void leave(Case caseExpression) {
		builder.append(" END");
	}
	void enter(ProcedureCall procedureCall) {
		builder.append("CALL ");
	}
	void leave(Namespace namespace) {
		builder.append(".");
	}
	void leave(ProcedureName procedureName) {
		builder.append(procedureName.getValue());
	}
	void enter(YieldItems yieldItems) {
		builder.append(" YIELD ");
	}
	void leave(ProcedureCall procedureCall) {
		builder.append(" ");
	}
	void enter(Enum<?> anEnum) {
		builder.append(anEnum.name().replace("_", " ")).append(" ");
	}
	boolean inSubquery;
	void enter(Subquery subquery) {
		this.inSubquery = true;
		builder.append("CALL {");
	}
	void leave(Subquery subquery) {
		this.inSubquery = false;
		int l = builder.length() - 1;
		if (builder.charAt(l) == ' ' && !subquery.doesReturnOrYield()) {
			builder.replace(l, builder.length(), "} ");
		} else {
			builder.append("} ");
		}
	}
	void leave(InTransactions inTransactions) {
		int l = builder.length() - 1;
		if (builder.charAt(l) != ' ') {
			builder.append(" ");
		}
		builder.append("IN TRANSACTIONS ");
		if (inTransactions.getRows() != null) {
			builder.append("OF ").append(inTransactions.getRows()).append(" ROWS ");
		}
	}
	void enter(Foreach foreach) {
		builder.append("FOREACH (");
	}
	void leave(Foreach foreach) {
		builder.setCharAt(builder.length() - 1, ')'); // replace trailing space with ')'
		builder.append(" ");
	}
	void enter(SubqueryExpression subquery) {
		if (subquery instanceof CountExpression) {
			builder.append("COUNT");
		} else if (subquery instanceof ExistentialSubquery) {
			builder.append("EXISTS");
		} else if (subquery instanceof CollectExpression) {
			builder.append("COLLECT");
		}
		builder.append(" { ");
	}
	void leave(SubqueryExpression subquery) {
		// Trimming the inner match without having to do this in the match (looking up if inside subquery).
		if (builder.charAt(builder.length() - 1) == ' ') {
			builder.replace(builder.length() - 1, builder.length(), " }");
		} else {
			builder.append(" }");
		}
	}
	void enter(Hint hint) {
		builder.append(" USING ");
	}
	void enter(LoadCSV loadCSV) {
		builder.append("LOAD CSV");
		if (loadCSV.isWithHeaders()) {
			builder.append(" WITH HEADERS");
		}
		builder.append(" FROM '")
			.append(loadCSV.getUri().toString())
			.append("' AS ")
			.append(loadCSV.getAlias());
		if (loadCSV.getFieldTerminator() != null) {
			builder.append(" FIELDTERMINATOR '")
				.append(loadCSV.getFieldTerminator())
				.append("'");
		}
		builder.append(" ");
	}
	void enter(UsingPeriodicCommit usingPeriodicCommit) {
		builder.append("USING PERIODIC COMMIT ");
		if (usingPeriodicCommit.rate() != null) {
			builder.append(usingPeriodicCommit.rate()).append(" ");
		}
	}
	void enter(Use use) {
		builder.append("USE ");
		if (use.dynamic()) {
			builder.append("graph.byName(");
		}
	}
	void leave(Use use) {
		if (use.dynamic()) {
			builder.append(")");
		}
		builder.append(" ");
	}
	void enter(QuantifiedPathPattern.TargetPattern qpp) {
		builder.append("(");
	}
	void leave(QuantifiedPathPattern.TargetPattern qpp) {
		builder.append(")");
	}
	void enter(QuantifiedPathPattern.Quantifier quantifier) {
		builder.append(quantifier.toString());
	}
	@Override
	public String getRenderedContent() {
		return this.builder.toString();
	}
	/**
	 * Escapes a symbolic name. Such a symbolic name is either used for a nodes label, the type of a relationship or a
	 * variable.
	 *
	 * @param unescapedName The name to escape.
	 * @return An empty optional when the unescaped name is {@literal null}, otherwise the correctly escaped name, safe to be used in statements.
	 */
	protected final Optional<String> escapeName(String unescapedName) {
		return SchemaNamesBridge.sanitize(unescapedName, alwaysEscapeNames);
	}
	protected final String escapeIfNecessary(String potentiallyNonIdentifier) {
		return SchemaNamesBridge.sanitize(potentiallyNonIdentifier, false).orElse(null);
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import java.util.List;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.utils.Assertions;
/**
 * Factory methods for creating predicates.
 *
 * @author Michael J. Simons
 * @soundtrack Mine &amp; Fatoni - Alle Liebe nachträglich
 * @since 1.0
 * be accessible.
 */
final class Predicates {
	/**
	 * Creates a new condition based on a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param property The property to be passed to {@code exists()}
	 * @return A function call for {@code exists()} for one property
	 */
	@NotNull @Contract(pure = true)
	static Condition exists(Property property) {
		return new BooleanFunctionCondition(FunctionInvocation.create(BuiltInFunctions.Predicates.EXISTS, property));
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code exists()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-exists">exists</a>.
	 *
	 * @param pattern The pattern to be passed to {@code exists()}
	 * @return A function call for {@code exists()} for one pattern
	 */
	@NotNull @Contract(pure = true)
	static Condition exists(RelationshipPattern pattern) {
		return new BooleanFunctionCondition(FunctionInvocation.create(BuiltInFunctions.Predicates.EXISTS, pattern));
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a>. The statement may or  may not have  a {@literal  RETURN} clause. It  must however not  contain any
	 * updates. While it  would render syntactically correct  Cypher, Neo4j does not support  updates inside existential
	 * sub-queries.
	 *
	 * @param statement The statement to be passed to {@code exists{}}
	 * @param imports   Optional imports to be used in the statement (will be imported with {@literal WITH})
	 * @return An existential sub-query.
	 * @since 2023.1.0
	 */
	static Condition exists(Statement statement, IdentifiableElement... imports) {
		return ExistentialSubquery.exists(statement, imports);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns
	 *
	 * @param pattern the pattern that must exists
	 *
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	static Condition exists(PatternElement pattern) {
		return ExistentialSubquery.exists(List.of(pattern), null);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns
	 *
	 * @param pattern the list of patterns that must exists
	 *
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	static Condition exists(List<PatternElement> pattern) {
		return ExistentialSubquery.exists(pattern, null);
	}
	/**
	 * Creates                  a                 new                  condition                 via                  an
	 * <a     href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries">existential
	 * sub-query</a> based on the list of patterns and an optional {@link Where where-clause}.
	 *
	 * @param pattern the list of patterns that must exists
	 * @param where an optional where-clause
	 *
	 * @return An existential sub-query.
	 * @since 2023.9.0
	 */
	static Condition exists(List<PatternElement> pattern, @Nullable Where where) {
		return ExistentialSubquery.exists(pattern, where);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code all()} predicate function
	 * @see #all(SymbolicName)
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	static OngoingListBasedPredicateFunction all(String variable) {
		return all(SymbolicName.of(variable));
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code all()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code all()} predicate function
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	static OngoingListBasedPredicateFunction all(SymbolicName variable) {
		return new Builder(BuiltInFunctions.Predicates.ALL, variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code any()} predicate function
	 * @see #any(SymbolicName)
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	static OngoingListBasedPredicateFunction any(String variable) {
		return any(SymbolicName.of(variable));
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code any()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-any">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code any()} predicate function
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	static OngoingListBasedPredicateFunction any(SymbolicName variable) {
		return new Builder(BuiltInFunctions.Predicates.ANY, variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code none()} predicate function
	 * @see #none(SymbolicName)
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	static OngoingListBasedPredicateFunction none(String variable) {
		return none(SymbolicName.of(variable));
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code none()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-none">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code none()} predicate function
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	static OngoingListBasedPredicateFunction none(SymbolicName variable) {
		return new Builder(BuiltInFunctions.Predicates.NONE, variable);
	}
	/**
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code single()} predicate function
	 * @see #single(SymbolicName)
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	static OngoingListBasedPredicateFunction single(String variable) {
		return single(SymbolicName.of(variable));
	}
	/**
	 * Starts building a new condition based on a function invocation for the {@code single()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-single">exists</a>.
	 *
	 * @param variable The variable referring to elements of a list
	 * @return A builder for the {@code single()} predicate function
	 * @since 1.1
	 */
	@NotNull @Contract(pure = true)
	static OngoingListBasedPredicateFunction single(SymbolicName variable) {
		return new Builder(BuiltInFunctions.Predicates.SINGLE, variable);
	}
	/**
	 * Creates a new condition based on a function invocation for the {@code isEmpty()} function.
	 * See <a href="https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-isempty">isEmpty</a>.
	 * <p>
	 * The argument {@code e} must refer to an expression that evaluates to a list for {@code isEmpty()} to work
	 *
	 * @param e An expression referring to a list
	 * @return A function call for {@code isEmpty()} for a list
	 * @since 2023.6.1
	 */
	static Condition isEmpty(Expression e) {
		return new BooleanFunctionCondition(FunctionInvocation.create(BuiltInFunctions.Predicates.IS_EMPTY, e));
	}
	private static class Builder implements OngoingListBasedPredicateFunction,
		OngoingListBasedPredicateFunctionWithList {
		private final BuiltInFunctions.Predicates predicate;
		private final SymbolicName name;
		private Expression listExpression;
		Builder(BuiltInFunctions.Predicates predicate, SymbolicName name) {
			Assertions.notNull(predicate, "The predicate is required");
			Assertions.notNull(name, "The name is required");
			this.predicate = predicate;
			this.name = name;
		}
		@Override @NotNull
		public OngoingListBasedPredicateFunctionWithList in(Expression list) {
			Assertions.notNull(list, "The list expression is required");
			this.listExpression = list;
			return this;
		}
		@Override @NotNull
		public Condition where(Condition condition) {
			Assertions.notNull(condition, "The condition is required");
			return new BooleanFunctionCondition(
				FunctionInvocation.create(predicate, new ListPredicate(name, listExpression, new Where(condition))));
		}
	}
	private Predicates() {
	}
}
/*
 * Copyright (c) 2019-2025 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypherdsl.core;
import org.neo4j.cypherdsl.core.internal.Distinct;
import org.neo4j.cypherdsl.core.ast.Visitor;
/**
 * AST representation of the {@literal DISTINCT} keyword.
 *
 * @author Michael J. Simons
 * @since 1.0
 */
final class DistinctExpression implements Expression {
	private final Expression delegate;
	DistinctExpression(Expression delegate) {
		this.delegate = delegate;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		Distinct.INSTANCE.accept(visitor);
		this.delegate.accept(visitor);
		visitor.leave(this);
	}
}