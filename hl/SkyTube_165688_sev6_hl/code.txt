/*
 * SkyTube
 * Copyright (C) 2021  Zsombor Gegesy
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.businessobjects.db;
import android.content.Context;
import android.text.TextUtils;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.util.Pair;
import java.util.Collections;
import java.util.List;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.YouTube.POJOs.ChannelView;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.VideoBlocker;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeException;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.model.Status;
import free.rm.skytube.gui.businessobjects.views.ChannelSubscriber;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.disposables.Disposable;
import io.reactivex.rxjava3.schedulers.Schedulers;
/**
 * Contains database-related tasks to be carried out asynchronously.
 */
public class DatabaseTasks {
    private static final String TAG = DatabaseTasks.class.getSimpleName();
    private DatabaseTasks() {}
    /**
     * Task to retrieve channel information - from the local cache, or from the remote service if the
     * value is old or doesn't exist.
     */
    public static Maybe<PersistentChannel> getChannelInfo(@NonNull Context context,
                                                          @NonNull ChannelId channelId,
                                                          boolean staleAcceptable) {
        return Maybe.fromCallable(() -> getChannelOrRefresh(context, channelId, staleAcceptable))
                .observeOn(AndroidSchedulers.mainThread())
                .doOnError(throwable -> {
                    Log.e(TAG, "Error: " + throwable.getMessage(), throwable);
                    final String msg = (throwable.getCause() != null ? throwable.getCause() : throwable).getMessage();
                    final String toastMsg = msg != null ?
                            context.getString(R.string.could_not_get_channel_detailed, msg) :
                            context.getString(R.string.could_not_get_channel);
                    Toast.makeText(context, toastMsg, Toast.LENGTH_LONG).show();
                })
                .subscribeOn(Schedulers.io());
    }
    /**
     * Returns the cached information about the channel, or tries to retrieve it from the network.
     */
    public static PersistentChannel getChannelOrRefresh(Context context, ChannelId channelId, boolean staleAcceptable) throws NewPipeException {
        SkyTubeApp.nonUiThread();
        final SubscriptionsDb db = SubscriptionsDb.getSubscriptionsDb();
        PersistentChannel persistentChannel = db.getCachedChannel(channelId);
        final boolean needsRefresh;
        if (persistentChannel == null || TextUtils.isEmpty(persistentChannel.channel().getTitle())) {
            needsRefresh = true;
        } else if (staleAcceptable) {
            needsRefresh = false;
        } else {
            needsRefresh = persistentChannel.channel().getLastCheckTime() < System.currentTimeMillis() - (24 * 60 * 60 * 1000L);
        }
        if (needsRefresh && SkyTubeApp.isConnected(context)) {
            try {
                return NewPipeService.get().getChannelDetails(channelId, persistentChannel);
            } catch (NewPipeException newPipeException) {
                if (persistentChannel != null && persistentChannel.status() != Status.OK) {
                    Log.e(TAG, "Channel is blocked/terminated - and kept that way: "+ persistentChannel+", message:"+newPipeException.getMessage());
                    return persistentChannel;
                }
                throw newPipeException;
            }
        }
        return persistentChannel;
    }
    public static Single<List<ChannelView>> getSubscribedChannelView(Context context, @Nullable View progressBar,
                                                                     @Nullable String searchText) {
        final boolean sortChannelsAlphabetically = SkyTubeApp.getPreferenceManager()
                .getBoolean(SkyTubeApp.getStr(R.string.pref_key_subscriptions_alphabetical_order), false);
        if (progressBar != null) {
            progressBar.setVisibility(View.VISIBLE);
        }
        // filter out for any whitelisted/blacklisted channels
        return Single.fromCallable(() -> new VideoBlocker().filterChannels(SubscriptionsDb.getSubscriptionsDb()
                .getSubscribedChannelsByText(searchText, sortChannelsAlphabetically)))
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSuccess(list -> {
                    if (progressBar != null) {
                        progressBar.setVisibility(View.INVISIBLE);
                    }
                }).onErrorReturn(error -> {
                    Log.e(TAG, "Error: " + error.getMessage(), error);
                    String msg = context.getString(R.string.could_not_get_channel_detailed, error.getMessage());
                    Toast.makeText(context, msg, Toast.LENGTH_LONG).show();
                    return Collections.emptyList();
                });
    }
    /**
     * A task that checks if this video is bookmarked or not. If it is bookmarked, then it will hide
     * the menu option to bookmark the video; otherwise it will hide the option to unbookmark the
     * video.
     */
    public static Disposable isVideoBookmarked(@NonNull String videoId, @NonNull Menu menu) {
        return BookmarksDb.getBookmarksDb().isVideoBookmarked(videoId)
                .subscribe(videoIsBookmarked -> {
                    // if this video has been bookmarked, hide the bookmark option and show the unbookmark option.
                    menu.findItem(R.id.bookmark_video).setVisible(!videoIsBookmarked);
                    menu.findItem(R.id.unbookmark_video).setVisible(videoIsBookmarked);
                });
    }
    public static void updateDownloadedVideoMenu(@NonNull YouTubeVideo video, @NonNull Menu menu) {
        final MenuItem downloadVideo = menu.findItem(R.id.download_video);
        downloadVideo.setVisible(false);
        if (video != null) {
            DownloadedVideosDb.getVideoDownloadsDb().isVideoDownloaded(video.getVideoId()).subscribe(isDownloaded -> {
                SkyTubeApp.uiThread();
                if (!isDownloaded) {
                    downloadVideo.setVisible(true);
                }
            });
        }
    }
    /**
     * A task that checks if the passed {@link YouTubeVideo} is marked as watched, to update the passed {@link Menu} accordingly.
     */
    public static Disposable isVideoWatched(@NonNull String videoId, @NonNull Menu menu) {
        return PlaybackStatusDb.getPlaybackStatusDb().getVideoWatchedStatusAsync(videoId)
                .subscribe(videoStatus -> {
                    boolean videoIsWatched = videoStatus != null && videoStatus.isFullyWatched();
                    // if this video has been watched, hide the set watched option and show the set unwatched option.
                    menu.findItem(R.id.mark_watched).setVisible(!videoIsWatched);
                    menu.findItem(R.id.mark_unwatched).setVisible(videoIsWatched);
                });
    }
    /**
     * A task that subscribes to / unsubscribes from a YouTube channel.
     *
     * @param subscribeToChannel  Whether the channel should be subscribed to.
     * @param subscribeButton	  The subscribe button that the user has just clicked.
     * @param context             The context to be used to show the toast, if necessary.
     * @param channelId			  The channel id the user wants to subscribe / unsubscribe.
     * @param displayToastMessage Whether or not a toast should be shown.
     */
    public static Single<Pair<PersistentChannel, DatabaseResult>> subscribeToChannel(boolean subscribeToChannel,
                                                            @Nullable ChannelSubscriber subscribeButton,
                                                            @NonNull Context context,
                                                            @NonNull ChannelId channelId,
                                                            boolean displayToastMessage) {
        return Single.fromCallable(() -> {
            PersistentChannel channel = DatabaseTasks.getChannelOrRefresh(context, channelId, true);
            SubscriptionsDb db = SubscriptionsDb.getSubscriptionsDb();
            final DatabaseResult result;
            if (subscribeToChannel) {
                result = db.subscribe(channel, channel.channel().getYouTubeVideos());
            } else {
                result = db.unsubscribe(channel);
            }
            return Pair.create(channel, result);
        })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSuccess(databaseResultPair -> {
                    YouTubeChannel channel = databaseResultPair.first.channel();
                    if (databaseResultPair.second == DatabaseResult.SUCCESS) {
                        // we need to refresh the Feed tab so it shows videos from the newly subscribed (or
                        // unsubscribed) channels
                        SkyTubeApp.getSettings().setRefreshSubsFeedFromCache(true);
                        if (subscribeToChannel) {
                            // change the state of the button
                            if (subscribeButton != null)
                                subscribeButton.setSubscribedState(true);
                            // Also change the subscription state of the channel
                            channel.setUserSubscribed(true);
                            // notify about the subscription list change
                            EventBus.getInstance().notifyMainTabChanged(EventBus.SettingChange.SUBSCRIPTION_LIST_CHANGED);
                            if (displayToastMessage) {
                                Toast.makeText(context, R.string.subscribed, Toast.LENGTH_LONG).show();
                            }
                        } else {
                            // change the state of the button
                            if (subscribeButton != null)
                                subscribeButton.setSubscribedState(false);
                            // Also change the subscription state of the channel
                            channel.setUserSubscribed(false);
                            // remove the channel from the channels subscriptions list/drawer
                            EventBus.getInstance().notifyChannelRemoved(channel.getChannelId());
                            if (displayToastMessage) {
                                Toast.makeText(context, R.string.unsubscribed, Toast.LENGTH_LONG).show();
                            }
                        }
                    } else if (databaseResultPair.second == DatabaseResult.NOT_MODIFIED) {
                        if (subscribeToChannel) {
                            Toast.makeText(context, R.string.channel_already_subscribed, Toast.LENGTH_LONG).show();
                        }
                    } else {
                        String err = String.format(SkyTubeApp.getStr(R.string.error_unable_to_subscribe), channel.getId());
                        Toast.makeText(context, err, Toast.LENGTH_LONG).show();
                    }
                });
    }
    /**
     * A task that unsubscribes the user from all the channels at once.
     */
    public static Completable completableUnsubscribeFromAllChannels() {
        return Completable.fromAction(() ->
                SubscriptionsDb.getSubscriptionsDb().unsubscribeFromAllChannels())
                .subscribeOn(Schedulers.io());
    }
}
/*
 * SkyTube
 * Copyright (C) 2016  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.businessobjects.db;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import androidx.annotation.NonNull;
import androidx.core.util.Pair;
import com.github.skytube.components.utils.SQLiteHelper;
import com.google.gson.Gson;
import org.json.JSONException;
import org.json.JSONObject;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.app.Utils;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.CardData;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.newpipe.VideoId;
import free.rm.skytube.businessobjects.interfaces.OrderableDatabase;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.schedulers.Schedulers;
/**
 * A database (DB) that stores user's bookmarked videos.
 */
public class BookmarksDb extends CardEventEmitterDatabase implements OrderableDatabase {
	private static volatile BookmarksDb bookmarksDb = null;
	private static final int DATABASE_VERSION = 1;
	private static final String DATABASE_NAME = "bookmarks.db";
	private BookmarksDb(Context context) {
		super(context, DATABASE_NAME, null, DATABASE_VERSION);
	}
	public static synchronized BookmarksDb getBookmarksDb() {
		if (bookmarksDb == null) {
			bookmarksDb = new BookmarksDb(SkyTubeApp.getContext());
		}
		return bookmarksDb;
	}
	@Override
	public void onCreate(SQLiteDatabase db) {
		db.execSQL(BookmarksTable.getCreateStatement());
	}
	@Override
	public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
	}
	/**
	 * A task that checks if this video is bookmarked or not. If it is bookmarked, then it will hide
	 * the menu option to bookmark the video; otherwise it will hide the option to unbookmark the
	 * video.
	 */
	public Single<Boolean> isVideoBookmarked(@NonNull String videoId) {
		return Single.fromCallable(() -> isBookmarked(videoId))
				.subscribeOn(Schedulers.io())
				.observeOn(AndroidSchedulers.mainThread());
	}
        /**
         * Add the specified video to the list of bookmarked videos. The video will appear at the
         * top of the list (when displayed in the grid, videos will be ordered by the Order
         * field, descending.
         *
         * @param video Video to add
         *
         * @return True if the video was successfully saved/bookmarked to the DB.
         */
    private DatabaseResult add(YouTubeVideo video) {
		Gson gson = new Gson();
		ContentValues values = new ContentValues();
		values.put(BookmarksTable.COL_YOUTUBE_VIDEO_ID, video.getId());
		values.put(BookmarksTable.COL_YOUTUBE_VIDEO, gson.toJson(video).getBytes());
		int order = getMaximumOrderNumber();
		order++;
		values.put(BookmarksTable.COL_ORDER, order);
		try {
			long result = getWritableDatabase().insertWithOnConflict(BookmarksTable.TABLE_NAME, null, values, SQLiteDatabase.CONFLICT_IGNORE);
			Logger.i(this, "Result for adding "+ video+ " IS "+ result);
			if (result >= 1) {
				return DatabaseResult.SUCCESS;
			}
			if (isBookmarked(video.getId())) {
				return DatabaseResult.NOT_MODIFIED;
			} else {
				return DatabaseResult.ERROR;
			}
		} catch (SQLException e) {
			Logger.e(this, "Unexpected error in bookmark creation :"+ video+" - error:"+e.getMessage(), e);
			return DatabaseResult.ERROR;
		}
	}
    public Single<DatabaseResult> bookmarkAsync(YouTubeVideo video) {
        return Single.fromSupplier(() -> add(video))
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSuccess(status -> {
                    if (status == DatabaseResult.SUCCESS) {
                        notifyCardAdded(video);
                    }
                });
    }
    public Single<DatabaseResult> unbookmarkAsync(VideoId video) {
        return Single.fromSupplier(() -> remove(video))
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSuccess(status -> {
                    if (status == DatabaseResult.SUCCESS) {
                        notifyCardDeleted(video);
                    }
                });
    }
	/**
	 * Remove the specified video from the list of bookmarked videos.
	 *
	 * @param video Video to remove.
	 *
	 * @return True if the video has been unbookmarked; false otherwise.
	 */
	private DatabaseResult remove(VideoId video) {
		try {
			int rowsDeleted = getWritableDatabase().delete(BookmarksTable.TABLE_NAME,
					BookmarksTable.COL_YOUTUBE_VIDEO_ID + " = ?",
					new String[]{video.getId()});
			if (rowsDeleted > 0) {
				// Since we've removed a video, we will need to update the order column for all the videos.
				int order = 1;
				try (Cursor cursor = getReadableDatabase().query(
						BookmarksTable.TABLE_NAME,
						new String[]{BookmarksTable.COL_YOUTUBE_VIDEO, BookmarksTable.COL_ORDER},
						null,
						null, null, null, BookmarksTable.COL_ORDER + " ASC")) {
                    int blobCol = cursor.getColumnIndexOrThrow(BookmarksTable.COL_YOUTUBE_VIDEO);
                    Gson gson = new Gson();
                    while (cursor.moveToNext()) {
                        byte[] blob = cursor.getBlob(blobCol);
                        YouTubeVideo uvideo = gson.fromJson(new String(blob), YouTubeVideo.class).updatePublishTimestampFromDate();
                        ContentValues contentValues = new ContentValues();
                        contentValues.put(BookmarksTable.COL_ORDER, order++);
                        getWritableDatabase().update(BookmarksTable.TABLE_NAME, contentValues, BookmarksTable.COL_YOUTUBE_VIDEO_ID + " = ?",
                                new String[]{uvideo.getId()});
                    }
                }
                return DatabaseResult.SUCCESS;
            }
            return DatabaseResult.NOT_MODIFIED;
		} catch (SQLException e) {
			Logger.e(this, "Database error: " + e.getMessage(), e);
			return DatabaseResult.ERROR;
		}
	}
	/**
	 * When a Video in the Bookmarks tab is drag & dropped to a new position, this will be
	 * called with the new updated list of videos. Since the videos are displayed in descending order,
	 * the first video in the list will have the highest number.
	 *
	 * @param videos List of Videos to update their order.
	 */
	@Override
	public void updateOrder(List<CardData> videos) {
		int order = getMaximumOrderNumber();
		for(CardData video : videos) {
			ContentValues cv = new ContentValues();
			cv.put(BookmarksTable.COL_ORDER, order--);
			getWritableDatabase().update(BookmarksTable.TABLE_NAME, cv, BookmarksTable.COL_YOUTUBE_VIDEO_ID + " = ?", new String[]{video.getId()});
		}
	}
	/**
	 * Check if the specified Video has been bookmarked.
	 *
	 * @param videoId Video to check
	 *
	 * @return True if it has been bookmarked, false if not.
	 */
	public boolean isBookmarked(String videoId) {
		SkyTubeApp.nonUiThread();
		return SQLiteHelper.executeQueryForInteger(getReadableDatabase(), BookmarksTable.IS_BOOKMARKED_QUERY, new String[]{videoId}, 0) > 0;
	}
    /**
     * @return The total number of bookmarked videos.
     */
    public Single<Integer> getTotalBookmarkCount() {
        return Single.fromCallable(() ->
                SQLiteHelper.executeQueryForInteger(getReadableDatabase(), BookmarksTable.COUNT_ALL_BOOKMARKS, 0)
        ).subscribeOn(Schedulers.io());
    }
	/**
	 * @return The maximum of the order number - which could be different from the number of bookmarked videos, in case some of them are deleted.
	 */
	public int getMaximumOrderNumber() {
		SkyTubeApp.nonUiThread();
		return SQLiteHelper.executeQueryForInteger(getReadableDatabase(), BookmarksTable.MAXIMUM_ORDER_QUERY, 0);
	}
	/**
	 * Get the list of Videos that have been bookmarked.
	 *
	 * @return List of Videos
	 */
	public @NonNull Pair<List<YouTubeVideo>, Integer> getBookmarkedVideos(int limit, Integer maxOrderLimit) {
        //Logger.i(this, "getBookmarkedVideos " + limit + ',' + maxOrderLimit +
        //        " - " + (maxOrderLimit != null ? BookmarksTable.PAGED_QUERY : BookmarksTable.PAGED_QUERY_UNBOUNDED));
		SkyTubeApp.nonUiThread();
        SQLiteDatabase db = getReadableDatabase();
        Cursor	cursor = maxOrderLimit != null ?
                db.rawQuery(
                        BookmarksTable.PAGED_QUERY, new String[] { String.valueOf(maxOrderLimit), String.valueOf(limit)}) :
                db.rawQuery(
                        BookmarksTable.PAGED_QUERY_UNBOUNDED, new String[] { String.valueOf(limit)});
		List<YouTubeVideo> videos = new ArrayList<>();
		final Gson gson = new Gson();
		Integer minOrder = null;
		if(cursor.moveToNext()) {
			final int colOrder = cursor.getColumnIndex(BookmarksTable.COL_ORDER);
			final int colVideo = cursor.getColumnIndex(BookmarksTable.COL_YOUTUBE_VIDEO);
			do {
				final byte[] blob = cursor.getBlob(colVideo);
				final int currentOrder = cursor.getInt(colOrder);
                minOrder = Utils.min(currentOrder, minOrder);
				final String videoJson = new String(blob);
				// convert JSON into YouTubeVideo
				YouTubeVideo video = gson.fromJson(videoJson, YouTubeVideo.class).updatePublishTimestampFromDate();
                // Logger.i(this, "Order "+cursor.getInt(colOrder)+ ", id="+video.getId()+","+video.getTitle());
                // due to upgrade to YouTubeVideo (by changing channel{Id,Name} to YouTubeChannel)
				// from version 2.82 to 2.90
				if (video.getChannel() == null) {
					try {
						JSONObject videoJsonObj = new JSONObject(videoJson);
						final String channelId   = videoJsonObj.get("channelId").toString();
						final String channelName = videoJsonObj.get("channelName").toString();
						video.setChannel(new YouTubeChannel(channelId, channelName));
					} catch (JSONException e) {
						Logger.e(this, "Error occurred while extracting channel{Id,Name} from JSON", e);
					}
				}
				// regenerate the video's PublishDatePretty (e.g. 5 hours ago)
				//video.forceRefreshPublishDatePretty();
				// add the video to the list
				videos.add(video);
			} while(cursor.moveToNext());
		}
		cursor.close();
		return Pair.create(videos, minOrder);
	}
	/**
	 *
	 * @return all the bookmarked video's id.
	 */
	public @NonNull Set<VideoId> getAllBookmarkedVideoIds() {
		SkyTubeApp.nonUiThread();
		SQLiteDatabase db = getReadableDatabase();
		Set<VideoId> results = new HashSet<>();
		try (Cursor	cursor = db.rawQuery(BookmarksTable.QUERY_ALL_IDS, new String[0] )) {
			while(cursor.moveToNext()) {
				String id = cursor.getString(0);
				results.add(VideoId.create(id));
			}
		}
		return results;
	}
}
/*
 * SkyTube
 * Copyright (C) 2024  Zsombor Gegesy
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.businessobjects.YouTube.POJOs;
import java.util.Objects;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.model.Status;
public final class PersistentChannel {
    final YouTubeChannel channel;
    final long channelPk;
    final Long subscriptionPk;
    final Status status;
    public PersistentChannel(YouTubeChannel channel, long channelPk, Long subscriptionPk, Status status) {
        this.channel = Objects.requireNonNull(channel, "channel");
        this.channelPk = channelPk;
        this.subscriptionPk = subscriptionPk;
        this.status = status;
    }
    public YouTubeChannel channel() {
        return channel;
    }
    public Status status() {
        return status;
    }
    public ChannelId getChannelId() {
        return channel.getChannelId();
    }
    public long channelPk() {
        return channelPk;
    }
    public Long subscriptionPk() {
        return subscriptionPk;
    }
    public boolean isSubscribed() {
        return subscriptionPk != null;
    }
    public PersistentChannel with(YouTubeChannel newInstance) {
        newInstance.setUserSubscribed(isSubscribed());
        return new PersistentChannel(newInstance, channelPk, subscriptionPk, status);
    }
    public PersistentChannel withSubscriptionPk(Long newSubscriptionPk) {
        return new PersistentChannel(channel, channelPk, newSubscriptionPk, status);
    }
}
/*
 * SkyTube
 * Copyright (C) 2018  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.businessobjects.YouTube.POJOs;
import android.content.Context;
import android.widget.Toast;
import androidx.core.util.Pair;
import org.schabi.newpipe.extractor.exceptions.ParsingException;
import org.schabi.newpipe.extractor.services.youtube.linkHandler.YoutubeChannelLinkHandlerFactory;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.app.Utils;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.VideoBlocker;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.db.ChannelFilteringDb;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.businessobjects.db.SubscriptionsDb;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.disposables.Disposable;
import io.reactivex.rxjava3.schedulers.Schedulers;
/**
 * Represents a YouTube Channel.
 *
 * <p>This class has the ability to query channel info by using the given channel ID.</p>
 */
public class YouTubeChannel extends CardData implements Serializable {
	private String bannerUrl;
	private String totalSubscribers;
	private long subscriberCount;
	private boolean isUserSubscribed;
	private long	lastVisitTime;
	private long    lastCheckTime;
	private long    lastVideoTime;
	private Integer categoryId;
	private final List<YouTubeVideo> youTubeVideos = new ArrayList<>();
	private final List<String> tags;
	public YouTubeChannel() {
		tags = Collections.emptyList();
	}
	public YouTubeChannel(String id, String title) {
		this();
		this.id = id;
		this.title = title;
	}
	public YouTubeChannel(String id, String title, String description, String thumbnailUrl,
						  String bannerUrl, long subscriberCount, boolean isUserSubscribed, long lastVisitTime, long lastCheckTime,
						  Integer categoryId, List<String> tags) {
		this.id = id;
		this.title = title;
		this.description = description;
		this.thumbnailUrl = thumbnailUrl;
		this.bannerUrl = bannerUrl;
		this.subscriberCount = subscriberCount;
		this.totalSubscribers = getFormattedSubscribers(subscriberCount);
		this.isUserSubscribed = isUserSubscribed;
		this.lastVisitTime = lastVisitTime;
		this.lastCheckTime = lastCheckTime;
		this.categoryId = categoryId;
		this.tags = tags;
	}
	private static String getFormattedSubscribers(long subscriberCount) {
		return String.format(SkyTubeApp.getStr(R.string.total_subscribers),subscriberCount);
	}
	public ChannelId getChannelId() {
		return new ChannelId(id);
	}
	public String getBannerUrl() {
		return bannerUrl;
	}
	public String getTotalSubscribers() {
		return totalSubscribers;
	}
	public boolean isUserSubscribed() {
		return isUserSubscribed;
	}
	public long getSubscriberCount() {
		return subscriberCount;
	}
	public long getLastCheckTime() { return lastCheckTime; }
	public Integer getCategoryId() {
		return categoryId;
	}
	public void setCategoryId(Integer categoryId) {
		this.categoryId = categoryId;
	}
	public void setUserSubscribed(boolean userSubscribed) {
		isUserSubscribed = userSubscribed;
	}
    public Disposable updateLastVisitTime() {
        return SubscriptionsDb.getSubscriptionsDb().updateLastVisitTimeAsync(getChannelId()).subscribe(timestamp -> {
            lastVisitTime = timestamp;
            if (lastVisitTime < 0) {
                Logger.e(YouTubeChannel.this, "Unable to update channel's last visit time.  ChannelID=" + id);
            }
        });
    }
	public long getLastVisitTime() {
		return lastVisitTime;
	}
	public long getLastVideoTime() {
		return lastVideoTime;
	}
    public void setLastVideoTime(long lastVideoTime) {
        this.lastVideoTime = lastVideoTime;
    }
	public List<String> getTags() {
		return tags;
	}
	public void addYouTubeVideo(YouTubeVideo video) {
		if(!youTubeVideos.contains(video)) {
			youTubeVideos.add(video);
		}
	}
	public List<YouTubeVideo> getYouTubeVideos() {
		return youTubeVideos;
	}
	/**
	 * Block a channel.  This operation depends on what filtering method was enabled by the user:
	 * i.e. either channel blacklisting or whitelisting.
	 */
	public Single<Boolean> blockChannel() {
		return blockChannel(true);
	}
	/**
	 * Block a channel.  This operation depends on what filtering method was enabled by the user:
	 * i.e. either channel blacklisting or whitelisting.
	 *
	 * @param displayToastMessage Set to true to display toast message when the operation is carried
	 *                            out.
	 */
	public Single<Boolean> blockChannel(boolean displayToastMessage) {
		return DatabaseTasks.subscribeToChannel(false,
						null, SkyTubeApp.getContext(), getChannelId(), false)
				.flatMap(result -> {
					if (SkyTubeApp.getSettings().isChannelDenyListEnabled()) {
						return dennyChannel(displayToastMessage);
					} else {
						return removeAllowedChannel(displayToastMessage);
					}
				})
				.observeOn(AndroidSchedulers.mainThread());
	}
	/**
	 * Block a channel.  This operation depends on what filtering method was enabled by the user:
	 * i.e. either channel blacklisting or whitelisting.
	 */
	public Single<Boolean> unblockChannel() {
		return unblockChannel(true);
	}
    public Single<Boolean> unblockChannel(boolean displayToastMessage) {
        return (SkyTubeApp.getSettings().isChannelDenyListEnabled() ? removeDeniedChannel(displayToastMessage) : allowChannel(displayToastMessage)).observeOn(AndroidSchedulers.mainThread());
    }
	/**
	 * Denny the channel.
	 *
	 * @param displayToastMessage   Set to true to display toast message when the operation is carried
	 *                              out.
	 *
	 * @return True if successful.
	 */
	private Single<Boolean> dennyChannel(boolean displayToastMessage) {
		return Single.fromCallable(() -> ChannelFilteringDb.getChannelFilteringDb().denyChannel(id, title))
				.subscribeOn(Schedulers.io())
				.observeOn(AndroidSchedulers.mainThread())
				.doOnSuccess(success -> {
					if (displayToastMessage) {
						Toast.makeText(SkyTubeApp.getContext(),
								success ? R.string.channel_blacklisted : R.string.channel_blacklist_error,
								Toast.LENGTH_LONG).show();
					}
				});
	}
	/**
	 * Denny the channel.
	 *
	 * @param displayToastMessage   Set to true to display toast message when the operation is carried
	 *                              out.
	 *
	 * @return True if successful.
	 */
	private Single<Boolean> allowChannel(boolean displayToastMessage) {
		return Single.fromCallable(() -> ChannelFilteringDb.getChannelFilteringDb().allowChannel(id, title))
				.subscribeOn(Schedulers.io())
				.observeOn(AndroidSchedulers.mainThread())
				.doOnSuccess(success -> {
					if (displayToastMessage) {
						Toast.makeText(SkyTubeApp.getContext(),
								success ? R.string.channel_blacklisted : R.string.channel_blacklist_error,
								Toast.LENGTH_LONG).show();
					}
				});
	}
	/**
	 * Whitelist the channel.
	 *
	 * @param displayToastMessage   Set to true to display toast message when the operation is carried
	 *                              out.
	 *
	 * @return True if successful.
	 */
	private Single<Boolean> removeAllowedChannel(boolean displayToastMessage) {
		return Single.fromCallable(() -> ChannelFilteringDb.getChannelFilteringDb().removeAllowList(id))
				.subscribeOn(Schedulers.io())
				.observeOn(AndroidSchedulers.mainThread())
				.doOnSuccess(success -> {
					if (displayToastMessage) {
						Toast.makeText(SkyTubeApp.getContext(),
								success ? R.string.channel_unwhitelist_success : R.string.channel_unwhitelist_error,
								Toast.LENGTH_LONG).show();
					}
				});
	}
	/**
	 * Remove channel from the deny list.
	 *
	 * @param displayToastMessage   Set to true to display toast message when the operation is carried
	 *                              out.
	 *
	 * @return True if successful.
	 */
	private Single<Boolean> removeDeniedChannel(boolean displayToastMessage) {
		return Single.fromCallable(() -> ChannelFilteringDb.getChannelFilteringDb().removeDenyList(id))
				.subscribeOn(Schedulers.io())
				.observeOn(AndroidSchedulers.mainThread())
				.doOnSuccess(success -> {
					if (displayToastMessage) {
						Toast.makeText(SkyTubeApp.getContext(),
								success ? R.string.channel_blacklist_updated : R.string.channel_blacklist_update_failure,
								Toast.LENGTH_LONG).show();
					}
				});
	}
	public String getChannelUrl() {
		return getChannelId().toURL();
	}
}
/*
 * SkyTube
 * Copyright (C) 2015  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.app;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.ActivityNotFoundException;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.Build;
import android.os.Looper;
import android.os.StrictMode;
import android.os.SystemClock;
import android.util.Log;
import android.widget.Toast;
import androidx.annotation.ArrayRes;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.core.app.NotificationChannelCompat;
import androidx.core.app.NotificationManagerCompat;
import androidx.core.content.ContextCompat;
import androidx.core.content.res.ResourcesCompat;
import androidx.core.graphics.ColorUtils;
import androidx.core.net.ConnectivityManagerCompat;
import androidx.multidex.MultiDexApplication;
import androidx.preference.PreferenceManager;
import com.google.api.client.googleapis.json.GoogleJsonError;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import org.ocpsoft.prettytime.PrettyTime;
import org.schabi.newpipe.extractor.exceptions.ReCaptchaException;
import java.io.IOException;
import java.net.SocketException;
import java.time.LocalDate;
import java.util.Arrays;
import java.util.List;
import free.rm.skytube.BuildConfig;
import free.rm.skytube.R;
import free.rm.skytube.businessobjects.FeedUpdaterReceiver;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubePlaylist;
import free.rm.skytube.businessobjects.YouTube.YouTubeTasks;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.ContentId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.gui.activities.MainActivity;
import free.rm.skytube.gui.businessobjects.YouTubePlayer;
import free.rm.skytube.gui.fragments.ChannelBrowserFragment;
import free.rm.skytube.gui.fragments.FragmentNames;
import free.rm.skytube.gui.fragments.PlaylistVideosFragment;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.exceptions.UndeliverableException;
import io.reactivex.rxjava3.plugins.RxJavaPlugins;
import io.reactivex.rxjava3.schedulers.Schedulers;
/**
 * SkyTube application.
 */
public class SkyTubeApp extends MultiDexApplication {
	/** SkyTube Application databaseInstance. */
	private static SkyTubeApp skyTubeApp = null;
	private Settings settings;
	private FragmentNames names;
	private static final String TAG = "SkyTubeApp";
	public static final String KEY_SUBSCRIPTIONS_LAST_UPDATED = "SkyTubeApp.KEY_SUBSCRIPTIONS_LAST_UPDATED";
	public static final String NEW_VIDEOS_NOTIFICATION_CHANNEL = "free.rm.skytube.NEW_VIDEOS_NOTIFICATION_CHANNEL";
	public static final int NEW_VIDEOS_NOTIFICATION_CHANNEL_ID = 1;
	@Override
	public void onCreate() {
		super.onCreate();
		this.settings = new Settings(this);
		this.settings.migrate();
		this.names = new FragmentNames(this);
		skyTubeApp = this;
		setupRxJava();
		preloadPrettyTime();
		if (BuildConfig.DEBUG) {
			StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
					.detectDiskReads()
					.detectDiskWrites()
					.detectCustomSlowCalls()
					.detectNetwork()   // or .detectAll() for all detectable problems
					.penaltyLog()
					.build());
			StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
					.detectLeakedSqlLiteObjects()
					.detectLeakedClosableObjects()
					.penaltyLog()
					//.penaltyDeath()
					.build());
		}
		initChannels();
	}
	private void setupRxJava() {
		RxJavaPlugins.setErrorHandler(e -> {
			if (e instanceof UndeliverableException) {
				e = e.getCause();
			}
			if ((e instanceof IOException) || (e instanceof SocketException)) {
				// fine, irrelevant network problem or API that throws on cancellation
				return;
			}
			if (e instanceof InterruptedException) {
				// fine, some blocking code was interrupted by a dispose call
				return;
			}
			if ((e instanceof NullPointerException) || (e instanceof IllegalArgumentException)) {
				// that's likely a bug in the application
				Thread.currentThread().getUncaughtExceptionHandler()
						.uncaughtException(Thread.currentThread(), e);
				return;
			}
			if (e instanceof IllegalStateException) {
				// that's a bug in RxJava or in a custom operator
				Thread.currentThread().getUncaughtExceptionHandler()
						.uncaughtException(Thread.currentThread(), e);
				return;
			}
			Log.e(TAG, "Undeliverable exception received, not sure what to do" + e.getMessage(), e);
		});
	}
	private static void preloadPrettyTime() {
		Completable.fromAction(() -> new PrettyTime().format(LocalDate.of(2021, 2, 23)))
				.subscribeOn(Schedulers.io())
				.onErrorReturn(exc -> {
					Log.e(TAG, "Unable to initialize PrettyTime, because: " + exc.getMessage(), exc);
					return "";
				})
				.subscribe();
	}
	@RequiresApi(api = Build.VERSION_CODES.M)
	private static void uiThreadImpl() {
		if (!Looper.getMainLooper().isCurrentThread()) {
			throw new RuntimeException("Expected to be executing in UI!");
		}
	}
	public static void uiThread() {
		if (BuildConfig.DEBUG) {
			if (Build.VERSION.SDK_INT >= 29) {
				uiThreadImpl();
			} else {
				Log.i(TAG, "Expected to be UI thread : " + Thread.currentThread().getName() + " [" + Build.VERSION.SDK_INT + ']');
			}
		}
	}
	@RequiresApi(api = Build.VERSION_CODES.M)
	private static void nonUiThreadImpl() {
		if (Looper.getMainLooper().isCurrentThread()) {
			throw new RuntimeException("Expected to be NOT blocking the UI!");
		}
	}
	public static void nonUiThread() {
		if (BuildConfig.DEBUG) {
			if (Build.VERSION.SDK_INT >= 29) {
				nonUiThreadImpl();
			} else {
				Log.i(TAG, "Expected to be non-UI thread : " + Thread.currentThread().getName() + " [" + Build.VERSION.SDK_INT + ']');
			}
		}
	}
	/**
	 * Returns a localised string.
	 *
	 * @param  stringResId	String resource ID (e.g. R.string.my_string)
	 * @return Localised string, from the strings XML file.
	 */
	public static String getStr(int stringResId) {
		return skyTubeApp.getString(stringResId);
	}
	/**
	 * Given a string array resource ID, it returns an array of strings.
	 *
	 * @param stringArrayResId String array resource ID (e.g. R.string.my_array_string)
	 * @return Array of String.
	 */
	public static String[] getStringArray(@ArrayRes int stringArrayResId) {
		return skyTubeApp.getStrArray(stringArrayResId);
	}
	/**
	 * Given a string array resource ID, it returns an array of strings.
	 *
	 * @param stringArrayResId String array resource ID (e.g. R.string.my_array_string)
	 * @return Array of String.
	 */
	public String[] getStrArray(@ArrayRes int stringArrayResId) {
		return getResources().getStringArray(stringArrayResId);
	}
	/**
	 * Given a string array resource ID, it returns an list of strings.
	 *
	 * @param stringArrayResId String array resource ID (e.g. R.string.my_array_string)
	 * @return List of String.
	 */
	public static List<String> getStringArrayAsList(@ArrayRes int stringArrayResId) {
		return Arrays.asList(getStringArray(stringArrayResId));
	}
	/**
	 * Returns the App's {@link SharedPreferences}.
	 *
	 * @return {@link SharedPreferences}
	 */
	public static SharedPreferences getPreferenceManager() {
		return PreferenceManager.getDefaultSharedPreferences(skyTubeApp);
	}
	/**
	 * Returns the dimension value that is specified in R.dimens.*.  This value is NOT converted into
	 * pixels, but rather it is kept as it was originally written (e.g. dp).
	 *
	 * @return The dimension value.
	 */
	public static float getDimension(int dimensionId) {
		return skyTubeApp.getResources().getDimension(dimensionId);
	}
	/**
	 * @param colorId   Color resource ID (e.g. R.color.green).
	 *
	 * @return The color for the given color resource id.
	 */
	public static int getColorEx(int colorId) {
		return ResourcesCompat.getColor(skyTubeApp.getResources(), colorId, null);
	}
	/**
	 * @return {@link Context}.
	 */
	public static Context getContext() {
		return skyTubeApp.getBaseContext();
	}
	public static FragmentNames getFragmentNames() {
		return skyTubeApp.names;
	}
	/**
	 * Restart the app.
	 */
	public static void restartApp() {
		Context context = getContext();
		PackageManager packageManager = context.getPackageManager();
		Intent intent = packageManager.getLaunchIntentForPackage(context.getPackageName());
		ComponentName componentName = intent.getComponent();
		Intent mainIntent = Intent.makeRestartActivityTask(componentName);
		context.startActivity(mainIntent);
		System.exit(0);
	}
	/**
	 * @return  True if the device is a tablet; false otherwise.
	 */
	public static boolean isTablet() {
		return getContext().getResources().getBoolean(R.bool.is_tablet);
	}
	/**
	 * @return True if the device is connected to a metered network.
	 */
	public static boolean isActiveNetworkMetered() {
		return ConnectivityManagerCompat.isActiveNetworkMetered(ContextCompat.getSystemService(skyTubeApp,
				ConnectivityManager.class));
	}
	/**
	 * Get the network info
	 * @param context
	 * @return
	 */
	public static NetworkInfo getNetworkInfo(@NonNull Context context){
		return ContextCompat.getSystemService(context, ConnectivityManager.class).getActiveNetworkInfo();
	}
	/**
	 * Check if there is any connectivity
	 * @param context
	 * @return
	 */
	public static boolean isConnected(@NonNull Context context){
		NetworkInfo info = getNetworkInfo(context);
		return (info != null && info.isConnected());
	}
	/*
	 * Initialize Notification Channels (for Android OREO)
	 */
	private void initChannels() {
		final NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
		final NotificationChannelCompat notificationChannel = new NotificationChannelCompat
				.Builder(NEW_VIDEOS_NOTIFICATION_CHANNEL, NotificationManagerCompat.IMPORTANCE_LOW)
				.setName(getString(R.string.notification_channel_feed_title))
				.setLightsEnabled(true)
				.setLightColor(ColorUtils.compositeColors(0xFFFF0000, 0xFFFF0000))
				.setVibrationEnabled(true)
				.build();
		notificationManager.createNotificationChannel(notificationChannel);
	}
	/**
	 * Setup the Feed Updater Service. First, cancel the Alarm that will trigger the next fetch (if there is one), then set the
	 * Alarm with the passed interval, if it's greater than 0.
	 * @param interval The number of milliseconds between each time new videos for subscribed channels should be fetched.
	 */
	public static void setFeedUpdateInterval(int interval) {
		Intent alarm = new Intent(getContext(), FeedUpdaterReceiver.class);
		PendingIntent pendingIntent = PendingIntent.getBroadcast(getContext(), 0, alarm, PendingIntent.FLAG_CANCEL_CURRENT);
		AlarmManager alarmManager = ContextCompat.getSystemService(getContext(), AlarmManager.class);
		// Feed Auto Updater has been cancelled. If the selected interval is greater than 0, set the new alarm to call FeedUpdaterService
		if(interval > 0) {
			alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime()+interval, interval, pendingIntent);
		}
	}
	public static Settings getSettings() {
		return skyTubeApp.settings;
	}
	public Settings getAppSettings() {
		return settings;
	}
	public static void notifyUserOnError(@NonNull Context ctx, @Nullable Throwable throwable) {
		if (throwable == null) {
			return;
		}
        if (throwable instanceof ReCaptchaException) {
            handleRecaptchaException(ctx, (ReCaptchaException) throwable);
            return;
        }
		final String message;
		if (throwable instanceof GoogleJsonResponseException) {
			GoogleJsonResponseException exception = (GoogleJsonResponseException) throwable;
			List<GoogleJsonError.ErrorInfo> errors = exception.getDetails().getErrors();
			if (errors != null && !errors.isEmpty()) {
				message =  "Server error:" + errors.get(0).getMessage()+ ", reason: "+ errors.get(0).getReason();
			} else {
				message = exception.getDetails().getMessage();
			}
		} else {
			message = throwable.getMessage();
		}
		if (message != null) {
			Log.e(TAG, "Error: "+message);
			String toastText = message;
			if(message.contains("resolve host")) {
				toastText = "No internet connection available";
			}
			if(message.contains("JavaScript player")) {
				return; // Error from Player when watching downloaded videos offline
			}
			Toast.makeText(ctx, toastText, Toast.LENGTH_LONG).show();
		}
	}
    private static void handleRecaptchaException(Context context, ReCaptchaException reCaptchaException) {
        // remove "pbj=1" parameter from YouYube urls, as it makes the page JSON and not HTML
        String url = reCaptchaException.getUrl().replace("&pbj=1", "").replace("pbj=1&", "").replace("?pbj=1", "");
        Log.e(TAG, "Error: " + reCaptchaException.getMessage() + " url: " + url, reCaptchaException);
        Toast.makeText(context, R.string.recaptcha_challenge_requested, Toast.LENGTH_LONG).show();
        viewInBrowser(url, context);
        return;
    }
	public static void shareUrl(@NonNull Context context, String url) {
		Intent intent = new Intent(android.content.Intent.ACTION_SEND);
		intent.setType("text/plain");
		intent.putExtra(android.content.Intent.EXTRA_TEXT, url);
		context.startActivity(Intent.createChooser(intent, context.getString(R.string.share_via)));
	}
	public static void copyUrl(@NonNull Context context, String text, String url) {
		ClipData clip = ClipData.newPlainText(text, url);
		ContextCompat.getSystemService(context, ClipboardManager.class).setPrimaryClip(clip);
		Toast.makeText(context, R.string.url_copied_to_clipboard, Toast.LENGTH_SHORT).show();
	}
	/**
	 * The video URL is passed to SkyTube via another Android app (i.e. via an intent).
	 *
	 * @return The URL of the YouTube video the user wants to play.
	 */
	public static ContentId getUrlFromIntent(@NonNull final Context ctx, final Intent intent) {
		if (Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getData() != null) {
			return parseUrl(ctx, intent.getData().toString(), true);
		}
		return null;
	}
	public static ContentId parseUrl(@NonNull Context context, String url, boolean showErrorIfNotValid) {
		try {
			ContentId id = NewPipeService.get().getContentId(url);
			if (id == null && showErrorIfNotValid) {
				showInvalidUrlToast(context, url);
			}
			return id;
		} catch (RuntimeException e) {
			SkyTubeApp.notifyUserOnError(context, e);
			return null;
		}
	}
	private static void showInvalidUrlToast(@NonNull Context context, String url) {
		String message = String.format(context.getString(R.string.error_invalid_url), url);
		Toast.makeText(context, message, Toast.LENGTH_LONG).show();
	}
	/**
	 * Open the url - internally, or externally if useExternalBrowser is switched on.
	 * @param ctx
	 * @param url
	 * @param useExternalBrowser
	 */
	public static void openUrl(Context ctx, String url, boolean useExternalBrowser) {
		// Show error message only if we don't want to use external browser, so we expect that the URL
		// can be handled internally, and if the URL is invalid, it's an error.
		ContentId content = parseUrl(ctx, url, !useExternalBrowser);
		if (openContent(ctx, content)) {
			return;
		} else {
			if (useExternalBrowser) {
				viewInBrowser(url, ctx);
			}
		}
	}
	/**
	 * Open the content in the appropriate viewer Activity, return true if it found one.
	 * @param ctx
	 * @param content
	 * @return
	 */
	public static boolean openContent(Context ctx, ContentId content) {
		if (content == null) {
			return false;
		}
		switch (content.getType()) {
			case STREAM: {
				YouTubePlayer.launch(content, ctx);
				break;
			}
			case CHANNEL: {
				SkyTubeApp.launchChannel(new ChannelId(content.getId()), ctx);
				break;
			}
			case PLAYLIST: {
				YouTubeTasks.getPlaylist(ctx, content.getId())
						.subscribe(playlist -> launchPlaylist(playlist, ctx));
				break;
			}
			default:
				return false;
		}
		return true;
	}
	/**
	 * Launches the channel view, so the user can see all the videos from a channel.
	 *
	 * @param channelId the channel to be displayed.
	 */
	public static void launchChannel(ChannelId channelId, Context context) {
		if (channelId != null) {
			DatabaseTasks.getChannelInfo(context, channelId, true)
					.subscribe(youTubeChannel -> launchChannel(youTubeChannel.channel(), context));
		}
	}
	/**
	 * Launches the channel view, so the user can see all the videos from a channel.
	 *
	 * @param youTubeChannel the channel to be displayed.
	 */
	public static void launchChannel(YouTubeChannel youTubeChannel, Context context) {
		Intent i = new Intent(context, MainActivity.class);
		i.setAction(MainActivity.ACTION_VIEW_CHANNEL);
		i.putExtra(ChannelBrowserFragment.CHANNEL_OBJ, youTubeChannel);
		context.startActivity(i);
	}
	/**
	 * Launch the {@link PlaylistVideosFragment}
	 * @param playlist the playlist to display
	 */
	public static void launchPlaylist(final YouTubePlaylist playlist, final Context context) {
		Intent playlistIntent = new Intent(context, MainActivity.class);
		playlistIntent.setAction(MainActivity.ACTION_VIEW_PLAYLIST);
		playlistIntent.putExtra(PlaylistVideosFragment.PLAYLIST_OBJ, playlist);
		context.startActivity(playlistIntent);
	}
	/**
	 * Launch an external activity to actually open the given URL
	 * @param url
	 */
	public static void viewInBrowser(String url, final Context context) {
		Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
		browserIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		try {
			context.startActivity(browserIntent);
		} catch (ActivityNotFoundException e) {
			showInvalidUrlToast(context, url);
			Log.e(TAG, "Activity not found for " + url + ", error:" + e.getMessage(), e);
		}
	}
}
/*
 * SkyTube
 * Copyright (C) 2021  Zsombor Gegesy
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.app;
import java.util.function.Consumer;
import free.rm.skytube.app.utils.WeakList;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.Tasks.GetSubscriptionVideosTaskListener;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.gui.businessobjects.MainActivityListener;
import free.rm.skytube.gui.fragments.MainFragment;
public class EventBus {
    public enum SettingChange {
        HIDE_TABS,
        CONTENT_COUNTRY,
        SUBSCRIPTION_LIST_CHANGED
    }
    private static EventBus instance;
    private WeakList<MainFragment> mainFragments = new WeakList<>();
    private WeakList<MainActivityListener> mainActivityListeners = new WeakList<>();
    private WeakList<GetSubscriptionVideosTaskListener> subscriptionListeners = new WeakList<GetSubscriptionVideosTaskListener>();
    private WeakList<Consumer<YouTubeVideo>> videoDetailListeners = new WeakList<>();
    public static synchronized EventBus getInstance() {
        if (instance == null) {
            instance = new EventBus();
        }
        return instance;
    }
    public void registerMainFragment(MainFragment mainFragment) {
        this.mainFragments.add(mainFragment);
    }
    public void notifyMainTabChanged(SettingChange settingChange) {
        this.mainFragments.forEach(main -> main.refreshTabs(settingChange));
    }
    public void notifyChannelNewVideosStatus(ChannelId channelId, boolean newVideos) {
        this.mainFragments.forEach(main -> main.notifyChangeChannelNewVideosStatus(channelId, newVideos));
    }
    public void notifyChannelNewVideos(ChannelId channelId, int newVideos) {
        if (newVideos > 0) {
            this.mainFragments.forEach(main -> main.notifyChangeChannelNewVideosStatus(channelId, true));
        }
    }
    public void notifyVideoDetailFetched(YouTubeVideo video) {
        this.videoDetailListeners.forEach(listener -> listener.accept(video));
    }
    public void registerVideoDetailFetcher(Consumer<YouTubeVideo> videoListener) {
        this.videoDetailListeners.add(videoListener);
    }
    public void notifyChannelRemoved(ChannelId channelId) {
        this.mainFragments.forEach(main -> main.notifyChannelRemoved(channelId));
    }
    public void registerMainActivityListener(MainActivityListener listener) {
        this.mainActivityListeners.add(listener);
    }
    public void notifyMainActivities(Consumer<MainActivityListener> function) {
        this.mainActivityListeners.forEach(function);
    }
    public void registerSubscriptionListener(GetSubscriptionVideosTaskListener listener) {
        this.subscriptionListeners.add(listener);
    }
    public void unregisterSubscriptionListener(GetSubscriptionVideosTaskListener listener) {
        this.subscriptionListeners.remove(listener);
    }
    public void notifyChannelVideoFetchingFinished(boolean changes) {
        this.subscriptionListeners.forEach(listener -> listener.onChannelVideoFetchFinish(changes));
    }
    public void notifySubscriptionRefreshFinished() {
        this.subscriptionListeners.forEach(listener -> listener.onSubscriptionRefreshFinished());
    }
    public void notifyChannelsFound(boolean hasSubscriptions) {
        this.subscriptionListeners.forEach(listener -> listener.onChannelsFound(hasSubscriptions));
    }
}
/*
 * SkyTube
 * Copyright (C) 2016  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.businessobjects.db;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import com.github.skytube.components.utils.SQLiteHelper;
import com.github.skytube.components.utils.Stopwatch;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.google.gson.JsonSerializer;
import java.io.IOException;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.app.Utils;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.ChannelView;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.model.Status;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.schedulers.Schedulers;
/**
 * A database (DB) that stores user subscriptions (with respect to YouTube channels).
 */
public class SubscriptionsDb extends SQLiteOpenHelperEx {
    private static final String HAS_VIDEO_QUERY = String.format("SELECT COUNT(*) FROM %s WHERE %s = ?", SubscriptionsVideosTable.TABLE_NAME_V2, SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID);
    private static final String GET_VIDEO_IDS_BY_CHANNEL_TO_PUBLISH_TS = String.format("SELECT %s,%s FROM %s WHERE %s = ?",
            SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID, SubscriptionsVideosTable.COL_PUBLISH_TIME.name(), SubscriptionsVideosTable.TABLE_NAME_V2, SubscriptionsVideosTable.COL_CHANNEL_ID);
    private static final String GET_VIDEO_IDS_BY_CHANNEL = String.format("SELECT %s FROM %s WHERE %s = ?",
            SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID, SubscriptionsVideosTable.TABLE_NAME_V2, SubscriptionsVideosTable.COL_CHANNEL_ID);
    private static final String FIND_EMPTY_RETRIEVAL_TS = String.format("SELECT %s,%s FROM %s WHERE %s IS NULL",
			SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID, SubscriptionsVideosTable.COL_YOUTUBE_VIDEO, SubscriptionsVideosTable.TABLE_NAME, SubscriptionsVideosTable.COL_RETRIEVAL_TS);
    private static final String SUBSCRIBED_CHANNEL_INFO = "SELECT c.Channel_Id,c.Title,c.Thumbnail_Normal_Url,s.Last_Visit_Time,c.Last_Video_TS as latest_video_ts,c.state FROM Subs s,Channel c where s.channel_pk = c._Id ";
	private static final String SUBSCRIBED_CHANNEL_INFO_ORDER_BY = " ORDER BY LOWER(" + LocalChannelTable.COL_TITLE + ") ASC";
	private static final String SUBSCRIBED_CHANNEL_LIMIT_BY_TITLE = " and LOWER(c." +LocalChannelTable.COL_TITLE + ") like ?";
    private static final String GET_ALL_SUBSCRIBED_CHANNEL_ID = "SELECT s." + SubscriptionsTable.COL_CHANNEL_ID + " FROM " + SubscriptionsTable.TABLE_NAME + " s, " + LocalChannelTable.TABLE_NAME + " c where s.channel_pk = c._Id and c." + LocalChannelTable.COL_STATE.name() + " = 0";
	private static final String IS_SUBSCRIBED_QUERY = String.format("SELECT EXISTS(SELECT %s FROM %s WHERE %s =?) AS VAL ", SubscriptionsTable.COL_ID, SubscriptionsTable.TABLE_NAME, SubscriptionsTable.COL_CHANNEL_ID);
    private static final String GET_PK_FROM_CHANNEL_ID = "SELECT " + SubscriptionsTable.COL_ID + " FROM " + SubscriptionsTable.TABLE_NAME + " WHERE " + SubscriptionsTable.COL_CHANNEL_ID + " = ?";
	private static volatile SubscriptionsDb subscriptionsDb = null;
    private static final int DATABASE_VERSION = 18;
    private static final String DATABASE_NAME = "subs.db";
    private SubscriptionsDb(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }
	public static synchronized SubscriptionsDb getSubscriptionsDb() {
		if (subscriptionsDb == null) {
			subscriptionsDb = new SubscriptionsDb(SkyTubeApp.getContext());
		}
		return subscriptionsDb;
	}
    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(SubscriptionsTable.getCreateStatement());
        SubscriptionsVideosTable.addNewFlatTable(db, false);
        SubscriptionsVideosTable.addPublishTimeIndex(db);
        db.execSQL(LocalChannelTable.getCreateStatement(true));
        LocalChannelTable.addChannelIdIndex(db);
        db.execSQL(CategoriesTable.getCreateStatement());
        new CategoryManagement(db).setupDefaultCategories();
    }
	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        VersionUpgrade upgrade = new VersionUpgrade(oldVersion, newVersion);
        // Version 2 of the database introduces the SubscriptionsVideosTable, which stores videos found in each subscribed channel
        if (upgrade.executeStep(2)) {
            db.execSQL(SubscriptionsVideosTable.getCreateStatement());
        }
        if (upgrade.executeStep(3)) {
            SQLiteHelper.execSQLUpdates(db, SubscriptionsTable.getAddColumns());
        }
        if (upgrade.executeStep(4)) {
            SQLiteHelper.execSQLUpdates(db, SubscriptionsVideosTable.getAddTimestampColumns());
            setupRetrievalTimestamp(db);
        }
        if (upgrade.executeStep(5)) {
            SQLiteHelper.execSQLUpdates(db, SubscriptionsTable.getLastCheckTimeColumn());
			db.execSQL(LocalChannelTable.getCreateStatement(false));
			try {
				for (YouTubeChannel channel : getSubscribedChannels(db)) {
					if (!Utils.isEmpty(channel.getId()) &&
							!Utils.isEmpty(channel.getTitle()) &&
							!Utils.isEmpty(channel.getBannerUrl()) &&
							!Utils.isEmpty(channel.getThumbnailUrl()) &&
							!Utils.isEmpty(channel.getDescription())) {
						cacheChannel(db, null, channel);
					}
				}
			} catch (IOException ex) {
				Logger.e(this, "Unable to load subscribed channels to populate cache:" + ex.getMessage(), ex);
			}
		}
        if (upgrade.executeStep(7)) {
            db.execSQL(SubscriptionsVideosTable.getIndexOnVideos());
        }
        if (upgrade.executeStep(8)) {
            SQLiteHelper.continueOnError(db, CategoriesTable.getCreateStatement());
            new CategoryManagement(db).setupDefaultCategories();
            SubscriptionsTable.addCategoryColumn(db);
        }
        if (upgrade.executeStep(9)) {
            SubscriptionsVideosTable.addNewFlatTable(db, true);
            migrateFromJsonColumn(db);
        }
        if (upgrade.executeStep(10)) {
            fixChannelIds(db);
        }
        if (upgrade.executeStep(11)) {
            dropOldSubsVideosTable(db);
        }
        if (upgrade.executeStep(12)) {
            normalizeSubscriptionVideosTable(db);
        }
        if (upgrade.executeStep(13)) {
            LocalChannelTable.addIdColumn(db);
        }
        if (upgrade.executeStep(14)) {
            normalizeSubscriptionVideosTableSecondStep(db);
        }
        if (upgrade.executeStep(15)) {
            SubscriptionsTable.cleanupTable(db);
        }
        if (upgrade.executeStep(17)) {
            Logger.w(this, "Remove channel title from subscription_videos table");
            SubscriptionsVideosTable.removeChannelTitle(db);
            SubscriptionsVideosTable.addPublishTimeIndex(db);
        }
        if (upgrade.executeStep(18)) {
            Logger.w(this, "Optimize Channel table");
            LocalChannelTable.addChannelIdIndex(db);
            SubscriptionsTable.addChannelIdColumn(db);
            LocalChannelTable.addStateColumn(db);
        }
    }
    private void normalizeSubscriptionVideosTable(final SQLiteDatabase db) {
        Logger.w(this, "Normalizing subscription_videos table");
        SubscriptionsVideosTable.addSubsIdColumn(db);
        Map<ChannelId, Long> channelIdLongMap = getChannelIdLongMap(db, SubscriptionsTable.GET_ID_AND_CHANNEL_ID);
        for (Map.Entry<ChannelId, Long> entry : channelIdLongMap.entrySet()) {
            db.execSQL("update subscription_videos set subs_id = ? where Channel_Id = ?",new Object[] {
                    entry.getValue(), entry.getKey().getRawId() });
        }
    }
    private void normalizeSubscriptionVideosTableSecondStep(final SQLiteDatabase db) {
        Logger.w(this, "Normalizing subscription_videos table - 2nd step");
        SubscriptionsVideosTable.addChannelPkColumn(db);
        Map<ChannelId, Long> channelIdLongMap = getChannelIdLongMap(db, LocalChannelTable.GET_ID_AND_CHANNEL_ID);
        for (Map.Entry<ChannelId, Long> entry : channelIdLongMap.entrySet()) {
            db.execSQL("update subscription_videos set channel_pk = ? where Channel_Id = ?",new Object[] {
                    entry.getValue(), entry.getKey().getRawId() });
        }
    }
    private static Map<ChannelId, Long> getChannelIdLongMap(final SQLiteDatabase db, final String query) {
        Map<ChannelId, Long> channelIdLongMap = new HashMap<>();
        try (Cursor cursor = db.rawQuery(query, null)) {
            final int _idIdx = cursor.getColumnIndex(SubscriptionsTable.COL_ID);
            final int channelIdx = cursor.getColumnIndex(SubscriptionsTable.COL_CHANNEL_ID);
            while (cursor.moveToNext()) {
                Long id = Objects.requireNonNull(cursor.getLong(_idIdx), "missing _id column");
                String channelIds = Objects.requireNonNull(cursor.getString(channelIdx), "missing channelIdx column");
                channelIdLongMap.put(new ChannelId(channelIds), id);
            }
        }
        return channelIdLongMap;
    }
    private void dropOldSubsVideosTable(final SQLiteDatabase db) {
        Logger.w(this, "Dropping old Subs table");
        SQLiteHelper.continueOnError(db, SubscriptionsVideosTable.getDropTableStatement());
    }
    private void fixChannelIds(final SQLiteDatabase db) {
        Logger.w(this, "Fixing channel_id in the subscription_videos table");
        db.execSQL("update subscription_videos set channel_id = substr(channel_id, 33) where channel_id like \"https://www.youtube.com/channel/%\"");
    }
    private void migrateFromJsonColumn(final SQLiteDatabase db) {
        int fullCount = 0;
        Gson gson = new GsonBuilder().registerTypeAdapter(YouTubeChannel.class, (JsonSerializer<YouTubeChannel>) (src, typeOfSrc, context) -> {
            JsonObject obj = new JsonObject();
            obj.addProperty("id", src.getId());
            obj.addProperty("title", src.getTitle());
            obj.addProperty("description", src.getDescription());
            obj.addProperty("thumbnailNormalUrl", src.getThumbnailUrl());
            obj.addProperty("bannerUrl", src.getBannerUrl());
            return obj;
        }).create();
        while (true) {
            int success = migrateFromJsonColumnBlock(db, gson);
            if (success > 0) {
                fullCount += success;
            } else {
                Logger.w(this, "Migrated " + fullCount + " videos");
                return;
            }
        }
    }
    private int migrateFromJsonColumnBlock(final SQLiteDatabase db, Gson gson) {
        int counter = 0;
        int success = 0;
        try (Cursor cursor = db.query(SubscriptionsVideosTable.TABLE_NAME,
                new String[] { SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID, SubscriptionsVideosTable.COL_YOUTUBE_VIDEO},
                null,
                null,null, null, null, "100")) {
            while (cursor.moveToNext()) {
                counter ++;
                String id = cursor.getString(0);
                final byte[] blob = cursor.getBlob(1);
                final String videoJson = new String(blob);
                // convert JSON into YouTubeVideo
                YouTubeVideo video = gson.fromJson(videoJson, YouTubeVideo.class);
                ContentValues values = convertToContentValues(video, null);
                long rowId = db.insert(SubscriptionsVideosTable.TABLE_NAME_V2, null, values);
                if (rowId > 0) {
                    success ++;
                }
            }
        }
        Logger.w(this, "Loaded " + counter + " videos, updated " + success + " videos successfully");
        return success;
    }
	private void setupRetrievalTimestamp(SQLiteDatabase db) {
        List<YouTubeVideo> videos = extractVideos(db.rawQuery(FIND_EMPTY_RETRIEVAL_TS, null), false);
        int count = 0;
        for (YouTubeVideo video : videos) {
            final Long publishTimestamp = video.getPublishTimestamp();
            if (publishTimestamp != null) {
                ContentValues values = new ContentValues();
                values.put(SubscriptionsVideosTable.COL_PUBLISH_TS, publishTimestamp);
                values.put(SubscriptionsVideosTable.COL_RETRIEVAL_TS, publishTimestamp);
                int updateCount = db.update(
                        SubscriptionsVideosTable.TABLE_NAME,
                        values,
                        SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID_EQUALS_TO,
                        new String[]{video.getId()});
                Logger.i(this,"updating " + video.getId() + " with publish date:" + ZonedDateTime.ofInstant(Instant.ofEpochMilli(publishTimestamp), ZoneId.systemDefault()) + " -> " + updateCount);
                count += updateCount;
            }
        }
        Logger.i(this, "From " + videos.size() + ", retrieval timestamp filled for " + count);
    }
	/**
	 * Saves the given channel into the subscriptions DB.
	 *
	 * @param persistentChannel Channel the user wants to subscribe to.
	 * @param videos the channel videos, which needs to be added to the database.
     *
	 * @return DatabaseResult.SUCCESS if the operation was successful; NOT_MODIFIED or ERROR otherwise.
	 */
	public DatabaseResult subscribe(PersistentChannel persistentChannel, Collection<YouTubeVideo> videos) {
		SkyTubeApp.nonUiThread();
		saveChannelVideos(videos, persistentChannel, false);
		return saveSubscription(persistentChannel.channelPk(), persistentChannel.getChannelId());
	}
	/**
	 * Saves the given channel into the subscriptions DB.
	 *
	 * @param channelId The id of the channel the user wants to subscribe to.
	 *
	 * @return True if the operation was successful; false otherwise.
	 */
	private DatabaseResult saveSubscription(long channelPk, ChannelId channelId) {
		SkyTubeApp.nonUiThread();
		ContentValues values = new ContentValues();
		values.put(SubscriptionsTable.COL_CHANNEL_ID, channelId.getRawId());
        values.put(SubscriptionsTable.COL_CHANNEL_PK.name(), channelPk);
		SQLiteDatabase db = getWritableDatabase();
		try {
			long result = db.insertWithOnConflict(SubscriptionsTable.TABLE_NAME, null, values, SQLiteDatabase.CONFLICT_IGNORE);
			if (result > 0) {
				return DatabaseResult.SUCCESS;
			}
			if (isUserSubscribedToChannel(channelId)) {
				Logger.i(this, "Already subscribed to " + channelId);
				return DatabaseResult.NOT_MODIFIED;
			}
			Logger.i(this, "Unable to subscribe to " + channelId);
			return DatabaseResult.ERROR;
		} catch (SQLException e) {
			Logger.e(this, "Error during subscribing: " + e.getMessage(), e);
			return DatabaseResult.ERROR;
		}
	}
	/**
	 * Removes the given channel from the subscriptions DB.
	 *
	 * @param channel  the channel the user wants to unsubscribe from.
	 *
	 * @return True if the operation was successful; false otherwise.
	 */
	public DatabaseResult unsubscribe(PersistentChannel channel) {
		SkyTubeApp.nonUiThread();
        Logger.i(this, "unsubscribing subs_id= %s, channel_id = %s, channel_pk = %s", channel.subscriptionPk(), channel.getChannelId(), channel.channelPk());
        // delete any feed videos pertaining to this channel
        getWritableDatabase().delete(SubscriptionsVideosTable.TABLE_NAME_V2,
                SubscriptionsVideosTable.COL_SUBS_ID.name() + " = ?",
                toArray(channel.subscriptionPk()));
        // remove this channel from the subscriptions DB
        int rowsDeleted = getWritableDatabase().delete(SubscriptionsTable.TABLE_NAME,
                SubscriptionsTable.COL_CHANNEL_ID + " = ?",
                toArray(channel.channel().getId()));
		// Need to make sure when we come back to MainActivity, that we refresh the Feed tab so it hides videos from the newly unsubscribed
		SkyTubeApp.getSettings().setRefreshSubsFeedFromCache(true);
		return (rowsDeleted >= 0) ? DatabaseResult.SUCCESS : DatabaseResult.NOT_MODIFIED;
	}
	public void unsubscribeFromAllChannels() {
		getWritableDatabase().delete(SubscriptionsVideosTable.TABLE_NAME_V2,null,null);
		getWritableDatabase().delete(SubscriptionsTable.TABLE_NAME,null,null);
	}
	/**
	 * @param channelId the id of the channel
	 * @return all the video ids for the subscribed channels from the database.
	 */
	public Set<String> getSubscribedChannelVideosByChannel(ChannelId channelId) {
		SkyTubeApp.nonUiThread();
        try (Cursor cursor = getReadableDatabase().rawQuery(GET_VIDEO_IDS_BY_CHANNEL, toArrayParam(channelId))) {
			Set<String> result = new HashSet<>();
			while(cursor.moveToNext()) {
				result.add(cursor.getString(0));
			}
			return result;
		}
	}
    /**
     * @param channelId the id of the channel
     * @return all the video ids for the subscribed channels from the database, mapped to publication times
     */
    public Map<String, Long> getSubscribedChannelVideosByChannelToTimestamp(ChannelId channelId) {
        SkyTubeApp.nonUiThread();
        try(Cursor cursor = getReadableDatabase().rawQuery(GET_VIDEO_IDS_BY_CHANNEL_TO_PUBLISH_TS, toArrayParam(channelId))) {
            Map<String, Long> result = new HashMap<>();
            while(cursor.moveToNext()) {
                result.put(cursor.getString(0), cursor.getLong(1));
            }
            return result;
        }
    }
    public void updateVideo(YouTubeVideo video) {
        ContentValues values = convertToContentValues(video, null);
        getWritableDatabase().update(
                SubscriptionsVideosTable.TABLE_NAME_V2,
                values,
                SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID_EQUALS_TO,
                new String[] { video.getId() });
    }
    private ContentValues convertToContentValues(final YouTubeVideo video, @Nullable PersistentChannel persistentChannel) {
        ContentValues values = new ContentValues();
        if (persistentChannel != null) {
            ChannelId chId = persistentChannel.getChannelId();
            values.put(SubscriptionsVideosTable.COL_CHANNEL_ID_V2.name(), chId.getRawId());
            values.put(SubscriptionsVideosTable.COL_SUBS_ID.name(), persistentChannel.subscriptionPk());
            values.put(SubscriptionsVideosTable.COL_CHANNEL_PK.name(), persistentChannel.channelPk());
        }
        values.put(SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID_V2.name(), video.getId());
        values.put(SubscriptionsVideosTable.COL_CATEGORY_ID.name(), video.getCategoryId());
        values.put(SubscriptionsVideosTable.COL_PUBLISH_TIME_EXACT.name(), video.getPublishTimestampExact());
        values.put(SubscriptionsVideosTable.COL_PUBLISH_TIME.name(), video.getPublishTimestamp());
        if (video.getLikeCountNumber() != null) {
            values.put(SubscriptionsVideosTable.COL_LIKES.name(), video.getLikeCountNumber());
        }
        if (video.getDislikeCountNumber() != null) {
            values.put(SubscriptionsVideosTable.COL_DISLIKES.name(), video.getDislikeCountNumber());
        }
        if (video.getViewsCountInt() != null) {
            values.put(SubscriptionsVideosTable.COL_VIEWS.name(), video.getViewsCountInt().longValue());
        }
        if (video.getTitle() != null) {
            values.put(SubscriptionsVideosTable.COL_TITLE.name(), video.getTitle());
        }
        if (video.getDescription() != null) {
            values.put(SubscriptionsVideosTable.COL_DESCRIPTION.name(), video.getDescription());
        }
        values.put(SubscriptionsVideosTable.COL_DURATION.name(), video.getDurationInSeconds());
        if (video.getThumbnailUrl() != null) {
            values.put(SubscriptionsVideosTable.COL_THUMBNAIL_URL.name(), video.getThumbnailUrl());
        }
        return values;
    }
    public int setPublishTimestamp(YouTubeVideo video) {
        ContentValues values = new ContentValues();
        values.put(SubscriptionsVideosTable.COL_PUBLISH_TIME.name(), video.getPublishTimestamp());
        return getWritableDatabase().update(
                SubscriptionsVideosTable.TABLE_NAME_V2,
                values,
                SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID_EQUALS_TO,
                new String[] { video.getId() });
    }
	private List<ChannelId> getSubscribedChannelIds() {
		SkyTubeApp.nonUiThread();
		try (Cursor cursor = getReadableDatabase().rawQuery(GET_ALL_SUBSCRIBED_CHANNEL_ID,null)) {
			List<ChannelId> result = new ArrayList<>();
			while(cursor.moveToNext()) {
				result.add(new ChannelId(cursor.getString(0)));
			}
			return result;
		}
	}
	public Single<List<ChannelId>> getSubscribedChannelIdsAsync() {
		return Single.fromCallable(() -> getSubscribedChannelIds())
				.subscribeOn(Schedulers.io());
	}
    public void setChannelState(@NonNull ChannelId channelId, @NonNull Status status) {
        Logger.i(this, "Set channel id=%s state to %s", channelId, status);
        SkyTubeApp.nonUiThread();
        LocalChannelTable.updateChannelStatus(getWritableDatabase(), channelId, status);
    }
    /**
	 * Returns a list of channels that the user subscribed to, without accessing the network
	 *
	 *
	 * @return A list of channels that the user subscribed to.
	 * @throws IOException
	 */
	private List<YouTubeChannel> getSubscribedChannels(SQLiteDatabase db) throws IOException {
		SkyTubeApp.nonUiThread();
		try (Cursor cursor = db.rawQuery("select s._id subs_id, s.category_id, s.Last_Visit_Time, c.* from Subs s join Channel c on s.Channel_Id = c.Channel_Id", null)) {
			List<YouTubeChannel> subsChannels = new ArrayList<>();
			if (cursor.moveToNext()) {
				final int colChannelIdNum = cursor.getColumnIndexOrThrow(LocalChannelTable.COL_CHANNEL_ID.name());
				final int colTitle = cursor.getColumnIndexOrThrow(LocalChannelTable.COL_TITLE);
				final int colDescription = cursor.getColumnIndexOrThrow(LocalChannelTable.COL_DESCRIPTION);
				final int colBanner = cursor.getColumnIndexOrThrow(LocalChannelTable.COL_BANNER_URL);
				final int colThumbnail = cursor.getColumnIndexOrThrow(LocalChannelTable.COL_THUMBNAIL_NORMAL_URL);
				final int colSubscribers = cursor.getColumnIndexOrThrow(LocalChannelTable.COL_SUBSCRIBER_COUNT);
				final int colLastCheck = cursor.getColumnIndexOrThrow(LocalChannelTable.COL_LAST_CHECK_TS);
                final int colLastVisit = cursor.getColumnIndexOrThrow(SubscriptionsTable.COL_LAST_VISIT_TIME);
				final int colCategoryId = cursor.getColumnIndexOrThrow(SubscriptionsTable.COL_CATEGORY_ID.name());
				do {
					final String id = cursor.getString(colChannelIdNum);
					Integer categoryId = getInteger(cursor, colCategoryId);
					subsChannels.add(new YouTubeChannel(id, cursor.getString(colTitle),
							cursor.getString(colDescription), cursor.getString(colThumbnail),
							cursor.getString(colBanner), cursor.getLong(colSubscribers), true, cursor.getLong(colLastVisit),
							cursor.getLong(colLastCheck),
							categoryId, Collections.emptyList()));
				} while (cursor.moveToNext());
			}
			return subsChannels;
		}
	}
	private Integer getInteger(Cursor cursor, int colCategoryId) {
		return (colCategoryId < 0 || cursor.isNull(colCategoryId)) ? null : cursor.getInt(colCategoryId);
	}
	/**
	 * Checks if the user is subscribed to the given channel.
	 *
	 * @param channelId	Channel ID
	 * @return True if the user is subscribed; false otherwise.
	 * @throws IOException
	 */
	public boolean isUserSubscribedToChannel(ChannelId channelId) {
		SkyTubeApp.nonUiThread();
        return SQLiteHelper.executeQueryForInteger(getReadableDatabase(), IS_SUBSCRIBED_QUERY, toArrayParam(channelId), 0) > 0;
	}
	public Single<Boolean> getUserSubscribedToChannel(ChannelId channelId) {
		return Single.fromCallable(() -> isUserSubscribedToChannel(channelId)).subscribeOn(Schedulers.io());
	}
    /**
     * Updates the given channel's last visit time.
     *
     * @param channelId	Channel ID
     *
     * @return	last visit time, if the update was successful;  -1 otherwise.
     */
    public Single<Long> updateLastVisitTimeAsync(ChannelId channelId) {
        return Single.fromCallable(() -> {
            SQLiteDatabase	db = getWritableDatabase();
            long			currentTime = System.currentTimeMillis();
            ContentValues values = new ContentValues();
            values.put(SubscriptionsTable.COL_LAST_VISIT_TIME, currentTime);
            int count = db.update(
                SubscriptionsTable.TABLE_NAME,
                values,
                SubscriptionsTable.COL_CHANNEL_ID + " = ?",
                toArrayParam(channelId));
            return (count > 0 ? currentTime : -1);
        }).subscribeOn(Schedulers.io());
    }
    
    private boolean hasVideo(YouTubeVideo video) {
        return SQLiteHelper.executeQueryForInteger(getReadableDatabase(), HAS_VIDEO_QUERY, new String[]{video.getId()}, 0) > 0;
    }
	/**
	 * Loop through each video saved in the passed {@link YouTubeChannel} and insert it into the database, or update it.
	 * @param videos the list of videos
     * @param persistentChannel information about the persisted channel.
	 */
	public void saveChannelVideos(Collection<YouTubeVideo> videos, PersistentChannel persistentChannel, boolean doUpdate) {
        SkyTubeApp.nonUiThread();
        SQLiteDatabase db = getWritableDatabase();
        long latestPublishTimestamp = 0;
        for (YouTubeVideo video : videos) {
            if (video.getPublishTimestamp() != null) {
                latestPublishTimestamp = Math.max(latestPublishTimestamp, video.getPublishTimestamp());
                ContentValues values = createContentValues(video, persistentChannel);
                if (hasVideo(video)) {
                    if (doUpdate) {
                        values.remove(SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID);
                        db.update(SubscriptionsVideosTable.TABLE_NAME_V2,
                                values,
                                SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID_EQUALS_TO,
                                new String[]{video.getId()});
                    }
                } else {
                    db.insert(SubscriptionsVideosTable.TABLE_NAME_V2, null, values);
                }
            }
        }
        SubscriptionsTable.updateLastVideoFetchTimestamps(db, persistentChannel);
        LocalChannelTable.updateLatestVideoTimestamp(db, persistentChannel, latestPublishTimestamp);
    }
    private ContentValues createContentValues(YouTubeVideo video, PersistentChannel persistentChannel) {
        ContentValues values = convertToContentValues(video, persistentChannel);
        values.put(SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID, video.getId());
        final long publishInstant = video.getPublishTimestamp();
        values.put(SubscriptionsVideosTable.COL_PUBLISH_TIME.name(), publishInstant);
        values.put(SubscriptionsVideosTable.COL_CATEGORY_ID.name(), video.getCategoryId());
        return values;
    }
    /**
     * Query the database to retrieve number of videos for subscribed channels starting from the given video.
     * @return a list of {@link YouTubeVideo}
     */
    public List<YouTubeVideo> getSubscriptionVideoPage(int limit, String videoId, long beforeTimestamp) {
        SkyTubeApp.nonUiThread();
        final String selection;
        final String sortingColumn = SubscriptionsVideosTable.COL_PUBLISH_TIME.name();
        final String[] selectionArguments;
        if (videoId != null) {
            selection = "WHERE (" + sortingColumn + " < ?) OR (" + sortingColumn + " = ? AND " + SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID + " > ?)";
            String formatted = String.valueOf(beforeTimestamp);
            selectionArguments = new String[]{ formatted, formatted, videoId };
        } else {
            selection = "";
            selectionArguments = null;
        }
        final String sorting = " ORDER BY " + sortingColumn + " DESC, " + SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID + " ASC limit "+ limit;
        String query = SubscriptionsVideosTable.BASE_QUERY + selection + sorting;
        try (Stopwatch s = new Stopwatch("getVideos " + query + ",limit=" + limit + ", beforeTimestamp=" + beforeTimestamp+" videoid="+videoId)) {
            Cursor cursor = getReadableDatabase().rawQuery(query, selectionArguments);
            return extractVideos(cursor, true);
        }
    }
    /**
     * Load YouTubeVideo objects from a cursor, only SubscriptionsVideosTable.COL_YOUTUBE_VIDEO column is needed.
     * @param cursor the cursor to process
     * @param fullColumnList get all the columns, not just the JSON blob - set to false only for db
     *                       maintenance queries!
     */
    private List<YouTubeVideo> extractVideos(Cursor cursor, boolean fullColumnList) {
        SkyTubeApp.nonUiThread();
        List<YouTubeVideo> videos = new ArrayList<>();
        Set<String> invalidIds = new HashSet<>();
        try {
            if (cursor.moveToNext()) {
                final int idIdx = cursor.getColumnIndex(SubscriptionsVideosTable.COL_YOUTUBE_VIDEO_ID);
                final int categoryIdx = cursor.getColumnIndex(SubscriptionsVideosTable.COL_CATEGORY_ID.name());
                final int publishTsIdx = fullColumnList ? SubscriptionsVideosTable.COL_PUBLISH_TIME.getColumn(cursor) : -1;
                final int publishTsExactIdx = SubscriptionsVideosTable.COL_PUBLISH_TIME_EXACT.getColumn(cursor);
                final int titleColumn = SubscriptionsVideosTable.COL_TITLE.getColumn(cursor);
                final int descriptionColumn = SubscriptionsVideosTable.COL_DESCRIPTION.getColumn(cursor);
                final int durationColumn = SubscriptionsVideosTable.COL_DURATION.getColumn(cursor);
                final int viewsColumn = SubscriptionsVideosTable.COL_VIEWS.getColumn(cursor);
                final int likesColumn = SubscriptionsVideosTable.COL_LIKES.getColumn(cursor);
                final int dislikesColumn = SubscriptionsVideosTable.COL_DISLIKES.getColumn(cursor);
                final int thumbnailUrlColumn = SubscriptionsVideosTable.COL_THUMBNAIL_URL.getColumn(cursor);
                final int channelTitleColumn = SubscriptionsVideosTable.COL_CHANNEL_TITLE.getColumn(cursor);
                final int channelIdColumn = SubscriptionsVideosTable.COL_CHANNEL_ID_V2.getColumn(cursor);
                do {
                    final String id = cursor.getString(idIdx);
                    // String id, String title, String description, long durationInSeconds,
                    //                            YouTubeChannel channel, long viewCount, Instant publishDate,
                    //                            boolean publishDateExact, String thumbnailUrl
                    YouTubeVideo video = new YouTubeVideo(id, cursor.getString(titleColumn), cursor.getString(descriptionColumn),
                            cursor.getLong(durationColumn),
                            new YouTubeChannel(cursor.getString(channelIdColumn), cursor.getString(channelTitleColumn)),
                            cursor.getLong(viewsColumn),  
                            Instant.ofEpochMilli(cursor.getLong(publishTsIdx)), 
                            cursor.getInt(publishTsExactIdx) > 0,
                            cursor.getString(thumbnailUrlColumn));
                    video.setLikeDislikeCount(cursor.getLong(likesColumn), cursor.getLong(dislikesColumn));
                    video.setPublishTimestamp(cursor.getLong(publishTsIdx));
                    video.setCategoryId(getInteger(cursor, categoryIdx));
                    video.updatePublishTimestampFromDate();
                    // regenerate the video's PublishDatePretty (e.g. 5 hours ago)
                    video.forceRefreshPublishDatePretty();
                    // add the video to the list
                    videos.add(video);
                } while (cursor.moveToNext());
            }
        } finally {
            cursor.close();
        }
        if (!invalidIds.isEmpty()) {
            Logger.e(this, "Found videos without channel: {}", invalidIds);
        }
        return videos;
    }
    public Maybe<PersistentChannel> getChannel(ChannelId channelId) {
        return Maybe.fromCallable(() -> getCachedChannel(channelId));
    }
	/**
	 *
	 * @param channelId
	 * @return all the information stored in the local cache about the channel.
	 */
	public PersistentChannel getCachedChannel(ChannelId channelId) {
        SkyTubeApp.nonUiThread();
        try (Cursor cursor = getReadableDatabase().rawQuery(
                "select s._id subs_id, c.* from  Channel c left outer Join Subs s on c.Channel_Id = s.Channel_Id where c.Channel_Id = ?",
                toArrayParam(channelId))) {
            if (cursor.moveToNext()) {
                Long subscriptionPk = SQLiteHelper.getOptionalLong(cursor, "subs_id");
                Long channelPk = SQLiteHelper.getLong(cursor, LocalChannelTable.COL_ID.name());
				String title = cursor.getString(cursor.getColumnIndexOrThrow(LocalChannelTable.COL_TITLE));
				String description = cursor.getString(cursor.getColumnIndexOrThrow(LocalChannelTable.COL_DESCRIPTION));
				String thumbnail = cursor.getString(cursor.getColumnIndexOrThrow(LocalChannelTable.COL_THUMBNAIL_NORMAL_URL));
				String banner = cursor.getString(cursor.getColumnIndexOrThrow(LocalChannelTable.COL_BANNER_URL));
                long subscriberCount = SQLiteHelper.getLong(cursor, LocalChannelTable.COL_SUBSCRIBER_COUNT);
                long lastCheckTs = SQLiteHelper.getLong(cursor, LocalChannelTable.COL_LAST_CHECK_TS);
                Status statusCode = getStatusCode(cursor);
                // TODO: use
                Long lastVideoTs = SQLiteHelper.getOptionalLong(cursor, LocalChannelTable.COL_LAST_VIDEO_TS);
                YouTubeChannel channel = new YouTubeChannel(channelId.getRawId(), title, description, thumbnail, banner, subscriberCount, subscriptionPk != null, -1, lastCheckTs, null, Collections.emptyList());
                return new PersistentChannel(channel, channelPk, subscriptionPk, statusCode);
            }
		}
		return null;
	}
    /**
     * Save channel informations in the database from the Object.
     *
     * @param channel which contains all the recent informations.
     * @return true, if the channel was inside the database.
     */
    public PersistentChannel cacheChannel(@Nullable PersistentChannel persistentChannel, YouTubeChannel channel) {
        SQLiteDatabase db = getWritableDatabase();
        return cacheChannel(db, persistentChannel, channel);
    }
    private Status getStatusCode(Cursor cursor) {
        return Status.lookup(SQLiteHelper.getLong(cursor, LocalChannelTable.COL_STATE.name()));
    }
    private String[] toArray(Object obj) {
        return new String[] { String.valueOf(obj)};
    }
    private String[] toArrayParam(ChannelId channelId) {
        return new String[] { channelId.getRawId() };
    }
    private @Nullable Long getChannelPk(SQLiteDatabase db, ChannelId channelId){
        try (Cursor cursor = db.rawQuery(GET_PK_FROM_CHANNEL_ID, toArrayParam(channelId))) {
            if (cursor.moveToNext()) {
                return cursor.getLong(0);
            }
        }
        return null;
    }
    private PersistentChannel cacheChannel(SQLiteDatabase db, @Nullable PersistentChannel persistentChannel, YouTubeChannel channel) {
        ContentValues values = toContentValues(channel);
        final Long channelPk;
        final Status status;
        if (persistentChannel != null) {
            channelPk = persistentChannel.channelPk();
            status = persistentChannel.status();
        } else {
            channelPk = getChannelPk(db, channel.getChannelId());
            status = Status.OK;
        }
        Long subPk = persistentChannel != null ? persistentChannel.subscriptionPk() : null;
        // If there is a persistentChannel info, we already have the channel in the db
        if (channelPk != null) {
            // Try to update it ...
            int count = db.update(
                    LocalChannelTable.TABLE_NAME,
                    values,
                    LocalChannelTable.COL_ID.name() + " = ?",
                    toArray(channelPk));
            if (count != 1) {
                throw new IllegalStateException("Unable to update channel " + channel + ", with pk= " + channelPk);
            }
            return new PersistentChannel(channel, channelPk, subPk, status);
        }
        values.put(LocalChannelTable.COL_CHANNEL_ID.name(), channel.getChannelId().getRawId());
        long newPk = db.insert(LocalChannelTable.TABLE_NAME, null, values);
        return new PersistentChannel(channel, newPk, subPk, status);
    }
    private static ContentValues toContentValues(YouTubeChannel channel) {
        ContentValues values = new ContentValues();
        values.put(LocalChannelTable.COL_TITLE, channel.getTitle());
        if (!Utils.isEmpty(channel.getDescription())) {
            values.put(LocalChannelTable.COL_DESCRIPTION, channel.getDescription());
        }
        if (!Utils.isEmpty(channel.getBannerUrl())) {
            values.put(LocalChannelTable.COL_BANNER_URL, channel.getBannerUrl());
        }
        if (!Utils.isEmpty(channel.getThumbnailUrl())) {
            values.put(LocalChannelTable.COL_THUMBNAIL_NORMAL_URL, channel.getThumbnailUrl());
        }
        if (channel.getSubscriberCount() > 0) {
            values.put(LocalChannelTable.COL_SUBSCRIBER_COUNT, channel.getSubscriberCount());
        }
        if(channel.getLastVideoTime() > 0) {
            values.put(LocalChannelTable.COL_LAST_VIDEO_TS, channel.getLastVideoTime());
        }
        if (channel.getLastCheckTime() > 0) {
            values.put(LocalChannelTable.COL_LAST_CHECK_TS, channel.getLastCheckTime());
        }
        return values;
    }
    public List<ChannelView> getSubscribedChannelsByText(String searchText, boolean sortChannelsAlphabetically) {
		List<ChannelView> result = new ArrayList<>();
		try (Cursor cursor = createSubscriptionCursor(searchText, sortChannelsAlphabetically); Stopwatch s = new Stopwatch("search for "+searchText)) {
			final int channelId = cursor.getColumnIndexOrThrow(SubscriptionsTable.COL_CHANNEL_ID);
			final int title = cursor.getColumnIndexOrThrow(LocalChannelTable.COL_TITLE);
			final int thumbnail = cursor.getColumnIndexOrThrow(LocalChannelTable.COL_THUMBNAIL_NORMAL_URL);
			final int colLastVisit = cursor.getColumnIndexOrThrow(SubscriptionsTable.COL_LAST_VISIT_TIME);
			final int colLatestVideoTs = cursor.getColumnIndexOrThrow("latest_video_ts");
            final int colStatus = cursor.getColumnIndexOrThrow(LocalChannelTable.COL_STATE.name());
			while(cursor.moveToNext()) {
				Long lastVisit = cursor.getLong(colLastVisit);
				Long latestVideoTs = cursor.getLong(colLatestVideoTs);
				boolean hasNew = (latestVideoTs != null && (lastVisit == null || latestVideoTs > lastVisit));
                Status status = Status.lookup(cursor.getInt(colStatus));
				result.add(new ChannelView(new ChannelId(cursor.getString(channelId)), cursor.getString(title), cursor.getString(thumbnail), hasNew, status));
			}
			return result;
		}
	}
    private Cursor createSubscriptionCursor(String searchText, boolean sortChannelsAlphabetically) {
        if (Utils.isEmpty(searchText)) {
            return getReadableDatabase().rawQuery(SUBSCRIBED_CHANNEL_INFO +
                    (sortChannelsAlphabetically ? SUBSCRIBED_CHANNEL_INFO_ORDER_BY : ""), null);
        } else {
            return getReadableDatabase().rawQuery(SUBSCRIBED_CHANNEL_INFO + SUBSCRIBED_CHANNEL_LIMIT_BY_TITLE +
                            (sortChannelsAlphabetically ? SUBSCRIBED_CHANNEL_INFO_ORDER_BY : ""),
                    new String[]{"%" + searchText.toLowerCase() + "%"});
        }
    }
}
/*
 * SkyTube
 * Copyright (C) 2020  Zsombor Gegesy
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.businessobjects.YouTube.POJOs;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.model.Status;
public class ChannelView {
    private final ChannelId id;
    private final String title;
    private final String thumbnailUrl;
    private boolean newVideosSinceLastVisit;
    private final Status status;
    public ChannelView(ChannelId id, String title, String thumbnailUrl, boolean newVideosSinceLastVisit, Status status) {
        this.id = id;
        this.title = title;
        this.thumbnailUrl = thumbnailUrl;
        this.newVideosSinceLastVisit = newVideosSinceLastVisit;
        this.status = status;
    }
    public ChannelId getId() {
        return id;
    }
    public String getTitle() {
        return title;
    }
    public String getThumbnailUrl() {
        return thumbnailUrl;
    }
    public boolean isNewVideosSinceLastVisit() {
        return newVideosSinceLastVisit;
    }
    public Status status() {
        return status;
    }
    public void setNewVideosSinceLastVisit(boolean newVideosSinceLastVisit) {
        this.newVideosSinceLastVisit = newVideosSinceLastVisit;
    }
}
/*
 * SkyTube
 * Copyright (C) 2023  Zsombor Gegesy
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.businessobjects.YouTube.newpipe;
import java.util.Objects;
import free.rm.skytube.app.Utils;
public class ChannelId {
    private final String id;
    public ChannelId(String id) {
        this.id = Utils.removeChannelIdPrefix(Objects.requireNonNull(id, "rawId is null"));
    }
    public String getRawId() {
        return id;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ChannelId channelId = (ChannelId) o;
        return Objects.equals(id, channelId.id);
    }
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
    @Override
    public String toString() {
        return "ChannelId{'" + id + '\'' + '}';
    }
    public String toURL() {
        return String.format("https://www.youtube.com/channel/%s", id);
    }
}
package free.rm.skytube.businessobjects.db;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.net.Uri;
import android.util.Log;
import android.widget.Toast;
import androidx.annotation.NonNull;
import com.github.skytube.components.utils.SQLiteHelper;
import com.google.gson.Gson;
import org.json.JSONException;
import org.json.JSONObject;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import free.rm.skytube.R;
import free.rm.skytube.app.Settings;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.AsyncTaskParallel;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.Sponsorblock.SBTasks;
import free.rm.skytube.businessobjects.Sponsorblock.SBVideoInfo;
import free.rm.skytube.businessobjects.YouTube.POJOs.CardData;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.newpipe.VideoId;
import free.rm.skytube.businessobjects.interfaces.OrderableDatabase;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.schedulers.Schedulers;
/**
 * A database (DB) that stores user's downloaded videos.
 */
public class DownloadedVideosDb extends CardEventEmitterDatabase implements OrderableDatabase {
    private final static String TAG = "DownloadedVideosDb";
    public static class Status {
        final Uri uri;
        final Uri audioUri;
        final boolean disappeared;
        final VideoId videoId;
        public Status(VideoId videoId,Uri uri, Uri audioUri, boolean disappeared) {
            this.uri = uri;
            this.audioUri = audioUri;
            this.disappeared = disappeared;
            this.videoId = videoId;
        }
        public Uri getUri() {
            return uri;
        }
        public File getLocalVideoFile() {
            if (uri != null) {
                return new File(uri.getPath());
            }
            return null;
        }
        public File getLocalAudioFile() {
            if (audioUri != null) {
                return new File(audioUri.getPath());
            }
            return null;
        }
        public File getParentFolder() {
            File localFile = getLocalVideoFile();
            if (localFile == null) {
                localFile = getLocalAudioFile();
            }
            return localFile != null ? localFile.getParentFile() : null;
        }
        public long getLocalSize() {
            File video = getLocalVideoFile();
            File audio = getLocalAudioFile();
            return (video != null ? video.length() : 0) + (audio != null ? audio.length() : 0);
        }
        public Uri getAudioUri() {
            return audioUri;
        }
        public boolean isDisappeared() {
            return disappeared;
        }
        @Override
        public String toString() {
            final StringBuilder sb = new StringBuilder("Status{");
            if (uri != null) {
                sb.append("uri=").append(uri);
            }
            if (audioUri != null) {
                sb.append(", audioUri=").append(audioUri);
            }
            sb.append(", disapeared=").append(disappeared);
            sb.append('}');
            return sb.toString();
        }
        public VideoId getVideoId() {
            return videoId;
        }
    }
    public static class FileDeletionFailed extends Exception {
        String path;
        FileDeletionFailed(String path) {
            super("File deletion failed for " + path);
            this.path = path;
        }
        public String getPath() {
            return path;
        }
    }
    private static volatile DownloadedVideosDb downloadsDb = null;
    private static boolean hasUpdated = false;
    private static final int DATABASE_VERSION = 3;
    private static final String DATABASE_NAME = "videodownloads.db";
    public static synchronized DownloadedVideosDb getVideoDownloadsDb() {
        if (downloadsDb == null) {
            downloadsDb = new DownloadedVideosDb(SkyTubeApp.getContext());
        }
        return downloadsDb;
    }
    private DownloadedVideosDb(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }
    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(DownloadedVideosTable.getCreateStatement());
    }
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        if (oldVersion == 1 && newVersion >= 2) {
            db.execSQL(DownloadedVideosTable.getAddAudioUriColumn());
        }
        if (oldVersion == 2 && newVersion >= 3) {
            db.execSQL(DownloadedVideosTable.getAddSponsorBlockColumn());
        }
    }
    /**
     * Get the list of Videos that have been downloaded.
     *
     * @return List of Videos
     */
    public List<YouTubeVideo> getDownloadedVideos() {
        SkyTubeApp.nonUiThread();
        return getDownloadedVideos(DownloadedVideosTable.COL_ORDER + " DESC");
    }
    /**
     * Get the list Statuses of Videos that have been downloaded.
     *
     * @return List of Status
     */
    public List<Status> getDownloadedVideosStatuses() {
        SkyTubeApp.nonUiThread();
        try (Cursor cursor = getReadableDatabase().query(
                DownloadedVideosTable.TABLE_NAME,
                new String[]{DownloadedVideosTable.COL_YOUTUBE_VIDEO_ID, DownloadedVideosTable.COL_FILE_URI, DownloadedVideosTable.COL_AUDIO_FILE_URI},
                null,
                null, null, null, null)) {
            List<Status> statuses = new ArrayList<>();
            while (cursor.moveToNext()) {
                String id = cursor.getString(cursor.getColumnIndex(DownloadedVideosTable.COL_YOUTUBE_VIDEO_ID));
                statuses.add(new Status(VideoId.create(id),
                        getUri(cursor, cursor.getColumnIndex(DownloadedVideosTable.COL_FILE_URI)),
                        getUri(cursor, cursor.getColumnIndex(DownloadedVideosTable.COL_AUDIO_FILE_URI)),
                        false));
            }
            return statuses;
        }
    }
    public SBVideoInfo getDownloadedVideoSponsorblock(String videoId) {
        SkyTubeApp.nonUiThread();
        try (Cursor cursor = getReadableDatabase().query(
                DownloadedVideosTable.TABLE_NAME,
                new String[]{DownloadedVideosTable.COL_SB},
                DownloadedVideosTable.COL_YOUTUBE_VIDEO_ID + " = ?",
                new String[]{videoId}, null, null, null)) {
            SBVideoInfo result = null;
            if (cursor.moveToNext()) {
                Gson gson = new Gson();
                do {
                    final byte[] sbBlob = cursor.getBlob(cursor.getColumnIndex(DownloadedVideosTable.COL_SB));
                    if (sbBlob == null) {
                        return null;
                    }
                    final String sbJson = new String(sbBlob);
                    result = gson.fromJson(sbJson, SBVideoInfo.class);
                } while (cursor.moveToNext());
            }
            return result;
        }
    }
    /**
     * Get the list of Videos that have been downloaded in the given order.
     *
     * @return List of Videos
     */
    private List<YouTubeVideo> getDownloadedVideos(String ordering) {
        try (Cursor cursor = getReadableDatabase().query(
                DownloadedVideosTable.TABLE_NAME,
                new String[]{DownloadedVideosTable.COL_YOUTUBE_VIDEO, DownloadedVideosTable.COL_FILE_URI},
                null,
                null, null, null, ordering)) {
            List<YouTubeVideo> videos = new ArrayList<>();
            if (cursor.moveToNext()) {
                Gson gson = new Gson();
                do {
                    final byte[] blob = cursor.getBlob(cursor.getColumnIndex(DownloadedVideosTable.COL_YOUTUBE_VIDEO));
                    final String videoJson = new String(blob);
                    // convert JSON into YouTubeVideo
                    YouTubeVideo video = gson.fromJson(videoJson, YouTubeVideo.class).updatePublishTimestampFromDate();
                    // due to upgrade to YouTubeVideo (by changing channel{Id,Name} to YouTubeChannel)
                    // from version 2.82 to 2.90
                    if (video.getChannel() == null) {
                        try {
                            JSONObject videoJsonObj = new JSONObject(videoJson);
                            final String channelId = videoJsonObj.get("channelId").toString();
                            final String channelName = videoJsonObj.get("channelName").toString();
                            video.setChannel(new YouTubeChannel(channelId, channelName));
                        } catch (JSONException e) {
                            Logger.e(this, "Error occurred while extracting channel{Id,Name} from JSON", e);
                        }
                    }
                    video.forceRefreshPublishDatePretty();
                    videos.add(video);
                } while (cursor.moveToNext());
            }
            return videos;
        }
    }
    public Single<Boolean> add(YouTubeVideo video, Uri fileUri, Uri audioUri) {
        return Single.fromCallable(() -> {
                    Gson gson = new Gson();
                    ContentValues values = new ContentValues();
                    values.put(DownloadedVideosTable.COL_YOUTUBE_VIDEO_ID, video.getId());
                    values.put(DownloadedVideosTable.COL_YOUTUBE_VIDEO, gson.toJson(video).getBytes());
                    if (fileUri != null) {
                        values.put(DownloadedVideosTable.COL_FILE_URI, fileUri.toString());
                    }
                    if (audioUri != null) {
                        values.put(DownloadedVideosTable.COL_AUDIO_FILE_URI, audioUri.toString());
                    }
                    if (SkyTubeApp.getSettings().isSponsorblockEnabled()) {
                        SBVideoInfo sbInfo = SBTasks.retrieveSponsorblockSegmentsBk(video.getVideoId());
                        values.put(DownloadedVideosTable.COL_SB, gson.toJson(sbInfo).getBytes());
                    }
                    int order = getMaximumOrderNumber();
                    order++;
                    values.put(DownloadedVideosTable.COL_ORDER, order);
                    return getWritableDatabase().replace(DownloadedVideosTable.TABLE_NAME, null, values) != -1;
                }).subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSuccess(success -> {
                    if (success) {
                        notifyCardAdded(video);
                    }
                });
    }
    /**
     * Remove the filenames of the downloaded video from the database
     *
     * @param videoId
     * @return
     */
    private boolean remove(String videoId) {
        int rowsDeleted = getWritableDatabase().delete(DownloadedVideosTable.TABLE_NAME,
                DownloadedVideosTable.COL_YOUTUBE_VIDEO_ID + " = ?",
                new String[]{videoId});
        onUpdated();
        return (rowsDeleted >= 0);
    }
    /**
     * Remove local copy of this video, and delete it from the VideoDownloads DB.
     *
     * @return
     */
    public @NonNull
    Single<Status> removeDownload(Context ctx, VideoId videoId) {
        return Single.fromCallable(() -> {
                    SkyTubeApp.nonUiThread();
                    Status status = getVideoFileStatus(videoId);
                    Log.i(TAG, "removeDownload for " + videoId + " -> " + status);
                    if (status != null) {
                        deleteIfExists(status.getLocalAudioFile());
                        deleteIfExists(status.getLocalVideoFile());
                        remove(videoId.getId());
                        final Settings settings = SkyTubeApp.getSettings();
                        if (settings.isDownloadToSeparateFolders()) {
                            removeParentFolderIfEmpty(status, settings.getDownloadParentFolder());
                        }
                    }
                    return status;
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSuccess(status -> {
                    SkyTubeApp.uiThread();
                    notifyCardDeleted(videoId);
                })
                .doOnError(exception -> {
                    displayGenericError(ctx, exception);
                });
    }
    private void removeParentFolderIfEmpty(Status file, File downloadParentFolder) {
        File parentFile = file.getParentFolder();
        Log.i(TAG, "removeParentFolderIfEmpty " + parentFile.getAbsolutePath() + " " + parentFile.exists() + " " + parentFile.isDirectory());
        if (parentFile.exists() && parentFile.isDirectory()) {
            if (parentFile.getParentFile().getAbsolutePath().equals(downloadParentFolder.getAbsolutePath())) {
                String[] fileList = parentFile.list();
                Log.i(TAG, "file list is " + Arrays.asList(fileList) + " under " + parentFile.getAbsolutePath());
                if (fileList != null) {
                    if (fileList.length == 0) {
                        // that was the last file in the directory, remove it
                        Log.i(TAG, "now delete it:" + parentFile);
                        parentFile.delete();
                    }
                }
            } else {
                Log.w(TAG, "Download parent folder is " + downloadParentFolder.getAbsolutePath() +
                        " but the file is stored under " + parentFile.getParentFile().getAbsolutePath());
            }
        }
        Log.i(TAG, "exit removeParentFolderIfEmpty");
    }
    /**
     * Returns whether or not the video has been downloaded.
     *
     * @return True if the video was previously saved by the user.
     */
    public Single<Boolean> isVideoDownloaded(@NonNull YouTubeVideo video) {
        return isVideoDownloaded(video.getVideoId());
    }
    /**
     * Returns whether or not the video with the given ID has been downloaded.
     *
     * @return True if the video was previously saved by the user.
     */
    public Single<Boolean> isVideoDownloaded(VideoId video) {
        return Single.fromCallable(() -> {
                    SkyTubeApp.nonUiThread();
                    try (Cursor cursor = getReadableDatabase().query(
                            DownloadedVideosTable.TABLE_NAME,
                            new String[]{DownloadedVideosTable.COL_FILE_URI},
                            DownloadedVideosTable.COL_YOUTUBE_VIDEO_ID + " = ?",
                            new String[]{video.getId()}, null, null, null)) {
                        boolean isDownloaded = false;
                        if (cursor.moveToNext()) {
                            String uri = cursor.getString(cursor.getColumnIndex(DownloadedVideosTable.COL_FILE_URI));
                            isDownloaded = uri != null;
                        }
                        return isDownloaded;
                    }
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread());
    }
    private Status getVideoFileStatus(VideoId videoId) {
        try (Cursor cursor = getReadableDatabase().query(
                DownloadedVideosTable.TABLE_NAME,
                new String[]{DownloadedVideosTable.COL_FILE_URI, DownloadedVideosTable.COL_AUDIO_FILE_URI},
                DownloadedVideosTable.COL_YOUTUBE_VIDEO_ID + " = ?",
                new String[]{videoId.getId()}, null, null, null)) {
            if (cursor.moveToNext()) {
                return new Status(videoId,
                        getUri(cursor, cursor.getColumnIndex(DownloadedVideosTable.COL_FILE_URI)),
                        getUri(cursor, cursor.getColumnIndex(DownloadedVideosTable.COL_AUDIO_FILE_URI)),
                        false);
            }
            return null;
        }
    }
    private Uri getUri(Cursor cursor, int columnIndex) {
        String uri = cursor.getString(columnIndex);
        if (uri != null) {
            return Uri.parse(uri);
        } else {
            return null;
        }
    }
    /**
     * Return a locally saved file URI for the given video, the call ensures, that the file exists currently
     *
     * @param videoId the id of the video
     * @return the status, never null
     */
    private @NonNull
    Single<Status> getVideoFileUriAndValidate(@NonNull VideoId videoId) {
        return Single.fromCallable(() -> {
                    Status downloadStatus = getVideoFileStatus(videoId);
                    if (downloadStatus != null) {
                        File localVideo = downloadStatus.getLocalVideoFile();
                        if (localVideo != null) {
                            if (!localVideo.exists()) {
                                deleteIfExists(downloadStatus.getLocalAudioFile());
                                remove(videoId.getId());
                                return new Status(videoId, null, null, true);
                            }
                        }
                        File localAudio = downloadStatus.getLocalAudioFile();
                        if (localAudio != null) {
                            if (!localAudio.exists()) {
                                deleteIfExists(downloadStatus.getLocalVideoFile());
                                remove(videoId.getId());
                                return new Status(videoId, null, null, true);
                            }
                        }
                        return downloadStatus;
                    }
                    return new Status(videoId, null, null, false);
                }).subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread());
    }
    /**
     * Get the Uri for the local copy of this Video, if the file is missing, or incorrect state, it tries to cleanup,
     * and notifies the user about that error
     *
     * @return Status object - never null
     */
    public @NonNull
    Single<Status> getDownloadedFileStatus(Context context, @NonNull VideoId videoId) {
        return getVideoFileUriAndValidate(videoId).onErrorReturn(error -> {
            displayGenericError(context, error);
            return new Status(videoId, null, null, true);
        });
    }
    private void displayGenericError(Context context, Throwable exception) {
        if (exception instanceof FileDeletionFailed) {
            displayError(context, (FileDeletionFailed) exception);
        } else {
            Log.e(TAG, "Exception : " + exception.getMessage(), exception);
        }
    }
    private void displayError(Context context, DownloadedVideosDb.FileDeletionFailed fileDeletionFailed) {
        Logger.e(this, "Unable to delete file : %s", fileDeletionFailed.getPath());
        Toast.makeText(context, context.getString(R.string.unable_to_delete_file, fileDeletionFailed.getPath()), Toast.LENGTH_LONG).show();
    }
    private void deleteIfExists(File file) throws FileDeletionFailed {
        if (file != null && file.exists()) {
            Log.i(TAG, "File exists " + file.getAbsolutePath());
            if (!file.delete()) {
                throw new FileDeletionFailed(file.getAbsolutePath());
            }
        }
    }
    private synchronized void onUpdated() {
    }
    /**
     * When a Video in the Downloads tab is drag & dropped to a new position, this will be
     * called with the new updated list of videos. Since the videos are displayed in descending order,
     * the first video in the list will have the highest number.
     *
     * @param videos List of Videos to update their order.
     */
    @Override
    public void updateOrder(List<CardData> videos) {
        int order = videos.size();
        for (CardData video : videos) {
            ContentValues cv = new ContentValues();
            cv.put(DownloadedVideosTable.COL_ORDER, order--);
            getWritableDatabase().update(DownloadedVideosTable.TABLE_NAME, cv, DownloadedVideosTable.COL_YOUTUBE_VIDEO_ID + " = ?", new String[]{video.getId()});
        }
    }
    /**
     * @return The total number of bookmarked videos.
     */
    public Single<Integer> getTotalCount() {
        return Single.fromCallable(() ->
                SQLiteHelper.executeQueryForInteger(getReadableDatabase(), DownloadedVideosTable.COUNT_ALL, 0)
        ).subscribeOn(Schedulers.io());
    }
    /**
     * @return The maximum of the order number - which could be different from the number of downloaded files, in case some of them are deleted.
     */
    private int getMaximumOrderNumber() {
        try (Cursor cursor = getReadableDatabase().rawQuery(DownloadedVideosTable.MAXIMUM_ORDER_QUERY, null)) {
            int totalDownloads = 0;
            if (cursor.moveToFirst()) {
                totalDownloads = cursor.getInt(0);
            }
            return totalDownloads;
        }
    }
    /**
     * AsyncTask to remove any videos from the Database whose local files have gone missing.
     */
    public static class RemoveMissingVideosTask extends AsyncTaskParallel<Void, Void, Void> {
        @Override
        protected Void doInBackground(Void... voids) {
            try (Cursor cursor = getVideoDownloadsDb().getReadableDatabase().query(
                    DownloadedVideosTable.TABLE_NAME,
                    new String[]{DownloadedVideosTable.COL_YOUTUBE_VIDEO_ID, DownloadedVideosTable.COL_FILE_URI},
                    null,
                    null, null, null, null)) {
                if (cursor.moveToNext()) {
                    do {
                        String videoId = cursor.getString(cursor.getColumnIndex(DownloadedVideosTable.COL_YOUTUBE_VIDEO_ID));
                        Uri uri = Uri.parse(cursor.getString(cursor.getColumnIndex(DownloadedVideosTable.COL_FILE_URI)));
                        File file = new File(uri.getPath());
                        if (!file.exists()) {
                            getVideoDownloadsDb().remove(videoId);
                        }
                    } while (cursor.moveToNext());
                }
                return null;
            }
        }
    }
}
/*
 * SkyTube
 * Copyright (C) 2018  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.businessobjects.YouTube.POJOs;
import android.app.DownloadManager;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Environment;
import android.view.Menu;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.core.content.FileProvider;
import com.google.api.services.youtube.model.Channel;
import com.google.api.services.youtube.model.Thumbnail;
import com.google.api.services.youtube.model.Video;
import com.google.api.services.youtube.model.VideoSnippet;
import com.google.api.services.youtube.model.VideoStatistics;
import org.ocpsoft.prettytime.PrettyTime;
import org.schabi.newpipe.extractor.stream.Stream;
import org.schabi.newpipe.extractor.stream.StreamInfo;
import org.schabi.newpipe.extractor.stream.VideoStream;
import java.io.File;
import java.io.Serializable;
import java.math.BigInteger;
import java.time.Duration;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.util.Locale;
import free.rm.skytube.BuildConfig;
import free.rm.skytube.R;
import free.rm.skytube.app.Settings;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.app.StreamSelectionPolicy;
import free.rm.skytube.businessobjects.FileDownloader;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.YouTubeTasks;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeUtils;
import free.rm.skytube.businessobjects.YouTube.newpipe.VideoId;
import free.rm.skytube.businessobjects.db.BookmarksDb;
import free.rm.skytube.businessobjects.db.DatabaseResult;
import free.rm.skytube.businessobjects.db.DownloadedVideosDb;
import free.rm.skytube.businessobjects.interfaces.GetDesiredStreamListener;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Single;
import static free.rm.skytube.app.SkyTubeApp.getContext;
import static free.rm.skytube.app.SkyTubeApp.getStr;
/**
 * Represents a YouTube video.
 */
public class YouTubeVideo extends CardData implements Serializable {
	/**
	 * Channel (only id and name are set).
	 */
	private YouTubeChannel channel;
	/**
	 * The total number of 'likes'.
	 */
	private Long likeCountNumber;
	/**
	 * The total number of 'dislikes'.
	 */
	private Long dislikeCountNumber;
	/**
	 * The percentage of people that thumbs-up this video.
	 */
	private int thumbsUpPercentage;
	/**
	 * Video duration string (e.g. "5:15").
	 */
	private String duration;
	/**
	 *  Video duration in seconds
	 */
	private int durationInSeconds = -1;
	/**
	 * Total views count.  This can be <b>null</b> if the video does not allow the user to
	 * like/dislike it.  Format:  "<number> Views"
	 */
	private String viewsCount;
	/**
	 * Total views count.
	 */
	private BigInteger viewsCountInt;
	/**
	 * The date/time of when this video was published.
	 */
	private transient ZonedDateTime publishDate;
	/**
	 * Thumbnail URL (maximum resolution).
	 */
	private String thumbnailMaxResUrl;
	/**
	 * The language of this video.  (This tends to be ISO 639-1).
	 */
	private String language;
	/**
	 * Set to true if the video is a current live stream.
	 */
	private boolean isLiveStream;
	private Integer categoryId;
	/**
	 * Constructor.
	 */
	public YouTubeVideo(Video video) throws IllegalArgumentException {
		this.id = video.getId();
		VideoSnippet snippet = video.getSnippet();
		if (snippet == null) {
			throw new IllegalArgumentException("Missing snippet in "+video);
		}
		this.title = snippet.getTitle();
		this.channel = new YouTubeChannel(snippet.getChannelId(), snippet.getChannelTitle());
		setPublishTimestamp(snippet.getPublishedAt().getValue());
		setPublishTimestampExact(true);
		if (snippet.getThumbnails() != null) {
			Thumbnail thumbnail = snippet.getThumbnails().getHigh();
			if (thumbnail != null) {
				this.thumbnailUrl = thumbnail.getUrl();
			}
			thumbnail = snippet.getThumbnails().getMaxres();
			if (thumbnail != null) {
				this.thumbnailMaxResUrl = thumbnail.getUrl();
			}
		}
		this.language = snippet.getDefaultAudioLanguage() != null ? snippet.getDefaultAudioLanguage()
				: (snippet.getDefaultLanguage());
		this.description = snippet.getDescription();
		if (video.getContentDetails() != null) {
			setDuration(video.getContentDetails().getDuration());
			setIsLiveStream();
			setDurationInSeconds(video.getContentDetails().getDuration());
		}
		VideoStatistics statistics = video.getStatistics();
		if (statistics != null) {
			setLikeDislikeCount(statistics.getLikeCount() != null ? statistics.getLikeCount().longValue() : null, statistics.getDislikeCount() != null ? statistics.getDislikeCount().longValue() : null);
			setViewCount(statistics.getViewCount());
		}
	}
	public void setCategoryId(Integer categoryId) {
		this.categoryId = categoryId;
	}
	public Integer getCategoryId() {
		return categoryId;
	}
	public void setViewCount(BigInteger viewsCountInt) {
		this.viewsCountInt = viewsCountInt;
		this.viewsCount = String.format(getStr(R.string.views), viewsCountInt);
	}
        public YouTubeVideo(String id, String title, String description, long durationInSeconds,
							YouTubeChannel channel, long viewCount, Instant publishDate,
							boolean publishDateExact, String thumbnailUrl) {
            this.id = id;
            this.title = title;
            this.description = description;
            setDurationInSeconds((int) durationInSeconds);
            if (viewCount >= 0) {
                setViewCount(BigInteger.valueOf(viewCount));
            }
            if (publishDate != null) {
                setPublishTimestamp(publishDate.toEpochMilli());
            }
            setPublishTimestampExact(publishDateExact);
            this.thumbnailMaxResUrl = thumbnailUrl;
            this.thumbnailUrl = thumbnailUrl;
            this.channel = channel;
            this.thumbsUpPercentage = -1;
        }
        public VideoId getVideoId() {
            // TODO: this should be created by the NewPipe backend
            return new VideoId(id, getVideoUrl(), null);
        }
	/**
	 * Sets the {@link #thumbsUpPercentage}, i.e. the percentage of people that thumbs-up this video
	 * (format:  "<percentage>%").
	 *
	 * @param likedCountInt	Total number of "likes".
	 * @param dislikedCountInt Total number of "dislikes".
	 */
	public void setLikeDislikeCount(Long likedCountInt, Long dislikedCountInt) {
		this.thumbsUpPercentage = -1;
		// Logger.d(this, "setLikeDislikeCount "+likedCountInt+" "+dislikedCountInt +" -> "+likeCountNumber+" "+dislikeCountNumber);
		final Long likes = filterNegative(likedCountInt);
		final Long dislikes = filterNegative(dislikedCountInt);
		// some videos do not allow users to like/dislike them:  hence likedCountInt / dislikedCountInt
		// might be null in those cases
		if (likes != null && dislikes != null) {
			long likedCount = likes;
			long dislikedCount = dislikes;
			long totalVoteCount = likedCount + dislikedCount;	// liked and disliked counts
			if (totalVoteCount != 0) {
				this.thumbsUpPercentage = (int) Math.round((double)likedCount*100/totalVoteCount);
			}
		}
		this.likeCountNumber = likes;
		this.dislikeCountNumber = dislikes;
	}
	private static Long filterNegative(Long value) {
		if (value != null && value.longValue() < 0) {
			return null;
		}
		return value;
	}
	/**
	 * Using {@link #duration} it detects if the video/stream is live or not.
	 * <p>
	 * <p>If it is live, then it will change {@link #duration} to "LIVE" and modify {@link #publishDate}
	 * to current time (which will appear as "moments ago" when using {@link PrettyTime}).</p>
	 */
	private void setIsLiveStream() {
		// is live stream?
		if (duration.equals("0:00")) {
			isLiveStream = true;
			duration = getStr(R.string.LIVE);
			// set publishDate to current (as there is a bug in YouTube API in which live videos's date is incorrect)
			setPublishTimestamp(Instant.now().toEpochMilli());
		} else {
			isLiveStream = false;
		}
	}
	public YouTubeChannel getChannel() {
		return channel;
	}
	public void setChannel(YouTubeChannel channel) {
		this.channel = channel;
	}
    public String getSafeChannelId() {
        return channel != null ? channel.getChannelId().getRawId() : null;
    }
    public String getSafeChannelName() {
        return channel != null ? channel.getTitle() : null;
    }
	public ChannelId getChannelId() {
		return channel.getChannelId();
	}
	public String getChannelName() {
		return channel.getTitle();
	}
	/**
	 * @return True if the video allows the users to like/dislike it.
	 */
	public boolean isThumbsUpPercentageSet() {
		return (thumbsUpPercentage >= 0);
	}
	/**
	 * @return The thumbs up percentage (as an integer).  Can return <b>-1</b> if the video does not
	 * allow the users to like/dislike it.  Refer to {@link #isThumbsUpPercentageSet}.
	 */
	public int getThumbsUpPercentage() {
		return thumbsUpPercentage;
	}
	/**
	 * @return The thumbs up percentage (format:  "«percentage»%").  Can return <b>null</b> if the
	 * video does not allow the users to like/dislike it.  Refer to {@link #isThumbsUpPercentageSet}.
	 */
	public String getThumbsUpPercentageStr() {
		// round the liked percentage to 0 decimal places and convert it to string
		return thumbsUpPercentage >= 0 ? thumbsUpPercentage + "%" : null;
	}
	/**
	 * @return The total number of 'likes'.  Can return <b>null</b> if the video does not allow the
	 * users to like/dislike it.  Refer to {@link #isThumbsUpPercentageSet}.
	 */
	public String getLikeCount() {
		if (likeCountNumber != null) {
			return String.format(Locale.getDefault(), "%,d", likeCountNumber);
		}
		return null;
	}
	/**
	 * @return The total number of 'likes'.  Can return <b>null</b> for videos serialized with only a 'string' like count.
	 */
	public Long getLikeCountNumber() {
		return likeCountNumber;
	}
	/**
	 * @return The total number of 'dislikes'.  Can return <b>null</b> if the video does not allow the
	 * users to like/dislike it.  Refer to {@link #isThumbsUpPercentageSet}.
	 */
	public String getDislikeCount() {
		if (dislikeCountNumber != null) {
			return String.format(Locale.getDefault(), "%,d", dislikeCountNumber);
		}
		return null;
	}
	/**
	 * @return The total number of 'dislikes'.  Can return <b>null</b> for videos serialized with only a 'string' like count.
	 */
	public Long getDislikeCountNumber() {
		return dislikeCountNumber;
	}
	public String getDuration() {
		return duration;
	}
	public int getDurationInSeconds() {
		return durationInSeconds;
	}
	/**
	 * Sets the {@link #duration} by converts ISO 8601 duration to human readable string.
	 *
	 * @param duration ISO 8601 duration.
	 */
	private void setDuration(String duration) {
		this.duration = VideoDuration.toHumanReadableString(duration);
	}
	public String getViewsCount() {
		return viewsCount;
	}
	public BigInteger getViewsCountInt() {
		return viewsCountInt;
	}
	/*
	 * Sets the {@link #durationInSeconds}
	 * @param durationInSeconds The duration in seconds.
	 */
	public void setDurationInSeconds(String durationInSeconds) {
		this.durationInSeconds = (int) Duration.parse(durationInSeconds).toMillis() / 1000;
	}
	public void setDurationInSeconds(int durationInSeconds) {
		this.durationInSeconds = durationInSeconds;
		this.duration = VideoDuration.toHumanReadableString(durationInSeconds);
	}
	/**
	 * Update the {@link #publishTimestamp} from {@link #publishDate} if the former is not set, just the later.
	 * Useful when deserialized from json.
	 * @return self.
	 */
	public YouTubeVideo updatePublishTimestampFromDate() {
		if (this.publishTimestamp == null) {
			if (this.publishDate != null) {
				setPublishTimestamp(this.publishDate.toInstant().toEpochMilli());
			}
		}
		return this;
	}
	public String getThumbnailMaxResUrl() {
		return thumbnailMaxResUrl;
	}
	public String getVideoUrl() {
		return String.format("https://youtu.be/%s", id);
	}
	public String getLanguage() {
		return language;
	}
	public boolean isLiveStream() {
		return isLiveStream;
	}
    public Single<Boolean> bookmarkVideo(Context context) {
        return bookmarkVideo(context, null);
    }
    public Single<Boolean> bookmarkVideo(Context context, Menu menu) {
        return BookmarksDb.getBookmarksDb().bookmarkAsync(this)
                .map(result -> {
                    Toast.makeText(context,
                            getBookmarkMessage(result),
                            Toast.LENGTH_LONG).show();
                    if (result.isPositive() && menu != null) {
                        menu.findItem(R.id.bookmark_video).setVisible(false);
                        menu.findItem(R.id.unbookmark_video).setVisible(true);
                    }
                    return result.isPositive();
        });
    }
	static int getBookmarkMessage(@NonNull DatabaseResult result) {
		switch (result) {
			case ERROR: return R.string.video_bookmarked_error;
			case NOT_MODIFIED: return R.string.video_already_bookmarked;
			case SUCCESS: return R.string.video_bookmarked;
		}
		throw new IllegalStateException("Result "+ result);
	}
	static int getUnBookmarkMessage(@NonNull DatabaseResult result) {
		switch (result) {
			case ERROR: return R.string.video_unbookmarked_error;
			case NOT_MODIFIED: return R.string.video_was_not_bookmarked;
			case SUCCESS: return R.string.video_unbookmarked;
		}
		throw new IllegalStateException("Result "+ result);
	}
    public Single<Boolean> unbookmarkVideo(Context context, Menu menu) {
        return BookmarksDb.getBookmarksDb().unbookmarkAsync(getVideoId())
                .map(result -> {
                    Toast.makeText(context,
                            getUnBookmarkMessage(result),
                            Toast.LENGTH_LONG).show();
                    if (result.isPositive() && menu != null) {
                        menu.findItem(R.id.bookmark_video).setVisible(true);
                        menu.findItem(R.id.unbookmark_video).setVisible(false);
                    }
                    return result.isPositive();
                });
    }
	public void shareVideo(Context context) {
		SkyTubeApp.shareUrl(context, getVideoUrl());
	}
	public void copyUrl(Context context) {
		SkyTubeApp.copyUrl(context, "Video URL", getVideoUrl());
	}
	public void updateFromStreamInfo(StreamInfo streamInfo) {
		final Long like = filterNegative(streamInfo.getLikeCount());
		final Long dislike = filterNegative(streamInfo.getDislikeCount());
		this.setLikeDislikeCount(like != null ? like : likeCountNumber, dislike != null ? dislike : dislikeCountNumber);
		final Long views = filterNegative(streamInfo.getViewCount());
		if (views != null) {
			this.setViewCount(BigInteger.valueOf(views));
		}
		this.setDescription(NewPipeUtils.filterHtml(streamInfo.getDescription()));
	}
	/**
	 * Downloads this video.
	 *
	 * @return The download task.
	 * @param context Context
	 */
	public Completable downloadVideo(final Context context) {
		return DownloadedVideosDb.getVideoDownloadsDb().isVideoDownloaded(YouTubeVideo.this.getVideoId())
				.flatMapCompletable((downloadedVideo) -> {
			if (downloadedVideo) {
				return Completable.complete();
			} else {
				return YouTubeTasks.getDesiredStream(this, new GetDesiredStreamListener() {
					@Override
					public void onGetDesiredStream(StreamInfo streamInfo, YouTubeVideo video) {
						final Settings settings = SkyTubeApp.getSettings();
						StreamSelectionPolicy selectionPolicy = settings.getDesiredVideoResolution(true);
						StreamSelectionPolicy.StreamSelection streamSelection = selectionPolicy.select(streamInfo);
						if (streamSelection != null) {
							VideoStream videoStream = streamSelection.getVideoStream();
							// download the video
							downloadTheVideo(videoStream, settings);
						} else {
							Toast.makeText(context, selectionPolicy.getErrorMessage(context), Toast.LENGTH_LONG).show();
						}
					}
					private void downloadTheVideo(Stream stream, Settings settings) {
						new VideoDownloader()
								.setRemoteFileUrl(stream.getUrl())
								.setDirType(Environment.DIRECTORY_MOVIES)
								.setTitle(getTitle())
								.setDescription(getStr(R.string.video) + " ― " + getChannelName())
								.setOutputFileName(getId() + " - " + getTitle())
								.setOutputDirectoryName(getChannelName())
								.setParentDirectory(settings.getDownloadParentFolder())
								.setOutputFileExtension(stream.getFormat().suffix)
								.setAllowedOverRoaming(false)
								.setAllowedNetworkTypesFlags(DownloadManager.Request.NETWORK_WIFI | DownloadManager.Request.NETWORK_MOBILE)
								.displayPermissionsActivity(context);
					}
					@Override
					public void onGetDesiredStreamError(Throwable throwable) {
						Logger.e(YouTubeVideo.this, "Stream error: " + throwable.getMessage(), throwable);
						Context context = getContext();
						Toast.makeText(context,
								String.format(context.getString(R.string.video_download_stream_error), getTitle()),
								Toast.LENGTH_LONG).show();
					}
				});
			}
		});
	}
	/**
	 * Play the video using an external app
	 */
	public Single<DownloadedVideosDb.Status> playVideoExternally(Context context) {
		return DownloadedVideosDb.getVideoDownloadsDb().getDownloadedFileStatus(context, getVideoId()).map(fileStatus -> {
			if (fileStatus.getLocalVideoFile() != null) {
				Uri uri;
				File file = fileStatus.getLocalVideoFile();
				try {
					uri = FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID + ".provider", file);
				} catch (Exception e) {
					Logger.e(YouTubeVideo.this, "Error accessing path: " + file + ", message:" + e.getMessage(), e);
					uri = fileStatus.getUri();
				}
				Intent intent = new Intent(Intent.ACTION_VIEW, uri);
				intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
				context.startActivity(intent);
			} else {
				Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(getVideoUrl()));
				context.startActivity(browserIntent);
			}
			return fileStatus;
		});
	}
	////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Downloads a YouTube video.
	 */
	private class VideoDownloader extends FileDownloader implements Serializable {
		@Override
		public void onFileDownloadStarted() {
			Toast.makeText(getContext(),
					String.format(getContext().getString(R.string.starting_video_download), getTitle()),
					Toast.LENGTH_LONG).show();
		}
        @Override
        public void onFileDownloadCompleted(boolean success, Uri localFileUri) {
            if (success) {
                DownloadedVideosDb.getVideoDownloadsDb().add(YouTubeVideo.this, localFileUri, null)
                    .doOnSuccess(saveSucceeded -> {
                        showToast(saveSucceeded);
                    }).doOnError(err -> {
                        SkyTubeApp.notifyUserOnError(getContext(), err);
                    }).subscribe();
            } else {
                showToast(false);
            }
        }
        private void showToast(boolean success) {
            Toast.makeText(getContext(),
                    String.format(getContext().getString(success ? R.string.video_downloaded : R.string.video_download_stream_error), getTitle()),
                    Toast.LENGTH_LONG).show();
        }
        @Override
        public void onDownloadStartFailed(String downloadName, final RuntimeException runtimeException) {
            Toast.makeText(getContext(),
                    String.format(getContext().getString(R.string.download_failed_because), downloadName, runtimeException.getMessage()),
                    Toast.LENGTH_LONG).show();
        }
        @Override
        public void onExternalStorageNotAvailable() {
            Toast.makeText(getContext(),
                    R.string.external_storage_not_available,
                    Toast.LENGTH_LONG).show();
        }
    }
}
package free.rm.skytube.businessobjects.db;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import androidx.annotation.NonNull;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.CardData;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.interfaces.VideoPlayStatusUpdateListener;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.disposables.Disposable;
import io.reactivex.rxjava3.schedulers.Schedulers;
/**
 * A database (DB) that stores video playback history
 */
public class PlaybackStatusDb extends SQLiteOpenHelperEx {
	private static volatile PlaybackStatusDb playbackStatusDb = null;
	private static HashMap<String, VideoWatchedStatus> playbackHistoryMap = null;
	private static final int DATABASE_VERSION = 1;
	private int updateCounter = 0;
	private static final String DATABASE_NAME = "playbackhistory.db";
	private final Set<VideoPlayStatusUpdateListener> listeners = new HashSet<>();
	public static synchronized PlaybackStatusDb getPlaybackStatusDb() {
		if (playbackStatusDb == null) {
			playbackStatusDb = new PlaybackStatusDb(SkyTubeApp.getContext());
		}
		return playbackStatusDb;
	}
	private PlaybackStatusDb(Context context) {
		super(context, DATABASE_NAME, null, DATABASE_VERSION);
	}
	public void deleteAllPlaybackHistory() {
		getWritableDatabase().delete(PlaybackStatusTable.TABLE_NAME, null, null);
		playbackHistoryMap = null;
		updateCounter++;
		onUpdated(null);
	}
	@Override
	public void onCreate(SQLiteDatabase db) {
		db.execSQL(PlaybackStatusTable.getCreateStatement());
	}
	@Override
	public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {
	}
	/**
	 * Get the watched status of the passed {@link YouTubeVideo}. Instead of always querying the database, a HashMap
	 * is constructed that stores the watch status of all videos (that have a status). Subsequent calls to this method
	 * will return the watch status for the passed video from this HashMap (which also gets updated by calls to setWatchedStatus().
	 *
	 * @param videoId {@link YouTubeVideo}
	 * @return {@link VideoWatchedStatus} of the passed video, which contains the position (in ms) and whether or not the video
	 * 					has been (completely) watched.
	 */
	public synchronized VideoWatchedStatus getVideoWatchedStatus(@NonNull String videoId) {
		if(playbackHistoryMap == null) {
            try (Cursor cursor = getReadableDatabase().query(
                    PlaybackStatusTable.TABLE_NAME,
                    new String[]{PlaybackStatusTable.COL_YOUTUBE_VIDEO_ID, PlaybackStatusTable.COL_YOUTUBE_VIDEO_POSITION, PlaybackStatusTable.COL_YOUTUBE_VIDEO_WATCHED},
                    null,
                    null, null, null, null)) {
                playbackHistoryMap = new HashMap<>();
                final int videoIdIdx = cursor.getColumnIndexOrThrow(PlaybackStatusTable.COL_YOUTUBE_VIDEO_ID);
                final int positionIdx = cursor.getColumnIndexOrThrow(PlaybackStatusTable.COL_YOUTUBE_VIDEO_POSITION);
                final int finishedIdx = cursor.getColumnIndexOrThrow(PlaybackStatusTable.COL_YOUTUBE_VIDEO_WATCHED);
                while (cursor.moveToNext()) {
                    String video_id = cursor.getString(videoIdIdx);
                    int position = cursor.getInt(positionIdx);
                    int finished = cursor.getInt(finishedIdx);
                    VideoWatchedStatus status = new VideoWatchedStatus(position, finished == 1);
                    playbackHistoryMap.put(video_id, status);
                }
            }
		}
		if(playbackHistoryMap.get(videoId) == null) {
			// Requested video has no entry in the database, so create one in the Map. No need to create it in the Database yet - if needed,
			// that will happen when video position is set
			VideoWatchedStatus status = new VideoWatchedStatus();
			playbackHistoryMap.put(videoId, status);
		}
		return playbackHistoryMap.get(videoId);
	}
    public Maybe<VideoWatchedStatus> getVideoWatchedStatusAsync(@NonNull String videoId) {
        return Maybe.fromCallable(() -> getVideoWatchedStatus(videoId))
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread());
    }
	/**
	 * Set the position (in ms) of the passed {@link YouTubeVideo}. If the position is less than 5 seconds,
	 * don't do anything. If the position is greater than or equal to 90% of the duration of the video, set
	 * the position to 0 and mark the video as watched.
	 *
	 * @param video {@link YouTubeVideo}
	 * @param position Number of milliseconds
	 * @return Disposable which contains the background task.
	 */
	public Disposable setVideoPositionInBackground(YouTubeVideo video, long position) {
		// Don't record the position if it's < 5 seconds
		if (SkyTubeApp.getSettings().isPlaybackStatusEnabled() && position >= 5000) {
			boolean watched = false;
			// If the user has stopped watching the video and the position is greater than 90% of the duration, mark the video as watched and reset position
			if((float)position / (video.getDurationInSeconds()*1000) >= 0.9) {
				watched = true;
				position = 0;
			}
			final long positionValue = position;
			final boolean watchedValue = watched;
			return Single.fromCallable(() -> saveVideoWatchStatus(video.getId(), positionValue, watchedValue))
					.subscribeOn(Schedulers.io())
					.observeOn(AndroidSchedulers.mainThread())
					.subscribe((success) -> {
						Logger.i(this, "onUpdated " + success);
						if (success) {
							onUpdated(video);
						}
					});
		} else {
			return Disposable.empty();
		}
	}
	/**
	 * Set the watched status of the passed {@link YouTubeVideo}. Regardless of watched status, set the
	 * position to 0.
	 *
	 * @param video {@link YouTubeVideo}
	 * @param watched boolean on whether or not the passed video has been watched
	 * @return boolean on whether the database was updated successfully.
	 */
	public Maybe<Boolean> setVideoWatchedStatusInBackground(YouTubeVideo video, boolean watched) {
		if (SkyTubeApp.getSettings().isPlaybackStatusEnabled()) {
			return Maybe.fromCallable(() -> saveVideoWatchStatus(video.getId(), 0, watched))
					.subscribeOn(Schedulers.io())
					.observeOn(AndroidSchedulers.mainThread())
					.doOnSuccess((success) -> {
						Logger.i(this, "onUpdated " + success);
                        if (success) {
                            onUpdated(video);
                        }
					});
		} else {
			return Maybe.empty();
		}
	}
	private boolean saveVideoWatchStatus(String videoId, long position, boolean watched) {
		ContentValues values = new ContentValues();
		values.put(PlaybackStatusTable.COL_YOUTUBE_VIDEO_ID, videoId);
		values.put(PlaybackStatusTable.COL_YOUTUBE_VIDEO_POSITION, (int)position);
		values.put(PlaybackStatusTable.COL_YOUTUBE_VIDEO_WATCHED, watched ? 1 : 0);
		boolean addSuccessful = getWritableDatabase().insertWithOnConflict(PlaybackStatusTable.TABLE_NAME, null, values, SQLiteDatabase.CONFLICT_REPLACE) != -1;
		if(addSuccessful) {
			updateCounter++;
		}
		VideoWatchedStatus status = playbackHistoryMap.get(videoId);
		if (status == null) {
			status = new VideoWatchedStatus();
			playbackHistoryMap.put(videoId, status);
		}
		status.position = position;
		status.watched = watched;
		return addSuccessful;
	}
    private void onUpdated(CardData cardData) {
        for(VideoPlayStatusUpdateListener listener : listeners) {
            listener.onVideoStatusUpdated(cardData);
        }
    }
	/**
	 * Class that contains the position and watched status of a video.
	 */
	public static class VideoWatchedStatus {
		public VideoWatchedStatus() {}
		public VideoWatchedStatus(long position, boolean watched) {
			this.position = position;
			this.watched = watched;
		}
		@Override
		public String toString() {
			return String.format("Position: %d\nWatched: %s\n", position, watched);
		}
		private long position = 0;
		private boolean watched = false;
		public boolean isFullyWatched() {
			return watched;
		}
		public boolean isWatched() {
			return position > 0 || watched;
		}
		public long getPosition() {
			return position;
		}
	}
	/**
	 * Return the number of updates happened to the playback status
	 * If it different than the VideoGrid has, it needs to be refreshed.
	 *
	 * @return int updateCounter
	 */
	public int getUpdateCounter() {
		return updateCounter;
	}
	public void addListener(VideoPlayStatusUpdateListener listener) {
		listeners.add(listener);
	}
	public void removeListener(VideoPlayStatusUpdateListener listener) {
		listeners.remove(listener);
	}
}
/*
 * SkyTube
 * Copyright (C) 2019  Zsombor Gegesy
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.businessobjects.YouTube.newpipe;
import android.util.Log;
import androidx.annotation.NonNull;
import com.github.skytube.components.httpclient.OkHttpDownloader;
import org.json.JSONException;
import org.json.JSONObject;
import org.schabi.newpipe.extractor.NewPipe;
import org.schabi.newpipe.extractor.ServiceList;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.channel.ChannelExtractor;
import org.schabi.newpipe.extractor.channel.tabs.ChannelTabExtractor;
import org.schabi.newpipe.extractor.channel.tabs.ChannelTabs;
import org.schabi.newpipe.extractor.comments.CommentsExtractor;
import org.schabi.newpipe.extractor.downloader.Response;
import org.schabi.newpipe.extractor.exceptions.ExtractionException;
import org.schabi.newpipe.extractor.exceptions.ParsingException;
import org.schabi.newpipe.extractor.exceptions.ReCaptchaException;
import org.schabi.newpipe.extractor.feed.FeedExtractor;
import org.schabi.newpipe.extractor.kiosk.KioskExtractor;
import org.schabi.newpipe.extractor.kiosk.KioskList;
import org.schabi.newpipe.extractor.linkhandler.LinkHandler;
import org.schabi.newpipe.extractor.linkhandler.LinkHandlerFactory;
import org.schabi.newpipe.extractor.linkhandler.ListLinkHandler;
import org.schabi.newpipe.extractor.linkhandler.ListLinkHandlerFactory;
import org.schabi.newpipe.extractor.localization.ContentCountry;
import org.schabi.newpipe.extractor.localization.DateWrapper;
import org.schabi.newpipe.extractor.localization.Localization;
import org.schabi.newpipe.extractor.playlist.PlaylistExtractor;
import org.schabi.newpipe.extractor.search.SearchExtractor;
import org.schabi.newpipe.extractor.stream.StreamExtractor;
import org.schabi.newpipe.extractor.stream.StreamInfo;
import org.schabi.newpipe.extractor.subscription.SubscriptionExtractor;
import org.schabi.newpipe.extractor.utils.Utils;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import free.rm.skytube.BuildConfig;
import free.rm.skytube.app.Settings;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
/**
 * Service to interact with remote video services, using the NewPipeExtractor backend.
 */
public class NewPipeService {
    // TODO: remove this singleton
    private static NewPipeService instance;
    private final StreamingService streamingService;
    private final Settings settings;
    final static boolean DEBUG_LOG = false;
    static class ChannelWithExtractor {
        final YouTubeChannel channel;
        final ChannelExtractor extractor;
        ChannelWithExtractor(YouTubeChannel channel, ChannelExtractor extractor) {
            this.channel = channel;
            this.extractor = extractor;
        }
        ListLinkHandler findListLinkHandler(String name) throws ParsingException {
            // it's a bit overcomplicated
            return extractor.getTabs().stream()
                .filter(linkHandler -> {
                    List<String> filters = linkHandler.getContentFilters();
                    return filters != null && filters.contains(name);
                }).findAny().orElse(null);
        }
        ChannelTabExtractor findChannelTab(String name) throws ParsingException {
            ListLinkHandler listLinkHandler = findListLinkHandler(name);
            if(listLinkHandler != null) {
                try {
                    return instance.streamingService.getChannelTabExtractor(listLinkHandler);
                } catch (ExtractionException e) {
                    Logger.e(instance, "findChannelTab (" + name + ") : " + listLinkHandler + ", err:" + e.getMessage(), e);
                    return null;
                }
            }
            return null;
        }
        ChannelTabExtractor findVideosTab() throws ParsingException {
            return findChannelTab(ChannelTabs.VIDEOS);
        }
        ChannelTabExtractor findPlaylistTab() throws ParsingException {
            return findChannelTab(ChannelTabs.PLAYLISTS);
        }
    }
    @FunctionalInterface
    interface ParserCall<X> {
        X get() throws ParsingException;
    }
    public NewPipeService(StreamingService streamingService, Settings settings) {
        this.streamingService = streamingService;
        this.settings = settings;
    }
    /**
     * Returns a list of video/stream meta-data that is supported by this app.
     *
     * @return The {@link StreamInfo}.
     */
    private StreamInfo getStreamInfoByUrl(String videoUrl) throws IOException, ExtractionException {
        // actual extraction
        return StreamInfo.getInfo(streamingService, videoUrl);
    }
    public ContentId getVideoId(String url) throws ParsingException {
        if (url == null) {
            return null;
        }
        return parse(streamingService.getStreamLHFactory(), url, StreamingService.LinkType.STREAM);
    }
    public ContentId getContentId(String url) {
        if (url == null) {
            return null;
        }
        ContentId id;
        id = parse(streamingService.getStreamLHFactory(), url, StreamingService.LinkType.STREAM);
        if (id != null) {
            return id;
        }
        id = parse(streamingService.getChannelLHFactory(), url, StreamingService.LinkType.CHANNEL);
        if (id != null) {
            return id;
        }
        id = parse(streamingService.getPlaylistLHFactory(), url, StreamingService.LinkType.PLAYLIST);
        return id;
    }
    private ContentId parse(LinkHandlerFactory handlerFactory, String url, StreamingService.LinkType type) {
        if (handlerFactory != null) {
            try {
                String id = handlerFactory.getId(url);
                String canonicalUrl = handlerFactory.getUrl(id);
                if (type == StreamingService.LinkType.STREAM) {
                    return new VideoId(id, canonicalUrl, parseTimeStamp(url));
                } else {
                    return new ContentId(id, handlerFactory.getUrl(id), type);
                }
            } catch (ParsingException pe) {
                return null;
            }
        }
        return null;
    }
    private Integer parseTimeStamp(String url) {
        try {
            String time = Utils.getQueryValue(new URL(url), "t");
            if (time != null) {
                return Integer.parseInt(time);
            }
        } catch (MalformedURLException|NumberFormatException e) {
        }
        return null;
    }
    /**
     * Returns a list of video/stream meta-data that is supported by this app for this video ID.
     *
     * @param videoId the id of the video.
     * @return List of {@link StreamInfo}.
     */
    public StreamInfo getStreamInfoByVideoId(String videoId) throws ExtractionException, IOException {
        return getStreamInfoByUrl(getVideoUrl(videoId));
    }
    /**
     * Return the most recent videos for the given channel
     * @param channelId the id of the channel
     * @return list of recent {@link YouTubeVideo}.
     * @throws ExtractionException
     * @throws IOException
     */
    private List<YouTubeVideo> getChannelVideos(ChannelId channelId) throws NewPipeException {
        SkyTubeApp.nonUiThread();
        VideoPagerWithChannel pager = getChannelPager(channelId);
        List<YouTubeVideo> result = pager.getNextPageAsVideosAndUpdateChannel(null).channel().getYouTubeVideos();
        Logger.i(this, "getChannelVideos for %s(%s)  -> %s videos", pager.getChannel().getTitle(), channelId, result.size());
        return result;
    }
    /**
     * Return the most recent videos for the given channel from a dedicated feed (with a {@link FeedExtractor}).
     * @param channelId the id of the channel
     * @return list of recent {@link YouTubeVideo}, or null, if there is no feed.
     * @throws ExtractionException
     * @throws IOException
     */
    private List<YouTubeVideo> getFeedVideos(String channelId) throws ExtractionException, IOException, NewPipeException {
        SkyTubeApp.nonUiThread();
        final String url = getListLinkHandler(channelId).getUrl();
        final FeedExtractor feedExtractor = streamingService.getFeedExtractor(url);
        if (feedExtractor == null) {
            Logger.i(this, "getFeedExtractor doesn't return anything for %s -> %s", channelId, url);
            return null;
        }
        feedExtractor.fetchPage();
        return new VideoPagerWithChannel(streamingService, feedExtractor, createInternalChannelFromFeed(feedExtractor)).getNextPageAsVideos();
    }
    /**
     * Return the most recent videos for the given channel, either from a dedicated feed (with a {@link FeedExtractor} or from
     * the generic {@link ChannelExtractor}.
     * @param channelId the id of the channel
     * @return list of recent {@link YouTubeVideo}.
     * @throws ExtractionException
     * @throws IOException
     */
    public List<YouTubeVideo> getVideosFromFeedOrFromChannel(ChannelId channelId) throws NewPipeException {
        try {
            SkyTubeApp.nonUiThread();
            List<YouTubeVideo> videos = getFeedVideos(channelId.getRawId());
            if (videos != null) {
                return videos;
            }
        } catch (IOException | ExtractionException | RuntimeException | NewPipeException e) {
            Logger.e(this, "Unable to get videos from a feed " + channelId + " : "+ e.getMessage(), e);
        }
        return getChannelVideos(channelId);
    }
    public VideoPager getTrending() throws NewPipeException {
        try {
            KioskList kiosks = streamingService.getKioskList();
            KioskExtractor kex = kiosks.getDefaultKioskExtractor();
            kex.fetchPage();
            return new VideoPager(streamingService, kex);
        } catch (ExtractionException | IOException e) {
            throw new NewPipeException("Unable to get 'trending' list:" + e.getMessage(), e);
        }
    }
    public VideoPagerWithChannel getChannelPager(ChannelId channelId) throws NewPipeException {
        try {
            Logger.e(this, "fetching channel info: "+ channelId);
            ChannelWithExtractor channelExtractor = getChannelWithExtractor(channelId);
            return new VideoPagerWithChannel(streamingService, channelExtractor.findVideosTab(), channelExtractor.channel);
        } catch (ParsingException | RuntimeException e) {
            throw new NewPipeException("Getting videos for " + channelId + " fails:" + e.getMessage(), e);
        }
    }
    public ChannelWithExtractor getChannelWithExtractor(ChannelId channelId) throws NewPipeException {
        try {
            ChannelExtractor channelExtractor = getChannelExtractor(channelId);
            YouTubeChannel channel = createInternalChannel(channelExtractor);
            return new ChannelWithExtractor(channel, channelExtractor);
        } catch (ExtractionException | IOException | RuntimeException e) {
            throw new NewPipeException("Getting playlists for " + channelId + " fails:" + e.getMessage(), e);
        }
    }
    public PlaylistPager getPlaylistPager(String playlistId) throws NewPipeException {
        try {
            ListLinkHandler playlistLinkHandler = getPlaylistHandler(playlistId);
            PlaylistExtractor playlistExtractor = streamingService.getPlaylistExtractor(playlistLinkHandler);
            playlistExtractor.fetchPage();
            return new PlaylistPager(streamingService, playlistExtractor);
        } catch (ExtractionException | IOException | RuntimeException e) {
            throw new NewPipeException("Getting playlists for " + playlistId + " fails:" + e.getMessage(), e);
        }
    }
    public CommentPager getCommentPager(String videoId) throws NewPipeException {
        try {
            final ListLinkHandler linkHandler = streamingService.getCommentsLHFactory().fromId(videoId);
            final CommentsExtractor commentsExtractor = streamingService.getCommentsExtractor(linkHandler);
            return new CommentPager(streamingService, commentsExtractor);
        } catch (ExtractionException | RuntimeException | IOException e) {
            throw new NewPipeException("Getting comments for " + videoId + " fails:" + e.getMessage(), e);
        }
    }
    /**
     * Return detailed, fresh information for a channel from it's id.
     * @param persistentChannel
     * @return the {@link YouTubeChannel}, with a list of recent videos.
     * @throws ExtractionException
     * @throws IOException
     */
    public PersistentChannel getChannelDetails(ChannelId channelId, PersistentChannel persistentChannel) throws NewPipeException {
        Logger.i(this, "Fetching channel details for " + channelId);
        VideoPagerWithChannel pager = getChannelPager(channelId);
        // get the channel, and add all the videos from the first page
        try {
            return pager.getNextPageAsVideosAndUpdateChannel(persistentChannel);
        } catch (NewPipeException e) {
            Logger.e(this, "Unable to retrieve videos for "+channelId+", error: "+e.getMessage(), e);
            throw e;
        }
    }
    private YouTubeChannel createInternalChannelFromFeed(FeedExtractor extractor) throws ParsingException {
        return new YouTubeChannel(extractor.getId(), extractor.getName(), null,
                null, null, -1, false, 0, System.currentTimeMillis(), null, Collections.emptyList());
    }
    private YouTubeChannel createInternalChannel(ChannelExtractor extractor) throws ParsingException {
        return new YouTubeChannel(
                extractor.getId(),
                extractor.getName(),
                NewPipeUtils.filterHtml(extractor.getDescription()),
                callParser(() -> NewPipeUtils.getThumbnailUrl(extractor.getAvatars()), null),
                callParser(() -> NewPipeUtils.getThumbnailUrl(extractor.getBanners()), null),
                callParser(() -> extractor.getSubscriberCount(), -1L),
                false,
                0,
                System.currentTimeMillis(),
                null,
                extractor.getTags());
    }
    private <X> X callParser(ParserCall<X> parser, X defaultValue) {
        try {
            return parser.get();
        } catch (NullPointerException | ParsingException e) {
            Logger.e(this, "Unable to parse: " + parser + ", error: " + e.getMessage(), e);
            return defaultValue;
        }
    }
    private ChannelExtractor getChannelExtractor(ChannelId channelId)
            throws ExtractionException, IOException {
        // Extract from it
        ChannelExtractor channelExtractor = streamingService
                .getChannelExtractor(getListLinkHandler(Objects.requireNonNull(channelId, "channelId").getRawId()));
        channelExtractor.fetchPage();
        return channelExtractor;
    }
    private ListLinkHandler getListLinkHandler(String channelId) throws ParsingException {
        // Get channel LinkHandler, handle three cases:
        // 1, channelId=UCbx1TZgxfIauUZyPuBzEwZg
        // 2, channelId=https://www.youtube.com/channel/UCbx1TZgxfIauUZyPuBzEwZg
        // 3, channelId=channel/UCbx1TZgxfIauUZyPuBzEwZg
        ListLinkHandlerFactory channelLHFactory = streamingService.getChannelLHFactory();
        try {
            return channelLHFactory.fromUrl(channelId);
        } catch (ParsingException p) {
            if (DEBUG_LOG) {
                Logger.d(this, "Unable to parse channel url=%s", channelId);
            }
        }
        if (channelId.startsWith("channel/") || channelId.startsWith("c/") || channelId.startsWith("user/")) {
            return channelLHFactory.fromId(channelId);
        }
        return channelLHFactory.fromId("channel/" + channelId);
    }
    private ListLinkHandler getPlaylistHandler(String playlistId) throws ParsingException {
        ListLinkHandlerFactory factory = streamingService.getPlaylistLHFactory();
        try {
            return factory.fromUrl(playlistId);
        } catch (Exception parsingException) {
            Logger.i(instance, "PlaylistId '"+playlistId+"' is not an url:"+ parsingException.getMessage());
            return factory.fromId(playlistId);
        }
    }
    /**
     * Return detailed information about a video from it's id.
     * @param videoId the id of the video.
     * @return a {@link YouTubeVideo}
     * @throws ExtractionException
     * @throws IOException
     */
    public YouTubeVideo getDetails(String videoId) throws ExtractionException, IOException {
        SkyTubeApp.nonUiThread();
        LinkHandler url = streamingService.getStreamLHFactory().fromId(videoId);
        StreamExtractor extractor = streamingService.getStreamExtractor(url);
        extractor.fetchPage();
        DateInfo uploadDate = new DateInfo(extractor.getUploadDate());
        Logger.i(this, "getDetails for %s -> %s %s", videoId, url.getUrl(), uploadDate);
        long viewCount;
        try {
            viewCount = extractor.getViewCount();
        } catch (NumberFormatException|ParsingException e) {
            Logger.e(this, "Unable to get view count for " + url.getUrl()+", error: "+e.getMessage(), e);
            viewCount = 0;
        }
        YouTubeVideo video = new YouTubeVideo(extractor.getId(), extractor.getName(), NewPipeUtils.filterHtml(extractor.getDescription()),
                extractor.getLength(), new YouTubeChannel(extractor.getUploaderUrl(), extractor.getUploaderName()),
                viewCount, uploadDate.instant, uploadDate.exact, NewPipeUtils.getThumbnailUrl(extractor.getThumbnails()));
        try {
            video.setLikeDislikeCount(extractor.getLikeCount(), getDislikeCount(extractor, videoId));
        } catch (ParsingException pe) {
            Logger.e(this, "Unable get like count for " + url.getUrl() + ", created at " + uploadDate + ", error:" + pe.getMessage(), pe);
            video.setLikeDislikeCount(null, null);
        }
        return video;
    }
    private Long getDislikeCount(StreamExtractor extractor, String id) {
        try {
            long dislikeCount = extractor.getDislikeCount();
            if (dislikeCount >= 0) {
                return dislikeCount;
            }
        } catch (ParsingException e) {
            Logger.e(this, "Unable get dislike count for " + extractor.getLinkHandler().getUrl() + ", error:" + e.getMessage(), e);
        }
        return getDislikeCountFromApi(id);
    }
    public Long getDislikeCountFromApi(String videoId)  {
        if (settings.isUseDislikeApi()) {
            // send the request
            String url = "https://returnyoutubedislikeapi.com/votes?videoId=" + videoId;
            try {
                Logger.i(this, "fetching dislike count for "+ url);
                OkHttpDownloader downloader = OkHttpDownloader.getInstance();
                Response response = downloader.get(url);
                // get the response
                int responseCode = response.responseCode();
                if (responseCode != 200) {
                    Logger.e(this, "ResponseCode " + responseCode + " for " + url);
                    return null;
                }
                JSONObject jsonObject = new JSONObject(response.responseBody());
                Logger.i(this, "for "+ url +" -> "+jsonObject);
                return jsonObject.getLong("dislikes");
            } catch (IOException | JSONException | ReCaptchaException e) {
                Logger.e(this, "getDislikeCount: error: " + e.getMessage() + " for url:" + url, e);
            }
        } else {
            Logger.i(this, "Like fetching disabled for " + videoId);
        }
        return null;
    }
    static class DateInfo {
        boolean exact;
        Instant instant;
        public DateInfo(DateWrapper uploadDate) {
            if (uploadDate != null) {
                instant = uploadDate.offsetDateTime().toInstant();
                exact = !uploadDate.isApproximation();
            } else {
                instant = null;
                exact = false;
            }
        }
        private static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        @NonNull
        @Override
        public String toString() {
            try {
                return "[time= " + dtf.format(instant) + ",exact=" + exact + ']';
            } catch (Exception e){
                return "[incorrect time= " + instant + " ,exact=" + exact + ']';
            }
        }
    }
    static String getThumbnailUrl(String id) {
        // Logger.d(NewPipeService.class, "getThumbnailUrl  %s", id);
        return "https://i.ytimg.com/vi/" + id + "/hqdefault.jpg";
    }
    public VideoPager getSearchResult(String query) throws NewPipeException {
        SkyTubeApp.nonUiThread();
        try {
            SearchExtractor extractor = streamingService.getSearchExtractor(query);
            extractor.fetchPage();
            return new VideoPager(streamingService, extractor);
        } catch (ExtractionException | IOException | RuntimeException e) {
            throw new NewPipeException("Getting search result for " + query + " fails:" + e.getMessage(), e);
        }
    }
    /**
     * Given video ID it will return the video's page URL.
     *
     * @param videoId       The ID of the video.
     * @throws ParsingException 
     */
    private String getVideoUrl(String videoId) throws ParsingException {
        return streamingService.getStreamLHFactory().getUrl(videoId);
    }
    public synchronized static NewPipeService get() {
        if (instance == null) {
            getHttpDownloader();
            instance = new NewPipeService(ServiceList.YouTube, SkyTubeApp.getSettings());
        }
        return instance;
    }
    public SubscriptionExtractor createSubscriptionExtractor() {
        return streamingService.getSubscriptionExtractor();
    }
    /**
     * Initialize NewPipe with a custom HttpDownloader.
     */
    public static OkHttpDownloader getHttpDownloader() {
        OkHttpDownloader downloader = OkHttpDownloader.getInstance();
        downloader.setApiUserAgent("SkyTube-Android-" + BuildConfig.VERSION_CODE);
        if (NewPipe.getDownloader() == null) {
            NewPipe.init(downloader, Localization.DEFAULT, toContentCountry(SkyTubeApp.getSettings().getPreferredContentCountry()));
        }
        return downloader;
    }
    private static ContentCountry toContentCountry(String countryCode){
        if (countryCode == null || countryCode.isEmpty()) {
            return ContentCountry.DEFAULT;
        } else {
            return new ContentCountry(countryCode);
        }
    }
    public static void setCountry(String countryCodeStr) {
        getHttpDownloader();
        final ContentCountry contentCountry = toContentCountry(countryCodeStr);
        Log.i("NewPipeService", "set preferred content country to " + contentCountry);
        NewPipe.setPreferredContentCountry(contentCountry);
    }
}/*
 * SkyTube
 * Copyright (C) 2018  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.businessobjects.YouTube;
import com.google.common.base.Optional;
import com.optimaize.langdetect.DetectedLanguage;
import com.optimaize.langdetect.LanguageDetector;
import com.optimaize.langdetect.LanguageDetectorBuilder;
import com.optimaize.langdetect.i18n.LdLocale;
import com.optimaize.langdetect.ngram.NgramExtractors;
import com.optimaize.langdetect.profiles.LanguageProfile;
import com.optimaize.langdetect.profiles.LanguageProfileReader;
import com.optimaize.langdetect.text.CommonTextObjectFactories;
import com.optimaize.langdetect.text.TextObject;
import com.optimaize.langdetect.text.TextObjectFactory;
import java.io.IOException;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import free.rm.skytube.R;
import free.rm.skytube.app.Settings;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.CardData;
import free.rm.skytube.businessobjects.YouTube.POJOs.ChannelView;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.db.ChannelFilteringDb;
import static free.rm.skytube.app.SkyTubeApp.getStr;
/**
 * Filters videos base on constraints set by the user.
 */
public class VideoBlocker {
	/** Listener that will be called once a video is blocked. */
	private static volatile VideoBlockerListener videoBlockerListener = null;
	/** Default preferred language(s) -- by default, no language shall be filtered out. */
	private static final Set<String> defaultPrefLanguages = new HashSet<>(SkyTubeApp.getStringArrayAsList(R.array.languages_iso639_codes));
	private final Settings settings;
	public VideoBlocker() {
		settings = SkyTubeApp.getSettings();
	}
	/**
	 * Sets the {@link VideoBlockerListener}.
	 */
	public static void setVideoBlockerListener(VideoBlockerListener listener) {
		videoBlockerListener = listener;
	}
	/**
	 * Filters videos base on constraints set by the user.
	 *
	 * @param videosList    Videos list to be filtered.
	 *
	 * @return  A list of valid videos that fit the user's criteria.
	 */
	public List<CardData> filter(List<CardData> videosList) {
		// if the video blocker is disabled, then do not filter any videos
		if (!isVideoBlockerEnabled()) {
			return videosList;
		}
		List<CardData>      filteredVideosList    = new ArrayList<>();
		final boolean       isChannelBlacklistEnabled = settings.isChannelDenyListEnabled();
		final List<ChannelId>  blacklistedChannelIds = isChannelBlacklistEnabled  ? ChannelFilteringDb.getChannelFilteringDb().getDeniedChannelsIdsList() : null;
		final List<ChannelId>  whitelistedChannelIds = !isChannelBlacklistEnabled ? ChannelFilteringDb.getChannelFilteringDb().getAllowedChannelsIdsList() : null;
		// set of user's preferred ISO 639 language codes (regex)
		final Set<String>   preferredLanguages    = SkyTubeApp.getPreferenceManager().getStringSet(getStr(R.string.pref_key_preferred_languages), defaultPrefLanguages);
		final BigInteger    minimumVideoViews     = getViewsFilteringValue();
		final int           minimumVideoDislikes  = getDislikesFilteringValue();
		for (CardData cardData : videosList) {
			if (cardData instanceof YouTubeVideo) {
				YouTubeVideo video = (YouTubeVideo) cardData;
				if (!((isChannelBlacklistEnabled && filterByBlacklistedChannels(video, blacklistedChannelIds))
						|| (!isChannelBlacklistEnabled && filterByWhitelistedChannels(video, whitelistedChannelIds))
						|| filterByLanguage(video, preferredLanguages)
						|| filterByLanguageDetection(video, preferredLanguages)
						|| filterByViews(video, minimumVideoViews)
						|| filterByDislikes(video, minimumVideoDislikes))) {
					filteredVideosList.add(video);
				}
			} else {
				filteredVideosList.add(cardData);
			}
		}
		return filteredVideosList;
	}
	/**
	 * @return True if the user wants to use the video blocker, false otherwise.
	 */
	private boolean isVideoBlockerEnabled() {
		return settings.isEnableVideoBlocker();
	}
	/**
	 * Filter channels base on constraints set by the user.  Used by the SubsAdapter and hence the
	 * user will not be informed if a channel has been hidden in the SubsAdapter.
	 *
	 * @param channels  Channels list to be filtered.
	 *
	 * @return A list of valid channels that fit the user's criteria.
	 */
	public List<ChannelView> filterChannels(List<ChannelView> channels) {
		List<ChannelView>       filteredChannels    = new ArrayList<>();
		final boolean           isChannelBlacklistEnabled = settings.isChannelDenyListEnabled();
		if (!isChannelBlacklistEnabled) {
			return channels;
		}
		final List<ChannelId>      blacklistedChannelIds = isChannelBlacklistEnabled  ? ChannelFilteringDb.getChannelFilteringDb().getDeniedChannelsIdsList() : null;
		final List<ChannelId>      whitelistedChannelIds = !isChannelBlacklistEnabled ? ChannelFilteringDb.getChannelFilteringDb().getAllowedChannelsIdsList() : null;
		for (ChannelView channel : channels) {
			if ( !(isChannelBlacklistEnabled ? filterByBlacklistedChannels(channel.getId(), blacklistedChannelIds)
					: filterByWhitelistedChannels(channel.getId(), whitelistedChannelIds)) ) {
				filteredChannels.add(channel);
			}
		}
		return filteredChannels;
	}
	/**
	 * Log filtered videos and calls the VideoBlockerListener.
	 *
	 * @param video         Video being filtered.
	 * @param filteringType Criteria (why being filtered - e.g. channel blocked).
	 * @param reason        The criteria hit (e.g. ID of the channel blocked).
	 */
	private void log(YouTubeVideo video, FilterType filteringType, String reason) {
		// log the filtering event
		Logger.i(this, "\uD83D\uDED1 VIDEO='%s'  |  FILTER='%s'  |  REASON='%s'", video.getTitle(), filteringType, reason);
		if (videoBlockerListener != null) {
			videoBlockerListener.onVideoBlocked(new BlockedVideo(video, filteringType, reason));
		}
	}
	/**
	 * Filter the video for blacklisted channels.
	 *
	 * @param video                 Video to be checked.
	 * @param blacklistedChannelIds Blacklisted channels IDs.
	 *
	 * @return True if the video is to be filtered; false otherwise.
	 */
	private boolean filterByBlacklistedChannels(YouTubeVideo video, List<ChannelId> blacklistedChannelIds) {
		if (filterByBlacklistedChannels(video.getChannelId(), blacklistedChannelIds)) {
			log(video, FilterType.CHANNEL_BLACKLIST, video.getChannelName());
			return true;
		} else {
			return false;
		}
	}
	/**
	 * Filter the channel for blacklisted channels.
	 *
	 * @param channelId             Id of the channel to be checked.
	 * @param blacklistedChannelIds Blacklisted channels IDs.
	 *
	 * @return True if the channel is to be filtered; false otherwise.
	 */
	private boolean filterByBlacklistedChannels(ChannelId channelId, List<ChannelId> blacklistedChannelIds) {
		return blacklistedChannelIds.contains(channelId);
	}
	/**
	 * Filter the video for whitelisted channels.
	 *
	 * @param video                 Video to be checked.
	 * @param whitelistedChannelIds Whitelisted channels IDs.
	 *
	 * @return True if the video is to be filtered; false otherwise.
	 */
	private boolean filterByWhitelistedChannels(YouTubeVideo video, List<ChannelId> whitelistedChannelIds) {
		if (filterByWhitelistedChannels(video.getChannelId(), whitelistedChannelIds)) {
			log(video, FilterType.CHANNEL_WHITELIST, video.getChannelName());
			return true;
		} else {
			return false;
		}
	}
	/**
	 * Filter the channel for whitelisted channels.
	 *
	 * @param channelId             Id of the channel to be checked.
	 * @param whitelistedChannelIds Whitelisted channels IDs.
	 *
	 * @return True if the channel is to be filtered; false otherwise.
	 */
	private boolean filterByWhitelistedChannels(ChannelId channelId, List<ChannelId> whitelistedChannelIds) {
		return !whitelistedChannelIds.contains(channelId);
	}
	/**
	 * Return true if this video does not meet the preferred language criteria;  false otherwise.
	 * Many YouTube videos do not set the language, hence this method will not be accurate.
	 *
	 * @param video                 Video that is going to be checked for filtering purposes.
	 * @param preferredLanguages    A set of user's preferred ISO 639 language codes (regex).
	 *
	 * @return True to filter out the video; false otherwise.
	 */
	private boolean filterByLanguage(YouTubeVideo video, Set<String> preferredLanguages) {
		// if the video's language is not defined (i.e. null) or empty
		//	OR if there is no linguistic content to the video (zxx)
		//	OR if the language is undefined (und)
		// then we are NOT going to filter this video
		if (video.getLanguage() == null
				|| video.getLanguage().isEmpty()
				|| video.getLanguage().equalsIgnoreCase("zxx")
				|| video.getLanguage().equalsIgnoreCase("und"))
			return false;
		// if there are no preferred languages, then it means we must not filter this video
		if (preferredLanguages.isEmpty())
			return false;
		// if this video's language is equal to the user's preferred one... then do NOT filter it out
		for (String prefLanguage : preferredLanguages) {
			if (video.getLanguage().matches(prefLanguage))
				return false;
		}
		// this video is undesirable, hence we are going to filter it
		log(video, FilterType.LANGUAGE, video.getLanguage());
		return true;
	}
	/**
	 * Filter out the given video if it does not meet the preferred language criteria.  The app will
	 * try to determine the language of the video by analyzing the video's title.
	 *
	 * @param video                 Video that is going to be checked for filtering purposes.
	 * @param preferredLanguages    A set of user's preferred ISO 639 language codes (regex).
	 *
	 * @return True to filter out the video; false otherwise.
	 */
	private boolean filterByLanguageDetection(YouTubeVideo video, Set<String> preferredLanguages) {
		final String text = video.getTitle().toLowerCase();
		List<String> detectLanguageList = new ArrayList<>();
		// if the user does not want to block videos based on artificial language detection, then do
		// not filter the video
		if (!SkyTubeApp.getPreferenceManager().getBoolean(getStr(R.string.pref_key_lang_detection_video_filtering), false))
			return false;
		// if there are no preferred languages, then it means we must not filter this video
		if (preferredLanguages.isEmpty())
			return false;
		try {
			// detect language
			TextObject textObject = LanguageDetectionSingleton.get().getTextObjectFactory().forText(text);
			Optional<LdLocale> lang = LanguageDetectionSingleton.get().getLanguageDetector().detect(textObject);
			// if the confidence in the language detection is 100%, then ...
			if (lang.isPresent()) {
				final String langDetected = lang.get().getLanguage();
				detectLanguageList.add(langDetected);
				// if this video's language is equal to the user's preferred one... then do NOT filter it out
				for (String prefLanguage : preferredLanguages) {
					if (langDetected.matches(prefLanguage))
						return false;
				}
			} else {
				// else if the library is not 100% that the language detected is the correct one...
				List<DetectedLanguage> detectedLangList = LanguageDetectionSingleton.get().getLanguageDetector().getProbabilities(text);
				for (DetectedLanguage detectedLanguage : detectedLangList) {
					String langDetected = detectedLanguage.getLocale().getLanguage();
					detectLanguageList.add(langDetected);
					for (String prefLanguage : preferredLanguages) {
						if (langDetected.matches(prefLanguage))
							return false;
					}
				}
			}
		} catch (Throwable tr) {
			Logger.e(this, "Exception caught while detecting language", tr);
		}
		log(video, FilterType.LANGUAGE_DETECTION, detectLanguageList.toString());
		return true;
	}
	/**
	 * @return The views filtering value set by the user.
	 */
	private BigInteger getViewsFilteringValue() {
		final  String viewsFiltering = SkyTubeApp.getPreferenceManager().getString(getStr(R.string.pref_key_low_views_filter), getStr(R.string.views_filtering_disabled));
		return new BigInteger(viewsFiltering);
	}
	/**
	 * Filter videos by minimum views.  I.e. if videos has less views than minimumVideoViews, then
	 * filter it out.
	 *
	 * @param video             Video being processed.
	 * @param minimumVideoViews The minimum amount of views that a video should have as set by the
	 *                          user.
	 *
	 * @return True to filter out the video; false otherwise.
	 */
	private boolean filterByViews(YouTubeVideo video, BigInteger minimumVideoViews) {
		// if the user has not enabled the view filtering (i.e. it is set as -1), then do not filter
		// this video
		if (minimumVideoViews.signum() < 0  ||  video.getViewsCountInt() == null)
			return false;
		// if the video has less views than minimumVideoViews, then filter it out
		if (video.getViewsCountInt().compareTo(minimumVideoViews) < 0) {
			log(video, FilterType.VIEWS, String.format(getStr(R.string.views), video.getViewsCountInt()));
			return true;
		}
		return false;
	}
	/**
	 * @return The dislikes filtering value set by the user.
	 */
	private int getDislikesFilteringValue() {
		final  String dislikesFiltering = SkyTubeApp.getPreferenceManager().getString(getStr(R.string.pref_key_dislikes_filter), getStr(R.string.dislikes_filtering_disabled));
		return Integer.parseInt(dislikesFiltering);
	}
	/**
	 * Filter videos by dislikes.  I.e. if videos has more dislikes than minimumVideoDislikes, then
	 * filter it out.
	 *
	 * @param video                 Video being processed.
	 * @param minimumVideoDislikes  The minimum amount of dislikes that a video should have as set
	 *                              by the user.
	 *
	 * @return True to filter out the video; false otherwise.
	 */
	private boolean filterByDislikes(YouTubeVideo video, int minimumVideoDislikes) {
		// if the user has not enabled the dislikes filtering (i.e. it is set as -1), then do not
		// filter this video
		if (minimumVideoDislikes < 0)
			return false;
		// a video may not allow users to like/dislike...
		if (video.getThumbsUpPercentage() == -1)
			return false;
		final int dislikesPercentage = 100 - video.getThumbsUpPercentage();
		// if the video has more dislikes than minimumVideoDislikes, then filter it out
		if (dislikesPercentage >= minimumVideoDislikes) {
			log(video, FilterType.DISLIKES, String.format(getStr(R.string.dislikes), dislikesPercentage));
			return true;
		}
		return false;
	}
	////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * The type of video filtering.
	 */
	public enum FilterType implements Serializable {
		CHANNEL_BLACKLIST,
		CHANNEL_WHITELIST,
		LANGUAGE,
		LANGUAGE_DETECTION,
		VIEWS,
		DISLIKES;
		@Override
		public String toString() {
			// Full emoji support was introduced in Android 7.0.
			// Refer to:  https://www.android.com/versions/nougat-7-0/
			final boolean emojisSupported = (android.os.Build.VERSION.SDK_INT >= 24);
			switch (this) {
				case CHANNEL_BLACKLIST:
					return emojisSupported ? "⚫" : "B";
				case CHANNEL_WHITELIST:
					return emojisSupported ? "⚪" : "W";
				case LANGUAGE:
					return emojisSupported ? "\uD83D\uDDE3️" : "L";
				case LANGUAGE_DETECTION:
					return emojisSupported ? "\uD83D\uDD0D" : "LD";
				case VIEWS:
					return emojisSupported ? "\uD83D\uDC41️" : "V";
				case DISLIKES:
					return emojisSupported ? "\uD83D\uDC4E" : "D";
			}
			return super.toString();
		}
	}
	/**
	 * Represents a blocked YouTube video.
	 */
	public static class BlockedVideo implements Serializable {
		private final YouTubeVideo    video;
		private final FilterType      filteringType;
		private final String          reason;
		BlockedVideo(YouTubeVideo video, FilterType filteringType, String reason) {
			this.video = video;
			this.filteringType = filteringType;
			this.reason = reason;
		}
		public YouTubeVideo getVideo() {
			return video;
		}
		public FilterType getFilteringType() {
			return filteringType;
		}
		public String getReason() {
			return reason;
		}
	}
	/**
	 * {@link VideoBlocker} listener.
	 */
	public interface VideoBlockerListener {
		/**
		 * Will be called once a video is blocked by {@link VideoBlocker}.
		 *
		 * @param video The video that has been blocked.
		 */
		void onVideoBlocked(BlockedVideo video);
	}
	/**
	 * A singleton of objects used to detect languages.  This is required to improve the language
	 * detection performance...
	 */
	private static class LanguageDetectionSingleton {
		private static LanguageDetectionSingleton languageDetectionSingleton = null;
		private final TextObjectFactory textObjectFactory;
		private final LanguageDetector  languageDetector;
		private LanguageDetectionSingleton() throws IOException {
			// load all languages
			List<LanguageProfile> languageProfiles = new LanguageProfileReader().readAllBuiltIn();
			// build language detector
			languageDetector = LanguageDetectorBuilder.create(NgramExtractors.standard())
					.withProfiles(languageProfiles)
					.build();
			// create a text object factory
			textObjectFactory = CommonTextObjectFactories.forDetectingShortCleanText();
		}
		public static LanguageDetectionSingleton get() throws IOException {
			if (languageDetectionSingleton == null) {
				languageDetectionSingleton = new LanguageDetectionSingleton();
			}
			return languageDetectionSingleton;
		}
		TextObjectFactory getTextObjectFactory() {
			return textObjectFactory;
		}
		LanguageDetector getLanguageDetector() {
			return languageDetector;
		}
	}
}
package free.rm.skytube.gui.businessobjects;
import android.Manifest;
import android.app.Activity;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Environment;
import android.text.SpannableString;
import android.text.util.Linkify;
import android.util.Log;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.core.text.util.LinkifyCompat;
import androidx.fragment.app.Fragment;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonPrimitive;
import com.afollestad.materialdialogs.MaterialDialog;
import com.obsez.android.lib.filechooser.ChooserDialog;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.exceptions.ExtractionException;
import org.schabi.newpipe.extractor.subscription.SubscriptionExtractor;
import org.schabi.newpipe.extractor.subscription.SubscriptionItem;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlPullParserFactory;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.YouTube.newpipe.ContentId;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeException;
import free.rm.skytube.businessobjects.YouTube.newpipe.NewPipeService;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.businessobjects.db.SubscriptionsDb;
import free.rm.skytube.gui.businessobjects.preferences.BackupDatabases;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
import io.reactivex.rxjava3.schedulers.Schedulers;
/**
 * Custom class to handle Backups and Subscriptions imports. This class must be instantiated using either a native Fragment
 * or the support library (v4) Fragment. That Fragment must then override onRequestPermissionsResult and call the same method
 * in this class in order to pass the permission request result on to this class for handling.
 */
public class SubscriptionsBackupsManager {
    private final Activity activity;
    private final Fragment fragment;
    private static final int EXT_STORAGE_PERM_CODE_BACKUP = 1950;
    private static final int EXT_STORAGE_PERM_CODE_IMPORT = 1951;
    private static final int IMPORT_SUBSCRIPTIONS_READ_CODE = 42;
    private static final String TAG = SubscriptionsBackupsManager.class.getSimpleName();
    private boolean isUnsubsribeAllChecked = false;
    private final CompositeDisposable compositeDisposable = new CompositeDisposable();
    public SubscriptionsBackupsManager(Activity activity, Fragment fragment) {
        this.activity = activity;
        this.fragment = fragment;
    }
    private static class Result {
        private final  List<MultiSelectListPreferenceItem> newChannels;
        private final boolean noChannelFound;
        private Result(final List<MultiSelectListPreferenceItem> newChannels, final boolean noChannelFound) {
            this.newChannels = newChannels;
            this.noChannelFound = noChannelFound;
        }
    }
    public void clearBackgroundTasks() {
        compositeDisposable.clear();
    }
    /**
     * Backup the databases.
     */
    public void backupDatabases() {
        // if the user has granted us access to the external storage, then perform the backup
        // operation
        if (hasAccessToExtStorage(EXT_STORAGE_PERM_CODE_BACKUP)) {
            Toast.makeText(activity, R.string.databases_backing_up, Toast.LENGTH_SHORT).show();
            compositeDisposable.add(
                    Single.fromCallable(() -> new BackupDatabases().backupDbsToSdCard())
                            .subscribeOn(Schedulers.io())
                            .observeOn(AndroidSchedulers.mainThread())
                            .onErrorReturn(throwable -> {
                                Log.e(TAG, "Unable to backup the databases...", throwable);
                                return "";
                            })
                            .subscribe(backupPath -> {
                                String message = (!backupPath.isEmpty()) ?
                                        String.format(activity.getString(R.string.databases_backup_success),
                                                backupPath) :
                                        activity.getString(R.string.databases_backup_fail);
                                new AlertDialog.Builder(activity)
                                        .setMessage(message)
                                        .setNeutralButton(R.string.ok, null)
                                        .show();
                            })
            );
        }
    }
    /**
     * Display file picker to be used by the user to select the BACKUP (database) or
     * YOUTUBE SUBS (json or xml file) to import.
     */
    public void displayFilePicker() {
        displayFilePicker(true);
    }
    /**
     * Display file picker to be used by the user to select the BACKUP (database) or
     * YOUTUBE SUBS (json or xml file) to import.
     *
     * @param importDb  If set to true, the app will import (previously backed-up) database;
     *                  Otherwise, it will import YouTube subs (json or xml file).
     */
    private void displayFilePicker(final boolean importDb) {
        // do not display the file picker until the user gives us access to the external storage
        if (!hasAccessToExtStorage(importDb ? EXT_STORAGE_PERM_CODE_IMPORT : IMPORT_SUBSCRIPTIONS_READ_CODE))
            return;
        ChooserDialog dialog = new ChooserDialog(activity)
                .withStartFile((importDb ? Environment.getExternalStorageDirectory()
                        : Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS))
                        .getAbsolutePath())
                .displayPath(true)
                .withChosenListener((file, dirFile) -> {
                    if (importDb)
                        displayImportDbsBackupWarningMsg(file);
                    else {
                        Uri uri = Uri.fromFile(new File(file));
                        parseWithNewPipe(uri);
                    }
                })
                .withOnCancelListener(DialogInterface::cancel);
        if(importDb) {
            dialog.withFilter(false, false, "skytube");
        } else {
            dialog.withFilterRegex(false, false, ".*(json|xml|subscription_manager|zip|csv)$");
        }
        dialog.build().show();
    }
    /**
     * Check if the app has access to the external storage.  If not, ask the user whether he wants
     * to give us access...
     *
     * @param permissionRequestCode The request code (either EXT_STORAGE_PERM_CODE_BACKUP or
     *                              EXT_STORAGE_PERM_CODE_IMPORT) which is used by
     *                              {onRequestPermissionsResult(int, String[], int[])} to
     *                              determine whether we are going to backup (export) or to import.
     *
     * @return True if the user has given access to write to the external storage in the past;
     * false otherwise.
     */
    private boolean hasAccessToExtStorage(int permissionRequestCode) {
        boolean hasAccessToExtStorage = true;
        // if the user has not yet granted us access to the external storage...
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            // We can request the permission (to the users).  If the user grants us access (or
            // otherwise), then the method #onRequestPermissionsResult() will be called.
            fragment.requestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
                    permissionRequestCode);
            hasAccessToExtStorage = false;
        }
        return hasAccessToExtStorage;
    }
    /**
     * Display import database warning:  i.e. all the current data will be replaced by that of the
     * import file.
     *
     * @param backupFilePath    The backup file to import.
     */
    private void displayImportDbsBackupWarningMsg(final String backupFilePath) {
        new AlertDialog.Builder(activity)
                        .setMessage(R.string.databases_import_warning_message)
                        .setPositiveButton(R.string.continue_, (dialog, which) -> importDatabases(backupFilePath))
                        .setNegativeButton(R.string.cancel, null)
                        .show();
    }
    /**
     * Imports the subscription and bookmark databases.
     */
    private void importDatabases(String backupFilePath) {
        Toast.makeText(activity, R.string.databases_importing, Toast.LENGTH_SHORT).show();
        compositeDisposable.add(
                Single.fromCallable(() -> {
                    BackupDatabases backupDatabases = new BackupDatabases();
                    backupDatabases.importBackupDb(backupFilePath);
                    return true;
                })
                        .subscribeOn(Schedulers.io())
                        .observeOn(AndroidSchedulers.mainThread())
                        .onErrorReturn(throwable -> {
                            Log.e(TAG, "Unable to import the databases...", throwable);
                            return false;
                        })
                        .subscribe(successfulImport -> {
                            // We need to force the app to refresh the subscriptions feed when the app is
                            // restarted (irrespective to when the feeds were last refreshed -- which could be
                            // during the last 5 mins).  This is as we are loading new databases...
                            SkyTubeApp.getSettings().updateFeedsLastUpdateTime(null);
                            // ask the user to restart the app
                            new AlertDialog.Builder(activity)
                                    .setCancelable(false)
                                    .setMessage(successfulImport ? R.string.databases_import_success : R.string.databases_import_fail)
                                    .setNeutralButton(R.string.restart, (dialog, which) -> SkyTubeApp.restartApp())
                                    .show();
                        })
        );
    }
    private void parseWithNewPipe(Uri uri) {
        parseWithNewPipeBackground(uri)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(result -> {
                    importChannels(result.newChannels, result.noChannelFound);
                });
    }
    private Single<Result> parseWithNewPipeBackground(Uri uri) {
        return Single.fromCallable(() -> {
            SubscriptionExtractor extractor = NewPipeService.get().createSubscriptionExtractor();
            String extension = getExtension(uri);
            if (extractor != null && extension != null) {
                Log.i(TAG, "Parsing with " + extractor + " : " + uri);
                try (InputStream input = activity.getContentResolver().openInputStream(uri)) {
                    if ("csv".equals(extension) || "json".equals(extension) || "zip".equals(extension)) {
                        List<SubscriptionItem> items = extractor.fromInputStream(input, extension);
                        return importChannels(items);
                    }
                } catch (IOException | ExtractionException e) {
                    Log.e(TAG, "Unable to extract subscriptions: " + e.getMessage(), e);
                    SkyTubeApp.notifyUserOnError(activity, e);
                }
            }
            Log.i(TAG, "Parsing with old code : "+ uri.toString());
            return parseImportedSubscriptions(uri);
        });
    }
    private Result importChannels(final List<SubscriptionItem> items) {
        List<MultiSelectListPreferenceItem> result = new ArrayList();
        NewPipeService newPipeService = NewPipeService.get();
        SubscriptionsDb subscriptionsDb = SubscriptionsDb.getSubscriptionsDb();
        for (SubscriptionItem item : items){
            String url = item.getUrl();
            ContentId contentId = newPipeService.getContentId(url);
            if (contentId != null && contentId.getType() == StreamingService.LinkType.CHANNEL && !subscriptionsDb.isUserSubscribedToChannel(new ChannelId(contentId.getId()))) {
                result.add(new MultiSelectListPreferenceItem(contentId.getId(), item.getName()));
            }
        }
        return new Result(result, items.isEmpty());
    }
    private String getExtension(Uri uri) {
        String name = uri.toString().toLowerCase(Locale.ROOT);
        int lastDot = name.lastIndexOf('.');
        if (lastDot >= 0) {
            return name.substring(lastDot + 1);
        }
        return "";
    }
    /**
     * Parse the file that the user selected to import subscriptions from. Each channel contained in the file
     * that the user is not already subscribed to will appear in a dialog, to allow the user to select individual channels
     * to subscribe to, via a new Dialog. Once the user chooses to import the selected channels via the Import Subscriptions
     * button, {@link #subscribeToImportedChannels(List)} will be executed with a list of the selected channels.
     *
     * @param uri The URI pointing to the file containing YouTube Channels to subscribe to.
     * @return
     */
    private Result parseImportedSubscriptions(Uri uri) {
        ArrayList<MultiSelectListPreferenceItem> channels;
        String uriString = uri.toString();
        int lastIndexOf = uriString.lastIndexOf(".");
        if (lastIndexOf > 0 && uriString.substring(lastIndexOf).equalsIgnoreCase("xml")) {
            channels = parseChannelsXML(uri);
        } else {
            channels = parseChannelsJson(uri);
        }
        // Check the channel list for new channels
        ArrayList<MultiSelectListPreferenceItem> newChannels = new ArrayList<>();
        for (MultiSelectListPreferenceItem channel : channels) {
            if (channel.id != null && !SubscriptionsDb.getSubscriptionsDb().isUserSubscribedToChannel(new ChannelId(channel.id))) {
                newChannels.add(channel);
            }
        }
        return new Result(newChannels, channels.isEmpty());
    }
    private void importChannels(List<MultiSelectListPreferenceItem> newChannels, boolean noChannelFound) {
        if(newChannels.size() > 0) {
            // display a dialog which allows the user to select the channels to import
            new MultiSelectListPreferenceDialog(activity, newChannels)
                    .title(R.string.import_subscriptions)
                    .positiveText(R.string.import_subscriptions)
                    .onPositive((dialog, which) -> {
                        List<MultiSelectListPreferenceItem> channelsToSubscribeTo = new ArrayList<>();
                        for(MultiSelectListPreferenceItem channel: newChannels) {
                            if(channel.isChecked)
                                channelsToSubscribeTo.add(channel);
                        }
                        // if the user checked the "Unsubscribe to all subscribed channels" checkbox
                        if (isUnsubsribeAllChecked) {
                            compositeDisposable.add(DatabaseTasks.completableUnsubscribeFromAllChannels().andThen(
                                    subscribeToImportedChannels(channelsToSubscribeTo)
                            ).subscribe());
                        } else {
                            // subscribe to the channels selected by the user
                            compositeDisposable.add(subscribeToImportedChannels(channelsToSubscribeTo).subscribe());
                        }
                    })
                    .negativeText(R.string.cancel)
                    .build()
                    .show();
        } else {
            new AlertDialog.Builder(activity)
                    .setMessage(noChannelFound ? R.string.no_channels_found : R.string.no_new_channels_found)
                    .setNeutralButton(R.string.ok, null)
                    .show();
        }
    }
    /**
     * Parse the JSON file that the user selected to import subscriptions from.
     *
     * @param uri The URI pointing to the JSON file containing YouTube Channels to subscribe to
     * @return The channels found in the given file
     */
    private ArrayList<MultiSelectListPreferenceItem> parseChannelsJson(Uri uri) {
        JsonArray jsonArray;
        final ArrayList<MultiSelectListPreferenceItem> channels = new ArrayList<>();
        try {
            InputStreamReader fileReader = new InputStreamReader(activity.getContentResolver().openInputStream(uri));
            jsonArray = JsonParser.parseReader(fileReader).getAsJsonArray();
            fileReader.close();
        } catch (IOException e) {
            Logger.e(this, "An error occurred while reading the file", e);
            Toast.makeText(activity, String.format(activity.getString(R.string.import_subscriptions_parse_error), e.getMessage()), Toast.LENGTH_LONG).show();
            return channels;
        }
        for (JsonElement obj : jsonArray) {
            JsonObject snippet = obj.getAsJsonObject().getAsJsonObject("snippet");
            if (snippet == null) {
                continue;
            }
            JsonPrimitive channelName = snippet.getAsJsonPrimitive("title");
            JsonObject resourceId = snippet.getAsJsonObject("resourceId");
            if (resourceId == null) {
                continue;
            }
            JsonPrimitive channelId = resourceId.getAsJsonPrimitive("channelId");
            if (channelId != null && channelName != null) {
                channels.add(new MultiSelectListPreferenceItem(channelId.getAsString(), channelName.getAsString()));
            }
        }
        return channels;
    }
    /**
     * Parse the XML file that the user selected to import subscriptions from.
     *
     * @param uri The URI pointing to the XML file containing YouTube Channels to subscribe to
     * @return The channels found in the given file
     */
    private ArrayList<MultiSelectListPreferenceItem> parseChannelsXML(Uri uri) {
        final ArrayList<MultiSelectListPreferenceItem> channels = new ArrayList<>();
        Pattern channelPattern = Pattern.compile(".*channel_id=([^&]+)");
        Matcher matcher;
        try {
            XmlPullParserFactory xmlFactoryObject = XmlPullParserFactory.newInstance();
            XmlPullParser parser = xmlFactoryObject.newPullParser();
            parser.setInput(activity.getContentResolver().openInputStream(uri), null);
            int event = parser.getEventType();
            // If channels are found in the XML file but they are all already subscribed to, alert the user with a different
            // message than if no channels were found at all.
            while (event != XmlPullParser.END_DOCUMENT) {
                String name = parser.getName();
                switch (event) {
                    case XmlPullParser.START_TAG:
                        break;
                    case XmlPullParser.END_TAG:
                        if (name.equals("outline")) {
                            String xmlUrl = parser.getAttributeValue(null, "xmlUrl");
                            if (xmlUrl != null) {
                                matcher = channelPattern.matcher(xmlUrl);
                                if (matcher.matches()) {
                                    String channelId = matcher.group(1);
                                    String channelName = parser.getAttributeValue(null, "title");
                                    channels.add(new MultiSelectListPreferenceItem(channelId, channelName));
                                }
                            }
                        }
                        break;
                }
                event = parser.next();
            }
        } catch (IOException e) {
            Logger.e(this, "An error occurred while reading the file", e);
            Toast.makeText(activity, String.format(activity.getString(R.string.import_subscriptions_parse_error), e.getMessage()), Toast.LENGTH_LONG).show();
        } catch (XmlPullParserException e) {
            Logger.e(this, "An error occurred while attempting to parse the XML file uploaded", e);
            Toast.makeText(activity, String.format(activity.getString(R.string.import_subscriptions_parse_error), e.getMessage()), Toast.LENGTH_LONG).show();
        }
        return channels;
    }
    /**
     * A dialog that asks the user to import subscriptions from a YouTube account.
     */
    public void displayImportSubscriptionsFromYouTubeDialog() {
        SpannableString msg = new SpannableString(activity.getText(R.string.import_subscriptions_description));
        LinkifyCompat.addLinks(msg, Linkify.WEB_URLS);
        new SkyTubeMaterialDialog(activity)
                .title(R.string.import_subscriptions)
                .content(msg)
                .positiveText(R.string.select_sub_file)
                .checkBoxPromptRes(R.string.unsubscribe_from_all_current_sibbed_channels, false, (compoundButton, b) -> isUnsubsribeAllChecked = true)
                .onPositive((dialog, which) -> displayFilePicker(false))
                .build()
                .show();
    }
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if(requestCode == IMPORT_SUBSCRIPTIONS_READ_CODE && resultCode == Activity.RESULT_OK) {
            if (data != null) {
                Uri uri = data.getData();
                parseImportedSubscriptions(uri);
            }
        }
    }
    private @NonNull Single<Object[]> subscribeToImportedChannels(final List<MultiSelectListPreferenceItem> channels) {
        return Single.fromCallable(() -> {
            // display the "Subscribing to channels …" dialog
            final MaterialDialog dialog = new MaterialDialog.Builder(activity)
                    .content(R.string.subscribing_to_channels)
                    .progress(true, 0)
                    .build();
            dialog.show();
            return dialog;
        }).subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(Schedulers.io())
                .map(dialog -> {
                    SubscriptionsDb db = SubscriptionsDb.getSubscriptionsDb();
                    int success = 0;
                    for (MultiSelectListPreferenceItem selectedItem : channels) {
                        try {
                            ChannelId channelId = new ChannelId(selectedItem.id);
                            PersistentChannel channelInfo = DatabaseTasks.getChannelOrRefresh(activity, channelId, true);
                            if (!channelInfo.isSubscribed()) {
                                db.subscribe(channelInfo, Collections.emptyList());
                                success += 1;
                            }
                        } catch (NewPipeException newPipeException) {
                            Log.e(TAG, "Error: " + newPipeException.getMessage(), newPipeException);
                        }
                    }
                    return new Object[] { dialog, success };
                })
                .observeOn(AndroidSchedulers.mainThread())
                .map(inputs -> {
                    // hide the dialog
                    ((MaterialDialog) inputs[0]).dismiss();
                    int totalChannelsSubscribedTo = (Integer) inputs[1];
                    // inform the SubsAdapter that it needs to repopulate the subbed channels list
                    EventBus.getInstance().notifyMainTabChanged(EventBus.SettingChange.SUBSCRIPTION_LIST_CHANGED);
                    Toast.makeText(activity,
                            String.format(SkyTubeApp.getStr(R.string.subscriptions_to_channels_imported), totalChannelsSubscribedTo),
                            Toast.LENGTH_SHORT).show();
                    // refresh the Feed tab so it shows videos from the newly subscribed channels
                    SkyTubeApp.getSettings().setRefreshSubsFeedFull(true);
                    // if the user imported the subs channels from the Feed tab/fragment, then we
                    // need to refresh the fragment in order for the fragment to update the feed...
                    ActivityCompat.recreate(activity);
                    return inputs;
                });
    }
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        // EXT_STORAGE_PERM_CODE_BACKUP is used to backup the databases
        if (requestCode == EXT_STORAGE_PERM_CODE_BACKUP) {
            if (grantResults.length > 0  &&  grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // permission was granted by the user
                backupDatabases();
            } else {
                // permission denied by the user
                Toast.makeText(activity, R.string.databases_backup_fail, Toast.LENGTH_LONG).show();
            }
        }
        // EXT_STORAGE_PERM_CODE_IMPORT is used for the file picker (to import database backups)
        else if (requestCode == EXT_STORAGE_PERM_CODE_IMPORT) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                displayFilePicker();
            }
            else {
                // permission not been granted by user
                Toast.makeText(activity, R.string.databases_import_fail, Toast.LENGTH_LONG).show();
            }
        }
        else if (requestCode == IMPORT_SUBSCRIPTIONS_READ_CODE)
        {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                displayFilePicker(false);
            }
            else {
                // permission not been granted by user
                Toast.makeText(activity, R.string.failed_to_import_subscriptions, Toast.LENGTH_LONG).show();
            }
        }
    }
}
package free.rm.skytube.gui.fragments;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Rect;
import android.media.AudioManager;
import android.media.MediaPlayer;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.BaseExpandableListAdapter;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.core.content.ContextCompat;
import androidx.media.AudioManagerCompat;
import androidx.preference.PreferenceManager;
import com.bumptech.glide.Glide;
import com.bumptech.glide.request.RequestOptions;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.stream.StreamInfo;
import java.io.File;
import java.util.Locale;
import free.rm.skytube.R;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.app.StreamSelectionPolicy;
import free.rm.skytube.app.Utils;
import free.rm.skytube.app.enums.Policy;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.YouTubeTasks;
import free.rm.skytube.businessobjects.YouTube.newpipe.ContentId;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.businessobjects.db.DownloadedVideosDb;
import free.rm.skytube.businessobjects.db.PlaybackStatusDb;
import free.rm.skytube.businessobjects.interfaces.GetDesiredStreamListener;
import free.rm.skytube.businessobjects.interfaces.YouTubePlayerActivityListener;
import free.rm.skytube.businessobjects.interfaces.YouTubePlayerFragmentInterface;
import free.rm.skytube.databinding.FragmentYoutubePlayerV1Binding;
import free.rm.skytube.databinding.VideoDescriptionBinding;
import free.rm.skytube.gui.activities.ThumbnailViewerActivity;
import free.rm.skytube.gui.businessobjects.MediaControllerEx;
import free.rm.skytube.gui.businessobjects.MobileNetworkWarningDialog;
import free.rm.skytube.gui.businessobjects.OnSwipeTouchListener;
import free.rm.skytube.gui.businessobjects.ResumeVideoTask;
import free.rm.skytube.gui.businessobjects.SkyTubeMaterialDialog;
import free.rm.skytube.gui.businessobjects.adapters.CommentsAdapter;
import free.rm.skytube.gui.businessobjects.fragments.ImmersiveModeFragment;
import free.rm.skytube.gui.businessobjects.views.ChannelActionHandler;
import free.rm.skytube.gui.businessobjects.views.Linker;
import free.rm.skytube.businessobjects.interfaces.PlaybackStateListener;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
import static free.rm.skytube.gui.activities.YouTubePlayerActivity.YOUTUBE_VIDEO_OBJ;
/**
 * A fragment that holds a standalone YouTube player.
 */
public class YouTubePlayerV1Fragment extends ImmersiveModeFragment implements MediaPlayer.OnPreparedListener, YouTubePlayerFragmentInterface {
	/** Timeout (in milliseconds) before the HUD (i.e. media controller + action/title bar) is hidden. */
	private static final int HUD_VISIBILITY_TIMEOUT = 5000;
	/** Timeout (in milliseconds) before the navigation bar is hidden (which will occur only after
	 * the HUD is hidden). */
	private static final int NAVBAR_VISIBILITY_TIMEOUT = 500;
	private static final String VIDEO_CURRENT_POSITION = "YouTubePlayerV1Fragment.VideoCurrentPosition";
	private static final String TAG = YouTubePlayerV1Fragment.class.getSimpleName();
	private static final int MAX_VIDEO_STEP_TIME = 60 * 1000;
	private static final int MAX_BRIGHTNESS = 100;
	private PlaybackStateListener playbackStateListener;
	private YouTubeVideo youTubeVideo = null;
	private YouTubeChannel youTubeChannel = null;
	private FragmentYoutubePlayerV1Binding fragmentBinding;
	private VideoDescriptionBinding videoDescriptionBinding;
	/** The current video position (i.e. play time). */
	private int videoCurrentPosition = 0;
	private MediaControllerEx mediaController = null;
	private BaseExpandableListAdapter commentsAdapter = null;
	private Menu menu = null;
	private YouTubePlayerActivityListener listener = null;
	private Handler hideHudTimerHandler = null;
	private Handler hideVideoDescAndCommentsIconsTimerHandler = null;
	private float startBrightness = -1.0f;
	private float startVolumePercent  = -1.0f;
	private int startVideoTime = -1;
	private final CompositeDisposable compositeDisposable = new CompositeDisposable();
	private final ChannelActionHandler actionHandler = new ChannelActionHandler(compositeDisposable);
	@Override
	public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		// hide the navigation bar
		hideNavigationBar();
		// inflate the layout for this fragment
		fragmentBinding = FragmentYoutubePlayerV1Binding.inflate(inflater, container, false);
		videoDescriptionBinding = fragmentBinding.desContent;
		// indicate that this fragment has an action bar menu
		setHasOptionsMenu(true);
		if (savedInstanceState != null)
			videoCurrentPosition = savedInstanceState.getInt(VIDEO_CURRENT_POSITION, 0);
		if (youTubeVideo == null) {
			// initialise the views
			initViews();
			// hide action bar
			getSupportActionBar().hide();
			// get which video we need to play...
			Bundle bundle = requireActivity().getIntent().getExtras();
			if (bundle != null  &&  bundle.getSerializable(YOUTUBE_VIDEO_OBJ) != null) {
				// ... either the video details are passed through the previous activity
				youTubeVideo = (YouTubeVideo) bundle.getSerializable(YOUTUBE_VIDEO_OBJ);
				setUpHUDAndPlayVideo();
				getVideoInfoTasks();
			} else {
				// ... or the video URL is passed to SkyTube via another Android app
				final ContentId contentId = SkyTubeApp.getUrlFromIntent(requireContext(), requireActivity().getIntent());
				Utils.isTrue(contentId.getType() == StreamingService.LinkType.STREAM, "Content is a video:"+contentId);
				compositeDisposable.add(YouTubeTasks.getVideoDetails(requireContext(), contentId)
						.subscribe(youTubeVideo1 -> {
							if (youTubeVideo1 == null) {
								// invalid URL error (i.e. we are unable to decode the URL)
								String err = String.format(getString(R.string.error_invalid_url), contentId.getCanonicalUrl());
								Toast.makeText(getActivity(), err, Toast.LENGTH_LONG).show();
								// log error
								Log.e(TAG, err);
								// close the video player activity
								closeActivity();
							} else {
								YouTubePlayerV1Fragment.this.youTubeVideo = youTubeVideo1;
								// setup the HUD and play the video
								setUpHUDAndPlayVideo();
								getVideoInfoTasks();
								// will now check if the video is bookmarked or not (and then update the menu
								// accordingly)
								compositeDisposable.add(DatabaseTasks.isVideoBookmarked(youTubeVideo.getId(), menu));
							}
						}));
			}
		}
		return fragmentBinding.getRoot();
	}
	@Override
	public void onAttach(@NonNull Context context) {
		super.onAttach(context);
		try {
			Activity activity = (Activity)context;
			listener = (YouTubePlayerActivityListener)activity;
		} catch (ClassCastException e) {
			throw new ClassCastException("YouTubePlayerFragment must be instantiated from an Activity " +
					"that implements YouTubePlayerActivityListener");
		}
	}
	@Override
	public void onDestroy() {
		compositeDisposable.clear();
		videoDescriptionBinding.videoDescSubscribeButton.clearBackgroundTasks();
		fragmentBinding = null;
		videoDescriptionBinding = null;
		super.onDestroy();
	}
	/**
	 * Initialise the views.
	 *
	 */
	private void initViews() {
		// videoView should log any errors
		fragmentBinding.videoView.setOnErrorListener((mp, what, extra) -> {
			String msg = String.format(Locale.getDefault(),
					"Error has occurred while playing video, url='%s', what=%d, extra=%d",
					youTubeVideo != null ? youTubeVideo.getVideoUrl() : "null",
					what,
					extra);
			Logger.e(TAG, msg);
			return false;
		});
		// play the video once its loaded
		fragmentBinding.videoView.setOnPreparedListener(this);
		// setup the media controller (will control the video playing/pausing)
		mediaController = new MediaControllerEx(getActivity(), fragmentBinding.videoView, this);
		// ensure that the mediaController is always above the NavBar (given that the NavBar can be
		// in immersive mode)
		mediaController.setPadding(0, 0, 0, getNavBarHeightInPixels());
		// detect if user's swipes motions and taps...
		fragmentBinding.voidView.setOnTouchListener(new OnSwipeTouchListener(getActivity()) {
			/** Enable/Disable video gestures based on user preferences. */
			private final boolean disableGestures = SkyTubeApp.getPreferenceManager().getBoolean(SkyTubeApp.getStr(R.string.pref_key_disable_screen_gestures), false);
			@Override
			public boolean onSwipeLeft() {
				fragmentBinding.commentsDrawer.animateOpen();
				return true;
			}
			@Override
			public boolean onSwipeTop() {
				fragmentBinding.desDrawer.animateOpen();
				return true;
			}
			@Override
			public boolean onDoubleTap() {
				if (fragmentBinding.videoView.isPlaying()) {
					pause();
				} else {
					play();
				}
				return true;
			}
			@Override
			public boolean onSingleTap() {
				showOrHideHud();
				return true;
			}
			@Override
			public void onGestureDone() {
				startBrightness = -1.0f;
				startVolumePercent = -1.0f;
				startVideoTime = -1;
				hideIndicator();
			}
			@Override
			public void adjustBrightness(double adjustPercent) {
				if (disableGestures) {
					return;
				}
				// We are setting brightness percent to a value that should be from -1.0 to 1.0. We need to limit it here for these values first
				if (adjustPercent < -1.0f) {
					adjustPercent = -1.0f;
				} else if (adjustPercent > 1.0f) {
					adjustPercent = 1.0f;
				}
				WindowManager.LayoutParams lp = getActivity().getWindow().getAttributes();
				if (startBrightness < 0) {
					startBrightness = lp.screenBrightness;
				}
				// We are getting a final brightness value when summing current brightness and the percent we got from swipe action. Should be >= 0 and <= 1
				float targetBrightness = (float) (startBrightness + adjustPercent * 1.0f);
				if (targetBrightness <= 0.0f) {
					targetBrightness = 0.0f;
				} else if (targetBrightness >= 1.0f) {
					targetBrightness = 1.0f;
				}
				lp.screenBrightness = targetBrightness;
				getActivity().getWindow().setAttributes(lp);
				fragmentBinding.indicatorImageView.setImageResource(R.drawable.ic_brightness);
				fragmentBinding.indicatorTextView.setText((int) (targetBrightness * MAX_BRIGHTNESS) + "%");
				// Show indicator. It will be hidden once onGestureDone will be called
				showIndicator();
			}
			@Override
			public void adjustVolumeLevel(double adjustPercent) {
				if (disableGestures) {
					return;
				}
				// We are setting volume percent to a value that should be from -1.0 to 1.0. We need to limit it here for these values first
				if (adjustPercent < -1.0f) {
					adjustPercent = -1.0f;
				} else if (adjustPercent > 1.0f) {
					adjustPercent = 1.0f;
				}
				AudioManager audioManager = ContextCompat.getSystemService(requireContext(), AudioManager.class);
				final int STREAM = AudioManager.STREAM_MUSIC;
				// Max volume will return INDEX of volume not the percent. For example, on my device it is 15
				int maxVolume = AudioManagerCompat.getStreamMaxVolume(audioManager, STREAM);
				if (maxVolume == 0) return;
				if (startVolumePercent < 0) {
					// We are getting actual volume index (NOT volume but index). It will be >= 0.
					int curVolume = audioManager.getStreamVolume(STREAM);
					// And counting percents of maximum volume we have now
					startVolumePercent = curVolume * 1.0f / maxVolume;
				}
				// Should be >= 0 and <= 1
				double targetPercent = startVolumePercent + adjustPercent;
				if (targetPercent > 1.0f) {
					targetPercent = 1.0f;
				} else if (targetPercent < 0) {
					targetPercent = 0;
				}
				// Calculating index. Test values are 15 * 0.12 = 1 ( because it's int)
				int index = (int) (maxVolume * targetPercent);
				if (index > maxVolume) {
					index = maxVolume;
				} else if (index < 0) {
					index = 0;
				}
				audioManager.setStreamVolume(STREAM, index, 0);
				fragmentBinding.indicatorImageView.setImageResource(R.drawable.ic_volume);
				fragmentBinding.indicatorTextView.setText(index * 100 / maxVolume + "%");
				// Show indicator. It will be hidden once onGestureDone will be called
				showIndicator();
			}
			@Override
			public void adjustVideoPosition(double adjustPercent, boolean forwardDirection) {
				if (disableGestures) {
					return;
				}
				if (adjustPercent < -1.0f) {
					adjustPercent = -1.0f;
				} else if (adjustPercent > 1.0f) {
					adjustPercent = 1.0f;
				}
				int totalTime = fragmentBinding.videoView.getDuration();
				if (startVideoTime < 0) {
					startVideoTime = fragmentBinding.videoView.getCurrentPosition();
				}
				// adjustPercent: value from -1 to 1.
                double positiveAdjustPercent = Math.max(adjustPercent,-adjustPercent);
				// End of line makes seek speed not linear
				int targetTime = startVideoTime + (int) (MAX_VIDEO_STEP_TIME * adjustPercent * (positiveAdjustPercent / 0.1));
				if (targetTime > totalTime) {
					targetTime = totalTime;
				}
				if (targetTime < 0) {
					targetTime = 0;
				}
				String targetTimeString = formatDuration(targetTime / 1000);
				if (forwardDirection) {
					fragmentBinding.indicatorImageView.setImageResource(R.drawable.ic_forward);
				} else {
					fragmentBinding.indicatorImageView.setImageResource(R.drawable.ic_rewind);
				}
				fragmentBinding.indicatorTextView.setText(targetTimeString);
				showIndicator();
				fragmentBinding.videoView.seekTo(targetTime);
			}
			@Override
			public Rect viewRect() {
				return new Rect(fragmentBinding.voidView.getLeft(), fragmentBinding.voidView.getTop(),
						fragmentBinding.voidView.getRight(), fragmentBinding.voidView.getBottom());
			}
		});
		videoDescriptionBinding.videoDescChannelThumbnailImageView.setOnClickListener(v -> {
			if (youTubeChannel != null) {
				SkyTubeApp.launchChannel(youTubeChannel, getActivity());
			}
		});
		fragmentBinding.commentsDrawer.setOnDrawerOpenListener(() -> {
			if (commentsAdapter == null && youTubeVideo != null) {
				commentsAdapter = CommentsAdapter.createAdapter(getActivity(), null, youTubeVideo.getId(),
						fragmentBinding.commentsExpandableListView, fragmentBinding.commentsProgressBar,
						fragmentBinding.noVideoCommentsTextView, fragmentBinding.videoCommentsAreDisabled);
			}
		});
		Linker.configure(videoDescriptionBinding.videoDescDescription, null);
	}
	@Override
	public void onSaveInstanceState(@NonNull Bundle outState) {
		super.onSaveInstanceState(outState);
		outState.putInt(VIDEO_CURRENT_POSITION, videoCurrentPosition);
	}
	/**
	 * Will asynchronously retrieve additional video information such as channel, avatar ...etc
	 */
	private void getVideoInfoTasks() {
		// get Channel info (e.g. avatar...etc) task
		compositeDisposable.add(DatabaseTasks.getChannelInfo(requireContext(), youTubeVideo.getChannelId(), false)
				.subscribe(persistentChannel -> {
					youTubeChannel = persistentChannel.channel();
					videoDescriptionBinding.videoDescSubscribeButton.setChannelInfo(persistentChannel);
					if (youTubeChannel != null) {
						Glide.with(requireContext())
								.load(youTubeChannel.getThumbnailUrl())
								.apply(new RequestOptions().placeholder(R.drawable.channel_thumbnail_default))
								.into(videoDescriptionBinding.videoDescChannelThumbnailImageView);
					}
				}));
	}
	/**
	 * Will setup the HUD's details according to the contents of {@link #youTubeVideo}.  Then it
	 * will try to load and play the video.
	 */
	private void setUpHUDAndPlayVideo() {
		setupInfoDisplay(youTubeVideo);
		new ResumeVideoTask(requireContext(), youTubeVideo.getId(), position -> {
			videoCurrentPosition = position;
			YouTubePlayerV1Fragment.this.loadVideo();
		}).ask();
	}
	private void setupInfoDisplay(YouTubeVideo video) {
		getSupportActionBar().setTitle(video.getTitle());
		videoDescriptionBinding.videoDescTitle.setText(video.getTitle());
		videoDescriptionBinding.videoDescChannel.setText(video.getChannelName());
		videoDescriptionBinding.videoDescViews.setText(video.getViewsCount());
		videoDescriptionBinding.videoDescPublishDate.setText(video.getPublishDatePretty());
		if (video.getDescription() != null) {
			Linker.setTextAndLinkify(videoDescriptionBinding.videoDescDescription, video.getDescription());
		}
		if (video.isThumbsUpPercentageSet()) {
			videoDescriptionBinding.videoDescLikes.setText(video.getLikeCount());
			videoDescriptionBinding.videoDescDislikes.setText(video.getDislikeCount());
			videoDescriptionBinding.videoDescLikesBar.setProgress(video.getThumbsUpPercentage());
			videoDescriptionBinding.videoDescRatingsDisabled.setVisibility(View.GONE);
			videoDescriptionBinding.videoDescLikes.setVisibility(View.VISIBLE);
			videoDescriptionBinding.videoDescDislikes.setVisibility(View.VISIBLE);
			videoDescriptionBinding.videoDescLikesBar.setVisibility(View.VISIBLE);
		} else {
			videoDescriptionBinding.videoDescLikes.setVisibility(View.GONE);
			videoDescriptionBinding.videoDescDislikes.setVisibility(View.GONE);
			videoDescriptionBinding.videoDescLikesBar.setVisibility(View.GONE);
			videoDescriptionBinding.videoDescRatingsDisabled.setVisibility(View.VISIBLE);
		}
	}
	@Override
	public void onPrepared(MediaPlayer mediaPlayer) {
		fragmentBinding.loadingVideoView.setVisibility(View.GONE);
		fragmentBinding.videoView.seekTo(videoCurrentPosition);
		play();
		showHud();
	}
	@Override
	public void onPause() {
		if (fragmentBinding != null && fragmentBinding.videoView.isPlaying()) {
			videoCurrentPosition = fragmentBinding.videoView.getCurrentPosition();
		}
		saveVideoPosition(videoCurrentPosition);
		saveCurrentBrightness();
		super.onPause();
	}
	@Override
	public void onResume() {
		super.onResume();
		setupUserPrefs();
	}
	// We can also add volume level or something in the future.
	private void setupUserPrefs() {
		SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(requireActivity());
		float brightnessLevel = sp.getFloat(getString(R.string.pref_key_brightness_level), -1.0f);
		setBrightness(brightnessLevel);
	}
	private void saveCurrentBrightness() {
		WindowManager.LayoutParams lp = requireActivity().getWindow().getAttributes();
		float brightnessLevel = lp.screenBrightness;
		SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());
		sp.edit().putFloat(getString(R.string.pref_key_brightness_level), brightnessLevel).apply();
		Logger.d(this, "BRIGHTNESS: %f", brightnessLevel);
	}
	private void setBrightness(float level) {
		if(level <= 0.0f && level > 1.0f) return;
		WindowManager.LayoutParams lp = requireActivity().getWindow().getAttributes();
		lp.screenBrightness = level;
		getActivity().getWindow().setAttributes(lp);
	}
	/**
	 * @return True if the HUD is visible (provided that this Fragment is also visible).
	 */
	private boolean isHudVisible() {
		return isVisible()  &&  (mediaController.isShowing()  ||  getSupportActionBar().isShowing());
	}
	/**
	 * Hide or display the HUD depending if the HUD is currently visible or not.
	 */
	private void showOrHideHud() {
		if (fragmentBinding.commentsDrawer.isOpened()) {
			fragmentBinding.commentsDrawer.animateClose();
		} else if (fragmentBinding.desDrawer.isOpened()) {
			fragmentBinding.desDrawer.animateClose();
		} else if (isHudVisible()) {
			hideHud();
		} else {
			showHud();
		}
	}
	/**
	 * Show the HUD (head-up display), i.e. the Action Bar and Media Controller.
	 */
	private void showHud() {
		if (!isHudVisible()) {
			getSupportActionBar().show();
			getSupportActionBar().setTitle(youTubeVideo != null ? youTubeVideo.getTitle() : "");
			mediaController.show(0);
			fragmentBinding.desDrawer.close();
			fragmentBinding.videoDescIconImageView.setVisibility(View.INVISIBLE);
			fragmentBinding.commentsDrawer.close();
			fragmentBinding.commentsIconImageView.setVisibility(View.INVISIBLE);
			// hide UI after a certain timeout (defined in HUD_VISIBILITY_TIMEOUT)
			hideHudTimerHandler = new Handler();
			hideHudTimerHandler.postDelayed(() -> {
				hideHud();
				hideHudTimerHandler = null;
			}, HUD_VISIBILITY_TIMEOUT);
		}
	}
	/**
	 * Hide the HUD.
	 */
	private void hideHud() {
		if (isHudVisible()) {
			getSupportActionBar().hide();
			mediaController.hideController();
			// Due to the IMMERSIVE mode experience (i.e. comments/desc icons are hidden by default):
			// Hide the navigation bar.  Due to Android pre-defined mechanisms, the nav bar can
			// only be hidden after all animation have been rendered (e.g. mediaController is
			// fully closed).  As a result, a delay is needed in order to explicitly hide the
			// nav bar.
			hideVideoDescAndCommentsIconsTimerHandler = new Handler();
			hideVideoDescAndCommentsIconsTimerHandler.postDelayed(() -> {
				hideNavigationBar();
				hideVideoDescAndCommentsIconsTimerHandler = null;
			}, NAVBAR_VISIBILITY_TIMEOUT);
			// If there is a hideHudTimerHandler running, then cancel it (stop if from running).  This way,
			// if the HUD was hidden on the 5th second, and the user reopens the HUD, this code will
			// prevent the HUD to re-disappear 2 seconds after it was displayed (assuming that
			// HUD_VISIBILITY_TIMEOUT = 5 seconds).
			if (hideHudTimerHandler != null) {
				hideHudTimerHandler.removeCallbacksAndMessages(null);
				hideHudTimerHandler = null;
			}
		}
	}
	private void showIndicator() {
		fragmentBinding.indicatorView.setVisibility(View.VISIBLE);
	}
	private void hideIndicator() {
		fragmentBinding.indicatorView.setVisibility(View.GONE);
	}
	// Returns a (localized) string for the given duration (in seconds).
	private String formatDuration(int duration) {
		int h = duration / 3600;
		int m = (duration - h * 3600) / 60;
		int s = duration - (h * 3600 + m * 60);
		String durationValue;
		if (h == 0) {
			durationValue = String.format(Locale.getDefault(),"%1$02d:%2$02d", m, s);
		} else {
			durationValue = String.format(Locale.getDefault(),"%1$d:%2$02d:%3$02d", h, m, s);
		}
		return durationValue;
	}
	@Override
	public void onPrepareOptionsMenu(@NonNull Menu menu) {
		DatabaseTasks.updateDownloadedVideoMenu(youTubeVideo, menu);
		if (youTubeVideo != null && youTubeVideo.getChannelId() != null) {
			menu.findItem(R.id.subscribe_channel).setVisible(true);
			menu.findItem(R.id.open_channel).setVisible(true);
		} else {
			menu.findItem(R.id.subscribe_channel).setVisible(false);
			menu.findItem(R.id.open_channel).setVisible(false);
		}
	}
	@Override
	public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
		inflater.inflate(R.menu.menu_youtube_player, menu);
		this.menu = menu;
		listener.onOptionsMenuCreated(menu);
		// Will now check if the video is bookmarked or not (and then update the menu accordingly).
		//
		// youTubeVideo might be null if we have only passed the video URL to this fragment (i.e.
		// the app is still trying to construct youTubeVideo in the background).
		if (youTubeVideo != null) {
			compositeDisposable.add(DatabaseTasks.isVideoBookmarked(youTubeVideo.getId(), menu));
		}
	}
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		if (actionHandler.handleChannelActions(getContext(), youTubeChannel, item.getItemId())) {
			return true;
		}
		switch (item.getItemId()) {
			case R.id.menu_reload_video:
				loadVideo();
				return true;
			case R.id.menu_open_video_with:
				compositeDisposable.add(youTubeVideo.playVideoExternally(getContext())
						.subscribe(status -> pause()));
				return true;
			case R.id.share:
				youTubeVideo.shareVideo(getContext());
				return true;
			case R.id.copyurl:
				youTubeVideo.copyUrl(getContext());
				return true;
			case R.id.bookmark_video:
				compositeDisposable.add(youTubeVideo.bookmarkVideo(getContext(), menu).subscribe());
				return true;
			case R.id.unbookmark_video:
				compositeDisposable.add(youTubeVideo.unbookmarkVideo(getContext(), menu).subscribe());
				return true;
			case R.id.view_thumbnail:
				Intent i = new Intent(getActivity(), ThumbnailViewerActivity.class);
				i.putExtra(ThumbnailViewerActivity.YOUTUBE_VIDEO, youTubeVideo);
				startActivity(i);
				return true;
			case R.id.download_video:
				final Policy decision = new MobileNetworkWarningDialog(requireContext())
						.showDownloadWarning(youTubeVideo);
				if (decision == Policy.ALLOW) {
					youTubeVideo.downloadVideo(getContext()).subscribe();
				}
				return true;
			default:
				return super.onOptionsItemSelected(item);
		}
	}
	/**
	 * Loads the video specified in {@link #youTubeVideo}.
	 */
	private void loadVideo() {
		loadVideo(true);
	}
	/**
	 * Loads the video specified in {@link #youTubeVideo}.
	 *
	 * @param showMobileNetworkWarning Set to true to show the warning displayed when the user is
	 *                                 using mobile network data (i.e. 4g).
	 */
	private void loadVideo(boolean showMobileNetworkWarning) {
		Context ctx = getContext();
		compositeDisposable.add(
			DownloadedVideosDb.getVideoDownloadsDb().getDownloadedFileStatus(ctx, youTubeVideo.getVideoId())
				.subscribe (downloadStatus -> {
					Policy decision = Policy.ALLOW;
					Logger.i(YouTubePlayerV1Fragment.this, "Opening video : "+downloadStatus.getLocalVideoFile() + " for "+downloadStatus.getUri());
					// if the user is using mobile network (i.e. 4g), then warn him
					if (showMobileNetworkWarning && downloadStatus.getUri() == null) {
						decision = new MobileNetworkWarningDialog(getActivity())
							.onPositive((dialog, which) -> loadVideo(false))
							.onNegativeOrCancel((dialog) -> closeActivity())
							.showAndGetStatus(MobileNetworkWarningDialog.ActionType.STREAM_VIDEO);
					}
					if (decision == Policy.ALLOW) {
						// if the video is NOT live
						if (!youTubeVideo.isLiveStream()) {
							fragmentBinding.loadingVideoView.setVisibility(View.VISIBLE);
							if (downloadStatus.isDisappeared()) {
								// If the file for this video has gone missing, warn and then play remotely.
								Toast.makeText(getContext(),
										getString(R.string.playing_video_file_missing),
										Toast.LENGTH_LONG).show();
								loadVideo();
								return;
							}
							if (downloadStatus.getUri() != null) {
								fragmentBinding.loadingVideoView.setVisibility(View.GONE);
								Logger.i(this, ">> PLAYING LOCALLY: %s", downloadStatus.getUri());
								fragmentBinding.videoView.setVideoURI(downloadStatus.getUri());
								// get the video statistics
								compositeDisposable.add(YouTubeTasks.getVideoDetails(ctx, youTubeVideo.getVideoId())
										.subscribe(video -> {
											if (video != null) {
												setupInfoDisplay(video);
											}
										}));
							} else {
								compositeDisposable.add(
									YouTubeTasks.getDesiredStream(youTubeVideo,
										new GetDesiredStreamListener() {
											@Override
											public void onGetDesiredStream(StreamInfo desiredStream, YouTubeVideo video) {
												// hide the loading video view (progress bar)
												fragmentBinding.loadingVideoView.setVisibility(View.GONE);
												// Play the video.  Check if this fragment is visible before playing the
												// video.  It might not be visible if the user clicked on the back button
												// before the video streams are retrieved (such action would cause the app
												// to crash if not catered for...).
												if (isVisible()) {
													StreamSelectionPolicy selectionPolicy = SkyTubeApp.getSettings().getDesiredVideoResolution(false).withAllowVideoOnly(false);
													StreamSelectionPolicy.StreamSelection selection = selectionPolicy.select(desiredStream);
													if (selection != null) {
														Uri uri = selection.getVideoStreamUri();
														Logger.i(YouTubePlayerV1Fragment.this, ">> PLAYING: %s, audio: %s", uri, selection.getAudioStreamUri());
														fragmentBinding.videoView.setVideoURI(uri);
														setupInfoDisplay(video);
													} else {
														videoPlaybackError(selectionPolicy.getErrorMessage(getContext()));
													}
												}
											}
											@Override
											public void onGetDesiredStreamError(Throwable throwable) {
												if (throwable != null) {
													videoPlaybackError(throwable.getMessage());
												}
											}
										}).subscribe());
									}
								} else {
									openAsLiveStream();
								}
							}
						}));
	}
	private void openAsLiveStream() {
		// else, if the video is a LIVE STREAM
		// video is live:  ask the user if he wants to play the video using an other app
		Context ctx = getContext();
		if (ctx != null) {
			new SkyTubeMaterialDialog(ctx)
					.onNegativeOrCancel((dialog) -> closeActivity())
					.content(R.string.warning_live_video)
					.title(R.string.error_video_play)
					.onPositive((dialog, which) -> {
						youTubeVideo.playVideoExternally(getContext())
								.subscribe(status -> closeActivity());
					})
					.show();
		}
	}
	private void loadVideoX(boolean showMobileNetworkWarning) {
		Policy decision = Policy.ALLOW;
		// if the user is using mobile network (i.e. 4g), then warn him
		if (showMobileNetworkWarning) {
			decision = new MobileNetworkWarningDialog(requireContext())
					.onPositive((dialog, which) -> loadVideo(false))
					.onNegativeOrCancel(dialog -> closeActivity())
					.showAndGetStatus(MobileNetworkWarningDialog.ActionType.STREAM_VIDEO);
		}
		if (decision == Policy.ALLOW) {
			// if the video is NOT live
			if (!youTubeVideo.isLiveStream()) {
				stopPlayback();
				fragmentBinding.loadingVideoView.setVisibility(View.VISIBLE);
				compositeDisposable.add(
					DownloadedVideosDb.getVideoDownloadsDb().getDownloadedFileStatus(getContext(), youTubeVideo.getVideoId())
						.subscribe(status -> {
							if (status.getLocalVideoFile() != null) {
								File file = status.getLocalVideoFile();
								// If the file for this video has gone missing, remove it from the Database and then play remotely.
								if (!file.exists()) {
									Toast.makeText(getContext(),
											getContext().getString(R.string.playing_video_file_missing),
											Toast.LENGTH_LONG).show();
									loadVideo();
								} else {
									Logger.i(YouTubePlayerV1Fragment.this, ">> PLAYING LOCALLY: %s", file);
									fragmentBinding.videoView.setVideoURI(status.getUri());
								}
							} else {
								compositeDisposable.add(
										YouTubeTasks.getDesiredStream(youTubeVideo, new GetDesiredStreamListener() {
											@Override
											public void onGetDesiredStream(StreamInfo desiredStream, YouTubeVideo youTubeVideo) {
												Linker.setTextAndLinkify(videoDescriptionBinding.videoDescDescription, youTubeVideo.getDescription());
												StreamSelectionPolicy selectionPolicy = SkyTubeApp.getSettings().getDesiredVideoResolution(false).withAllowVideoOnly(false);
												StreamSelectionPolicy.StreamSelection selection = selectionPolicy.select(desiredStream);
												if (selection != null) {
													Uri uri = selection.getVideoStreamUri();
													Logger.i(YouTubePlayerV1Fragment.this, ">> PLAYING: %s", uri);
													fragmentBinding.videoView.setVideoURI(uri);
												} else {
													videoPlaybackError(selectionPolicy.getErrorMessage(getContext()));
												}
											}
											@Override
											public void onGetDesiredStreamError(Throwable throwable) {
												if (throwable != null) {
													Logger.e(YouTubePlayerV1Fragment.this, "Error getting stream info: " + throwable.getMessage(), throwable);
													videoPlaybackError(throwable.getMessage());
												}
											}
										})
								.subscribe());
							}
						}));
			} else {
				// video is live:  ask the user if he wants to play the video using an other app
				new AlertDialog.Builder(requireContext())
						.setMessage(R.string.warning_live_video)
						.setTitle(R.string.error_video_play)
						.setNegativeButton(R.string.cancel, (dialog, which) -> closeActivity())
						.setPositiveButton(R.string.ok, (dialog, which) ->
								youTubeVideo.playVideoExternally(getContext()).subscribe(status -> closeActivity()))
						.show();
			}
		}
	}
	void videoPlaybackError(String errorMessage) {
		if (playbackStateListener != null) {
			playbackStateListener.ended();
		}
		Context ctx = getContext();
		if (ctx == null) {
			Logger.e(YouTubePlayerV1Fragment.this, "Error during getting stream: %s", errorMessage);
			return;
		}
		new AlertDialog.Builder(ctx)
				.setMessage(errorMessage)
				.setTitle(R.string.error_video_play)
				.setCancelable(false)
				.setPositiveButton(R.string.ok, (dialog, which) -> closeActivity())
				.show();
	}
	////////////////////////////////////////////////////////////////////////////////////////////////
	@Override
	public void videoPlaybackStopped() {
		int position = fragmentBinding.videoView.getCurrentPosition();
		stopPlayback();
		saveVideoPosition(position);
	}
	private void saveVideoPosition(int position) {
		compositeDisposable.add(
				PlaybackStatusDb.getPlaybackStatusDb().setVideoPositionInBackground(youTubeVideo, position));
	}
	@Override
	public YouTubeVideo getYouTubeVideo() {
		return youTubeVideo;
	}
	@Override
	public int getCurrentVideoPosition() {
		return fragmentBinding.videoView.getCurrentPosition();
	}
	@Override
	public boolean isPlaying() {
		return fragmentBinding.videoView.isPlaying();
	}
	private void stopPlayback() {
		fragmentBinding.videoView.pause();
		fragmentBinding.videoView.stopPlayback();
		if (playbackStateListener != null) {
			playbackStateListener.ended();
		}
	}
	@Override
	public void pause() {
		fragmentBinding.videoView.pause();
		if (playbackStateListener != null && !fragmentBinding.videoView.isPlaying()) {
			playbackStateListener.paused();
		}
	}
	@Override
	public void play() {
		fragmentBinding.videoView.start();
		if (playbackStateListener != null && fragmentBinding.videoView.isPlaying()) {
			playbackStateListener.started();
		}
	}
	@Override
	public void setPlaybackStateListener(PlaybackStateListener listener) {
		playbackStateListener = listener;
	}
}
/*
 * SkyTube
 * Copyright (C) 2023  Zsombor Gegesy
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.gui.businessobjects.views;
import android.content.Context;
import android.view.Menu;
import android.view.MenuItem;
import androidx.annotation.Nullable;
import free.rm.skytube.R;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.businessobjects.db.SubscriptionsDb;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
public class ChannelActionHandler {
    private CompositeDisposable compositeDisposable;
    public ChannelActionHandler(CompositeDisposable compositeDisposable) {
        this.compositeDisposable = compositeDisposable;
    }
    public boolean handleChannelActions(Context context, YouTubeChannel channel, int itemId) {
        switch (itemId) {
            case R.id.subscribe_channel:
                compositeDisposable.add(DatabaseTasks.subscribeToChannel(true, null, context, channel.getChannelId(), true).subscribe());
                return true;
            case R.id.unsubscribe_channel:
                compositeDisposable.add(DatabaseTasks.subscribeToChannel(false,
                        null, context, channel.getChannelId(), true).subscribe());
                return true;
            case R.id.open_channel:
                SkyTubeApp.launchChannel(channel.getChannelId(), context);
                return true;
            case R.id.block_channel:
                compositeDisposable.add(channel.blockChannel().subscribe());
                return true;
            case R.id.unblock_channel:
                compositeDisposable.add(channel.unblockChannel().subscribe());
                return true;
            case R.id.share_channel:
                SkyTubeApp.shareUrl(context, channel.getChannelUrl());
                return true;
            case R.id.channel_copyurl:
                SkyTubeApp.copyUrl(context, "Channel URL", channel.getChannelUrl());
                return true;
        }
        return false;
    }
    public void updateSubscribeMenuItem(@Nullable ChannelId channelId, Menu menu) {
        setVisible(menu, R.id.open_channel, channelId != null);
        if (channelId != null) {
            compositeDisposable.add(SubscriptionsDb.getSubscriptionsDb().getUserSubscribedToChannel(channelId)
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe((subscribed) -> {
                        setVisible(menu, R.id.subscribe_channel, !subscribed);
                        setVisible(menu, R.id.unsubscribe_channel, subscribed);
                    }));
        }
    }
    public void updateBlockingMenuItem(Menu menu) {
        boolean visibility = SkyTubeApp.getSettings().isEnableVideoBlocker();
        setVisible(menu, R.id.block_channel, visibility);
        setVisible(menu, R.id.unblock_channel, visibility);
    }
    private void setVisible(Menu menu, int id, boolean visible) {
        MenuItem item = menu.findItem(id);
        if (item != null) {
            item.setVisible(visible);
        }
    }
}
/*
 * SkyTube
 * Copyright (C) 2018  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.gui.businessobjects.adapters;
import android.content.Context;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;
import com.bumptech.glide.Glide;
import com.bumptech.glide.request.RequestOptions;
import java.util.Iterator;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.businessobjects.YouTube.POJOs.ChannelView;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.databinding.SubChannelBinding;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
/**
 * Channel subscriptions adapter: Contains a list of channels (that the user subscribed to) together
 * with a notification whether the channel has new videos since last visit to the channel or not.
 */
public class SubsAdapter extends RecyclerViewAdapterEx<ChannelView, SubsAdapter.SubChannelViewHolder> {
	private static final String TAG = SubsAdapter.class.getSimpleName();
	private String searchText;
	private final CompositeDisposable compositeDisposable = new CompositeDisposable();
	public SubsAdapter(Context context, View progressBar) {
		super(context);
		// populate this adapter with user's subscribed channels
		executeQuery(null, progressBar);
	}
	/**
	 * Remove channel from this adapter.
	 *
	 * @param channelId Channel to remove.
	 */
	public void removeChannel(ChannelId channelId) {
		int size = getItemCount();
		for (int i = 0; i < size; i++) {
			if (get(i).getId().equals(channelId)) {
				remove(i);
				return;
			}
		}
		Log.e(TAG, "Channel not removed from adapter:  id=" + channelId);
	}
	/**
	 * Changes the channel's 'new videos' status.  The channel's view is then refreshed.
	 *
	 * @param channelId Channel ID.
	 * @param newVideos 'New videos' status (true = new videos have been added since user's last
	 *                  visit;  false = no new videos)
	 * @return True if the operations have been successful; false otherwise.
	 */
	public boolean changeChannelNewVideosStatus(ChannelId channelId, boolean newVideos) {
		ChannelView channel;
		int position = 0;
		for (Iterator<ChannelView> i = getIterator(); i.hasNext(); position++) {
			channel = i.next();
			if (channel.getId() != null && channel.getId().equals(channelId)) {
				// change the 'new videos' status
				channel.setNewVideosSinceLastVisit(newVideos);
				// we now need to notify the SubsAdapter to remove the new videos notification (near the channel name)
				updateView(position);
				return true;
			}
		}
		return false;
	}
	/**
	 * Update the contents of a view (i.e. refreshes the given view).
	 *
	 * @param viewPosition The position of the view that we want to update.
	 */
	private void updateView(int viewPosition) {
		notifyItemChanged(viewPosition);
	}
	@Override
	@NonNull
	public SubChannelViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
		SubChannelBinding binding = SubChannelBinding.inflate(LayoutInflater.from(parent.getContext()),
				parent, false);
		return new SubChannelViewHolder(binding);
	}
	@Override
	public void onBindViewHolder(SubChannelViewHolder viewHolder, int position) {
		viewHolder.updateInfo(get(position));
	}
	/**
	 * This should be called only from MainFragment
	 */
	public void refreshSubsList() {
		clearList();
		executeQuery(searchText, null);
	}
	private void refreshFilteredSubsList(String searchText) {
		clearList();
		executeQuery(searchText, null);
	}
	private void executeQuery(String searchText, View progressBar) {
		compositeDisposable.add(DatabaseTasks.getSubscribedChannelView(getContext(), progressBar, searchText)
				.subscribe(this::appendList));
	}
	public void filterSubSearch(String searchText){
		this.searchText = searchText;
		refreshFilteredSubsList(searchText);
	}
	////////////////////////////////////////////////////////////////////////////////////////////////
	class SubChannelViewHolder extends RecyclerView.ViewHolder {
		private final SubChannelBinding binding;
		private ChannelView channel;
		SubChannelViewHolder(SubChannelBinding binding) {
			super(binding.getRoot());
			this.binding = binding;
			binding.getRoot().setOnClickListener(v -> {
				ChannelId channelId = channel.getId();
				EventBus.getInstance().notifyMainActivities(listener -> {
					listener.onChannelClick(channelId);
				});
			});
		}
		void updateInfo(ChannelView channel) {
			Glide.with(itemView.getContext().getApplicationContext())
					.load(channel.getThumbnailUrl())
					.apply(new RequestOptions().placeholder(R.drawable.channel_thumbnail_default))
					.into(binding.subChannelThumbnailImageView);
            final String prefix;
            switch (channel.status()) {
                case ACCOUNT_TERMINATED: {
                    prefix = itemView.getContext().getString(R.string.status_account_terminated);
                    break;
                }
                case NOT_EXISTS: {
                    prefix = itemView.getContext().getString(R.string.status_not_exists);
                    break;
                }
                default: {
                    prefix = "";
                    break;
                }
            }
			binding.subChannelNameTextView.setText(prefix + channel.getTitle());
			binding.subChannelNewVideosNotification.setVisibility(channel.isNewVideosSinceLastVisit() ? View.VISIBLE : View.INVISIBLE);
			this.channel = channel;
		}
	}
}
/*
 * SkyTube
 * Copyright (C) 2018  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.gui.businessobjects.adapters;
import android.content.Context;
import android.content.Intent;
import android.view.Menu;
import android.view.View;
import androidx.annotation.MenuRes;
import androidx.annotation.NonNull;
import androidx.appcompat.widget.PopupMenu;
import androidx.recyclerview.widget.RecyclerView;
import com.bumptech.glide.Glide;
import com.bumptech.glide.request.RequestOptions;
import java.io.Serializable;
import free.rm.skytube.R;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.app.enums.Policy;
import free.rm.skytube.businessobjects.YouTube.POJOs.CardData;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubePlaylist;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.businessobjects.db.DownloadedVideosDb;
import free.rm.skytube.businessobjects.db.PlaybackStatusDb;
import free.rm.skytube.businessobjects.db.SubscriptionsDb;
import free.rm.skytube.databinding.VideoCellBinding;
import free.rm.skytube.gui.activities.ThumbnailViewerActivity;
import free.rm.skytube.gui.businessobjects.MainActivityListener;
import free.rm.skytube.gui.businessobjects.MobileNetworkWarningDialog;
import free.rm.skytube.gui.businessobjects.YouTubePlayer;
import free.rm.skytube.gui.businessobjects.views.ChannelActionHandler;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
/**
 * A ViewHolder for the videos grid view.
 */
public class GridViewHolder extends RecyclerView.ViewHolder implements Serializable {
	/** YouTube video */
	private CardData currentCard = null;
	private Context context = null;
	private MainActivityListener mainActivityListener;
	private boolean showChannelInfo;
	private final transient VideoCellBinding binding;
	private final transient CompositeDisposable compositeDisposable;
	private final transient ChannelActionHandler actionHandler;
	/**
	 * Constructor.
	 *
	 * @param binding           Cell binding (parent).
	 * @param listener          MainActivity listener.
	 * @param showChannelInfo   True to display channel information (e.g. channel name) and allows
	 *                          user to open and browse the channel; false to hide such information.
	 */
	GridViewHolder(@NonNull VideoCellBinding binding, MainActivityListener listener,
				   boolean showChannelInfo) {
		super(binding.getRoot());
		this.binding = binding;
		this.mainActivityListener = listener;
		this.showChannelInfo = showChannelInfo;
		compositeDisposable = new CompositeDisposable();
		actionHandler = new ChannelActionHandler(compositeDisposable);
		binding.thumbnailImageView.setOnClickListener(thumbnailView -> {
			if (currentCard instanceof YouTubeVideo) {
				YouTubePlayer.launch((YouTubeVideo) currentCard, context);
			} else if (currentCard instanceof YouTubePlaylist) {
				mainActivityListener.onPlaylistClick((YouTubePlaylist) currentCard);
			} else if (currentCard instanceof YouTubeChannel) {
				mainActivityListener.onChannelClick(((YouTubeChannel) currentCard).getChannelId());
			}
		});
		View.OnClickListener channelOnClickListener = v -> {
			if(mainActivityListener != null) {
				if (currentCard instanceof YouTubeVideo) {
					mainActivityListener.onChannelClick(((YouTubeVideo) currentCard).getChannelId());
				} else if (currentCard instanceof YouTubePlaylist) {
					mainActivityListener.onPlaylistClick((YouTubePlaylist) currentCard);
				}
			}
		};
		binding.channelLayout.setOnClickListener(showChannelInfo ? channelOnClickListener : null);
		binding.optionsButton.setOnClickListener(this::onOptionsButtonClick);
	}
	void clearBackgroundTasks() {
		compositeDisposable.clear();
	}
	/**
	 * Updates the contents of this ViewHolder such that the data of these views is equal to the
	 * given youTubeVideo.
	 *
	 * @param currentCard		{@link YouTubeVideo} or {@link YouTubePlaylist} instance.
	 */
	void updateInfo(@NonNull CardData currentCard, Context context, MainActivityListener listener) {
		this.currentCard = currentCard;
		this.context = context;
		this.mainActivityListener = listener;
		updateViewsData();
	}
	/**
	 * This method will update the {@link View}s of this object reflecting this GridView's video.
	 *
	 */
	public void updateViewsData() {
		binding.titleTextView.setText(currentCard.getTitle());
		if (currentCard.getPublishTimestamp() != null) {
			binding.publishDateTextView.setText(currentCard.getPublishDatePretty());
		} else {
			binding.publishDateTextView.setVisibility(View.GONE);
			binding.separatorTextView.setVisibility(View.GONE);
		}
		Glide.with(context)
				.load(currentCard.getThumbnailUrl())
				.apply(new RequestOptions().placeholder(R.drawable.thumbnail_default))
				.into(binding.thumbnailImageView);
		if (currentCard instanceof YouTubeVideo) {
			updateViewsData((YouTubeVideo) currentCard);
		} else if (currentCard instanceof YouTubePlaylist) {
			updateViewsData((YouTubePlaylist) currentCard);
		} else if (currentCard instanceof YouTubeChannel) {
			updateViewsData((YouTubeChannel) currentCard);
		}
	}
	private void updateViewsData(@NonNull YouTubeChannel currentCard) {
		if (currentCard.getSubscriberCount() >= 0) {
			binding.viewsTextView.setText(currentCard.getTotalSubscribers());
		} else {
			// the subscriber count is hidden/disabled
			binding.viewsTextView.setVisibility(View.GONE);
			binding.separatorTextView.setVisibility(View.GONE);
		}
		binding.thumbsUpTextView.setVisibility(View.GONE);
		binding.videoDurationTextView.setVisibility(View.GONE);
		binding.videoPositionProgressBar.setVisibility(View.GONE);
		binding.channelTextView.setVisibility(View.GONE);
	}
	private void updateViewsData(@NonNull YouTubePlaylist playlistInfoItem) {
		binding.viewsTextView.setText(String.format(context.getString(R.string.num_videos), playlistInfoItem.getVideoCount()));
		binding.thumbsUpTextView.setVisibility(View.GONE);
		binding.videoDurationTextView.setVisibility(View.GONE);
		binding.channelTextView.setVisibility(View.GONE);
		binding.optionsButton.setVisibility(View.GONE);
		binding.videoPositionProgressBar.setVisibility(View.GONE);
	}
    private void updateViewsData(@NonNull YouTubeVideo youTubeVideo) {
        binding.channelTextView.setText(showChannelInfo ? youTubeVideo.getChannelName() : "");
        binding.videoDurationTextView.setText(youTubeVideo.getDuration());
        binding.viewsTextView.setText(youTubeVideo.getViewsCount());
        if (youTubeVideo.getThumbsUpPercentageStr() != null) {
            binding.thumbsUpTextView.setVisibility(View.VISIBLE);
            binding.thumbsUpTextView.setText(youTubeVideo.getThumbsUpPercentageStr());
        } else {
            binding.thumbsUpTextView.setVisibility(View.INVISIBLE);
        }
        if(SkyTubeApp.getSettings().isPlaybackStatusEnabled()) {
            PlaybackStatusDb.getPlaybackStatusDb().getVideoWatchedStatusAsync(youTubeVideo.getId()).subscribe(videoWatchedStatus -> {
                if (videoWatchedStatus.isWatched()) {
                    binding.videoPositionProgressBar.setVisibility(View.VISIBLE);
                    binding.videoPositionProgressBar.setMax(youTubeVideo.getDurationInSeconds() * 1000);
                    if (videoWatchedStatus.isFullyWatched()) {
                        binding.videoPositionProgressBar.setProgress(youTubeVideo.getDurationInSeconds() * 1000);
                    } else {
                        binding.videoPositionProgressBar.setProgress((int) videoWatchedStatus.getPosition());
                    }
                } else {
                    binding.videoPositionProgressBar.setVisibility(View.INVISIBLE);
                }
            });
        } else {
            binding.videoPositionProgressBar.setVisibility(View.INVISIBLE);
        }
    }
 	private void onOptionsButtonClick(final View view) {
		if (currentCard instanceof YouTubeVideo) {
			onOptionsButtonClick(view, (YouTubeVideo) currentCard);
		} else if (currentCard instanceof YouTubeChannel) {
			onOptionsButtonClick(view, (YouTubeChannel) currentCard);
		}
	}
	private void onOptionsButtonClick(final View view, YouTubeChannel channel) {
		final PopupMenu popupMenu = createPopup(R.menu.channel_options_menu, view);
		Menu menu = popupMenu.getMenu();
		actionHandler.updateSubscribeMenuItem(channel.getChannelId(), menu);
		popupMenu.setOnMenuItemClickListener(item ->
			actionHandler.handleChannelActions(context, channel, item.getItemId())
		);
		popupMenu.show();
	}
	private void onOptionsButtonClick(final View view, YouTubeVideo youTubeVideo) {
		final PopupMenu popupMenu = createPopup(R.menu.video_options_menu, view);
		final Menu menu = popupMenu.getMenu();
		compositeDisposable.add(DatabaseTasks.isVideoBookmarked(youTubeVideo.getId(), menu));
		// If playback history is not disabled, see if this video has been watched. Otherwise, hide the "mark watched" & "mark unwatched" options from the menu.
		if (SkyTubeApp.getSettings().isPlaybackStatusEnabled()) {
			compositeDisposable.add(DatabaseTasks.isVideoWatched(youTubeVideo.getId(), menu));
		} else {
			menu.findItem(R.id.mark_watched).setVisible(false);
			menu.findItem(R.id.mark_unwatched).setVisible(false);
		}
		boolean online = SkyTubeApp.isConnected(view.getContext());
		menu.findItem(R.id.download_video).setVisible(false);
		menu.findItem(R.id.delete_download).setVisible(false);
		compositeDisposable.add(DownloadedVideosDb.getVideoDownloadsDb().isVideoDownloaded(youTubeVideo).subscribe(isDownloaded -> {
			if(isDownloaded) {
				menu.findItem(R.id.delete_download).setVisible(true);
			} else {
				menu.findItem(R.id.download_video).setVisible(online);
			}
		}));
		actionHandler.updateBlockingMenuItem(menu);
		actionHandler.updateSubscribeMenuItem(youTubeVideo.getChannelId(), menu);
		popupMenu.setOnMenuItemClickListener(item -> {
			if (actionHandler.handleChannelActions(context, youTubeVideo.getChannel(), item.getItemId())) {
				return true;
			}
			switch(item.getItemId()) {
				case R.id.menu_open_video_with:
					compositeDisposable.add(youTubeVideo.playVideoExternally(context).subscribe());
					return true;
				case R.id.share:
					youTubeVideo.shareVideo(view.getContext());
					return true;
				case R.id.copyurl:
					youTubeVideo.copyUrl(context);
					return true;
				case R.id.mark_watched:
					compositeDisposable.add(
							PlaybackStatusDb.getPlaybackStatusDb().setVideoWatchedStatusInBackground(youTubeVideo, true)
									.subscribe((success) -> updateViewsData()));
					return true;
				case R.id.mark_unwatched:
					compositeDisposable.add(
							PlaybackStatusDb.getPlaybackStatusDb().setVideoWatchedStatusInBackground(youTubeVideo, false)
									.subscribe((success) -> updateViewsData()));
					return true;
				case R.id.bookmark_video:
					compositeDisposable.add(youTubeVideo.bookmarkVideo(context, menu).subscribe());
					return true;
				case R.id.unbookmark_video:
					compositeDisposable.add(youTubeVideo.unbookmarkVideo(context, menu).subscribe());
					return true;
				case R.id.view_thumbnail:
					Intent i = new Intent(context, ThumbnailViewerActivity.class);
					i.putExtra(ThumbnailViewerActivity.YOUTUBE_VIDEO, youTubeVideo);
					context.startActivity(i);
					return true;
				case R.id.delete_download:
					compositeDisposable.add(
							DownloadedVideosDb.getVideoDownloadsDb().removeDownload(context, youTubeVideo.getVideoId()).subscribe());
					return true;
				case R.id.download_video:
					final Policy decision = new MobileNetworkWarningDialog(view.getContext())
							.showDownloadWarning(youTubeVideo);
					if (decision == Policy.ALLOW) {
						youTubeVideo.downloadVideo(context).subscribe();
					}
					return true;
			}
			return false;
		});
		popupMenu.show();
	}
	private PopupMenu createPopup(@MenuRes int menuId, View view) {
		final PopupMenu popupMenu = new PopupMenu(view.getContext(), view);
		popupMenu.getMenuInflater().inflate(menuId, popupMenu.getMenu());
		return popupMenu;
	}
}
/*
 * SkyTube
 * Copyright (C) 2016  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.gui.fragments;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AccelerateDecelerateInterpolator;
import androidx.annotation.NonNull;
import androidx.appcompat.app.ActionBar;
import androidx.core.view.ViewCompat;
import androidx.fragment.app.FragmentManager;
import androidx.fragment.app.FragmentPagerAdapter;
import androidx.viewpager.widget.ViewPager;
import com.bumptech.glide.Glide;
import com.bumptech.glide.request.RequestOptions;
import com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton;
import com.google.android.material.tabs.TabLayout;
import com.mikepenz.iconics.IconicsDrawable;
import com.mikepenz.iconics.typeface.library.materialdesigniconic.MaterialDesignIconic;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import free.rm.skytube.R;
import free.rm.skytube.app.EventBus;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.databinding.FragmentChannelBrowserBinding;
import free.rm.skytube.gui.businessobjects.fragments.FragmentEx;
import free.rm.skytube.gui.businessobjects.fragments.TabFragment;
import free.rm.skytube.gui.businessobjects.views.ChannelSubscriber;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
/**
 * A Fragment that displays information about a channel.
 *
 * This fragment is made up of three other fragments:
 * <ul>
 *     <li>{@link ChannelVideosFragment}</li>
 *     <li>{@link ChannelPlaylistsFragment}.</li>
 *     <li>{@link ChannelAboutFragment}.</li>
 * </ul>
 */
public class ChannelBrowserFragment extends FragmentEx implements ChannelSubscriber {
	private YouTubeChannel		channel;
	private ChannelId channelId;
	private Boolean 			userSubscribed;
	public static final String FRAGMENT_CHANNEL_VIDEOS = "ChannelBrowserFragment.FRAGMENT_CHANNEL_VIDEOS";
	public static final String FRAGMENT_CHANNEL_PLAYLISTS = "ChannelBrowserFragment.FRAGMENT_CHANNEL_PLAYLISTS";
	private FragmentChannelBrowserBinding binding;
	private CompositeDisposable          disposable = new CompositeDisposable();
	public static final String CHANNEL_OBJ = "ChannelBrowserFragment.ChannelObj";
	public static final String CHANNEL_ID  = "ChannelBrowserFragment.ChannelID";
	// The fragments that will be displayed
	private ChannelVideosFragment       channelVideosFragment;
	private ChannelPlaylistsFragment    channelPlaylistsFragment;
	private ChannelAboutFragment        channelAboutFragment;
	private ChannelPagerAdapter channelPagerAdapter;
	@Override
	public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		if(savedInstanceState != null) {
			channelVideosFragment = (ChannelVideosFragment)getChildFragmentManager().getFragment(savedInstanceState, FRAGMENT_CHANNEL_VIDEOS);
			channelPlaylistsFragment = (ChannelPlaylistsFragment)getChildFragmentManager().getFragment(savedInstanceState, FRAGMENT_CHANNEL_PLAYLISTS);
		}
		// inflate the layout for this fragment
		binding = FragmentChannelBrowserBinding.inflate(inflater, container, false);
		binding.channelSubscribeButton.setIcon(new IconicsDrawable(getContext(),MaterialDesignIconic.Icon.gmi_favorite));
		binding.tabLayout.setupWithViewPager(binding.pager);
		binding.tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {
			@Override
			public void onTabSelected(TabLayout.Tab tab) {
				binding.pager.setCurrentItem(tab.getPosition());
			}
			@Override
			public void onTabUnselected(TabLayout.Tab tab) {
			}
            @Override
            public void onTabReselected(TabLayout.Tab tab) {
                //When current tab reselected scroll to the top of the video list
                TabFragment tabFragment = channelPagerAdapter.getItem(tab.getPosition());
                if (tabFragment instanceof VideosGridFragment) {
                    ((VideosGridFragment)tabFragment).scrollToTop();
                }
            }
		});
		binding.pager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
			@Override
			public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
			}
			@Override
			public void onPageSelected(int position) {
				if (channelPagerAdapter != null) {
					channelPagerAdapter.getItem(position).onFragmentSelected();
				}
			}
			@Override
			public void onPageScrollStateChanged(int state) {
			}
		});
		// setup the toolbar/actionbar
		setSupportActionBar(binding.toolbar);
		getSupportActionBar().setDisplayHomeAsUpEnabled(true);
		binding.channelSubscribeButton.setOnClickListener(view -> {
			if (userSubscribed != null && channel != null) {
				startAnimation(view);
				disposable.add(
					DatabaseTasks.subscribeToChannel(!userSubscribed, ChannelBrowserFragment.this, getContext(), channelId, true).subscribe(result -> {
						ViewCompat.animate(view).setDuration(200);
						view.setRotation(0);
					})
				);
			}
		});
		getChannelParameters();
		return binding.getRoot();
	}
	@Override
	public void onDestroy() {
		if (disposable != null) {
			disposable.dispose();
		}
		binding = null;
		super.onDestroy();
	}
	private static void startAnimation(View fab) {
		fab.setRotation(0);
		ViewCompat.animate(fab)
				.rotation(360)
				.withLayer()
				//.setDuration(1000)
				.setInterpolator(new AccelerateDecelerateInterpolator())
				.start();
	}
	@Override
	public void setSubscribedState(boolean subscribed) {
		final ExtendedFloatingActionButton channelSubscribeButton = binding.channelSubscribeButton;
		channelSubscribeButton.setVisibility(View.VISIBLE);
		userSubscribed = subscribed;
		if (subscribed) {
			channelSubscribeButton.setIcon(new IconicsDrawable(getContext(), MaterialDesignIconic.Icon.gmi_eye_off));
			channelSubscribeButton.setText(R.string.unsubscribe);
		} else {
			channelSubscribeButton.setIcon(new IconicsDrawable(getContext(), MaterialDesignIconic.Icon.gmi_eye));
			channelSubscribeButton.setText(R.string.subscribe);
		}
	}
	private void setChannel(YouTubeChannel channel) {
		this.channel = channel;
		if (channel != null) {
			this.channelId = channel.getChannelId();
		} else {
			this.channelId = null;
		}
	}
	private void getChannelParameters() {
		// we need to create a YouTubeChannel object:  this can be done by either:
		//   (1) the YouTubeChannel object is passed to this Fragment
		//   (2) passing the channel ID... a task is then created to create a YouTubeChannel
		//       instance using the given channel ID
		final Bundle bundle = getArguments();
		final ChannelId oldChannelId = this.channelId;
		Logger.i(ChannelBrowserFragment.this, "getChannelParameters " + bundle);
		if (bundle != null  &&  bundle.getSerializable(CHANNEL_OBJ) != null) {
			setChannel((YouTubeChannel) bundle.getSerializable(CHANNEL_OBJ));
		} else {
			channelId = new ChannelId(bundle.getString(CHANNEL_ID));
			if (!Objects.equals(oldChannelId, channelId)) {
				this.channel = null;
			}
		}
		if (channel == null) {
			disposable.add(DatabaseTasks.getChannelInfo(requireContext(), channelId, false)
				.subscribe(youTubeChannel -> {
					if (youTubeChannel == null) {
						return;
					}
					// In the event this fragment is passed a channel id and not a channel object, set the
					// channel the subscribe button is for since there wasn't a channel object to set when
					// the button was created.
					channel = youTubeChannel.channel();
					initViews();
				}));
		} else {
			initViews();
		}
	}
	@Override
	public synchronized void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		outState.putString(CHANNEL_ID, channelId.getRawId());
		// if channel is not null, the ChannelPagerAdapter is initialized, with all the sub-fragments
		if (channel != null) {
			outState.putSerializable(CHANNEL_OBJ, channel);
			if (channelVideosFragment != null) {
				getChildFragmentManager().putFragment(outState, FRAGMENT_CHANNEL_VIDEOS, channelVideosFragment);
			}
			if (channelPlaylistsFragment != null) {
				getChildFragmentManager().putFragment(outState, FRAGMENT_CHANNEL_PLAYLISTS, channelPlaylistsFragment);
			}
		}
	}
	private FragmentManager getChildFragmentManagerSafely() {
		try {
			return getChildFragmentManager();
		} catch (IllegalStateException e) {
			Logger.e(this, "Fragment mapper is not available, as the Fragment is not attached :"+e.getMessage(), e);
			return null;
		}
	}
	/**
	 * Initialise views that are related to {@link #channel}.
	 */
	private synchronized void initViews() {
		if (channel != null) {
			FragmentManager fm = getChildFragmentManagerSafely();
			if (fm == null) {
				return;
			}
			channelPagerAdapter = new ChannelPagerAdapter(fm);
			binding.pager.setOffscreenPageLimit(2);
			binding.pager.setAdapter(channelPagerAdapter);
			this.channelVideosFragment.setYouTubeChannel(channel);
			this.channelVideosFragment.onFragmentSelected();
			Glide.with(requireContext())
					.load(channel.getThumbnailUrl())
					.apply(new RequestOptions().placeholder(R.drawable.channel_thumbnail_default))
					.into(binding.channelThumbnailImageView);
			Glide.with(requireContext())
					.load(channel.getBannerUrl())
					.apply(new RequestOptions().placeholder(R.drawable.banner_default))
					.into(binding.channelBannerImageView);
			if (channel.getSubscriberCount() >= 0) {
				binding.channelSubsTextView.setText(channel.getTotalSubscribers());
			} else {
				Logger.i(this, "Channel subscriber count for %s is %s", channel.getTitle(), channel.getSubscriberCount());
				binding.channelSubsTextView.setVisibility(View.GONE);
			}
			ActionBar actionBar = getSupportActionBar();
			if (actionBar != null) {
				actionBar.setTitle(channel.getTitle());
			}
			// if the user has subscribed to this channel, then change the state of the
			// subscribe button
			setSubscribedState(channel.isUserSubscribed());
			if (userSubscribed) {
				// the user is visiting the channel, so we need to update the last visit time
				channel.updateLastVisitTime();
				// since we are visiting the channel, then we need to disable the new videos notification
				EventBus.getInstance().notifyChannelNewVideosStatus(channel.getChannelId(), false);
			}
		}
	}
	////////////////////////////////////////////////////////////////////////////////////////////////
	private class ChannelPagerAdapter extends FragmentPagerAdapter {
		/** List of fragments that will be displayed as tabs. */
		private final List<TabFragment> channelBrowserFragmentList = new ArrayList<>();
		public ChannelPagerAdapter(FragmentManager fm) {
			super(fm, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);
			// Initialize fragments
			if (channelVideosFragment == null) {
				channelVideosFragment = new ChannelVideosFragment();
			}
			if (channelPlaylistsFragment == null) {
				channelPlaylistsFragment = new ChannelPlaylistsFragment();
			}
			if (channelAboutFragment == null) {
				channelAboutFragment = new ChannelAboutFragment();
			}
			Bundle bundle = new Bundle();
			bundle.putSerializable(CHANNEL_OBJ, channel);
			channelVideosFragment.setArguments(bundle);
			channelPlaylistsFragment.setArguments(bundle);
			channelAboutFragment.setArguments(bundle);
			channelBrowserFragmentList.add(channelVideosFragment);
			channelBrowserFragmentList.add(channelPlaylistsFragment);
			channelBrowserFragmentList.add(channelAboutFragment);
		}
		@Override
		public TabFragment getItem(int position) {
			return channelBrowserFragmentList.get(position);
		}
		@Override
		public int getCount() {
			return channelBrowserFragmentList.size();
		}
		@Override
		public CharSequence getPageTitle(int position) {
			return channelBrowserFragmentList.get(position).getFragmentName();
		}
	}
	/**
	 * Return the Channel Playlists Fragment. This is needed so that the fragment can have a reference to MainActivity
	 * @return {@link free.rm.skytube.gui.fragments.ChannelPlaylistsFragment}
	 */
	public ChannelPlaylistsFragment getChannelPlaylistsFragment() {
		if(channelPlaylistsFragment == null)
			channelPlaylistsFragment = new ChannelPlaylistsFragment();
		return channelPlaylistsFragment;
	}
}
/*
 * SkyTube
 * Copyright (C) 2018  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.gui.businessobjects.views;
import android.content.Context;
import android.util.AttributeSet;
import android.view.View;
import android.widget.RemoteViews;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.google.android.material.button.MaterialButton;
import free.rm.skytube.R;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.newpipe.ChannelId;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
/**
 * The (channel) subscribe button.
 */
@RemoteViews.RemoteView
public class SubscribeButton extends MaterialButton implements View.OnClickListener, ChannelSubscriber {
	/** Is user subscribed to a channel? */
	private boolean isUserSubscribed = false;
	private ChannelId channelId;
	private OnClickListener externalClickListener = null;
	private final CompositeDisposable compositeDisposable = new CompositeDisposable();
	public SubscribeButton(Context context, AttributeSet attrs) {
		super(context, attrs);
		super.setOnClickListener(this);
	}
	@Override
	public void onClick(View view) {
		// Need to handle externalClickListener first, in case this Button is used by the ChannelBrowserFragment,
		// which will save the channel's videos to the channel object from the video grid. The channels will then be saved
		// by the SubscribeToChannelTask.
		if(externalClickListener != null) {
			externalClickListener.onClick(SubscribeButton.this);
		}
		if(channelId != null) {
			compositeDisposable.add(DatabaseTasks.subscribeToChannel(!isUserSubscribed,
					this, getContext(), channelId, true).subscribe());
		}
	}
	@Override
	public void setOnClickListener(@Nullable OnClickListener l) {
		externalClickListener = l;
		super.setOnClickListener(this);
	}
	public void clearBackgroundTasks() {
		compositeDisposable.clear();
	}
	public void setChannelInfo(@NonNull PersistentChannel persistentChannel) {
		this.channelId = persistentChannel.getChannelId();
		setSubscribedState(persistentChannel.isSubscribed());
	}
	/**
	 * Set the button's state to subscribe or unsubscribe (i.e. once clicked, the user indicates that he wants to
	 * unsubscribe).
	 */
	@Override
	public void setSubscribedState(boolean subscribed) {
		isUserSubscribed = subscribed;
		if (subscribed) {
			// the user is subscribed currently
			setText(R.string.unsubscribe);
		} else {
			// the user is currently NOT subscribed
			setText(R.string.subscribe);
		}
	}
}
package free.rm.skytube.gui.fragments;
import android.os.Bundle;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.SeekBar;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.bumptech.glide.Glide;
import com.bumptech.glide.request.RequestOptions;
import com.google.android.gms.cast.MediaInfo;
import com.google.android.gms.cast.MediaStatus;
import com.google.android.gms.cast.framework.media.RemoteMediaClient;
import free.rm.skytube.R;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.databinding.FragmentChromecastControllerBinding;
import free.rm.skytube.databinding.VideoDescriptionBinding;
import free.rm.skytube.gui.businessobjects.views.Linker;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
/**
 * Fragment class that is used for Chromecast control. This Fragment is full screen, and can be accessed by clicking on
 * {@link ChromecastMiniControllerFragment} or dragging it up.
 */
public class ChromecastControllerFragment extends ChromecastBaseControllerFragment implements SeekBar.OnSeekBarChangeListener {
	public static final String CHROMECAST_CONTROLLER_FRAGMENT = "free.rm.skytube.CHROMECAST_CONTROLLER_FRAGMENT";
	private FragmentChromecastControllerBinding fragmentBinding;
	private VideoDescriptionBinding videoDescriptionBinding;
	private final CompositeDisposable compositeDisposable = new CompositeDisposable();
	@Nullable
	@Override
	public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
		fragmentBinding = FragmentChromecastControllerBinding.inflate(inflater, container, false);
		videoDescriptionBinding = fragmentBinding.videoDescription;
		chromecastPlaybackProgressBar = fragmentBinding.chromecastPlaybackProgressBar;
		playButton = fragmentBinding.playButton;
		pauseButton = fragmentBinding.pauseButton;
		forwardButton = fragmentBinding.forwardButton;
		rewindButton = fragmentBinding.rewindButton;
		stopButton = fragmentBinding.stopButton;
		bufferingSpinner = fragmentBinding.bufferingSpinner;
		Linker.configure(videoDescriptionBinding.videoDescDescription, null);
		fragmentBinding.chromecastPlaybackProgressBar.setOnSeekBarChangeListener(this);
		if(savedInstanceState != null) {
			setupDescription();
		}
		return fragmentBinding.getRoot();
	}
	@Override
	public void onDestroy() {
		compositeDisposable.clear();
		super.onDestroy();
	}
	@Override
	public void init(RemoteMediaClient client, MediaInfo media, int position) {
		super.init(client, media, position);
		if(video != null) {
			setupDescription();
		}
		fragmentBinding.duration.setMilliseconds(chromecastPlaybackProgressBar.getMax());
		if(!media.getMetadata().getImages().isEmpty()) {
			Glide.with(getContext())
							.load(media.getMetadata().getImages().get(0).getUrl().toString())
							.apply(new RequestOptions().placeholder(R.drawable.thumbnail_default))
							.into(fragmentBinding.videoImage);
		}
	}
	private void setupDescription() {
		if(video == null)
			return;
		Linker.setTextAndLinkify(videoDescriptionBinding.videoDescDescription, video.getDescription());
		videoDescriptionBinding.videoDescTitle.setText(video.getTitle());
		videoDescriptionBinding.videoDescChannel.setText(video.getChannelName());
		videoDescriptionBinding.videoDescPublishDate.setText(video.getPublishDatePretty());
		videoDescriptionBinding.videoDescViews.setText(video.getViewsCount());
		if (video.isThumbsUpPercentageSet()) {
			videoDescriptionBinding.videoDescLikesBar.setProgress(video.getThumbsUpPercentage());
			videoDescriptionBinding.videoDescLikes.setText(video.getLikeCount());
			videoDescriptionBinding.videoDescDislikes.setText(video.getDislikeCount());
		} else {
			videoDescriptionBinding.videoDescLikesBar.setVisibility(View.INVISIBLE);
			videoDescriptionBinding.videoDescLikes.setVisibility(View.INVISIBLE);
			videoDescriptionBinding.videoDescDislikes.setVisibility(View.INVISIBLE);
			videoDescriptionBinding.videoDescRatingsDisabled.setVisibility(View.VISIBLE);
		}
		compositeDisposable.add(
				DatabaseTasks.getChannelInfo(requireContext(), video.getChannelId(), false)
						.subscribe(subscribedChannel -> {
                            YouTubeChannel youTubeChannel = subscribedChannel.channel();
                            videoDescriptionBinding.videoDescSubscribeButton.setChannelInfo(subscribedChannel);
							Glide.with(requireContext())
									.load(youTubeChannel.getThumbnailUrl())
									.apply(new RequestOptions().placeholder(R.drawable.channel_thumbnail_default))
									.into(videoDescriptionBinding.videoDescChannelThumbnailImageView);
						})
		);
	}
	@Override
	public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
		if (!fromUser && fragmentBinding.duration.getMilliseconds() != seekBar.getMax())
			fragmentBinding.duration.setMilliseconds(seekBar.getMax());
		fragmentBinding.currentRuntime.setMilliseconds(progress);
	}
	@Override
	public void setProgress(int progress) {
		super.setProgress(progress);
		fragmentBinding.currentRuntime.setMilliseconds(progress);
	}
	@Override
	public void setDuration(int duration) {
		super.setDuration(duration);
		fragmentBinding.duration.setMilliseconds(duration);
	}
	@Override
	public void onStartTrackingTouch(SeekBar seekBar) {
		isSeeking = true;
	}
	@Override
	public void onStopTrackingTouch(SeekBar seekBar) {
		isSeeking = false;
		remoteMediaClient.seek(seekBar.getProgress());
		if(remoteMediaClient.getPlayerState() == MediaStatus.PLAYER_STATE_PAUSED)
			remoteMediaClient.play();
	}
	@Override
	protected long getProgressBarPeriod() {
		return 1000;
	}
}
/*
 * SkyTube
 * Copyright (C) 2018  Ramon Mifsud
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation (version 3 of the License).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package free.rm.skytube.gui.fragments;
import static free.rm.skytube.gui.activities.YouTubePlayerActivity.YOUTUBE_VIDEO_OBJ;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Rect;
import android.media.AudioManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.widget.BaseExpandableListAdapter;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.appcompat.widget.Toolbar;
import androidx.core.content.ContextCompat;
import androidx.media.AudioManagerCompat;
import com.bumptech.glide.Glide;
import com.bumptech.glide.request.RequestOptions;
import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.DefaultLoadControl;
import com.google.android.exoplayer2.DefaultRenderersFactory;
import com.google.android.exoplayer2.ExoPlaybackException;
import com.google.android.exoplayer2.ExoPlayerFactory;
import com.google.android.exoplayer2.Player;
import com.google.android.exoplayer2.SimpleExoPlayer;
import com.google.android.exoplayer2.source.UnrecognizedInputFormatException;
import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
import com.google.android.exoplayer2.trackselection.TrackSelection;
import com.google.android.exoplayer2.ui.AspectRatioFrameLayout;
import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
import org.schabi.newpipe.extractor.StreamingService;
import org.schabi.newpipe.extractor.stream.StreamInfo;
import java.util.Locale;
import free.rm.skytube.R;
import free.rm.skytube.app.Settings;
import free.rm.skytube.app.SkyTubeApp;
import free.rm.skytube.app.StreamSelectionPolicy;
import free.rm.skytube.app.Utils;
import free.rm.skytube.app.enums.Policy;
import free.rm.skytube.businessobjects.Logger;
import free.rm.skytube.businessobjects.Sponsorblock.SBSegment;
import free.rm.skytube.businessobjects.Sponsorblock.SBTasks;
import free.rm.skytube.businessobjects.Sponsorblock.SBTimeBarView;
import free.rm.skytube.businessobjects.Sponsorblock.SBVideoInfo;
import free.rm.skytube.businessobjects.YouTube.POJOs.PersistentChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeChannel;
import free.rm.skytube.businessobjects.YouTube.POJOs.YouTubeVideo;
import free.rm.skytube.businessobjects.YouTube.YouTubeTasks;
import free.rm.skytube.businessobjects.YouTube.newpipe.ContentId;
import free.rm.skytube.businessobjects.YouTube.newpipe.VideoId;
import free.rm.skytube.businessobjects.db.DatabaseTasks;
import free.rm.skytube.businessobjects.db.DownloadedVideosDb;
import free.rm.skytube.businessobjects.db.PlaybackStatusDb;
import free.rm.skytube.businessobjects.interfaces.GetDesiredStreamListener;
import free.rm.skytube.businessobjects.interfaces.PlaybackStateListener;
import free.rm.skytube.businessobjects.interfaces.YouTubePlayerActivityListener;
import free.rm.skytube.businessobjects.interfaces.YouTubePlayerFragmentInterface;
import free.rm.skytube.databinding.FragmentYoutubePlayerV2Binding;
import free.rm.skytube.databinding.VideoDescriptionBinding;
import free.rm.skytube.gui.activities.ThumbnailViewerActivity;
import free.rm.skytube.gui.businessobjects.DatasourceBuilder;
import free.rm.skytube.gui.businessobjects.MobileNetworkWarningDialog;
import free.rm.skytube.gui.businessobjects.PlaybackSpeedController;
import free.rm.skytube.gui.businessobjects.PlayerViewGestureDetector;
import free.rm.skytube.gui.businessobjects.ResumeVideoTask;
import free.rm.skytube.gui.businessobjects.SkyTubeMaterialDialog;
import free.rm.skytube.gui.businessobjects.adapters.CommentsAdapter;
import free.rm.skytube.gui.businessobjects.fragments.ImmersiveModeFragment;
import free.rm.skytube.gui.businessobjects.views.ChannelActionHandler;
import free.rm.skytube.gui.businessobjects.views.Linker;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
import io.reactivex.rxjava3.internal.functions.Functions;
/**
 * A fragment that holds a standalone YouTube player (version 2).
 */
@RequiresApi(api = 14)
public class YouTubePlayerV2Fragment extends ImmersiveModeFragment implements YouTubePlayerFragmentInterface, Linker.CurrentActivity {
    private static final String TAG = YouTubePlayerV2Fragment.class.getSimpleName();
    private YouTubeVideo youTubeVideo = null;
    private VideoId videoId;
    private YouTubeChannel youTubeChannel = null;
    private FragmentYoutubePlayerV2Binding fragmentBinding;
    private VideoDescriptionBinding videoDescriptionBinding;
    private SimpleExoPlayer player;
    private long playerInitialPosition = 0;
    private DatasourceBuilder datasourceBuilder;
    private Menu menu = null;
    private BaseExpandableListAdapter commentsAdapter = null;
    private YouTubePlayerActivityListener listener = null;
    private PlayerViewGestureHandler playerViewGestureHandler;
    private PlaybackSpeedController playbackSpeedController;
    private final CompositeDisposable compositeDisposable = new CompositeDisposable();
    private final ChannelActionHandler actionHandler = new ChannelActionHandler(compositeDisposable);
    private boolean videoIsPlaying;
    private PlaybackStateListener playbackStateListener = null;
    private SBVideoInfo sponsorBlockVideoInfo;
    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        hideNavigationBar();
        playerViewGestureHandler = new PlayerViewGestureHandler(SkyTubeApp.getSettings());
        // inflate the layout for this fragment
        fragmentBinding = FragmentYoutubePlayerV2Binding.inflate(inflater, container, false);
        videoDescriptionBinding = fragmentBinding.desContent;
        // indicate that this fragment has an action bar menu
        setHasOptionsMenu(true);
        if (youTubeVideo == null) {
            // initialise the views
            initViews();
            // get which video we need to play...
            Intent intent = requireActivity().getIntent();
            Bundle bundle = intent.getExtras();
            if (bundle != null && bundle.getSerializable(YOUTUBE_VIDEO_OBJ) != null) {
                // ... either the video details are passed through the previous activity
                setYouTubeVideo((YouTubeVideo) bundle.getSerializable(YOUTUBE_VIDEO_OBJ));
                setUpHUDAndPlayVideo();
                fetchVideoInformations();
            } else {
                // ... or the video URL is passed to SkyTube via another Android app
                final ContentId contentId = SkyTubeApp.getUrlFromIntent(requireContext(), intent);
                openVideo(contentId);
            }
        }
        return fragmentBinding.getRoot();
    }
    private TextView getPlaybackSpeedTextView() {
        return fragmentBinding.getRoot().findViewById(R.id.playbackSpeed);
    }
    private void openVideo(ContentId contentId) {
        Utils.isTrue(contentId.getType() == StreamingService.LinkType.STREAM, "Content is a video:" + contentId);
        compositeDisposable.add(YouTubeTasks.getVideoDetails(requireContext(), contentId)
            .subscribe(video -> {
                if (video == null) {
                    // invalid URL error (i.e. we are unable to decode the URL)
                    String err = String.format(getString(R.string.error_invalid_url), contentId.getCanonicalUrl());
                    Toast.makeText(getActivity(), err, Toast.LENGTH_LONG).show();
                    // log error
                    Logger.e(this, err);
                    // close the video player activity
                    closeActivity();
                } else {
                    setYouTubeVideo(video);
                    // setup the HUD and play the video
                    setUpHUDAndPlayVideo();
                    fetchVideoInformations();
                    // will now check if the video is bookmarked or not (and then update the menu
                    // accordingly)
                    compositeDisposable.add(DatabaseTasks.isVideoBookmarked(youTubeVideo.getId(), menu));
                }
            }));
    }
    protected void setYouTubeVideo(YouTubeVideo video) {
        this.youTubeVideo = video;
        this.videoId = video != null ? video.getVideoId() : null;
    }
    @Override
    public void onAttach(@NonNull Context context) {
        super.onAttach(context);
        try {
            Activity activity = (Activity) context;
            listener = (YouTubePlayerActivityListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException("YouTubePlayerFragment must be instantiated from an Activity that implements YouTubePlayerActivityListener");
        }
    }
    /**
     * Initialise the views.
     */
    private void initViews() {
        // setup the toolbar / actionbar
        Toolbar toolbar = fragmentBinding.getRoot().findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        getSupportActionBar().setDisplayShowHomeEnabled(true);
        // setup the player
        playerViewGestureHandler.initView();
        fragmentBinding.playerView.setOnTouchListener(playerViewGestureHandler);
        fragmentBinding.playerView.requestFocus();
        setupPlayer();
        // ensure that videos are played in their correct aspect ratio
        fragmentBinding.playerView.setResizeMode(AspectRatioFrameLayout.RESIZE_MODE_FIT);
        videoDescriptionBinding.videoDescChannelThumbnailImageView.setOnClickListener(v -> {
            if (youTubeChannel != null) {
                SkyTubeApp.launchChannel(youTubeChannel, getActivity());
            }
        });
        fragmentBinding.commentsDrawer.setOnDrawerOpenListener(() -> {
            if (commentsAdapter == null) {
                commentsAdapter = CommentsAdapter.createAdapter(getActivity(), this, youTubeVideo.getId(),
                        fragmentBinding.commentsExpandableListView, fragmentBinding.commentsProgressBar,
                        fragmentBinding.noVideoCommentsTextView, fragmentBinding.videoCommentsAreDisabled);
            }
        });
        this.playbackSpeedController = new PlaybackSpeedController(getContext(),
                getPlaybackSpeedTextView(), player);
        //set playback speed
        float playbackSpeed = SkyTubeApp.getSettings().getDefaultPlaybackSpeed();
        playbackSpeedController.setPlaybackSpeed(playbackSpeed);
        Linker.configure(videoDescriptionBinding.videoDescDescription, this);
    }
    private synchronized void setupPlayer() {
        if (fragmentBinding.playerView.getPlayer() == null) {
            if (player == null) {
                player = createExoPlayer();
                datasourceBuilder = new DatasourceBuilder(getContext(), player);
            } else {
                Logger.i(this, ">> found already existing player, re-using it, to avoid duplicate usage");
            }
            player.addListener(new Player.EventListener() {
                @Override
                public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
                    Logger.i(this, ">> onPlayerStateChanged " + playWhenReady + " state=" + playbackState);
                    videoIsPlaying = playbackState == Player.STATE_READY && playWhenReady;
                    if (videoIsPlaying) {
                        preventDeviceSleeping(true);
                        playbackSpeedController.updateMenu();
                    } else {
                        preventDeviceSleeping(false);
                    }
                    if (playbackStateListener != null) {
                        boolean videoIsPaused = playbackState == Player.STATE_READY && !playWhenReady;
                        if (videoIsPlaying) {
                            playbackStateListener.started();
                        } else if (videoIsPaused) {
                            playbackStateListener.paused();
                        } else {
                            playbackStateListener.ended();
                        }
                    }
                }
                @Override
                public void onPlayerError(ExoPlaybackException error) {
                    Logger.e(this, ":: onPlayerError " + error.getMessage(), error);
                    saveVideoPosition();
                    if (playbackStateListener != null) {
                        playbackStateListener.ended();
                    }
                    boolean askForDelete = askForDelete(error);
                    String errorMessage = error.getCause().getMessage();
                    Context ctx = YouTubePlayerV2Fragment.this.getContext();
                    new SkyTubeMaterialDialog(ctx)
                            .onNegativeOrCancel(dialog -> closeActivity())
                            .content(askForDelete ? R.string.error_downloaded_file_is_corrupted : R.string.error_video_parse_error, errorMessage)
                            .title(R.string.error_video_play)
                            .negativeText(R.string.close)
                            .positiveText(null)
                            .positiveText(askForDelete ? R.string.delete_download : 0)
                            .onPositive((dialog, which) -> {
                                if (askForDelete) {
                                    compositeDisposable.add(
                                            DownloadedVideosDb.getVideoDownloadsDb().removeDownload(ctx, youTubeVideo.getVideoId())
                                                    .subscribe(
                                                            status -> closeActivity(),
                                                            err -> Logger.e(YouTubePlayerV2Fragment.this, "Error:" + err.getMessage(), err)));
                                } else {
                                    closeActivity();
                                }
                            }).show();
                }
                private boolean askForDelete(ExoPlaybackException error) {
                    Throwable cause = error.getCause();
                    if (cause instanceof UnrecognizedInputFormatException) {
                        UnrecognizedInputFormatException uie = (UnrecognizedInputFormatException) cause;
                        return "file".equals(uie.uri.getScheme());
                    }
                    return false;
                }
            });
            player.setPlayWhenReady(true);
            player.setVideoScalingMode(C.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING);    // ensure that videos are played in their correct aspect ratio
            fragmentBinding.playerView.setPlayer(player);
        }
    }
    private SimpleExoPlayer createExoPlayer() {
        DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
        TrackSelection.Factory videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory();
        DefaultTrackSelector trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
        Context context = getContext();
        DefaultRenderersFactory defaultRenderersFactory = new DefaultRenderersFactory(context);
        return ExoPlayerFactory.newSimpleInstance(getContext(), defaultRenderersFactory, trackSelector, new DefaultLoadControl(), null, bandwidthMeter);
    }
    /**
     * Will setup the HUD's details according to the contents of {@link #youTubeVideo}.  Then it
     * will try to load and play the video.
     */
    private void setUpHUDAndPlayVideo() {
        setupInfoDisplay(youTubeVideo);
        new ResumeVideoTask(getContext(), youTubeVideo.getId(), position -> {
            playerInitialPosition = position;
            YouTubePlayerV2Fragment.this.loadVideo();
        }).ask();
    }
    private void setupInfoDisplay(YouTubeVideo video) {
        getSupportActionBar().setTitle(video.getTitle());
        videoDescriptionBinding.videoDescTitle.setText(video.getTitle());
        videoDescriptionBinding.videoDescChannel.setText(video.getChannelName());
        videoDescriptionBinding.videoDescViews.setText(video.getViewsCount());
        videoDescriptionBinding.videoDescPublishDate.setText(video.getPublishDatePretty());
        if (video.getDescription() != null) {
            Linker.setTextAndLinkify(videoDescriptionBinding.videoDescDescription, video.getDescription());
        }
        setupLikeCounters(video);
        if (SkyTubeApp.getSettings().isSponsorblockEnabled()) {
            initSponsorBlock();
        }
    }
    private void setupLikeCounters(YouTubeVideo video) {
        final boolean hasLikes = video.getLikeCountNumber() != null;
        setTextAndVisibility(videoDescriptionBinding.videoDescLikes, hasLikes, video.getLikeCount());
        final boolean hasDislikes = video.getDislikeCountNumber() != null;
        setTextAndVisibility(videoDescriptionBinding.videoDescDislikes, hasDislikes, video.getDislikeCount());
        setValueAndVisibility(videoDescriptionBinding.videoDescLikesBar, video.isThumbsUpPercentageSet(), video.getThumbsUpPercentage());
        setVisibility(videoDescriptionBinding.videoDescRatingsDisabled, !hasLikes && !hasDislikes);
        if (!hasDislikes) {
            YouTubeTasks.getDislikeCountFromApi(video.getId()).subscribe(dislikeCount -> {
                video.setLikeDislikeCount(video.getLikeCountNumber(), dislikeCount);
                final boolean hasDislikesFresh = video.getDislikeCountNumber() != null;
                setTextAndVisibility(videoDescriptionBinding.videoDescDislikes, hasDislikesFresh, video.getDislikeCount());
                setVisibility(videoDescriptionBinding.videoDescRatingsDisabled, !hasLikes && !hasDislikesFresh);
            });
        }
    }
    /**
     * Retrieve the sponsorBlock information, either from the internal downloaded videos table, or from the network.
     */
    private void retrieveSponsorBlockIfPossible() {
        if (SkyTubeApp.getSettings().isSponsorblockEnabled()) {
            if (sponsorBlockVideoInfo == null) {
                sponsorBlockVideoInfo = DownloadedVideosDb.getVideoDownloadsDb().getDownloadedVideoSponsorblock(youTubeVideo.getId());
                if (sponsorBlockVideoInfo == null) {
                    sponsorBlockVideoInfo = SBTasks.retrieveSponsorblockSegmentsBk(youTubeVideo.getVideoId());
                }
                initSponsorBlock();
            }
        }
    }
    private void initSponsorBlock() {
        if (sponsorBlockVideoInfo != null) {
            Log.d(TAG, "SBInfo has loaded");
            Handler handler = new Handler(Looper.getMainLooper());
            for (SBSegment segment : sponsorBlockVideoInfo.getSegments()) {
                long startPosMs = Math.round(segment.getStartPos() * 1000);
                player.createMessage((messageType, payload) -> {
                            SBSegment payloadSegment = (SBSegment) payload;
                            handler.post(() -> {
                                SBTasks.LabelAndColor labelAndColor = SBTasks.getLabelAndColor(payloadSegment.getCategory());
                                if (labelAndColor != null) {
                                    String categoryLabel = getString(labelAndColor.label);
                                    Toast.makeText(getContext(),
                                            getString(R.string.sponsorblock_skipped, categoryLabel),
                                            Toast.LENGTH_SHORT).show();
                                } else {
                                    Log.w(TAG, "Unknown sponsorBlock category: " + payloadSegment.getCategory());
                                }
                            });
                            long pos = Math.round(payloadSegment.getEndPos() * 1000);
                            player.seekTo(pos);
                        })
                        .setHandler(handler)
                        .setPosition(startPosMs)
                        .setPayload(segment)
                        .setDeleteAfterDelivery(false)
                        .send();
            }
            SBTimeBarView sbView = fragmentBinding.getRoot().findViewById(R.id.exo_sponsorblock_progress);
            if (sbView != null) {
                sbView.setSegments(sponsorBlockVideoInfo);
            } else {
                Log.e(TAG, "SBView not found!");
            }
        } else {
            Log.d(TAG, "SBInfo not loaded yet");
        }
    }
    private void setTextAndVisibility(TextView view, boolean visible, String text) {
        setVisibility(view, visible);
        if (visible) {
            view.setText(text);
        }
    }
    private void setValueAndVisibility(ProgressBar view, boolean visible, int percentage) {
        setVisibility(view, visible);
        if (visible) {
            view.setProgress(percentage);
        }
    }
    private void setVisibility(View view, boolean visible) {
        view.setVisibility(visible ? View.VISIBLE : View.GONE);
    }
    /**
     * Loads the video specified in {@link #youTubeVideo}.
     */
    private void loadVideo() {
        loadVideo(true);
    }
    private void preventDeviceSleeping(boolean flag) {
        // prevent the device from sleeping while playing
        Activity activity = getActivity();
        if (activity != null) {
            Window window = activity.getWindow();
            if (window != null) {
                if (flag) {
                    Logger.i(this, ">> Setting FLAG_KEEP_SCREEN_ON");
                    window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                } else {
                    Logger.i(this, ">> Clearing FLAG_KEEP_SCREEN_ON");
                    window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                }
            }
        }
    }
    /**
     * Loads the video specified in {@link #videoId}.
     *
     * @param showMobileNetworkWarning Set to true to show the warning displayed when the user is
     *                                 using mobile network data (i.e. 4g).
     */
    private void loadVideo(boolean showMobileNetworkWarning) {
        Context ctx = getContext();
        compositeDisposable.add(
                DownloadedVideosDb.getVideoDownloadsDb().getDownloadedFileStatus(ctx, videoId)
                        .subscribe(downloadStatus -> {
                            Policy decision = Policy.ALLOW;
                            // if the user is using mobile network (i.e. 4g), then warn him
                            if (showMobileNetworkWarning && downloadStatus.getUri() == null) {
                                decision = new MobileNetworkWarningDialog(getActivity())
                                        .onPositive((dialog, which) -> loadVideo(false))
                                        .onNegativeOrCancel((dialog) -> closeActivity())
                                        .showAndGetStatus(MobileNetworkWarningDialog.ActionType.STREAM_VIDEO);
                            }
                            if (decision == Policy.ALLOW) {
                                // if the video is NOT live
                                if (!youTubeVideo.isLiveStream()) {
                                    fragmentBinding.loadingVideoView.setVisibility(View.VISIBLE);
                                    if (downloadStatus.isDisappeared()) {
                                        // If the file for this video has gone missing, warn and then play remotely.
                                        Toast.makeText(getContext(),
                                                getString(R.string.playing_video_file_missing),
                                                Toast.LENGTH_LONG).show();
                                        loadVideo();
                                        return;
                                    }
                                    if (downloadStatus.getUri() != null) {
                                        fragmentBinding.loadingVideoView.setVisibility(View.GONE);
                                        Logger.i(this, ">> PLAYING LOCALLY: %s", downloadStatus.getUri());
                                        playVideo(downloadStatus.getUri(), downloadStatus.getAudioUri(), null);
                                        retrieveSponsorBlockIfPossible();
                                        // get the video statistics
                                        compositeDisposable.add(YouTubeTasks.getVideoDetails(ctx, youTubeVideo.getVideoId())
                                                .subscribe(video -> {
                                                    if (video != null) {
                                                        setupInfoDisplay(video);
                                                    }
                                                }));
                                    } else {
                                        compositeDisposable.add(
                                                YouTubeTasks.getDesiredStream(youTubeVideo,
                                                        new GetDesiredStreamListener() {
                                                            @Override
                                                            public void onGetDesiredStream(StreamInfo desiredStream, YouTubeVideo video) {
                                                                // hide the loading video view (progress bar)
                                                                fragmentBinding.loadingVideoView.setVisibility(View.GONE);
                                                                // Play the video.  Check if this fragment is visible before playing the
                                                                // video.  It might not be visible if the user clicked on the back button
                                                                // before the video streams are retrieved (such action would cause the app
                                                                // to crash if not catered for...).
                                                                if (isVisible()) {
                                                                    StreamSelectionPolicy selectionPolicy = SkyTubeApp.getSettings().getDesiredVideoResolution(false);
                                                                    StreamSelectionPolicy.StreamSelection selection = selectionPolicy.select(desiredStream);
                                                                    if (selection != null) {
                                                                        Uri uri = selection.getVideoStreamUri();
                                                                        Logger.i(YouTubePlayerV2Fragment.this, ">> PLAYING: %s, audio: %s", uri, selection.getAudioStreamUri());
                                                                        playVideo(uri, selection.getAudioStreamUri(), desiredStream);
                                                                        setupInfoDisplay(video);
                                                                    } else {
                                                                        videoPlaybackError(selectionPolicy.getErrorMessage(getContext()));
                                                                    }
                                                                }
                                                            }
                                                            @Override
                                                            public void onGetDesiredStreamError(Throwable throwable) {
                                                                if (throwable != null) {
                                                                    videoPlaybackError(throwable.getMessage());
                                                                }
                                                            }
                                                        }).subscribe());
                                    }
                                } else {
                                    openAsLiveStream();
                                }
                            }
                        }));
    }
    private void videoPlaybackError(String errorMessage) {
        Context ctx = getContext();
        if (ctx == null) {
            Logger.e(YouTubePlayerV2Fragment.this, "Error during getting stream: %s", errorMessage);
            return;
        }
        new SkyTubeMaterialDialog(ctx)
                .content(errorMessage)
                .title(R.string.error_video_play)
                .cancelable(false)
                .onPositive((dialog, which) -> closeActivity())
                .show();
    }
    private void openAsLiveStream() {
        // else, if the video is a LIVE STREAM
        // video is live:  ask the user if he wants to play the video using an other app
        Context ctx = getContext();
        if (ctx != null) {
            new SkyTubeMaterialDialog(ctx)
                    .onNegativeOrCancel((dialog) -> closeActivity())
                    .content(R.string.warning_live_video)
                    .title(R.string.error_video_play)
                    .onPositive((dialog, which) -> {
                        youTubeVideo.playVideoExternally(getContext())
                                .subscribe(status -> closeActivity());
                    })
                    .show();
        }
    }
    /**
     * Play video.
     *
     * @param videoUri   The Uri of the video that is going to be played.
     * @param audioUri   The Uri of the audio part that is going to be played. Can be null.
     * @param streamInfo Additional information about the stream.
     */
    private void playVideo(Uri videoUri, @Nullable Uri audioUri, @Nullable StreamInfo streamInfo) {
        datasourceBuilder.play(videoUri, audioUri, streamInfo);
        if (playerInitialPosition > 0) {
            player.seekTo(playerInitialPosition);
        }
    }
    @Override
    public void onPrepareOptionsMenu(@NonNull Menu menu) {
        DatabaseTasks.updateDownloadedVideoMenu(youTubeVideo, menu);
        final MenuItem subscribeChannel = menu.findItem(R.id.subscribe_channel);
        final MenuItem openChannel = menu.findItem(R.id.open_channel);
        if (youTubeVideo != null && youTubeVideo.getChannelId() != null) {
            if (subscribeChannel != null) {
                subscribeChannel.setVisible(true);
            }
            if (openChannel != null) {
                openChannel.setVisible(true);
            }
        } else {
            if (subscribeChannel != null) {
                subscribeChannel.setVisible(false);
            }
            if (openChannel != null) {
                openChannel.setVisible(false);
            }
        }
    }
    @Override
    public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
        inflater.inflate(R.menu.menu_youtube_player, menu);
        this.menu = menu;
        menu.findItem(R.id.disable_gestures).setChecked(playerViewGestureHandler.disableGestures);
        listener.onOptionsMenuCreated(menu);
        // Will now check if the video is bookmarked or not (and then update the menu accordingly).
        //
        // youTubeVideo might be null if we have only passed the video URL to this fragment (i.e.
        // the app is still trying to construct youTubeVideo in the background).
        if (youTubeVideo != null) {
            compositeDisposable.add(DatabaseTasks.isVideoBookmarked(youTubeVideo.getId(), menu));
        }
    }
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        Context context = getContext();
        if (actionHandler.handleChannelActions(context, youTubeChannel, item.getItemId())) {
            return true;
        }
        switch (item.getItemId()) {
            case R.id.menu_reload_video:
                player.seekToDefaultPosition();
                return true;
            case R.id.menu_open_video_with:
                player.setPlayWhenReady(false);
                compositeDisposable.add(youTubeVideo.playVideoExternally(context).subscribe());
                return true;
            case R.id.share:
                player.setPlayWhenReady(false);
                youTubeVideo.shareVideo(context);
                return true;
            case R.id.copyurl:
                youTubeVideo.copyUrl(context);
                return true;
            case R.id.bookmark_video:
                compositeDisposable.add(youTubeVideo.bookmarkVideo(context, menu).subscribe());
                return true;
            case R.id.unbookmark_video:
                compositeDisposable.add(youTubeVideo.unbookmarkVideo(context, menu).subscribe());
                return true;
            case R.id.view_thumbnail:
                Intent i = new Intent(getActivity(), ThumbnailViewerActivity.class);
                i.putExtra(ThumbnailViewerActivity.YOUTUBE_VIDEO, youTubeVideo);
                startActivity(i);
                return true;
            case R.id.download_video:
                final Policy decision = new MobileNetworkWarningDialog(context)
                        .showDownloadWarning(youTubeVideo);
                if (decision == Policy.ALLOW) {
                    youTubeVideo.downloadVideo(context).subscribe();
                }
                return true;
            case R.id.disable_gestures:
                boolean disableGestures = !item.isChecked();
                item.setChecked(disableGestures);
                SkyTubeApp.getSettings().setDisableGestures(disableGestures);
                playerViewGestureHandler.setDisableGestures(disableGestures);
                return true;
            case R.id.video_repeat_toggle:
                boolean repeat = !item.isChecked();
                player.setRepeatMode(repeat ? Player.REPEAT_MODE_ALL : Player.REPEAT_MODE_OFF);
                item.setChecked(repeat);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }
    /**
     * Called when the options menu is closed.
     *
     * <p>The Navigation Bar is displayed when the Option Menu is visible.  Hence the objective of
     * this method is to hide the Navigation Bar once the Options Menu is hidden.</p>
     */
    public void onMenuClosed() {
        hideNavigationBar();
    }
    /**
     * Will asynchronously retrieve additional video information such as channel avatar ...etc
     */
    private void fetchVideoInformations() {
        // get Channel info (e.g. avatar...etc) task
        compositeDisposable.add(
                DatabaseTasks.getChannelInfo(requireContext(), youTubeVideo.getChannelId(), false)
                        .subscribe(newPersistentChannel -> {
                            youTubeChannel = newPersistentChannel.channel();
                            videoDescriptionBinding.videoDescSubscribeButton.setChannelInfo(newPersistentChannel);
                            if (youTubeChannel != null) {
                                Glide.with(requireContext())
                                        .load(youTubeChannel.getThumbnailUrl())
                                        .apply(new RequestOptions().placeholder(R.drawable.channel_thumbnail_default))
                                        .into(videoDescriptionBinding.videoDescChannelThumbnailImageView);
                            }
                        })
        );
        if (SkyTubeApp.getSettings().isSponsorblockEnabled()) {
            compositeDisposable.add(
                    SBTasks.retrieveSponsorblockSegmentsCtx(requireContext(), youTubeVideo.getVideoId())
                            .subscribe(segments -> {
                                Log.d(TAG, "Received SB Info with " + segments.getSegments().size() + " segments for duration of " + segments.getVideoDuration());
                                sponsorBlockVideoInfo = segments;
                                initSponsorBlock();
                            }, Functions.ON_ERROR_MISSING, () -> {
                                Log.d(TAG, "No SB info received for " + youTubeVideo.getVideoId());
                            })
            );
        }
    }
    @Override
    public void videoPlaybackStopped() {
        player.stop();
        // playerView.setPlayer(null);
        saveVideoPosition();
    }
    private void saveVideoPosition() {
        compositeDisposable.add(
                PlaybackStatusDb.getPlaybackStatusDb().setVideoPositionInBackground(youTubeVideo, player.getCurrentPosition()));
    }
    @Override
    public void onDestroy() {
        compositeDisposable.clear();
        super.onDestroy();
        // stop the player from playing (when this fragment is going to be destroyed) and clean up
        player.stop();
        player.release();
        player = null;
        fragmentBinding.playerView.setPlayer(null);
        videoDescriptionBinding.videoDescSubscribeButton.clearBackgroundTasks();
        fragmentBinding = null;
        videoDescriptionBinding = null;
    }
    @Override
    public boolean canNavigateTo(ContentId contentId) {
        if (contentId instanceof VideoId) {
            VideoId newVideoId = (VideoId) contentId;
            if (videoId.isSameContent(newVideoId)) {
                // same video, maybe different timestamp?
                Integer timestamp = newVideoId.getTimestamp();
                if (timestamp != null) {
                    player.seekTo(timestamp.longValue() * 1000L);
                }
            } else {
                openVideo(newVideoId);
            }
            return true;
        }
        return false;
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * This will handle any gesture swipe event performed by the user on the player view.
     */
    class PlayerViewGestureHandler extends PlayerViewGestureDetector {
        private boolean isControllerVisible = true;
        private VideoBrightness videoBrightness;
        private float startVolumePercent = -1.0f;
        private long startVideoTime = -1;
        /**
         * Enable/Disable video gestures based on user preferences.
         */
        private boolean disableGestures;
        private static final int MAX_VIDEO_STEP_TIME = 60 * 1000;
        PlayerViewGestureHandler(Settings settings) {
            super(getContext(), settings);
            this.disableGestures = settings.isDisableGestures();
            videoBrightness = new VideoBrightness(getActivity(), disableGestures);
        }
        void initView() {
            fragmentBinding.playerView.setControllerVisibilityListener(visibility -> {
                isControllerVisible = (visibility == View.VISIBLE);
                switch (visibility) {
                    case View.VISIBLE: {
                        showNavigationBar();
                        if (fragmentBinding != null) {
                            fragmentBinding.playerView.getOverlayFrameLayout().setVisibility(View.VISIBLE);
                        }
                        break;
                    }
                    case View.GONE: {
                        hideNavigationBar();
                        if (fragmentBinding != null) {
                            fragmentBinding.playerView.getOverlayFrameLayout().setVisibility(View.GONE);
                        }
                        break;
                    }
                }
            });
        }
        @Override
        public void onCommentsGesture() {
            if (SkyTubeApp.isConnected(requireContext())) {
                fragmentBinding.commentsDrawer.animateOpen();
            } else {
                Toast.makeText(requireContext(),
                        getString(R.string.error_get_comments_no_network),
                        Toast.LENGTH_LONG).show();
            }
        }
        @Override
        public void onVideoDescriptionGesture() {
            fragmentBinding.desDrawer.animateOpen();
        }
        @Override
        public void onDoubleTap() {
            // if the user is playing a video...
            if (player.getPlayWhenReady()) {
                // pause video - without showing the controller automatically
                boolean controllerAutoshow = fragmentBinding.playerView.getControllerAutoShow();
                fragmentBinding.playerView.setControllerAutoShow(false);
                pause();
                fragmentBinding.playerView.setControllerAutoShow(controllerAutoshow);
            } else {
                // play video
                player.setPlayWhenReady(true);
                // This is to force that the automatic hiding of the controller is re-triggered.
                if (isControllerVisible) {
                    fragmentBinding.playerView.showController();
                }
            }
        }
        @Override
        public boolean onSingleTap() {
            return showOrHideHud();
        }
        /**
         * Hide or display the HUD depending if the HUD is currently visible or not.
         */
        private boolean showOrHideHud() {
            if (fragmentBinding.commentsDrawer.isOpened()) {
                fragmentBinding.commentsDrawer.animateClose();
                return !isControllerVisible;
            }
            if (fragmentBinding.desDrawer.isOpened()) {
                fragmentBinding.desDrawer.animateClose();
                return !isControllerVisible;
            }
            if (isControllerVisible) {
                fragmentBinding.playerView.hideController();
            } else {
                fragmentBinding.playerView.showController();
            }
            return false;
        }
        @Override
        public void onGestureDone() {
            videoBrightness.onGestureDone();
            startVolumePercent = -1.0f;
            startVideoTime = -1;
            hideIndicator();
        }
        @Override
        public void adjustBrightness(double adjustPercent) {
            if (disableGestures) {
                return;
            }
            // adjust the video's brightness
            videoBrightness.setVideoBrightness(adjustPercent, getActivity());
            // set indicator
            fragmentBinding.indicatorImageView.setImageResource(R.drawable.ic_brightness);
            fragmentBinding.indicatorTextView.setText(videoBrightness.getBrightnessString());
            // Show indicator. It will be hidden once onGestureDone will be called
            showIndicator();
        }
        @Override
        public void adjustVolumeLevel(double adjustPercent) {
            if (disableGestures) {
                return;
            }
            // We are setting volume percent to a value that should be from -1.0 to 1.0. We need to limit it here for these values first
            if (adjustPercent < -1.0f) {
                adjustPercent = -1.0f;
            } else if (adjustPercent > 1.0f) {
                adjustPercent = 1.0f;
            }
            AudioManager audioManager = ContextCompat.getSystemService(requireContext(), AudioManager.class);
            final int STREAM = AudioManager.STREAM_MUSIC;
            // Max volume will return INDEX of volume not the percent. For example, on my device it is 15
            int maxVolume = AudioManagerCompat.getStreamMaxVolume(audioManager, STREAM);
            if (maxVolume == 0) return;
            if (startVolumePercent < 0) {
                // We are getting actual volume index (NOT volume but index). It will be >= 0.
                int curVolume = audioManager.getStreamVolume(STREAM);
                // And counting percents of maximum volume we have now
                startVolumePercent = curVolume * 1.0f / maxVolume;
            }
            // Should be >= 0 and <= 1
            double targetPercent = startVolumePercent + adjustPercent;
            if (targetPercent > 1.0f) {
                targetPercent = 1.0f;
            } else if (targetPercent < 0) {
                targetPercent = 0;
            }
            // Calculating index. Test values are 15 * 0.12 = 1 ( because it's int)
            int index = (int) (maxVolume * targetPercent);
            if (index > maxVolume) {
                index = maxVolume;
            } else if (index < 0) {
                index = 0;
            }
            audioManager.setStreamVolume(STREAM, index, 0);
            fragmentBinding.indicatorImageView.setImageResource(R.drawable.ic_volume);
            fragmentBinding.indicatorTextView.setText(index * 100 / maxVolume + "%");
            // Show indicator. It will be hidden once onGestureDone will be called
            showIndicator();
        }
        @Override
        public void adjustVideoPosition(double adjustPercent, boolean forwardDirection) {
            if (disableGestures) {
                return;
            }
            long totalTime = player.getDuration();
            if (adjustPercent < -1.0f) {
                adjustPercent = -1.0f;
            } else if (adjustPercent > 1.0f) {
                adjustPercent = 1.0f;
            }
            if (startVideoTime < 0) {
                startVideoTime = player.getCurrentPosition();
            }
            // adjustPercent: value from -1 to 1.
            double positiveAdjustPercent = Math.max(adjustPercent, -adjustPercent);
            // End of line makes seek speed not linear
            long targetTime = startVideoTime + (long) (MAX_VIDEO_STEP_TIME * adjustPercent * (positiveAdjustPercent / 0.1));
            if (targetTime > totalTime) {
                targetTime = totalTime;
            }
            if (targetTime < 0) {
                targetTime = 0;
            }
            String targetTimeString = formatDuration(targetTime / 1000);
            if (forwardDirection) {
                fragmentBinding.indicatorImageView.setImageResource(R.drawable.ic_forward);
            } else {
                fragmentBinding.indicatorImageView.setImageResource(R.drawable.ic_rewind);
            }
            fragmentBinding.indicatorTextView.setText(targetTimeString);
            showIndicator();
            player.seekTo(targetTime);
        }
        @Override
        public Rect getPlayerViewRect() {
            return new Rect(fragmentBinding.playerView.getLeft(), fragmentBinding.playerView.getTop(),
                    fragmentBinding.playerView.getRight(), fragmentBinding.playerView.getBottom());
        }
        private void showIndicator() {
            fragmentBinding.indicatorView.setVisibility(View.VISIBLE);
        }
        private void hideIndicator() {
            fragmentBinding.indicatorView.setVisibility(View.GONE);
        }
        /**
         * Returns a (localized) string for the given duration (in seconds).
         *
         * @param duration
         * @return a (localized) string for the given duration (in seconds).
         */
        private String formatDuration(long duration) {
            long h = duration / 3600;
            long m = (duration - h * 3600) / 60;
            long s = duration - (h * 3600 + m * 60);
            String durationValue;
            if (h == 0) {
                durationValue = String.format(Locale.getDefault(), "%1$02d:%2$02d", m, s);
            } else {
                durationValue = String.format(Locale.getDefault(), "%1$d:%2$02d:%3$02d", h, m, s);
            }
            return durationValue;
        }
        public void setDisableGestures(boolean disableGestures) {
            this.disableGestures = disableGestures;
            this.videoBrightness.setDisableGestures(disableGestures);
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Adjust video's brightness.  Once the brightness is adjust, it is saved in the preferences to
     * be used when a new video is played.
     */
    private static class VideoBrightness {
        /**
         * Current video brightness.
         */
        private float brightness;
        /**
         * Initial video brightness.
         */
        private float initialBrightness;
        private boolean disableGestures;
        private static final String BRIGHTNESS_LEVEL_PREF = SkyTubeApp.getStr(R.string.pref_key_brightness_level);
        /**
         * Constructor:  load the previously saved video brightness from the preference and set it.
         *
         * @param activity Activity.
         */
        public VideoBrightness(final Activity activity, final boolean disableGestures) {
            loadBrightnessFromPreference();
            initialBrightness = brightness;
            this.disableGestures = disableGestures;
            setVideoBrightness(0, activity);
        }
        public void setDisableGestures(boolean disableGestures) {
            this.disableGestures = disableGestures;
        }
        /**
         * Set the video brightness.  Once the video brightness is updated, save it in the preference.
         *
         * @param adjustPercent Percentage.
         * @param activity      Activity.
         */
        public void setVideoBrightness(double adjustPercent, final Activity activity) {
            if (disableGestures) {
                return;
            }
            // We are setting brightness percent to a value that should be from -1.0 to 1.0. We need to limit it here for these values first
            if (adjustPercent < -1.0f) {
                adjustPercent = -1.0f;
            } else if (adjustPercent > 1.0f) {
                adjustPercent = 1.0f;
            }
            // set the brightness instance variable
            setBrightness(initialBrightness + (float) adjustPercent);
            // adjust the video brightness as per this.brightness
            adjustVideoBrightness(activity);
            // save brightness to the preference
            saveBrightnessToPreference();
        }
        /**
         * Adjust the video brightness.
         *
         * @param activity Current activity.
         */
        private void adjustVideoBrightness(final Activity activity) {
            WindowManager.LayoutParams lp = activity.getWindow().getAttributes();
            lp.screenBrightness = brightness;
            activity.getWindow().setAttributes(lp);
        }
        /**
         * Saves {@link #brightness} to preference.
         */
        private void saveBrightnessToPreference() {
            SharedPreferences.Editor editor = SkyTubeApp.getPreferenceManager().edit();
            editor.putFloat(BRIGHTNESS_LEVEL_PREF, brightness);
            editor.apply();
            Logger.d(this, "BRIGHTNESS: %f", brightness);
        }
        /**
         * Loads the brightness from preference and set the {@link #brightness} instance variable.
         */
        private void loadBrightnessFromPreference() {
            final float brightnessPref = SkyTubeApp.getPreferenceManager().getFloat(BRIGHTNESS_LEVEL_PREF, 1);
            setBrightness(brightnessPref);
        }
        /**
         * Set the {@link #brightness} instance variable.
         *
         * @param brightness Brightness (from 0.0 to 1.0).
         */
        private void setBrightness(float brightness) {
            if (brightness < 0) {
                brightness = 0;
            } else if (brightness > 1) {
                brightness = 1;
            }
            this.brightness = brightness;
        }
        /**
         * @return Brightness as string:  e.g. "21%"
         */
        public String getBrightnessString() {
            return ((int) (brightness * 100)) + "%";
        }
        /**
         * To be called once the swipe gesture is done/completed.
         */
        public void onGestureDone() {
            initialBrightness = brightness;
        }
    }
    @Override
    public YouTubeVideo getYouTubeVideo() {
        return youTubeVideo;
    }
    @Override
    public int getCurrentVideoPosition() {
        return (int) player.getCurrentPosition();
    }
    @Override
    public boolean isPlaying() {
        return videoIsPlaying;
    }
    @Override
    public void pause() {
        player.setPlayWhenReady(false);
    }
    @Override
    public void play() {
        player.setPlayWhenReady(true);
    }
    @Override
    public void setPlaybackStateListener(final PlaybackStateListener listener) {
        playbackStateListener = listener;
    }
}