package org.pdfsam.tools.splitbybookmarks;
import jakarta.inject.Named;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.unicons.UniconsLine;
import org.pdfsam.injector.Auto;
import org.pdfsam.injector.Provides;
import org.pdfsam.model.tool.RequiredPdfData;
import org.pdfsam.model.tool.Tool;
import org.pdfsam.model.tool.ToolCategory;
import org.pdfsam.model.tool.ToolDescriptor;
import org.pdfsam.model.tool.ToolInputOutputType;
import org.pdfsam.model.tool.ToolPriority;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.tool.Footer;
import org.pdfsam.ui.components.tool.OpenButton;
import org.pdfsam.ui.components.tool.RunButton;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.model.tool.ToolDescriptorBuilder.builder;
import static org.pdfsam.ui.components.io.PdfDestinationPane.DestinationPanelFields.DISCARD_BOOKMARKS;
@Auto
public class SplitByBookmarksTool implements Tool {
    static final String TOOL_ID = "split.bybookmarks";
    private final ToolDescriptor descriptor = builder().category(ToolCategory.SPLIT)
            .inputTypes(ToolInputOutputType.SINGLE_PDF).name(i18n().tr("Split by bookmarks"))
            .description(i18n().tr("Split a PDF document at bookmarked pages by specifying a bookmark level."))
            .priority(ToolPriority.DEFAULT.getPriority()).supportURL("https:
            .build();
    @Override
    public ToolDescriptor descriptor() {
        return descriptor;
    }
    @Override
    public String id() {
        return TOOL_ID;
    }
    @Override
    public Pane panel() {
        return app().instance(SplitByBookmarksToolPanel.class);
    }
    @Override
    public RequiredPdfData[] requires() {
        return new RequiredPdfData[] { RequiredPdfData.DEFAULT, RequiredPdfData.BOOMARKS };
    }
    @Override
    public Node graphic() {
        var icon = new FontIcon(UniconsLine.FILE_BOOKMARK_ALT);
        icon.getStyleClass().addAll(this.descriptor().category().styleClass(), "tool-icon");
        return icon;
    }
    public static class ModuleConfig {
        @Provides
        @Named(TOOL_ID + "field")
        public BrowsableOutputDirectoryField destinationDirectoryField() {
            return new BrowsableOutputDirectoryField();
        }
        @Provides
        @Named(TOOL_ID + "pane")
        public PdfDestinationPane destinationPane(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField outputField) {
            PdfDestinationPane panel = new PdfDestinationPane(outputField, TOOL_ID, DISCARD_BOOKMARKS);
            panel.enableSameAsSourceItem();
            return panel;
        }
        @Provides
        @Named(TOOL_ID + "footer")
        public Footer footer(RunButton runButton, @Named(TOOL_ID + "openButton") OpenButton openButton) {
            return new Footer(runButton, openButton, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "openButton")
        public OpenButton openButton() {
            return new OpenButton(TOOL_ID, ToolInputOutputType.MULTIPLE_PDF);
        }
        @Provides
        @Named(TOOL_ID + "prefix")
        public PrefixPane prefixPane() {
            return new PrefixPane(TOOL_ID, new PreferencesRepository("/org/pdfsam/user/conf/" + TOOL_ID));
        }
    }
}
package org.pdfsam.i18n;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ObservableValue;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.text.MessageFormat;
import java.util.Locale;
import java.util.Optional;
import java.util.ResourceBundle;
import java.util.Set;
import static java.util.Objects.nonNull;
import static java.util.Optional.empty;
import static java.util.Optional.ofNullable;
import static org.pdfsam.eventstudio.StaticStudio.eventStudio;
public final class I18nContext {
    private static final Logger LOG = LoggerFactory.getLogger(I18nContext.class);
    private final Set<Locale> supported = Set.of(Locale.of("af"), Locale.of("bs"), Locale.of("bg"), Locale.of("el"),
            Locale.of("eu"), Locale.of("pt", "BR"), Locale.SIMPLIFIED_CHINESE, Locale.TRADITIONAL_CHINESE,
            Locale.of("co"), Locale.of("ca"), Locale.of("hr"), Locale.of("cs"), Locale.of("da"), Locale.of("nl"),
            Locale.UK, Locale.FRENCH, Locale.GERMAN, Locale.of("he"), Locale.of("hi"), Locale.of("hu"), Locale.JAPANESE,
            Locale.ITALIAN, Locale.of("pl"), Locale.of("pt"), Locale.of("ro"), Locale.of("ru"), Locale.of("sk"),
            Locale.of("sl"), Locale.of("sr"), Locale.of("sv"), Locale.of("es"), Locale.of("tr"), Locale.of("uk"),
            Locale.of("fi"), Locale.of("ko"), Locale.of("oc"));
    private final SimpleObjectProperty<Locale> locale = new SimpleObjectProperty<>();
    private Optional<ResourceBundle> bundle = empty();
    I18nContext() {
        eventStudio().addAnnotatedListeners(this);
        locale.subscribe(this::loadBundles);
    }
    @EventListener
    public void setLocale(SetLocaleRequest e) {
        if (nonNull(e.languageTag()) && !e.languageTag().isBlank()) {
            LOG.trace("Setting locale to {}", e.languageTag());
            ofNullable(Locale.forLanguageTag(e.languageTag())).filter(supported::contains).ifPresent(locale::set);
        }
    }
    private void loadBundles(Locale l) {
        if (nonNull(l)) {
            Locale.setDefault(l);
            LOG.trace("Loading i18n bundle for {}", Locale.getDefault());
            try {
                this.bundle = ofNullable(ResourceBundle.getBundle("org.pdfsam.i18n.Messages", Locale.getDefault(),
                        I18nContext.class.getModule()));
                LOG.debug("Locale set to {}", Locale.getDefault());
            } catch (Exception e) {
                LOG.error("Unable to load translations bundle", e);
            }
        }
    }
    Locale getBestLocale() {
        if (supported.contains(Locale.getDefault())) {
            LOG.trace("Using best matching locale: {}", Locale.getDefault());
            return Locale.getDefault();
        }
        var onlyLanguage = Locale.of(Locale.getDefault().getLanguage());
        if (supported.contains(onlyLanguage)) {
            LOG.trace("Using supported locale closest to default {}", onlyLanguage);
            return onlyLanguage;
        }
        LOG.trace("Using fallback locale");
        return Locale.ENGLISH;
    }
    public static I18nContext i18n() {
        return I18nContextHolder.CONTEXT;
    }
    public ObservableValue<Locale> locale() {
        return this.locale;
    }
    public String tr(String text) {
        initBundleIfRequired();
        return bundle.filter(r -> r.containsKey(text)).map(r -> r.getString(text)).orElse(text);
    }
    public String tr(String text, String... replace) {
        initBundleIfRequired();
        return MessageFormat.format(tr(text), (Object[]) replace);
    }
    private void initBundleIfRequired() {
        if (bundle.isEmpty()) {
            locale.set(getBestLocale());
        }
    }
    public Set<Locale> getSupported() {
        return supported;
    }
    private static final class I18nContextHolder {
        private I18nContextHolder() {
        }
        static final I18nContext CONTEXT = new I18nContext();
    }
}
package org.pdfsam.tools.split;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.VBox;
import org.apache.commons.lang3.builder.Builder;
import org.pdfsam.core.support.params.SinglePdfSourceMultipleOutputParametersBuilder;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.pdfsam.eventstudio.annotation.EventStation;
import org.pdfsam.model.tool.ClearToolRequest;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.selection.single.TaskParametersBuilderSingleSelectionPane;
import org.pdfsam.ui.components.support.Views;
import org.pdfsam.ui.components.tool.BaseToolPanel;
import org.pdfsam.ui.components.tool.Footer;
import org.sejda.model.parameter.AbstractSplitByPageParameters;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.Optional;
import java.util.function.Consumer;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.tools.split.SplitTool.TOOL_ID;
public class SplitToolPanel extends BaseToolPanel {
    private final TaskParametersBuilderSingleSelectionPane selectionPane;
    private final BrowsableOutputDirectoryField destinationDirectoryField;
    private final PdfDestinationPane destinationPane;
    private final SplitOptionsPane splitOptions = new SplitOptionsPane();
    private final PrefixPane prefix;
    @Inject
    public SplitToolPanel(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField destinationDirectoryField,
            @Named(TOOL_ID + "pane") PdfDestinationPane destinationPane, @Named(TOOL_ID + "footer") Footer footer,
            @Named(TOOL_ID + "prefix") PrefixPane prefix) {
        super(TOOL_ID, footer);
        this.destinationDirectoryField = destinationDirectoryField;
        this.destinationPane = destinationPane;
        this.selectionPane = new TaskParametersBuilderSingleSelectionPane(id());
        this.selectionPane.setPromptText(i18n().tr("Select or drag and drop the PDF you want to split"));
        this.selectionPane.addOnLoaded(d -> splitOptions.setMaxPages(d.pages().getValue()));
        this.prefix = prefix;
        initModuleSettingsPanel(settingPanel());
    }
    @Override
    public void onSaveWorkspace(Map<String, String> data) {
        selectionPane.saveStateTo(data);
        splitOptions.saveStateTo(data);
        destinationDirectoryField.saveStateTo(data);
        destinationPane.saveStateTo(data);
        prefix.saveStateTo(data);
    }
    @Override
    public void onLoadWorkspace(Map<String, String> data) {
        selectionPane.restoreStateFrom(data);
        splitOptions.restoreStateFrom(data);
        destinationDirectoryField.restoreStateFrom(data);
        destinationPane.restoreStateFrom(data);
        prefix.restoreStateFrom(data);
    }
    @Override
    protected Builder<? extends AbstractSplitByPageParameters> getBuilder(Consumer<String> onError) {
        Optional<SinglePdfSourceMultipleOutputParametersBuilder<? extends AbstractSplitByPageParameters>> builder = Optional.ofNullable(
                splitOptions.getBuilder(onError));
        builder.ifPresent(b -> {
            selectionPane.apply(b, onError);
            destinationDirectoryField.apply(b, onError);
            destinationPane.apply(b, onError);
            prefix.apply(b, onError);
        });
        return builder.orElse(null);
    }
    private VBox settingPanel() {
        VBox pane = new VBox();
        pane.setAlignment(Pos.TOP_CENTER);
        TitledPane prefixTitled = Views.titledPane(i18n().tr("File names settings"), prefix);
        prefix.addMenuItemFor(Prefix.CURRENTPAGE);
        prefix.addMenuItemFor(Prefix.FILENUMBER);
        prefix.addMenuItemFor("[TOTAL_FILESNUMBER]");
        pane.getChildren().addAll(selectionPane, Views.titledPane(i18n().tr("Split settings"), splitOptions),
                Views.titledPane(i18n().tr("Output settings"), destinationPane), prefixTitled);
        return pane;
    }
    @EventListener
    public void onClearModule(ClearToolRequest e) {
        if (e.clearEverything()) {
            splitOptions.resetView();
            prefix.resetView();
            destinationPane.resetView();
        }
    }
    @EventStation
    public String id() {
        return TOOL_ID;
    }
}
package org.pdfsam.tools.splitbysize;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.VBox;
import org.apache.commons.lang3.builder.Builder;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.pdfsam.eventstudio.annotation.EventStation;
import org.pdfsam.model.tool.ClearToolRequest;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.selection.single.TaskParametersBuilderSingleSelectionPane;
import org.pdfsam.ui.components.support.Views;
import org.pdfsam.ui.components.tool.BaseToolPanel;
import org.pdfsam.ui.components.tool.Footer;
import org.sejda.model.parameter.SplitBySizeParameters;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.function.Consumer;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.tools.splitbysize.SplitBySizeTool.TOOL_ID;
public class SplitBySizeToolPanel extends BaseToolPanel {
    private final TaskParametersBuilderSingleSelectionPane selectionPane;
    private final BrowsableOutputDirectoryField destinationDirectoryField;
    private final PdfDestinationPane destinationPane;
    private final SplitOptionsPane splitOptions = new SplitOptionsPane();
    private final PrefixPane prefix;
    @Inject
    public SplitBySizeToolPanel(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField destinationDirectoryField,
            @Named(TOOL_ID + "pane") PdfDestinationPane destinationPane, @Named(TOOL_ID + "footer") Footer footer,
            @Named(TOOL_ID + "prefix") PrefixPane prefix) {
        super(TOOL_ID, footer);
        this.destinationDirectoryField = destinationDirectoryField;
        this.destinationPane = destinationPane;
        this.selectionPane = new TaskParametersBuilderSingleSelectionPane(id());
        this.selectionPane.setPromptText(i18n().tr("Select or drag and drop the PDF you want to split"));
        this.prefix = prefix;
        initModuleSettingsPanel(settingPanel());
    }
    @Override
    public void onSaveWorkspace(Map<String, String> data) {
        selectionPane.saveStateTo(data);
        splitOptions.saveStateTo(data);
        destinationDirectoryField.saveStateTo(data);
        destinationPane.saveStateTo(data);
        prefix.saveStateTo(data);
    }
    @Override
    public void onLoadWorkspace(Map<String, String> data) {
        selectionPane.restoreStateFrom(data);
        splitOptions.restoreStateFrom(data);
        destinationDirectoryField.restoreStateFrom(data);
        destinationPane.restoreStateFrom(data);
        prefix.restoreStateFrom(data);
    }
    @Override
    protected Builder<SplitBySizeParameters> getBuilder(Consumer<String> onError) {
        SplitBySizeParametersBuilder builder = new SplitBySizeParametersBuilder();
        splitOptions.apply(builder, onError);
        selectionPane.apply(builder, onError);
        destinationDirectoryField.apply(builder, onError);
        destinationPane.apply(builder, onError);
        prefix.apply(builder, onError);
        return builder;
    }
    private VBox settingPanel() {
        VBox pane = new VBox();
        pane.setAlignment(Pos.TOP_CENTER);
        TitledPane prefixTitled = Views.titledPane(i18n().tr("File names settings"), prefix);
        prefix.addMenuItemFor(Prefix.CURRENTPAGE);
        prefix.addMenuItemFor(Prefix.FILENUMBER);
        prefix.addMenuItemFor("[TOTAL_FILESNUMBER]");
        pane.getChildren().addAll(selectionPane, Views.titledPane(i18n().tr("Split settings"), splitOptions),
                Views.titledPane(i18n().tr("Output settings"), destinationPane), prefixTitled);
        return pane;
    }
    @EventListener
    public void onClearModule(ClearToolRequest e) {
        if (e.clearEverything()) {
            splitOptions.resetView();
            prefix.resetView();
            destinationPane.resetView();
        }
    }
    @EventStation
    public String id() {
        return TOOL_ID;
    }
}
package org.pdfsam.tools.splitbysize;
import jakarta.inject.Named;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.unicons.UniconsLine;
import org.pdfsam.injector.Auto;
import org.pdfsam.injector.Provides;
import org.pdfsam.model.tool.Tool;
import org.pdfsam.model.tool.ToolCategory;
import org.pdfsam.model.tool.ToolDescriptor;
import org.pdfsam.model.tool.ToolInputOutputType;
import org.pdfsam.model.tool.ToolPriority;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.tool.Footer;
import org.pdfsam.ui.components.tool.OpenButton;
import org.pdfsam.ui.components.tool.RunButton;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.model.tool.ToolDescriptorBuilder.builder;
import static org.pdfsam.ui.components.io.PdfDestinationPane.DestinationPanelFields.DISCARD_BOOKMARKS;
@Auto
public class SplitBySizeTool implements Tool {
    static final String TOOL_ID = "split.bysize";
    private final ToolDescriptor descriptor = builder().category(ToolCategory.SPLIT)
            .inputTypes(ToolInputOutputType.SINGLE_PDF).name(i18n().tr("Split by size"))
            .description(i18n().tr("Split a PDF document in files of the given size (roughly)."))
            .priority(ToolPriority.LOW.getPriority()).supportURL("https:
            .build();
    @Override
    public ToolDescriptor descriptor() {
        return descriptor;
    }
    @Override
    public String id() {
        return TOOL_ID;
    }
    @Override
    public Pane panel() {
        return app().instance(SplitBySizeToolPanel.class);
    }
    @Override
    public Node graphic() {
        var icon = new FontIcon(UniconsLine.ARROWS_RESIZE_H);
        icon.getStyleClass().addAll(this.descriptor().category().styleClass(), "tool-icon");
        return icon;
    }
    public static class ModuleConfig {
        @Provides
        @Named(TOOL_ID + "field")
        public BrowsableOutputDirectoryField destinationDirectoryField() {
            BrowsableOutputDirectoryField field = new BrowsableOutputDirectoryField();
            field.setId(TOOL_ID + "field");
            return field;
        }
        @Provides
        @Named(TOOL_ID + "pane")
        public PdfDestinationPane destinationPane(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField outputField) {
            PdfDestinationPane panel = new PdfDestinationPane(outputField, TOOL_ID, DISCARD_BOOKMARKS);
            panel.enableSameAsSourceItem();
            return panel;
        }
        @Provides
        @Named(TOOL_ID + "footer")
        public Footer footer(RunButton runButton, @Named(TOOL_ID + "openButton") OpenButton openButton) {
            return new Footer(runButton, openButton, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "openButton")
        public OpenButton openButton() {
            return new OpenButton(TOOL_ID, ToolInputOutputType.MULTIPLE_PDF);
        }
        @Provides
        @Named(TOOL_ID + "prefix")
        public PrefixPane prefixPane() {
            return new PrefixPane(TOOL_ID, new PreferencesRepository("/org/pdfsam/user/conf/" + TOOL_ID));
        }
    }
}
package org.pdfsam.tools.splitbybookmarks;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.VBox;
import org.apache.commons.lang3.builder.Builder;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.pdfsam.eventstudio.annotation.EventStation;
import org.pdfsam.model.tool.ClearToolRequest;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.selection.single.TaskParametersBuilderSingleSelectionPane;
import org.pdfsam.ui.components.support.Views;
import org.pdfsam.ui.components.tool.BaseToolPanel;
import org.pdfsam.ui.components.tool.Footer;
import org.sejda.model.parameter.SplitByOutlineLevelParameters;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.function.Consumer;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.tools.splitbybookmarks.SplitByBookmarksTool.TOOL_ID;
public class SplitByBookmarksToolPanel extends BaseToolPanel {
    private final TaskParametersBuilderSingleSelectionPane selectionPane;
    private final BrowsableOutputDirectoryField destinationDirectoryField;
    private final PdfDestinationPane destinationPane;
    private final SplitOptionsPane splitOptions = new SplitOptionsPane();
    private final PrefixPane prefix;
    @Inject
    public SplitByBookmarksToolPanel(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField destinationDirectoryField,
            @Named(TOOL_ID + "pane") PdfDestinationPane destinationPane, @Named(TOOL_ID + "footer") Footer footer,
            @Named(TOOL_ID + "prefix") PrefixPane prefix) {
        super(TOOL_ID, footer);
        this.destinationDirectoryField = destinationDirectoryField;
        this.destinationPane = destinationPane;
        this.selectionPane = new TaskParametersBuilderSingleSelectionPane(id());
        this.selectionPane.setPromptText(i18n().tr("Select or drag and drop the PDF you want to split"));
        this.selectionPane.addOnLoaded(d -> splitOptions.setValidBookmarkLevels(d.getValidBookmarksLevels()));
        this.prefix = prefix;
        initModuleSettingsPanel(settingPanel());
    }
    @Override
    public void onSaveWorkspace(Map<String, String> data) {
        selectionPane.saveStateTo(data);
        splitOptions.saveStateTo(data);
        destinationDirectoryField.saveStateTo(data);
        destinationPane.saveStateTo(data);
        prefix.saveStateTo(data);
    }
    @Override
    public void onLoadWorkspace(Map<String, String> data) {
        selectionPane.restoreStateFrom(data);
        splitOptions.restoreStateFrom(data);
        destinationDirectoryField.restoreStateFrom(data);
        destinationPane.restoreStateFrom(data);
        prefix.restoreStateFrom(data);
    }
    @Override
    protected Builder<SplitByOutlineLevelParameters> getBuilder(Consumer<String> onError) {
        SplitByOutlineLevelParametersBuilder builder = new SplitByOutlineLevelParametersBuilder();
        splitOptions.apply(builder, onError);
        selectionPane.apply(builder, onError);
        destinationDirectoryField.apply(builder, onError);
        destinationPane.apply(builder, onError);
        prefix.apply(builder, onError);
        return builder;
    }
    private VBox settingPanel() {
        VBox pane = new VBox();
        pane.setAlignment(Pos.TOP_CENTER);
        TitledPane prefixTitled = Views.titledPane(i18n().tr("File names settings"), prefix);
        prefix.addMenuItemFor(Prefix.CURRENTPAGE);
        prefix.addMenuItemFor(Prefix.FILENUMBER);
        prefix.addMenuItemFor(Prefix.BOOKMARK);
        prefix.addMenuItemFor(Prefix.BOOKMARK_STRICT);
        prefix.addMenuItemFor("[TOTAL_FILESNUMBER]");
        pane.getChildren().addAll(selectionPane, Views.titledPane(i18n().tr("Split settings"), splitOptions),
                Views.titledPane(i18n().tr("Output settings"), destinationPane), prefixTitled);
        return pane;
    }
    @EventStation
    public String id() {
        return TOOL_ID;
    }
    @EventListener
    public void onClearModule(ClearToolRequest e) {
        if (e.clearEverything()) {
            splitOptions.resetView();
            prefix.resetView();
            destinationPane.resetView();
        }
    }
}
package org.pdfsam.core.context;
import javafx.application.ConditionalFeature;
import javafx.application.Platform;
import javafx.scene.Scene;
import org.apache.commons.lang3.StringUtils;
import org.pdfsam.injector.Injector;
import org.pdfsam.injector.Key;
import org.pdfsam.persistence.PreferencesRepository;
import java.io.Closeable;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Objects;
import java.util.Optional;
import static java.util.function.Predicate.not;
import static org.pdfsam.core.context.StringPersistentProperty.FONT_SIZE;
import static org.pdfsam.core.context.StringPersistentProperty.WORKING_PATH;
public class ApplicationContext implements Closeable {
    private static final ApplicationContext CONTEXT = new ApplicationContext();
    private final ApplicationPersistentSettings persistentSettings;
    private ApplicationRuntimeState runtimeState;
    private Optional<Injector> injector = Optional.empty();
    private ApplicationContext() {
        this(new ApplicationPersistentSettings(new PreferencesRepository("/org/pdfsam/user/conf")), null);
    }
    @Deprecated
    ApplicationContext(ApplicationPersistentSettings persistentSettings, ApplicationRuntimeState runtimeState) {
        this.persistentSettings = persistentSettings;
        this.runtimeState = runtimeState;
    }
    public static ApplicationContext app() {
        return CONTEXT;
    }
    public ApplicationPersistentSettings persistentSettings() {
        return this.persistentSettings;
    }
    public ApplicationRuntimeState runtimeState() {
        synchronized (this) {
            if (Objects.isNull(this.runtimeState)) {
                this.runtimeState = new ApplicationRuntimeState();
                this.persistentSettings().settingsChanges(WORKING_PATH).subscribe(path -> {
                    this.runtimeState.defaultWorkingPath(
                            path.filter(StringUtils::isNotBlank).map(Paths::get).filter(Files::isDirectory)
                                    .orElse(null));
                });
                var workingPath = persistentSettings().get(WORKING_PATH).filter(StringUtils::isNotBlank).map(Paths::get)
                        .filter(Files::isDirectory).orElse(null);
                this.runtimeState.defaultWorkingPath(workingPath);
            }
        }
        return this.runtimeState;
    }
    public void registerScene(Scene scene) {
        this.runtimeState().theme().subscribe(t -> {
            if (Objects.nonNull(t)) {
                Platform.runLater(() -> {
                    scene.getStylesheets().setAll(t.stylesheets());
                    if (!Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW)) {
                        scene.getStylesheets().addAll(t.transparentIncapableStylesheets());
                    }
                });
            }
        });
        this.persistentSettings().settingsChanges(FONT_SIZE).subscribe(size -> {
            size.filter(StringUtils::isNotBlank).map(s -> String.format("-fx-font-size: %s;", s))
                    .ifPresentOrElse(scene.getRoot()::setStyle, () -> scene.getRoot().setStyle(""));
        });
        this.persistentSettings().get(FONT_SIZE).filter(not(String::isBlank))
                .ifPresent(size -> scene.getRoot().setStyle(String.format("-fx-font-size: %s;", size)));
    }
    public void injector(Injector injector) {
        this.injector = Optional.ofNullable(injector);
    }
    public <T> T instance(Class<T> type) {
        return injector.orElseThrow(() -> new IllegalStateException("Injector not set for this application"))
                .instance(type);
    }
    public <T> T instance(Key<T> key) {
        return injector.orElseThrow(() -> new IllegalStateException("Injector not set for this application"))
                .instance(key);
    }
    public void clean() {
        persistentSettings.clean();
    }
    @Override
    public void close() {
        injector.ifPresent(Injector::close);
    }
}
package org.pdfsam.tools.split;
import jakarta.inject.Named;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.unicons.UniconsLine;
import org.pdfsam.injector.Auto;
import org.pdfsam.injector.Provides;
import org.pdfsam.model.tool.Tool;
import org.pdfsam.model.tool.ToolCategory;
import org.pdfsam.model.tool.ToolDescriptor;
import org.pdfsam.model.tool.ToolInputOutputType;
import org.pdfsam.model.tool.ToolPriority;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.tool.Footer;
import org.pdfsam.ui.components.tool.OpenButton;
import org.pdfsam.ui.components.tool.RunButton;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.model.tool.ToolDescriptorBuilder.builder;
import static org.pdfsam.ui.components.io.PdfDestinationPane.DestinationPanelFields.DISCARD_BOOKMARKS;
@Auto
public class SplitTool implements Tool {
    static final String TOOL_ID = "split.simple";
    private final ToolDescriptor descriptor = builder().category(ToolCategory.SPLIT)
            .inputTypes(ToolInputOutputType.SINGLE_PDF).name(i18n().tr("Split"))
            .description(i18n().tr("Split a PDF document at the given page numbers."))
            .priority(ToolPriority.HIGH.getPriority()).supportURL("https:
            .build();
    @Override
    public ToolDescriptor descriptor() {
        return descriptor;
    }
    @Override
    public Pane panel() {
        return app().instance(SplitToolPanel.class);
    }
    @Override
    public String id() {
        return TOOL_ID;
    }
    @Override
    public Node graphic() {
        var icon = new FontIcon(UniconsLine.IMAGE_BROKEN);
        icon.getStyleClass().addAll(this.descriptor().category().styleClass(), "tool-icon");
        return icon;
    }
    public static class ModuleConfig {
        @Provides
        @Named(TOOL_ID + "field")
        public BrowsableOutputDirectoryField destinationDirectoryField() {
            return new BrowsableOutputDirectoryField();
        }
        @Provides
        @Named(TOOL_ID + "pane")
        public PdfDestinationPane destinationPane(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField outputField) {
            PdfDestinationPane panel = new PdfDestinationPane(outputField, TOOL_ID, DISCARD_BOOKMARKS);
            panel.enableSameAsSourceItem();
            return panel;
        }
        @Provides
        @Named(TOOL_ID + "footer")
        public Footer footer(RunButton runButton, @Named(TOOL_ID + "openButton") OpenButton openButton) {
            return new Footer(runButton, openButton, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "openButton")
        public OpenButton openButton() {
            return new OpenButton(TOOL_ID, ToolInputOutputType.MULTIPLE_PDF);
        }
        @Provides
        @Named(TOOL_ID + "prefix")
        public PrefixPane prefixPane() {
            return new PrefixPane(TOOL_ID, new PreferencesRepository("/org/pdfsam/user/conf/" + TOOL_ID));
        }
    }
}
package org.pdfsam.core.context;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ObservableValue;
import org.pdfsam.persistence.PersistenceException;
import org.pdfsam.persistence.PreferencesRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Arrays;
import java.util.Optional;
import static java.util.Objects.nonNull;
import static java.util.Optional.empty;
import static java.util.Optional.of;
import static java.util.Optional.ofNullable;
import static org.sejda.commons.util.RequireUtils.requireNotNullArg;
public class ApplicationPersistentSettings {
    private static final Logger LOG = LoggerFactory.getLogger(ApplicationPersistentSettings.class);
    private final PreferencesRepository repo;
    private final SimpleObjectProperty<PersistentPropertyChange<String>> stringSettingsChanges = new SimpleObjectProperty<>();
    private final SimpleObjectProperty<PersistentPropertyChange<Integer>> intSettingsChanges = new SimpleObjectProperty<>();
    private final SimpleObjectProperty<PersistentPropertyChange<Boolean>> boolSettingsChanges = new SimpleObjectProperty<>();
    ApplicationPersistentSettings(PreferencesRepository repo) {
        this.repo = repo;
    }
    public Optional<String> get(StringPersistentProperty prop) {
        requireNotNullArg(prop, "Cannot get value for a null property");
        try {
            return ofNullable(this.repo.getString(prop.key(), prop.defaultSupplier()));
        } catch (PersistenceException e) {
            LOG.error("Unable to get persistent property: " + prop, e);
        }
        return ofNullable(prop.defaultSupplier().get());
    }
    public int get(IntegerPersistentProperty prop) {
        requireNotNullArg(prop, "Cannot get value for a null property");
        try {
            return this.repo.getInt(prop.key(), prop.defaultSupplier());
        } catch (PersistenceException e) {
            LOG.error("Unable to get persistent property: " + prop, e);
        }
        return prop.defaultSupplier().get();
    }
    public boolean get(BooleanPersistentProperty prop) {
        requireNotNullArg(prop, "Cannot get value for a null property");
        try {
            return this.repo.getBoolean(prop.key(), prop.defaultSupplier());
        } catch (NumberFormatException | PersistenceException e) {
            LOG.error("Unable to get persistent property: " + prop, e);
        }
        return prop.defaultSupplier().get();
    }
    public void set(StringPersistentProperty prop, String value) {
        requireNotNullArg(prop, "Cannot set value for a null property");
        try {
            this.repo.saveString(prop.key(), value);
            stringSettingsChanges.set(new PersistentPropertyChange<>(prop, ofNullable(value)));
        } catch (PersistenceException e) {
            LOG.error("Unable to save persistent property", e);
        }
    }
    public void set(IntegerPersistentProperty prop, int value) {
        requireNotNullArg(prop, "Cannot set value for a null property");
        try {
            this.repo.saveInt(prop.key(), value);
            intSettingsChanges.set(new PersistentPropertyChange<>(prop, of(value)));
        } catch (PersistenceException e) {
            LOG.error("Unable to save persistent property", e);
        }
    }
    public void set(BooleanPersistentProperty prop, boolean value) {
        requireNotNullArg(prop, "Cannot set value for a null property");
        try {
            this.repo.saveBoolean(prop.key(), value);
            boolSettingsChanges.set(new PersistentPropertyChange<>(prop, of(value)));
        } catch (PersistenceException e) {
            LOG.error("Unable to save persistent property", e);
        }
    }
    public boolean hasValueFor(PersistentProperty<?> property) {
        if (nonNull(property)) {
            return Arrays.stream(this.repo.keys()).anyMatch(k -> k.equals(property.key()));
        }
        return false;
    }
    public void delete(PersistentProperty<?> property) {
        if (nonNull(property)) {
            this.repo.delete(property.key());
        }
    }
    public ObservableValue<Optional<String>> settingsChanges(StringPersistentProperty prop) {
        var value = new SimpleObjectProperty<Optional<String>>(empty());
        stringSettingsChanges.subscribe((old, c) -> {
            if (c.property().equals(prop)) {
                value.set(c.value());
            }
        });
        return value;
    }
    public ObservableValue<Optional<Integer>> settingsChanges(IntegerPersistentProperty prop) {
        var value = new SimpleObjectProperty<Optional<Integer>>(empty());
        intSettingsChanges.subscribe((old, c) -> {
            if (c.property().equals(prop)) {
                value.set(c.value());
            }
        });
        return value;
    }
    public ObservableValue<Optional<Boolean>> settingsChanges(BooleanPersistentProperty prop) {
        var value = new SimpleObjectProperty<Optional<Boolean>>(empty());
        boolSettingsChanges.subscribe((old, c) -> {
            if (c.property().equals(prop)) {
                value.set(c.value());
            }
        });
        return value;
    }
    public void clean() {
        try {
            this.repo.clean();
            LOG.info("Persistent application settings deleted");
        } catch (PersistenceException e) {
            LOG.error("Unable to clear application settings", e);
        }
    }
}
package org.pdfsam.core.context;
import org.sejda.model.pdf.PdfVersion;
import java.util.function.Supplier;
import static org.pdfsam.core.ConfigurableSystemProperty.LOCALE_PROP;
import static org.pdfsam.core.ConfigurableSystemProperty.PDFVERSION_PROP;
import static org.pdfsam.core.ConfigurableSystemProperty.PREFIX_PROP;
import static org.pdfsam.core.ConfigurableSystemProperty.THEME_PROP;
public enum StringPersistentProperty implements PersistentProperty<String> {
    WORKSPACE_PATH(() -> ""),
    WORKING_PATH(() -> ""),
    STARTUP_MODULE(() -> ""),
    LOCALE(() -> System.getProperty(LOCALE_PROP)),
    THEME(() -> System.getProperty(THEME_PROP)),
    FONT_SIZE(() -> ""),
    PDF_VERSION(() -> {
        var version = System.getProperty(PDFVERSION_PROP, PdfVersion.VERSION_1_5.name());
        try {
            PdfVersion.valueOf(version);
            return version;
        } catch (IllegalArgumentException e) {
            return PdfVersion.VERSION_1_5.name();
        }
    }),
    PREFIX(() -> System.getProperty(PREFIX_PROP, "PDFsam_"));
    private final Supplier<String> defaultSupplier;
    StringPersistentProperty(Supplier<String> supplier) {
        this.defaultSupplier = supplier;
    }
    @Override
    public String key() {
        return this.name().toLowerCase();
    }
    @Override
    public Supplier<String> defaultSupplier() {
        return defaultSupplier;
    }
}
package org.pdfsam.ui.components.io;
import javafx.css.PseudoClass;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.input.Clipboard;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import org.pdfsam.model.ui.workspace.RestorableView;
import org.pdfsam.ui.components.commons.ValidableTextField;
import org.pdfsam.ui.components.support.FXValidationSupport;
import org.pdfsam.ui.components.support.Style;
import java.io.File;
import java.nio.file.Path;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import static org.apache.commons.lang3.StringUtils.EMPTY;
import static org.apache.commons.lang3.StringUtils.defaultString;
import static org.pdfsam.i18n.I18nContext.i18n;
abstract class BrowsableField extends HBox implements RestorableView {
    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass("selected");
    private final Button browseButton;
    private final ValidableTextField textField = new ValidableTextField() {
        @Override
        public void paste() {
            Clipboard clipboard = Clipboard.getSystemClipboard();
            if (clipboard.hasString()) {
                String text = clipboard.getString();
                if (text.length() > 2 && text.charAt(0) == '"' && text.charAt(text.length() - 1) == '"') {
                    replaceSelection(text.substring(1, text.length() - 1));
                } else {
                    super.paste();
                }
            }
        }
    };
    private final HBox validableContainer;
    private String browseWindowTitle = i18n().tr("Select");
    public BrowsableField() {
        this(new Button(i18n().tr("Browse")));
        browseButton.getStyleClass().addAll(Style.BROWSE_BUTTON.css());
        browseButton.prefHeightProperty().bind(textField.heightProperty());
        browseButton.setMaxHeight(USE_PREF_SIZE);
        browseButton.setMinHeight(USE_PREF_SIZE);
        getChildren().add(browseButton);
    }
    public BrowsableField(Button browseButton) {
        this.browseButton = browseButton;
        HBox.setHgrow(textField, Priority.ALWAYS);
        this.getStyleClass().add("browsable-field");
        validableContainer = new HBox(textField);
        validableContainer.getStyleClass().add("validable-container");
        textField.getStyleClass().add("validable-container-field");
        HBox.setHgrow(validableContainer, Priority.ALWAYS);
        textField.validProperty().addListener((o, oldValue, newValue) -> {
            if (newValue == FXValidationSupport.ValidationState.INVALID) {
                validableContainer.getStyleClass().addAll(Style.INVALID.css());
            } else {
                validableContainer.getStyleClass().removeAll(Style.INVALID.css());
            }
        });
        textField.focusedProperty().addListener(
                (o, oldVal, newVal) -> validableContainer.pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, newVal));
        getChildren().add(validableContainer);
    }
    public ValidableTextField getTextField() {
        return textField;
    }
    @Override
    public void saveStateTo(Map<String, String> data) {
        data.put(defaultString(getId()) + "browsableField", defaultString(textField.getText()));
    }
    @Override
    public void restoreStateFrom(Map<String, String> data) {
        textField.setText(Optional.ofNullable(data.get(defaultString(getId()) + "browsableField")).orElse(EMPTY));
    }
    public final void setGraphic(Node value) {
        validableContainer.getChildren().clear();
        if (value != null) {
            validableContainer.getChildren().add(value);
        }
        validableContainer.getChildren().add(textField);
    }
    Button getBrowseButton() {
        return browseButton;
    }
    String getBrowseWindowTitle() {
        return browseWindowTitle;
    }
    public void setBrowseWindowTitle(String browseWindowTitle) {
        this.browseWindowTitle = browseWindowTitle;
    }
    abstract void setTextFromFile(File inputFile);
    public void setTextFromFile(Path inputFile) {
        if (Objects.nonNull(inputFile)) {
            this.setTextFromFile(inputFile.toFile());
        }
    }
}
package org.pdfsam.ui.components.commons;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.geometry.Point2D;
import javafx.scene.Scene;
import javafx.scene.control.TextField;
import javafx.scene.control.Tooltip;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.stage.Window;
import javafx.util.Duration;
import org.pdfsam.core.support.validation.Validator;
import org.pdfsam.ui.components.support.FXValidationSupport;
import org.pdfsam.ui.components.support.Style;
import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.sejda.commons.util.RequireUtils.requireNotBlank;
import static org.sejda.commons.util.RequireUtils.requireNotNullArg;
public class ValidableTextField extends TextField {
    private static final KeyCombination ENTER_COMBO = new KeyCodeCombination(KeyCode.ENTER);
    private final FXValidationSupport<String> validationSupport = new FXValidationSupport<>();
    private ErrorTooltipManager errorTooltipManager;
    public ValidableTextField() {
        this("");
    }
    public ValidableTextField(String text) {
        super(text);
        this.getStyleClass().add("validable-field");
        focusedProperty().addListener((o, oldVal, newVal) -> {
            if (!newVal) {
                validate();
            }
        });
        textProperty().addListener((o, oldVal, newVal) -> validationSupport.makeNotValidated());
        validationSupport.validationStateProperty().addListener(
                o -> {
                    if (validationSupport.validationStateProperty().get() == FXValidationSupport.ValidationState.INVALID
                            && errorTooltipManager != null) {
                        errorTooltipManager.showTooltip();
                    }
                });
    }
    public final FXValidationSupport.ValidationState getValidationState() {
        return validationSupport.validationStateProperty().get();
    }
    public final ReadOnlyObjectProperty<FXValidationSupport.ValidationState> validProperty() {
        return validationSupport.validationStateProperty();
    }
    public void setEnableInvalidStyle(final boolean active) {
        validationSupport.validationStateProperty().addListener(o -> {
            if (active) {
                if (validationSupport.validationStateProperty().get() == FXValidationSupport.ValidationState.INVALID) {
                    getStyleClass().addAll(Style.INVALID.css());
                } else {
                    getStyleClass().removeAll(Style.INVALID.css());
                }
            }
        });
    }
    public void setErrorMessage(String message) {
        if (isNotBlank(message)) {
            this.errorTooltipManager = new ErrorTooltipManager(message);
        } else {
            this.errorTooltipManager = null;
        }
    }
    public void setOnEnterValidation(final boolean active) {
        setOnKeyReleased(t -> {
            if (active && ENTER_COMBO.match(t)) {
                validate();
            }
        });
    }
    public void setValidator(Validator<String> validator) {
        requireNotNullArg(validator, "Validator cannot be null for ValidableTextField");
        validationSupport.setValidator(validator);
    }
    public void validate() {
        validationSupport.validate(getText());
    }
    private final class ErrorTooltipManager {
        private static final String ERROR_TOOLTIP_CLASS = "error-tooltip";
        private final Tooltip tooltip;
        private boolean active = false;
        private final Timeline activationTimer = new Timeline();
        private final Timeline hideTimer = new Timeline();
        private ErrorTooltipManager(String message) {
            requireNotBlank(message, "Tooltip message cannot be blank");
            this.tooltip = new Tooltip(message);
            this.tooltip.getStyleClass().add(ERROR_TOOLTIP_CLASS);
            hideTimer.getKeyFrames().add(new KeyFrame(new Duration(5000)));
            hideTimer.setOnFinished(e -> {
                tooltip.hide();
                ErrorTooltipManager.this.active = false;
            });
            activationTimer.getKeyFrames().add(new KeyFrame(new Duration(250)));
            activationTimer.setOnFinished(e -> {
                if (!ErrorTooltipManager.this.active) {
                    Scene scene = getScene();
                    if (scene != null) {
                        Window owner = scene.getWindow();
                        if (owner != null && owner.isShowing() && ValidableTextField.this.isVisible()) {
                            Point2D where = getDisplayCoordiantes(owner, scene);
                            tooltip.show(ValidableTextField.this, where.getX(), where.getY());
                            ErrorTooltipManager.this.active = true;
                            hideTimer.playFromStart();
                        }
                    }
                }
            });
        }
        private void showTooltip() {
            if (activationTimer.getStatus() != Status.RUNNING) {
                activationTimer.stop();
                activationTimer.playFromStart();
            }
        }
        private Point2D getDisplayCoordiantes(Window owner, Scene scene) {
            Point2D nodeCoord = ValidableTextField.this.localToScene(0.0, ValidableTextField.this.getHeight());
            double anchorX = Math.round(owner.getX() + scene.getX() + nodeCoord.getX());
            double anchorY = Math.round(owner.getY() + scene.getY() + nodeCoord.getY() + 1);
            return new Point2D(anchorX, anchorY);
        }
    }
}
package org.pdfsam.ui.components.support;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import org.pdfsam.core.support.validation.Validator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import static org.sejda.commons.util.RequireUtils.requireNotNullArg;
public class FXValidationSupport<T> {
    private static final Logger LOG = LoggerFactory.getLogger(FXValidationSupport.class);
    private final ReadOnlyObjectWrapper<ValidationState> validationState = new ReadOnlyObjectWrapper<>(
            ValidationState.NOT_VALIDATED);
    private Validator<T> validator = input -> true;
    public void validate(T value) {
        LOG.trace("Validating {}", value);
        if (validator.isValid(value)) {
            validationState.set(ValidationState.VALID);
        } else {
            validationState.set(ValidationState.INVALID);
        }
    }
    public void setValidator(Validator<T> validator) {
        requireNotNullArg(validator, "Validator cannot be null");
        this.validator = validator;
        makeNotValidated();
    }
    public void makeNotValidated() {
        LOG.trace("Making state {}", ValidationState.NOT_VALIDATED);
        validationState.set(ValidationState.NOT_VALIDATED);
    }
    public final ReadOnlyObjectProperty<ValidationState> validationStateProperty() {
        return validationState.getReadOnlyProperty();
    }
    public enum ValidationState {
        VALID,
        INVALID,
        NOT_VALIDATED
    }
}
package org.pdfsam.tools.rotate;
import jakarta.inject.Named;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.unicons.UniconsLine;
import org.pdfsam.injector.Auto;
import org.pdfsam.injector.Provides;
import org.pdfsam.model.tool.Tool;
import org.pdfsam.model.tool.ToolCategory;
import org.pdfsam.model.tool.ToolDescriptor;
import org.pdfsam.model.tool.ToolInputOutputType;
import org.pdfsam.model.tool.ToolPriority;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.tool.Footer;
import org.pdfsam.ui.components.tool.OpenButton;
import org.pdfsam.ui.components.tool.RunButton;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.model.tool.ToolDescriptorBuilder.builder;
@Auto
public class RotateTool implements Tool {
    static final String TOOL_ID = "rotate";
    private final ToolDescriptor descriptor = builder().category(ToolCategory.OTHER)
            .inputTypes(ToolInputOutputType.MULTIPLE_PDF, ToolInputOutputType.SINGLE_PDF).name(i18n().tr("Rotate"))
            .description(i18n().tr("Rotate the pages of multiple PDF documents."))
            .priority(ToolPriority.DEFAULT.getPriority()).supportURL("https:
            .build();
    @Override
    public ToolDescriptor descriptor() {
        return descriptor;
    }
    @Override
    public Pane panel() {
        return app().instance(RotateToolPanel.class);
    }
    @Override
    public String id() {
        return TOOL_ID;
    }
    @Override
    public Node graphic() {
        var icon = new FontIcon(UniconsLine.ROTATE_360);
        icon.getStyleClass().addAll(this.descriptor().category().styleClass(), "tool-icon");
        return icon;
    }
    public static class ModuleConfig {
        @Provides
        @Named(TOOL_ID + "field")
        public BrowsableOutputDirectoryField destinationDirectoryField() {
            return new BrowsableOutputDirectoryField();
        }
        @Provides
        @Named(TOOL_ID + "pane")
        public PdfDestinationPane destinationPane(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField outputField) {
            return new PdfDestinationPane(outputField, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "footer")
        public Footer footer(RunButton runButton, @Named(TOOL_ID + "openButton") OpenButton openButton) {
            return new Footer(runButton, openButton, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "openButton")
        public OpenButton openButton() {
            return new OpenButton(TOOL_ID, ToolInputOutputType.MULTIPLE_PDF);
        }
        @Provides
        @Named(TOOL_ID + "prefix")
        public PrefixPane prefixPane() {
            return new PrefixPane(TOOL_ID, new PreferencesRepository("/org/pdfsam/user/conf/" + TOOL_ID));
        }
    }
}
package org.pdfsam.ui.components.io;
import org.pdfsam.core.context.ApplicationContext;
import org.pdfsam.core.support.params.MultipleOutputTaskParametersBuilder;
import org.pdfsam.core.support.params.TaskParametersBuildStep;
import org.pdfsam.model.ui.NonExistingOutputDirectoryEvent;
import org.pdfsam.ui.components.support.FXValidationSupport;
import org.sejda.model.parameter.base.SingleOrMultipleOutputTaskParameters;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.function.Consumer;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.core.context.StringPersistentProperty.WORKING_PATH;
import static org.pdfsam.core.support.validation.Validators.and;
import static org.pdfsam.core.support.validation.Validators.nonBlank;
import static org.pdfsam.eventstudio.StaticStudio.eventStudio;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.sejda.model.output.FileOrDirectoryTaskOutput.directory;
public class BrowsableOutputDirectoryField extends BrowsableDirectoryField
        implements TaskParametersBuildStep<MultipleOutputTaskParametersBuilder<?>> {
    public BrowsableOutputDirectoryField() {
        this(app());
    }
    BrowsableOutputDirectoryField(ApplicationContext context) {
        context.persistentSettings().get(WORKING_PATH).ifPresent(getTextField()::setText);
        getTextField().setValidator(and(nonBlank(), v -> !Files.isRegularFile(Paths.get(v))));
    }
    @Override
    public void apply(MultipleOutputTaskParametersBuilder<? extends SingleOrMultipleOutputTaskParameters> builder,
            Consumer<String> onError) {
        getTextField().validate();
        if (getTextField().getValidationState() == FXValidationSupport.ValidationState.VALID) {
            var output = Paths.get(getTextField().getText());
            if (!Files.exists(output)) {
                eventStudio().broadcast(new NonExistingOutputDirectoryEvent(output));
            }
            if (Files.isDirectory(output)) {
                builder.output(directory(output.toFile()));
            } else {
                onError.accept(i18n().tr("An existing output directory is required"));
            }
        } else {
            onError.accept(i18n().tr("The output directory is required"));
        }
    }
}
package org.pdfsam.tools.extract;
import jakarta.inject.Named;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.unicons.UniconsLine;
import org.pdfsam.injector.Auto;
import org.pdfsam.injector.Provides;
import org.pdfsam.model.tool.Tool;
import org.pdfsam.model.tool.ToolCategory;
import org.pdfsam.model.tool.ToolDescriptor;
import org.pdfsam.model.tool.ToolInputOutputType;
import org.pdfsam.model.tool.ToolPriority;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.tool.Footer;
import org.pdfsam.ui.components.tool.OpenButton;
import org.pdfsam.ui.components.tool.RunButton;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.model.tool.ToolDescriptorBuilder.builder;
import static org.pdfsam.ui.components.io.PdfDestinationPane.DestinationPanelFields.DISCARD_BOOKMARKS;
@Auto
public class ExtractTool implements Tool {
    static final String TOOL_ID = "extract";
    private final ToolDescriptor descriptor = builder().category(ToolCategory.SPLIT)
            .inputTypes(ToolInputOutputType.MULTIPLE_PDF, ToolInputOutputType.SINGLE_PDF).name(i18n().tr("Extract"))
            .description(i18n().tr("Extract pages from PDF documents.")).priority(ToolPriority.DEFAULT.getPriority())
            .supportURL("https:
            .build();
    @Override
    public ToolDescriptor descriptor() {
        return descriptor;
    }
    @Override
    public Pane panel() {
        return app().instance(ExtractToolPanel.class);
    }
    @Override
    public String id() {
        return TOOL_ID;
    }
    @Override
    public Node graphic() {
        var icon = new FontIcon(UniconsLine.FILE_EXPORT);
        icon.getStyleClass().addAll(this.descriptor().category().styleClass(), "tool-icon");
        return icon;
    }
    public static class ModuleConfig {
        @Provides
        @Named(TOOL_ID + "field")
        public BrowsableOutputDirectoryField destinationDirectoryField() {
            return new BrowsableOutputDirectoryField();
        }
        @Provides
        @Named(TOOL_ID + "pane")
        public PdfDestinationPane destinationPane(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField outputField) {
            return new PdfDestinationPane(outputField, TOOL_ID, DISCARD_BOOKMARKS);
        }
        @Provides
        @Named(TOOL_ID + "footer")
        public Footer footer(RunButton runButton, @Named(TOOL_ID + "openButton") OpenButton openButton) {
            return new Footer(runButton, openButton, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "openButton")
        public OpenButton openButton() {
            return new OpenButton(TOOL_ID, ToolInputOutputType.MULTIPLE_PDF);
        }
        @Provides
        @Named(TOOL_ID + "prefix")
        public PrefixPane prefixPane() {
            return new PrefixPane(TOOL_ID, new PreferencesRepository("/org/pdfsam/user/conf/" + TOOL_ID));
        }
    }
}
package org.pdfsam.ui.components.io;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.input.DragEvent;
import javafx.scene.input.TransferMode;
import org.pdfsam.core.io.Choosers;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.function.Consumer;
import static java.util.Objects.nonNull;
import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
public class BrowsableDirectoryField extends BrowsableField {
    public BrowsableDirectoryField() {
        setBrowseWindowTitle(i18n().tr("Select a directory"));
        getTextField().setErrorMessage(i18n().tr("Select an existing directory"));
        getTextField().setPromptText(i18n().tr("Select a directory"));
        var handler = new BrowseEventHandler();
        getBrowseButton().setOnAction(handler);
        getTextField().setOnAction(handler);
        setOnDragOver(e -> dragConsume(e, this.onDragOverConsumer()));
        setOnDragDropped(e -> dragConsume(e, this.onDragDropped()));
    }
    private class BrowseEventHandler implements EventHandler<ActionEvent> {
        @Override
        public void handle(ActionEvent event) {
            var directoryChooser = Choosers.directoryChooser(getBrowseWindowTitle());
            String currentSelection = getTextField().getText();
            if (isNotBlank(currentSelection)) {
                var path = Paths.get(currentSelection);
                if (!path.isAbsolute()) {
                    path = app().runtimeState().workingPathValue().map(w -> w.resolve(currentSelection)).orElse(path);
                }
                if (Files.exists(path)) {
                    directoryChooser.setInitialDirectory(path);
                }
            }
            setTextFromFile(directoryChooser.showDialog(getTextField().getScene().getWindow()));
        }
    }
    @Override
    void setTextFromFile(File inputFile) {
        if (nonNull(inputFile)) {
            if (inputFile.isDirectory()) {
                getTextField().setText(inputFile.getAbsolutePath());
            } else {
                getTextField().setText(inputFile.getParent());
            }
            getTextField().validate();
        }
    }
    private void dragConsume(DragEvent e, Consumer<DragEvent> c) {
        List<File> files = e.getDragboard().getFiles();
        if (files != null && !files.isEmpty()) {
            c.accept(e);
        }
        e.consume();
    }
    private Consumer<DragEvent> onDragOverConsumer() {
        return (DragEvent e) -> e.acceptTransferModes(TransferMode.COPY_OR_MOVE);
    }
    private Consumer<DragEvent> onDragDropped() {
        return (DragEvent e) -> {
            e.getDragboard().getFiles().stream().filter(File::isDirectory).findFirst().ifPresent(this::setTextFromFile);
            e.setDropCompleted(true);
        };
    }
}
package org.pdfsam.tools.extract;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.pdfsam.eventstudio.annotation.EventStation;
import org.pdfsam.model.tool.ClearToolRequest;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.support.Views;
import org.pdfsam.ui.components.tool.BaseToolPanel;
import org.pdfsam.ui.components.tool.Footer;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.function.Consumer;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.tools.extract.ExtractTool.TOOL_ID;
import static org.pdfsam.ui.components.support.Views.titledPane;
public class ExtractToolPanel extends BaseToolPanel {
    private final ExtractSelectionPane selectionPane = new ExtractSelectionPane(TOOL_ID);
    private final ExtractOptionsPane extractOptions = new ExtractOptionsPane();
    private final BrowsableOutputDirectoryField destinationDirectoryField;
    private final PdfDestinationPane destinationPane;
    private final PrefixPane prefix;
    @Inject
    public ExtractToolPanel(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField destinationDirectoryField,
            @Named(TOOL_ID + "pane") PdfDestinationPane destinationPane, @Named(TOOL_ID + "footer") Footer footer,
            @Named(TOOL_ID + "prefix") PrefixPane prefix) {
        super(TOOL_ID, footer);
        this.destinationDirectoryField = destinationDirectoryField;
        this.destinationPane = destinationPane;
        this.prefix = prefix;
        initModuleSettingsPanel(settingPanel());
    }
    @Override
    protected ExtractParametersBuilder getBuilder(Consumer<String> onError) {
        ExtractParametersBuilder builder = new ExtractParametersBuilder();
        extractOptions.apply(builder, onError);
        selectionPane.apply(builder, onError);
        destinationDirectoryField.apply(builder, onError);
        destinationPane.apply(builder, onError);
        prefix.apply(builder, onError);
        return builder;
    }
    @Override
    public void onSaveWorkspace(Map<String, String> data) {
        selectionPane.saveStateTo(data);
        extractOptions.saveStateTo(data);
        destinationPane.saveStateTo(data);
        destinationDirectoryField.saveStateTo(data);
        prefix.saveStateTo(data);
    }
    @Override
    public void onLoadWorkspace(Map<String, String> data) {
        if (data.containsKey("input")) {
            data.put("input.0", data.get("input"));
            data.put("input.password.0", data.get("input.password"));
            data.put("input.size", "1");
        }
        selectionPane.restoreStateFrom(data);
        extractOptions.restoreStateFrom(data);
        destinationPane.restoreStateFrom(data);
        destinationDirectoryField.restoreStateFrom(data);
        prefix.restoreStateFrom(data);
    }
    private VBox settingPanel() {
        VBox pane = new VBox();
        pane.setAlignment(Pos.TOP_CENTER);
        VBox.setVgrow(selectionPane, Priority.ALWAYS);
        TitledPane prefixTitled = Views.titledPane(i18n().tr("File names settings"), prefix);
        prefix.addMenuItemFor(Prefix.FILENUMBER);
        prefix.addMenuItemFor("[TOTAL_FILESNUMBER]");
        pane.getChildren().addAll(selectionPane, titledPane(i18n().tr("Extract settings"), extractOptions),
                titledPane(i18n().tr("Output settings"), destinationPane), prefixTitled);
        return pane;
    }
    @EventStation
    public String id() {
        return TOOL_ID;
    }
    @EventListener
    public void onClearModule(ClearToolRequest e) {
        if (e.clearEverything()) {
            extractOptions.resetView();
            prefix.resetView();
            destinationPane.resetView();
        }
    }
}
package org.pdfsam.tools.rotate;
import jakarta.inject.Inject;
import jakarta.inject.Named;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.pdfsam.eventstudio.annotation.EventStation;
import org.pdfsam.model.tool.ClearToolRequest;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.support.Views;
import org.pdfsam.ui.components.tool.BaseToolPanel;
import org.pdfsam.ui.components.tool.Footer;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.function.Consumer;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.tools.rotate.RotateTool.TOOL_ID;
public class RotateToolPanel extends BaseToolPanel {
    private final RotateSelectionPane selectionPane = new RotateSelectionPane(TOOL_ID);
    private final RotateOptionsPane rotateOptions = new RotateOptionsPane();
    private final BrowsableOutputDirectoryField destinationDirectoryField;
    private final PdfDestinationPane destinationPane;
    private final PrefixPane prefix;
    @Inject
    public RotateToolPanel(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField destinationDirectoryField,
            @Named(TOOL_ID + "pane") PdfDestinationPane destinationPane, @Named(TOOL_ID + "footer") Footer footer,
            @Named(TOOL_ID + "prefix") PrefixPane prefix) {
        super(TOOL_ID, footer);
        this.destinationDirectoryField = destinationDirectoryField;
        this.destinationPane = destinationPane;
        this.prefix = prefix;
        initModuleSettingsPanel(settingPanel());
    }
    @Override
    protected RotateParametersBuilder getBuilder(Consumer<String> onError) {
        RotateParametersBuilder builder = new RotateParametersBuilder();
        rotateOptions.apply(builder, onError);
        selectionPane.apply(builder, onError);
        destinationDirectoryField.apply(builder, onError);
        destinationPane.apply(builder, onError);
        prefix.apply(builder, onError);
        return builder;
    }
    @Override
    public void onSaveWorkspace(Map<String, String> data) {
        selectionPane.saveStateTo(data);
        rotateOptions.saveStateTo(data);
        destinationPane.saveStateTo(data);
        destinationDirectoryField.saveStateTo(data);
        prefix.saveStateTo(data);
    }
    @Override
    public void onLoadWorkspace(Map<String, String> data) {
        selectionPane.restoreStateFrom(data);
        rotateOptions.restoreStateFrom(data);
        destinationPane.restoreStateFrom(data);
        destinationDirectoryField.restoreStateFrom(data);
        prefix.restoreStateFrom(data);
    }
    private VBox settingPanel() {
        VBox pane = new VBox();
        pane.setAlignment(Pos.TOP_CENTER);
        VBox.setVgrow(selectionPane, Priority.ALWAYS);
        TitledPane prefixTitled = Views.titledPane(i18n().tr("File names settings"), prefix);
        prefix.addMenuItemFor(Prefix.FILENUMBER);
        prefix.addMenuItemFor("[TOTAL_FILESNUMBER]");
        TitledPane options = Views.titledPane(i18n().tr("Rotate settings"), rotateOptions);
        pane.getChildren()
                .addAll(selectionPane, options, Views.titledPane(i18n().tr("Output settings"), destinationPane),
                        prefixTitled);
        return pane;
    }
    @EventStation
    public String id() {
        return TOOL_ID;
    }
    @EventListener
    public void onClearModule(ClearToolRequest e) {
        if (e.clearEverything()) {
            rotateOptions.resetView();
            prefix.resetView();
            destinationPane.resetView();
        }
    }
}