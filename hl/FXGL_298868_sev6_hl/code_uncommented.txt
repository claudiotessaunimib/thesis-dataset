package com.almasb.fxgl.physics.box2d.dynamics;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.box2d.collision.AABB;
import com.almasb.fxgl.physics.box2d.collision.RayCastInput;
import com.almasb.fxgl.physics.box2d.collision.RayCastOutput;
import com.almasb.fxgl.physics.box2d.collision.broadphase.BroadPhase;
import com.almasb.fxgl.physics.box2d.collision.shapes.MassData;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.collision.shapes.ShapeType;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactEdge;
public final class Fixture {
    private final Filter filter = new Filter();
    private final Body body;
    private final Shape shape;
    private Object userData;
    private HitBox hitBox;
    private float density;
    private float friction;
    private float restitution;
    private boolean isSensor;
    private FixtureProxy[] proxies;
    private int proxyCount = 0;
    Fixture(Body body, FixtureDef def) {
        this.body = body;
        shape = def.getShape().clone();
        userData = def.getUserData();
        density = def.getDensity();
        friction = def.getFriction();
        restitution = def.getRestitution();
        isSensor = def.isSensor();
        filter.set(def.getFilter());
        int childCount = shape.getChildCount();
        proxies = new FixtureProxy[childCount];
        for (int i = 0; i < childCount; i++) {
            proxies[i] = new FixtureProxy();
        }
    }
    public Body getBody() {
        return body;
    }
    public Shape getShape() {
        return shape;
    }
    public ShapeType getType() {
        return shape.getType();
    }
    public Filter getFilterData() {
        return filter;
    }
    public void setFilterData(final Filter filter) {
        this.filter.set(filter);
        refilter();
    }
    public Object getUserData() {
        return userData;
    }
    public void setUserData(Object data) {
        userData = data;
    }
    public HitBox getHitBox() {
        return hitBox;
    }
    public void setHitBox(HitBox hitBox) {
        this.hitBox = hitBox;
    }
    public float getDensity() {
        return density;
    }
    public void setDensity(float density) {
        this.density = density;
    }
    public float getFriction() {
        return friction;
    }
    public void setFriction(float friction) {
        this.friction = friction;
    }
    public float getRestitution() {
        return restitution;
    }
    public void setRestitution(float restitution) {
        this.restitution = restitution;
    }
    public boolean isSensor() {
        return isSensor;
    }
    public void setSensor(boolean sensor) {
        if (sensor != isSensor) {
            body.setAwake(true);
            isSensor = sensor;
        }
    }
    public int getProxyCount() {
        return proxyCount;
    }
    public int getProxyId(int index) {
        return proxies[index].proxyId;
    }
    public void refilter() {
        ContactEdge edge = body.getContactList();
        while (edge != null) {
            Contact contact = edge.contact;
            if (contact.getFixtureA() == this || contact.getFixtureB() == this) {
                contact.flagForFiltering();
            }
            edge = edge.next;
        }
        World world = body.getWorld();
        if (world == null) {
            return;
        }
        BroadPhase broadPhase = world.getContactManager().broadPhase;
        for (int i = 0; i < proxyCount; ++i) {
            broadPhase.touchProxy(proxies[i].proxyId);
        }
    }
    public boolean containsPoint(Vec2 p) {
        return shape.containsPoint(body.m_xf, p);
    }
    public boolean raycast(RayCastOutput output, RayCastInput input, int childIndex) {
        return shape.raycast(output, input, body.m_xf, childIndex);
    }
    public void getMassData(MassData massData) {
        shape.computeMass(massData, density);
    }
    public AABB getAABB(int childIndex) {
        return proxies[childIndex].aabb;
    }
    public float computeDistance(Vec2 p, int childIndex, Vec2 normalOut) {
        return shape.computeDistanceToOut(body.getTransform(), p, childIndex, normalOut);
    }
    void createProxies(BroadPhase broadPhase, final Transform xf) {
        proxyCount = shape.getChildCount();
        for (int i = 0; i < proxyCount; ++i) {
            FixtureProxy proxy = proxies[i];
            shape.computeAABB(proxy.aabb, xf, i);
            proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);
            proxy.fixture = this;
            proxy.childIndex = i;
        }
    }
    void destroyProxies(BroadPhase broadPhase) {
        for (int i = 0; i < proxyCount; ++i) {
            FixtureProxy proxy = proxies[i];
            broadPhase.destroyProxy(proxy.proxyId);
            proxy.proxyId = BroadPhase.NULL_PROXY;
        }
        proxyCount = 0;
    }
    private final AABB pool1 = new AABB();
    private final AABB pool2 = new AABB();
    private final Vec2 displacement = new Vec2();
    void synchronize(BroadPhase broadPhase, Transform transform1, Transform transform2) {
        if (proxyCount == 0) {
            return;
        }
        for (int i = 0; i < proxyCount; ++i) {
            FixtureProxy proxy = proxies[i];
            AABB aabb1 = pool1;
            AABB aabb2 = pool2;
            shape.computeAABB(aabb1, transform1, proxy.childIndex);
            shape.computeAABB(aabb2, transform2, proxy.childIndex);
            proxy.aabb.combine(aabb1, aabb2);
            displacement.x = transform2.p.x - transform1.p.x;
            displacement.y = transform2.p.y - transform1.p.y;
            broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);
        }
    }
    void destroy() {
        proxies = null;
    }
    static class FixtureProxy {
        final AABB aabb = new AABB();
        Fixture fixture = null;
        int proxyId = BroadPhase.NULL_PROXY;
        int childIndex;
        private FixtureProxy() { }
    }
}
package com.almasb.fxgl.physics.box2d.collision.shapes;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.collision.AABB;
import com.almasb.fxgl.physics.box2d.collision.RayCastInput;
import com.almasb.fxgl.physics.box2d.collision.RayCastOutput;
import com.almasb.fxgl.physics.box2d.common.Transform;
public abstract class Shape {
    private final ShapeType type;
    private float radius;
    public Shape(ShapeType type, float radius) {
        this.type = type;
        this.radius = radius;
    }
    @Override
    public abstract Shape clone();
    public ShapeType getType() {
        return type;
    }
    public float getRadius() {
        return radius;
    }
    public void setRadius(float radius) {
        this.radius = radius;
    }
    public abstract int getChildCount();
    public abstract boolean containsPoint(Transform xf, Vec2 point);
    public abstract boolean raycast(RayCastOutput output, RayCastInput input, Transform transform,
                                    int childIndex);
    public abstract void computeAABB(final AABB aabb, final Transform xf, int childIndex);
    public abstract void computeMass(final MassData massData, final float density);
    public abstract float computeDistanceToOut(Transform xf, Vec2 p, int childIndex, Vec2 normalOut);
}
package com.almasb.fxgl.physics.box2d.dynamics;
import com.almasb.fxgl.core.collection.Array;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.callbacks.*;
import com.almasb.fxgl.physics.box2d.collision.AABB;
import com.almasb.fxgl.physics.box2d.collision.RayCastInput;
import com.almasb.fxgl.physics.box2d.collision.RayCastOutput;
import com.almasb.fxgl.physics.box2d.collision.TimeOfImpact.TOIInput;
import com.almasb.fxgl.physics.box2d.collision.TimeOfImpact.TOIOutput;
import com.almasb.fxgl.physics.box2d.collision.TimeOfImpact.TOIOutputState;
import com.almasb.fxgl.physics.box2d.collision.broadphase.BroadPhase;
import com.almasb.fxgl.physics.box2d.collision.broadphase.DefaultBroadPhaseBuffer;
import com.almasb.fxgl.physics.box2d.collision.broadphase.DynamicTree;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.JBoxSettings;
import com.almasb.fxgl.physics.box2d.common.Sweep;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactEdge;
import com.almasb.fxgl.physics.box2d.dynamics.joints.Joint;
import com.almasb.fxgl.physics.box2d.dynamics.joints.JointDef;
import com.almasb.fxgl.physics.box2d.dynamics.joints.JointEdge;
import com.almasb.fxgl.physics.box2d.particle.*;
import com.almasb.fxgl.physics.box2d.pooling.DefaultWorldPool;
import com.almasb.fxgl.physics.box2d.pooling.IWorldPool;
public final class World {
    private static final int WORLD_POOL_SIZE = 100;
    private static final int WORLD_POOL_CONTAINER_SIZE = 10;
    private final ContactManager contactManager;
    private final ParticleSystem particleSystem;
    private final IWorldPool pool;
    private DestructionListener destructionListener = null;
    private ParticleDestructionListener particleDestructionListener = null;
    private boolean newFixture = false;
    private boolean locked = false;
    private boolean autoClearForces = true;
    private boolean allowSleep = true;
    private boolean warmStarting = true;
    private boolean continuousPhysics = true;
    private boolean subStepping = false;
    private boolean stepComplete = true;
    private Array<Body> bodies = new Array<>(WORLD_POOL_SIZE);
    private Array<Joint> joints = new Array<>();
    private final Vec2 gravity = new Vec2();
    public World(Vec2 gravity) {
        this.gravity.set(gravity);
        pool = new DefaultWorldPool(WORLD_POOL_SIZE, WORLD_POOL_CONTAINER_SIZE);
        contactManager = new ContactManager(pool, new DefaultBroadPhaseBuffer(new DynamicTree()));
        particleSystem = new ParticleSystem(this);
    }
    public Body createBody(BodyDef def) {
        assertNotLocked();
        Body b = new Body(def, this);
        bodies.add(b);
        return b;
    }
    public void destroyBody(Body body) {
        assertNotLocked();
        body.destroy();
        bodies.removeValueByIdentity(body);
    }
    public <T extends Joint> T createJoint(JointDef<T> def) {
        assertNotLocked();
        T j = Joint.create(this, def);
        joints.add(j);
        j.m_edgeA.joint = j;
        j.m_edgeA.other = j.getBodyB();
        j.m_edgeA.prev = null;
        j.m_edgeA.next = j.getBodyA().m_jointList;
        if (j.getBodyA().m_jointList != null) {
            j.getBodyA().m_jointList.prev = j.m_edgeA;
        }
        j.getBodyA().m_jointList = j.m_edgeA;
        j.m_edgeB.joint = j;
        j.m_edgeB.other = j.getBodyA();
        j.m_edgeB.prev = null;
        j.m_edgeB.next = j.getBodyB().m_jointList;
        if (j.getBodyB().m_jointList != null) {
            j.getBodyB().m_jointList.prev = j.m_edgeB;
        }
        j.getBodyB().m_jointList = j.m_edgeB;
        Body bodyA = def.getBodyA();
        Body bodyB = def.getBodyB();
        if (!def.isBodyCollisionAllowed()) {
            flagContactsForFiltering(bodyA, bodyB);
        }
        return j;
    }
    public void destroyJoint(Joint j) {
        assertNotLocked();
        boolean collideConnected = j.getCollideConnected();
        joints.removeValueByIdentity(j);
        Body bodyA = j.getBodyA();
        Body bodyB = j.getBodyB();
        bodyA.setAwake(true);
        bodyB.setAwake(true);
        if (j.m_edgeA.prev != null) {
            j.m_edgeA.prev.next = j.m_edgeA.next;
        }
        if (j.m_edgeA.next != null) {
            j.m_edgeA.next.prev = j.m_edgeA.prev;
        }
        if (j.m_edgeA == bodyA.m_jointList) {
            bodyA.m_jointList = j.m_edgeA.next;
        }
        j.m_edgeA.prev = null;
        j.m_edgeA.next = null;
        if (j.m_edgeB.prev != null) {
            j.m_edgeB.prev.next = j.m_edgeB.next;
        }
        if (j.m_edgeB.next != null) {
            j.m_edgeB.next.prev = j.m_edgeB.prev;
        }
        if (j.m_edgeB == bodyB.m_jointList) {
            bodyB.m_jointList = j.m_edgeB.next;
        }
        j.m_edgeB.prev = null;
        j.m_edgeB.next = null;
        Joint.destroy(j);
        if (!collideConnected) {
            flagContactsForFiltering(bodyA, bodyB);
        }
    }
    private void flagContactsForFiltering(Body bodyA, Body bodyB) {
        ContactEdge edge = bodyB.getContactList();
        while (edge != null) {
            if (edge.other == bodyA) {
                edge.contact.flagForFiltering();
            }
            edge = edge.next;
        }
    }
    private final TimeStep step = new TimeStep();
    private float dtInverse = 0;
    public void step(float dt, int velocityIterations, int positionIterations) {
        if (newFixture) {
            contactManager.findNewContacts();
            newFixture = false;
        }
        locked = true;
        step.dt = dt;
        step.velocityIterations = velocityIterations;
        step.positionIterations = positionIterations;
        if (dt > 0.0f) {
            step.inv_dt = 1.0f / dt;
        } else {
            step.inv_dt = 0.0f;
        }
        step.dtRatio = dtInverse * dt;
        step.warmStarting = warmStarting;
        contactManager.collide();
        if (step.dt > 0) {
            if (stepComplete) {
                particleSystem.solve(step); 
                solve(step);
            }
            if (continuousPhysics) {
                solveTOI(step);
            }
            dtInverse = step.inv_dt;
        }
        if (isAutoClearForces()) {
            clearForces();
        }
        locked = false;
    }
    private final Island island = new Island();
    private Body[] stack = new Body[10];
    private void solve(TimeStep step) {
        for (Body b : bodies) {
            b.m_xf0.set(b.m_xf);
        }
        island.init(getBodyCount(), contactManager.contactCount, getJointCount(), contactManager.getContactListener());
        for (Body b : bodies) {
            b.setIslandFlag(false);
        }
        for (Contact c = contactManager.contactList; c != null; c = c.m_next) {
            c.m_flags &= ~Contact.ISLAND_FLAG;
        }
        for (Joint j : joints) {
            j.m_islandFlag = false;
        }
        int stackSize = getBodyCount();
        if (stack.length < stackSize) {
            stack = new Body[stackSize];
        }
        for (Body seed : bodies) {
            if (seed.isIslandFlagOn2()) {
                continue;
            }
            if (!seed.isAwake() || !seed.isActive()) {
                continue;
            }
            if (seed.getType() == BodyType.STATIC) {
                continue;
            }
            island.clear();
            int stackCount = 0;
            stack[stackCount++] = seed;
            seed.setIslandFlag(true);
            while (stackCount > 0) {
                Body b = stack[--stackCount];
                island.add(b);
                b.setAwake(true);
                if (b.getType() == BodyType.STATIC) {
                    continue;
                }
                for (ContactEdge ce = b.m_contactList; ce != null; ce = ce.next) {
                    Contact contact = ce.contact;
                    if ((contact.m_flags & Contact.ISLAND_FLAG) == Contact.ISLAND_FLAG) {
                        continue;
                    }
                    if (!contact.isEnabled() || !contact.isTouching()) {
                        continue;
                    }
                    boolean sensorA = contact.m_fixtureA.isSensor();
                    boolean sensorB = contact.m_fixtureB.isSensor();
                    if (sensorA || sensorB) {
                        continue;
                    }
                    island.add(contact);
                    contact.m_flags |= Contact.ISLAND_FLAG;
                    Body other = ce.other;
                    if (other.isIslandFlagOn2()) {
                        continue;
                    }
                    assert stackCount < stackSize;
                    stack[stackCount++] = other;
                    other.setIslandFlag(true);
                }
                for (JointEdge je = b.m_jointList; je != null; je = je.next) {
                    if (je.joint.m_islandFlag) {
                        continue;
                    }
                    Body other = je.other;
                    if (!other.isActive()) {
                        continue;
                    }
                    island.add(je.joint);
                    je.joint.m_islandFlag = true;
                    if (other.isIslandFlagOn2()) {
                        continue;
                    }
                    assert stackCount < stackSize;
                    stack[stackCount++] = other;
                    other.setIslandFlag(true);
                }
            }
            island.solve(step, gravity, allowSleep);
            island.postSolveCleanup();
        }
        for (Body b : bodies) {
            if (b.isIslandFlagOff()) {
                continue;
            }
            if (b.getType() == BodyType.STATIC) {
                continue;
            }
            b.synchronizeFixtures();
        }
        contactManager.findNewContacts();
    }
    private final Island toiIsland = new Island();
    private final TOIInput toiInput = new TOIInput();
    private final TOIOutput toiOutput = new TOIOutput();
    private final TimeStep subStep = new TimeStep();
    private final Body[] tempBodies = new Body[2];
    private final Sweep backup1 = new Sweep();
    private final Sweep backup2 = new Sweep();
    private void solveTOI(final TimeStep step) {
        final Island island = toiIsland;
        island.init(2 * JBoxSettings.maxTOIContacts, JBoxSettings.maxTOIContacts, 0, contactManager.getContactListener());
        if (stepComplete) {
            for (Body b : bodies) {
                b.setIslandFlag(false);
                b.m_sweep.alpha0 = 0.0f;
            }
            for (Contact c = contactManager.contactList; c != null; c = c.m_next) {
                c.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);
                c.m_toiCount = 0;
                c.m_toi = 1.0f;
            }
        }
        for (; ; ) {
            Contact minContact = null;
            float minAlpha = 1.0f;
            for (Contact c = contactManager.contactList; c != null; c = c.m_next) {
                if (!c.isEnabled()) {
                    continue;
                }
                if (c.m_toiCount > JBoxSettings.maxSubSteps) {
                    continue;
                }
                float alpha = 1.0f;
                if ((c.m_flags & Contact.TOI_FLAG) != 0) {
                    alpha = c.m_toi;
                } else {
                    Fixture fA = c.getFixtureA();
                    Fixture fB = c.getFixtureB();
                    if (fA.isSensor() || fB.isSensor()) {
                        continue;
                    }
                    Body bA = fA.getBody();
                    Body bB = fB.getBody();
                    BodyType typeA = bA.getType();
                    BodyType typeB = bB.getType();
                    assert typeA == BodyType.DYNAMIC || typeB == BodyType.DYNAMIC;
                    boolean activeA = bA.isAwake() && typeA != BodyType.STATIC;
                    boolean activeB = bB.isAwake() && typeB != BodyType.STATIC;
                    if (!activeA && !activeB) {
                        continue;
                    }
                    boolean collideA = bA.isBullet() || typeA != BodyType.DYNAMIC;
                    boolean collideB = bB.isBullet() || typeB != BodyType.DYNAMIC;
                    if (!collideA && !collideB) {
                        continue;
                    }
                    float alpha0 = bA.m_sweep.alpha0;
                    if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
                        alpha0 = bB.m_sweep.alpha0;
                        bA.m_sweep.advance(alpha0);
                    } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
                        alpha0 = bA.m_sweep.alpha0;
                        bB.m_sweep.advance(alpha0);
                    }
                    assert alpha0 < 1.0f;
                    int indexA = c.getChildIndexA();
                    int indexB = c.getChildIndexB();
                    final TOIInput input = toiInput;
                    input.setProxyA(fA.getShape(), indexA);
                    input.setProxyB(fB.getShape(), indexB);
                    input.sweepA.set(bA.m_sweep);
                    input.sweepB.set(bB.m_sweep);
                    input.tMax = 1.0f;
                    pool.getTimeOfImpact().timeOfImpact(toiOutput, input);
                    float beta = toiOutput.t;
                    if (toiOutput.state == TOIOutputState.TOUCHING) {
                        alpha = Math.min(alpha0 + (1.0f - alpha0) * beta, 1.0f);
                    } else {
                        alpha = 1.0f;
                    }
                    c.m_toi = alpha;
                    c.m_flags |= Contact.TOI_FLAG;
                }
                if (alpha < minAlpha) {
                    minContact = c;
                    minAlpha = alpha;
                }
            }
            if (minContact == null || 1.0f - 10.0f * JBoxSettings.EPSILON < minAlpha) {
                stepComplete = true;
                break;
            }
            Fixture fA = minContact.getFixtureA();
            Fixture fB = minContact.getFixtureB();
            Body bA = fA.getBody();
            Body bB = fB.getBody();
            backup1.set(bA.m_sweep);
            backup2.set(bB.m_sweep);
            bA.advance(minAlpha);
            bB.advance(minAlpha);
            minContact.update(contactManager.getContactListener());
            minContact.m_flags &= ~Contact.TOI_FLAG;
            ++minContact.m_toiCount;
            if (!minContact.isEnabled() || !minContact.isTouching()) {
                minContact.setEnabled(false);
                bA.m_sweep.set(backup1);
                bB.m_sweep.set(backup2);
                bA.synchronizeTransform();
                bB.synchronizeTransform();
                continue;
            }
            bA.setAwake(true);
            bB.setAwake(true);
            island.clear();
            island.add(bA);
            island.add(bB);
            island.add(minContact);
            bA.setIslandFlag(true);
            bB.setIslandFlag(true);
            minContact.m_flags |= Contact.ISLAND_FLAG;
            tempBodies[0] = bA;
            tempBodies[1] = bB;
            for (int i = 0; i < 2; ++i) {
                Body body = tempBodies[i];
                if (body.getType() == BodyType.DYNAMIC) {
                    for (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {
                        if (island.isBodyCountEqualToCapacity()) {
                            break;
                        }
                        if (island.isContactCountEqualToCapacity()) {
                            break;
                        }
                        Contact contact = ce.contact;
                        if ((contact.m_flags & Contact.ISLAND_FLAG) != 0) {
                            continue;
                        }
                        Body other = ce.other;
                        if (other.getType() == BodyType.DYNAMIC && !body.isBullet() && !other.isBullet()) {
                            continue;
                        }
                        boolean sensorA = contact.m_fixtureA.isSensor();
                        boolean sensorB = contact.m_fixtureB.isSensor();
                        if (sensorA || sensorB) {
                            continue;
                        }
                        backup1.set(other.m_sweep);
                        if (other.isIslandFlagOff()) {
                            other.advance(minAlpha);
                        }
                        contact.update(contactManager.getContactListener());
                        if (!contact.isEnabled()) {
                            other.m_sweep.set(backup1);
                            other.synchronizeTransform();
                            continue;
                        }
                        if (!contact.isTouching()) {
                            other.m_sweep.set(backup1);
                            other.synchronizeTransform();
                            continue;
                        }
                        contact.m_flags |= Contact.ISLAND_FLAG;
                        island.add(contact);
                        if (other.isIslandFlagOn()) {
                            continue;
                        }
                        other.setIslandFlag(true);
                        if (other.getType() != BodyType.STATIC) {
                            other.setAwake(true);
                        }
                        island.add(other);
                    }
                }
            }
            subStep.dt = (1.0f - minAlpha) * step.dt;
            subStep.inv_dt = 1.0f / subStep.dt;
            subStep.dtRatio = 1.0f;
            subStep.positionIterations = 20;
            subStep.velocityIterations = step.velocityIterations;
            subStep.warmStarting = false;
            island.solveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);
            island.resetFlagsAndSynchronizeBroadphaseProxies();
            contactManager.findNewContacts();
            if (subStepping) {
                stepComplete = false;
                break;
            }
        }
    }
    private final WorldQueryWrapper wqwrapper = new WorldQueryWrapper();
    public void queryAABB(QueryCallback callback, ParticleQueryCallback particleCallback, AABB aabb) {
        queryAABB(callback, aabb);
        queryAABB(particleCallback, aabb);
    }
    public void queryAABB(QueryCallback callback, AABB aabb) {
        wqwrapper.broadPhase = contactManager.broadPhase;
        wqwrapper.callback = callback;
        contactManager.broadPhase.query(wqwrapper, aabb);
    }
    public void queryAABB(ParticleQueryCallback particleCallback, AABB aabb) {
        particleSystem.queryAABB(particleCallback, aabb);
    }
    private final WorldRayCastWrapper wrcwrapper = new WorldRayCastWrapper();
    private final RayCastInput input = new RayCastInput();
    public void raycast(RayCastCallback callback, ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {
        raycast(callback, point1, point2);
        raycast(particleCallback, point1, point2);
    }
    public void raycast(RayCastCallback callback, Vec2 point1, Vec2 point2) {
        wrcwrapper.broadPhase = contactManager.broadPhase;
        wrcwrapper.callback = callback;
        input.maxFraction = 1.0f;
        input.p1.set(point1);
        input.p2.set(point2);
        contactManager.broadPhase.raycast(wrcwrapper, input);
    }
    public void raycast(ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {
        particleSystem.raycast(particleCallback, point1, point2);
    }
    public void clearForces() {
        for (Body body : bodies) {
            body.clearForces();
        }
    }
    public int createParticle(ParticleDef def) {
        assertNotLocked();
        return particleSystem.createParticle(def);
    }
    public void destroyParticle(int index) {
        destroyParticle(index, false);
    }
    public void destroyParticle(int index, boolean callDestructionListener) {
        particleSystem.destroyParticle(index, callDestructionListener);
    }
    public int destroyParticlesInShape(Shape shape, Transform xf) {
        return destroyParticlesInShape(shape, xf, false);
    }
    public int destroyParticlesInShape(Shape shape, Transform xf, boolean callDestructionListener) {
        assertNotLocked();
        return particleSystem.destroyParticlesInShape(shape, xf, callDestructionListener);
    }
    public ParticleGroup createParticleGroup(ParticleGroupDef def) {
        assertNotLocked();
        return particleSystem.createParticleGroup(def);
    }
    public void joinParticleGroups(ParticleGroup groupA, ParticleGroup groupB) {
        assertNotLocked();
        particleSystem.joinParticleGroups(groupA, groupB);
    }
    public void destroyParticlesInGroup(ParticleGroup group, boolean callDestructionListener) {
        assertNotLocked();
        particleSystem.destroyParticlesInGroup(group, callDestructionListener);
    }
    public void destroyParticlesInGroup(ParticleGroup group) {
        destroyParticlesInGroup(group, false);
    }
    public ParticleGroup[] getParticleGroupList() {
        return particleSystem.getParticleGroupList();
    }
    public int getParticleGroupCount() {
        return particleSystem.getParticleGroupCount();
    }
    public int getParticleCount() {
        return particleSystem.getParticleCount();
    }
    public int getParticleMaxCount() {
        return particleSystem.getParticleMaxCount();
    }
    public void setParticleMaxCount(int count) {
        particleSystem.setParticleMaxCount(count);
    }
    public void setParticleDensity(float density) {
        particleSystem.setParticleDensity(density);
    }
    public float getParticleDensity() {
        return particleSystem.getParticleDensity();
    }
    public void setParticleGravityScale(float gravityScale) {
        particleSystem.setParticleGravityScale(gravityScale);
    }
    public float getParticleGravityScale() {
        return particleSystem.getParticleGravityScale();
    }
    public void setParticleDamping(float damping) {
        particleSystem.setParticleDamping(damping);
    }
    public float getParticleDamping() {
        return particleSystem.getParticleDamping();
    }
    public void setParticleRadius(float radius) {
        particleSystem.setParticleRadius(radius);
    }
    public float getParticleRadius() {
        return particleSystem.getParticleRadius();
    }
    public int[] getParticleFlagsBuffer() {
        return particleSystem.getParticleFlagsBuffer();
    }
    public Vec2[] getParticlePositionBuffer() {
        return particleSystem.getParticlePositionBuffer();
    }
    public Vec2[] getParticleVelocityBuffer() {
        return particleSystem.getParticleVelocityBuffer();
    }
    public ParticleColor[] getParticleColorBuffer() {
        return particleSystem.getParticleColorBuffer();
    }
    public ParticleGroup[] getParticleGroupBuffer() {
        return particleSystem.getParticleGroupBuffer();
    }
    public Object[] getParticleUserDataBuffer() {
        return particleSystem.getParticleUserDataBuffer();
    }
    public ParticleContact[] getParticleContacts() {
        return particleSystem.m_contactBuffer;
    }
    public int getParticleContactCount() {
        return particleSystem.m_contactCount;
    }
    public ParticleBodyContact[] getParticleBodyContacts() {
        return particleSystem.m_bodyContactBuffer;
    }
    public int getParticleBodyContactCount() {
        return particleSystem.m_bodyContactCount;
    }
    public float computeParticleCollisionEnergy() {
        return particleSystem.computeParticleCollisionEnergy();
    }
    public Array<Body> getBodies() {
        return bodies;
    }
    public Contact getContactList() {
        return contactManager.contactList;
    }
    public boolean isSleepingAllowed() {
        return allowSleep;
    }
    public void setSleepingAllowed(boolean sleepingAllowed) {
        allowSleep = sleepingAllowed;
    }
    public void setWarmStarting(boolean flag) {
        warmStarting = flag;
    }
    public boolean isWarmStarting() {
        return warmStarting;
    }
    public void setContinuousPhysics(boolean flag) {
        continuousPhysics = flag;
    }
    public boolean isContinuousPhysics() {
        return continuousPhysics;
    }
    public int getBodyCount() {
        return bodies.size();
    }
    public int getJointCount() {
        return joints.size();
    }
    public int getContactCount() {
        return contactManager.contactCount;
    }
    public void setGravity(Vec2 gravity) {
        this.gravity.set(gravity);
    }
    public Vec2 getGravity() {
        return gravity;
    }
    ContactManager getContactManager() {
        return contactManager;
    }
    public IWorldPool getPool() {
        return pool;
    }
    public DestructionListener getDestructionListener() {
        return destructionListener;
    }
    public void setDestructionListener(DestructionListener listener) {
        destructionListener = listener;
    }
    public ParticleDestructionListener getParticleDestructionListener() {
        return particleDestructionListener;
    }
    public void setParticleDestructionListener(ParticleDestructionListener listener) {
        particleDestructionListener = listener;
    }
    public boolean isAllowSleep() {
        return allowSleep;
    }
    public void setAllowSleep(boolean flag) {
        if (flag == allowSleep) {
            return;
        }
        allowSleep = flag;
        if (!allowSleep) {
            for (Body b : bodies) {
                b.setAwake(true);
            }
        }
    }
    public void setSubStepping(boolean subStepping) {
        this.subStepping = subStepping;
    }
    public boolean isSubStepping() {
        return subStepping;
    }
    public ParticleSystem getParticleSystem() {
        return particleSystem;
    }
    public void setAutoClearForces(boolean flag) {
        autoClearForces = flag;
    }
    public boolean isAutoClearForces() {
        return autoClearForces;
    }
    public void setContactFilter(ContactFilter filter) {
        contactManager.setContactFilter(filter);
    }
    public void setContactListener(ContactListener listener) {
        contactManager.setContactListener(listener);
    }
    void notifyNewFixture() {
        newFixture = true;
    }
    public boolean isLocked() {
        return locked;
    }
    void assertNotLocked() {
        if (isLocked())
            throw new IllegalStateException("Physics world is locked during time step");
    }
    private static class WorldQueryWrapper implements TreeCallback {
        BroadPhase broadPhase;
        QueryCallback callback;
        @Override
        public boolean treeCallback(int nodeId) {
            Fixture.FixtureProxy proxy = (Fixture.FixtureProxy) broadPhase.getUserData(nodeId);
            return callback.reportFixture(proxy.fixture);
        }
    }
    private static class WorldRayCastWrapper implements TreeRayCastCallback {
        private final RayCastOutput output = new RayCastOutput();
        private final Vec2 temp = new Vec2();
        private final Vec2 point = new Vec2();
        BroadPhase broadPhase;
        RayCastCallback callback;
        @Override
        public float raycastCallback(RayCastInput input, int nodeId) {
            Object userData = broadPhase.getUserData(nodeId);
            Fixture.FixtureProxy proxy = (Fixture.FixtureProxy) userData;
            Fixture fixture = proxy.fixture;
            int index = proxy.childIndex;
            boolean hit = fixture.raycast(output, input, index);
            if (hit) {
                float fraction = output.fraction;
                temp.set(input.p2).mulLocal(fraction);
                point.set(input.p1).mulLocal(1 - fraction).addLocal(temp);
                return callback.reportFixture(fixture, point, output.normal, fraction);
            }
            return input.maxFraction;
        }
    }
}
package com.almasb.fxgl.physics.box2d.collision;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.common.JBoxSettings;
import com.almasb.fxgl.physics.box2d.pooling.IWorldPool;
import static com.almasb.fxgl.core.math.FXGLMath.abs;
public final class AABB {
    public final Vec2 lowerBound;
    public final Vec2 upperBound;
    public AABB() {
        lowerBound = new Vec2();
        upperBound = new Vec2();
    }
    public AABB(AABB copy) {
        this(copy.lowerBound, copy.upperBound);
    }
    public AABB(Vec2 lowerVertex, Vec2 upperVertex) {
        this.lowerBound = lowerVertex.copy();
        this.upperBound = upperVertex.copy();
    }
    public void set(AABB aabb) {
        Vec2 v = aabb.lowerBound;
        lowerBound.x = v.x;
        lowerBound.y = v.y;
        Vec2 v1 = aabb.upperBound;
        upperBound.x = v1.x;
        upperBound.y = v1.y;
    }
    public Vec2 getCenter() {
        return new Vec2(lowerBound)
                .addLocal(upperBound)
                .mulLocal(0.5);
    }
    public Vec2 getExtents() {
        return new Vec2(upperBound)
                .subLocal(lowerBound)
                .mulLocal(0.5);
    }
    public float getPerimeter() {
        return 2.0f * (upperBound.x - lowerBound.x + upperBound.y - lowerBound.y);
    }
    public void combine(AABB aabb1, AABB aabb2) {
        lowerBound.x = aabb1.lowerBound.x < aabb2.lowerBound.x ? aabb1.lowerBound.x : aabb2.lowerBound.x;
        lowerBound.y = aabb1.lowerBound.y < aabb2.lowerBound.y ? aabb1.lowerBound.y : aabb2.lowerBound.y;
        upperBound.x = aabb1.upperBound.x > aabb2.upperBound.x ? aabb1.upperBound.x : aabb2.upperBound.x;
        upperBound.y = aabb1.upperBound.y > aabb2.upperBound.y ? aabb1.upperBound.y : aabb2.upperBound.y;
    }
    public void combine(AABB aabb) {
        lowerBound.x = lowerBound.x < aabb.lowerBound.x ? lowerBound.x : aabb.lowerBound.x;
        lowerBound.y = lowerBound.y < aabb.lowerBound.y ? lowerBound.y : aabb.lowerBound.y;
        upperBound.x = upperBound.x > aabb.upperBound.x ? upperBound.x : aabb.upperBound.x;
        upperBound.y = upperBound.y > aabb.upperBound.y ? upperBound.y : aabb.upperBound.y;
    }
    public boolean contains(AABB aabb) {
        return lowerBound.x <= aabb.lowerBound.x && lowerBound.y <= aabb.lowerBound.y
                && aabb.upperBound.x <= upperBound.x && aabb.upperBound.y <= upperBound.y;
    }
    public boolean raycast(final RayCastOutput output, final RayCastInput input, IWorldPool argPool) {
        float tmin = -Float.MAX_VALUE;
        float tmax = Float.MAX_VALUE;
        final Vec2 p = argPool.popVec2();
        final Vec2 d = argPool.popVec2();
        final Vec2 absD = argPool.popVec2();
        final Vec2 normal = argPool.popVec2();
        p.set(input.p1);
        d.set(input.p2).subLocal(input.p1);
        absD.x = abs(d.x);
        absD.y = abs(d.y);
        if (absD.x < JBoxSettings.EPSILON) {
            if (p.x < lowerBound.x || upperBound.x < p.x) {
                argPool.pushVec2(4);
                return false;
            }
        } else {
            final float inv_d = 1.0f / d.x;
            float t1 = (lowerBound.x - p.x) * inv_d;
            float t2 = (upperBound.x - p.x) * inv_d;
            float s = -1.0f;
            if (t1 > t2) {
                final float temp = t1;
                t1 = t2;
                t2 = temp;
                s = 1.0f;
            }
            if (t1 > tmin) {
                normal.setZero();
                normal.x = s;
                tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) {
                argPool.pushVec2(4);
                return false;
            }
        }
        if (absD.y < JBoxSettings.EPSILON) {
            if (p.y < lowerBound.y || upperBound.y < p.y) {
                argPool.pushVec2(4);
                return false;
            }
        } else {
            final float inv_d = 1.0f / d.y;
            float t1 = (lowerBound.y - p.y) * inv_d;
            float t2 = (upperBound.y - p.y) * inv_d;
            float s = -1.0f;
            if (t1 > t2) {
                final float temp = t1;
                t1 = t2;
                t2 = temp;
                s = 1.0f;
            }
            if (t1 > tmin) {
                normal.setZero();
                normal.y = s;
                tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) {
                argPool.pushVec2(4);
                return false;
            }
        }
        if (tmin < 0.0f || input.maxFraction < tmin) {
            argPool.pushVec2(4);
            return false;
        }
        output.fraction = tmin;
        output.normal.x = normal.x;
        output.normal.y = normal.y;
        argPool.pushVec2(4);
        return true;
    }
    public static boolean testOverlap(AABB a, AABB b) {
        if (b.lowerBound.x - a.upperBound.x > 0 || b.lowerBound.y - a.upperBound.y > 0
                || a.lowerBound.x - b.upperBound.x > 0 || a.lowerBound.y - b.upperBound.y > 0) {
            return false;
        }
        return true;
    }
    @Override
    public String toString() {
        return "AABB[" + lowerBound + " . " + upperBound + "]";
    }
}
package com.almasb.fxgl.physics.box2d.collision.shapes;
import com.almasb.fxgl.core.math.Vec2;
public class MassData {
    public float mass = 0;
    public final Vec2 center = new Vec2();
    public float I = 0;
}
package com.almasb.fxgl.physics.box2d.common;
import com.almasb.fxgl.core.math.Vec2;
import java.io.Serializable;
public final class Transform implements Serializable {
    private static final long serialVersionUID = 1L;
    public final Vec2 p = new Vec2();
    public final Rotation q = new Rotation();
    public Transform set(final Transform xf) {
        p.set(xf.p);
        q.set(xf.q);
        return this;
    }
    public void set(Vec2 p, float angle) {
        this.p.set(p);
        q.set(angle);
    }
    public void setIdentity() {
        p.setZero();
        q.setIdentity();
    }
    public float mulX(Vec2 v) {
        return q.c * v.x - q.s * v.y + p.x;
    }
    public float mulY(Vec2 v) {
        return q.s * v.x + q.c * v.y + p.y;
    }
    public void shift(Vec2 v) {
        p.x -= q.c * v.x - q.s * v.y;
        p.y -= q.s * v.x + q.c * v.y;
    }
    public static Vec2 mul(Transform T, Vec2 v) {
        return new Vec2(T.q.c * v.x - T.q.s * v.y + T.p.x, T.q.s * v.x + T.q.c * v.y + T.p.y);
    }
    public static void mulToOut(Transform T, Vec2 v, Vec2 out) {
        float tempy = T.q.s * v.x + T.q.c * v.y + T.p.y;
        out.x = T.q.c * v.x - T.q.s * v.y + T.p.x;
        out.y = tempy;
    }
    public static void mulToOutUnsafe(Transform T, Vec2 v, Vec2 out) {
        assert v != out;
        out.x = T.q.c * v.x - T.q.s * v.y + T.p.x;
        out.y = T.q.s * v.x + T.q.c * v.y + T.p.y;
    }
    public static void mulTransToOut(Transform T, Vec2 v, Vec2 out) {
        float px = v.x - T.p.x;
        float py = v.y - T.p.y;
        float tempy = -T.q.s * px + T.q.c * py;
        out.x = T.q.c * px + T.q.s * py;
        out.y = tempy;
    }
    public static void mulTransToOutUnsafe(Transform T, Vec2 v, Vec2 out) {
        assert v != out;
        float px = v.x - T.p.x;
        float py = v.y - T.p.y;
        out.x = T.q.c * px + T.q.s * py;
        out.y = -T.q.s * px + T.q.c * py;
    }
    public static void mulToOut(Transform A, Transform B, Transform out) {
        assert out != A;
        Rotation.mul(A.q, B.q, out.q);
        Rotation.mulToOut(A.q, B.p, out.p);
        out.p.addLocal(A.p);
    }
    private static Vec2 pool = new Vec2();
    public static void mulTransToOutUnsafe(Transform A, Transform B,
                                                 Transform out) {
        assert out != A;
        assert out != B;
        Rotation.mulTransUnsafe(A.q, B.q, out.q);
        pool.set(B.p).subLocal(A.p);
        Rotation.mulTransUnsafe(A.q, pool, out.p);
    }
    @Override
    public String toString() {
        String s = "XForm:\n";
        s += "Position: " + p + "\n";
        s += "R: \n" + q + "\n";
        return s;
    }
}
package com.almasb.fxgl.physics.box2d.dynamics;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.physics.box2d.collision.broadphase.BroadPhase;
import com.almasb.fxgl.physics.box2d.collision.shapes.MassData;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.Rotation;
import com.almasb.fxgl.physics.box2d.common.Sweep;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactEdge;
import com.almasb.fxgl.physics.box2d.dynamics.joints.JointEdge;
import java.util.ArrayList;
import java.util.List;
public final class Body {
    private static final int e_islandFlag = 0x0001;
    private static final int e_awakeFlag = 0x0002;
    private static final int e_bulletFlag = 0x0008;
    private static final int e_fixedRotationFlag = 0x0010;
    private static final int e_activeFlag = 0x0020;
    private final World world;
    private BodyType type;
    private List<Fixture> fixtures = new ArrayList<>();
    public JointEdge m_jointList = null;
    public ContactEdge m_contactList = null;
    public int m_flags = 0;
    private boolean isSleepingAllowed = false;
    public int m_islandIndex;
    public final Transform m_xf = new Transform();
    public final Transform m_xf0 = new Transform();
    public final Sweep m_sweep = new Sweep();
    private final Vec2 linearVelocity = new Vec2();
    private float angularVelocity;
    private final Vec2 m_force = new Vec2();
    private float m_torque = 0;
    private float m_mass;
    public float m_invMass;
    private float m_I = 0;
    public float m_invI = 0;
    private float linearDamping;
    private float angularDamping;
    private float gravityScale;
    private float sleepTime = 0;
    private final BroadPhase broadPhase;
    private Object userData;
    private Entity entity;
    Body(BodyDef bd, World world) {
        checkValid(bd);
        this.world = world;
        broadPhase = world.getContactManager().broadPhase;
        userData = bd.getUserData();
        if (bd.isBullet()) {
            m_flags |= e_bulletFlag;
        }
        if (bd.isFixedRotation()) {
            m_flags |= e_fixedRotationFlag;
        }
        if (bd.isAllowSleep()) {
            isSleepingAllowed = true;
        }
        if (bd.isAwake()) {
            m_flags |= e_awakeFlag;
        }
        if (bd.isActive()) {
            m_flags |= e_activeFlag;
        }
        m_xf.p.set(bd.getPosition());
        m_xf.q.set(bd.getAngle());
        m_sweep.localCenter.setZero();
        m_sweep.c0.set(m_xf.p);
        m_sweep.c.set(m_xf.p);
        m_sweep.a0 = bd.getAngle();
        m_sweep.a = bd.getAngle();
        m_sweep.alpha0 = 0.0f;
        linearVelocity.set(bd.getLinearVelocity());
        angularVelocity = bd.getAngularVelocity();
        linearDamping = bd.getLinearDamping();
        angularDamping = bd.getAngularDamping();
        gravityScale = bd.getGravityScale();
        type = bd.getType();
        if (type == BodyType.DYNAMIC) {
            m_mass = 1f;
            m_invMass = 1f;
        } else {
            m_mass = 0f;
            m_invMass = 0f;
        }
    }
    private void checkValid(BodyDef def) {
        if (def.getGravityScale() < 0)
            throw new IllegalArgumentException("Gravity scale is invalid");
        if (def.getAngularDamping() < 0)
            throw new IllegalArgumentException("Angular damping is invalid");
        if (def.getLinearDamping() < 0)
            throw new IllegalArgumentException("Linear damping is invalid");
    }
    public float getTorque() {
        return m_torque;
    }
    public void setTorque(float torque) {
        m_torque = torque;
    }
    public void setEntity(Entity entity) {
        this.entity = entity;
    }
    public Entity getEntity() {
        return entity;
    }
    public List<Fixture> getFixtures() {
        return fixtures;
    }
    public Fixture createFixture(FixtureDef def) {
        world.assertNotLocked();
        Fixture fixture = new Fixture(this, def);
        if ((m_flags & e_activeFlag) == e_activeFlag) {
            fixture.createProxies(broadPhase, m_xf);
        }
        fixtures.add(fixture);
        if (fixture.getDensity() > 0) {
            resetMassData();
        }
        world.notifyNewFixture();
        return fixture;
    }
    private final FixtureDef fixDef = new FixtureDef();
    public Fixture createFixture(Shape shape, float density) {
        fixDef.setShape(shape);
        fixDef.setDensity(density);
        return createFixture(fixDef);
    }
    public void destroyFixture(Fixture fixture) {
        world.assertNotLocked();
        fixtures.remove(fixture);
        ContactEdge edge = m_contactList;
        while (edge != null) {
            Contact c = edge.contact;
            edge = edge.next;
            if (fixture == c.getFixtureA() || fixture == c.getFixtureB()) {
                world.getContactManager().destroy(c);
            }
        }
        if ((m_flags & e_activeFlag) == e_activeFlag) {
            fixture.destroyProxies(broadPhase);
        }
        fixture.destroy();
        resetMassData();
    }
    public void setTransform(Vec2 position, float angle) {
        world.assertNotLocked();
        m_xf.q.set(angle);
        m_xf.p.set(position);
        Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c);
        m_sweep.a = angle;
        m_sweep.c0.set(m_sweep.c);
        m_sweep.a0 = m_sweep.a;
        for (Fixture f : fixtures) {
            f.synchronize(broadPhase, m_xf, m_xf);
        }
    }
    public Transform getTransform() {
        return m_xf;
    }
    public Vec2 getPosition() {
        return m_xf.p;
    }
    public float getAngle() {
        return m_sweep.a;
    }
    public Vec2 getWorldCenter() {
        return m_sweep.c;
    }
    public Vec2 getLocalCenter() {
        return m_sweep.localCenter;
    }
    public void setLinearVelocity(Vec2 v) {
        if (type == BodyType.STATIC) {
            return;
        }
        if (Vec2.dot(v, v) > 0) {
            setAwake(true);
        }
        linearVelocity.set(v);
    }
    void setLinearVelocityDirectly(float vx, float vy) {
        linearVelocity.set(vx, vy);
    }
    public Vec2 getLinearVelocity() {
        return linearVelocity;
    }
    public void setAngularVelocity(float w) {
        if (type == BodyType.STATIC) {
            return;
        }
        if (w * w > 0f) {
            setAwake(true);
        }
        angularVelocity = w;
    }
    void setAngularVelocityDirectly(float angularVelocity) {
        this.angularVelocity = angularVelocity;
    }
    public float getAngularVelocity() {
        return angularVelocity;
    }
    public float getGravityScale() {
        return gravityScale;
    }
    public void setGravityScale(float gravityScale) {
        this.gravityScale = gravityScale;
    }
    public void applyForce(Vec2 force, Vec2 point) {
        applyForceToCenter(force);
        m_torque += (point.x - m_sweep.c.x) * force.y - (point.y - m_sweep.c.y) * force.x;
    }
    public void applyForceToCenter(Vec2 force) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            setAwake(true);
        }
        m_force.addLocal(force);
    }
    public void applyTorque(float torque) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            setAwake(true);
        }
        m_torque += torque;
    }
    public void applyLinearImpulse(Vec2 impulse, Vec2 point, boolean wake) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            if (wake) {
                setAwake(true);
            } else {
                return;
            }
        }
        linearVelocity.x += impulse.x * m_invMass;
        linearVelocity.y += impulse.y * m_invMass;
        angularVelocity += m_invI * ((point.x - m_sweep.c.x) * impulse.y - (point.y - m_sweep.c.y) * impulse.x);
    }
    public void applyAngularImpulse(float impulse) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            setAwake(true);
        }
        angularVelocity += m_invI * impulse;
    }
    public float getMass() {
        return m_mass;
    }
    public float getInertia() {
        return m_I + m_mass * Vec2.dot(m_sweep.localCenter, m_sweep.localCenter);
    }
    public void getMassData(MassData data) {
        data.mass = m_mass;
        data.I = getInertia();
        data.center.set(m_sweep.localCenter);
    }
    public void setMassData(MassData massData) {
        world.assertNotLocked();
        if (type != BodyType.DYNAMIC) {
            return;
        }
        m_I = 0;
        m_invI = 0;
        m_mass = massData.mass;
        if (m_mass <= 0) {
            m_mass = 1;
        }
        m_invMass = 1.0f / m_mass;
        if (massData.I > 0 && (m_flags & e_fixedRotationFlag) == 0) {
            m_I = massData.I - m_mass * Vec2.dot(massData.center, massData.center);
            assert m_I > 0;
            m_invI = 1.0f / m_I;
        }
        final Vec2 oldCenter = world.getPool().popVec2();
        oldCenter.set(m_sweep.c);
        m_sweep.localCenter.set(massData.center);
        Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c0);
        m_sweep.c.set(m_sweep.c0);
        final Vec2 temp = world.getPool().popVec2();
        temp.set(m_sweep.c).subLocal(oldCenter);
        final float tempY = angularVelocity * temp.x;
        temp.x = -angularVelocity * temp.y;
        temp.y = tempY;
        linearVelocity.addLocal(temp);
        world.getPool().pushVec2(2);
    }
    private final MassData pmd = new MassData();
    public void resetMassData() {
        m_mass = 0;
        m_invMass = 0;
        m_I = 0;
        m_invI = 0;
        m_sweep.localCenter.setZero();
        if (type == BodyType.STATIC || type == BodyType.KINEMATIC) {
            m_sweep.c0.set(m_xf.p);
            m_sweep.c.set(m_xf.p);
            m_sweep.a0 = m_sweep.a;
            return;
        }
        final Vec2 localCenter = world.getPool().popVec2();
        localCenter.setZero();
        final Vec2 temp = world.getPool().popVec2();
        final MassData massData = pmd;
        for (Fixture f : fixtures) {
            if (f.getDensity() == 0.0f) {
                continue;
            }
            f.getMassData(massData);
            m_mass += massData.mass;
            temp.set(massData.center).mulLocal(massData.mass);
            localCenter.addLocal(temp);
            m_I += massData.I;
        }
        if (m_mass > 0.0f) {
            m_invMass = 1.0f / m_mass;
            localCenter.mulLocal(m_invMass);
        } else {
            m_mass = 1.0f;
            m_invMass = 1.0f;
        }
        if (m_I > 0.0f && (m_flags & e_fixedRotationFlag) == 0) {
            m_I -= m_mass * Vec2.dot(localCenter, localCenter);
            assert m_I > 0.0f;
            m_invI = 1.0f / m_I;
        } else {
            m_I = 0.0f;
            m_invI = 0.0f;
        }
        Vec2 oldCenter = world.getPool().popVec2();
        oldCenter.set(m_sweep.c);
        m_sweep.localCenter.set(localCenter);
        Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c0);
        m_sweep.c.set(m_sweep.c0);
        temp.set(m_sweep.c).subLocal(oldCenter);
        final Vec2 temp2 = oldCenter;
        Vec2.crossToOutUnsafe(angularVelocity, temp, temp2);
        linearVelocity.addLocal(temp2);
        world.getPool().pushVec2(3);
    }
    public Vec2 getWorldPoint(Vec2 localPoint) {
        Vec2 v = new Vec2();
        getWorldPointToOut(localPoint, v);
        return v;
    }
    public void getWorldPointToOut(Vec2 localPoint, Vec2 out) {
        Transform.mulToOut(m_xf, localPoint, out);
    }
    public Vec2 getWorldVector(Vec2 localVector) {
        Vec2 out = new Vec2();
        getWorldVectorToOut(localVector, out);
        return out;
    }
    public void getWorldVectorToOut(Vec2 localVector, Vec2 out) {
        Rotation.mulToOut(m_xf.q, localVector, out);
    }
    public void getWorldVectorToOutUnsafe(Vec2 localVector, Vec2 out) {
        Rotation.mulToOutUnsafe(m_xf.q, localVector, out);
    }
    public Vec2 getLocalPoint(Vec2 worldPoint) {
        Vec2 out = new Vec2();
        getLocalPointToOut(worldPoint, out);
        return out;
    }
    public void getLocalPointToOut(Vec2 worldPoint, Vec2 out) {
        Transform.mulTransToOut(m_xf, worldPoint, out);
    }
    public Vec2 getLocalVector(Vec2 worldVector) {
        Vec2 out = new Vec2();
        getLocalVectorToOut(worldVector, out);
        return out;
    }
    public void getLocalVectorToOut(Vec2 worldVector, Vec2 out) {
        Rotation.mulTrans(m_xf.q, worldVector, out);
    }
    public void getLocalVectorToOutUnsafe(Vec2 worldVector, Vec2 out) {
        Rotation.mulTransUnsafe(m_xf.q, worldVector, out);
    }
    public Vec2 getLinearVelocityFromWorldPoint(Vec2 worldPoint) {
        Vec2 out = new Vec2();
        getLinearVelocityFromWorldPointToOut(worldPoint, out);
        return out;
    }
    public void getLinearVelocityFromWorldPointToOut(Vec2 worldPoint, Vec2 out) {
        final float tempX = worldPoint.x - m_sweep.c.x;
        final float tempY = worldPoint.y - m_sweep.c.y;
        out.x = -angularVelocity * tempY + linearVelocity.x;
        out.y = angularVelocity * tempX + linearVelocity.y;
    }
    public Vec2 getLinearVelocityFromLocalPoint(Vec2 localPoint) {
        Vec2 out = new Vec2();
        getLinearVelocityFromLocalPointToOut(localPoint, out);
        return out;
    }
    public void getLinearVelocityFromLocalPointToOut(Vec2 localPoint, Vec2 out) {
        getWorldPointToOut(localPoint, out);
        getLinearVelocityFromWorldPointToOut(out, out);
    }
    public float getLinearDamping() {
        return linearDamping;
    }
    public void setLinearDamping(float linearDamping) {
        this.linearDamping = linearDamping;
    }
    public float getAngularDamping() {
        return angularDamping;
    }
    public void setAngularDamping(float angularDamping) {
        this.angularDamping = angularDamping;
    }
    public float getSleepTime() {
        return sleepTime;
    }
    void setSleepTime(float sleepTime) {
        this.sleepTime = sleepTime;
    }
    public BodyType getType() {
        return type;
    }
    public void setType(BodyType type) {
        world.assertNotLocked();
        if (this.type == type) {
            return;
        }
        this.type = type;
        resetMassData();
        if (this.type == BodyType.STATIC) {
            linearVelocity.setZero();
            angularVelocity = 0.0f;
            m_sweep.a0 = m_sweep.a;
            m_sweep.c0.set(m_sweep.c);
            synchronizeFixtures();
        }
        setAwake(true);
        clearForces();
        destroyAttachedContacts();
        for (Fixture f : fixtures) {
            int proxyCount = f.getProxyCount();
            for (int i = 0; i < proxyCount; ++i) {
                broadPhase.touchProxy(f.getProxyId(i));
            }
        }
    }
    void clearForces() {
        m_force.setZero();
        m_torque = 0.0f;
    }
    Vec2 getForce() {
        return m_force;
    }
    void destroy() {
        destroyAttachedJoints();
        destroyAttachedContacts();
        destroyFixtures();
    }
    private void destroyAttachedJoints() {
        JointEdge je = this.m_jointList;
        while (je != null) {
            JointEdge je0 = je;
            je = je.next;
            if (world.getDestructionListener() != null) {
                world.getDestructionListener().onDestroy(je0.joint);
            }
            world.destroyJoint(je0.joint);
            this.m_jointList = je;
        }
        this.m_jointList = null;
    }
    private void destroyAttachedContacts() {
        ContactEdge ce = m_contactList;
        while (ce != null) {
            ContactEdge ce0 = ce;
            ce = ce.next;
            world.getContactManager().destroy(ce0.contact);
        }
        m_contactList = null;
    }
    private void destroyFixtures() {
        for (Fixture f : getFixtures()) {
            if (world.getDestructionListener() != null) {
                world.getDestructionListener().onDestroy(f);
            }
            f.destroyProxies(broadPhase);
            f.destroy();
        }
        getFixtures().clear();
    }
    public boolean isBullet() {
        return (m_flags & e_bulletFlag) == e_bulletFlag;
    }
    public void setBullet(boolean flag) {
        if (flag) {
            m_flags |= e_bulletFlag;
        } else {
            m_flags &= ~e_bulletFlag;
        }
    }
    boolean isIslandFlagOff() {
        return (m_flags & e_islandFlag) == 0;
    }
    boolean isIslandFlagOn() {
        return (m_flags & e_islandFlag) != 0;
    }
    boolean isIslandFlagOn2() {
        return (m_flags & e_islandFlag) == e_islandFlag;
    }
    void setIslandFlag(boolean flag) {
        if (flag) {
            m_flags |= e_islandFlag;
        } else {
            m_flags &= ~e_islandFlag;
        }
    }
    public void setSleepingAllowed(boolean flag) {
        isSleepingAllowed = flag;
        if (!isSleepingAllowed) {
            setAwake(true);
        }
    }
    public boolean isSleepingAllowed() {
        return isSleepingAllowed;
    }
    public void setAwake(boolean flag) {
        if (flag) {
            if ((m_flags & e_awakeFlag) == 0) {
                m_flags |= e_awakeFlag;
                sleepTime = 0.0f;
            }
        } else {
            m_flags &= ~e_awakeFlag;
            sleepTime = 0.0f;
            linearVelocity.setZero();
            angularVelocity = 0.0f;
            clearForces();
        }
    }
    public boolean isAwake() {
        return (m_flags & e_awakeFlag) == e_awakeFlag;
    }
    public void setActive(boolean flag) {
        world.assertNotLocked();
        if (flag == isActive()) {
            return;
        }
        if (flag) {
            m_flags |= e_activeFlag;
            for (Fixture f : fixtures) {
                f.createProxies(broadPhase, m_xf);
            }
        } else {
            m_flags &= ~e_activeFlag;
            for (Fixture f : fixtures) {
                f.destroyProxies(broadPhase);
            }
            destroyAttachedContacts();
        }
    }
    public boolean isActive() {
        return (m_flags & e_activeFlag) == e_activeFlag;
    }
    public void setFixedRotation(boolean flag) {
        if (flag) {
            m_flags |= e_fixedRotationFlag;
        } else {
            m_flags &= ~e_fixedRotationFlag;
        }
        resetMassData();
    }
    public boolean isFixedRotation() {
        return (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;
    }
    public JointEdge getJointList() {
        return m_jointList;
    }
    public ContactEdge getContactList() {
        return m_contactList;
    }
    public Object getUserData() {
        return userData;
    }
    public void setUserData(Object data) {
        userData = data;
    }
    public World getWorld() {
        return world;
    }
    private final Transform pxf = new Transform();
    void synchronizeFixtures() {
        final Transform xf1 = pxf;
        xf1.q.set(m_sweep.a0);
        xf1.p.x = m_sweep.c0.x - xf1.q.c * m_sweep.localCenter.x + xf1.q.s * m_sweep.localCenter.y;
        xf1.p.y = m_sweep.c0.y - xf1.q.s * m_sweep.localCenter.x - xf1.q.c * m_sweep.localCenter.y;
        for (Fixture f : fixtures) {
            f.synchronize(broadPhase, xf1, m_xf);
        }
    }
    void synchronizeTransform() {
        m_xf.q.set(m_sweep.a);
        Rotation q = m_xf.q;
        Vec2 v = m_sweep.localCenter;
        m_xf.p.x = m_sweep.c.x - q.c * v.x + q.s * v.y;
        m_xf.p.y = m_sweep.c.y - q.s * v.x - q.c * v.y;
    }
    public boolean shouldCollide(Body other) {
        if (type != BodyType.DYNAMIC && other.type != BodyType.DYNAMIC) {
            return false;
        }
        for (JointEdge jn = m_jointList; jn != null; jn = jn.next) {
            if (jn.other == other && !jn.joint.getCollideConnected()) {
                return false;
            }
        }
        return true;
    }
    void advance(float t) {
        m_sweep.advance(t);
        m_sweep.c.set(m_sweep.c0);
        m_sweep.a = m_sweep.a0;
        m_xf.q.set(m_sweep.a);
        Rotation.mulToOutUnsafe(m_xf.q, m_sweep.localCenter, m_xf.p);
        m_xf.p.mulLocal(-1).addLocal(m_sweep.c);
    }
}
package com.almasb.fxgl.physics.box2d.callbacks;
import com.almasb.fxgl.physics.box2d.dynamics.Filter;
import com.almasb.fxgl.physics.box2d.dynamics.Fixture;
public class ContactFilter {
    public boolean shouldCollide(Fixture fixtureA, Fixture fixtureB) {
        Filter filterA = fixtureA.getFilterData();
        Filter filterB = fixtureB.getFilterData();
        if (filterA.groupIndex == filterB.groupIndex && filterA.groupIndex != 0) {
            return filterA.groupIndex > 0;
        }
        return (filterA.maskBits & filterB.categoryBits) != 0 &&
                (filterA.categoryBits & filterB.maskBits) != 0;
    }
}
package com.almasb.fxgl.physics.box2d.dynamics.contacts;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.collision.Manifold;
import com.almasb.fxgl.physics.box2d.collision.ManifoldPoint;
import com.almasb.fxgl.physics.box2d.collision.WorldManifold;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.JBoxSettings;
import com.almasb.fxgl.physics.box2d.common.Mat22;
import com.almasb.fxgl.physics.box2d.common.Rotation;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.Body;
import com.almasb.fxgl.physics.box2d.dynamics.Fixture;
import com.almasb.fxgl.physics.box2d.dynamics.TimeStep;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint;
public final class ContactSolver {
    private static final int INITIAL_NUM_CONSTRAINTS = 256;
    private static final float k_maxConditionNumber = 100.0f;
    private Position[] m_positions;
    private Velocity[] m_velocities;
    private ContactPositionConstraint[] m_positionConstraints = new ContactPositionConstraint[INITIAL_NUM_CONSTRAINTS];
    private ContactVelocityConstraint[] m_velocityConstraints = new ContactVelocityConstraint[INITIAL_NUM_CONSTRAINTS];
    private Contact[] m_contacts;
    private int m_count;
    public ContactSolver() {
        for (int i = 0; i < INITIAL_NUM_CONSTRAINTS; i++) {
            m_positionConstraints[i] = new ContactPositionConstraint();
            m_velocityConstraints[i] = new ContactVelocityConstraint();
        }
    }
    public ContactVelocityConstraint[] getVelocityConstraints() {
        return m_velocityConstraints;
    }
    public void init(ContactSolverDef def) {
        TimeStep step = def.step;
        m_count = def.count;
        if (m_positionConstraints.length < m_count) {
            ContactPositionConstraint[] old = m_positionConstraints;
            m_positionConstraints = new ContactPositionConstraint[Math.max(old.length * 2, m_count)];
            System.arraycopy(old, 0, m_positionConstraints, 0, old.length);
            for (int i = old.length; i < m_positionConstraints.length; i++) {
                m_positionConstraints[i] = new ContactPositionConstraint();
            }
        }
        if (m_velocityConstraints.length < m_count) {
            ContactVelocityConstraint[] old = m_velocityConstraints;
            m_velocityConstraints = new ContactVelocityConstraint[Math.max(old.length * 2, m_count)];
            System.arraycopy(old, 0, m_velocityConstraints, 0, old.length);
            for (int i = old.length; i < m_velocityConstraints.length; i++) {
                m_velocityConstraints[i] = new ContactVelocityConstraint();
            }
        }
        m_positions = def.positions;
        m_velocities = def.velocities;
        m_contacts = def.contacts;
        for (int i = 0; i < m_count; ++i) {
            final Contact contact = m_contacts[i];
            final Fixture fixtureA = contact.m_fixtureA;
            final Fixture fixtureB = contact.m_fixtureB;
            final Shape shapeA = fixtureA.getShape();
            final Shape shapeB = fixtureB.getShape();
            final float radiusA = shapeA.getRadius();
            final float radiusB = shapeB.getRadius();
            final Body bodyA = fixtureA.getBody();
            final Body bodyB = fixtureB.getBody();
            final Manifold manifold = contact.getManifold();
            int pointCount = manifold.pointCount;
            assert pointCount > 0;
            ContactVelocityConstraint vc = m_velocityConstraints[i];
            vc.friction = contact.getFriction();
            vc.restitution = contact.getRestitution();
            vc.tangentSpeed = contact.getTangentSpeed();
            vc.indexA = bodyA.m_islandIndex;
            vc.indexB = bodyB.m_islandIndex;
            vc.invMassA = bodyA.m_invMass;
            vc.invMassB = bodyB.m_invMass;
            vc.invIA = bodyA.m_invI;
            vc.invIB = bodyB.m_invI;
            vc.contactIndex = i;
            vc.pointCount = pointCount;
            vc.K.setZero();
            vc.normalMass.setZero();
            ContactPositionConstraint pc = m_positionConstraints[i];
            pc.indexA = bodyA.m_islandIndex;
            pc.indexB = bodyB.m_islandIndex;
            pc.invMassA = bodyA.m_invMass;
            pc.invMassB = bodyB.m_invMass;
            pc.localCenterA.set(bodyA.m_sweep.localCenter);
            pc.localCenterB.set(bodyB.m_sweep.localCenter);
            pc.invIA = bodyA.m_invI;
            pc.invIB = bodyB.m_invI;
            pc.localNormal.set(manifold.localNormal);
            pc.localPoint.set(manifold.localPoint);
            pc.pointCount = pointCount;
            pc.radiusA = radiusA;
            pc.radiusB = radiusB;
            pc.type = manifold.type;
            for (int j = 0; j < pointCount; j++) {
                ManifoldPoint cp = manifold.points[j];
                VelocityConstraintPoint vcp = vc.points[j];
                if (step.warmStarting) {
                    vcp.normalImpulse = step.dtRatio * cp.normalImpulse;
                    vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;
                } else {
                    vcp.normalImpulse = 0;
                    vcp.tangentImpulse = 0;
                }
                vcp.rA.setZero();
                vcp.rB.setZero();
                vcp.normalMass = 0;
                vcp.tangentMass = 0;
                vcp.velocityBias = 0;
                pc.localPoints[j].x = cp.localPoint.x;
                pc.localPoints[j].y = cp.localPoint.y;
            }
        }
    }
    public void warmStart() {
        for (int i = 0; i < m_count; ++i) {
            final ContactVelocityConstraint vc = m_velocityConstraints[i];
            int indexA = vc.indexA;
            int indexB = vc.indexB;
            float mA = vc.invMassA;
            float iA = vc.invIA;
            float mB = vc.invMassB;
            float iB = vc.invIB;
            int pointCount = vc.pointCount;
            Vec2 vA = m_velocities[indexA].v;
            float wA = m_velocities[indexA].w;
            Vec2 vB = m_velocities[indexB].v;
            float wB = m_velocities[indexB].w;
            Vec2 normal = vc.normal;
            float tangentx = 1.0f * normal.y;
            float tangenty = -1.0f * normal.x;
            for (int j = 0; j < pointCount; ++j) {
                VelocityConstraintPoint vcp = vc.points[j];
                float Px = tangentx * vcp.tangentImpulse + normal.x * vcp.normalImpulse;
                float Py = tangenty * vcp.tangentImpulse + normal.y * vcp.normalImpulse;
                wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
                vA.x -= Px * mA;
                vA.y -= Py * mA;
                wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
                vB.x += Px * mB;
                vB.y += Py * mB;
            }
            m_velocities[indexA].w = wA;
            m_velocities[indexB].w = wB;
        }
    }
    private final Transform xfA = new Transform();
    private final Transform xfB = new Transform();
    private final WorldManifold worldManifold = new WorldManifold();
    public void initializeVelocityConstraints() {
        for (int i = 0; i < m_count; ++i) {
            ContactVelocityConstraint vc = m_velocityConstraints[i];
            ContactPositionConstraint pc = m_positionConstraints[i];
            float radiusA = pc.radiusA;
            float radiusB = pc.radiusB;
            Manifold manifold = m_contacts[vc.contactIndex].getManifold();
            int indexA = vc.indexA;
            int indexB = vc.indexB;
            float mA = vc.invMassA;
            float mB = vc.invMassB;
            float iA = vc.invIA;
            float iB = vc.invIB;
            Vec2 localCenterA = pc.localCenterA;
            Vec2 localCenterB = pc.localCenterB;
            Vec2 cA = m_positions[indexA].c;
            float aA = m_positions[indexA].a;
            Vec2 vA = m_velocities[indexA].v;
            float wA = m_velocities[indexA].w;
            Vec2 cB = m_positions[indexB].c;
            float aB = m_positions[indexB].a;
            Vec2 vB = m_velocities[indexB].v;
            float wB = m_velocities[indexB].w;
            assert manifold.pointCount > 0;
            final Rotation xfAq = xfA.q;
            final Rotation xfBq = xfB.q;
            xfAq.set(aA);
            xfBq.set(aB);
            xfA.p.x = cA.x - (xfAq.c * localCenterA.x - xfAq.s * localCenterA.y);
            xfA.p.y = cA.y - (xfAq.s * localCenterA.x + xfAq.c * localCenterA.y);
            xfB.p.x = cB.x - (xfBq.c * localCenterB.x - xfBq.s * localCenterB.y);
            xfB.p.y = cB.y - (xfBq.s * localCenterB.x + xfBq.c * localCenterB.y);
            worldManifold.initialize(manifold, xfA, radiusA, xfB, radiusB);
            final Vec2 vcnormal = vc.normal;
            vcnormal.set(worldManifold.getNormalX(), worldManifold.getNormalY());
            int pointCount = vc.pointCount;
            for (int j = 0; j < pointCount; ++j) {
                VelocityConstraintPoint vcp = vc.points[j];
                Vec2 wmPj = worldManifold.getPoint(j);
                final Vec2 vcprA = vcp.rA;
                final Vec2 vcprB = vcp.rB;
                vcprA.x = wmPj.x - cA.x;
                vcprA.y = wmPj.y - cA.y;
                vcprB.x = wmPj.x - cB.x;
                vcprB.y = wmPj.y - cB.y;
                float rnA = vcprA.x * vcnormal.y - vcprA.y * vcnormal.x;
                float rnB = vcprB.x * vcnormal.y - vcprB.y * vcnormal.x;
                float kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                vcp.normalMass = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;
                float tangentx = 1.0f * vcnormal.y;
                float tangenty = -1.0f * vcnormal.x;
                float rtA = vcprA.x * tangenty - vcprA.y * tangentx;
                float rtB = vcprB.x * tangenty - vcprB.y * tangentx;
                float kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
                vcp.tangentMass = kTangent > 0.0f ? 1.0f / kTangent : 0.0f;
                vcp.velocityBias = 0.0f;
                float tempx = vB.x + -wB * vcprB.y - vA.x - (-wA * vcprA.y);
                float tempy = vB.y + wB * vcprB.x - vA.y - (wA * vcprA.x);
                float vRel = vcnormal.x * tempx + vcnormal.y * tempy;
                if (vRel < -JBoxSettings.velocityThreshold) {
                    vcp.velocityBias = -vc.restitution * vRel;
                }
            }
            if (vc.pointCount == 2) {
                VelocityConstraintPoint vcp1 = vc.points[0];
                VelocityConstraintPoint vcp2 = vc.points[1];
                float rn1A = vcp1.rA.x * vcnormal.y - vcp1.rA.y * vcnormal.x;
                float rn1B = vcp1.rB.x * vcnormal.y - vcp1.rB.y * vcnormal.x;
                float rn2A = vcp2.rA.x * vcnormal.y - vcp2.rA.y * vcnormal.x;
                float rn2B = vcp2.rB.x * vcnormal.y - vcp2.rB.y * vcnormal.x;
                float k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
                float k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
                float k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                    vc.K.ex.x = k11;
                    vc.K.ex.y = k12;
                    vc.K.ey.x = k12;
                    vc.K.ey.y = k22;
                    vc.K.invertToOut(vc.normalMass);
                } else {
                    vc.pointCount = 1;
                }
            }
        }
    }
    @SuppressWarnings("PMD.AvoidBranchingStatementAsLastInLoop")
    public void solveVelocityConstraints() {
        for (int i = 0; i < m_count; ++i) {
            final ContactVelocityConstraint vc = m_velocityConstraints[i];
            int indexA = vc.indexA;
            int indexB = vc.indexB;
            float mA = vc.invMassA;
            float mB = vc.invMassB;
            float iA = vc.invIA;
            float iB = vc.invIB;
            int pointCount = vc.pointCount;
            Vec2 vA = m_velocities[indexA].v;
            float wA = m_velocities[indexA].w;
            Vec2 vB = m_velocities[indexB].v;
            float wB = m_velocities[indexB].w;
            Vec2 normal = vc.normal;
            final float normalx = normal.x;
            final float normaly = normal.y;
            float tangentx = 1.0f * vc.normal.y;
            float tangenty = -1.0f * vc.normal.x;
            final float friction = vc.friction;
            assert pointCount == 1 || pointCount == 2;
            for (int j = 0; j < pointCount; ++j) {
                final VelocityConstraintPoint vcp = vc.points[j];
                final Vec2 a = vcp.rA;
                float dvx = -wB * vcp.rB.y + vB.x - vA.x + wA * a.y;
                float dvy = wB * vcp.rB.x + vB.y - vA.y - wA * a.x;
                final float vt = dvx * tangentx + dvy * tangenty - vc.tangentSpeed;
                float lambda = vcp.tangentMass * (-vt);
                final float maxFriction = friction * vcp.normalImpulse;
                final float newImpulse = FXGLMath.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);
                lambda = newImpulse - vcp.tangentImpulse;
                vcp.tangentImpulse = newImpulse;
                final float Px = tangentx * lambda;
                final float Py = tangenty * lambda;
                vA.x -= Px * mA;
                vA.y -= Py * mA;
                wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
                vB.x += Px * mB;
                vB.y += Py * mB;
                wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
            }
            if (vc.pointCount == 1) {
                final VelocityConstraintPoint vcp = vc.points[0];
                float dvx = -wB * vcp.rB.y + vB.x - vA.x + wA * vcp.rA.y;
                float dvy = wB * vcp.rB.x + vB.y - vA.y - wA * vcp.rA.x;
                final float vn = dvx * normalx + dvy * normaly;
                float lambda = -vcp.normalMass * (vn - vcp.velocityBias);
                float a = vcp.normalImpulse + lambda;
                final float newImpulse = a > 0.0f ? a : 0.0f;
                lambda = newImpulse - vcp.normalImpulse;
                vcp.normalImpulse = newImpulse;
                float Px = normalx * lambda;
                float Py = normaly * lambda;
                vA.x -= Px * mA;
                vA.y -= Py * mA;
                wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
                vB.x += Px * mB;
                vB.y += Py * mB;
                wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
            } else {
                final VelocityConstraintPoint cp1 = vc.points[0];
                final VelocityConstraintPoint cp2 = vc.points[1];
                final Vec2 cp1rA = cp1.rA;
                final Vec2 cp1rB = cp1.rB;
                final Vec2 cp2rA = cp2.rA;
                final Vec2 cp2rB = cp2.rB;
                float ax = cp1.normalImpulse;
                float ay = cp2.normalImpulse;
                assert ax >= 0.0f && ay >= 0.0f;
                float dv1x = -wB * cp1rB.y + vB.x - vA.x + wA * cp1rA.y;
                float dv1y = wB * cp1rB.x + vB.y - vA.y - wA * cp1rA.x;
                float dv2x = -wB * cp2rB.y + vB.x - vA.x + wA * cp2rA.y;
                float dv2y = wB * cp2rB.x + vB.y - vA.y - wA * cp2rA.x;
                float vn1 = dv1x * normalx + dv1y * normaly;
                float vn2 = dv2x * normalx + dv2y * normaly;
                float bx = vn1 - cp1.velocityBias;
                float by = vn2 - cp2.velocityBias;
                Mat22 R = vc.K;
                bx -= R.ex.x * ax + R.ey.x * ay;
                by -= R.ex.y * ax + R.ey.y * ay;
                for (; ; ) {
                    Mat22 R1 = vc.normalMass;
                    float xx = R1.ex.x * bx + R1.ey.x * by;
                    float xy = R1.ex.y * bx + R1.ey.y * by;
                    xx *= -1;
                    xy *= -1;
                    if (xx >= 0.0f && xy >= 0.0f) {
                        float dx = xx - ax;
                        float dy = xy - ay;
                        float P1x = dx * normalx;
                        float P1y = dx * normaly;
                        float P2x = dy * normalx;
                        float P2y = dy * normaly;
                        vA.x -= mA * (P1x + P2x);
                        vA.y -= mA * (P1y + P2y);
                        vB.x += mB * (P1x + P2x);
                        vB.y += mB * (P1y + P2y);
                        wA -= iA * (cp1rA.x * P1y - cp1rA.y * P1x + (cp2rA.x * P2y - cp2rA.y * P2x));
                        wB += iB * (cp1rB.x * P1y - cp1rB.y * P1x + (cp2rB.x * P2y - cp2rB.y * P2x));
                        cp1.normalImpulse = xx;
                        cp2.normalImpulse = xy;
                        break;
                    }
                    xx = -cp1.normalMass * bx;
                    xy = 0.0f;
                    vn1 = 0.0f;
                    vn2 = vc.K.ex.y * xx + by;
                    if (xx >= 0.0f && vn2 >= 0.0f) {
                        float dx = xx - ax;
                        float dy = xy - ay;
                        float P1x = normalx * dx;
                        float P1y = normaly * dx;
                        float P2x = normalx * dy;
                        float P2y = normaly * dy;
                        vA.x -= mA * (P1x + P2x);
                        vA.y -= mA * (P1y + P2y);
                        vB.x += mB * (P1x + P2x);
                        vB.y += mB * (P1y + P2y);
                        wA -= iA * (cp1rA.x * P1y - cp1rA.y * P1x + (cp2rA.x * P2y - cp2rA.y * P2x));
                        wB += iB * (cp1rB.x * P1y - cp1rB.y * P1x + (cp2rB.x * P2y - cp2rB.y * P2x));
                        cp1.normalImpulse = xx;
                        cp2.normalImpulse = xy;
                        break;
                    }
                    xx = 0.0f;
                    xy = -cp2.normalMass * by;
                    vn1 = vc.K.ey.x * xy + bx;
                    vn2 = 0.0f;
                    if (xy >= 0.0f && vn1 >= 0.0f) {
                        float dx = xx - ax;
                        float dy = xy - ay;
                        float P1x = normalx * dx;
                        float P1y = normaly * dx;
                        float P2x = normalx * dy;
                        float P2y = normaly * dy;
                        vA.x -= mA * (P1x + P2x);
                        vA.y -= mA * (P1y + P2y);
                        vB.x += mB * (P1x + P2x);
                        vB.y += mB * (P1y + P2y);
                        wA -= iA * (cp1rA.x * P1y - cp1rA.y * P1x + (cp2rA.x * P2y - cp2rA.y * P2x));
                        wB += iB * (cp1rB.x * P1y - cp1rB.y * P1x + (cp2rB.x * P2y - cp2rB.y * P2x));
                        cp1.normalImpulse = xx;
                        cp2.normalImpulse = xy;
                        break;
                    }
                    xx = 0.0f;
                    xy = 0.0f;
                    vn1 = bx;
                    vn2 = by;
                    if (vn1 >= 0.0f && vn2 >= 0.0f) {
                        float dx = xx - ax;
                        float dy = xy - ay;
                        float P1x = normalx * dx;
                        float P1y = normaly * dx;
                        float P2x = normalx * dy;
                        float P2y = normaly * dy;
                        vA.x -= mA * (P1x + P2x);
                        vA.y -= mA * (P1y + P2y);
                        vB.x += mB * (P1x + P2x);
                        vB.y += mB * (P1y + P2y);
                        wA -= iA * (cp1rA.x * P1y - cp1rA.y * P1x + (cp2rA.x * P2y - cp2rA.y * P2x));
                        wB += iB * (cp1rB.x * P1y - cp1rB.y * P1x + (cp2rB.x * P2y - cp2rB.y * P2x));
                        cp1.normalImpulse = xx;
                        cp2.normalImpulse = xy;
                        break;
                    }
                    break;
                }
            }
            m_velocities[indexA].w = wA;
            m_velocities[indexB].w = wB;
        }
    }
    public void storeImpulses() {
        for (int i = 0; i < m_count; i++) {
            final ContactVelocityConstraint vc = m_velocityConstraints[i];
            final Manifold manifold = m_contacts[vc.contactIndex].getManifold();
            for (int j = 0; j < vc.pointCount; j++) {
                manifold.points[j].normalImpulse = vc.points[j].normalImpulse;
                manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;
            }
        }
    }
    private final PositionSolverManifold psolver = new PositionSolverManifold();
    public boolean solvePositionConstraints() {
        float minSeparation = 0.0f;
        for (int i = 0; i < m_count; ++i) {
            ContactPositionConstraint pc = m_positionConstraints[i];
            int indexA = pc.indexA;
            int indexB = pc.indexB;
            float mA = pc.invMassA;
            float iA = pc.invIA;
            final float localCenterAx = pc.localCenterA.x;
            final float localCenterAy = pc.localCenterA.y;
            float mB = pc.invMassB;
            float iB = pc.invIB;
            final float localCenterBx = pc.localCenterB.x;
            final float localCenterBy = pc.localCenterB.y;
            int pointCount = pc.pointCount;
            Vec2 cA = m_positions[indexA].c;
            float aA = m_positions[indexA].a;
            Vec2 cB = m_positions[indexB].c;
            float aB = m_positions[indexB].a;
            for (int j = 0; j < pointCount; ++j) {
                final Rotation xfAq = xfA.q;
                final Rotation xfBq = xfB.q;
                xfAq.set(aA);
                xfBq.set(aB);
                xfA.p.x = cA.x - xfAq.c * localCenterAx + xfAq.s * localCenterAy;
                xfA.p.y = cA.y - xfAq.s * localCenterAx - xfAq.c * localCenterAy;
                xfB.p.x = cB.x - xfBq.c * localCenterBx + xfBq.s * localCenterBy;
                xfB.p.y = cB.y - xfBq.s * localCenterBx - xfBq.c * localCenterBy;
                psolver.initialize(pc, xfA, xfB, j);
                final Vec2 normal = psolver.normal;
                final Vec2 point = psolver.point;
                final float separation = psolver.separation;
                float rAx = point.x - cA.x;
                float rAy = point.y - cA.y;
                float rBx = point.x - cB.x;
                float rBy = point.y - cB.y;
                minSeparation = Math.min(minSeparation, separation);
                final float C =
                        FXGLMath.clamp(JBoxSettings.baumgarte * (separation + JBoxSettings.linearSlop),
                                -JBoxSettings.maxLinearCorrection, 0.0f);
                final float rnA = rAx * normal.y - rAy * normal.x;
                final float rnB = rBx * normal.y - rBy * normal.x;
                final float K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                final float impulse = K > 0.0f ? -C / K : 0.0f;
                float Px = normal.x * impulse;
                float Py = normal.y * impulse;
                cA.x -= Px * mA;
                cA.y -= Py * mA;
                aA -= iA * (rAx * Py - rAy * Px);
                cB.x += Px * mB;
                cB.y += Py * mB;
                aB += iB * (rBx * Py - rBy * Px);
            }
            m_positions[indexA].a = aA;
            m_positions[indexB].a = aB;
        }
        return minSeparation >= -3.0f * JBoxSettings.linearSlop;
    }
    public boolean solveTOIPositionConstraints(int toiIndexA, int toiIndexB) {
        float minSeparation = 0.0f;
        for (int i = 0; i < m_count; ++i) {
            ContactPositionConstraint pc = m_positionConstraints[i];
            int indexA = pc.indexA;
            int indexB = pc.indexB;
            Vec2 localCenterA = pc.localCenterA;
            Vec2 localCenterB = pc.localCenterB;
            final float localCenterAx = localCenterA.x;
            final float localCenterAy = localCenterA.y;
            final float localCenterBx = localCenterB.x;
            final float localCenterBy = localCenterB.y;
            int pointCount = pc.pointCount;
            float mA = 0.0f;
            float iA = 0.0f;
            if (indexA == toiIndexA || indexA == toiIndexB) {
                mA = pc.invMassA;
                iA = pc.invIA;
            }
            float mB = 0f;
            float iB = 0f;
            if (indexB == toiIndexA || indexB == toiIndexB) {
                mB = pc.invMassB;
                iB = pc.invIB;
            }
            Vec2 cA = m_positions[indexA].c;
            float aA = m_positions[indexA].a;
            Vec2 cB = m_positions[indexB].c;
            float aB = m_positions[indexB].a;
            for (int j = 0; j < pointCount; ++j) {
                final Rotation xfAq = xfA.q;
                final Rotation xfBq = xfB.q;
                xfAq.set(aA);
                xfBq.set(aB);
                xfA.p.x = cA.x - xfAq.c * localCenterAx + xfAq.s * localCenterAy;
                xfA.p.y = cA.y - xfAq.s * localCenterAx - xfAq.c * localCenterAy;
                xfB.p.x = cB.x - xfBq.c * localCenterBx + xfBq.s * localCenterBy;
                xfB.p.y = cB.y - xfBq.s * localCenterBx - xfBq.c * localCenterBy;
                final PositionSolverManifold psm = psolver;
                psm.initialize(pc, xfA, xfB, j);
                Vec2 normal = psm.normal;
                Vec2 point = psm.point;
                float separation = psm.separation;
                float rAx = point.x - cA.x;
                float rAy = point.y - cA.y;
                float rBx = point.x - cB.x;
                float rBy = point.y - cB.y;
                minSeparation = Math.min(minSeparation, separation);
                float C =
                        FXGLMath.clamp(JBoxSettings.toiBaugarte * (separation + JBoxSettings.linearSlop),
                                -JBoxSettings.maxLinearCorrection, 0.0f);
                float rnA = rAx * normal.y - rAy * normal.x;
                float rnB = rBx * normal.y - rBy * normal.x;
                float K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                float impulse = K > 0.0f ? -C / K : 0.0f;
                float Px = normal.x * impulse;
                float Py = normal.y * impulse;
                cA.x -= Px * mA;
                cA.y -= Py * mA;
                aA -= iA * (rAx * Py - rAy * Px);
                cB.x += Px * mB;
                cB.y += Py * mB;
                aB += iB * (rBx * Py - rBy * Px);
            }
            m_positions[indexA].a = aA;
            m_positions[indexB].a = aB;
        }
        return minSeparation >= -1.5f * JBoxSettings.linearSlop;
    }
    public static class ContactSolverDef {
        public TimeStep step;
        public Contact[] contacts;
        public int count;
        public Position[] positions;
        public Velocity[] velocities;
    }
    private static class PositionSolverManifold {
        final Vec2 normal = new Vec2();
        final Vec2 point = new Vec2();
        float separation;
        @SuppressWarnings("PMD.UselessParentheses")
        public void initialize(ContactPositionConstraint pc, Transform xfA, Transform xfB, int index) {
            assert pc.pointCount > 0;
            final Rotation xfAq = xfA.q;
            final Rotation xfBq = xfB.q;
            final Vec2 pcLocalPointsI = pc.localPoints[index];
            switch (pc.type) {
                case CIRCLES: {
                    final Vec2 plocalPoint = pc.localPoint;
                    final Vec2 pLocalPoints0 = pc.localPoints[0];
                    final float pointAx = (xfAq.c * plocalPoint.x - xfAq.s * plocalPoint.y) + xfA.p.x;
                    final float pointAy = (xfAq.s * plocalPoint.x + xfAq.c * plocalPoint.y) + xfA.p.y;
                    final float pointBx = (xfBq.c * pLocalPoints0.x - xfBq.s * pLocalPoints0.y) + xfB.p.x;
                    final float pointBy = (xfBq.s * pLocalPoints0.x + xfBq.c * pLocalPoints0.y) + xfB.p.y;
                    normal.x = pointBx - pointAx;
                    normal.y = pointBy - pointAy;
                    normal.getLengthAndNormalize();
                    point.x = (pointAx + pointBx) * .5f;
                    point.y = (pointAy + pointBy) * .5f;
                    final float tempx = pointBx - pointAx;
                    final float tempy = pointBy - pointAy;
                    separation = tempx * normal.x + tempy * normal.y - pc.radiusA - pc.radiusB;
                    break;
                }
                case FACE_A: {
                    final Vec2 pcLocalNormal = pc.localNormal;
                    final Vec2 pcLocalPoint = pc.localPoint;
                    normal.x = xfAq.c * pcLocalNormal.x - xfAq.s * pcLocalNormal.y;
                    normal.y = xfAq.s * pcLocalNormal.x + xfAq.c * pcLocalNormal.y;
                    final float planePointx = (xfAq.c * pcLocalPoint.x - xfAq.s * pcLocalPoint.y) + xfA.p.x;
                    final float planePointy = (xfAq.s * pcLocalPoint.x + xfAq.c * pcLocalPoint.y) + xfA.p.y;
                    final float clipPointx = (xfBq.c * pcLocalPointsI.x - xfBq.s * pcLocalPointsI.y) + xfB.p.x;
                    final float clipPointy = (xfBq.s * pcLocalPointsI.x + xfBq.c * pcLocalPointsI.y) + xfB.p.y;
                    final float tempx = clipPointx - planePointx;
                    final float tempy = clipPointy - planePointy;
                    separation = tempx * normal.x + tempy * normal.y - pc.radiusA - pc.radiusB;
                    point.x = clipPointx;
                    point.y = clipPointy;
                    break;
                }
                case FACE_B: {
                    final Vec2 pcLocalNormal = pc.localNormal;
                    final Vec2 pcLocalPoint = pc.localPoint;
                    normal.x = xfBq.c * pcLocalNormal.x - xfBq.s * pcLocalNormal.y;
                    normal.y = xfBq.s * pcLocalNormal.x + xfBq.c * pcLocalNormal.y;
                    final float planePointx = (xfBq.c * pcLocalPoint.x - xfBq.s * pcLocalPoint.y) + xfB.p.x;
                    final float planePointy = (xfBq.s * pcLocalPoint.x + xfBq.c * pcLocalPoint.y) + xfB.p.y;
                    final float clipPointx = (xfAq.c * pcLocalPointsI.x - xfAq.s * pcLocalPointsI.y) + xfA.p.x;
                    final float clipPointy = (xfAq.s * pcLocalPointsI.x + xfAq.c * pcLocalPointsI.y) + xfA.p.y;
                    final float tempx = clipPointx - planePointx;
                    final float tempy = clipPointy - planePointy;
                    separation = tempx * normal.x + tempy * normal.y - pc.radiusA - pc.radiusB;
                    point.x = clipPointx;
                    point.y = clipPointy;
                    normal.x *= -1;
                    normal.y *= -1;
                }
                break;
            }
        }
    }
}
package com.almasb.fxgl.physics.box2d.collision.broadphase;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.callbacks.PairCallback;
import com.almasb.fxgl.physics.box2d.callbacks.TreeCallback;
import com.almasb.fxgl.physics.box2d.callbacks.TreeRayCastCallback;
import com.almasb.fxgl.physics.box2d.collision.AABB;
import com.almasb.fxgl.physics.box2d.collision.RayCastInput;
public interface BroadPhase {
    int NULL_PROXY = -1;
    int createProxy(AABB aabb, Object userData);
    void destroyProxy(int proxyId);
    void moveProxy(int proxyId, AABB aabb, Vec2 displacement);
    void touchProxy(int proxyId);
    Object getUserData(int proxyId);
    boolean testOverlap(int proxyIdA, int proxyIdB);
    void updatePairs(PairCallback callback);
    void query(TreeCallback callback, AABB aabb);
    void raycast(TreeRayCastCallback callback, RayCastInput input);
}
package com.almasb.fxgl.core.math;
import com.almasb.fxgl.core.pool.Poolable;
import javafx.geometry.Point2D;
import java.io.Serializable;
public final class Vec2 implements Serializable, Poolable {
    private static final long serialVersionUID = 1L;
    public float x, y;
    public Vec2() {
        this(0, 0);
    }
    public Vec2(float x, float y) {
        this.x = x;
        this.y = y;
    }
    public Vec2(double x, double y) {
        this((float) x, (float) y);
    }
    public Vec2(Vec2 toCopy) {
        this(toCopy.x, toCopy.y);
    }
    public Vec2(Point2D toCopy) {
        this(toCopy.getX(), toCopy.getY());
    }
    public void setZero() {
        x = 0.0f;
        y = 0.0f;
    }
    public Vec2 set(float x, float y) {
        this.x = x;
        this.y = y;
        return this;
    }
    public Vec2 set(Vec2 v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    public Vec2 set(Point2D vector) {
        this.x = (float) vector.getX();
        this.y = (float) vector.getY();
        return this;
    }
    public Vec2 setFromAngle(double degrees) {
        this.x = (float) FXGLMath.cosDeg(degrees);
        this.y = (float) FXGLMath.sinDeg(degrees);
        return this;
    }
    public Vec2 add(Vec2 v) {
        return new Vec2(x + v.x, y + v.y);
    }
    public Vec2 add(Point2D vector) {
        return add(vector.getX(), vector.getY());
    }
    public Vec2 add(double otherX, double otherY) {
        return new Vec2(x + otherX, y + otherY);
    }
    public Vec2 sub(Vec2 v) {
        return new Vec2(x - v.x, y - v.y);
    }
    public Vec2 sub(Point2D vector) {
        return sub(vector.getX(), vector.getY());
    }
    public Vec2 sub(double otherX, double otherY) {
        return new Vec2(x - otherX, y - otherY);
    }
    public Vec2 mul(double a) {
        return new Vec2(x * a, y * a);
    }
    public Vec2 negate() {
        return new Vec2(-x, -y);
    }
    public Vec2 negateLocal() {
        x = -x;
        y = -y;
        return this;
    }
    public Vec2 addLocal(Vec2 v) {
        x += v.x;
        y += v.y;
        return this;
    }
    public Vec2 addLocal(double x, double y) {
        this.x += x;
        this.y += y;
        return this;
    }
    public Vec2 subLocal(Vec2 v) {
        x -= v.x;
        y -= v.y;
        return this;
    }
    public Vec2 subLocal(double x, double y) {
        this.x -= x;
        this.y -= y;
        return this;
    }
    public Vec2 mulLocal(double a) {
        x *= a;
        y *= a;
        return this;
    }
    public Vec2 perpendicularCCW() {
        return new Vec2(y, -x);
    }
    public Vec2 perpendicularCW() {
        return new Vec2(-y, x);
    }
    public Vec2 setLength(double length) {
        return normalizeLocal().mulLocal(length);
    }
    public float length() {
        return (float) FXGLMath.sqrt(x * x + y * y);
    }
    public float lengthSquared() {
        return x * x + y * y;
    }
    public double distance(Vec2 other) {
        return distance(other.x, other.y);
    }
    public float distanceF(Vec2 other) {
        return FXGLMath.sqrtF(distanceSquared(other));
    }
    public double distance(Point2D other) {
        return distance(other.getX(), other.getY());
    }
    public double distance(double otherX, double otherY) {
        double dx = otherX - x;
        double dy = otherY - y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    public float distanceSquared(Vec2 v) {
        float dx = x - v.x;
        float dy = y - v.y;
        return dx * dx + dy * dy;
    }
    public double distanceSquared(double otherX, double otherY) {
        double dx = otherX - x;
        double dy = otherY - y;
        return dx * dx + dy * dy;
    }
    public Vec2 normalize() {
        float length = length();
        if (length < FXGLMath.EPSILON) {
            return new Vec2();
        }
        float invLength = 1.0f / length;
        return new Vec2(x * invLength, y * invLength);
    }
    public float getLengthAndNormalize() {
        float length = length();
        if (length < FXGLMath.EPSILON) {
            return 0f;
        }
        float invLength = 1.0f / length;
        x *= invLength;
        y *= invLength;
        return length;
    }
    public Vec2 normalizeLocal() {
        getLengthAndNormalize();
        return this;
    }
    public Vec2 midpoint(Vec2 other) {
        return new Vec2(
                x + (other.x - x) / 2,
                y + (other.y - y) / 2
        );
    }
    public Vec2 midpoint(Point2D other) {
        return new Vec2(
                x + (other.getX() - x) / 2,
                y + (other.getY() - y) / 2
        );
    }
    public Vec2 abs() {
        return new Vec2(FXGLMath.abs(x), FXGLMath.abs(y));
    }
    public Vec2 absLocal() {
        x = FXGLMath.abs(x);
        y = FXGLMath.abs(y);
        return this;
    }
    public float angle() {
        return angle(1, 0);
    }
    public float angle(Vec2 other) {
        return angle(other.x, other.y);
    }
    public float angle(Point2D other) {
        return angle(other.getX(), other.getY());
    }
    public float angle(double otherX, double otherY) {
        double angle1 = Math.toDegrees(Math.atan2(y, x));
        double angle2 = Math.toDegrees(Math.atan2(otherY, otherX));
        return (float) (angle1 - angle2);
    }
    public Vec2 copy() {
        return new Vec2(x, y);
    }
    public Point2D toPoint2D() {
        return new Point2D(x, y);
    }
    @Override
    public String toString() {
        return "(" + x + "," + y + ")";
    }
    @Override
    public void reset() {
        setZero();
    }
    public static Vec2 fromAngle(double degrees) {
        return new Vec2(FXGLMath.cosDeg((float)degrees), FXGLMath.sinDeg((float)degrees));
    }
    public static float dot(final Vec2 a, final Vec2 b) {
        return a.x * b.x + a.y * b.y;
    }
    public static float cross(final Vec2 a, final Vec2 b) {
        return a.x * b.y - a.y * b.x;
    }
    public static void crossToOutUnsafe(Vec2 in, float scale, Vec2 out) {
        out.x = scale * in.y;
        out.y = -scale * in.x;
    }
    public static void crossToOutUnsafe(float scale, Vec2 in, Vec2 out) {
        out.x = -scale * in.y;
        out.y = scale * in.x;
    }
    public static void minToOut(Vec2 a, Vec2 b, Vec2 out) {
        out.x = a.x < b.x ? a.x : b.x;
        out.y = a.y < b.y ? a.y : b.y;
    }
    public static void maxToOut(Vec2 a, Vec2 b, Vec2 out) {
        out.x = a.x > b.x ? a.x : b.x;
        out.y = a.y > b.y ? a.y : b.y;
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + Float.floatToIntBits(x);
        result = prime * result + Float.floatToIntBits(y);
        return result;
    }
    @Override
    public boolean equals(Object obj) {
        if (obj == this)
            return true;
        if (obj instanceof Vec2) {
            Vec2 other = (Vec2) obj;
            return Float.floatToIntBits(x) == Float.floatToIntBits(other.x)
                    && Float.floatToIntBits(y) == Float.floatToIntBits(other.y);
        }
        return false;
    }
    public boolean isNearlyEqualTo(Point2D p) {
        return isCloseTo(p, 0.1);
    }
    public boolean isCloseTo(Point2D p, double tolerance) {
        return Math.abs(distance(p)) <= tolerance;
    }
}
package com.almasb.fxgl.physics.box2d.dynamics.contacts;
import com.almasb.fxgl.physics.box2d.dynamics.Body;
public class ContactEdge {
    public Body other = null;
    public Contact contact = null;
    public ContactEdge prev = null;
    public ContactEdge next = null;
    void reset() {
        other = null;
        contact = null;
        prev = null;
        next = null;
    }
}
package com.almasb.fxgl.physics;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.entity.components.BoundingBoxComponent;
import com.almasb.fxgl.entity.components.TransformComponent;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import javafx.beans.binding.Bindings;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import java.io.Serializable;
import static com.almasb.fxgl.core.math.FXGLMath.cosDegF;
import static com.almasb.fxgl.core.math.FXGLMath.sinDegF;
public final class HitBox implements Serializable {
    private String name;
    private BoundingShape shape;
    private Bounds bounds;
    Vec2[] axes = new Vec2[2];
    Vec2[] corners = new Vec2[4];
    public HitBox(BoundingShape shape) {
        this(String.valueOf(shape.hashCode()), shape);
    }
    public HitBox(Point2D localOrigin, BoundingShape shape){
        this(String.valueOf(shape.hashCode()), localOrigin, shape);
    }
    public HitBox(String name, BoundingShape shape) {
        this(name, Point2D.ZERO, shape);
    }
    public HitBox(String name, Point2D localOrigin, BoundingShape shape) {
        this.name = name;
        this.shape = shape;
        this.bounds = new BoundingBox(localOrigin.getX(), localOrigin.getY(),
                shape.getSize().getWidth(), shape.getSize().getHeight());
        axes[0] = new Vec2();
        axes[1] = new Vec2();
        for (int i = 0; i < 4; i++) {
            corners[i] = new Vec2();
        }
    }
    public Bounds getBounds() {
        return bounds;
    }
    public BoundingShape getShape() {
        return shape;
    }
    public double getMinX() {
        return bounds.getMinX();
    }
    public double getMinY() {
        return bounds.getMinY();
    }
    public double getMaxX() {
        return bounds.getMaxX();
    }
    public double getMaxY() {
        return bounds.getMaxY();
    }
    public double getWidth() {
        return getMaxXWorld() - getMinXWorld();
    }
    public double getHeight() {
        return getMaxYWorld() - getMinYWorld();
    }
    public String getName() {
        return name;
    }
    private transient DoubleProperty minXWorld = new SimpleDoubleProperty();
    private transient DoubleProperty maxXWorld = new SimpleDoubleProperty();
    private transient DoubleProperty minYWorld = new SimpleDoubleProperty();
    private transient DoubleProperty maxYWorld = new SimpleDoubleProperty();
    public void bindXY(TransformComponent transform) {
        var x1 = Bindings.createDoubleBinding(() ->
                        transform.getScaleOrigin().getX() - (transform.getScaleOrigin().getX() - getMinX()) * transform.getScaleX() + transform.getX(),
                transform.scaleOriginXProperty(), transform.scaleXProperty(), transform.xProperty()
        );
        var x2 = Bindings.createDoubleBinding(() ->
                        transform.getScaleOrigin().getX() - (transform.getScaleOrigin().getX() - getMaxX()) * transform.getScaleX() + transform.getX(),
                transform.scaleOriginXProperty(), transform.scaleXProperty(), transform.xProperty()
        );
        var y1 = Bindings.createDoubleBinding(() ->
                        transform.getScaleOrigin().getY() - (transform.getScaleOrigin().getY() - getMinY()) * transform.getScaleY() + transform.getY(),
                transform.scaleOriginYProperty(), transform.scaleYProperty(), transform.yProperty()
        );
        var y2 = Bindings.createDoubleBinding(() ->
                        transform.getScaleOrigin().getY() - (transform.getScaleOrigin().getY() - getMaxY()) * transform.getScaleY() + transform.getY(),
                transform.scaleOriginYProperty(), transform.scaleYProperty(), transform.yProperty()
        );
        var isX1GreaterX2 = x1.greaterThan(x2);
        var isY1GreaterY2 = y1.greaterThan(y2);
        minXWorld.bind(
                Bindings.when(isX1GreaterX2).then(x2).otherwise(x1)
        );
        maxXWorld.bind(
                Bindings.when(isX1GreaterX2).then(x1).otherwise(x2)
        );
        minYWorld.bind(
                Bindings.when(isY1GreaterY2).then(y2).otherwise(y1)
        );
        maxYWorld.bind(
                Bindings.when(isY1GreaterY2).then(y1).otherwise(y2)
        );
    }
    public void unbind() {
        minXWorld.unbind();
        maxXWorld.unbind();
        minYWorld.unbind();
        maxYWorld.unbind();
    }
    public double getMinXWorld() {
        return minXWorld.get();
    }
    public double getMaxXWorld() {
        return maxXWorld.get();
    }
    public double getMinYWorld() {
        return minYWorld.get();
    }
    public double getMaxYWorld() {
        return maxYWorld.get();
    }
    public Point2D getCenterWorld() {
        return new Point2D((getMinXWorld() + getMaxXWorld()) / 2, (getMinYWorld() + getMaxYWorld()) / 2);
    }
    public Point2D centerLocal() {
        return new Point2D((bounds.getMinX() + bounds.getMaxX()) / 2,
                (bounds.getMinY() + bounds.getMaxY()) / 2);
    }
    public Point2D centerWorld(double x, double y) {
        return centerLocal().add(x, y);
    }
    public Shape toBox2DShape(BoundingBoxComponent bbox, PhysicsUnitConverter converter) {
        return shape.toBox2DShape(this, bbox, converter);
    }
    float fastMinX;
    float fastMinY;
    float fastMaxX;
    float fastMaxY;
    public float getFastMinX() {
        return fastMinX;
    }
    public float getFastMinY() {
        return fastMinY;
    }
    public float getFastMaxX() {
        return fastMaxX;
    }
    public float getFastMaxY() {
        return fastMaxY;
    }
    SAT.MinMax axis1MinMax = new SAT.MinMax();
    SAT.MinMax axis2MinMax = new SAT.MinMax();
    public void applyTransform(TransformComponent transform) {
        double x1 = transform.getScaleOrigin().getX() - (transform.getScaleOrigin().getX() - getMinX()) * transform.getScaleX() + transform.getX();
        double x2 = transform.getScaleOrigin().getX() - (transform.getScaleOrigin().getX() - getMaxX()) * transform.getScaleX() + transform.getX();
        double y1 = transform.getScaleOrigin().getY() - (transform.getScaleOrigin().getY() - getMinY()) * transform.getScaleY() + transform.getY();
        double y2 = transform.getScaleOrigin().getY() - (transform.getScaleOrigin().getY() - getMaxY()) * transform.getScaleY() + transform.getY();
        fastMinX = (float) Math.min(x1, x2);
        fastMinY = (float) Math.min(y1, y2);
        fastMaxX = (float) Math.max(x1, x2);
        fastMaxY = (float) Math.max(y1, y2);
        double angle = transform.getAngle();
        float cos = cosDegF(angle);
        float sin = sinDegF(angle);
        axes[0].set(cos, sin).normalizeLocal();
        axes[1].set(cosDegF(angle + 90), sinDegF(angle + 90)).normalizeLocal();
        corners[0].set(fastMinX, fastMinY);
        corners[1].set(fastMaxX, fastMinY);
        corners[2].set(fastMaxX, fastMaxY);
        corners[3].set(fastMinX, fastMaxY);
        if (angle != 0.0) {
            var origin = transform.getRotationOrigin();
            double originX = origin.getX() + transform.getX();
            double originY = origin.getY() + transform.getY();
            for (Vec2 v : corners) {
                v.subLocal(originX, originY);
                v.set(v.x * cos - v.y * sin, v.x * sin + v.y * cos);
                v.addLocal(originX, originY);
            }
        }
        SAT.computeMinMax(corners, axes[0], axis1MinMax);
        SAT.computeMinMax(corners, axes[1], axis2MinMax);
    }
    @Override
    public String toString() {
        return "HitBox(" + name + "," + shape + ")";
    }
}
package com.almasb.fxgl.physics.box2d.dynamics;
import com.almasb.fxgl.physics.box2d.callbacks.ContactFilter;
import com.almasb.fxgl.physics.box2d.callbacks.ContactListener;
import com.almasb.fxgl.physics.box2d.callbacks.PairCallback;
import com.almasb.fxgl.physics.box2d.collision.broadphase.BroadPhase;
import com.almasb.fxgl.physics.box2d.collision.shapes.ShapeType;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactEdge;
import com.almasb.fxgl.physics.box2d.pooling.IDynamicStack;
import com.almasb.fxgl.physics.box2d.pooling.IWorldPool;
class ContactManager implements PairCallback {
    Contact contactList = null;
    int contactCount = 0;
    private ContactListener contactListener = null;
    private ContactFilter contactFilter = new ContactFilter();
    private final IWorldPool pool;
    final BroadPhase broadPhase;
    private ContactRegister[][] contactStacks = new ContactRegister[ShapeType.values().length][ShapeType.values().length];
    ContactManager(IWorldPool pool, BroadPhase broadPhase) {
        this.pool = pool;
        this.broadPhase = broadPhase;
        initializeRegisters();
    }
    private void initializeRegisters() {
        addType(pool.getCircleContactStack(), ShapeType.CIRCLE, ShapeType.CIRCLE);
        addType(pool.getPolyCircleContactStack(), ShapeType.POLYGON, ShapeType.CIRCLE);
        addType(pool.getPolyContactStack(), ShapeType.POLYGON, ShapeType.POLYGON);
        addType(pool.getEdgeCircleContactStack(), ShapeType.EDGE, ShapeType.CIRCLE);
        addType(pool.getEdgePolyContactStack(), ShapeType.EDGE, ShapeType.POLYGON);
        addType(pool.getChainCircleContactStack(), ShapeType.CHAIN, ShapeType.CIRCLE);
        addType(pool.getChainPolyContactStack(), ShapeType.CHAIN, ShapeType.POLYGON);
    }
    private void addType(IDynamicStack<Contact> creator, ShapeType type1, ShapeType type2) {
        contactStacks[type1.ordinal()][type2.ordinal()] = new ContactRegister(creator, true);
        if (type1 != type2) {
            contactStacks[type2.ordinal()][type1.ordinal()] = new ContactRegister(creator, false);
        }
    }
    void setContactFilter(ContactFilter contactFilter) {
        this.contactFilter = contactFilter;
    }
    void setContactListener(ContactListener contactListener) {
        this.contactListener = contactListener;
    }
    ContactListener getContactListener() {
        return contactListener;
    }
    @Override
    public void addPair(Object proxyUserDataA, Object proxyUserDataB) {
        Fixture.FixtureProxy proxyA = (Fixture.FixtureProxy) proxyUserDataA;
        Fixture.FixtureProxy proxyB = (Fixture.FixtureProxy) proxyUserDataB;
        Fixture fixtureA = proxyA.fixture;
        Fixture fixtureB = proxyB.fixture;
        int indexA = proxyA.childIndex;
        int indexB = proxyB.childIndex;
        Body bodyA = fixtureA.getBody();
        Body bodyB = fixtureB.getBody();
        if (bodyA == bodyB) {
            return;
        }
        ContactEdge edge = bodyB.getContactList();
        while (edge != null) {
            if (edge.other == bodyA) {
                Fixture fA = edge.contact.getFixtureA();
                Fixture fB = edge.contact.getFixtureB();
                int iA = edge.contact.getChildIndexA();
                int iB = edge.contact.getChildIndexB();
                if (fA == fixtureA && iA == indexA && fB == fixtureB && iB == indexB) {
                    return;
                }
                if (fA == fixtureB && iA == indexB && fB == fixtureA && iB == indexA) {
                    return;
                }
            }
            edge = edge.next;
        }
        if (!bodyB.shouldCollide(bodyA)) {
            return;
        }
        if (contactFilter != null && !contactFilter.shouldCollide(fixtureA, fixtureB)) {
            return;
        }
        Contact c = popContact(fixtureA, indexA, fixtureB, indexB);
        if (c == null) {
            return;
        }
        fixtureA = c.getFixtureA();
        fixtureB = c.getFixtureB();
        bodyA = fixtureA.getBody();
        bodyB = fixtureB.getBody();
        c.m_prev = null;
        c.m_next = contactList;
        if (contactList != null) {
            contactList.m_prev = c;
        }
        contactList = c;
        c.m_nodeA.contact = c;
        c.m_nodeA.other = bodyB;
        c.m_nodeA.prev = null;
        c.m_nodeA.next = bodyA.m_contactList;
        if (bodyA.m_contactList != null) {
            bodyA.m_contactList.prev = c.m_nodeA;
        }
        bodyA.m_contactList = c.m_nodeA;
        c.m_nodeB.contact = c;
        c.m_nodeB.other = bodyA;
        c.m_nodeB.prev = null;
        c.m_nodeB.next = bodyB.m_contactList;
        if (bodyB.m_contactList != null) {
            bodyB.m_contactList.prev = c.m_nodeB;
        }
        bodyB.m_contactList = c.m_nodeB;
        if (!fixtureA.isSensor() && !fixtureB.isSensor()) {
            bodyA.setAwake(true);
            bodyB.setAwake(true);
        }
        ++contactCount;
    }
    void findNewContacts() {
        broadPhase.updatePairs(this);
    }
    void destroy(Contact c) {
        Body bodyA = c.getFixtureA().getBody();
        Body bodyB = c.getFixtureB().getBody();
        if (contactListener != null && c.isTouching()) {
            contactListener.endContact(c);
        }
        if (c.m_prev != null) {
            c.m_prev.m_next = c.m_next;
        }
        if (c.m_next != null) {
            c.m_next.m_prev = c.m_prev;
        }
        if (c == contactList) {
            contactList = c.m_next;
        }
        if (c.m_nodeA.prev != null) {
            c.m_nodeA.prev.next = c.m_nodeA.next;
        }
        if (c.m_nodeA.next != null) {
            c.m_nodeA.next.prev = c.m_nodeA.prev;
        }
        if (c.m_nodeA == bodyA.m_contactList) {
            bodyA.m_contactList = c.m_nodeA.next;
        }
        if (c.m_nodeB.prev != null) {
            c.m_nodeB.prev.next = c.m_nodeB.next;
        }
        if (c.m_nodeB.next != null) {
            c.m_nodeB.next.prev = c.m_nodeB.prev;
        }
        if (c.m_nodeB == bodyB.m_contactList) {
            bodyB.m_contactList = c.m_nodeB.next;
        }
        pushContact(c);
        --contactCount;
    }
    void collide() {
        Contact c = contactList;
        while (c != null) {
            Fixture fixtureA = c.getFixtureA();
            Fixture fixtureB = c.getFixtureB();
            int indexA = c.getChildIndexA();
            int indexB = c.getChildIndexB();
            Body bodyA = fixtureA.getBody();
            Body bodyB = fixtureB.getBody();
            if ((c.m_flags & Contact.FILTER_FLAG) == Contact.FILTER_FLAG) {
                if (!bodyB.shouldCollide(bodyA)) {
                    Contact cNuke = c;
                    c = cNuke.getNext();
                    destroy(cNuke);
                    continue;
                }
                if (contactFilter != null && !contactFilter.shouldCollide(fixtureA, fixtureB)) {
                    Contact cNuke = c;
                    c = cNuke.getNext();
                    destroy(cNuke);
                    continue;
                }
                c.m_flags &= ~Contact.FILTER_FLAG;
            }
            boolean activeA = bodyA.isAwake() && bodyA.getType() != BodyType.STATIC;
            boolean activeB = bodyB.isAwake() && bodyB.getType() != BodyType.STATIC;
            if (!activeA && !activeB) {
                c = c.getNext();
                continue;
            }
            int proxyIdA = fixtureA.getProxyId(indexA);
            int proxyIdB = fixtureB.getProxyId(indexB);
            boolean overlap = broadPhase.testOverlap(proxyIdA, proxyIdB);
            if (!overlap) {
                Contact cNuke = c;
                c = cNuke.getNext();
                destroy(cNuke);
                continue;
            }
            c.update(contactListener);
            c = c.getNext();
        }
    }
    private Contact popContact(Fixture fixtureA, int indexA, Fixture fixtureB, int indexB) {
        final ShapeType type1 = fixtureA.getType();
        final ShapeType type2 = fixtureB.getType();
        final ContactRegister reg = contactStacks[type1.ordinal()][type2.ordinal()];
        if (reg == null)
            return null;
        Contact c = reg.creator.pop();
        if (reg.primary) {
            c.init(fixtureA, indexA, fixtureB, indexB);
        } else {
            c.init(fixtureB, indexB, fixtureA, indexA);
        }
        return c;
    }
    private void pushContact(Contact contact) {
        Fixture fixtureA = contact.getFixtureA();
        Fixture fixtureB = contact.getFixtureB();
        if (contact.getManifold().pointCount > 0 && !fixtureA.isSensor() && !fixtureB.isSensor()) {
            fixtureA.getBody().setAwake(true);
            fixtureB.getBody().setAwake(true);
        }
        ShapeType type1 = fixtureA.getType();
        ShapeType type2 = fixtureB.getType();
        IDynamicStack<Contact> creator = contactStacks[type1.ordinal()][type2.ordinal()].creator;
        creator.push(contact);
    }
    private static class ContactRegister {
        final IDynamicStack<Contact> creator;
        final boolean primary;
        ContactRegister(IDynamicStack<Contact> creator, boolean primary) {
            this.creator = creator;
            this.primary = primary;
        }
    }
}
package com.almasb.fxgl.physics.box2d.callbacks;
import com.almasb.fxgl.physics.box2d.dynamics.Fixture;
import com.almasb.fxgl.physics.box2d.dynamics.joints.Joint;
public interface DestructionListener {
    void onDestroy(Joint joint);
    void onDestroy(Fixture fixture);
}
package com.almasb.fxgl.physics.box2d.dynamics.contacts;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.physics.box2d.callbacks.ContactListener;
import com.almasb.fxgl.physics.box2d.collision.ContactID;
import com.almasb.fxgl.physics.box2d.collision.GenericCollision;
import com.almasb.fxgl.physics.box2d.collision.Manifold;
import com.almasb.fxgl.physics.box2d.collision.ManifoldPoint;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.Body;
import com.almasb.fxgl.physics.box2d.dynamics.Fixture;
import com.almasb.fxgl.physics.box2d.pooling.IWorldPool;
public abstract class Contact {
    public static final int ISLAND_FLAG = 0x0001;
    public static final int TOUCHING_FLAG = 0x0002;
    public static final int ENABLED_FLAG = 0x0004;
    public static final int FILTER_FLAG = 0x0008;
    public static final int TOI_FLAG = 0x0020;
    public int m_flags;
    public Contact m_prev;
    public Contact m_next;
    public ContactEdge m_nodeA = new ContactEdge();
    public ContactEdge m_nodeB = new ContactEdge();
    public Fixture m_fixtureA = null;
    public Fixture m_fixtureB = null;
    public int m_indexA;
    public int m_indexB;
    private final Manifold m_manifold = new Manifold();
    public float m_toiCount;
    public float m_toi;
    private float m_friction;
    private float m_restitution;
    private float m_tangentSpeed;
    protected final IWorldPool pool;
    protected Contact(IWorldPool argPool) {
        pool = argPool;
    }
    public void init(Fixture fA, int indexA, Fixture fB, int indexB) {
        m_flags = ENABLED_FLAG;
        m_fixtureA = fA;
        m_fixtureB = fB;
        m_indexA = indexA;
        m_indexB = indexB;
        m_manifold.pointCount = 0;
        m_prev = null;
        m_next = null;
        m_nodeA.reset();
        m_nodeB.reset();
        m_toiCount = 0;
        m_friction = mixFriction(fA.getFriction(), fB.getFriction());
        m_restitution = mixRestitution(fA.getRestitution(), fB.getRestitution());
        m_tangentSpeed = 0;
    }
    public Manifold getManifold() {
        return m_manifold;
    }
    public boolean isTouching() {
        return (m_flags & TOUCHING_FLAG) == TOUCHING_FLAG;
    }
    public void setEnabled(boolean flag) {
        if (flag) {
            m_flags |= ENABLED_FLAG;
        } else {
            m_flags &= ~ENABLED_FLAG;
        }
    }
    public boolean isEnabled() {
        return (m_flags & ENABLED_FLAG) == ENABLED_FLAG;
    }
    public Contact getNext() {
        return m_next;
    }
    public Fixture getFixtureA() {
        return m_fixtureA;
    }
    public int getChildIndexA() {
        return m_indexA;
    }
    public Fixture getFixtureB() {
        return m_fixtureB;
    }
    public int getChildIndexB() {
        return m_indexB;
    }
    public void setFriction(float friction) {
        m_friction = friction;
    }
    public float getFriction() {
        return m_friction;
    }
    public void resetFriction() {
        m_friction = mixFriction(m_fixtureA.getFriction(), m_fixtureB.getFriction());
    }
    public void setRestitution(float restitution) {
        m_restitution = restitution;
    }
    public float getRestitution() {
        return m_restitution;
    }
    public void resetRestitution() {
        m_restitution = mixRestitution(m_fixtureA.getRestitution(), m_fixtureB.getRestitution());
    }
    public void setTangentSpeed(float speed) {
        m_tangentSpeed = speed;
    }
    public float getTangentSpeed() {
        return m_tangentSpeed;
    }
    public abstract void evaluate(Manifold manifold, Transform xfA, Transform xfB);
    public void flagForFiltering() {
        m_flags |= FILTER_FLAG;
    }
    private final Manifold oldManifold = new Manifold();
    public void update(ContactListener listener) {
        oldManifold.set(m_manifold);
        m_flags |= ENABLED_FLAG;
        boolean wasTouching = (m_flags & TOUCHING_FLAG) == TOUCHING_FLAG;
        boolean sensorA = m_fixtureA.isSensor();
        boolean sensorB = m_fixtureB.isSensor();
        boolean sensor = sensorA || sensorB;
        Body bodyA = m_fixtureA.getBody();
        Body bodyB = m_fixtureB.getBody();
        Transform xfA = bodyA.getTransform();
        Transform xfB = bodyB.getTransform();
        boolean touching;
        if (sensor) {
            Shape shapeA = m_fixtureA.getShape();
            Shape shapeB = m_fixtureB.getShape();
            touching = GenericCollision.testOverlap(pool, shapeA, m_indexA, shapeB, m_indexB, xfA, xfB);
            m_manifold.pointCount = 0;
        } else {
            evaluate(m_manifold, xfA, xfB);
            touching = m_manifold.pointCount > 0;
            for (int i = 0; i < m_manifold.pointCount; ++i) {
                ManifoldPoint mp2 = m_manifold.points[i];
                mp2.normalImpulse = 0.0f;
                mp2.tangentImpulse = 0.0f;
                ContactID id2 = mp2.id;
                for (int j = 0; j < oldManifold.pointCount; ++j) {
                    ManifoldPoint mp1 = oldManifold.points[j];
                    if (mp1.id.isEqual(id2)) {
                        mp2.normalImpulse = mp1.normalImpulse;
                        mp2.tangentImpulse = mp1.tangentImpulse;
                        break;
                    }
                }
            }
            if (touching != wasTouching) {
                bodyA.setAwake(true);
                bodyB.setAwake(true);
            }
        }
        if (touching) {
            m_flags |= TOUCHING_FLAG;
        } else {
            m_flags &= ~TOUCHING_FLAG;
        }
        if (listener == null) {
            return;
        }
        if (!wasTouching && touching) {
            listener.beginContact(this);
        }
        if (wasTouching && !touching) {
            listener.endContact(this);
        }
        if (!sensor && touching) {
            listener.preSolve(this, oldManifold);
        }
    }
    private static float mixFriction(float friction1, float friction2) {
        return FXGLMath.sqrtF(friction1 * friction2);
    }
    private static float mixRestitution(float restitution1, float restitution2) {
        return restitution1 > restitution2 ? restitution1 : restitution2;
    }
}
package com.almasb.fxgl.physics.box2d.callbacks;
import com.almasb.fxgl.physics.box2d.dynamics.Fixture;
import com.almasb.fxgl.physics.box2d.dynamics.World;
public interface QueryCallback {
    boolean reportFixture(Fixture fixture);
}
package com.almasb.fxgl.physics.box2d.particle;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.callbacks.ParticleDestructionListener;
import com.almasb.fxgl.physics.box2d.callbacks.ParticleQueryCallback;
import com.almasb.fxgl.physics.box2d.callbacks.ParticleRaycastCallback;
import com.almasb.fxgl.physics.box2d.callbacks.QueryCallback;
import com.almasb.fxgl.physics.box2d.collision.AABB;
import com.almasb.fxgl.physics.box2d.collision.RayCastInput;
import com.almasb.fxgl.physics.box2d.collision.RayCastOutput;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.Rotation;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.Body;
import com.almasb.fxgl.physics.box2d.dynamics.Fixture;
import com.almasb.fxgl.physics.box2d.dynamics.TimeStep;
import com.almasb.fxgl.physics.box2d.dynamics.World;
import com.almasb.fxgl.physics.box2d.particle.VoronoiDiagram.VoronoiDiagramCallback;
import java.lang.reflect.Array;
import java.util.Arrays;
import static com.almasb.fxgl.physics.box2d.common.JBoxSettings.*;
public class ParticleSystem {
    private static final int k_pairFlags = ParticleTypeInternal.b2_springParticle;
    private static final int k_triadFlags = ParticleTypeInternal.b2_elasticParticle;
    private static final int k_noPressureFlags = ParticleTypeInternal.b2_powderParticle;
    private static final int xTruncBits = 12;
    private static final int yTruncBits = 12;
    private static final int tagBits = 8 * 4 - 1  ;
    private static final long yOffset = 1 << (yTruncBits - 1);
    private static final int yShift = tagBits - yTruncBits;
    private static final int xShift = tagBits - yTruncBits - xTruncBits;
    private static final long xScale = 1 << xShift;
    private static final long xOffset = xScale * (1 << (xTruncBits - 1));
    @SuppressWarnings("PMD.UselessParentheses")
    private static long computeTag(float x, float y) {
        return (((long) (y + yOffset)) << yShift) + (((long) (xScale * x)) + xOffset);
    }
    private static long computeRelativeTag(long tag, int x, int y) {
        return tag + (y << yShift) + (x << xShift);
    }
    private static int limitCapacity(int capacity, int maxCount) {
        return maxCount != 0 && capacity > maxCount ? maxCount : capacity;
    }
    int m_timestamp = 0;
    private int m_allParticleFlags = 0;
    private int m_allGroupFlags = 0;
    private float m_density = 1;
    private float m_inverseDensity = 1;
    private float m_gravityScale = 1;
    private float m_particleDiameter = 1;
    private float m_inverseDiameter = 1;
    private float m_squaredDiameter = 1;
    private int m_count = 0;
    private int m_internalAllocatedCapacity = 0;
    private int m_maxCount = 0;
    private ParticleBufferInt m_flagsBuffer = new ParticleBufferInt();
    ParticleBuffer<Vec2> m_positionBuffer = new ParticleBuffer<Vec2>(Vec2.class);
    ParticleBuffer<Vec2> m_velocityBuffer = new ParticleBuffer<Vec2>(Vec2.class);
    private float[] m_accumulationBuffer; 
    private Vec2[] m_accumulation2Buffer; 
    private float[] m_depthBuffer; 
    private ParticleBuffer<ParticleColor> m_colorBuffer = new ParticleBuffer<ParticleColor>(ParticleColor.class);
    private ParticleGroup[] m_groupBuffer;
    private ParticleBuffer<Object> m_userDataBuffer = new ParticleBuffer<Object>(Object.class);
    private int m_proxyCount = 0;
    private int m_proxyCapacity = 0;
    private Proxy[] m_proxyBuffer;
    public int m_contactCount = 0;
    private int m_contactCapacity = 0;
    public ParticleContact[] m_contactBuffer;
    public int m_bodyContactCount = 0;
    private int m_bodyContactCapacity = 0;
    public ParticleBodyContact[] m_bodyContactBuffer;
    private int m_pairCount = 0;
    private int m_pairCapacity = 0;
    private Pair[] m_pairBuffer;
    private int m_triadCount = 0;
    private int m_triadCapacity = 0;
    private Triad[] m_triadBuffer;
    private int m_groupCount = 0;
    private ParticleGroup m_groupList;
    private float m_pressureStrength = 0.05f;
    private float m_dampingStrength = 1.0f;
    private float m_elasticStrength = 0.25f;
    private float m_springStrength = 0.25f;
    private float m_viscousStrength = 0.25f;
    private float m_surfaceTensionStrengthA = 0.1f;
    private float m_surfaceTensionStrengthB = 0.2f;
    private float m_powderStrength = 0.5f;
    private float m_ejectionStrength = 0.5f;
    private float m_colorMixingStrength = 0.5f;
    private final World m_world;
    public ParticleSystem(World world) {
        m_world = world;
    }
    public int createParticle(ParticleDef def) {
        if (m_count >= m_internalAllocatedCapacity) {
            int capacity = m_count != 0 ? 2 * m_count : minParticleBufferCapacity;
            capacity = limitCapacity(capacity, m_maxCount);
            capacity = limitCapacity(capacity, m_flagsBuffer.userSuppliedCapacity);
            capacity = limitCapacity(capacity, m_positionBuffer.userSuppliedCapacity);
            capacity = limitCapacity(capacity, m_velocityBuffer.userSuppliedCapacity);
            capacity = limitCapacity(capacity, m_colorBuffer.userSuppliedCapacity);
            capacity = limitCapacity(capacity, m_userDataBuffer.userSuppliedCapacity);
            if (m_internalAllocatedCapacity < capacity) {
                m_flagsBuffer.data =
                        reallocateBuffer(m_flagsBuffer, m_internalAllocatedCapacity, capacity, false);
                m_positionBuffer.data =
                        reallocateBuffer(m_positionBuffer, m_internalAllocatedCapacity, capacity, false);
                m_velocityBuffer.data =
                        reallocateBuffer(m_velocityBuffer, m_internalAllocatedCapacity, capacity, false);
                m_accumulationBuffer =
                        reallocateBuffer(m_accumulationBuffer, 0, m_internalAllocatedCapacity, capacity, false);
                m_accumulation2Buffer =
                        reallocateBuffer(Vec2.class, m_accumulation2Buffer, 0, m_internalAllocatedCapacity, capacity, true);
                m_depthBuffer =
                        reallocateBuffer(m_depthBuffer, 0, m_internalAllocatedCapacity, capacity, true);
                m_colorBuffer.data =
                        reallocateBuffer(m_colorBuffer, m_internalAllocatedCapacity, capacity, true);
                m_groupBuffer =
                        reallocateBuffer(ParticleGroup.class, m_groupBuffer, 0, m_internalAllocatedCapacity, capacity, false);
                m_userDataBuffer.data =
                        reallocateBuffer(m_userDataBuffer, m_internalAllocatedCapacity, capacity, true);
                m_internalAllocatedCapacity = capacity;
            }
        }
        if (m_count >= m_internalAllocatedCapacity) {
            return invalidParticleIndex;
        }
        int index = m_count++;
        m_flagsBuffer.data[index] = def.getTypeFlags();
        m_positionBuffer.data[index].set(def.position);
        m_velocityBuffer.data[index].set(def.velocity);
        m_groupBuffer[index] = null;
        if (m_depthBuffer != null) {
            m_depthBuffer[index] = 0;
        }
        if (m_colorBuffer.data != null || def.color != null) {
            m_colorBuffer.data = requestParticleBuffer(m_colorBuffer.dataClass, m_colorBuffer.data);
            m_colorBuffer.data[index].set(def.color);
        }
        if (m_userDataBuffer.data != null || def.getUserData() != null) {
            m_userDataBuffer.data = requestParticleBuffer(m_userDataBuffer.dataClass, m_userDataBuffer.data);
            m_userDataBuffer.data[index] = def.getUserData();
        }
        if (m_proxyCount >= m_proxyCapacity) {
            int oldCapacity = m_proxyCapacity;
            int newCapacity = m_proxyCount != 0 ? 2 * m_proxyCount : minParticleBufferCapacity;
            m_proxyBuffer =
                    reallocateBuffer(Proxy.class, m_proxyBuffer, oldCapacity, newCapacity);
            m_proxyCapacity = newCapacity;
        }
        m_proxyBuffer[m_proxyCount++].index = index;
        return index;
    }
    public void destroyParticle(int index, boolean callDestructionListener) {
        int flags = ParticleTypeInternal.b2_zombieParticle;
        if (callDestructionListener) {
            flags |= ParticleTypeInternal.b2_destructionListener;
        }
        m_flagsBuffer.data[index] |= flags;
    }
    private final AABB temp = new AABB();
    private final DestroyParticlesInShapeCallback dpcallback = new DestroyParticlesInShapeCallback();
    public int destroyParticlesInShape(Shape shape, Transform xf, boolean callDestructionListener) {
        dpcallback.init(this, shape, xf, callDestructionListener);
        shape.computeAABB(temp, xf, 0);
        m_world.queryAABB(dpcallback, temp);
        return dpcallback.destroyed;
    }
    public void destroyParticlesInGroup(ParticleGroup group, boolean callDestructionListener) {
        for (int i = group.m_firstIndex; i < group.m_lastIndex; i++) {
            destroyParticle(i, callDestructionListener);
        }
    }
    private final AABB temp2 = new AABB();
    private final Vec2 tempVec = new Vec2();
    private final Transform tempTransform = new Transform();
    private final Transform tempTransform2 = new Transform();
    private CreateParticleGroupCallback createParticleGroupCallback = new CreateParticleGroupCallback();
    private final ParticleDef tempParticleDef = new ParticleDef();
    @SuppressWarnings("PMD.DontUseFloatTypeForLoopIndices")
    public ParticleGroup createParticleGroup(ParticleGroupDef groupDef) {
        float stride = getParticleStride();
        final Transform identity = tempTransform;
        identity.setIdentity();
        Transform transform = tempTransform2;
        transform.setIdentity();
        int firstIndex = m_count;
        if (groupDef.getShape() != null) {
            final ParticleDef particleDef = tempParticleDef;
            particleDef.setTypeFlags(groupDef.getTypeFlags());
            particleDef.color = groupDef.getColor();
            particleDef.setUserData(groupDef.getUserData());
            Shape shape = groupDef.getShape();
            transform.set(groupDef.getPosition(), groupDef.getAngle());
            AABB aabb = temp;
            int childCount = shape.getChildCount();
            for (int childIndex = 0; childIndex < childCount; childIndex++) {
                if (childIndex == 0) {
                    shape.computeAABB(aabb, identity, childIndex);
                } else {
                    AABB childAABB = temp2;
                    shape.computeAABB(childAABB, identity, childIndex);
                    aabb.combine(childAABB);
                }
            }
            final float upperBoundY = aabb.upperBound.y;
            final float upperBoundX = aabb.upperBound.x;
            for (float y = FXGLMath.floor(aabb.lowerBound.y / stride) * stride; y < upperBoundY; y += stride) {
                for (float x = FXGLMath.floor(aabb.lowerBound.x / stride) * stride; x < upperBoundX; x += stride) {
                    Vec2 p = tempVec;
                    p.x = x;
                    p.y = y;
                    if (shape.containsPoint(identity, p)) {
                        Transform.mulToOut(transform, p, p);
                        particleDef.position.x = p.x;
                        particleDef.position.y = p.y;
                        p.subLocal(groupDef.getPosition());
                        Vec2.crossToOutUnsafe(groupDef.getAngularVelocity(), p, particleDef.velocity);
                        particleDef.velocity.addLocal(groupDef.getLinearVelocity());
                        createParticle(particleDef);
                    }
                }
            }
        }
        int lastIndex = m_count;
        ParticleGroup group = new ParticleGroup();
        group.m_system = this;
        group.m_firstIndex = firstIndex;
        group.m_lastIndex = lastIndex;
        group.m_groupFlags = groupDef.getGroupFlags();
        group.m_strength = groupDef.getStrength();
        group.m_userData = groupDef.getUserData();
        group.m_transform.set(transform);
        group.m_destroyAutomatically = groupDef.isDestroyAutomatically();
        group.m_prev = null;
        group.m_next = m_groupList;
        if (m_groupList != null) {
            m_groupList.m_prev = group;
        }
        m_groupList = group;
        ++m_groupCount;
        for (int i = firstIndex; i < lastIndex; i++) {
            m_groupBuffer[i] = group;
        }
        updateContacts(true);
        if ((groupDef.getTypeFlags() & k_pairFlags) != 0) {
            for (int k = 0; k < m_contactCount; k++) {
                ParticleContact contact = m_contactBuffer[k];
                int a = contact.indexA;
                int b = contact.indexB;
                if (a > b) {
                    int temp = a;
                    a = b;
                    b = temp;
                }
                if (firstIndex <= a && b < lastIndex) {
                    if (m_pairCount >= m_pairCapacity) {
                        int oldCapacity = m_pairCapacity;
                        int newCapacity =
                                m_pairCount != 0 ? 2 * m_pairCount : minParticleBufferCapacity;
                        m_pairBuffer =
                                reallocateBuffer(Pair.class, m_pairBuffer, oldCapacity, newCapacity);
                        m_pairCapacity = newCapacity;
                    }
                    Pair pair = m_pairBuffer[m_pairCount];
                    pair.indexA = a;
                    pair.indexB = b;
                    pair.flags = contact.flags;
                    pair.strength = groupDef.getStrength();
                    pair.distance = m_positionBuffer.data[a].distanceF(m_positionBuffer.data[b]);
                    m_pairCount++;
                }
            }
        }
        if ((groupDef.getTypeFlags() & k_triadFlags) != 0) {
            VoronoiDiagram diagram = new VoronoiDiagram(lastIndex - firstIndex);
            for (int i = firstIndex; i < lastIndex; i++) {
                diagram.addGenerator(m_positionBuffer.data[i], i);
            }
            diagram.generate(stride / 2);
            createParticleGroupCallback.system = this;
            createParticleGroupCallback.def = groupDef;
            createParticleGroupCallback.firstIndex = firstIndex;
            diagram.getNodes(createParticleGroupCallback);
        }
        if ((groupDef.getGroupFlags() & ParticleGroupType.b2_solidParticleGroup) != 0) {
            computeDepthForGroup(group);
        }
        return group;
    }
    public void joinParticleGroups(ParticleGroup groupA, ParticleGroup groupB) {
        assert groupA != groupB;
        RotateBuffer(groupB.m_firstIndex, groupB.m_lastIndex, m_count);
        assert groupB.m_lastIndex == m_count;
        RotateBuffer(groupA.m_firstIndex, groupA.m_lastIndex, groupB.m_firstIndex);
        assert groupA.m_lastIndex == groupB.m_firstIndex;
        int particleFlags = 0;
        for (int i = groupA.m_firstIndex; i < groupB.m_lastIndex; i++) {
            particleFlags |= m_flagsBuffer.data[i];
        }
        updateContacts(true);
        if ((particleFlags & k_pairFlags) != 0) {
            for (int k = 0; k < m_contactCount; k++) {
                final ParticleContact contact = m_contactBuffer[k];
                int a = contact.indexA;
                int b = contact.indexB;
                if (a > b) {
                    int temp = a;
                    a = b;
                    b = temp;
                }
                if (groupA.m_firstIndex <= a && a < groupA.m_lastIndex && groupB.m_firstIndex <= b
                        && b < groupB.m_lastIndex) {
                    if (m_pairCount >= m_pairCapacity) {
                        int oldCapacity = m_pairCapacity;
                        int newCapacity = m_pairCount != 0 ? 2 * m_pairCount : minParticleBufferCapacity;
                        m_pairBuffer =
                                reallocateBuffer(Pair.class, m_pairBuffer, oldCapacity, newCapacity);
                        m_pairCapacity = newCapacity;
                    }
                    Pair pair = m_pairBuffer[m_pairCount];
                    pair.indexA = a;
                    pair.indexB = b;
                    pair.flags = contact.flags;
                    pair.strength = Math.min(groupA.m_strength, groupB.m_strength);
                    pair.distance = m_positionBuffer.data[a].distanceF(m_positionBuffer.data[b]);
                    m_pairCount++;
                }
            }
        }
        if ((particleFlags & k_triadFlags) != 0) {
            VoronoiDiagram diagram = new VoronoiDiagram(groupB.m_lastIndex - groupA.m_firstIndex);
            for (int i = groupA.m_firstIndex; i < groupB.m_lastIndex; i++) {
                if ((m_flagsBuffer.data[i] & ParticleTypeInternal.b2_zombieParticle) == 0) {
                    diagram.addGenerator(m_positionBuffer.data[i], i);
                }
            }
            diagram.generate(getParticleStride() / 2);
            JoinParticleGroupsCallback callback = new JoinParticleGroupsCallback();
            callback.system = this;
            callback.groupA = groupA;
            callback.groupB = groupB;
            diagram.getNodes(callback);
        }
        for (int i = groupB.m_firstIndex; i < groupB.m_lastIndex; i++) {
            m_groupBuffer[i] = groupA;
        }
        int groupFlags = groupA.m_groupFlags | groupB.m_groupFlags;
        groupA.m_groupFlags = groupFlags;
        groupA.m_lastIndex = groupB.m_lastIndex;
        groupB.m_firstIndex = groupB.m_lastIndex;
        destroyParticleGroup(groupB);
        if ((groupFlags & ParticleGroupType.b2_solidParticleGroup) != 0) {
            computeDepthForGroup(groupA);
        }
    }
    private void destroyParticleGroup(ParticleGroup group) {
        assert m_groupCount > 0;
        assert group != null;
        if (m_world.getParticleDestructionListener() != null) {
            m_world.getParticleDestructionListener().onDestroy(group);
        }
        for (int i = group.m_firstIndex; i < group.m_lastIndex; i++) {
            m_groupBuffer[i] = null;
        }
        if (group.m_prev != null) {
            group.m_prev.m_next = group.m_next;
        }
        if (group.m_next != null) {
            group.m_next.m_prev = group.m_prev;
        }
        if (group == m_groupList) {
            m_groupList = group.m_next;
        }
        --m_groupCount;
    }
    private void computeDepthForGroup(ParticleGroup group) {
        for (int i = group.m_firstIndex; i < group.m_lastIndex; i++) {
            m_accumulationBuffer[i] = 0;
        }
        for (int k = 0; k < m_contactCount; k++) {
            final ParticleContact contact = m_contactBuffer[k];
            int a = contact.indexA;
            int b = contact.indexB;
            if (a >= group.m_firstIndex && a < group.m_lastIndex && b >= group.m_firstIndex
                    && b < group.m_lastIndex) {
                float w = contact.weight;
                m_accumulationBuffer[a] += w;
                m_accumulationBuffer[b] += w;
            }
        }
        m_depthBuffer = requestParticleBuffer(m_depthBuffer);
        for (int i = group.m_firstIndex; i < group.m_lastIndex; i++) {
            float w = m_accumulationBuffer[i];
            m_depthBuffer[i] = w < 0.8f ? 0 : Float.MAX_VALUE;
        }
        int interationCount = group.getParticleCount();
        for (int t = 0; t < interationCount; t++) {
            boolean updated = false;
            for (int k = 0; k < m_contactCount; k++) {
                final ParticleContact contact = m_contactBuffer[k];
                int a = contact.indexA;
                int b = contact.indexB;
                if (a >= group.m_firstIndex && a < group.m_lastIndex && b >= group.m_firstIndex
                        && b < group.m_lastIndex) {
                    float r = 1 - contact.weight;
                    float ap0 = m_depthBuffer[a];
                    float bp0 = m_depthBuffer[b];
                    float ap1 = bp0 + r;
                    float bp1 = ap0 + r;
                    if (ap0 > ap1) {
                        m_depthBuffer[a] = ap1;
                        updated = true;
                    }
                    if (bp0 > bp1) {
                        m_depthBuffer[b] = bp1;
                        updated = true;
                    }
                }
            }
            if (!updated) {
                break;
            }
        }
        for (int i = group.m_firstIndex; i < group.m_lastIndex; i++) {
            float p = m_depthBuffer[i];
            if (p < Float.MAX_VALUE) {
                m_depthBuffer[i] *= m_particleDiameter;
            } else {
                m_depthBuffer[i] = 0;
            }
        }
    }
    private void addContact(int a, int b) {
        assert a != b;
        Vec2 pa = m_positionBuffer.data[a];
        Vec2 pb = m_positionBuffer.data[b];
        float dx = pb.x - pa.x;
        float dy = pb.y - pa.y;
        float d2 = dx * dx + dy * dy;
        if (d2 < m_squaredDiameter) {
            if (m_contactCount >= m_contactCapacity) {
                int oldCapacity = m_contactCapacity;
                int newCapacity = m_contactCount != 0 ? 2 * m_contactCount : minParticleBufferCapacity;
                m_contactBuffer =
                        reallocateBuffer(ParticleContact.class, m_contactBuffer, oldCapacity,
                                newCapacity);
                m_contactCapacity = newCapacity;
            }
            float invD = d2 != 0 ? FXGLMath.sqrtF(1 / d2) : Float.MAX_VALUE;
            ParticleContact contact = m_contactBuffer[m_contactCount];
            contact.indexA = a;
            contact.indexB = b;
            contact.flags = m_flagsBuffer.data[a] | m_flagsBuffer.data[b];
            contact.weight = 1 - d2 * invD * m_inverseDiameter;
            contact.normal.x = invD * dx;
            contact.normal.y = invD * dy;
            m_contactCount++;
        }
    }
    private void updateContacts(boolean exceptZombie) {
        for (int p = 0; p < m_proxyCount; p++) {
            Proxy proxy = m_proxyBuffer[p];
            int i = proxy.index;
            Vec2 pos = m_positionBuffer.data[i];
            proxy.tag = computeTag(m_inverseDiameter * pos.x, m_inverseDiameter * pos.y);
        }
        Arrays.sort(m_proxyBuffer, 0, m_proxyCount);
        m_contactCount = 0;
        int c_index = 0;
        for (int i = 0; i < m_proxyCount; i++) {
            Proxy a = m_proxyBuffer[i];
            long rightTag = computeRelativeTag(a.tag, 1, 0);
            for (int j = i + 1; j < m_proxyCount; j++) {
                Proxy b = m_proxyBuffer[j];
                if (rightTag < b.tag) {
                    break;
                }
                addContact(a.index, b.index);
            }
            long bottomLeftTag = computeRelativeTag(a.tag, -1, 1);
            for (; c_index < m_proxyCount; c_index++) {
                Proxy c = m_proxyBuffer[c_index];
                if (bottomLeftTag <= c.tag) {
                    break;
                }
            }
            long bottomRightTag = computeRelativeTag(a.tag, 1, 1);
            for (int b_index = c_index; b_index < m_proxyCount; b_index++) {
                Proxy b = m_proxyBuffer[b_index];
                if (bottomRightTag < b.tag) {
                    break;
                }
                addContact(a.index, b.index);
            }
        }
        if (exceptZombie) {
            int j = m_contactCount;
            for (int i = 0; i < j; i++) {
                if ((m_contactBuffer[i].flags & ParticleTypeInternal.b2_zombieParticle) != 0) {
                    --j;
                    ParticleContact temp = m_contactBuffer[j];
                    m_contactBuffer[j] = m_contactBuffer[i];
                    m_contactBuffer[i] = temp;
                    --i;
                }
            }
            m_contactCount = j;
        }
    }
    private final UpdateBodyContactsCallback ubccallback = new UpdateBodyContactsCallback();
    private void updateBodyContacts() {
        final AABB aabb = temp;
        aabb.lowerBound.x = Float.MAX_VALUE;
        aabb.lowerBound.y = Float.MAX_VALUE;
        aabb.upperBound.x = -Float.MAX_VALUE;
        aabb.upperBound.y = -Float.MAX_VALUE;
        for (int i = 0; i < m_count; i++) {
            Vec2 p = m_positionBuffer.data[i];
            Vec2.minToOut(aabb.lowerBound, p, aabb.lowerBound);
            Vec2.maxToOut(aabb.upperBound, p, aabb.upperBound);
        }
        aabb.lowerBound.x -= m_particleDiameter;
        aabb.lowerBound.y -= m_particleDiameter;
        aabb.upperBound.x += m_particleDiameter;
        aabb.upperBound.y += m_particleDiameter;
        m_bodyContactCount = 0;
        ubccallback.system = this;
        m_world.queryAABB(ubccallback, aabb);
    }
    private SolveCollisionCallback sccallback = new SolveCollisionCallback();
    private void solveCollision(TimeStep step) {
        final AABB aabb = temp;
        final Vec2 lowerBound = aabb.lowerBound;
        final Vec2 upperBound = aabb.upperBound;
        lowerBound.x = Float.MAX_VALUE;
        lowerBound.y = Float.MAX_VALUE;
        upperBound.x = -Float.MAX_VALUE;
        upperBound.y = -Float.MAX_VALUE;
        for (int i = 0; i < m_count; i++) {
            final Vec2 v = m_velocityBuffer.data[i];
            final Vec2 p1 = m_positionBuffer.data[i];
            final float p1x = p1.x;
            final float p1y = p1.y;
            final float p2x = p1x + step.dt * v.x;
            final float p2y = p1y + step.dt * v.y;
            final float bx = p1x < p2x ? p1x : p2x;
            final float by = p1y < p2y ? p1y : p2y;
            lowerBound.x = lowerBound.x < bx ? lowerBound.x : bx;
            lowerBound.y = lowerBound.y < by ? lowerBound.y : by;
            final float b1x = p1x > p2x ? p1x : p2x;
            final float b1y = p1y > p2y ? p1y : p2y;
            upperBound.x = upperBound.x > b1x ? upperBound.x : b1x;
            upperBound.y = upperBound.y > b1y ? upperBound.y : b1y;
        }
        sccallback.step = step;
        sccallback.system = this;
        m_world.queryAABB(sccallback, aabb);
    }
    public void solve(TimeStep step) {
        ++m_timestamp;
        if (m_count == 0) {
            return;
        }
        m_allParticleFlags = 0;
        for (int i = 0; i < m_count; i++) {
            m_allParticleFlags |= m_flagsBuffer.data[i];
        }
        if ((m_allParticleFlags & ParticleTypeInternal.b2_zombieParticle) != 0) {
            solveZombie();
        }
        if (m_count == 0) {
            return;
        }
        m_allGroupFlags = 0;
        for (ParticleGroup group = m_groupList; group != null; group = group.getNext()) {
            m_allGroupFlags |= group.m_groupFlags;
        }
        final float gravityx = step.dt * m_gravityScale * m_world.getGravity().x;
        final float gravityy = step.dt * m_gravityScale * m_world.getGravity().y;
        float criticalVelocytySquared = getCriticalVelocitySquared(step);
        for (int i = 0; i < m_count; i++) {
            Vec2 v = m_velocityBuffer.data[i];
            v.x += gravityx;
            v.y += gravityy;
            float v2 = v.x * v.x + v.y * v.y;
            if (v2 > criticalVelocytySquared) {
                float a = v2 == 0 ? Float.MAX_VALUE : FXGLMath.sqrtF(criticalVelocytySquared / v2);
                v.x *= a;
                v.y *= a;
            }
        }
        solveCollision(step);
        if ((m_allGroupFlags & ParticleGroupType.b2_rigidParticleGroup) != 0) {
            solveRigid(step);
        }
        if ((m_allParticleFlags & ParticleTypeInternal.b2_wallParticle) != 0) {
            solveWall(step);
        }
        for (int i = 0; i < m_count; i++) {
            Vec2 pos = m_positionBuffer.data[i];
            Vec2 vel = m_velocityBuffer.data[i];
            pos.x += step.dt * vel.x;
            pos.y += step.dt * vel.y;
        }
        updateBodyContacts();
        updateContacts(false);
        if ((m_allParticleFlags & ParticleTypeInternal.b2_viscousParticle) != 0) {
            solveViscous(step);
        }
        if ((m_allParticleFlags & ParticleTypeInternal.b2_powderParticle) != 0) {
            solvePowder(step);
        }
        if ((m_allParticleFlags & ParticleTypeInternal.b2_tensileParticle) != 0) {
            solveTensile(step);
        }
        if ((m_allParticleFlags & ParticleTypeInternal.b2_elasticParticle) != 0) {
            solveElastic(step);
        }
        if ((m_allParticleFlags & ParticleTypeInternal.b2_springParticle) != 0) {
            solveSpring(step);
        }
        if ((m_allGroupFlags & ParticleGroupType.b2_solidParticleGroup) != 0) {
            solveSolid(step);
        }
        if ((m_allParticleFlags & ParticleTypeInternal.b2_colorMixingParticle) != 0) {
            solveColorMixing(step);
        }
        solvePressure(step);
        solveDamping(step);
    }
    private void solvePressure(TimeStep step) {
        for (int i = 0; i < m_count; i++) {
            m_accumulationBuffer[i] = 0;
        }
        for (int k = 0; k < m_bodyContactCount; k++) {
            ParticleBodyContact contact = m_bodyContactBuffer[k];
            int a = contact.index;
            float w = contact.weight;
            m_accumulationBuffer[a] += w;
        }
        for (int k = 0; k < m_contactCount; k++) {
            ParticleContact contact = m_contactBuffer[k];
            int a = contact.indexA;
            int b = contact.indexB;
            float w = contact.weight;
            m_accumulationBuffer[a] += w;
            m_accumulationBuffer[b] += w;
        }
        if ((m_allParticleFlags & k_noPressureFlags) != 0) {
            for (int i = 0; i < m_count; i++) {
                if ((m_flagsBuffer.data[i] & k_noPressureFlags) != 0) {
                    m_accumulationBuffer[i] = 0;
                }
            }
        }
        float pressurePerWeight = m_pressureStrength * getCriticalPressure(step);
        for (int i = 0; i < m_count; i++) {
            float w = m_accumulationBuffer[i];
            float h =
                    pressurePerWeight * Math.max(0.0f, Math.min(w, maxParticleWeight) - minParticleWeight);
            m_accumulationBuffer[i] = h;
        }
        float velocityPerPressure = step.dt / (m_density * m_particleDiameter);
        for (int k = 0; k < m_bodyContactCount; k++) {
            ParticleBodyContact contact = m_bodyContactBuffer[k];
            int a = contact.index;
            Body b = contact.body;
            float w = contact.weight;
            float m = contact.mass;
            Vec2 n = contact.normal;
            Vec2 p = m_positionBuffer.data[a];
            float h = m_accumulationBuffer[a] + pressurePerWeight * w;
            final Vec2 f = tempVec;
            final float coef = velocityPerPressure * w * m * h;
            f.x = coef * n.x;
            f.y = coef * n.y;
            final Vec2 velData = m_velocityBuffer.data[a];
            final float particleInvMass = getParticleInvMass();
            velData.x -= particleInvMass * f.x;
            velData.y -= particleInvMass * f.y;
            b.applyLinearImpulse(f, p, true);
        }
        for (int k = 0; k < m_contactCount; k++) {
            ParticleContact contact = m_contactBuffer[k];
            int a = contact.indexA;
            int b = contact.indexB;
            float w = contact.weight;
            Vec2 n = contact.normal;
            float h = m_accumulationBuffer[a] + m_accumulationBuffer[b];
            final float fx = velocityPerPressure * w * h * n.x;
            final float fy = velocityPerPressure * w * h * n.y;
            final Vec2 velDataA = m_velocityBuffer.data[a];
            final Vec2 velDataB = m_velocityBuffer.data[b];
            velDataA.x -= fx;
            velDataA.y -= fy;
            velDataB.x += fx;
            velDataB.y += fy;
        }
    }
    @SuppressWarnings("PMD.UnusedFormalParameter")
    private void solveDamping(TimeStep step) {
        float damping = m_dampingStrength;
        for (int k = 0; k < m_bodyContactCount; k++) {
            final ParticleBodyContact contact = m_bodyContactBuffer[k];
            int a = contact.index;
            Body b = contact.body;
            float w = contact.weight;
            float m = contact.mass;
            Vec2 n = contact.normal;
            Vec2 p = m_positionBuffer.data[a];
            final float tempX = p.x - b.m_sweep.c.x;
            final float tempY = p.y - b.m_sweep.c.y;
            final Vec2 velA = m_velocityBuffer.data[a];
            float vx = -b.getAngularVelocity() * tempY + b.getLinearVelocity().x - velA.x;
            float vy = b.getAngularVelocity() * tempX + b.getLinearVelocity().y - velA.y;
            float vn = vx * n.x + vy * n.y;
            if (vn < 0) {
                final Vec2 f = tempVec;
                f.x = damping * w * m * vn * n.x;
                f.y = damping * w * m * vn * n.y;
                final float invMass = getParticleInvMass();
                velA.x += invMass * f.x;
                velA.y += invMass * f.y;
                f.x = -f.x;
                f.y = -f.y;
                b.applyLinearImpulse(f, p, true);
            }
        }
        for (int k = 0; k < m_contactCount; k++) {
            final ParticleContact contact = m_contactBuffer[k];
            int a = contact.indexA;
            int b = contact.indexB;
            float w = contact.weight;
            Vec2 n = contact.normal;
            final Vec2 velA = m_velocityBuffer.data[a];
            final Vec2 velB = m_velocityBuffer.data[b];
            final float vx = velB.x - velA.x;
            final float vy = velB.y - velA.y;
            float vn = vx * n.x + vy * n.y;
            if (vn < 0) {
                float fx = damping * w * vn * n.x;
                float fy = damping * w * vn * n.y;
                velA.x += fx;
                velA.y += fy;
                velB.x -= fx;
                velB.y -= fy;
            }
        }
    }
    @SuppressWarnings("PMD.UnusedFormalParameter")
    private void solveWall(TimeStep step) {
        for (int i = 0; i < m_count; i++) {
            if ((m_flagsBuffer.data[i] & ParticleTypeInternal.b2_wallParticle) != 0) {
                final Vec2 r = m_velocityBuffer.data[i];
                r.x = 0.0f;
                r.y = 0.0f;
            }
        }
    }
    private final Vec2 tempVec2 = new Vec2();
    private final Rotation tempRotation = new Rotation();
    private final Transform tempXf = new Transform();
    private final Transform tempXf2 = new Transform();
    private void solveRigid(final TimeStep step) {
        for (ParticleGroup group = m_groupList; group != null; group = group.getNext()) {
            if ((group.m_groupFlags & ParticleGroupType.b2_rigidParticleGroup) != 0) {
                group.updateStatistics();
                Vec2 temp = tempVec;
                Vec2 cross = tempVec2;
                Rotation rotation = tempRotation;
                rotation.set(step.dt * group.m_angularVelocity);
                Rotation.mulToOutUnsafe(rotation, group.m_center, cross);
                temp.set(group.m_linearVelocity).mulLocal(step.dt).addLocal(group.m_center).subLocal(cross);
                tempXf.p.set(temp);
                tempXf.q.set(rotation);
                Transform.mulToOut(tempXf, group.m_transform, group.m_transform);
                final Transform velocityTransform = tempXf2;
                velocityTransform.p.x = step.inv_dt * tempXf.p.x;
                velocityTransform.p.y = step.inv_dt * tempXf.p.y;
                velocityTransform.q.s = step.inv_dt * tempXf.q.s;
                velocityTransform.q.c = step.inv_dt * (tempXf.q.c - 1);
                for (int i = group.m_firstIndex; i < group.m_lastIndex; i++) {
                    Transform.mulToOutUnsafe(velocityTransform, m_positionBuffer.data[i],
                            m_velocityBuffer.data[i]);
                }
            }
        }
    }
    private void solveElastic(final TimeStep step) {
        float elasticStrength = step.inv_dt * m_elasticStrength;
        for (int k = 0; k < m_triadCount; k++) {
            final Triad triad = m_triadBuffer[k];
            if ((triad.flags & ParticleTypeInternal.b2_elasticParticle) != 0) {
                int a = triad.indexA;
                int b = triad.indexB;
                int c = triad.indexC;
                final Vec2 oa = triad.pa;
                final Vec2 ob = triad.pb;
                final Vec2 oc = triad.pc;
                final Vec2 pa = m_positionBuffer.data[a];
                final Vec2 pb = m_positionBuffer.data[b];
                final Vec2 pc = m_positionBuffer.data[c];
                final float px = 1f / 3 * (pa.x + pb.x + pc.x);
                final float py = 1f / 3 * (pa.y + pb.y + pc.y);
                float rs = Vec2.cross(oa, pa) + Vec2.cross(ob, pb) + Vec2.cross(oc, pc);
                float rc = Vec2.dot(oa, pa) + Vec2.dot(ob, pb) + Vec2.dot(oc, pc);
                float r2 = rs * rs + rc * rc;
                float invR = r2 == 0 ? Float.MAX_VALUE : FXGLMath.sqrtF(1f / r2);
                rs *= invR;
                rc *= invR;
                final float strength = elasticStrength * triad.strength;
                final float roax = rc * oa.x - rs * oa.y;
                final float roay = rs * oa.x + rc * oa.y;
                final float robx = rc * ob.x - rs * ob.y;
                final float roby = rs * ob.x + rc * ob.y;
                final float rocx = rc * oc.x - rs * oc.y;
                final float rocy = rs * oc.x + rc * oc.y;
                final Vec2 va = m_velocityBuffer.data[a];
                final Vec2 vb = m_velocityBuffer.data[b];
                final Vec2 vc = m_velocityBuffer.data[c];
                va.x += strength * (roax - (pa.x - px));
                va.y += strength * (roay - (pa.y - py));
                vb.x += strength * (robx - (pb.x - px));
                vb.y += strength * (roby - (pb.y - py));
                vc.x += strength * (rocx - (pc.x - px));
                vc.y += strength * (rocy - (pc.y - py));
            }
        }
    }
    private void solveSpring(final TimeStep step) {
        float springStrength = step.inv_dt * m_springStrength;
        for (int k = 0; k < m_pairCount; k++) {
            final Pair pair = m_pairBuffer[k];
            if ((pair.flags & ParticleTypeInternal.b2_springParticle) != 0) {
                int a = pair.indexA;
                int b = pair.indexB;
                final Vec2 pa = m_positionBuffer.data[a];
                final Vec2 pb = m_positionBuffer.data[b];
                final float dx = pb.x - pa.x;
                final float dy = pb.y - pa.y;
                float r0 = pair.distance;
                float r1 = FXGLMath.sqrtF(dx * dx + dy * dy);
                if (r1 == 0) r1 = Float.MAX_VALUE;
                float strength = springStrength * pair.strength;
                final float fx = strength * (r0 - r1) / r1 * dx;
                final float fy = strength * (r0 - r1) / r1 * dy;
                final Vec2 va = m_velocityBuffer.data[a];
                final Vec2 vb = m_velocityBuffer.data[b];
                va.x -= fx;
                va.y -= fy;
                vb.x += fx;
                vb.y += fy;
            }
        }
    }
    private void solveTensile(final TimeStep step) {
        m_accumulation2Buffer = requestParticleBuffer(Vec2.class, m_accumulation2Buffer);
        for (int i = 0; i < m_count; i++) {
            m_accumulationBuffer[i] = 0;
            m_accumulation2Buffer[i].setZero();
        }
        for (int k = 0; k < m_contactCount; k++) {
            final ParticleContact contact = m_contactBuffer[k];
            if ((contact.flags & ParticleTypeInternal.b2_tensileParticle) != 0) {
                int a = contact.indexA;
                int b = contact.indexB;
                float w = contact.weight;
                Vec2 n = contact.normal;
                m_accumulationBuffer[a] += w;
                m_accumulationBuffer[b] += w;
                final Vec2 a2A = m_accumulation2Buffer[a];
                final Vec2 a2B = m_accumulation2Buffer[b];
                final float inter = (1 - w) * w;
                a2A.x -= inter * n.x;
                a2A.y -= inter * n.y;
                a2B.x += inter * n.x;
                a2B.y += inter * n.y;
            }
        }
        float strengthA = m_surfaceTensionStrengthA * getCriticalVelocity(step);
        float strengthB = m_surfaceTensionStrengthB * getCriticalVelocity(step);
        for (int k = 0; k < m_contactCount; k++) {
            final ParticleContact contact = m_contactBuffer[k];
            if ((contact.flags & ParticleTypeInternal.b2_tensileParticle) != 0) {
                int a = contact.indexA;
                int b = contact.indexB;
                float w = contact.weight;
                Vec2 n = contact.normal;
                final Vec2 a2A = m_accumulation2Buffer[a];
                final Vec2 a2B = m_accumulation2Buffer[b];
                float h = m_accumulationBuffer[a] + m_accumulationBuffer[b];
                final float sx = a2B.x - a2A.x;
                final float sy = a2B.y - a2A.y;
                float fn = (strengthA * (h - 2) + strengthB * (sx * n.x + sy * n.y)) * w;
                final float fx = fn * n.x;
                final float fy = fn * n.y;
                final Vec2 va = m_velocityBuffer.data[a];
                final Vec2 vb = m_velocityBuffer.data[b];
                va.x -= fx;
                va.y -= fy;
                vb.x += fx;
                vb.y += fy;
            }
        }
    }
    @SuppressWarnings("PMD.UnusedFormalParameter")
    private void solveViscous(final TimeStep step) {
        float viscousStrength = m_viscousStrength;
        for (int k = 0; k < m_bodyContactCount; k++) {
            final ParticleBodyContact contact = m_bodyContactBuffer[k];
            int a = contact.index;
            if ((m_flagsBuffer.data[a] & ParticleTypeInternal.b2_viscousParticle) != 0) {
                Body b = contact.body;
                float w = contact.weight;
                float m = contact.mass;
                Vec2 p = m_positionBuffer.data[a];
                final Vec2 va = m_velocityBuffer.data[a];
                final float tempX = p.x - b.m_sweep.c.x;
                final float tempY = p.y - b.m_sweep.c.y;
                final float vx = -b.getAngularVelocity() * tempY + b.getLinearVelocity().x - va.x;
                final float vy = b.getAngularVelocity() * tempX + b.getLinearVelocity().y - va.y;
                final Vec2 f = tempVec;
                final float pInvMass = getParticleInvMass();
                f.x = viscousStrength * m * w * vx;
                f.y = viscousStrength * m * w * vy;
                va.x += pInvMass * f.x;
                va.y += pInvMass * f.y;
                f.x = -f.x;
                f.y = -f.y;
                b.applyLinearImpulse(f, p, true);
            }
        }
        for (int k = 0; k < m_contactCount; k++) {
            final ParticleContact contact = m_contactBuffer[k];
            if ((contact.flags & ParticleTypeInternal.b2_viscousParticle) != 0) {
                int a = contact.indexA;
                int b = contact.indexB;
                float w = contact.weight;
                final Vec2 va = m_velocityBuffer.data[a];
                final Vec2 vb = m_velocityBuffer.data[b];
                final float vx = vb.x - va.x;
                final float vy = vb.y - va.y;
                final float fx = viscousStrength * w * vx;
                final float fy = viscousStrength * w * vy;
                va.x += fx;
                va.y += fy;
                vb.x -= fx;
                vb.y -= fy;
            }
        }
    }
    private void solvePowder(final TimeStep step) {
        float powderStrength = m_powderStrength * getCriticalVelocity(step);
        float minWeight = 1.0f - particleStride;
        for (int k = 0; k < m_bodyContactCount; k++) {
            final ParticleBodyContact contact = m_bodyContactBuffer[k];
            int a = contact.index;
            if ((m_flagsBuffer.data[a] & ParticleTypeInternal.b2_powderParticle) != 0) {
                float w = contact.weight;
                if (w > minWeight) {
                    Body b = contact.body;
                    float m = contact.mass;
                    Vec2 p = m_positionBuffer.data[a];
                    Vec2 n = contact.normal;
                    final Vec2 f = tempVec;
                    final Vec2 va = m_velocityBuffer.data[a];
                    final float inter = powderStrength * m * (w - minWeight);
                    final float pInvMass = getParticleInvMass();
                    f.x = inter * n.x;
                    f.y = inter * n.y;
                    va.x -= pInvMass * f.x;
                    va.y -= pInvMass * f.y;
                    b.applyLinearImpulse(f, p, true);
                }
            }
        }
        for (int k = 0; k < m_contactCount; k++) {
            final ParticleContact contact = m_contactBuffer[k];
            if ((contact.flags & ParticleTypeInternal.b2_powderParticle) != 0) {
                float w = contact.weight;
                if (w > minWeight) {
                    int a = contact.indexA;
                    int b = contact.indexB;
                    Vec2 n = contact.normal;
                    final Vec2 va = m_velocityBuffer.data[a];
                    final Vec2 vb = m_velocityBuffer.data[b];
                    final float inter = powderStrength * (w - minWeight);
                    final float fx = inter * n.x;
                    final float fy = inter * n.y;
                    va.x -= fx;
                    va.y -= fy;
                    vb.x += fx;
                    vb.y += fy;
                }
            }
        }
    }
    private void solveSolid(final TimeStep step) {
        m_depthBuffer = requestParticleBuffer(m_depthBuffer);
        float ejectionStrength = step.inv_dt * m_ejectionStrength;
        for (int k = 0; k < m_contactCount; k++) {
            final ParticleContact contact = m_contactBuffer[k];
            int a = contact.indexA;
            int b = contact.indexB;
            if (m_groupBuffer[a] != m_groupBuffer[b]) {
                float w = contact.weight;
                Vec2 n = contact.normal;
                float h = m_depthBuffer[a] + m_depthBuffer[b];
                final Vec2 va = m_velocityBuffer.data[a];
                final Vec2 vb = m_velocityBuffer.data[b];
                final float inter = ejectionStrength * h * w;
                final float fx = inter * n.x;
                final float fy = inter * n.y;
                va.x -= fx;
                va.y -= fy;
                vb.x += fx;
                vb.y += fy;
            }
        }
    }
    @SuppressWarnings("PMD.UnusedFormalParameter")
    private void solveColorMixing(final TimeStep step) {
        m_colorBuffer.data = requestParticleBuffer(ParticleColor.class, m_colorBuffer.data);
        int colorMixing256 = (int) (256 * m_colorMixingStrength);
        for (int k = 0; k < m_contactCount; k++) {
            final ParticleContact contact = m_contactBuffer[k];
            int a = contact.indexA;
            int b = contact.indexB;
            if ((m_flagsBuffer.data[a] & m_flagsBuffer.data[b] & ParticleTypeInternal.b2_colorMixingParticle) != 0) {
                ParticleColor colorA = m_colorBuffer.data[a];
                ParticleColor colorB = m_colorBuffer.data[b];
                int dr = (colorMixing256 * (colorB.r - colorA.r)) >> 8;
                int dg = (colorMixing256 * (colorB.g - colorA.g)) >> 8;
                int db = (colorMixing256 * (colorB.b - colorA.b)) >> 8;
                int da = (colorMixing256 * (colorB.a - colorA.a)) >> 8;
                colorA.r += dr;
                colorA.g += dg;
                colorA.b += db;
                colorA.a += da;
                colorB.r -= dr;
                colorB.g -= dg;
                colorB.b -= db;
                colorB.a -= da;
            }
        }
    }
    @SuppressWarnings("PMD.EmptyIfStmt")
    private void solveZombie() {
        int newCount = 0;
        int[] newIndices = new int[m_count];
        for (int i = 0; i < m_count; i++) {
            int flags = m_flagsBuffer.data[i];
            if ((flags & ParticleTypeInternal.b2_zombieParticle) != 0) {
                ParticleDestructionListener destructionListener = m_world.getParticleDestructionListener();
                if ((flags & ParticleTypeInternal.b2_destructionListener) != 0 && destructionListener != null) {
                    destructionListener.onDestroy(i);
                }
                newIndices[i] = invalidParticleIndex;
            } else {
                newIndices[i] = newCount;
                if (i != newCount) {
                    m_flagsBuffer.data[newCount] = m_flagsBuffer.data[i];
                    m_positionBuffer.data[newCount].set(m_positionBuffer.data[i]);
                    m_velocityBuffer.data[newCount].set(m_velocityBuffer.data[i]);
                    m_groupBuffer[newCount] = m_groupBuffer[i];
                    if (m_depthBuffer != null) {
                        m_depthBuffer[newCount] = m_depthBuffer[i];
                    }
                    if (m_colorBuffer.data != null) {
                        m_colorBuffer.data[newCount].set(m_colorBuffer.data[i]);
                    }
                    if (m_userDataBuffer.data != null) {
                        m_userDataBuffer.data[newCount] = m_userDataBuffer.data[i];
                    }
                }
                newCount++;
            }
        }
        for (int k = 0; k < m_proxyCount; k++) {
            Proxy proxy = m_proxyBuffer[k];
            proxy.index = newIndices[proxy.index];
        }
        int j = m_proxyCount;
        for (int i = 0; i < j; i++) {
            if (isProxyInvalid(m_proxyBuffer[i])) {
                --j;
                Proxy temp = m_proxyBuffer[j];
                m_proxyBuffer[j] = m_proxyBuffer[i];
                m_proxyBuffer[i] = temp;
                --i;
            }
        }
        m_proxyCount = j;
        for (int k = 0; k < m_contactCount; k++) {
            ParticleContact contact = m_contactBuffer[k];
            contact.indexA = newIndices[contact.indexA];
            contact.indexB = newIndices[contact.indexB];
        }
        j = m_contactCount;
        for (int i = 0; i < j; i++) {
            if (isContactInvalid(m_contactBuffer[i])) {
                --j;
                ParticleContact temp = m_contactBuffer[j];
                m_contactBuffer[j] = m_contactBuffer[i];
                m_contactBuffer[i] = temp;
                --i;
            }
        }
        m_contactCount = j;
        for (int k = 0; k < m_bodyContactCount; k++) {
            ParticleBodyContact contact = m_bodyContactBuffer[k];
            contact.index = newIndices[contact.index];
        }
        j = m_bodyContactCount;
        for (int i = 0; i < j; i++) {
            if (isBodyContactInvalid(m_bodyContactBuffer[i])) {
                --j;
                ParticleBodyContact temp = m_bodyContactBuffer[j];
                m_bodyContactBuffer[j] = m_bodyContactBuffer[i];
                m_bodyContactBuffer[i] = temp;
                --i;
            }
        }
        m_bodyContactCount = j;
        for (int k = 0; k < m_pairCount; k++) {
            Pair pair = m_pairBuffer[k];
            pair.indexA = newIndices[pair.indexA];
            pair.indexB = newIndices[pair.indexB];
        }
        j = m_pairCount;
        for (int i = 0; i < j; i++) {
            if (isPairInvalid(m_pairBuffer[i])) {
                --j;
                Pair temp = m_pairBuffer[j];
                m_pairBuffer[j] = m_pairBuffer[i];
                m_pairBuffer[i] = temp;
                --i;
            }
        }
        m_pairCount = j;
        for (int k = 0; k < m_triadCount; k++) {
            Triad triad = m_triadBuffer[k];
            triad.indexA = newIndices[triad.indexA];
            triad.indexB = newIndices[triad.indexB];
            triad.indexC = newIndices[triad.indexC];
        }
        j = m_triadCount;
        for (int i = 0; i < j; i++) {
            if (isTriadInvalid(m_triadBuffer[i])) {
                --j;
                Triad temp = m_triadBuffer[j];
                m_triadBuffer[j] = m_triadBuffer[i];
                m_triadBuffer[i] = temp;
                --i;
            }
        }
        m_triadCount = j;
        for (ParticleGroup group = m_groupList; group != null; group = group.getNext()) {
            int firstIndex = newCount;
            int lastIndex = 0;
            boolean modified = false;
            for (int i = group.m_firstIndex; i < group.m_lastIndex; i++) {
                j = newIndices[i];
                if (j >= 0) {
                    firstIndex = Math.min(firstIndex, j);
                    lastIndex = Math.max(lastIndex, j + 1);
                } else {
                    modified = true;
                }
            }
            if (firstIndex < lastIndex) {
                group.m_firstIndex = firstIndex;
                group.m_lastIndex = lastIndex;
                if (modified && (group.m_groupFlags & ParticleGroupType.b2_rigidParticleGroup) != 0) {
                    group.m_toBeSplit = true;
                }
            } else {
                group.m_firstIndex = 0;
                group.m_lastIndex = 0;
                if (group.m_destroyAutomatically) {
                    group.m_toBeDestroyed = true;
                }
            }
        }
        m_count = newCount;
        for (ParticleGroup group = m_groupList; group != null; ) {
            ParticleGroup next = group.getNext();
            if (group.m_toBeDestroyed) {
                destroyParticleGroup(group);
            }
            group = next;
        }
    }
    private static class NewIndices {
        int start, mid, end;
        final int getIndex(final int i) {
            if (i < start) {
                return i;
            } else if (i < mid) {
                return i + end - mid;
            } else if (i < end) {
                return i + start - mid;
            } else {
                return i;
            }
        }
    }
    private final NewIndices newIndices = new NewIndices();
    private void RotateBuffer(int start, int mid, int end) {
        if (start == mid || mid == end) {
            return;
        }
        newIndices.start = start;
        newIndices.mid = mid;
        newIndices.end = end;
        rotate(m_flagsBuffer.data, start, mid, end);
        rotate(m_positionBuffer.data, start, mid, end);
        rotate(m_velocityBuffer.data, start, mid, end);
        rotate(m_groupBuffer, start, mid, end);
        if (m_depthBuffer != null) {
            rotate(m_depthBuffer, start, mid, end);
        }
        if (m_colorBuffer.data != null) {
            rotate(m_colorBuffer.data, start, mid, end);
        }
        if (m_userDataBuffer.data != null) {
            rotate(m_userDataBuffer.data, start, mid, end);
        }
        for (int k = 0; k < m_proxyCount; k++) {
            Proxy proxy = m_proxyBuffer[k];
            proxy.index = newIndices.getIndex(proxy.index);
        }
        for (int k = 0; k < m_contactCount; k++) {
            ParticleContact contact = m_contactBuffer[k];
            contact.indexA = newIndices.getIndex(contact.indexA);
            contact.indexB = newIndices.getIndex(contact.indexB);
        }
        for (int k = 0; k < m_bodyContactCount; k++) {
            ParticleBodyContact contact = m_bodyContactBuffer[k];
            contact.index = newIndices.getIndex(contact.index);
        }
        for (int k = 0; k < m_pairCount; k++) {
            Pair pair = m_pairBuffer[k];
            pair.indexA = newIndices.getIndex(pair.indexA);
            pair.indexB = newIndices.getIndex(pair.indexB);
        }
        for (int k = 0; k < m_triadCount; k++) {
            Triad triad = m_triadBuffer[k];
            triad.indexA = newIndices.getIndex(triad.indexA);
            triad.indexB = newIndices.getIndex(triad.indexB);
            triad.indexC = newIndices.getIndex(triad.indexC);
        }
        for (ParticleGroup group = m_groupList; group != null; group = group.getNext()) {
            group.m_firstIndex = newIndices.getIndex(group.m_firstIndex);
            group.m_lastIndex = newIndices.getIndex(group.m_lastIndex - 1) + 1;
        }
    }
    public void setParticleRadius(float radius) {
        m_particleDiameter = 2 * radius;
        m_squaredDiameter = m_particleDiameter * m_particleDiameter;
        m_inverseDiameter = 1 / m_particleDiameter;
    }
    public void setParticleDensity(float density) {
        m_density = density;
        m_inverseDensity = 1 / m_density;
    }
    public float getParticleDensity() {
        return m_density;
    }
    public void setParticleGravityScale(float gravityScale) {
        m_gravityScale = gravityScale;
    }
    public float getParticleGravityScale() {
        return m_gravityScale;
    }
    public void setParticleDamping(float damping) {
        m_dampingStrength = damping;
    }
    public float getParticleDamping() {
        return m_dampingStrength;
    }
    public float getParticleRadius() {
        return m_particleDiameter / 2;
    }
    float getCriticalVelocity(final TimeStep step) {
        return m_particleDiameter * step.inv_dt;
    }
    float getCriticalVelocitySquared(final TimeStep step) {
        float velocity = getCriticalVelocity(step);
        return velocity * velocity;
    }
    float getCriticalPressure(final TimeStep step) {
        return m_density * getCriticalVelocitySquared(step);
    }
    float getParticleStride() {
        return particleStride * m_particleDiameter;
    }
    float getParticleMass() {
        float stride = getParticleStride();
        return m_density * stride * stride;
    }
    float getParticleInvMass() {
        return 1.777777f * m_inverseDensity * m_inverseDiameter * m_inverseDiameter;
    }
    public int[] getParticleFlagsBuffer() {
        return m_flagsBuffer.data;
    }
    public Vec2[] getParticlePositionBuffer() {
        return m_positionBuffer.data;
    }
    public Vec2[] getParticleVelocityBuffer() {
        return m_velocityBuffer.data;
    }
    public ParticleColor[] getParticleColorBuffer() {
        m_colorBuffer.data = requestParticleBuffer(ParticleColor.class, m_colorBuffer.data);
        return m_colorBuffer.data;
    }
    public Object[] getParticleUserDataBuffer() {
        m_userDataBuffer.data = requestParticleBuffer(Object.class, m_userDataBuffer.data);
        return m_userDataBuffer.data;
    }
    public int getParticleMaxCount() {
        return m_maxCount;
    }
    public void setParticleMaxCount(int count) {
        assert m_count <= count;
        m_maxCount = count;
    }
    public ParticleGroup[] getParticleGroupBuffer() {
        return m_groupBuffer;
    }
    public int getParticleGroupCount() {
        return m_groupCount;
    }
    public ParticleGroup[] getParticleGroupList() {
        return m_groupBuffer;
    }
    public int getParticleCount() {
        return m_count;
    }
    private static int lowerBound(Proxy[] ray, int length, long tag) {
        int left = 0;
        int step, curr;
        while (length > 0) {
            step = length / 2;
            curr = left + step;
            if (ray[curr].tag < tag) {
                left = curr + 1;
                length -= step + 1;
            } else {
                length = step;
            }
        }
        return left;
    }
    private static int upperBound(Proxy[] ray, int length, long tag) {
        int left = 0;
        int step, curr;
        while (length > 0) {
            step = length / 2;
            curr = left + step;
            if (ray[curr].tag <= tag) {
                left = curr + 1;
                length -= step + 1;
            } else {
                length = step;
            }
        }
        return left;
    }
    public void queryAABB(ParticleQueryCallback callback, final AABB aabb) {
        if (m_proxyCount == 0) {
            return;
        }
        final float lowerBoundX = aabb.lowerBound.x;
        final float lowerBoundY = aabb.lowerBound.y;
        final float upperBoundX = aabb.upperBound.x;
        final float upperBoundY = aabb.upperBound.y;
        int firstProxy =
                lowerBound(m_proxyBuffer, m_proxyCount,
                        computeTag(m_inverseDiameter * lowerBoundX, m_inverseDiameter * lowerBoundY));
        int lastProxy =
                upperBound(m_proxyBuffer, m_proxyCount,
                        computeTag(m_inverseDiameter * upperBoundX, m_inverseDiameter * upperBoundY));
        for (int proxy = firstProxy; proxy < lastProxy; ++proxy) {
            int i = m_proxyBuffer[proxy].index;
            final Vec2 p = m_positionBuffer.data[i];
            if (lowerBoundX < p.x && p.x < upperBoundX && lowerBoundY < p.y && p.y < upperBoundY && !callback.reportParticle(i)) {
                break;
            }
        }
    }
    public void raycast(ParticleRaycastCallback callback, final Vec2 point1, final Vec2 point2) {
        if (m_proxyCount == 0) {
            return;
        }
        int firstProxy =
                lowerBound(
                        m_proxyBuffer,
                        m_proxyCount,
                        computeTag(m_inverseDiameter * Math.min(point1.x, point2.x) - 1, m_inverseDiameter
                                * Math.min(point1.y, point2.y) - 1));
        int lastProxy =
                upperBound(
                        m_proxyBuffer,
                        m_proxyCount,
                        computeTag(m_inverseDiameter * Math.max(point1.x, point2.x) + 1, m_inverseDiameter
                                * Math.max(point1.y, point2.y) + 1));
        float fraction = 1;
        final float vx = point2.x - point1.x;
        final float vy = point2.y - point1.y;
        float v2 = vx * vx + vy * vy;
        if (v2 == 0) v2 = Float.MAX_VALUE;
        for (int proxy = firstProxy; proxy < lastProxy; ++proxy) {
            int i = m_proxyBuffer[proxy].index;
            final Vec2 posI = m_positionBuffer.data[i];
            final float px = point1.x - posI.x;
            final float py = point1.y - posI.y;
            float pv = px * vx + py * vy;
            float p2 = px * px + py * py;
            float determinant = pv * pv - v2 * (p2 - m_squaredDiameter);
            if (determinant >= 0) {
                float sqrtDeterminant = FXGLMath.sqrtF(determinant);
                float t = (-pv - sqrtDeterminant) / v2;
                if (t > fraction) {
                    continue;
                }
                if (t < 0) {
                    t = (-pv + sqrtDeterminant) / v2;
                    if (t < 0 || t > fraction) {
                        continue;
                    }
                }
                final Vec2 n = tempVec;
                tempVec.x = px + t * vx;
                tempVec.y = py + t * vy;
                n.getLengthAndNormalize();
                final Vec2 point = tempVec2;
                point.x = point1.x + t * vx;
                point.y = point1.y + t * vy;
                float f = callback.reportParticle(i, point, n, t);
                fraction = Math.min(fraction, f);
                if (fraction <= 0) {
                    break;
                }
            }
        }
    }
    public float computeParticleCollisionEnergy() {
        float sum_v2 = 0;
        for (int k = 0; k < m_contactCount; k++) {
            final ParticleContact contact = m_contactBuffer[k];
            int a = contact.indexA;
            int b = contact.indexB;
            Vec2 n = contact.normal;
            final Vec2 va = m_velocityBuffer.data[a];
            final Vec2 vb = m_velocityBuffer.data[b];
            final float vx = vb.x - va.x;
            final float vy = vb.y - va.y;
            float vn = vx * n.x + vy * n.y;
            if (vn < 0) {
                sum_v2 += vn * vn;
            }
        }
        return 0.5f * getParticleMass() * sum_v2;
    }
    static <T> T[] reallocateBuffer(ParticleBuffer<T> buffer, int oldCapacity, int newCapacity,
                                    boolean deferred) {
        assert newCapacity > oldCapacity;
        return reallocateBuffer(buffer.dataClass, buffer.data, buffer.userSuppliedCapacity,
                oldCapacity, newCapacity, deferred);
    }
    @SuppressWarnings("unchecked")
    <T> T[] requestParticleBuffer(Class<T> klass, T[] buffer) {
        if (buffer == null) {
            buffer = (T[]) Array.newInstance(klass, m_internalAllocatedCapacity);
            for (int i = 0; i < m_internalAllocatedCapacity; i++) {
                try {
                    buffer[i] = klass.newInstance();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }
        return buffer;
    }
    float[] requestParticleBuffer(float[] buffer) {
        if (buffer == null) {
            buffer = new float[m_internalAllocatedCapacity];
        }
        return buffer;
    }
    public static class ParticleBuffer<T> {
        public T[] data;
        final Class<T> dataClass;
        int userSuppliedCapacity;
        public ParticleBuffer(Class<T> dataClass) {
            this.dataClass = dataClass;
        }
    }
    static class ParticleBufferInt {
        int[] data;
        int userSuppliedCapacity;
    }
    public static class Proxy implements Comparable<Proxy> {
        int index;
        long tag;
        @Override
        public int compareTo(Proxy o) {
            return tag - o.tag < 0 ? -1 : o.tag == tag ? 0 : 1;
        }
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null) return false;
            if (getClass() != obj.getClass()) return false;
            Proxy other = (Proxy) obj;
            if (tag != other.tag) return false;
            return true;
        }
    }
    public static class Pair {
        int indexA, indexB;
        int flags;
        float strength;
        float distance;
    }
    public static class Triad {
        int indexA, indexB, indexC;
        int flags;
        float strength;
        final Vec2 pa = new Vec2(), pb = new Vec2(), pc = new Vec2();
        float ka, kb, kc, s;
    }
    static class CreateParticleGroupCallback implements VoronoiDiagramCallback {
        ParticleSystem system;
        ParticleGroupDef def; 
        int firstIndex;
        public void callback(int a, int b, int c) {
            final Vec2 pa = system.m_positionBuffer.data[a];
            final Vec2 pb = system.m_positionBuffer.data[b];
            final Vec2 pc = system.m_positionBuffer.data[c];
            final float dabx = pa.x - pb.x;
            final float daby = pa.y - pb.y;
            final float dbcx = pb.x - pc.x;
            final float dbcy = pb.y - pc.y;
            final float dcax = pc.x - pa.x;
            final float dcay = pc.y - pa.y;
            float maxDistanceSquared = maxTriadDistanceSquared * system.m_squaredDiameter;
            if (dabx * dabx + daby * daby < maxDistanceSquared
                    && dbcx * dbcx + dbcy * dbcy < maxDistanceSquared
                    && dcax * dcax + dcay * dcay < maxDistanceSquared) {
                if (system.m_triadCount >= system.m_triadCapacity) {
                    int oldCapacity = system.m_triadCapacity;
                    int newCapacity =
                            system.m_triadCount != 0
                                    ? 2 * system.m_triadCount
                                    : minParticleBufferCapacity;
                    system.m_triadBuffer =
                            reallocateBuffer(Triad.class, system.m_triadBuffer, oldCapacity,
                                    newCapacity);
                    system.m_triadCapacity = newCapacity;
                }
                Triad triad = system.m_triadBuffer[system.m_triadCount];
                triad.indexA = a;
                triad.indexB = b;
                triad.indexC = c;
                triad.flags =
                        system.m_flagsBuffer.data[a] | system.m_flagsBuffer.data[b]
                                | system.m_flagsBuffer.data[c];
                triad.strength = def.getStrength();
                final float midPointx = (float) 1 / 3 * (pa.x + pb.x + pc.x);
                final float midPointy = (float) 1 / 3 * (pa.y + pb.y + pc.y);
                triad.pa.x = pa.x - midPointx;
                triad.pa.y = pa.y - midPointy;
                triad.pb.x = pb.x - midPointx;
                triad.pb.y = pb.y - midPointy;
                triad.pc.x = pc.x - midPointx;
                triad.pc.y = pc.y - midPointy;
                triad.ka = -(dcax * dabx + dcay * daby);
                triad.kb = -(dabx * dbcx + daby * dbcy);
                triad.kc = -(dbcx * dcax + dbcy * dcay);
                triad.s = Vec2.cross(pa, pb) + Vec2.cross(pb, pc) + Vec2.cross(pc, pa);
                system.m_triadCount++;
            }
        }
    }
    static class JoinParticleGroupsCallback implements VoronoiDiagramCallback {
        public void callback(int a, int b, int c) {
            int countA = (a < groupB.m_firstIndex ? 1 : 0) + (b < groupB.m_firstIndex ? 1 : 0) + (c < groupB.m_firstIndex ? 1 : 0);
            if (countA > 0 && countA < 3) {
                int af = system.m_flagsBuffer.data[a];
                int bf = system.m_flagsBuffer.data[b];
                int cf = system.m_flagsBuffer.data[c];
                if ((af & bf & cf & k_triadFlags) != 0) {
                    final Vec2 pa = system.m_positionBuffer.data[a];
                    final Vec2 pb = system.m_positionBuffer.data[b];
                    final Vec2 pc = system.m_positionBuffer.data[c];
                    final float dabx = pa.x - pb.x;
                    final float daby = pa.y - pb.y;
                    final float dbcx = pb.x - pc.x;
                    final float dbcy = pb.y - pc.y;
                    final float dcax = pc.x - pa.x;
                    final float dcay = pc.y - pa.y;
                    float maxDistanceSquared = maxTriadDistanceSquared * system.m_squaredDiameter;
                    if (dabx * dabx + daby * daby < maxDistanceSquared
                            && dbcx * dbcx + dbcy * dbcy < maxDistanceSquared
                            && dcax * dcax + dcay * dcay < maxDistanceSquared) {
                        if (system.m_triadCount >= system.m_triadCapacity) {
                            int oldCapacity = system.m_triadCapacity;
                            int newCapacity =
                                    system.m_triadCount != 0
                                            ? 2 * system.m_triadCount
                                            : minParticleBufferCapacity;
                            system.m_triadBuffer =
                                    reallocateBuffer(Triad.class, system.m_triadBuffer, oldCapacity,
                                            newCapacity);
                            system.m_triadCapacity = newCapacity;
                        }
                        Triad triad = system.m_triadBuffer[system.m_triadCount];
                        triad.indexA = a;
                        triad.indexB = b;
                        triad.indexC = c;
                        triad.flags = af | bf | cf;
                        triad.strength = Math.min(groupA.m_strength, groupB.m_strength);
                        final float midPointx = (float) 1 / 3 * (pa.x + pb.x + pc.x);
                        final float midPointy = (float) 1 / 3 * (pa.y + pb.y + pc.y);
                        triad.pa.x = pa.x - midPointx;
                        triad.pa.y = pa.y - midPointy;
                        triad.pb.x = pb.x - midPointx;
                        triad.pb.y = pb.y - midPointy;
                        triad.pc.x = pc.x - midPointx;
                        triad.pc.y = pc.y - midPointy;
                        triad.ka = -(dcax * dabx + dcay * daby);
                        triad.kb = -(dabx * dbcx + daby * dbcy);
                        triad.kc = -(dbcx * dcax + dbcy * dcay);
                        triad.s = Vec2.cross(pa, pb) + Vec2.cross(pb, pc) + Vec2.cross(pc, pa);
                        system.m_triadCount++;
                    }
                }
            }
        }
        ParticleSystem system;
        ParticleGroup groupA;
        ParticleGroup groupB;
    }
    static class DestroyParticlesInShapeCallback implements ParticleQueryCallback {
        ParticleSystem system;
        Shape shape;
        Transform xf;
        boolean callDestructionListener;
        int destroyed;
        public void init(ParticleSystem system, Shape shape, Transform xf, boolean callDestructionListener) {
            this.system = system;
            this.shape = shape;
            this.xf = xf;
            this.destroyed = 0;
            this.callDestructionListener = callDestructionListener;
        }
        @Override
        public boolean reportParticle(int index) {
            assert index >= 0 && index < system.m_count;
            if (shape.containsPoint(xf, system.m_positionBuffer.data[index])) {
                system.destroyParticle(index, callDestructionListener);
                destroyed++;
            }
            return true;
        }
    }
    static class UpdateBodyContactsCallback implements QueryCallback {
        ParticleSystem system;
        private final Vec2 tempVec = new Vec2();
        @Override
        public boolean reportFixture(Fixture fixture) {
            if (fixture.isSensor()) {
                return true;
            }
            final Shape shape = fixture.getShape();
            Body b = fixture.getBody();
            Vec2 bp = b.getWorldCenter();
            float bm = b.getMass();
            float bI = b.getInertia() - bm * b.getLocalCenter().lengthSquared();
            float invBm = bm > 0 ? 1 / bm : 0;
            float invBI = bI > 0 ? 1 / bI : 0;
            int childCount = shape.getChildCount();
            for (int childIndex = 0; childIndex < childCount; childIndex++) {
                AABB aabb = fixture.getAABB(childIndex);
                final float aabblowerBoundx = aabb.lowerBound.x - system.m_particleDiameter;
                final float aabblowerBoundy = aabb.lowerBound.y - system.m_particleDiameter;
                final float aabbupperBoundx = aabb.upperBound.x + system.m_particleDiameter;
                final float aabbupperBoundy = aabb.upperBound.y + system.m_particleDiameter;
                int firstProxy = lowerBound(
                        system.m_proxyBuffer,
                        system.m_proxyCount,
                        computeTag(system.m_inverseDiameter * aabblowerBoundx, system.m_inverseDiameter * aabblowerBoundy)
                );
                int lastProxy = upperBound(
                        system.m_proxyBuffer,
                        system.m_proxyCount,
                        computeTag(system.m_inverseDiameter * aabbupperBoundx, system.m_inverseDiameter * aabbupperBoundy)
                );
                for (int proxy = firstProxy; proxy != lastProxy; ++proxy) {
                    int a = system.m_proxyBuffer[proxy].index;
                    Vec2 ap = system.m_positionBuffer.data[a];
                    if (aabblowerBoundx <= ap.x && ap.x <= aabbupperBoundx && aabblowerBoundy <= ap.y && ap.y <= aabbupperBoundy) {
                        final Vec2 n = tempVec;
                        float d = fixture.computeDistance(ap, childIndex, n);
                        if (d < system.m_particleDiameter) {
                            float invAm = (system.m_flagsBuffer.data[a] & ParticleTypeInternal.b2_wallParticle) != 0 ? 0 : system.getParticleInvMass();
                            final float rpx = ap.x - bp.x;
                            final float rpy = ap.y - bp.y;
                            float rpn = rpx * n.y - rpy * n.x;
                            if (system.m_bodyContactCount >= system.m_bodyContactCapacity) {
                                int oldCapacity = system.m_bodyContactCapacity;
                                int newCapacity = system.m_bodyContactCount != 0 ? 2 * system.m_bodyContactCount : minParticleBufferCapacity;
                                system.m_bodyContactBuffer = reallocateBuffer(ParticleBodyContact.class, system.m_bodyContactBuffer, oldCapacity, newCapacity);
                                system.m_bodyContactCapacity = newCapacity;
                            }
                            ParticleBodyContact contact = system.m_bodyContactBuffer[system.m_bodyContactCount];
                            contact.index = a;
                            contact.body = b;
                            contact.weight = 1 - d * system.m_inverseDiameter;
                            contact.normal.x = -n.x;
                            contact.normal.y = -n.y;
                            contact.mass = 1 / (invAm + invBm + invBI * rpn * rpn);
                            system.m_bodyContactCount++;
                        }
                    }
                }
            }
            return true;
        }
    }
    static class SolveCollisionCallback implements QueryCallback {
        ParticleSystem system;
        TimeStep step;
        private final RayCastInput input = new RayCastInput();
        private final RayCastOutput output = new RayCastOutput();
        private final Vec2 tempVec = new Vec2();
        private final Vec2 tempVec2 = new Vec2();
        @Override
        public boolean reportFixture(Fixture fixture) {
            if (fixture.isSensor()) {
                return true;
            }
            final Shape shape = fixture.getShape();
            Body body = fixture.getBody();
            int childCount = shape.getChildCount();
            for (int childIndex = 0; childIndex < childCount; childIndex++) {
                AABB aabb = fixture.getAABB(childIndex);
                final float aabblowerBoundx = aabb.lowerBound.x - system.m_particleDiameter;
                final float aabblowerBoundy = aabb.lowerBound.y - system.m_particleDiameter;
                final float aabbupperBoundx = aabb.upperBound.x + system.m_particleDiameter;
                final float aabbupperBoundy = aabb.upperBound.y + system.m_particleDiameter;
                int firstProxy = lowerBound(
                        system.m_proxyBuffer,
                        system.m_proxyCount,
                        computeTag(system.m_inverseDiameter * aabblowerBoundx, system.m_inverseDiameter * aabblowerBoundy)
                );
                int lastProxy = upperBound(
                        system.m_proxyBuffer,
                        system.m_proxyCount,
                        computeTag(system.m_inverseDiameter * aabbupperBoundx, system.m_inverseDiameter * aabbupperBoundy)
                );
                for (int proxy = firstProxy; proxy != lastProxy; ++proxy) {
                    int a = system.m_proxyBuffer[proxy].index;
                    Vec2 ap = system.m_positionBuffer.data[a];
                    if (aabblowerBoundx <= ap.x && ap.x <= aabbupperBoundx && aabblowerBoundy <= ap.y && ap.y <= aabbupperBoundy) {
                        Vec2 av = system.m_velocityBuffer.data[a];
                        final Vec2 temp = tempVec;
                        Transform.mulTransToOutUnsafe(body.m_xf0, ap, temp);
                        Transform.mulToOutUnsafe(body.m_xf, temp, input.p1);
                        input.p2.x = ap.x + step.dt * av.x;
                        input.p2.y = ap.y + step.dt * av.y;
                        input.maxFraction = 1;
                        if (fixture.raycast(output, input, childIndex)) {
                            final Vec2 p = tempVec;
                            p.x = (1 - output.fraction) * input.p1.x + output.fraction * input.p2.x + linearSlop * output.normal.x;
                            p.y = (1 - output.fraction) * input.p1.y + output.fraction * input.p2.y + linearSlop * output.normal.y;
                            final float vx = step.inv_dt * (p.x - ap.x);
                            final float vy = step.inv_dt * (p.y - ap.y);
                            av.x = vx;
                            av.y = vy;
                            final float particleMass = system.getParticleMass();
                            final float ax = particleMass * (av.x - vx);
                            final float ay = particleMass * (av.y - vy);
                            Vec2 b = output.normal;
                            final float fdn = ax * b.x + ay * b.y;
                            final Vec2 f = tempVec2;
                            f.x = fdn * b.x;
                            f.y = fdn * b.y;
                            body.applyLinearImpulse(f, p, true);
                        }
                    }
                }
            }
            return true;
        }
    }
    private static boolean isProxyInvalid(Proxy proxy) {
        return proxy.index < 0;
    }
    private static boolean isContactInvalid(ParticleContact contact) {
        return contact.indexA < 0 || contact.indexB < 0;
    }
    private static boolean isBodyContactInvalid(ParticleBodyContact contact) {
        return contact.index < 0;
    }
    private static boolean isPairInvalid(Pair pair) {
        return pair.indexA < 0 || pair.indexB < 0;
    }
    private static boolean isTriadInvalid(Triad triad) {
        return triad.indexA < 0 || triad.indexB < 0 || triad.indexC < 0;
    }
    private static <T> T[] reallocateBuffer(Class<T> klass, T[] oldBuffer, int oldCapacity,
                                           int newCapacity) {
        assert newCapacity > oldCapacity;
        @SuppressWarnings("unchecked")
        T[] newBuffer = (T[]) Array.newInstance(klass, newCapacity);
        if (oldBuffer != null) {
            System.arraycopy(oldBuffer, 0, newBuffer, 0, oldCapacity);
        }
        for (int i = oldCapacity; i < newCapacity; i++) {
            try {
                newBuffer[i] = klass.newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return newBuffer;
    }
    private static int[] reallocateBuffer(int[] oldBuffer, int oldCapacity, int newCapacity) {
        assert newCapacity > oldCapacity;
        int[] newBuffer = new int[newCapacity];
        if (oldBuffer != null) {
            System.arraycopy(oldBuffer, 0, newBuffer, 0, oldCapacity);
        }
        return newBuffer;
    }
    private static float[] reallocateBuffer(float[] oldBuffer, int oldCapacity, int newCapacity) {
        assert newCapacity > oldCapacity;
        float[] newBuffer = new float[newCapacity];
        if (oldBuffer != null) {
            System.arraycopy(oldBuffer, 0, newBuffer, 0, oldCapacity);
        }
        return newBuffer;
    }
    private static <T> T[] reallocateBuffer(Class<T> klass, T[] buffer, int userSuppliedCapacity,
                                           int oldCapacity, int newCapacity, boolean deferred) {
        assert newCapacity > oldCapacity;
        assert userSuppliedCapacity == 0 || newCapacity <= userSuppliedCapacity;
        if ((!deferred || buffer != null) && userSuppliedCapacity == 0) {
            buffer = reallocateBuffer(klass, buffer, oldCapacity, newCapacity);
        }
        return buffer;
    }
    private static int[] reallocateBuffer(ParticleBufferInt buffer, int oldCapacity, int newCapacity, boolean deferred) {
        int[] data = buffer.data;
        if ((!deferred || data != null) && buffer.userSuppliedCapacity == 0) {
            data = reallocateBuffer(data, oldCapacity, newCapacity);
        }
        return data;
    }
    private static float[] reallocateBuffer(float[] buffer, int userSuppliedCapacity, int oldCapacity,
                                           int newCapacity, boolean deferred) {
        assert newCapacity > oldCapacity;
        assert userSuppliedCapacity == 0 || newCapacity <= userSuppliedCapacity;
        if ((!deferred || buffer != null) && userSuppliedCapacity == 0) {
            buffer = reallocateBuffer(buffer, oldCapacity, newCapacity);
        }
        return buffer;
    }
    private static <T> void rotate(T[] ray, int first, int new_first, int last) {
        int next = new_first;
        while (next != first) {
            T temp = ray[first];
            ray[first] = ray[next];
            ray[next] = temp;
            first++;
            next++;
            if (next == last) {
                next = new_first;
            } else if (first == new_first) {
                new_first = next;
            }
        }
    }
    private static void rotate(int[] ray, int first, int new_first, int last) {
        int next = new_first;
        while (next != first) {
            int temp = ray[first];
            ray[first] = ray[next];
            ray[next] = temp;
            first++;
            next++;
            if (next == last) {
                next = new_first;
            } else if (first == new_first) {
                new_first = next;
            }
        }
    }
    private static void rotate(float[] ray, int first, int new_first, int last) {
        int next = new_first;
        while (next != first) {
            float temp = ray[first];
            ray[first] = ray[next];
            ray[next] = temp;
            first++;
            next++;
            if (next == last) {
                next = new_first;
            } else if (first == new_first) {
                new_first = next;
            }
        }
    }
}
package com.almasb.fxgl.physics.box2d.callbacks;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.dynamics.Fixture;
import com.almasb.fxgl.physics.box2d.dynamics.World;
public interface RayCastCallback {
    float reportFixture(Fixture fixture, Vec2 point, Vec2 normal, float fraction);
}
package com.almasb.fxgl.physics;
import com.almasb.fxgl.core.collection.Array;
import com.almasb.fxgl.core.collection.UnorderedArray;
import com.almasb.fxgl.core.collection.UnorderedPairMap;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.core.pool.Pool;
import com.almasb.fxgl.core.pool.Pools;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.entity.EntityWorldListener;
import com.almasb.fxgl.entity.components.BoundingBoxComponent;
import com.almasb.fxgl.entity.components.CollidableComponent;
import com.almasb.fxgl.logging.Logger;
import com.almasb.fxgl.physics.box2d.callbacks.ContactFilter;
import com.almasb.fxgl.physics.box2d.callbacks.ContactImpulse;
import com.almasb.fxgl.physics.box2d.callbacks.ContactListener;
import com.almasb.fxgl.physics.box2d.collision.Manifold;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.dynamics.*;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.joints.*;
import javafx.beans.value.ChangeListener;
import javafx.geometry.Point2D;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
public final class PhysicsWorld implements EntityWorldListener, ContactListener, PhysicsUnitConverter {
    private static final Logger log = Logger.get(PhysicsWorld.class);
    private final double PIXELS_PER_METER;
    private final double METERS_PER_PIXELS;
    private World jboxWorld = new World(new Vec2(0, -10));
    private Array<Entity> entities = new UnorderedArray<>(128);
    private UnorderedPairMap<Object, CollisionHandler> collisionHandlers = new UnorderedPairMap<>(16);
    private UnorderedPairMap<Entity, CollisionPair> collisionsMap = new UnorderedPairMap<>(128);
    private CollisionDetectionStrategy strategy;
    private int appHeight;
    public PhysicsWorld(int appHeight, double ppm) {
        this(appHeight, ppm, CollisionDetectionStrategy.BRUTE_FORCE);
    }
    public PhysicsWorld(int appHeight, double ppm, CollisionDetectionStrategy strategy) {
        this.appHeight = appHeight;
        this.strategy = strategy;
        PIXELS_PER_METER = ppm;
        METERS_PER_PIXELS = 1 / PIXELS_PER_METER;
        initCollisionPool();
        initContactListener();
        initParticles();
        jboxWorld.setContactFilter(new CollisionFilterCallback());
        log.debugf("Physics world initialized: appHeight=%d, physics.ppm=%.1f",
                appHeight, ppm);
        log.debug("Using strategy: " + strategy);
    }
    private void initCollisionPool() {
        Pools.set(CollisionPair.class, new Pool<CollisionPair>() {
            @Override
            protected CollisionPair newObject() {
                return new CollisionPair();
            }
        });
    }
    private void initContactListener() {
        jboxWorld.setContactListener(this);
    }
    private void initParticles() {
        jboxWorld.setParticleGravityScale(1f);
        jboxWorld.setParticleDensity(1.2f);
        jboxWorld.setParticleRadius(toMetersF(1));    
    }
    private Array<Entity> delayedBodiesAdd = new UnorderedArray<>();
    private Array<Body> delayedBodiesRemove = new UnorderedArray<>();
    private Map<Entity, ChangeListener<Number> > scaleListeners = new HashMap<>();
    @Override
    public void onEntityAdded(Entity entity) {
        entities.add(entity);
        if (entity.hasComponent(PhysicsComponent.class)) {
            onPhysicsEntityAdded(entity);
        }
    }
    private void onPhysicsEntityAdded(Entity entity) {
        if (!jboxWorld.isLocked()) {
            createBody(entity);
        } else {
            delayedBodiesAdd.add(entity);
        }
        ChangeListener<Number> scaleChangeListener = (observable, oldValue, newValue) -> {
            Body b = entity.getComponent(PhysicsComponent.class).body;
            if (b != null) {
                List<Fixture> fixtures = List.copyOf(b.getFixtures());
                fixtures.forEach(b::destroyFixture);
                createFixtures(entity);
                createSensors(entity);
            }
        };
        scaleListeners.put(entity, scaleChangeListener);
        entity.getTransformComponent().scaleXProperty().addListener(scaleChangeListener);
        entity.getTransformComponent().scaleYProperty().addListener(scaleChangeListener);
    }
    @Override
    public void onEntityRemoved(Entity entity) {
        entities.removeValueByIdentity(entity);
        if (entity.hasComponent(PhysicsComponent.class)) {
            onPhysicsEntityRemoved(entity);
        }
    }
    private void onPhysicsEntityRemoved(Entity entity) {
        if (scaleListeners.containsKey(entity)) {
            ChangeListener<Number> scaleChangeListener = scaleListeners.get(entity);
            entity.getTransformComponent().scaleXProperty().removeListener(scaleChangeListener);
            entity.getTransformComponent().scaleYProperty().removeListener(scaleChangeListener);
            scaleListeners.remove(entity);
        }
        if (!jboxWorld.isLocked()) {
            destroyBody(entity);
        } else {
            delayedBodiesRemove.add(entity.getComponent(PhysicsComponent.class).getBody());
        }
    }
    public void onUpdate(double tpf) {
        jboxWorld.step((float) tpf, 8, 3);
        postStep();
        checkCollisions();
        notifyCollisions();
    }
    private void postStep() {
        for (Entity e : delayedBodiesAdd)
            createBody(e);
        delayedBodiesAdd.clear();
        for (Body body : delayedBodiesRemove)
            jboxWorld.destroyBody(body);
        delayedBodiesRemove.clear();
    }
    public void clear() {
        log.debug("Clearing physics world");
        entities.clear();
        collisionsMap.clear();
    }
    public void clearCollisionHandlers() {
        collisionHandlers.clear();
    }
    @Override
    public void beginContact(Contact contact) {
        Entity e1 = contact.getFixtureA().getBody().getEntity();
        Entity e2 = contact.getFixtureB().getBody().getEntity();
        if (contact.getFixtureA().isSensor()) {
            notifySensorCollisionBegin(e1, e2, contact.getFixtureA().getHitBox());
            return;
        } else if (contact.getFixtureB().isSensor()) {
            notifySensorCollisionBegin(e2, e1, contact.getFixtureB().getHitBox());
            return;
        }
        if (!areCollidable(e1, e2))
            return;
        CollisionHandler handler = getHandler(e1, e2);
        if (handler != null) {
            HitBox a = contact.getFixtureA().getHitBox();
            HitBox b = contact.getFixtureB().getHitBox();
            collisionBeginFor(handler, e1, e2, a, b);
        }
    }
    @Override
    public void endContact(Contact contact) {
        Entity e1 = contact.getFixtureA().getBody().getEntity();
        Entity e2 = contact.getFixtureB().getBody().getEntity();
        if (contact.getFixtureA().isSensor()) {
            notifySensorCollisionEnd(e1, e2, contact.getFixtureA().getHitBox());
            return;
        } else if (contact.getFixtureB().isSensor()) {
            notifySensorCollisionEnd(e2, e1, contact.getFixtureB().getHitBox());
            return;
        }
        if (!areCollidable(e1, e2))
            return;
        CollisionHandler handler = getHandler(e1, e2);
        if (handler != null) {
            collisionEndFor(e1, e2);
        }
    }
    public World getJBox2DWorld() {
        return jboxWorld;
    }
    private boolean isCollidable(Entity e) {
        if (!e.isActive())
            return false;
        return e.getComponentOptional(CollidableComponent.class)
                .map(CollidableComponent::getValue)
                .orElse(false);
    }
    private boolean areCollidable(Entity e1, Entity e2) {
        return isCollidable(e1) && isCollidable(e2);
    }
    @SuppressWarnings("PMD.UselessParentheses")
    private boolean needManualCheck(Entity e1, Entity e2) {
        BodyType type1 = e1.getComponentOptional(PhysicsComponent.class)
                .map(p -> p.body.getType())
                .orElse(null);
        if (type1 == null)
            return true;
        BodyType type2 = e2.getComponentOptional(PhysicsComponent.class)
                .map(p -> p.body.getType())
                .orElse(null);
        if (type2 == null)
            return true;
        return (type1 == BodyType.KINEMATIC && type2 == BodyType.STATIC)
                || (type2 == BodyType.KINEMATIC && type1 == BodyType.STATIC);
    }
    private CollisionHandler getHandler(Entity e1, Entity e2) {
        if (!e1.isActive() || !e2.isActive())
            return null;
        return collisionHandlers.get(e1.getType(), e2.getType());
    }
    private void notifySensorCollisionBegin(Entity eWithSensor, Entity eTriggered, HitBox box) {
        var handler = eWithSensor.getComponent(PhysicsComponent.class).getSensorHandlers().get(box);
        handler.onCollisionBegin(eTriggered);
    }
    private void notifySensorCollisionEnd(Entity eWithSensor, Entity eTriggered, HitBox box) {
        var handler = eWithSensor.getComponent(PhysicsComponent.class).getSensorHandlers().get(box);
        handler.onCollisionEnd(eTriggered);
    }
    @Override
    public void preSolve(Contact contact, Manifold oldManifold) { }
    @Override
    public void postSolve(Contact contact, ContactImpulse impulse) { }
    private Array<Entity> collidables = new UnorderedArray<>(128);
    private CollisionResult collisionResult = new CollisionResult();
    private CollisionGrid collisionGrid = new CollisionGrid(64, 64);
    private void checkCollisions() {
        if (strategy == CollisionDetectionStrategy.GRID_INDEXING) {
            for (Entity e : entities) {
                if (isCollidable(e)) {
                    e.getBoundingBoxComponent().applyTransformToHitBoxes$fxgl_entity();
                    collisionGrid.insert(e);
                }
            }
            collisionGrid.getCells().forEach((p, cell) -> {
                checkCollisionsInGroup(cell.getEntities());
            });
            collisionGrid.getCells().clear();
        } else {
            for (Entity e : entities) {
                if (isCollidable(e)) {
                    e.getBoundingBoxComponent().applyTransformToHitBoxes$fxgl_entity();
                    collidables.add(e);
                }
            }
            checkCollisionsInGroup(collidables);
            collidables.clear();
        }
    }
    private void checkCollisionsInGroup(Array<Entity> group) {
        for (int i = 0; i < group.size(); i++) {
            Entity e1 = group.get(i);
            for (int j = i + 1; j < group.size(); j++) {
                Entity e2 = group.get(j);
                CollisionHandler handler = getHandler(e1, e2);
                if (handler == null)
                    continue;
                if (!needManualCheck(e1, e2)) {
                    continue;
                }
                if (isIgnored(e1, e2))
                    continue;
                var collision = e1.getBoundingBoxComponent().checkCollisionPAT(e2.getBoundingBoxComponent(), collisionResult);
                if (collision) {
                    collisionBeginFor(handler, e1, e2, collisionResult.getBoxA(), collisionResult.getBoxB());
                } else {
                    collisionEndFor(e1, e2);
                }
            }
        }
    }
    private boolean isIgnored(Entity e1, Entity e2) {
        if (!e1.hasComponent(CollidableComponent.class) || !e2.hasComponent(CollidableComponent.class))
            return false;
        CollidableComponent c1 = e1.getComponent(CollidableComponent.class);
        for (Serializable t1 : c1.getIgnoredTypes()) {
            if (e2.isType(t1)) {
                return true;
            }
        }
        CollidableComponent c2 = e2.getComponent(CollidableComponent.class);
        for (Serializable t2 : c2.getIgnoredTypes()) {
            if (e1.isType(t2)) {
                return true;
            }
        }
        return false;
    }
    private void collisionBeginFor(CollisionHandler handler, Entity e1, Entity e2, HitBox a, HitBox b) {
        CollisionPair pair = collisionsMap.get(e1, e2);
        if (pair == null) {
            pair = Pools.obtain(CollisionPair.class);
            pair.init(e1, e2, handler);
            collisionsMap.put(pair.getA(), pair.getB(), pair);
            handler.onHitBoxTrigger(
                    pair.getA(), pair.getB(),
                    e1 == pair.getA() ? a : b,
                    e2 == pair.getB() ? b : a
            );
            pair.collisionBegin();
        }
    }
    private void collisionEndFor(Entity e1, Entity e2) {
        CollisionPair pair = collisionsMap.get(e1, e2);
        if (pair != null) {
            collisionsMap.remove(pair.getA(), pair.getB());
            pair.collisionEnd();
            Pools.free(pair);
        }
    }
    private void notifyCollisions() {
        for (Iterator<CollisionPair> it = collisionsMap.getValues().iterator(); it.hasNext(); ) {
            CollisionPair pair = it.next();
            if (!isCollidable(pair.getA()) || !isCollidable(pair.getB())) {
                pair.collisionEnd();
                it.remove();
                Pools.free(pair);
                continue;
            }
            pair.collision();
        }
    }
    public void addCollisionHandler(CollisionHandler handler) {
        collisionHandlers.put(handler.getA(), handler.getB(), handler);
    }
    public void removeCollisionHandler(CollisionHandler handler) {
        collisionHandlers.remove(handler.getA(), handler.getB());
    }
    public void setGravity(double x, double y) {
        jboxWorld.setGravity(toVector(new Point2D(x, y)));
    }
    private void createBody(Entity e) {
        PhysicsComponent physics = e.getComponent(PhysicsComponent.class);
        physics.setWorld(this);
        if (physics.bodyDef.getPosition().x == 0 && physics.bodyDef.getPosition().y == 0) {
            physics.bodyDef.getPosition().set(toPoint(e.getCenter()));
        }
        if (physics.bodyDef.getAngle() == 0) {
            physics.bodyDef.setAngle((float) -Math.toRadians(e.getRotation()));
        }
        physics.body = jboxWorld.createBody(physics.bodyDef);
        createFixtures(e);
        createSensors(e);
        physics.body.setEntity(e);
        physics.onInitPhysics();
    }
    private void createFixtures(Entity e) {
        BoundingBoxComponent bbox = e.getBoundingBoxComponent();
        PhysicsComponent physics = e.getComponent(PhysicsComponent.class);
        FixtureDef fd = physics.fixtureDef;
        for (HitBox box : bbox.hitBoxesProperty()) {
            Shape b2Shape = createShape(box, e);
            fd.setShape(b2Shape);
            Fixture fixture = physics.body.createFixture(fd);
            fixture.setHitBox(box);
        }
    }
    private void createSensors(Entity e) {
        PhysicsComponent physics = e.getComponent(PhysicsComponent.class);
        if (physics.getSensorHandlers().isEmpty())
            return;
        physics.getSensorHandlers().keySet().forEach(box -> {
            box.bindXY(e.getTransformComponent());
            Shape polygonShape = createShape(box, e);
            FixtureDef fd = new FixtureDef()
                    .sensor(true)
                    .shape(polygonShape);
            Fixture f = physics.body.createFixture(fd);
            f.setHitBox(box);
        });
    }
    private Shape createShape(HitBox box, Entity e) {
        if (e.getComponent(PhysicsComponent.class).body.getType() != BodyType.STATIC
                && box.getShape() instanceof ChainShapeData) {
            throw new IllegalArgumentException("BoundingShape.chain() can only be used with BodyType.STATIC");
        }
        return box.toBox2DShape(e.getBoundingBoxComponent(), this);
    }
    void destroyFixture(Body body, HitBox box) {
        body.getFixtures()
                .stream()
                .filter(f -> f.getHitBox() == box)
                .findAny()
                .ifPresent(body::destroyFixture);
    }
    private void destroyBody(Entity e) {
        jboxWorld.destroyBody(e.getComponent(PhysicsComponent.class).body);
    }
    private EdgeCallback raycastCallback = new EdgeCallback();
    public RaycastResult raycast(Point2D start, Point2D end) {
        raycastCallback.reset();
        jboxWorld.raycast(raycastCallback, toPoint(start), toPoint(end));
        Entity entity = null;
        Point2D point = null;
        if (raycastCallback.getFixture() != null)
            entity = raycastCallback.getFixture().getBody().getEntity();
        if (raycastCallback.getPoint() != null)
            point = toPoint(raycastCallback.getPoint());
        if (entity == null && point == null)
            return RaycastResult.NONE;
        return new RaycastResult(entity, point);
    }
    public RevoluteJoint addRevoluteJoint(Entity e1, Entity e2, Point2D localAnchor1, Point2D localAnchor2) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        RevoluteJointDef def = new RevoluteJointDef();
        def.localAnchorA = toPoint(e1.getAnchoredPosition().add(localAnchor1)).subLocal(p1.getBody().getWorldCenter());
        def.localAnchorB = toPoint(e2.getAnchoredPosition().add(localAnchor2)).subLocal(p2.getBody().getWorldCenter());
        return addJoint(e1, e2, def);
    }
    public RopeJoint addRopeJoint(Entity e1, Entity e2) {
        var c1 = e1.getBoundingBoxComponent().getCenterLocal();
        var c2 = e2.getBoundingBoxComponent().getCenterLocal();
        return addRopeJoint(e1, e2, c1, c2, e1.getCenter().distance(e2.getCenter()));
    }
    public RopeJoint addRopeJoint(Entity e1, Entity e2, Point2D localAnchor1, Point2D localAnchor2, double length) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        RopeJointDef def = new RopeJointDef();
        def.localAnchorA.set(toPoint(e1.getAnchoredPosition().add(localAnchor1)).subLocal(p1.getBody().getWorldCenter()));
        def.localAnchorB.set(toPoint(e2.getAnchoredPosition().add(localAnchor2)).subLocal(p2.getBody().getWorldCenter()));
        def.maxLength = toMetersF(length);
        return addJoint(e1, e2, def);
    }
    public PrismaticJoint addPrismaticJoint(Entity e1, Entity e2, Point2D axis, double limit) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        var def = new PrismaticJointDef();
        def.initialize(p1.getBody(), p2.getBody(), p2.getBody().getWorldCenter(), toVector(axis));
        def.enableLimit = true;
        def.upperTranslation = toMetersF(limit);
        return addJoint(e1, e2, def);
    }
    public <T extends Joint> T addJoint(Entity e1, Entity e2, JointDef<T> def) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        def.setBodyA(p1.body);
        def.setBodyB(p2.body);
        return jboxWorld.createJoint(def);
    }
    private void checkJointRequirements(Entity e1, Entity e2) {
        if (!e1.hasComponent(PhysicsComponent.class) || !e2.hasComponent(PhysicsComponent.class)) {
            throw new IllegalArgumentException("Cannot create a joint: both entities must have PhysicsComponent");
        }
    }
    public void removeJoint(Joint joint) {
        jboxWorld.destroyJoint(joint);
    }
    @Override
    public double toMeters(double pixels) {
        return pixels * METERS_PER_PIXELS;
    }
    @Override
    public double toPixels(double meters) {
        return meters * PIXELS_PER_METER;
    }
    @Override
    public Vec2 toPoint(Point2D p) {
        return new Vec2(toMetersF(p.getX()), toMetersF(appHeight - p.getY()));
    }
    @Override
    public Point2D toPoint(Vec2 p) {
        return new Point2D(toPixels(p.x), toPixels(toMeters(appHeight) - p.y));
    }
    private class CollisionFilterCallback extends ContactFilter {
        @Override
        public boolean shouldCollide(Fixture fixtureA, Fixture fixtureB) {
            Entity e1 = fixtureA.getBody().getEntity();
            Entity e2 = fixtureB.getBody().getEntity();
            if (areCollidable(e1, e2) && isIgnored(e1, e2))
                return false;
            return super.shouldCollide(fixtureA, fixtureB);
        }
    }
}