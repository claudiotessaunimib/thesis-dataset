/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Allergen;
import org.openmrs.Allergies;
import org.openmrs.Allergy;
import org.openmrs.BaseOpenmrsMetadata;
import org.openmrs.Concept;
import org.openmrs.Encounter;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.Order;
import org.openmrs.Patient;
import org.openmrs.PatientIdentifier;
import org.openmrs.PatientIdentifierType;
import org.openmrs.PatientProgram;
import org.openmrs.Person;
import org.openmrs.PersonAddress;
import org.openmrs.PersonAttribute;
import org.openmrs.PersonName;
import org.openmrs.Relationship;
import org.openmrs.User;
import org.openmrs.Visit;
import org.openmrs.api.APIException;
import org.openmrs.api.BlankIdentifierException;
import org.openmrs.api.DuplicateIdentifierException;
import org.openmrs.api.EncounterService;
import org.openmrs.api.InsufficientIdentifiersException;
import org.openmrs.api.MissingRequiredIdentifierException;
import org.openmrs.api.ObsService;
import org.openmrs.api.PatientIdentifierException;
import org.openmrs.api.PatientIdentifierTypeLockedException;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.UserService;
import org.openmrs.api.VisitService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.PatientDAO;
import org.openmrs.api.db.hibernate.HibernateUtil;
import org.openmrs.parameter.EncounterSearchCriteria;
import org.openmrs.parameter.EncounterSearchCriteriaBuilder;
import org.openmrs.patient.IdentifierValidator;
import org.openmrs.patient.impl.LuhnIdentifierValidator;
import org.openmrs.person.PersonMergeLog;
import org.openmrs.person.PersonMergeLogData;
import org.openmrs.serialization.SerializationException;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.validator.PatientIdentifierValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;
/**
 * Default implementation of the patient service. This class should not be used on its own. The
 * current OpenMRS implementation should be fetched from the Context via
 * <code>Context.getPatientService()</code>
 * 
 * @see org.openmrs.api.context.Context
 * @see org.openmrs.api.PatientService
 * @see org.openmrs.api.PersonService
 */
@Transactional
public class PatientServiceImpl extends BaseOpenmrsService implements PatientService {
	
	private static final Logger log = LoggerFactory.getLogger(PatientServiceImpl.class);
	
	private PatientDAO dao;
	
	/**
	 * PatientIdentifierValidators registered through spring's applicationContext-service.xml
	 */
	private static Map<Class<? extends IdentifierValidator>, IdentifierValidator> identifierValidators = null;
	
	/**
	 * @see org.openmrs.api.PatientService#setPatientDAO(org.openmrs.api.db.PatientDAO)
	 */
	@Override
	public void setPatientDAO(PatientDAO dao) {
		this.dao = dao;
	}
	
	/**
	 * Clean up after this class. Set the static var to null so that the classloader can reclaim the
	 * space.
	 * 
	 * @see org.openmrs.api.impl.BaseOpenmrsService#onShutdown()
	 */
	@Override
	public void onShutdown() {
		setIdentifierValidators(null);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#savePatient(org.openmrs.Patient)
	 */
	@Override
	public Patient savePatient(Patient patient) throws APIException {
		requireAppropriatePatientModificationPrivilege(patient);
		if (!patient.getVoided() && patient.getIdentifiers().size() == 1) {
			patient.getPatientIdentifier().setPreferred(true);
		}
		if (!patient.getVoided()) {
			checkPatientIdentifiers(patient);
		}
		setPreferredPatientIdentifier(patient);
		setPreferredPatientName(patient);
		setPreferredPatientAddress(patient);
		return dao.savePatient(patient);
	}
	private void requireAppropriatePatientModificationPrivilege(Patient patient) {
		if (patient.getPatientId() == null) {
			Context.requirePrivilege(PrivilegeConstants.ADD_PATIENTS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_PATIENTS);
		}
		if (patient.getVoided()) {
			Context.requirePrivilege(PrivilegeConstants.DELETE_PATIENTS);
		}
	}
	private void setPreferredPatientIdentifier(Patient patient) {
		PatientIdentifier preferredIdentifier = null;
		PatientIdentifier possiblePreferredId = patient.getPatientIdentifier();
		if (possiblePreferredId != null && possiblePreferredId.getPreferred() && !possiblePreferredId.getVoided()) {
			preferredIdentifier = possiblePreferredId;
		}
		for (PatientIdentifier id : patient.getIdentifiers()) {
			if (preferredIdentifier == null && !id.getVoided()) {
				id.setPreferred(true);
				preferredIdentifier = id;
				continue;
			}
			if (!id.equals(preferredIdentifier)) {
				id.setPreferred(false);
			}
		}
	}
	private void setPreferredPatientName(Patient patient) {
		PersonName preferredName = null;
		PersonName possiblePreferredName = patient.getPersonName();
		if (possiblePreferredName != null && possiblePreferredName.getPreferred() && !possiblePreferredName.getVoided()) {
			preferredName = possiblePreferredName;
		}
		for (PersonName name : patient.getNames()) {
			if (preferredName == null && !name.getVoided()) {
				name.setPreferred(true);
				preferredName = name;
				continue;
			}
			if (!name.equals(preferredName)) {
				name.setPreferred(false);
			}
		}
	}
	
	private void setPreferredPatientAddress(Patient patient) {
		PersonAddress preferredAddress = null;
		PersonAddress possiblePreferredAddress = patient.getPersonAddress();
		if (possiblePreferredAddress != null && possiblePreferredAddress.getPreferred()
				&& !possiblePreferredAddress.getVoided()) {
			preferredAddress = possiblePreferredAddress;
		}
		for (PersonAddress address : patient.getAddresses()) {
			if (preferredAddress == null && !address.getVoided()) {
				address.setPreferred(true);
				preferredAddress = address;
				continue;
			}
			if (!address.equals(preferredAddress)) {
				address.setPreferred(false);
			}
		}
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getPatient(java.lang.Integer)
	 */
	@Override
	@Transactional(readOnly = true)
	public Patient getPatient(Integer patientId) throws APIException {
		return dao.getPatient(patientId);
	}
	
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientOrPromotePerson(Integer patientOrPersonId) {
		Person person = Context.getPersonService().getPerson(patientOrPersonId);
		if (person == null) {
			return null;
		}
		person = HibernateUtil.getRealObjectFromProxy(person);
		if (person instanceof Patient) {
			return (Patient)person;
		}
		else {
			return new Patient(person);
		}
	}
	/**
	 * @see org.openmrs.api.PatientService#getAllPatients()
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getAllPatients() throws APIException {
		return Context.getPatientService().getAllPatients(false);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getAllPatients(boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getAllPatients(boolean includeVoided) throws APIException {
		return dao.getAllPatients(includeVoided);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getPatients(java.lang.String, java.lang.String,
	 *      java.util.List, boolean)
	 */
	@Override
	// TODO - search for usage with non-empty list of patient identifier types
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String name, String identifier, List<PatientIdentifierType> identifierTypes,
	        boolean matchIdentifierExactly) throws APIException {
		
		return Context.getPatientService().getPatients(name, identifier, identifierTypes, matchIdentifierExactly, 0, null);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#checkPatientIdentifiers(org.openmrs.Patient)
	 */
	@Override
	@Transactional(readOnly = true)
	public void checkPatientIdentifiers(Patient patient) throws PatientIdentifierException {
		// check patient has at least one identifier
		if (!patient.getVoided() && patient.getActiveIdentifiers().isEmpty()) {
			throw new InsufficientIdentifiersException("At least one nonvoided Patient Identifier is required");
		}
		final List<PatientIdentifier> patientIdentifiers = new ArrayList<>(patient.getIdentifiers());
		final Set<String> uniqueIdentifiers = new HashSet<>();
		patientIdentifiers.stream()
			.filter(pi -> !pi.getVoided())
			.forEach(pi -> {
				try {
					PatientIdentifierValidator.validateIdentifier(pi);
				}
				catch (BlankIdentifierException bie) {
					patient.removeIdentifier(pi);
					throw bie;
				}
				// check this patient for duplicate identifiers+identifierType
				String compareString = pi.getIdentifier() + " id type #: " + pi.getIdentifierType().getPatientIdentifierTypeId();
				if(! uniqueIdentifiers.add(compareString)) {
					throw new DuplicateIdentifierException("This patient has two identical identifiers of type "
							+ compareString, pi);
				}
			});
		checkForMissingRequiredIdentifiers(patientIdentifiers);
	}
	private void checkForMissingRequiredIdentifiers(List<PatientIdentifier> patientIdentifiers) {
		final Set<PatientIdentifierType> patientIdentifierTypes =
				patientIdentifiers.stream()
						.map(PatientIdentifier::getIdentifierType)
						.collect(Collectors.toSet());
		final List<PatientIdentifierType> requiredTypes = this.getPatientIdentifierTypes(null, null, true, null);
		final Set<String> missingRequiredTypeNames =
				requiredTypes.stream()
						.filter(requiredType -> !patientIdentifierTypes.contains(requiredType))
						.map(BaseOpenmrsMetadata::getName)
						.collect(Collectors.toSet());
		if(! missingRequiredTypeNames.isEmpty()) {
			throw new MissingRequiredIdentifierException(
					"Patient is missing the following required identifier(s): " + String.join(", ", missingRequiredTypeNames));
		}
	}
	/**
	 * @see org.openmrs.api.PatientService#voidPatient(org.openmrs.Patient, java.lang.String)
	 */
	@Override
	public Patient voidPatient(Patient patient, String reason) throws APIException {
		if (patient == null) {
			return null;
		}
		
		// patient and patientidentifier attributes taken care of by the BaseVoidHandler
		//call the DAO layer directly to avoid any further AOP around save*
		return dao.savePatient(patient);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#unvoidPatient(org.openmrs.Patient)
	 */
	@Override
	public Patient unvoidPatient(Patient patient) throws APIException {
		if (patient == null) {
			return null;
		}
		
		// patient and patientidentifier attributes taken care of by the BaseUnvoidHandler
		
		return Context.getPatientService().savePatient(patient);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#purgePatient(org.openmrs.Patient)
	 */
	@Override
	public void purgePatient(Patient patient) throws APIException {
		dao.deletePatient(patient);
	}
	
	// patient identifier section
	
	/**
	 * @see org.openmrs.api.PatientService#getPatientIdentifiers(java.lang.String, java.util.List,
	 *      java.util.List, java.util.List, java.lang.Boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifier> getPatientIdentifiers(String identifier,
	        List<PatientIdentifierType> patientIdentifierTypes, List<Location> locations, List<Patient> patients,
	        Boolean isPreferred) throws APIException {
		
		if (patientIdentifierTypes == null) {
			patientIdentifierTypes = new ArrayList<>();
		}
		
		if (locations == null) {
			locations = new ArrayList<>();
		}
		
		if (patients == null) {
			patients = new ArrayList<>();
		}
		
		return dao.getPatientIdentifiers(identifier, patientIdentifierTypes, locations, patients, isPreferred);
	}
	// end patient identifier section
	
	// patient identifier _type_ section
	
	/**
	 * 
	 * @see org.openmrs.api.PatientService#savePatientIdentifierType(org.openmrs.PatientIdentifierType)
	 */
	@Override
	public PatientIdentifierType savePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		return dao.savePatientIdentifierType(patientIdentifierType);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getAllPatientIdentifierTypes()
	 */
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getAllPatientIdentifierTypes() throws APIException {
		return Context.getPatientService().getAllPatientIdentifierTypes(false);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getAllPatientIdentifierTypes(boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getAllPatientIdentifierTypes(boolean includeRetired) throws APIException {
		return dao.getAllPatientIdentifierTypes(includeRetired);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getPatientIdentifierTypes(java.lang.String,
	 *      java.lang.String, java.lang.Boolean, java.lang.Boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getPatientIdentifierTypes(String name, String format, Boolean required,
	        Boolean hasCheckDigit) throws APIException {
		List<PatientIdentifierType> patientIdentifierTypes = dao.getPatientIdentifierTypes(name, format, required, hasCheckDigit);
		if (patientIdentifierTypes == null) {
			return new ArrayList<>();
		}
		return patientIdentifierTypes;
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getPatientIdentifierType(java.lang.Integer)
	 */
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierType(Integer patientIdentifierTypeId) throws APIException {
		return dao.getPatientIdentifierType(patientIdentifierTypeId);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getPatientIdentifierTypeByName(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierTypeByName(String name) throws APIException {
		List<PatientIdentifierType> types = getPatientIdentifierTypes(name, null, null, null);
		
		if (!types.isEmpty()) {
			return types.get(0);
		}
		
		return null;
	}
	
	/**
	 * @see org.openmrs.api.PatientService#retirePatientIdentifierType(org.openmrs.PatientIdentifierType,
	 *      String)
	 */
	@Override
	public PatientIdentifierType retirePatientIdentifierType(PatientIdentifierType patientIdentifierType, String reason)
	        throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		if (reason == null || reason.length() < 1) {
			throw new APIException("Patient.identifier.retire.reason", (Object[]) null);
		}
		
		patientIdentifierType.setRetired(true);
		patientIdentifierType.setRetiredBy(Context.getAuthenticatedUser());
		patientIdentifierType.setDateRetired(new Date());
		patientIdentifierType.setRetireReason(reason);
		return Context.getPatientService().savePatientIdentifierType(patientIdentifierType);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#unretirePatientIdentifierType(org.openmrs.PatientIdentifierType)
	 */
	@Override
	public PatientIdentifierType unretirePatientIdentifierType(PatientIdentifierType patientIdentifierType)
	        throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		patientIdentifierType.setRetired(false);
		patientIdentifierType.setRetiredBy(null);
		patientIdentifierType.setDateRetired(null);
		patientIdentifierType.setRetireReason(null);
		return Context.getPatientService().savePatientIdentifierType(patientIdentifierType);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#purgePatientIdentifierType(org.openmrs.PatientIdentifierType)
	 */
	@Override
	public void purgePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		dao.deletePatientIdentifierType(patientIdentifierType);
	}
	
	// end patient identifier _type_ section
	
	/**
	 * @see org.openmrs.api.PatientService#getPatients(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query) throws APIException {
		return Context.getPatientService().getPatients(query, 0, null);
	}
	
	/**
	 * This default implementation simply looks at the OpenMRS internal id (patient_id). If the id
	 * is null, assume this patient isn't found. If the patient_id is not null, try and find that id
	 * in the database
	 * 
	 * @see org.openmrs.api.PatientService#getPatientByExample(org.openmrs.Patient)
	 */
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientByExample(Patient patientToMatch) throws APIException {
		if (patientToMatch == null || patientToMatch.getPatientId() == null) {
			return null;
		}
		
		return Context.getPatientService().getPatient(patientToMatch.getPatientId());
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getDuplicatePatientsByAttributes(java.util.List)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getDuplicatePatientsByAttributes(List<String> attributes) throws APIException {
		
		if (attributes == null || attributes.isEmpty()) {
			throw new APIException("Patient.no.attribute", (Object[]) null);
		}
		
		return dao.getDuplicatePatientsByAttributes(attributes);
	}
	
	/**
	 * generate a relationship hash for use in mergePatients; follows the convention:
	 * [relationshipType][A|B][relativeId]
	 * 
	 * @param rel relationship under consideration
	 * @param primary the focus of the hash
	 * @return hash depicting relevant information to avoid duplicates
	 */
	private String relationshipHash(Relationship rel, Person primary) {
		boolean isA = rel.getPersonA().equals(primary);
		return rel.getRelationshipType().getRelationshipTypeId().toString() + (isA ? "A" : "B")
		        + (isA ? rel.getPersonB().getPersonId().toString() : rel.getPersonA().getPersonId().toString());
	}
	/**
	 * 1) Moves object (encounters/obs) pointing to <code>nonPreferred</code> to
	 * <code>preferred</code> 2) Copies data (gender/birthdate/names/ids/etc) from
	 * <code>nonPreferred</code> to <code>preferred</code> iff the data is missing or null in
	 * <code>preferred</code> 3) <code>notPreferred</code> is marked as voided
	 * 
	 * @param preferred
	 * @param notPreferred
	 * @throws APIException
	 * @see org.openmrs.api.PatientService#mergePatients(org.openmrs.Patient, org.openmrs.Patient)
	 */
	@Override
	public void mergePatients(Patient preferred, Patient notPreferred) throws APIException, SerializationException {
		log.debug("Merging patients: (preferred)" + preferred.getPatientId() + ", (notPreferred) "
		        + notPreferred.getPatientId());
		if (preferred.getPatientId().equals(notPreferred.getPatientId())) {
			log.debug("Merge operation cancelled: Cannot merge user" + preferred.getPatientId() + " to self");
			throw new APIException("Patient.merge.cancelled", new Object[] { preferred.getPatientId() });
		}
		requireNoActiveOrderOfSameType(preferred,notPreferred);
		PersonMergeLogData mergedData = new PersonMergeLogData();
		mergeVisits(preferred, notPreferred, mergedData);
		mergeEncounters(preferred, notPreferred, mergedData);
		mergeProgramEnrolments(preferred, notPreferred, mergedData);
		mergeRelationships(preferred, notPreferred, mergedData);
		mergeObservationsNotContainedInEncounters(preferred, notPreferred, mergedData);
		mergeIdentifiers(preferred, notPreferred, mergedData);
		
		mergeNames(preferred, notPreferred, mergedData);
		mergeAddresses(preferred, notPreferred, mergedData);
		mergePersonAttributes(preferred, notPreferred, mergedData);
		mergeGenderInformation(preferred, notPreferred, mergedData);
		mergeDateOfBirth(preferred, notPreferred, mergedData);
		mergeDateOfDeath(preferred, notPreferred, mergedData);
		
		// void the non preferred patient
		Context.getPatientService().voidPatient(notPreferred, "Merged with patient #" + preferred.getPatientId());
		
		// void the person associated with not preferred patient
		Context.getPersonService().voidPerson(notPreferred,
		    "The patient corresponding to this person has been voided and Merged with patient #" + preferred.getPatientId());
		
		// associate the Users associated with the not preferred person, to the preferred person.
		changeUserAssociations(preferred, notPreferred, mergedData);
		
		// Save the newly update preferred patient
		// This must be called _after_ voiding the nonPreferred patient so that
		//  a "Duplicate Identifier" error doesn't pop up.
		savePatient(preferred);
		
		//save the person merge log
		PersonMergeLog personMergeLog = new PersonMergeLog();
		personMergeLog.setWinner(preferred);
		personMergeLog.setLoser(notPreferred);
		personMergeLog.setPersonMergeLogData(mergedData);
		Context.getPersonService().savePersonMergeLog(personMergeLog);
	}
	
	private void requireNoActiveOrderOfSameType(Patient patient1, Patient patient2) {
		String messageKey = "Patient.merge.cannotHaveSameTypeActiveOrders";
		List<Order> ordersByPatient1 = Context.getOrderService().getAllOrdersByPatient(patient1);
		List<Order> ordersByPatient2 = Context.getOrderService().getAllOrdersByPatient(patient2);
		ordersByPatient1.forEach((Order order1) -> ordersByPatient2.forEach((Order order2) -> {
			if (order1.isActive() && order2.isActive() && order1.getOrderType().equals(order2.getOrderType())) {
				Object[] parameters = { patient1.getPatientId(), patient2.getPatientId(), order1.getOrderType() };
				String message = Context.getMessageSourceService().getMessage(messageKey, parameters,
						Context.getLocale());
				log.debug(message);
				throw new APIException(message);
			}
		}));
	}
	private void mergeProgramEnrolments(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		// copy all program enrollments
		ProgramWorkflowService programService = Context.getProgramWorkflowService();
		for (PatientProgram pp : programService.getPatientPrograms(notPreferred, null, null, null, null, null, false)) {
			if (!pp.getVoided()) {
				pp.setPatient(preferred);
				log.debug("Moving patientProgram {} to {}", pp.getPatientProgramId(), preferred.getPatientId());
				PatientProgram persisted = programService.savePatientProgram(pp);
				mergedData.addMovedProgram(persisted.getUuid());
			}
		}
	}
	
	private void mergeVisits(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		// move all visits, including voided ones (encounters will be handled below)
		//TODO: this should be a copy, not a move
		
		VisitService visitService = Context.getVisitService();
		
		for (Visit visit : visitService.getVisitsByPatient(notPreferred, true, true)) {
			log.debug("Merging visit {} to {}", visit.getVisitId(), preferred.getPatientId());
			visit.setPatient(preferred);
			Visit persisted = visitService.saveVisit(visit);
			mergedData.addMovedVisit(persisted.getUuid());
		}
	}
	
	private void mergeEncounters(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		// change all encounters. This will cascade to obs and orders contained in those encounters
		// TODO: this should be a copy, not a move
		EncounterService es = Context.getEncounterService();
		EncounterSearchCriteria notPreferredPatientEncounterSearchCriteria = new EncounterSearchCriteriaBuilder()
				.setIncludeVoided(true)
				.setPatient(notPreferred)
				.createEncounterSearchCriteria();
		for (Encounter e : es.getEncounters(notPreferredPatientEncounterSearchCriteria)) {
			e.setPatient(preferred);
			log.debug("Merging encounter " + e.getEncounterId() + " to " + preferred.getPatientId());
			Encounter persisted = es.saveEncounter(e);
			mergedData.addMovedEncounter(persisted.getUuid());
		}
	}
	
	private void mergeRelationships(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		// copy all relationships
		PersonService personService = Context.getPersonService();
		Set<String> existingRelationships = new HashSet<>();
		// fill in the existing relationships with hashes
		for (Relationship rel : personService.getRelationshipsByPerson(preferred)) {
			existingRelationships.add(relationshipHash(rel, preferred));
		}
		// iterate over notPreferred's relationships and only copy them if they are needed
		for (Relationship rel : personService.getRelationshipsByPerson(notPreferred)) {
			if (!rel.getVoided()) {
				boolean personAisPreferred = rel.getPersonA().equals(preferred);
				boolean personAisNotPreferred = rel.getPersonA().equals(notPreferred);
				boolean personBisPreferred = rel.getPersonB().equals(preferred);
				boolean personBisNotPreferred = rel.getPersonB().equals(notPreferred);
				String relHash = relationshipHash(rel, notPreferred);
				
				if ((personAisPreferred && personBisNotPreferred) || (personBisPreferred && personAisNotPreferred)) {
					// void this relationship if it's between the preferred and notPreferred patients
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged to person " + (personAisPreferred ? "A" : "B"));
				} else if (existingRelationships.contains(relHash)) {
					// void this relationship if it already exists between preferred and the other side
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged and a relationship already exists");
				} else {
					// copy this relationship and replace notPreferred with preferred
					Relationship tmpRel = rel.copy();
					if (personAisNotPreferred) {
						tmpRel.setPersonA(preferred);
					}
					if (personBisNotPreferred) {
						tmpRel.setPersonB(preferred);
					}
					log.debug("Copying relationship " + rel.getRelationshipId() + " to " + preferred.getPatientId());
					Relationship persisted = personService.saveRelationship(tmpRel);
					mergedData.addCreatedRelationship(persisted.getUuid());
					// void the existing relationship to the notPreferred
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged, relationship copied to #" + tmpRel.getRelationshipId());
					// add the relationship hash to existing relationships
					existingRelationships.add(relHash);
				}
				mergedData.addVoidedRelationship(rel.getUuid());
			}
		}
	}
	
	private void mergeObservationsNotContainedInEncounters(Patient preferred, Patient notPreferred,
	        PersonMergeLogData mergedData) {
		// move all obs that weren't contained in encounters
		// TODO: this should be a copy, not a move
		ObsService obsService = Context.getObsService();
		for (Obs obs : obsService.getObservationsByPerson(notPreferred)) {
			if (obs.getEncounter() == null && !obs.getVoided()) {
				obs.setPerson(preferred);
				Obs persisted = obsService.saveObs(obs, "Merged from patient #" + notPreferred.getPatientId());
				mergedData.addMovedIndependentObservation(persisted.getUuid());
			}
		}
	}
	
	private void mergeIdentifiers(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		// move all identifiers
		// (must be done after all calls to services above so hbm doesn't try to save things prematurely (hacky)
		for (PatientIdentifier pi : notPreferred.getActiveIdentifiers()) {
			PatientIdentifier tmpIdentifier = new PatientIdentifier();
			tmpIdentifier.setIdentifier(pi.getIdentifier());
			tmpIdentifier.setIdentifierType(pi.getIdentifierType());
			tmpIdentifier.setLocation(pi.getLocation());
			tmpIdentifier.setPatient(preferred);
			boolean found = false;
			for (PatientIdentifier preferredIdentifier : preferred.getIdentifiers()) {
				if (preferredIdentifier.getIdentifier() != null
				        && preferredIdentifier.getIdentifier().equals(tmpIdentifier.getIdentifier())
				        && preferredIdentifier.getIdentifierType() != null
				        && preferredIdentifier.getIdentifierType().equals(tmpIdentifier.getIdentifierType())) {
					found = true;
				}
			}
			if (!found) {
				tmpIdentifier.setIdentifierType(pi.getIdentifierType());
				tmpIdentifier.setCreator(Context.getAuthenticatedUser());
				tmpIdentifier.setDateCreated(new Date());
				tmpIdentifier.setVoided(false);
				tmpIdentifier.setVoidedBy(null);
				tmpIdentifier.setVoidReason(null);
				tmpIdentifier.setUuid(UUID.randomUUID().toString());
				// we don't want to change the preferred identifier of the preferred patient
				tmpIdentifier.setPreferred(false);
				preferred.addIdentifier(tmpIdentifier);
				mergedData.addCreatedIdentifier(tmpIdentifier.getUuid());
				log.debug("Merging identifier " + tmpIdentifier.getIdentifier() + " to " + preferred.getPatientId());
			}
		}
	}
	
	private void mergeDateOfDeath(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorDateOfDeath(preferred.getDeathDate());
		if (preferred.getDeathDate() == null) {
			preferred.setDeathDate(notPreferred.getDeathDate());
		}
		
		if (preferred.getCauseOfDeath() != null) {
			mergedData.setPriorCauseOfDeath(preferred.getCauseOfDeath().getUuid());
		}
		if (preferred.getCauseOfDeath() == null) {
			preferred.setCauseOfDeath(notPreferred.getCauseOfDeath());
		}
	}
	
	private void mergeDateOfBirth(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorDateOfBirth(preferred.getBirthdate());
		mergedData.setPriorDateOfBirthEstimated(preferred.getBirthdateEstimated());
		if (preferred.getBirthdate() == null || (preferred.getBirthdateEstimated() && !notPreferred.getBirthdateEstimated())) {
			preferred.setBirthdate(notPreferred.getBirthdate());
			preferred.setBirthdateEstimated(notPreferred.getBirthdateEstimated());
		}
	}
	
	private void mergePersonAttributes(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		// copy person attributes
		for (PersonAttribute attr : notPreferred.getAttributes()) {
			if (!attr.getVoided()) {
				PersonAttribute tmpAttr = attr.copy();
				tmpAttr.setPerson(null);
				tmpAttr.setUuid(UUID.randomUUID().toString());
				preferred.addAttribute(tmpAttr);
				mergedData.addCreatedAttribute(tmpAttr.getUuid());
			}
		}
	}
	
	private void mergeGenderInformation(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		// move all other patient info
		mergedData.setPriorGender(preferred.getGender());
		if (!"M".equals(preferred.getGender()) && !"F".equals(preferred.getGender())) {
			preferred.setGender(notPreferred.getGender());
		}
	}
	
	private void mergeNames(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		// move all names
		// (must be done after all calls to services above so hbm doesn't try to save things prematurely (hacky)
		for (PersonName newName : notPreferred.getNames()) {
			boolean containsName = false;
			for (PersonName currentName : preferred.getNames()) {
				containsName = currentName.equalsContent(newName);
				if (containsName) {
					break;
				}
			}
			if (!containsName) {
				PersonName tmpName = constructTemporaryName(newName);
				preferred.addName(tmpName);
				mergedData.addCreatedName(tmpName.getUuid());
				log.debug("Merging name " + newName.getGivenName() + " to " + preferred.getPatientId());
			}
		}
	}
	
	private PersonName constructTemporaryName(PersonName newName) {
		PersonName tmpName = PersonName.newInstance(newName);
		tmpName.setPersonNameId(null);
		tmpName.setVoided(false);
		tmpName.setVoidedBy(null);
		tmpName.setVoidReason(null);
		// we don't want to change the preferred name of the preferred patient
		tmpName.setPreferred(false);
		tmpName.setUuid(UUID.randomUUID().toString());
		return tmpName;
	}
	
	private void mergeAddresses(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData)
	        throws SerializationException {
		// move all addresses
		// (must be done after all calls to services above so hbm doesn't try to save things prematurely (hacky)
		for (PersonAddress newAddress : notPreferred.getAddresses()) {
			boolean containsAddress = false;
			for (PersonAddress currentAddress : preferred.getAddresses()) {
				containsAddress = currentAddress.equalsContent(newAddress);
				if (containsAddress) {
					break;
				}
			}
			if (!containsAddress) {
				PersonAddress tmpAddress = (PersonAddress) newAddress.clone();
				tmpAddress.setPersonAddressId(null);
				tmpAddress.setVoided(false);
				tmpAddress.setVoidedBy(null);
				tmpAddress.setVoidReason(null);
				tmpAddress.setPreferred(false); // addresses from non-preferred patient shouldn't be marked as preferred
				tmpAddress.setUuid(UUID.randomUUID().toString());
				preferred.addAddress(tmpAddress);
				mergedData.addCreatedAddress(tmpAddress.getUuid());
				log.debug("Merging address " + newAddress.getPersonAddressId() + " to " + preferred.getPatientId());
			}
		}
		
		// copy person attributes
		for (PersonAttribute attr : notPreferred.getAttributes()) {
			if (!attr.getVoided()) {
				PersonAttribute tmpAttr = attr.copy();
				tmpAttr.setPerson(null);
				tmpAttr.setUuid(UUID.randomUUID().toString());
				preferred.addAttribute(tmpAttr);
				mergedData.addCreatedAttribute(tmpAttr.getUuid());
			}
		}
		
		// move all other patient info
		mergedData.setPriorGender(preferred.getGender());
		if (!"M".equals(preferred.getGender()) && !"F".equals(preferred.getGender())) {
			preferred.setGender(notPreferred.getGender());
		}
		mergedData.setPriorDateOfBirth(preferred.getBirthdate());
		mergedData.setPriorDateOfBirthEstimated(preferred.getBirthdateEstimated());
		if (preferred.getBirthdate() == null || (preferred.getBirthdateEstimated() && !notPreferred.getBirthdateEstimated())) {
			preferred.setBirthdate(notPreferred.getBirthdate());
			preferred.setBirthdateEstimated(notPreferred.getBirthdateEstimated());
		}
		mergedData.setPriorDateOfDeathEstimated(preferred.getDeathdateEstimated());
		if (preferred.getDeathdateEstimated() == null) {
			preferred.setDeathdateEstimated(notPreferred.getDeathdateEstimated());
		}
		
		mergedData.setPriorDateOfDeath(preferred.getDeathDate());
		if (preferred.getDeathDate() == null) {
			preferred.setDeathDate(notPreferred.getDeathDate());
		}
		
		if (preferred.getCauseOfDeath() != null) {
			mergedData.setPriorCauseOfDeath(preferred.getCauseOfDeath().getUuid());
		}
		if (preferred.getCauseOfDeath() == null) {
			preferred.setCauseOfDeath(notPreferred.getCauseOfDeath());
		}
		
		// void the non preferred patient
		Context.getPatientService().voidPatient(notPreferred, "Merged with patient #" + preferred.getPatientId());
		
		// void the person associated with not preferred patient
		Context.getPersonService().voidPerson(notPreferred,
		    "The patient corresponding to this person has been voided and Merged with patient #" + preferred.getPatientId());
		
		// associate the Users associated with the not preferred person, to the preferred person.
		changeUserAssociations(preferred, notPreferred, mergedData);
		
		// Save the newly update preferred patient
		// This must be called _after_ voiding the nonPreferred patient so that
		//  a "Duplicate Identifier" error doesn't pop up.
		savePatient(preferred);
		
		//save the person merge log
		PersonMergeLog personMergeLog = new PersonMergeLog();
		personMergeLog.setWinner(preferred);
		personMergeLog.setLoser(notPreferred);
		personMergeLog.setPersonMergeLogData(mergedData);
		Context.getPersonService().savePersonMergeLog(personMergeLog);
	}
	
	/**
	 * Change user associations for notPreferred to preferred person.
	 * 
	 * @param preferred
	 * @param notPreferred
	 * @param mergedData a patient merge audit data object to update
	 * @see PatientServiceImpl#mergePatients(Patient, Patient)
	 */
	private void changeUserAssociations(Patient preferred, Person notPreferred, PersonMergeLogData mergedData) {
		UserService userService = Context.getUserService();
		List<User> users = userService.getUsersByPerson(notPreferred, true);
		for (User user : users) {
			user.setPerson(preferred);
			User persisted = userService.saveUser(user);
			if (mergedData != null) {
				mergedData.addMovedUser(persisted.getUuid());
			}
		}
	}
	
	/**
	 * This is the way to establish that a patient has left the care center. This API call is
	 * responsible for:
	 * <ol>
	 * <li>Closing workflow statuses</li>
	 * <li>Terminating programs</li>
	 * <li>Discontinuing orders</li>
	 * <li>Flagging patient table</li>
	 * <li>Creating any relevant observations about the patient (if applicable)</li>
	 * </ol>
	 * 
	 * @param patient - the patient who has exited care
	 * @param dateExited - the declared date/time of the patient's exit
	 * @param reasonForExit - the concept that corresponds with why the patient has been declared as
	 *            exited
	 * @throws APIException
	 */
	public void exitFromCare(Patient patient, Date dateExited, Concept reasonForExit) throws APIException {
		
		if (patient == null) {
			throw new APIException("Patient.invalid.care", (Object[]) null);
		}
		if (dateExited == null) {
			throw new APIException("Patient.no.valid.dateExited", (Object[]) null);
		}
		if (reasonForExit == null) {
			throw new APIException("Patient.no.valid.reasonForExit", (Object[]) null);
		}
		
		// need to create an observation to represent this (otherwise how
		// will we know?)
		saveReasonForExitObs(patient, dateExited, reasonForExit);
	}
	
	/**
	 * TODO: Patients should actually be allowed to exit multiple times
	 * 
	 * @param patient
	 * @param exitDate
	 * @param cause
	 */
	private void saveReasonForExitObs(Patient patient, Date exitDate, Concept cause) throws APIException {
		
		if (patient == null) {
			throw new APIException("Patient.null", (Object[]) null);
		}
		if (exitDate == null) {
			throw new APIException("Patient.exit.date.null", (Object[]) null);
		}
		if (cause == null) {
			throw new APIException("Patient.cause.null", (Object[]) null);
		}
		
		// need to make sure there is an Obs that represents the patient's
		// exit
		log.debug("Patient is exiting, so let's make sure there's an Obs for it");
		
		String codProp = Context.getAdministrationService().getGlobalProperty("concept.reasonExitedCare");
		Concept reasonForExit = Context.getConceptService().getConcept(codProp);
		
		if (reasonForExit != null) {
			List<Obs> obssExit = Context.getObsService().getObservationsByPersonAndConcept(patient, reasonForExit);
			if (obssExit != null) {
				if (obssExit.size() > 1) {
					log.error("Multiple reasons for exit (" + obssExit.size() + ")?  Shouldn't be...");
				} else {
					Obs obsExit;
					if (obssExit.size() == 1) {
						// already has a reason for exit - let's edit it.
						log.debug("Already has a reason for exit, so changing it");
						
						obsExit = obssExit.iterator().next();
						
					} else {
						// no reason for exit obs yet, so let's make one
						log.debug("No reason for exit yet, let's create one.");
						
						obsExit = new Obs();
						obsExit.setPerson(patient);
						obsExit.setConcept(reasonForExit);
						
						Location loc = Context.getLocationService().getDefaultLocation();
						
						if (loc != null) {
							obsExit.setLocation(loc);
						} else {
							log.error("Could not find a suitable location for which to create this new Obs");
						}
					}
					
					if (obsExit != null) {
						// put the right concept and (maybe) text in this
						// obs
						obsExit.setValueCoded(cause);
						obsExit.setValueCodedName(cause.getName()); // ABKTODO: presume current locale?
						obsExit.setObsDatetime(exitDate);
						Context.getObsService().saveObs(obsExit, "updated by PatientService.saveReasonForExit");
					}
				}
			}
		} else {
			log.debug("Reason for exit is null - should not have gotten here without throwing an error on the form.");
		}
		
	}
	
	/**
	 * This is the way to establish that a patient has died. In addition to exiting the patient from
	 * care (see above), this method will also set the appropriate patient characteristics to
	 * indicate that they have died, when they died, etc.
	 * 
	 * @param patient - the patient who has died
	 * @param dateDied - the declared date/time of the patient's death
	 * @param causeOfDeath - the concept that corresponds with the reason the patient died
	 * @param otherReason - in case the causeOfDeath is 'other', a place to store more info
	 * @throws APIException
	 */
	@Override
	public void processDeath(Patient patient, Date dateDied, Concept causeOfDeath, String otherReason) throws APIException {
		
		if (patient != null && dateDied != null && causeOfDeath != null) {
			// set appropriate patient characteristics
			patient.setDead(true);
			patient.setDeathDate(dateDied);
			patient.setCauseOfDeath(causeOfDeath);
			this.savePatient(patient);
			saveCauseOfDeathObs(patient, dateDied, causeOfDeath, otherReason);
			
			// exit from program
			// first, need to get Concept for "Patient Died"
			String strPatientDied = Context.getAdministrationService().getGlobalProperty("concept.patientDied");
			Concept conceptPatientDied = Context.getConceptService().getConcept(strPatientDied);
			
			if (conceptPatientDied == null) {
				log.debug("ConceptPatientDied is null");
			}
			exitFromCare(patient, dateDied, conceptPatientDied);
			
		} else {
			if (patient == null) {
				throw new APIException("Patient.invalid.dead", (Object[]) null);
			}
			if (dateDied == null) {
				throw new APIException("Patient.no.valid.dateDied", (Object[]) null);
			}
			if (causeOfDeath == null) {
				throw new APIException("Patient.no.valid.causeOfDeath", (Object[]) null);
			}
		}
	}
	
	/**
	 * @see org.openmrs.api.PatientService#saveCauseOfDeathObs(org.openmrs.Patient, java.util.Date,
	 *      org.openmrs.Concept, java.lang.String)
	 */
	@Override
	public void saveCauseOfDeathObs(Patient patient, Date deathDate, Concept cause, String otherReason) throws APIException {
		
		if (patient == null) {
			throw new APIException("Patient.null", (Object[]) null);
		}
		if (deathDate == null) {
			throw new APIException("Patient.death.date.null", (Object[]) null);
		}
		if (cause == null) {
			throw new APIException("Patient.cause.null", (Object[]) null);
		}
		
		if (!patient.getDead()) {
			patient.setDead(true);
			patient.setDeathDate(deathDate);
			patient.setCauseOfDeath(cause);
		}
		
		log.debug("Patient is dead, so let's make sure there's an Obs for it");
		// need to make sure there is an Obs that represents the patient's
		// cause of death, if applicable
		
		String codProp = Context.getAdministrationService().getGlobalProperty("concept.causeOfDeath");
		
		Concept causeOfDeath = Context.getConceptService().getConcept(codProp);
		
		if (causeOfDeath != null) {
			List<Obs> obssDeath = Context.getObsService().getObservationsByPersonAndConcept(patient, causeOfDeath);
			if (obssDeath != null) {
				if (obssDeath.size() > 1) {
					log.error("Multiple causes of death (" + obssDeath.size() + ")?  Shouldn't be...");
				} else {
					Obs obsDeath;
					if (obssDeath.size() == 1) {
						// already has a cause of death - let's edit it.
						log.debug("Already has a cause of death, so changing it");
						
						obsDeath = obssDeath.iterator().next();
						
					} else {
						// no cause of death obs yet, so let's make one
						log.debug("No cause of death yet, let's create one.");
						
						obsDeath = new Obs();
						obsDeath.setPerson(patient);
						obsDeath.setConcept(causeOfDeath);
						Location location = Context.getLocationService().getDefaultLocation();
						if (location != null) {
							obsDeath.setLocation(location);
						} else {
							log.error("Could not find a suitable location for which to create this new Obs");
						}
					}
					
					// put the right concept and (maybe) text in this obs
					Concept currCause = patient.getCauseOfDeath();
					if (currCause == null) {
						// set to NONE
						log.debug("Current cause is null, attempting to set to NONE");
						String noneConcept = Context.getAdministrationService().getGlobalProperty("concept.none");
						currCause = Context.getConceptService().getConcept(noneConcept);
					}
					
					if (currCause != null) {
						log.debug("Current cause is not null, setting to value_coded");
						obsDeath.setValueCoded(currCause);
						obsDeath.setValueCodedName(currCause.getName()); // ABKTODO: presume current locale?
						
						Date dateDeath = patient.getDeathDate();
						if (dateDeath == null) {
							dateDeath = new Date();
						}
						obsDeath.setObsDatetime(dateDeath);
						
						// check if this is an "other" concept - if so, then
						// we need to add value_text
						String otherConcept = Context.getAdministrationService().getGlobalProperty("concept.otherNonCoded");
						Concept conceptOther = Context.getConceptService().getConcept(otherConcept);
						if (conceptOther != null) {
							if (conceptOther.equals(currCause)) {
								// seems like this is an other concept -
								// let's try to get the "other" field info
								log.debug("Setting value_text as " + otherReason);
								obsDeath.setValueText(otherReason);
							} else {
								log.debug("New concept is NOT the OTHER concept, so setting to blank");
								obsDeath.setValueText("");
							}
						} else {
							log.debug("Don't seem to know about an OTHER concept, so deleting value_text");
							obsDeath.setValueText("");
						}
						
						Context.getObsService().saveObs(obsDeath, "updated by PatientService.saveCauseOfDeathObs");
					} else {
						log.debug("Current cause is still null - aborting mission");
					}
				}
			}
		} else {
			log.debug("Cause of death is null - should not have gotten here without throwing an error on the form.");
		}
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getPatientByUuid(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientByUuid(String uuid) throws APIException {
		return dao.getPatientByUuid(uuid);
	}
	
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifier getPatientIdentifierByUuid(String uuid) throws APIException {
		return dao.getPatientIdentifierByUuid(uuid);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getPatientIdentifierTypeByUuid(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierTypeByUuid(String uuid) throws APIException {
		return dao.getPatientIdentifierTypeByUuid(uuid);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getDefaultIdentifierValidator()
	 */
	@Override
	@Transactional(readOnly = true)
	public IdentifierValidator getDefaultIdentifierValidator() {
		String defaultPIV = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR, "");
		
		try {
			return identifierValidators.get(Class.forName(defaultPIV));
		}
		catch (ClassNotFoundException e) {
			log.error("Global Property " + OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR
			        + " not set to an actual class.", e);
			return identifierValidators.get(LuhnIdentifierValidator.class);
		}
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getIdentifierValidator(java.lang.String)
	 */
	@Override
	public IdentifierValidator getIdentifierValidator(Class<IdentifierValidator> identifierValidator) {
		return identifierValidators.get(identifierValidator);
	}
	
	public Map<Class<? extends IdentifierValidator>, IdentifierValidator> getIdentifierValidators() {
		if (identifierValidators == null) {
			identifierValidators = new LinkedHashMap<>();
		}
		return identifierValidators;
	}
	
	/**
	 * ADDs identifierValidators, doesn't replace them
	 * 
	 * @param identifierValidators
	 */
	public void setIdentifierValidators(Map<Class<? extends IdentifierValidator>, IdentifierValidator> identifierValidators) {
		if (identifierValidators == null) {
			PatientServiceImpl.setStaticIdentifierValidators(null);
			return;
		}
		for (Map.Entry<Class<? extends IdentifierValidator>, IdentifierValidator> entry : identifierValidators.entrySet()) {
			getIdentifierValidators().put(entry.getKey(), entry.getValue());
		}
	}
	
	/**
	 * Sets identifierValidators using static method
	 *
	 * @param currentIdentifierValidators
	 */
	private static void setStaticIdentifierValidators(
	        Map<Class<? extends IdentifierValidator>, IdentifierValidator> currentIdentifierValidators) {
		PatientServiceImpl.identifierValidators = currentIdentifierValidators;
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getAllIdentifierValidators()
	 */
	@Override
	public Collection<IdentifierValidator> getAllIdentifierValidators() {
		return identifierValidators.values();
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getIdentifierValidator(java.lang.String)
	 */
	@Override
	@SuppressWarnings("unchecked")
	@Transactional(readOnly = true)
	public IdentifierValidator getIdentifierValidator(String pivClassName) {
		if (StringUtils.isBlank(pivClassName)) {
			return null;
		}
		
		try {
			return getIdentifierValidator((Class<IdentifierValidator>) Context.loadClass(pivClassName));
		}
		catch (ClassNotFoundException e) {
			throw new PatientIdentifierException("Could not find patient identifier validator " + pivClassName, e);
		}
	}
	
	/**
	 * @see org.openmrs.api.PatientService#isIdentifierInUseByAnotherPatient(org.openmrs.PatientIdentifier)
	 */
	@Override
	@Transactional(readOnly = true)
	public boolean isIdentifierInUseByAnotherPatient(PatientIdentifier patientIdentifier) {
		return dao.isIdentifierInUseByAnotherPatient(patientIdentifier);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getPatientIdentifier(java.lang.Integer)
	 */
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifier getPatientIdentifier(Integer patientIdentifierId) throws APIException {
		return dao.getPatientIdentifier(patientIdentifierId);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#voidPatientIdentifier(org.openmrs.PatientIdentifier,
	 *      java.lang.String)
	 */
	@Override
	public PatientIdentifier voidPatientIdentifier(PatientIdentifier patientIdentifier, String reason) throws APIException {
		
		if (patientIdentifier == null || StringUtils.isBlank(reason)) {
			throw new APIException("Patient.identifier.cannot.be.null", (Object[]) null);
		}
		return Context.getPatientService().savePatientIdentifier(patientIdentifier);
		
	}
	
	/**
	 * @see org.openmrs.api.PatientService#mergePatients(org.openmrs.Patient, java.util.List)
	 */
	@Override
	public void mergePatients(Patient preferred, List<Patient> notPreferred) throws APIException, SerializationException {
		
		for (Patient nonPreferred : notPreferred) {
			mergePatients(preferred, nonPreferred);
		}
	}
	
	/**
	 * @see org.openmrs.api.PatientService#savePatientIdentifier(org.openmrs.PatientIdentifier)
	 */
	@Override
	public PatientIdentifier savePatientIdentifier(PatientIdentifier patientIdentifier) throws APIException {
		//if the argument or the following required fields are not specified
		PatientIdentifierType.LocationBehavior locationBehavior = null;
		if (patientIdentifier != null) {
			locationBehavior = patientIdentifier.getIdentifierType().getLocationBehavior();
		}
		
		if (patientIdentifier == null
		        || patientIdentifier.getPatient() == null
		        || patientIdentifier.getIdentifierType() == null
		        || StringUtils.isBlank(patientIdentifier.getIdentifier())
		        || (locationBehavior == PatientIdentifierType.LocationBehavior.REQUIRED && patientIdentifier.getLocation() == null)) {
			throw new APIException("Patient.identifier.null", (Object[]) null);
		}
		if (patientIdentifier.getPatientIdentifierId() == null) {
			Context.requirePrivilege(PrivilegeConstants.ADD_PATIENT_IDENTIFIERS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_PATIENT_IDENTIFIERS);
		}
		
		return dao.savePatientIdentifier(patientIdentifier);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#purgePatientIdentifier(org.openmrs.PatientIdentifier)
	 */
	@Override
	public void purgePatientIdentifier(PatientIdentifier patientIdentifier) throws APIException {
		
		dao.deletePatientIdentifier(patientIdentifier);
		
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getAllergies(org.openmrs.Patient)
	 */
	@Override
	@Transactional(readOnly = true)
	public Allergies getAllergies(Patient patient) {
		if (patient == null) {
			throw new IllegalArgumentException("An existing (NOT NULL) patient is required to get allergies");
		}
		
		Allergies allergies = new Allergies();
		List<Allergy> allergyList = dao.getAllergies(patient);
		if (!allergyList.isEmpty()) {
			allergies.addAll(allergyList);
		} else {
			String status = dao.getAllergyStatus(patient);
			if (Allergies.NO_KNOWN_ALLERGIES.equals(status)) {
				allergies.confirmNoKnownAllergies();
			}
		}
		return allergies;
	}
	
	/**
	 * @see org.openmrs.api.PatientService#setAllergies(org.openmrs.Patient,
	 *      org.openmrs.Allergies)
	 */
	@Override
	public Allergies setAllergies(Patient patient, Allergies allergies) {
		//NOTE We neither delete nor edit allergies. We instead void them.
		//Because we shield the API users from this business logic,
		//we end up with the complicated code below. :)
		
		//get the current allergies as stored in the database
		List<Allergy> dbAllergyList = getAllergies(patient);
		for (Allergy originalAllergy : dbAllergyList) {
			//check if we still have each allergy, else it has just been deleted
			if (allergies.contains(originalAllergy)) {
				//we still have this allergy, check if it has been edited/changed
				Allergy potentiallyEditedAllergy = allergies.getAllergy(originalAllergy.getAllergyId());
				if (!potentiallyEditedAllergy.hasSameValues(originalAllergy)) {
					//allergy has been edited, so void it and create a new one with the current values
					Allergy newAllergy = new Allergy();
					try {
						//remove the edited allergy from our current list, and void id
						allergies.remove(potentiallyEditedAllergy);
						
						//copy values from edited allergy, and add it to the current list
						newAllergy.copy(potentiallyEditedAllergy);
						allergies.add(newAllergy);
						
						//we void its original values, as came from the database, 
						//instead the current ones which have just been copied 
						//into the new allergy we have just created above
						voidAllergy(originalAllergy);
					}
					catch (Exception ex) {
						throw new APIException("Failed to copy edited values", ex);
					}
				}
				continue;
			}
			
			//void the allergy that has been deleted
			voidAllergy(originalAllergy);
		}
		
		for (Allergy allergy : allergies) {
			if (allergy.getAllergyId() == null && allergy.getAllergen().getCodedAllergen() == null
			        && StringUtils.isNotBlank(allergy.getAllergen().getNonCodedAllergen())) {
				
				Concept otherNonCoded = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid());
				if (otherNonCoded == null) {
					throw new APIException("Can't find concept with uuid:" + Allergen.getOtherNonCodedConceptUuid());
				}
				allergy.getAllergen().setCodedAllergen(otherNonCoded);
			}
		}
		
		return dao.saveAllergies(patient, allergies);
	}
	
	/**
	 * Voids a given allergy
	 * 
	 * @param allergy the allergy to void
	 */
	private void voidAllergy(Allergy allergy) {
		allergy.setVoided(true);
		allergy.setVoidedBy(Context.getAuthenticatedUser());
		allergy.setDateVoided(new Date());
		allergy.setVoidReason("Voided by API");
		dao.saveAllergy(allergy);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getAllergy(java.lang.Integer)
	 */
	@Override
	@Transactional(readOnly = true)
	public Allergy getAllergy(Integer allergyId) throws APIException {
		return dao.getAllergy(allergyId);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#getAllergyByUuid(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public Allergy getAllergyByUuid(String uuid) throws APIException {
		return dao.getAllergyByUuid(uuid);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#saveAllergy(org.openmrs.Allergy)
	 */
	@Override
	public void saveAllergy(Allergy allergy) throws APIException {
		dao.saveAllergy(allergy);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#removeAllergy(org.openmrs.Allergy,
	 *      java.lang.String)
	 */
	@Override
	public void removeAllergy(Allergy allergy, String reason) throws APIException {
		voidAllergy(allergy, reason);
	}
	
	/**
	 * @see org.openmrs.api.PatientService#voidAllergy(org.openmrs.Allergy,
	 *      java.lang.String)
	 */
	@Override
	public void voidAllergy(Allergy allergy, String reason) throws APIException {
		allergy.setVoided(true);
		allergy.setVoidedBy(Context.getAuthenticatedUser());
		allergy.setDateVoided(new Date());
		allergy.setVoidReason(reason);
		dao.saveAllergy(allergy);
	}
	
	/**
	 * @see PatientService#getCountOfPatients(String)
	 */
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfPatients(String query) {
		int count = 0;
		if (StringUtils.isBlank(query)) {
			return count;
		}
		
		return OpenmrsUtil.convertToInteger(dao.getCountOfPatients(query));
	}
	
	/**
	 * @see PatientService#getCountOfPatients(String, boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfPatients(String query, boolean includeVoided) {
		int count = 0;
		if (StringUtils.isBlank(query)) {
			return count;
		}
		
		return OpenmrsUtil.convertToInteger(dao.getCountOfPatients(query, includeVoided));
	}
	
	/**
	 * @see PatientService#getPatients(String, Integer, Integer)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query, Integer start, Integer length) throws APIException {
		List<Patient> patients = new ArrayList<>();
		if (StringUtils.isBlank(query)) {
			return patients;
		}
		
		return dao.getPatients(query, start, length);
	}
	
	/**
	 * @see PatientService#getPatients(String, boolean, Integer, Integer)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query, boolean includeVoided, Integer start, Integer length) throws APIException {
		if (StringUtils.isBlank(query)) {
			return Collections.emptyList();
		}
		
		return dao.getPatients(query, includeVoided, start, length);
	}
	
	/**
	 * @see PatientService#getPatients(String, String, List, boolean, Integer, Integer)
	 */
	// TODO - search for usage with non-empty list of patient identifier types - not used
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String name, String identifier, List<PatientIdentifierType> identifierTypes,
	        boolean matchIdentifierExactly, Integer start, Integer length) throws APIException {
		
		if(identifierTypes == null) {
			return dao.getPatients(name != null ? name : identifier, start, length);
		}
		else {
			return dao.getPatients(name != null ? name : identifier, identifierTypes, matchIdentifierExactly, start, length);
		}
	}
	
	/**
	 * @see PatientService#checkIfPatientIdentifierTypesAreLocked()
	 */
	@Override
	public void checkIfPatientIdentifierTypesAreLocked() {
		String locked = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_IDENTIFIER_TYPES_LOCKED, "false");
		if ("true".equalsIgnoreCase(locked)) {
			throw new PatientIdentifierTypeLockedException();
		}
	}
	/**
	 * @see PatientService#getPatientIdentifiersByPatientProgram(org.openmrs.PatientProgram)
	 */
	public List<PatientIdentifier> getPatientIdentifiersByPatientProgram(PatientProgram patientProgram) {
		return dao.getPatientIdentifierByProgram(patientProgram);
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import org.openmrs.Person;
import org.openmrs.Privilege;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.annotation.Authorized;
import org.openmrs.annotation.Logging;
import org.openmrs.util.PersonByNameComparator;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.notification.MessageException;
/**
 * Contains methods pertaining to Users in the system Use:<br>
 * 
 * <pre>
 * 
 * 
 * List&lt;User&gt; users = Context.getUserService().getAllUsers();
 * </pre>
 * 
 * @see org.openmrs.api.context.Context
 */
public interface UserService extends OpenmrsService {
	public static final String ADMIN_PASSWORD_LOCKED_PROPERTY = "admin_password_locked";
	
	/**
	 * Create user with given password.
	 *
	 * @param user the user to create
	 * @param password the password for created user
	 * @return created user
	 * @throws APIException
	 */
	@Authorized( { PrivilegeConstants.ADD_USERS })
	@Logging(ignoredArgumentIndexes = { 1 })
	public User createUser(User user, String password) throws APIException;
	
	/**
	 * Change user password.
	 *
	 * @param user the user to update password
	 * @param oldPassword the user password  to update
	 * @param newPassword the new user password
	 * @throws APIException for not existing user and if old password is weak
	 * @since 1.12
	 * <strong>Should</strong> throw APIException if old password is not correct
	 * <strong>Should</strong> throw APIException if new password is the same as old passoword
	 * <strong>Should</strong> throw APIException if given user does not exist
	 * <strong>Should</strong> change password for given user if oldPassword is correctly passed
	 * <strong>Should</strong> change password for given user if oldPassword is null and changing user have privileges
	 * <strong>Should</strong> throw exception if oldPassword is null and changing user have not privileges
	 * <strong>Should</strong> throw exception if new password is too short
	 */
	@Authorized( { PrivilegeConstants.EDIT_USER_PASSWORDS })
	@Logging(ignoredArgumentIndexes = { 1, 2 })
	public void changePassword(User user, String oldPassword, String newPassword) throws APIException;
	
	/**
	 * Get user by internal user identifier.
	 * 
	 * @param userId internal identifier
	 * @return requested user
	 * @throws APIException
	 * <strong>Should</strong> fetch user with given userId
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public User getUser(Integer userId) throws APIException;
	
	/**
	 * Get user by the given uuid.
	 * 
	 * @param uuid
	 * @return user or null
	 * @throws APIException
	 * <strong>Should</strong> fetch user with given uuid
	 * <strong>Should</strong> find object given valid uuid
	 * <strong>Should</strong> return null if no object found with given uuid
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public User getUserByUuid(String uuid) throws APIException;
	
	/**
	 * Get user by username (user's login identifier)
	 * 
	 * @param username User's identifier used for authentication
	 * @return requested user
	 * <strong>Should</strong> get user by username
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public User getUserByUsername(String username);
	
	/**
	 * Gets a user by username or email
	 * 
	 * @param usernameOrEmail User's email address or username
	 * @return requested user or null if not found
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public User getUserByUsernameOrEmail(String usernameOrEmail);
	
	/**
	 * Gets a user with the specified activation key
	 * @param activationKey User's activation key for password reset 
	 * @return requested User with associated  activation key
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public User getUserByActivationKey(String activationKey);
	
	/**
	 * true/false if username or systemId is already in db in username or system_id columns
	 * 
	 * @param user User to compare
	 * @return boolean
	 * @throws APIException
	 * <strong>Should</strong> verify that username and system id is unique
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public boolean hasDuplicateUsername(User user) throws APIException;
	
	/**
	 * Get users by role granted
	 * 
	 * @param role Role that the Users must have to be returned
	 * @return users with requested role
	 * @throws APIException
	 * <strong>Should</strong> fetch users assigned given role
	 * <strong>Should</strong> not fetch user that does not belong to given role
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public List<User> getUsersByRole(Role role) throws APIException;
	
	/**
	 * Updates a given <code>user</code> in the database.
	 * 
	 * @param user
	 * @return the saved user
	 * @throws APIException
	 */
	@Authorized( { PrivilegeConstants.EDIT_USERS })
	public User saveUser(User user) throws APIException;
	
	/**
	 * Deactivate a user account so that it can no longer log in.
	 * 
	 * @param user
	 * @param reason
	 * @throws APIException
	 * <strong>Should</strong> retire user and set attributes
	 */
	@Authorized( { PrivilegeConstants.EDIT_USERS })
	public User retireUser(User user, String reason) throws APIException;
	
	/**
	 * Clears retired flag for a user.
	 * 
	 * @param user
	 * @throws APIException
	 * <strong>Should</strong> unretire and unmark all attributes
	 */
	@Authorized( { PrivilegeConstants.EDIT_USERS })
	public User unretireUser(User user) throws APIException;
	
	/**
	 * Completely remove a location from the database (not reversible). This method delegates to
	 * #purgeLocation(location, boolean) method.
	 * 
	 * @param user the User to remove from the database.
	 * <strong>Should</strong> delete given user
	 */
	@Authorized( { PrivilegeConstants.PURGE_USERS })
	public void purgeUser(User user) throws APIException;
	
	/**
	 * Completely remove a user from the database (not reversible). This is a delete from the
	 * database. This is included for troubleshooting and low-level system administration. Ideally,
	 * this method should <b>never</b> be called &mdash; <code>Users</code> should be
	 * <em>voided</em> and not <em>deleted</em> altogether (since many foreign key constraints
	 * depend on users, deleting a user would require deleting all traces, and any historical trail
	 * would be lost). This method only clears user roles and attempts to delete the user record. If
	 * the user has been included in any other parts of the database (through a foreign key), the
	 * attempt to delete the user will violate foreign key constraints and fail.
	 * 
	 * @param cascade <code>true</code> to delete associated content
	 * <strong>Should</strong> throw APIException if cascade is true
	 * <strong>Should</strong> delete given user when cascade equals false
	 * <strong>Should</strong> not delete user roles for given user when cascade equals false
	 */
	@Authorized( { PrivilegeConstants.PURGE_USERS })
	public void purgeUser(User user, boolean cascade) throws APIException;
	
	/**
	 * Returns all privileges currently possible for any User
	 * 
	 * @return Global list of privileges
	 * @throws APIException
	 * <strong>Should</strong> return all privileges in the system
	 */
	@Authorized(PrivilegeConstants.MANAGE_PRIVILEGES)
	public List<Privilege> getAllPrivileges() throws APIException;
	
	/**
	 * Returns all roles currently possible for any User
	 * 
	 * @return Global list of roles
	 * @throws APIException
	 * <strong>Should</strong> return all roles in the system
	 */
	@Authorized(PrivilegeConstants.MANAGE_ROLES)
	public List<Role> getAllRoles() throws APIException;
	
	/**
	 * Save the given role in the database
	 * 
	 * @param role Role to update
	 * @return the saved role
	 * @throws APIException
	 * <strong>Should</strong> throw error if role inherits from itself
	 * <strong>Should</strong> save given role to the database
	 */
	@Authorized( { PrivilegeConstants.MANAGE_ROLES })
	public Role saveRole(Role role) throws APIException;
	
	/**
	 * Complete remove a role from the database
	 * 
	 * @param role Role to delete from the database
	 * @throws APIException
	 * <strong>Should</strong> throw error when role is a core role
	 * <strong>Should</strong> return if role is null
	 * <strong>Should</strong> delete given role from database
	 */
	@Authorized( { PrivilegeConstants.PURGE_ROLES })
	public void purgeRole(Role role) throws APIException;
	
	/**
	 * Save the given privilege in the database
	 * 
	 * @param privilege Privilege to update
	 * @return the saved privilege
	 * @throws APIException
	 * <strong>Should</strong> save given privilege to the database
	 */
	@Authorized( { PrivilegeConstants.MANAGE_PRIVILEGES })
	public Privilege savePrivilege(Privilege privilege) throws APIException;
	
	/**
	 * Completely remove a privilege from the database
	 * 
	 * @param privilege Privilege to delete
	 * @throws APIException
	 * <strong>Should</strong> delete given privilege from the database
	 * <strong>Should</strong> throw error when privilege is core privilege
	 */
	@Authorized( { PrivilegeConstants.PURGE_PRIVILEGES })
	public void purgePrivilege(Privilege privilege) throws APIException;
	
	/**
	 * Returns role object with given string role
	 * 
	 * @return Role object for specified string
	 * @throws APIException
	 * <strong>Should</strong> fetch role for given role name
	 */
	@Authorized(PrivilegeConstants.GET_ROLES)
	public Role getRole(String r) throws APIException;
	
	/**
	 * Get Role by its UUID
	 * 
	 * @param uuid
	 * @return role or null
	 * <strong>Should</strong> find object given valid uuid
	 * <strong>Should</strong> return null if no object found with given uuid
	 */
	@Authorized(PrivilegeConstants.GET_ROLES)
	public Role getRoleByUuid(String uuid) throws APIException;
	
	/**
	 * Returns Privilege in the system with given String privilege
	 * 
	 * @return Privilege
	 * @throws APIException
	 * <strong>Should</strong> fetch privilege for given name
	 */
	@Authorized(PrivilegeConstants.GET_PRIVILEGES)
	public Privilege getPrivilege(String p) throws APIException;
	
	/**
	 * Get Privilege by its UUID
	 * 
	 * @param uuid
	 * @return privilege or null
	 * <strong>Should</strong> find object given valid uuid
	 * <strong>Should</strong> return null if no object found with given uuid
	 * <strong>Should</strong> fetch privilege for given uuid
	 */
	@Authorized(PrivilegeConstants.GET_PRIVILEGES)
	public Privilege getPrivilegeByUuid(String uuid) throws APIException;
	
	/**
	 * Returns all users in the system
	 * 
	 * @return Global list of users
	 * @throws APIException
	 * <strong>Should</strong> fetch all users in the system
	 * <strong>Should</strong> not contains any duplicate users
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public List<User> getAllUsers() throws APIException;
	
	/**
	 * Changes the current user's password.
	 * 
	 * @param oldPassword current password
	 * @param newPassword new password
	 * @throws APIException
	 * <strong>Should</strong> match on correctly hashed sha1 stored password
	 * <strong>Should</strong> match on incorrectly hashed sha1 stored password
	 * <strong>Should</strong> match on sha512 hashed password
	 * <strong>Should</strong> be able to update password multiple times
	 * <strong>Should</strong> respect locking via runtime properties
	 */
	@Authorized
	@Logging(ignoredArgumentIndexes = { 0, 1 })
	public void changePassword(String oldPassword, String newPassword) throws APIException;
	/**
	 * Changes password of {@link User} passed in
	 * @param user user whose password is to be changed
	 * @param newPassword new password to set
	 * @throws APIException
	 * <strong>Should</strong> update password of given user when logged in user has edit users password privilege
	 * <strong>Should</strong> not update password of given user when logged in user does not have edit users password privilege
	 */
	@Authorized({PrivilegeConstants.EDIT_USER_PASSWORDS})
	public void changePassword(User user, String newPassword) throws APIException;
	
	/**
	 * Changes the current user's password directly. This is most useful if migrating users from
	 * other systems and you want to retain the existing passwords. This method will simply save the
	 * passed hashed password and salt directly to the database.
	 * 
	 * @param user the user whose password you want to change
	 * @param hashedPassword - the <em>already hashed</em> password to store
	 * @param salt - the salt which should be used with this hashed password
	 * @throws APIException
	 * @since 1.5
	 * <strong>Should</strong> change the hashed password for the given user
	 */
	@Authorized( { PrivilegeConstants.EDIT_USER_PASSWORDS })
	public void changeHashedPassword(User user, String hashedPassword, String salt) throws APIException;
	
	/**
	 * Changes the passed user's secret question and answer.
	 * 
	 * @param u User to change
	 * @param question
	 * @param answer
	 * @throws APIException
	 * @since 1.5
	 * <strong>Should</strong> change the secret question and answer for given user
	 */
	@Authorized( { PrivilegeConstants.EDIT_USER_PASSWORDS })
	@Logging(ignoredArgumentIndexes = { 1, 2 })
	public void changeQuestionAnswer(User u, String question, String answer) throws APIException;
	
	/**
	 * Changes the current user's secret question and answer.
	 * 
	 * @param pw user's password
	 * @param q question
	 * @param a answer
	 * @throws APIException
	 * <strong>Should</strong> match on correctly hashed stored password
	 * <strong>Should</strong> match on incorrectly hashed stored password
	 */
	@Authorized
	@Logging(ignoreAllArgumentValues = true)
	public void changeQuestionAnswer(String pw, String q, String a) throws APIException;
	
	/**
	 * Returns secret question for the given user.
	 * 
	 * @param user
	 * @return
	 * @throws APIException
	 * @since 2.0
	 */
	public String getSecretQuestion(User user) throws APIException;
	
	/**
	 * Compares <code>answer</code> against the <code>user</code>'s secret answer.
	 * 
	 * @param u user
	 * @param answer
	 * @throws APIException
	 * <strong>Should</strong> return true when given answer matches stored secret answer
	 * <strong>Should</strong> return false when given answer does not match the stored secret answer
	 */
	@Logging(ignoredArgumentIndexes = { 1 })
	public boolean isSecretAnswer(User u, String answer) throws APIException;
	
	/**
	 * Return a list of users sorted by personName (see {@link PersonByNameComparator}) if any part
	 * of the search matches first/last/system id and the user has one at least one of the given
	 * <code>roles</code> assigned to them
	 * 
	 * @param nameSearch string to compare to the beginning of user's given/middle/family/family2
	 *            names
	 * @param roles all the Roles the user must contain
	 * @param includeVoided true/false whether to include voided users
	 * @return list of users matching the given attributes
	 * <strong>Should</strong> match search to familyName2
	 * <strong>Should</strong> fetch voided users if includedVoided is true
	 * <strong>Should</strong> not fetch voided users if includedVoided is false
	 * <strong>Should</strong> fetch users with name that contains given nameSearch
	 * <strong>Should</strong> fetch users with systemId that contains given nameSearch
	 * <strong>Should</strong> fetch users with at least one of the given role objects
	 * <strong>Should</strong> not fetch duplicate users
	 * <strong>Should</strong> fetch all users if nameSearch is empty or null
	 * <strong>Should</strong> not fail if roles are searched but name is empty
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public List<User> getUsers(String nameSearch, List<Role> roles, boolean includeVoided) throws APIException;
	
	/**
	 * Search for a list of users by exact first name and last name.
	 * 
	 * @param givenName
	 * @param familyName
	 * @param includeRetired
	 * @return List&lt;User&gt; object of users matching criteria
	 * <strong>Should</strong> fetch users exactly matching the given givenName and familyName
	 * <strong>Should</strong> fetch voided users whenincludeVoided is true
	 * <strong>Should</strong> not fetch any voided users when includeVoided is false
	 * <strong>Should</strong> not fetch any duplicate users
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public List<User> getUsersByName(String givenName, String familyName, boolean includeRetired) throws APIException;
	
	/**
	 * Get all user accounts that belong to a given person.
	 * 
	 * @param person
	 * @param includeRetired
	 * @return all user accounts that belong to person, including retired ones if specified
	 * @throws APIException
	 * <strong>Should</strong> fetch all accounts for a person when include retired is true
	 * <strong>Should</strong> not fetch retired accounts when include retired is false
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public List<User> getUsersByPerson(Person person, boolean includeRetired) throws APIException;
	
	/**
	 * Adds the <code>key</code>/<code>value</code> pair to the given <code>user</code>.
	 * <p>
	 * <b>Implementations of this method should handle privileges</b>
	 * 
	 * @param user
	 * @param key
	 * @param value
	 * @return the user that was passed in and added to
	 * <strong>Should</strong> return null if user is null
	 * <strong>Should</strong> throw error when user is not authorized to edit users
	 * <strong>Should</strong> add property with given key and value when key does not already exist
	 * <strong>Should</strong> modify property with given key and value when key already exists
	 */
	@Authorized
	public User setUserProperty(User user, String key, String value) throws APIException;
	
	/**
	 * Removes the property denoted by <code>key</code> from the <code>user</code>'s properties.
	 * <b>Implementations of this method should handle privileges</b>
	 * 
	 * @param user
	 * @param key
	 * @return the user that was passed in and removed from
	 * <strong>Should</strong> return null if user is null
	 * <strong>Should</strong> throw error when user is not authorized to edit users
	 * <strong>Should</strong> remove user property for given user and key
	 */
	@Authorized
	public User removeUserProperty(User user, String key) throws APIException;
	
	/**
	 * Get/generate/find the next system id to be doled out. Assume check digit /not/ applied in
	 * this method
	 * 
	 * @return new system id
	 */
	@Authorized
	public String generateSystemId();
	
	/**
	 * Return a batch of users of a specific size sorted by personName (see
	 * {@link PersonByNameComparator}) if any part of the search matches first/last/system id and
	 * the user has one at least one of the given <code>roles</code> assigned to them. If start and
	 * length are not specified, then all matches are returned, If name is empty or null, then all
	 * all users will be returned taking into consideration the values of start and length
	 * arguments.
	 * 
	 * @param name string to compare to the beginning of user's given/middle/family/family2 names
	 * @param roles all the Roles the user must contain
	 * @param includeRetired true/false whether to include voided users
	 * @param start beginning index for the batch
	 * @param length number of users to return in the batch
	 * @return list of matching users of a size based on the specified arguments
	 * @since 1.8
	 * <strong>Should</strong> return users whose roles inherit requested roles
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public List<User> getUsers(String name, List<Role> roles, boolean includeRetired, Integer start, Integer length)
	        throws APIException;
	
	/**
	 * Return the number of users with a matching name or system id and have at least one of the
	 * given roles assigned to them
	 * 
	 * @param name patient name
	 * @param roles all the Roles the user must contain
	 * @param includeRetired Specifies whether voided users should be included
	 * @return the number of users matching the given attributes
	 * @since 1.8
	 */
	@Authorized( { PrivilegeConstants.GET_USERS })
	public Integer getCountOfUsers(String name, List<Role> roles, boolean includeRetired);
	
	/**
	 * Saves the current key/value as a user property for the current user.
	 * 
	 * @param key the authenticated user's property
	 * @param value value of the property
	 * @since 1.10
	 */
	@Authorized
	public User saveUserProperty(String key, String value);
	
	/**
	 * Replaces all user properties with the given map of properties for the current user
	 * 
	 * @param properties the authenticated user's properties
	 * @since 1.10
	 */
	@Authorized
	public User saveUserProperties(Map<String, String> properties);
	
	/**
	 * Change user password given the answer to the secret question
	 * @param secretAnswer the answer to secret question
	 * @param pw the new password
	 * <strong>Should</strong> update password if secret is correct
	 * <strong>Should</strong> not update password if secret is not correct
	 */
	@Authorized
	public void changePasswordUsingSecretAnswer(String secretAnswer, String pw) throws APIException;
	
	/**
	 * Sets a user's activation key
	 * @param user The user for which the activation key will be set
	 */
	@Authorized(PrivilegeConstants.EDIT_USER_PASSWORDS)
	public User setUserActivationKey(User user) throws MessageException;
	
	/**
	 * Change user password given the activation key
	 * 
	 * @param activationKey the activation for password reset
	 * @param newPassword the new password
	 */
	public void changePasswordUsingActivationKey(String activationKey, String newPassword);
	/**
	 * @param user the User whose Locale to retrieve
	 * @return the default Locale of the given user, or the system locale if unspecified
	 * @since 2.3.6, 2.4.6, 2.5.4, 2.6.0
	 */
	@Authorized
	Locale getDefaultLocaleForUser(User user);
	/**
	 * Retrieves the last login time of the user in Unix Timestamp
	 * 
	 * @param user the subject user
	 * @return timestamp representing last login time (e.g. 1717414410587)
	 * @since 2.7.0
	 * 
	 * @should return empty string on last login time if a different user is logged in
	 * @should not be empty if user is authenticated
	 * @should return empty string on last login time if property not set
	 */
	@Authorized
	String getLastLoginTime(User user);
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.migration;
import java.io.IOException;
import java.io.StringReader;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.openmrs.Location;
import org.openmrs.Patient;
import org.openmrs.PatientIdentifier;
import org.openmrs.PatientIdentifierType;
import org.openmrs.PatientProgram;
import org.openmrs.PatientState;
import org.openmrs.Person;
import org.openmrs.PersonName;
import org.openmrs.Program;
import org.openmrs.ProgramWorkflow;
import org.openmrs.ProgramWorkflowState;
import org.openmrs.Relationship;
import org.openmrs.RelationshipType;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.LocationService;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.UserService;
import org.openmrs.api.context.Context;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
/**
 * The MigrationHelper will be removed from openmrs-core. If you need the code migrate it to your code base.
 * 
 * @deprecated since 2.2.0
 */
@Deprecated
public class MigrationHelper {
	private MigrationHelper() {
	}
	
	private static final String DATE_TIME_PATTERN = "yyyy-MM-dd HH:mm:ss";
	private static final Logger log = LoggerFactory.getLogger(MigrationHelper.class);
	
	static DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	/**
	 * @deprecated since 2.2.0 migrate the method to your code base if needed
	 */
	@Deprecated
	public static Date parseDate(String s) throws ParseException {
		if (s == null || s.length() == 0) {
			return null;
		} else {
			if (s.length() == 10) {
				s += " 00:00:00";
			}
			DateFormat df = new SimpleDateFormat(DATE_TIME_PATTERN);
			return df.parse(s);
		}
	}
	/**
	 * @deprecated since 2.2.0 migrate the method to your code base if needed
	 */
	@Deprecated
	public static Document parseXml(String xml) throws ParserConfigurationException {
		DocumentBuilder builder = factory.newDocumentBuilder();
		try {
			// Disable resolution of external entities. See TRUNK-3942 
			builder.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader("")));
			
			return builder.parse(new InputSource(new StringReader(xml)));
		}
		catch (IOException | SAXException ex) {
			return null;
		}
	}
	
	private static void findNodesNamed(Node node, String lookForName, Collection<Node> ret) {
		if (node.getNodeName().equals(lookForName)) {
			ret.add(node);
		} else {
			NodeList list = node.getChildNodes();
			for (int i = 0; i < list.getLength(); ++i) {
				findNodesNamed(list.item(i), lookForName, ret);
			}
		}
	}
	
	/**
	 * Takes XML like: &lt;something&gt; &lt;user date_changed="2001-03-06 08:46:53.0"
	 * date_created="2001-03-06 08:46:53.0" username="hamish@mit.edu" first_name="Hamish"
	 * last_name="Fraser" user_id="2001"/&gt; &lt;/something&gt; Returns the number of users added
	 * 
	 * @deprecated since 2.2.0 migrate the method to your code base if needed
	 */
	@Deprecated
	public static int importUsers(Document document) throws ParseException {
		int ret = 0;
		Random rand = new Random();
		UserService us = Context.getUserService();
		
		List<Node> toAdd = new ArrayList<>();
		findNodesNamed(document, "user", toAdd);
		for (Node node : toAdd) {
			Element e = (Element) node;
			String username = e.getAttribute("username");
			if (username == null || username.length() == 0) {
				throw new IllegalArgumentException("each <user /> element must define a user_name attribute");
			}
			if (us.getUserByUsername(username) != null) {
				continue;
			}
			User user = new User();
			user.setPerson(new Person());
			PersonName pn = new PersonName(e.getAttribute("first_name"), "", e.getAttribute("last_name"));
			user.addName(pn);
			user.setUsername(username);
			user.setDateCreated(parseDate(e.getAttribute("date_created")));
			user.setDateChanged(parseDate(e.getAttribute("date_changed")));
			
			// Generate a temporary password: 8-12 random characters
			String pass;
			{
				int length = rand.nextInt(4) + 8;
				char[] password = new char[length];
				for (int x = 0; x < length; x++) {
					int randDecimalAsciiVal = rand.nextInt(93) + 33;
					password[x] = (char) randDecimalAsciiVal;
				}
				pass = new String(password);
			}
			us.createUser(user, pass);
			++ret;
		}
		return ret;
	}
	
	/**
	 * Takes XML like: &lt;something&gt; &lt;location name="Cerca-la-Source"/&gt; &lt;/something&gt; returns the
	 * number of locations added
	 * 
	 * @deprecated since 2.2.0 migrate the method to your code base if needed
	 */
	@Deprecated
	public static int importLocations(Document document) {
		int ret = 0;
		LocationService ls = Context.getLocationService();
		List<Node> toAdd = new ArrayList<>();
		findNodesNamed(document, "location", toAdd);
		for (Node node : toAdd) {
			Element e = (Element) node;
			String name = e.getAttribute("name");
			if (name == null || name.length() == 0) {
				throw new IllegalArgumentException("each <location /> element must define a name attribute");
			}
			if (ls.getLocation(name) != null) {
				continue;
			}
			Location location = new Location();
			location.setName(name);
			
			ls.saveLocation(location);
			++ret;
		}
		return ret;
	}
	
	/**
	 * Takes a list of Strings of the format RELATIONSHIP:&lt;user last name&gt;,&lt;user first
	 * name&gt;,&lt;relationship type name&gt;,&lt;patient identifier type name&gt;,&lt;identifier&gt; so if user hfraser
	 * if the cardiologist of the patient with patient_id 8039 in PIH's old emr, then:
	 * RELATIONSHIP:hfraser,Cardiologist,HIV-EMRV1,8039 (the "RELATIONSHIP:" is not actually
	 * necessary. Anything before and including the first : will be dropped If autoCreateUsers is
	 * true, and no user exists with the given username, one will be created. If autoAddRole is
	 * true, then whenever a user is auto-created, if a role exists with the same name as
	 * relationshipType.name, then the user will be added to that role
	 * 
	 * @deprecated since 2.2.0 migrate the method to your code base if needed
	 */
	@Deprecated
	public static int importRelationships(Collection<String> relationships, boolean autoCreateUsers, boolean autoAddRole) {
		PatientService ps = Context.getPatientService();
		UserService us = Context.getUserService();
		PersonService personService = Context.getPersonService();
		List<Relationship> relsToAdd = new ArrayList<>();
		Random rand = new Random();
		for (String s : relationships) {
			if (s.contains(":")) {
				s = s.substring(s.indexOf(":") + 1);
			}
			String[] ss = s.split(",");
			if (ss.length < 5) {
				throw new IllegalArgumentException("The line '" + s + "' is in the wrong format");
			}
			String userLastName = ss[0];
			String userFirstName = ss[1];
			String username = (userFirstName + userLastName).replaceAll(" ", "");
			String relationshipType = ss[2];
			String identifierType = ss[3];
			String identifier = ss[4];
			User user = null;
			{ // first try looking for non-voided users
				List<User> users = us.getUsersByName(userFirstName, userLastName, false);
				if (users.size() == 1) {
					user = users.get(0);
				} else if (users.size() > 1) {
					throw new IllegalArgumentException("Found " + users.size() + " users named '" + userLastName + ", "
					        + userFirstName + "'");
				}
			}
			if (user == null) {
				// next try looking for voided users
				List<User> users = us.getUsersByName(userFirstName, userLastName, false);
				if (users.size() == 1) {
					user = users.get(0);
				} else if (users.size() > 1) {
					throw new IllegalArgumentException("Found " + users.size() + " voided users named '" + userLastName
					        + ", " + userFirstName + "'");
				}
			}
			if (user == null && autoCreateUsers) {
				user = new User();
				user.setPerson(new Person());
				PersonName pn = new PersonName(userFirstName, "", userLastName);
				user.addName(pn);
				user.setUsername(username);
				// Generate a temporary password: 8-12 random characters
				String pass;
				{
					int length = rand.nextInt(4) + 8;
					char[] password = new char[length];
					for (int x = 0; x < length; x++) {
						int randDecimalAsciiVal = rand.nextInt(93) + 33;
						password[x] = (char) randDecimalAsciiVal;
					}
					pass = new String(password);
				}
				if (autoAddRole) {
					Role role = us.getRole(relationshipType);
					if (role != null) {
						user.addRole(role);
					}
				}
				us.createUser(user, pass);
			}
			if (user == null) {
				throw new IllegalArgumentException("Can't find user '" + userLastName + ", " + userFirstName + "'");
			}
			Person person = personService.getPerson(user.getUserId());
			
			RelationshipType relationship = personService.getRelationshipTypeByName(relationshipType);
			PatientIdentifierType pit = ps.getPatientIdentifierTypeByName(identifierType);
			List<PatientIdentifier> found = ps.getPatientIdentifiers(identifier, Collections.singletonList(pit), null, null,
			    null);
			if (found.size() != 1) {
				throw new IllegalArgumentException("Found " + found.size() + " patients with identifier '" + identifier
				        + "' of type " + identifierType);
			}
			Person relative = personService.getPerson(found.get(0).getPatient().getPatientId());
			Relationship rel = new Relationship();
			rel.setPersonA(person);
			rel.setRelationshipType(relationship);
			rel.setPersonB(relative);
			relsToAdd.add(rel);
		}
		int addedSoFar = 0;
		for (Relationship rel : relsToAdd) {
			personService.saveRelationship(rel);
			++addedSoFar;
		}
		return addedSoFar;
	}
	/**
	 * @deprecated since 2.2.0 migrate the method to your code base if needed
	 */
	@Deprecated
	public static int importProgramsAndStatuses(List<String> programWorkflow) throws ParseException {
		ProgramWorkflowService pws = Context.getProgramWorkflowService();
		PatientService ps = Context.getPatientService();
		List<PatientProgram> patientPrograms = new ArrayList<>();
		Map<String, PatientProgram> knownPatientPrograms = new HashMap<>();
		Map<String, Program> programsByName = new HashMap<>();
		for (Program program : pws.getAllPrograms()) {
			programsByName.put(program.getConcept().getName(Context.getLocale(), false).getName(), program);
		}
		for (String s : programWorkflow) {
			// ENROLLMENT:HIVEMR-V1,9266,IMB HIV PROGRAM,2005-08-25,
			log.debug(s);
			if (s.startsWith("ENROLLMENT:")) {
				s = s.substring(s.indexOf(":") + 1);
				String[] temp = s.split(",");
				PatientIdentifierType pit = ps.getPatientIdentifierTypeByName(temp[0]);
				String identifier = temp[1];
				List<PatientIdentifier> pis = ps.getPatientIdentifiers(identifier, Collections.singletonList(pit), null,
				    null, null);
				if (pis.size() != 1) {
					throw new IllegalArgumentException("Found " + pis.size() + " instances of identifier " + identifier
					        + " of type " + pit);
				}
				Patient p = pis.get(0).getPatient();
				Program program = programsByName.get(temp[2]);
				if (program == null) {
					throw new RuntimeException("Couldn't find program \"" + temp[2] + "\" in " + programsByName);
				}
				Date enrollmentDate = temp.length < 4 ? null : parseDate(temp[3]);
				Date completionDate = temp.length < 5 ? null : parseDate(temp[4]);
				PatientProgram pp = new PatientProgram();
				pp.setPatient(p);
				pp.setProgram(program);
				pp.setDateEnrolled(enrollmentDate);
				pp.setDateCompleted(completionDate);
				patientPrograms.add(pp);
				knownPatientPrograms.put(temp[0] + "," + temp[1] + "," + temp[2], pp); // "HIVEMR-V1,9266,IMB HIV PROGRAM"
			} else if (s.startsWith("STATUS:")) {
				// STATUS:HIVEMR-V1,9266,IMB HIV PROGRAM,TREATMENT STATUS,ACTIVE,2005-08-25,,
				s = s.substring(s.indexOf(":") + 1);
				String[] temp = s.split(",");
				Program program = programsByName.get(temp[2]);
				if (program == null) {
					throw new RuntimeException("Couldn't find program \"" + temp[2] + "\" in " + programsByName);
				}
				ProgramWorkflow wf = program.getWorkflowByName(temp[3]);
				if (wf == null) {
					throw new RuntimeException("Couldn't find workflow \"" + temp[3] + "\" for program " + program + " (in "
					        + program.getAllWorkflows() + ")");
				}
				ProgramWorkflowState st = wf.getStateByName(temp[4]);
				if (st == null) {
					throw new RuntimeException("Couldn't find state \"" + temp[4] + "\" for workflow " + wf + " (in "
					        + wf.getStates() + ")");
				}
				Date startDate = temp.length < 6 ? null : parseDate(temp[5]);
				Date endDate = temp.length < 7 ? null : parseDate(temp[6]);
				PatientState state = new PatientState();
				PatientProgram pp = knownPatientPrograms.get(temp[0] + "," + temp[1] + "," + temp[2]);
				state.setPatientProgram(pp);
				state.setState(st);
				state.setStartDate(startDate);
				state.setEndDate(endDate);
				pp.getStates().add(state);
			}
		}
		int numAdded = 0;
		
		for (PatientProgram pp : knownPatientPrograms.values()) {
			pws.savePatientProgram(pp);
			++numAdded;
		}
		return numAdded;
	}
	
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api.context;
import org.aopalliance.aop.Advice;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.SessionFactory;
import org.openmrs.Allergen;
import org.openmrs.GlobalProperty;
import org.openmrs.OpenmrsObject;
import org.openmrs.PersonName;
import org.openmrs.Privilege;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.CohortService;
import org.openmrs.api.ConceptService;
import org.openmrs.api.ConditionService;
import org.openmrs.api.DatatypeService;
import org.openmrs.api.DiagnosisService;
import org.openmrs.api.EncounterService;
import org.openmrs.api.FormService;
import org.openmrs.api.LocationService;
import org.openmrs.api.MedicationDispenseService;
import org.openmrs.api.ObsService;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.OrderService;
import org.openmrs.api.OrderSetService;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.ProviderService;
import org.openmrs.api.SerializationService;
import org.openmrs.api.UserService;
import org.openmrs.api.VisitService;
import org.openmrs.api.db.ContextDAO;
import org.openmrs.hl7.HL7Service;
import org.openmrs.logic.LogicService;
import org.openmrs.messagesource.MessageSourceService;
import org.openmrs.module.ModuleMustStartException;
import org.openmrs.module.ModuleUtil;
import org.openmrs.notification.AlertService;
import org.openmrs.notification.MessageException;
import org.openmrs.notification.MessagePreparator;
import org.openmrs.notification.MessageSender;
import org.openmrs.notification.MessageService;
import org.openmrs.notification.mail.MailMessageSender;
import org.openmrs.notification.mail.velocity.VelocityMessagePreparator;
import org.openmrs.scheduler.SchedulerService;
import org.openmrs.scheduler.SchedulerUtil;
import org.openmrs.util.ConfigUtil;
import org.openmrs.util.DatabaseUpdateException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.validator.ValidateUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Advisor;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.NoUniqueBeanDefinitionException;
import javax.mail.Authenticator;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import java.sql.Connection;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.Future;
/**
 * Represents an OpenMRS <code>Context</code>, which may be used to authenticate to the database and
 * obtain services in order to interact with the system.<br>
 * <br>
 * The Context is split into a {@link UserContext} and {@link ServiceContext}. The UserContext is
 * lightweight and there is an instance for every user logged into the system. The ServiceContext is
 * heavier and it contains each service class. This is more static and there is only one ServiceContext
 * per OpenMRS instance. <br>
 * <br>
 * Both the {@link UserContext} and the {@link ServiceContext} should not be used directly. This
 * context class has methods to pass through to the currently defined UserContext for the thread and
 * the currently defined ServiceContext. <br>
 * <br>
 * To use the OpenMRS api there are four things that have to be done:
 * <ol>
 * <li>Call {@link Context#startup(String, String, String, Properties)} to let the Context contact
 * the database</li>
 * <li>Call {@link Context#openSession()} to start a "unit of work".</li>
 * <li>Call {@link Context#authenticate(String, String)} to authenticate the current user on the
 * current thread</li>
 * <li>Call {@link Context#closeSession()} to end your "unit of work" and commit all changes to the
 * database.</li>
 * </ol>
 * <br>
 * Example usage:
 *
 * <pre>
 * 	public static void main(String[] args) {
 * 		Context.startup("jdbc:mysql://localhost:3306/db-name?autoReconnect=true", "openmrs-db-user", "3jknfjkn33ijt", new Properties());
 * 		try {
 * 			Context.openSession();
 * 			Context.authenticate("admin", "test");
 * 			List&lt;Patients&gt; patients = Context.getPatientService().getPatientsByName("Fred");
 * 			patients.get(0).setBirthdate(new Date());
 * 			Context.getPatientService().savePatient(patients.get(0));
 * 			...
 *        }
 * 		finally {
 * 			Context.closeSession();
 *        }
 *    }
 * </pre>
 *
 * @see org.openmrs.api.context.UserContext
 * @see org.openmrs.api.context.ServiceContext
 */
public class Context {
	private static final Logger log = LoggerFactory.getLogger(Context.class);
	// Global resources
	private static ContextDAO contextDAO;
	private static Session mailSession;
	// Using "wrapper" (Object array) around UserContext to avoid ThreadLocal
	// bug in Java 1.5
	private static final ThreadLocal<Object[] /* UserContext */> userContextHolder = new ThreadLocal<>();
	private static volatile ServiceContext serviceContext;
	private static Properties runtimeProperties = new Properties();
	private static Properties configProperties = new Properties();
	private static AuthenticationScheme authenticationScheme;
	/**
	 * Default public constructor
	 */
	public Context() {
	}
	/**
	 * Gets the context's data access object
	 *
	 * @return ContextDAO
	 */
	static ContextDAO getContextDAO() {
		if (contextDAO == null) {
			throw new APIException("error.context.null", (Object[]) null);
		}
		return contextDAO;
	}
	/**
	 * Used to set the context's DAO for the application.
	 *
	 * @param dao ContextDAO to set
	 */
	public void setContextDAO(ContextDAO dao) {
		setDAO(dao);
	}
	public static void setDAO(ContextDAO dao) {
		contextDAO = dao;
	}
	/**
	 * Spring init method that sets the authentication scheme.
	 */
	private static void setAuthenticationScheme() {
		authenticationScheme = new UsernamePasswordAuthenticationScheme();
		try {
			authenticationScheme = Context.getServiceContext().getApplicationContext().getBean(AuthenticationScheme.class); // manual autowiring (from a module)
			log.info("An authentication scheme override was provided. Using this one in place of the OpenMRS default authentication scheme.");
		}
		catch(NoUniqueBeanDefinitionException e) {
			log.error("Multiple authentication schemes overrides are being provided, this is currently not supported. Sticking to OpenMRS default authentication scheme.");
		}
		catch(NoSuchBeanDefinitionException e) {
			log.debug("No authentication scheme override was provided. Sticking to OpenMRS default authentication scheme.");
		}
		catch(BeansException e){
			log.error("Fatal error encountered when injecting the authentication scheme override. Sticking to OpenMRS default authentication scheme.");
		}
	}
	/**
	 * Loads a class with an instance of the OpenmrsClassLoader. Convenience method equivalent to
	 * OpenmrsClassLoader.getInstance().loadClass(className);
	 *
	 * @param className the class to load
	 * @return the class that was loaded
	 * @throws ClassNotFoundException
	 * <strong>Should</strong> load class with the OpenmrsClassLoader
	 */
	public static Class<?> loadClass(String className) throws ClassNotFoundException {
		return OpenmrsClassLoader.getInstance().loadClass(className);
	}
	/**
	 * Sets the user context on the thread local so that the service layer can perform
	 * authentication/authorization checks.<br>
	 * <br>
	 * This is thread safe since it stores the given user context in ThreadLocal.
	 *
	 * @param ctx UserContext to set
	 */
	public static void setUserContext(UserContext ctx) {
		log.trace("Setting user context {}", ctx);
		Object[] arr = new Object[] { ctx };
		userContextHolder.set(arr);
	}
	/**
	 * Clears the user context from the threadlocal.
	 */
	public static void clearUserContext() {
		log.trace("Clearing user context {}", Arrays.toString(userContextHolder.get()));
		userContextHolder.remove();
	}
	/**
	 * Gets the user context from the thread local. This might be accessed by several threads at the
	 * same time.
	 *
	 * @return The current UserContext for this thread.
	 * <strong>Should</strong> fail if session hasn't been opened
	 */
	public static UserContext getUserContext() {
		Object[] arr = userContextHolder.get();
		log.trace("Getting user context {} from userContextHolder {}", Arrays.toString(arr), userContextHolder);
		if (arr == null) {
			log.trace("userContext is null.");
			throw new APIException(
					"A user context must first be passed to setUserContext()...use Context.openSession() (and closeSession() to prevent memory leaks!) before using the API");
		}
		return (UserContext) userContextHolder.get()[0];
	}
	/**
	 * Gets the currently defined service context. If one is not defined, one will be created and
	 * then returned.
	 *
	 * @return the current ServiceContext
	 */
	static ServiceContext getServiceContext() {
		if (serviceContext == null) {
			synchronized (Context.class) {
				if (serviceContext == null) {
					log.info("Creating new service context");
					serviceContext = ServiceContext.getInstance();
				}
			}
		}
		log.trace("serviceContext: {}", serviceContext);
		return ServiceContext.getInstance();
	}
	/**
	 * Sets the service context.
	 *
	 * @param ctx
	 */
	public void setServiceContext(ServiceContext ctx) {
		setContext(ctx);
	}
	public static void setContext(ServiceContext ctx) {
		serviceContext = ctx;
	}
	/**
	 * OpenMRS provides its default authentication scheme that authenticates via DAO with OpenMRS usernames and passwords.
	 * 
	 * Any module can provide an authentication scheme override by Spring wiring a custom implementation of {@link AuthenticationScheme}.
	 * This method would return Core's default authentication scheme unless a Spring override is provided somewhere else.
	 * 
	 * @return The enforced authentication scheme.
	 */
	public static AuthenticationScheme getAuthenticationScheme() {
		return authenticationScheme;
	}
	/**
	 * @deprecated as of 2.3.0, replaced by {@link #authenticate(Credentials)}
	 * 
	 * Used to authenticate user within the context
	 *
	 * @param username user's identifier token for login
	 * @param password user's password for authenticating to context
	 * @throws ContextAuthenticationException
	 * <strong>Should</strong> not authenticate with null username and password
	 * <strong>Should</strong> not authenticate with null password
	 * <strong>Should</strong> not authenticate with null username
	 * <strong>Should</strong> not authenticate with null password and proper username
	 * <strong>Should</strong> not authenticate with null password and proper system id
	 */
	@Deprecated
	public static void authenticate(String username, String password) throws ContextAuthenticationException {
		authenticate(new UsernamePasswordCredentials(username, password));
	}
	/**
	 * @param credentials
	 * @throws ContextAuthenticationException
	 * 
	 * @since 2.3.0
	 */
	public static Authenticated authenticate(Credentials credentials) throws ContextAuthenticationException {
		if (Daemon.isDaemonThread()) {
			log.error("Authentication attempted while operating on a "
					+ "daemon thread, authenticating is not necessary or allowed");
			return new BasicAuthenticated(Daemon.getDaemonThreadUser(), "No auth scheme used by Context - Daemon user is always authenticated.");
		}
		if (credentials == null) {
			throw new ContextAuthenticationException("Context cannot authenticate with null credentials.");
		}
		return getUserContext().authenticate(credentials);
	}
	/**
	 * Refresh the authenticated user object in the current UserContext. This should be used when
	 * updating information in the database about the current user and it needs to be reflecting in
	 * the (cached) {@link #getAuthenticatedUser()} User object.
	 *
	 * @since 1.5
	 * <strong>Should</strong> get fresh values from the database
	 */
	public static void refreshAuthenticatedUser() {
		if (Daemon.isDaemonThread()) {
			return;
		}
		log.debug("Refreshing authenticated user");
		getUserContext().refreshAuthenticatedUser();
	}
	/**
	 * Become a different user. (You should only be able to do this as a superuser.)
	 *
	 * @param systemId
	 * @throws ContextAuthenticationException
	 * <strong>Should</strong> change locale when become another user
	 */
	public static void becomeUser(String systemId) throws ContextAuthenticationException {
		log.info("systemId: {}", systemId);
		getUserContext().becomeUser(systemId);
	}
	/**
	 * Get the runtime properties that this OpenMRS instance was started with
	 *
	 * @return copy of the runtime properties
	 */
	public static Properties getRuntimeProperties() {
		log.trace("getting runtime properties. size: {}", runtimeProperties.size());
		Properties props = new Properties();
		props.putAll(runtimeProperties);
		return props;
	}
	/**
	 * Set the runtime properties to be used by this OpenMRS instance
	 *
	 * @param props runtime properties
	 */
	public static void setRuntimeProperties(Properties props) {
		runtimeProperties = props;
	}
	/**
	 * @return concept dictionary-related services
	 */
	public static ConceptService getConceptService() {
		return getServiceContext().getConceptService();
	}
	/**
	 * @return encounter-related services
	 */
	public static EncounterService getEncounterService() {
		return getServiceContext().getEncounterService();
	}
	/**
	 * @return location services
	 */
	public static LocationService getLocationService() {
		return getServiceContext().getLocationService();
	}
	/**
	 * @return observation services
	 */
	public static ObsService getObsService() {
		return getServiceContext().getObsService();
	}
	/**
	 * @return patient-related services
	 */
	public static PatientService getPatientService() {
		return getServiceContext().getPatientService();
	}
	public static CohortService getCohortService() {
		return getServiceContext().getCohortService();
	}
	/**
	 * @return person-related services
	 */
	public static PersonService getPersonService() {
		return getServiceContext().getPersonService();
	}
	/**
	 * @return condition-related services
	 * 
	 * @since 2.2
	 */
	public static ConditionService getConditionService(){
		return getServiceContext().getConditionService();
	}
	/**
	 * @return diagnosis-related services
	 *
	 * @since 2.2
	 */
	public static DiagnosisService getDiagnosisService(){
		return getServiceContext().getDiagnosisService();
	}
	/**
	 * @return MedicationDispense-related service
	 * @since 2.6.0
	 */
	public static MedicationDispenseService getMedicationDispenseService(){
		return getServiceContext().getMedicationDispenseService();
	}
	/**
	 * @return Returns the hl7Service.
	 */
	public static HL7Service getHL7Service() {
		return getServiceContext().getHL7Service();
	}
	/**
	 * @return user-related services
	 */
	public static UserService getUserService() {
		return getServiceContext().getUserService();
	}
	/**
	 * @return order service
	 */
	public static OrderService getOrderService() {
		return getServiceContext().getOrderService();
	}
	/**
	 * @return orderSet service
	 * @since 1.12
	 */
	public static OrderSetService getOrderSetService() {
		return getServiceContext().getOrderSetService();
	}
	/**
	 * @return form service
	 */
	public static FormService getFormService() {
		return getServiceContext().getFormService();
	}
	/**
	 * @return serialization service
	 * @since 1.5
	 */
	public static SerializationService getSerializationService() {
		return getServiceContext().getSerializationService();
	}
	/**
	 * @return logic service
	 */
	public static LogicService getLogicService() {
		return getServiceContext().getLogicService();
	}
	/**
	 * @return admin-related services
	 */
	public static AdministrationService getAdministrationService() {
		return getServiceContext().getAdministrationService();
	}
	/**
	 * @return MessageSourceService
	 */
	public static MessageSourceService getMessageSourceService() {
		return getServiceContext().getMessageSourceService();
	}
	/**
	 * @return scheduler service
	 */
	public static SchedulerService getSchedulerService() {
		return getServiceContext().getSchedulerService();
	}
	/**
	 * @return alert service
	 */
	public static AlertService getAlertService() {
		return getServiceContext().getAlertService();
	}
	/**
	 * @return program- and workflow-related services
	 */
	public static ProgramWorkflowService getProgramWorkflowService() {
		return getServiceContext().getProgramWorkflowService();
	}
	
	/**
	 * Get the message service.
	 *
	 * @return message service
	 */
	public static MessageService getMessageService() {
		MessageService ms = getServiceContext().getMessageService();
		try {
			// Message service dependencies
			if (ms.getMessagePreparator() == null) {
				ms.setMessagePreparator(getMessagePreparator());
			}
			if (ms.getMessageSender() == null) {
				ms.setMessageSender(getMessageSender());
			}
		}
		catch (Exception e) {
			log.error("Unable to create message service due", e);
		}
		return ms;
	}
	/**
	 * @return all of the configured properties that are used to configure the Mail Session in the Message Service
	 * These properties are defined as all properties that are prefixed with "mail." and this will return all such
	 * properties as defined in global properties, runtime properties, and/or system properties, with 
	 * system properties overriding runtime properties overriding global properties.
	 */
	public static Properties getMailProperties() {
		Properties p = new Properties();
		String prefix = "mail.";
		for (GlobalProperty gp : getAdministrationService().getGlobalPropertiesByPrefix(prefix)) {
			// Historically, some mail properties defined with underscores, support these for legacy compatibility
			if (gp.getProperty().equals("mail.transport_protocol")) {
				p.setProperty("mail.transport.protocol", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_host")) {
				p.setProperty("mail.smtp.host", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_port")) {
				p.setProperty("mail.smtp.port", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_auth")) {
				p.setProperty("mail.smtp.auth", gp.getPropertyValue());
			}
			else {
				p.setProperty(gp.getProperty(), gp.getPropertyValue());
			}
		}
		for (String runtimeProperty : runtimeProperties.stringPropertyNames()) {
			if (runtimeProperty.startsWith(prefix)) {
				p.setProperty(runtimeProperty, runtimeProperties.getProperty(runtimeProperty));
			}
		}
		for (String systemProperty : System.getProperties().stringPropertyNames()) {
			if (systemProperty.startsWith(prefix)) {
				p.setProperty(systemProperty, System.getProperty(systemProperty));
			}
		}
		return p;
	}
	/**
	 * Gets the mail session required by the mail message service. This function forces
	 * authentication via the getAdministrationService() method call
	 *
	 * @return a java mail session
	 */
	private static Session getMailSession() {
		if (mailSession == null) {
			synchronized (Context.class) {
				if (mailSession == null) {
					Authenticator auth = new Authenticator() {
						@Override
						public PasswordAuthentication getPasswordAuthentication() {
							return new PasswordAuthentication(
								ConfigUtil.getProperty("mail.user"),
								ConfigUtil.getProperty("mail.password")
							);
						}
					};
					mailSession = Session.getInstance(getMailProperties(), auth);
				}
			}
		}
		return mailSession;
	}
	/**
	 * Convenience method to allow us to change the configuration more easily. TODO Ideally, we
	 * would be using Spring's method injection to set the dependencies for the message service.
	 *
	 * @return the ServiceContext
	 */
	private static MessageSender getMessageSender() {
		return new MailMessageSender(getMailSession());
	}
	/**
	 * Convenience method to allow us to change the configuration more easily. TODO See todo for
	 * message sender.
	 *
	 * @return
	 */
	private static MessagePreparator getMessagePreparator() throws MessageException {
		return new VelocityMessagePreparator();
	}
	/**
	 * @return "active" user who has been authenticated, otherwise <code>null</code>
	 */
	public static User getAuthenticatedUser() {
		if (Daemon.isDaemonThread()) {
			return Daemon.getDaemonThreadUser();
		}
		return getUserContext().getAuthenticatedUser();
	}
	/**
	 * @return true if user has been authenticated in this context
	 */
	public static boolean isAuthenticated() {
		if (Daemon.isDaemonThread()) {
			return true;
		} else {
			try {
				return getAuthenticatedUser() != null;
			} catch (APIException e) {
				log.info("Could not get authenticated user inside called to isAuthenticated(), assuming no user context has been defined", e);
				return false;
			}
		}
	}
	/**
	 * logs out the "active" (authenticated) user within context
	 *
	 * @see #authenticate
	 * <strong>Should</strong> not fail if session hasn't been opened yet
	 */
	public static void logout() {
		if (!isSessionOpen()) {
			return; // fail early if there isn't even a session open
		}
		log.debug("Logging out : {}", getAuthenticatedUser());
		getUserContext().logout();
		// reset the UserContext object (usually cleared out by closeSession()
		// soon after this)
		setUserContext(new UserContext(getAuthenticationScheme()));
	}
	/**
	 * Convenience method. Passes through to userContext.getAllRoles(User)
	 */
	public static Set<Role> getAllRoles(User user) throws Exception {
		return getUserContext().getAllRoles();
	}
	/**
	 * Convenience method. Passes through to userContext.hasPrivilege(String)
	 *
	 * <strong>Should</strong> give daemon user full privileges
	 */
	public static boolean hasPrivilege(String privilege) {
		// the daemon threads have access to all things
		if (Daemon.isDaemonThread()) {
			return true;
		}
		return getUserContext().hasPrivilege(privilege);
	}
	/**
	 * Throws an exception if the currently authenticated user does not have the specified
	 * privilege.
	 *
	 * @param privilege
	 * @throws ContextAuthenticationException
	 */
	public static void requirePrivilege(String privilege) throws ContextAuthenticationException {
		if (!hasPrivilege(privilege)) {
			String errorMessage;
			if (StringUtils.isNotBlank(privilege)) {
				errorMessage = Context.getMessageSourceService().getMessage("error.privilegesRequired",
						new Object[] { privilege }, null);
			} else {
				//Should we even be here if the privilege is blank?
				errorMessage = Context.getMessageSourceService().getMessage("error.privilegesRequiredNoArgs");
			}
			throw new ContextAuthenticationException(errorMessage);
		}
	}
	/**
	 * Convenience method. Passes through to {@link UserContext#addProxyPrivilege(String)}
	 */
	public static void addProxyPrivilege(String privilege) {
		getUserContext().addProxyPrivilege(privilege);
	}
	/**
	 * Convenience method. Passes through to {@link UserContext#removeProxyPrivilege(String)}
	 */
	public static void removeProxyPrivilege(String privilege) {
		getUserContext().removeProxyPrivilege(privilege);
	}
	/**
	 * Convenience method. Passes through to {@link UserContext#setLocale(Locale)}
	 */
	public static void setLocale(Locale locale) {
		getUserContext().setLocale(locale);
	}
	/**
	 * Convenience method. Passes through to {@link UserContext#getLocale()}
	 *
	 * <strong>Should</strong> not fail if session hasn't been opened
	 */
	public static Locale getLocale() {
		// if a session hasn't been opened, just fetch the default
		if (!isSessionOpen()) {
			return LocaleUtility.getDefaultLocale();
		}
		return getUserContext().getLocale();
	}
	/**
	 * Used to define a unit of work. All "units of work" should be surrounded by openSession and
	 * closeSession calls.
	 */
	public static void openSession() {
		log.trace("opening session");
		setUserContext(new UserContext(getAuthenticationScheme())); // must be cleared out in
		// closeSession()
		getContextDAO().openSession();
	}
	/**
	 * Used to define a unit of work. All "units of work" should be surrounded by openSession and
	 * closeSession calls.
	 */
	public static void closeSession() {
		log.trace("closing session");
		clearUserContext(); // because we set a UserContext on the current
		// thread in openSession()
		getContextDAO().closeSession();
	}
	/**
	 * Used to define a unit of work which does not require clearing out the currently authenticated
	 * user. Remember to call closeSessionWithCurrentUser in a, preferably, finally block after this
	 * work.
	 *
	 * @since 1.10
	 */
	public static void openSessionWithCurrentUser() {
		getContextDAO().openSession();
	}
	/**
	 * Used when the a unit of work which started with a call for openSessionWithCurrentUser has
	 * finished. This should be in a, preferably, finally block.
	 *
	 * @since 1.10
	 */
	public static void closeSessionWithCurrentUser() {
		getContextDAO().closeSession();
	}
	/**
	 * Clears cached changes made so far during this unit of work without writing them to the
	 * database. If you call this method, and later call closeSession() or flushSession() your
	 * changes are still lost.
	 */
	public static void clearSession() {
		log.trace("clearing session");
		getContextDAO().clearSession();
	}
	/**
	 * Forces any changes made so far in this unit of work to be written to the database
	 *
	 * @since 1.6
	 */
	public static void flushSession() {
		log.trace("flushing session");
		getContextDAO().flushSession();
	}
	/**
	 * This method tells whether {@link #openSession()} has been called or not already. If it hasn't
	 * been called, some methods won't work correctly because a {@link UserContext} isn't available.
	 *
	 * @return true if {@link #openSession()} has been called already.
	 * @since 1.5
	 * <strong>Should</strong> return true if session is closed
	 */
	public static boolean isSessionOpen() {
		return userContextHolder.get() != null;
	}
	/**
	 * Used to re-read the state of the given instance from the underlying database.
	 * @since 2.0
	 * @param obj The object to refresh from the database in the session
	 */
	public static void refreshEntity(Object obj) {
		log.trace("refreshing object: {}", obj);
		getContextDAO().refreshEntity(obj);
	}
	/**
	 * Used to clear a cached object out of a session in the middle of a unit of work. Future
	 * updates to this object will not be saved. Future gets of this object will not fetch this
	 * cached copy
	 *
	 * @param obj The object to evict/remove from the session
	 */
	public static void evictFromSession(Object obj) {
		log.trace("clearing session");
		getContextDAO().evictFromSession(obj);
	}
	/**
	 * Evicts the entity data for a particular entity instance.
	 *
	 * @param object entity instance to evict from the DB cache
	 */
	public static void evictEntity(OpenmrsObject object) {
		log.debug("Clearing DB cache for entity: {} with id: {}", object.getClass(), object.getId());
		getContextDAO().evictEntity(object);
	}
	
	/**
	 * Evicts all entity data of a particular class from the given region.
	 * 
	 * @param entityClass entity class to evict from the DB cache
	 */
	public static void evictAllEntities(Class<?> entityClass) {
		log.debug("Clearing DB cache for entities of type: {}", entityClass);
		getContextDAO().evictAllEntities(entityClass);
	}
	
	/**
	 * Evicts data from all cache regions.
	 */
	public static void clearEntireCache() {
		log.debug("Clearing DB cache from all regions");
		getContextDAO().clearEntireCache();
	}
	
	/**
	 * Starts the OpenMRS System Should be called prior to any kind of activity
	 *
	 * @param props Runtime properties to use for startup
	 * @throws InputRequiredException if the {@link DatabaseUpdater} has determined that updates
	 *             cannot continue without input from the user
	 * @throws DatabaseUpdateException if database updates are required, see
	 *             {@link DatabaseUpdater#executeChangelog()}
	 * @throws ModuleMustStartException if a module that should be started is not able to
	 * @see InputRequiredException#getRequiredInput() InputRequiredException#getRequiredInput() for
	 *      the required question/datatypes
	 */
	public static synchronized void startup(Properties props) throws DatabaseUpdateException, InputRequiredException,
	ModuleMustStartException {
		// do any context database specific startup
		getContextDAO().startup(props);
		// find/set/check whether the current database version is compatible
		checkForDatabaseUpdates(props);
		// this should be first in the startup routines so that the application
		// data directory can be set from the runtime properties
		OpenmrsUtil.startup(props);
		openSession();
		clearSession();
		// add any privileges/roles that /must/ exist for openmrs to work
		// correctly.
		checkCoreDataset();
		getContextDAO().setupSearchIndex();
		// Loop over each module and startup each with these custom properties
		ModuleUtil.startup(props);
	}
	/**
	 * Starts the OpenMRS System in a _non-webapp_ environment<br>
	 * <br>
	 * <b>Note:</b> This method calls {@link Context#openSession()}, so you must call
	 * {@link Context#closeSession()} somewhere on the same thread of this application so as to not
	 * leak memory.
	 *
	 * @param url database url like "jdbc:mysql://localhost:3306/openmrs?autoReconnect=true"
	 * @param username Connection username
	 * @param password Connection password
	 * @param properties Other startup properties
	 * @throws InputRequiredException if the {@link DatabaseUpdater} has determined that updates
	 *             cannot continue without input from the user
	 * @throws DatabaseUpdateException if the database must be updated. See {@link DatabaseUpdater}
	 * @throws ModuleMustStartException if a module that should start is not able to
	 * @see #startup(Properties)
	 * @see InputRequiredException#getRequiredInput() InputRequiredException#getRequiredInput() for
	 *      the required question/datatypes
	 */
	public static synchronized void startup(String url, String username, String password, Properties properties)
			throws DatabaseUpdateException, InputRequiredException, ModuleMustStartException {
		if (properties == null) {
			properties = new Properties();
		}
		properties.put("connection.url", url);
		properties.put("connection.username", username);
		properties.put("connection.password", password);
		setRuntimeProperties(properties);
		openSession(); // so that the startup method can use proxyPrivileges
		startup(properties);
		// start the scheduled tasks
		SchedulerUtil.startup(properties);
		closeSession();
	}
	/**
	 * Stops the OpenMRS System Should be called after all activity has ended and application is
	 * closing
	 */
	public static void shutdown() {
		log.debug("Shutting down the scheduler");
		try {
			// Needs to be shutdown before Hibernate
			SchedulerUtil.shutdown();
		}
		catch (Exception e) {
			log.warn("Error while shutting down scheduler service", e);
		}
		log.debug("Shutting down the modules");
		try {
			ModuleUtil.shutdown();
		}
		catch (Exception e) {
			log.warn("Error while shutting down module system", e);
		}
		log.debug("Shutting down the context");
		try {
			ContextDAO dao = null;
			try {
				dao = getContextDAO();
			}
			catch (APIException e) {
				// pass
			}
			if (dao != null) {
				dao.shutdown();
			}
		}
		catch (Exception e) {
			log.warn("Error while shutting down context dao", e);
		}
	}
	/**
	 * Used for getting services not in the previous get*Service() calls
	 *
	 * @param cls The Class of the service to get
	 * @return The requested Service
	 * <strong>Should</strong> return the same object when called multiple times for the same class
	 */
	public static <T> T getService(Class<? extends T> cls) {
		return getServiceContext().getService(cls);
	}
	/**
	 * Adds an AOP advisor around the given Class <code>cls</code>
	 * <p>
	 * Advisors can wrap around a method and effect the method before or after
	 *
	 * @param cls
	 * @param advisor
	 */
	public static void addAdvisor(Class cls, Advisor advisor) {
		getServiceContext().addAdvisor(cls, advisor);
	}
	/**
	 * Adds an AOP advice object around the given Class <code>cls</code>
	 * <p>
	 * Advice comes in the form of before or afterReturning methods
	 *
	 * @param cls
	 * @param advice
	 */
	public static void addAdvice(Class cls, Advice advice) {
		getServiceContext().addAdvice(cls, advice);
	}
	/**
	 * Removes the given AOP advisor from Class <code>cls</code>
	 *
	 * @param cls
	 * @param advisor
	 */
	public static void removeAdvisor(Class cls, Advisor advisor) {
		getServiceContext().removeAdvisor(cls, advisor);
	}
	/**
	 * Removes the given AOP advice object from Class <code>cls</code>
	 *
	 * @param cls
	 * @param advice
	 */
	public static void removeAdvice(Class cls, Advice advice) {
		getServiceContext().removeAdvice(cls, advice);
	}
	/**
	 * Runs through the core data (e.g. privileges, roles, and global properties) and adds them if
	 * necessary.
	 */
	public static void checkCoreDataset() {
		// setting core roles
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ROLES);
			Set<String> currentRoleNames = new HashSet<>();
			for (Role role : Context.getUserService().getAllRoles()) {
				currentRoleNames.add(role.getRole().toUpperCase());
			}
			Map<String, String> map = OpenmrsUtil.getCoreRoles();
			for (Map.Entry<String, String> entry : map.entrySet()) {
				String roleName = entry.getKey();
				if (!currentRoleNames.contains(roleName.toUpperCase())) {
					Role role = new Role();
					role.setRole(roleName);
					role.setDescription(entry.getValue());
					Context.getUserService().saveRole(role);
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core roles for openmrs system", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ROLES);
		}
		// setting core privileges
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_PRIVILEGES);
			Set<String> currentPrivilegeNames = new HashSet<>();
			for (Privilege privilege : Context.getUserService().getAllPrivileges()) {
				currentPrivilegeNames.add(privilege.getPrivilege().toUpperCase());
			}
			Map<String, String> map = OpenmrsUtil.getCorePrivileges();
			for (Map.Entry<String, String> entry : map.entrySet()) {
				String privilegeName = entry.getKey();
				if (!currentPrivilegeNames.contains(privilegeName.toUpperCase())) {
					Privilege p = new Privilege();
					p.setPrivilege(privilegeName);
					p.setDescription(entry.getValue());
					Context.getUserService().savePrivilege(p);
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core privileges", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_PRIVILEGES);
		}
		// setting core global properties
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			Context.addProxyPrivilege(PrivilegeConstants.GET_GLOBAL_PROPERTIES);
			Set<String> currentPropNames = new HashSet<>();
			Map<String, GlobalProperty> propsMissingDescription = new HashMap<>();
			Map<String, GlobalProperty> propsMissingDatatype = new HashMap<>();
			for (GlobalProperty prop : Context.getAdministrationService().getAllGlobalProperties()) {
				currentPropNames.add(prop.getProperty().toUpperCase());
				if (prop.getDescription() == null) {
					propsMissingDescription.put(prop.getProperty().toUpperCase(), prop);
				}
				if (prop.getDatatypeClassname() == null) {
					propsMissingDatatype.put(prop.getProperty().toUpperCase(), prop);
				}
			}
			for (GlobalProperty coreProp : OpenmrsConstants.CORE_GLOBAL_PROPERTIES()) {
				String corePropName = coreProp.getProperty().toUpperCase();
				// if the prop doesn't exist, save it
				if (!currentPropNames.contains(corePropName)) {
					Context.getAdministrationService().saveGlobalProperty(coreProp);
					currentPropNames.add(corePropName); // add to list in case
					// of duplicates
				} else {
					// if the prop is missing its description, update it
					GlobalProperty propToUpdate = propsMissingDescription.get(corePropName);
					if (propToUpdate != null) {
						propToUpdate.setDescription(coreProp.getDescription());
						Context.getAdministrationService().saveGlobalProperty(propToUpdate);
					}
					// set missing datatypes
					propToUpdate = propsMissingDatatype.get(corePropName);
					if (propToUpdate != null && coreProp.getDatatypeClassname() != null) {
						propToUpdate.setDatatypeClassname(coreProp.getDatatypeClassname());
						propToUpdate.setDatatypeConfig(coreProp.getDatatypeConfig());
						propToUpdate.setPreferredHandlerClassname(coreProp.getPreferredHandlerClassname());
						propToUpdate.setHandlerConfig(coreProp.getHandlerConfig());
						Context.getAdministrationService().saveGlobalProperty(propToUpdate);
					}
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core global properties", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			Context.removeProxyPrivilege(PrivilegeConstants.GET_GLOBAL_PROPERTIES);
		}
		// setting default validation rule
		AdministrationService as = Context.getAdministrationService();
		Boolean disableValidation = Boolean.valueOf(as.getGlobalProperty(OpenmrsConstants.GP_DISABLE_VALIDATION, "false"));
		ValidateUtil.setDisableValidation(disableValidation);
		PersonName.setFormat(Context.getAdministrationService().getGlobalProperty(
				OpenmrsConstants.GLOBAL_PROPERTY_LAYOUT_NAME_FORMAT));
		Allergen.setOtherNonCodedConceptUuid(Context.getAdministrationService().getGlobalProperty(
				OpenmrsConstants.GP_ALLERGEN_OTHER_NON_CODED_UUID));
	}
	/**
	 * Runs any needed updates on the current database if the user has the allow_auto_update runtime
	 * property set to true. If not set to true, then {@link #updateDatabase(Map)} must be called.<br>
	 * <br>
	 * If an {@link InputRequiredException} is thrown, a call to {@link #updateDatabase(Map)} is
	 * required with a mapping from question prompt to user answer.
	 *
	 * @param props the runtime properties
	 * @throws InputRequiredException if the {@link DatabaseUpdater} has determined that updates
	 *             cannot continue without input from the user
	 * @see InputRequiredException#getRequiredInput() InputRequiredException#getRequiredInput() for
	 *      the required question/datatypes
	 */
	private static void checkForDatabaseUpdates(Properties props) throws DatabaseUpdateException, InputRequiredException {
		boolean updatesRequired;
		try {
			updatesRequired = DatabaseUpdater.updatesRequired();
		}
		catch (Exception e) {
			throw new DatabaseUpdateException("Unable to check if database updates are required", e);
		}
		// this must be the first thing run in case it changes database mappings
		if (updatesRequired) {
			if (DatabaseUpdater.allowAutoUpdate()) {
				DatabaseUpdater.executeChangelog();
			} else {
				throw new DatabaseUpdateException(
						"Database updates are required.  Call Context.updateDatabase() before .startup() to continue.");
			}
		}
	}
	/**
	 * Updates the openmrs database to the latest. This is only needed if using the API alone. <br>
	 * <br>
	 * The typical use-case would be: Try to {@link #startup(String, String, String, Properties)},
	 * if that fails, call this method to get the database up to speed.
	 *
	 * @param userInput (can be null) responses from the user about needed input
	 * @throws DatabaseUpdateException if an error occurred while updating
	 * @since 1.5
	 * @deprecated as of 2.4
	 * 
	 */
	@Deprecated
	public static void updateDatabase(Map<String, Object> userInput) throws DatabaseUpdateException {
		throw new UnsupportedOperationException("As of 2.4, this method is not longer implemented");
	}
	/**
	 * Gets the simple date format for the current user's locale. The format will be similar in size
	 * to mm/dd/yyyy
	 *
	 * @return SimpleDateFormat for the user's current locale
	 * @see org.openmrs.util.OpenmrsUtil#getDateFormat(Locale)
	 * <strong>Should</strong> return a pattern with four y characters in it
	 */
	public static SimpleDateFormat getDateFormat() {
		return OpenmrsUtil.getDateFormat(getLocale());
	}
	/**
	 * Gets the simple time format for the current user's locale. The format will be similar to
	 * hh:mm a
	 *
	 * @return SimpleDateFormat for the user's current locale
	 * @see org.openmrs.util.OpenmrsUtil#getTimeFormat(Locale)
	 * <strong>Should</strong> return a pattern with two h characters in it
	 */
	public static SimpleDateFormat getTimeFormat() {
		return OpenmrsUtil.getTimeFormat(getLocale());
	}
	/**
	 * Gets the simple datetime format for the current user's locale. The format will be similar to
	 * mm/dd/yyyy hh:mm a
	 *
	 * @return SimpleDateFormat for the user's current locale
	 * @see org.openmrs.util.OpenmrsUtil#getDateTimeFormat(Locale)
	 * <strong>Should</strong> return a pattern with four y characters and two h characters in it
	 */
	public static SimpleDateFormat getDateTimeFormat() {
		return OpenmrsUtil.getDateTimeFormat(getLocale());
	}
	/**
	 * @return true/false whether the service context is currently being refreshed
	 * @see org.openmrs.api.context.ServiceContext#isRefreshingContext()
	 */
	public static boolean isRefreshingContext() {
		return getServiceContext().isRefreshingContext();
	}
	/**
	 * @since 1.5
	 * @see ServiceContext#getRegisteredComponents(Class)
	 */
	public static <T> List<T> getRegisteredComponents(Class<T> type) {
		return getServiceContext().getRegisteredComponents(type);
	}
	/**
	 * @see ServiceContext#getRegisteredComponent(String, Class)
	 * @since 1.9.4
	 */
	public static <T> T getRegisteredComponent(String beanName, Class<T> type) throws APIException {
		return getServiceContext().getRegisteredComponent(beanName, type);
	}
	/**
	 * @see ServiceContext#getModuleOpenmrsServices(String)
	 * @since 1.9
	 */
	public static List<OpenmrsService> getModuleOpenmrsServices(String modulePackage) {
		return getServiceContext().getModuleOpenmrsServices(modulePackage);
	}
	/**
	 * @since 1.9
	 * @see ServiceContext#getVisitService()
	 */
	public static VisitService getVisitService() {
		return getServiceContext().getVisitService();
	}
	/**
	 * @since 1.9
	 * @see ServiceContext#getProviderService()
	 */
	public static ProviderService getProviderService() {
		return getServiceContext().getProviderService();
	}
	/**
	 * @since 1.9
	 * @see ServiceContext#getDatatypeService()
	 */
	public static DatatypeService getDatatypeService() {
		return getServiceContext().getDatatypeService();
	}
	/**
	 * Add or replace a property in the config properties list
	 *
	 * @param key name of the property
	 * @param value value of the property
	 * @since 1.9
	 */
	public static void addConfigProperty(Object key, Object value) {
		configProperties.put(key, value);
	}
	/**
	 * Remove a property from the list of config properties
	 *
	 * @param key name of the property
	 * @since 1.9
	 */
	public static void removeConfigProperty(Object key) {
		configProperties.remove(key);
	}
	/**
	 * Get the config properties that have been added to this OpenMRS instance
	 *
	 * @return copy of the module properties
	 * @since 1.9
	 */
	public static Properties getConfigProperties() {
		Properties props = new Properties();
		props.putAll(configProperties);
		return props;
	}
	/**
	 * Updates the search index. It is a blocking operation, which may take even a few minutes
	 * depending on the index size.
	 * <p>
	 * There is no need to call this method in normal usage since the index is automatically updated
	 * whenever DB transactions are committed.
	 * <p>
	 * The method is designated to be used in tests, which rollback transactions. Note that if the
	 * transaction is rolled back, changes to the index will not be reverted.
	 *
	 * @since 1.11
	 */
	public static void updateSearchIndex() {
		getContextDAO().updateSearchIndex();
	}
	/**
	 * Updates the search index. It is an asynchronous operation.
	 * <p>
	 * There is no need to call this method in normal usage since the index is automatically updated
	 * whenever DB transactions are committed.
	 * <p>
	 *
	 * @return object representing the result of the started asynchronous operation
	 */
	public static Future<?> updateSearchIndexAsync() {
		return getContextDAO().updateSearchIndexAsync();
	}
	/**
	 * Updates the search index for objects of the given type.
	 *
	 * @see #updateSearchIndex()
	 * @param type
	 * @since 1.11
	 */
	public static void updateSearchIndexForType(Class<?> type) {
		getContextDAO().updateSearchIndexForType(type);
	}
	/**
	 * Updates the search index for the given object.
	 *
	 * @see #updateSearchIndex()
	 * @param object
	 * @since 1.11
	 */
	public static void updateSearchIndexForObject(Object object) {
		getContextDAO().updateSearchIndexForObject(object);
	}
	/**
	 * @see org.openmrs.api.context.ServiceContext#setUseSystemClassLoader(boolean)
	 * @since 1.10
	 */
	public static void setUseSystemClassLoader(boolean useSystemClassLoader) {
		getServiceContext().setUseSystemClassLoader(useSystemClassLoader);
	}
	/**
	 * @see org.openmrs.api.context.ServiceContext#isUseSystemClassLoader()
	 * @since 1.10
	 */
	public static boolean isUseSystemClassLoader() {
		return getServiceContext().isUseSystemClassLoader();
	}
	/**
	 * @return a Connection from the OpenMRS database connection pool
	 * @since 2.5.7
	 */
	public static Connection getDatabaseConnection() {
		return getContextDAO().getDatabaseConnection();
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import javax.persistence.Transient;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.envers.NotAudited;
import org.hibernate.search.annotations.Analyze;
import org.hibernate.search.annotations.ContainedIn;
import org.hibernate.search.annotations.DateBridge;
import org.hibernate.search.annotations.DocumentId;
import org.hibernate.search.annotations.EncodingType;
import org.hibernate.search.annotations.Field;
import org.hibernate.search.annotations.Resolution;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;
/**
 * A Person in the system. This can be either a small person stub, or indicative of an actual
 * Patient in the system. This class holds the generic person things that both the stubs and
 * patients share. Things like birthdate, names, addresses, and attributes are all generified into
 * the person table (and hence this super class)
 * 
 * @see org.openmrs.Patient
 */
@Audited
public class Person extends BaseChangeableOpenmrsData {
	
	public static final long serialVersionUID = 2L;
	
	private static final Logger log = LoggerFactory.getLogger(Person.class);
	
	@DocumentId
	protected Integer personId;
	
	private Set<PersonAddress> addresses = null;
	
	@ContainedIn
	private Set<PersonName> names = null;
	
	@ContainedIn
	private Set<PersonAttribute> attributes = null;
	
	@Field
	private String gender;
	
	@Field(analyze = Analyze.YES)
	@DateBridge(encoding = EncodingType.STRING, resolution = Resolution.DAY)
	private Date birthdate;
	
	private Date birthtime;
	
	private Boolean birthdateEstimated = false;
	
	private Boolean deathdateEstimated = false;
	
	@Field
	private Boolean dead = false;
	
	private Date deathDate;
	
	private Concept causeOfDeath;
	
	private String causeOfDeathNonCoded;
	private User personCreator;
	
	private Date personDateCreated;
	private User personChangedBy;
	
	private Date personDateChanged;
	
	private Boolean personVoided = false;
	private User personVoidedBy;
	
	private Date personDateVoided;
	
	private String personVoidReason;
	
	@Field
	@NotAudited
	private boolean isPatient;
	
	/**
	 * Convenience map from PersonAttributeType.name to PersonAttribute.<br>
	 * <br>
	 * This is "cached" for each user upon first load. When an attribute is changed, the cache is
	 * cleared and rebuilt on next access.
	 */
	@Transient
	Map<String, PersonAttribute> attributeMap = null;
	
	@Transient
	private Map<String, PersonAttribute> allAttributeMap = null;
	
	/**
	 * default empty constructor
	 */
	public Person() {
	}
	
	/**
	 * This constructor is used to build a new Person object copy from another person object
	 * (usually a patient or a user subobject). All attributes are copied over to the new object.
	 * NOTE! All child collection objects are copied as pointers, each individual element is not
	 * copied. <br>
	 *
	 * @param person Person to create this person object from
	 */
	public Person(Person person) {
		if (person == null) {
			return;
		}
		
		personId = person.getPersonId();
		setUuid(person.getUuid());
		addresses = person.getAddresses();
		names = person.getNames();
		attributes = person.getAttributes();
		
		gender = person.getGender();
		birthdate = person.getBirthdate();
		birthtime = person.getBirthDateTime();
		birthdateEstimated = person.getBirthdateEstimated();
		deathdateEstimated = person.getDeathdateEstimated();
		dead = person.getDead();
		deathDate = person.getDeathDate();
		causeOfDeath = person.getCauseOfDeath();
		causeOfDeathNonCoded = person.getCauseOfDeathNonCoded();
		// base creator/voidedBy/changedBy info is not copied here
		// because that is specific to and will be recreated
		// by the subobject upon save
		
		setPersonCreator(person.getPersonCreator());
		setPersonDateCreated(person.getPersonDateCreated());
		setPersonChangedBy(person.getPersonChangedBy());
		setPersonDateChanged(person.getPersonDateChanged());
		setPersonVoided(person.getPersonVoided());
		setPersonVoidedBy(person.getPersonVoidedBy());
		setPersonDateVoided(person.getPersonDateVoided());
		setPersonVoidReason(person.getPersonVoidReason());
		
		setPatient(person.getIsPatient());
	}
	
	/**
	 * Default constructor taking in the primary key personId value
	 * 
	 * @param personId Integer internal id for this person
	 * <strong>Should</strong> set person id
	 */
	public Person(Integer personId) {
		this.personId = personId;
	}
	
	// Property accessors
	
	/**
	 * @return Returns the personId.
	 */
	public Integer getPersonId() {
		return personId;
	}
	
	/**
	 * @param personId The personId to set.
	 */
	public void setPersonId(Integer personId) {
		this.personId = personId;
	}
	
	/**
	 * @return person's gender
	 */
	public String getGender() {
		return this.gender;
	}
	
	/**
	 * @param gender person's gender
	 */
	public void setGender(String gender) {
		this.gender = gender;
	}
	
	/**
	 * @return person's date of birth
	 */
	public Date getBirthdate() {
		return this.birthdate;
	}
	
	/**
	 * @param birthdate person's date of birth
	 */
	public void setBirthdate(Date birthdate) {
		this.birthdate = birthdate;
	}
	
	/**
	 * @return true if person's birthdate is estimated
	 * @deprecated as of 2.0, use {@link #getBirthdateEstimated()}
	 */
	@Deprecated
	@JsonIgnore
	public Boolean isBirthdateEstimated() {
		return getBirthdateEstimated();
	}
	
	public Boolean getBirthdateEstimated() {
		return birthdateEstimated;
	}
	
	/**
	 * @param birthdateEstimated true if person's birthdate is estimated
	 */
	public void setBirthdateEstimated(Boolean birthdateEstimated) {
		this.birthdateEstimated = birthdateEstimated;
	}
	
	public Boolean getDeathdateEstimated() {
		return this.deathdateEstimated;
	}
	
	/**
	 * @param deathdateEstimated true if person's deathdate is estimated
	 */
	public void setDeathdateEstimated(Boolean deathdateEstimated) {
		this.deathdateEstimated = deathdateEstimated;
	}
	
	/**
	 * @param birthtime person's time of birth
	 */
	public void setBirthtime(Date birthtime) {
		this.birthtime = birthtime;
	}
	
	/**
	 * @return person's time of birth with the date portion set to the date from person's birthdate
	 */
	public Date getBirthDateTime() {
		if (birthdate != null && birthtime != null) {
			String birthDateString = new SimpleDateFormat("yyyy-MM-dd").format(birthdate);
			String birthTimeString = new SimpleDateFormat("HH:mm:ss").format(birthtime);
			
			try {
				return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(birthDateString + " " + birthTimeString);
			}
			catch (ParseException e) {
				log.error("Failed to parse birth date string", e);
			}
		}
		return null;
	}
	
	/**
	 * @return person's time of birth.
	 */
	public Date getBirthtime() {
		return this.birthtime;
	}
	
	/**
	 * @return Returns the death status.
	 * @deprecated as of 2.0, use {@link #getDead()}
	 */
	@Deprecated
	@JsonIgnore
	public Boolean isDead() {
		return getDead();
	}
	
	/**
	 * @return Returns the death status.
	 */
	public Boolean getDead() {
		return dead;
	}
	
	/**
	 * @param dead The dead to set.
	 */
	public void setDead(Boolean dead) {
		this.dead = dead;
	}
	
	/**
	 * @return date of person's death
	 */
	public Date getDeathDate() {
		return this.deathDate;
	}
	
	/**
	 * @param deathDate date of person's death
	 */
	public void setDeathDate(Date deathDate) {
		this.deathDate = deathDate;
		if (deathDate != null) {
			setDead(true);
		}
	}
	
	/**
	 * @return cause of person's death
	 */
	public Concept getCauseOfDeath() {
		return this.causeOfDeath;
	}
	
	/**
	 * @param causeOfDeath cause of person's death
	 */
	public void setCauseOfDeath(Concept causeOfDeath) {
		this.causeOfDeath = causeOfDeath;
	}
	
	/**
	 * This method returns the non coded cause of death
	 * 
	 * @return non coded cause of death
	 * @since 2.2.0
	 */
	public String getCauseOfDeathNonCoded() {
		return this.causeOfDeathNonCoded;
	}
	
	/**
	 * This method sets the non coded cause of death with the value given as parameter
	 * 
	 * @param causeOfDeathNonCoded is a String that describes as text the cause of death
	 * @since 2.2.0
	 * <strong>Should</strong> not fail with null causeOfDeathNonCoded
	 * <strong>Should</strong> set the attribute causeOfDeathNonCoded with the given parameter
	 */
	public void setCauseOfDeathNonCoded(String causeOfDeathNonCoded) {
		this.causeOfDeathNonCoded = causeOfDeathNonCoded;
	}
	
	/**
	 * @return list of known addresses for person
	 * @see org.openmrs.PersonAddress
	 * <strong>Should</strong> not get voided addresses
	 * <strong>Should</strong> not fail with null addresses
	 */
	public Set<PersonAddress> getAddresses() {
		if (addresses == null) {
			addresses = new TreeSet<>();
		}
		return this.addresses;
	}
	
	/**
	 * @param addresses Set&lt;PersonAddress&gt; list of known addresses for person
	 * @see org.openmrs.PersonAddress
	 */
	public void setAddresses(Set<PersonAddress> addresses) {
		this.addresses = addresses;
	}
	
	/**
	 * @return all known names for person
	 * @see org.openmrs.PersonName
	 * <strong>Should</strong> not get voided names
	 * <strong>Should</strong> not fail with null names
	 */
	public Set<PersonName> getNames() {
		if (names == null) {
			names = new TreeSet<>();
		}
		return this.names;
	}
	
	/**
	 * @param names update all known names for person
	 * @see org.openmrs.PersonName
	 */
	public void setNames(Set<PersonName> names) {
		this.names = names;
	}
	
	/**
	 * @return all known attributes for person
	 * @see org.openmrs.PersonAttribute
	 * <strong>Should</strong> not get voided attributes
	 * <strong>Should</strong> not fail with null attributes
	 */
	public Set<PersonAttribute> getAttributes() {
		if (attributes == null) {
			attributes = new TreeSet<>();
		}
		return this.attributes;
	}
	
	/**
	 * Returns only the non-voided attributes for this person
	 * 
	 * @return list attributes
	 * <strong>Should</strong> not get voided attributes
	 * <strong>Should</strong> not fail with null attributes
	 */
	public List<PersonAttribute> getActiveAttributes() {
		List<PersonAttribute> attrs = new ArrayList<>();
		for (PersonAttribute attr : getAttributes()) {
			if (!attr.getVoided()) {
				attrs.add(attr);
			}
		}
		return attrs;
	}
	
	/**
	 * @param attributes update all known attributes for person
	 * @see org.openmrs.PersonAttribute
	 */
	public void setAttributes(Set<PersonAttribute> attributes) {
		this.attributes = attributes;
		attributeMap = null;
		allAttributeMap = null;
	}
	
	// Convenience methods
	
	/**
	 * Convenience method to add the <code>attribute</code> to this person's attribute list if the
	 * attribute doesn't exist already.<br>
	 * <br>
	 * Voids any current attribute with type = <code>newAttribute.getAttributeType()</code><br>
	 * <br>
	 * NOTE: This effectively limits persons to only one attribute of any given type **
	 * 
	 * @param newAttribute PersonAttribute to add to the Person
	 * <strong>Should</strong> fail when new attribute exist
	 * <strong>Should</strong> fail when new atribute are the same type with same value
	 * <strong>Should</strong> void old attribute when new attribute are the same type with different value
	 * <strong>Should</strong> remove attribute when old attribute are temporary
	 * <strong>Should</strong> not save an attribute with a null value
	 * <strong>Should</strong> not save an attribute with a blank string value
	 * <strong>Should</strong> void old attribute when a null or blank string value is added
	 */
	public void addAttribute(PersonAttribute newAttribute) {
		newAttribute.setPerson(this);
		boolean newIsNull = !StringUtils.hasText(newAttribute.getValue());
		
		for (PersonAttribute currentAttribute : getActiveAttributes()) {
			if (currentAttribute.equals(newAttribute)) {
				// if we have the same PersonAttributeId, don't add the new attribute
				return;
			} else if (currentAttribute.getAttributeType().equals(newAttribute.getAttributeType())) {
				if (currentAttribute.getValue() != null && currentAttribute.getValue().equals(newAttribute.getValue())) {
					// this person already has this attribute
					return;
				}
				
				// if the to-be-added attribute isn't already voided itself
				// and if we have the same type, different value
				if (!newAttribute.getVoided() || newIsNull) {
					if (currentAttribute.getCreator() != null) {
						currentAttribute.voidAttribute("New value: " + newAttribute.getValue());
					} else {
						// remove the attribute if it was just temporary (didn't have a creator
						// attached to it yet)
						removeAttribute(currentAttribute);
					}
				}
			}
		}
		attributeMap = null;
		allAttributeMap = null;
		if (!OpenmrsUtil.collectionContains(attributes, newAttribute) && !newIsNull) {
			attributes.add(newAttribute);
		}
	}
	
	/**
	 * Convenience method to get the <code>attribute</code> from this person's attribute list if the
	 * attribute exists already.
	 * 
	 * @param attribute
	 * <strong>Should</strong> not fail when person attribute is null
	 * <strong>Should</strong> not fail when person attribute is not exist
	 * <strong>Should</strong> remove attribute when exist
	 */
	public void removeAttribute(PersonAttribute attribute) {
		if (attributes != null && attributes.remove(attribute)) {
			attributeMap = null;
			allAttributeMap = null;
		}
	}
	
	/**
	 * Convenience Method to return the first non-voided person attribute matching a person
	 * attribute type. <br>
	 * <br>
	 * Returns null if this person has no non-voided {@link PersonAttribute} with the given
	 * {@link PersonAttributeType}, the given {@link PersonAttributeType} is null, or this person
	 * has no attributes.
	 * 
	 * @param pat the PersonAttributeType to look for (can be a stub, see
	 *            {@link PersonAttributeType#equals(Object)} for how its compared)
	 * @return PersonAttribute that matches the given type
	 * <strong>Should</strong> not fail when attribute type is null
	 * <strong>Should</strong> not return voided attribute
	 * <strong>Should</strong> return null when existing PersonAttributeType is voided
	 */
	public PersonAttribute getAttribute(PersonAttributeType pat) {
		if (pat != null) {
			for (PersonAttribute attribute : getAttributes()) {
				if (pat.equals(attribute.getAttributeType()) && !attribute.getVoided()) {
					return attribute;
				}
			}
		}
		return null;
	}
	
	/**
	 * Convenience method to get this person's first attribute that has a PersonAttributeType.name
	 * equal to <code>attributeName</code>.<br>
	 * <br>
	 * Returns null if this person has no non-voided {@link PersonAttribute} with the given type
	 * name, the given name is null, or this person has no attributes.
	 * 
	 * @param attributeName the name string to match on
	 * @return PersonAttribute whose {@link PersonAttributeType#getName()} matchs the given name
	 *         string
	 * <strong>Should</strong> return person attribute based on attributeName
	 * <strong>Should</strong> return null if AttributeName is voided
	 */
	public PersonAttribute getAttribute(String attributeName) {
		if (attributeName != null) {
			for (PersonAttribute attribute : getAttributes()) {
				PersonAttributeType type = attribute.getAttributeType();
				if (type != null && attributeName.equals(type.getName()) && !attribute.getVoided()) {
					return attribute;
				}
			}
		}
		
		return null;
	}
	
	/**
	 * Convenience method to get this person's first attribute that has a PersonAttributeTypeId
	 * equal to <code>attributeTypeId</code>.<br>
	 * <br>
	 * Returns null if this person has no non-voided {@link PersonAttribute} with the given type id
	 * or this person has no attributes.<br>
	 * <br>
	 * The given id cannot be null.
	 * 
	 * @param attributeTypeId the id of the {@link PersonAttributeType} to look for
	 * @return PersonAttribute whose {@link PersonAttributeType#getId()} equals the given Integer id
	 * <strong>Should</strong> return PersonAttribute based on attributeTypeId
	 * <strong>Should</strong> return null when existing personAttribute with matching attribute type id is voided
	 */
	public PersonAttribute getAttribute(Integer attributeTypeId) {
		for (PersonAttribute attribute : getActiveAttributes()) {
			if (attributeTypeId.equals(attribute.getAttributeType().getPersonAttributeTypeId())) {
				return attribute;
			}
		}
		return null;
	}
	
	/**
	 * Convenience method to get all of this person's attributes that have a
	 * PersonAttributeType.name equal to <code>attributeName</code>.
	 * 
	 * @param attributeName
	 * <strong>Should</strong> return all PersonAttributes with matching attributeType names
	 */
	public List<PersonAttribute> getAttributes(String attributeName) {
		List<PersonAttribute> ret = new ArrayList<>();
		
		for (PersonAttribute attribute : getActiveAttributes()) {
			PersonAttributeType type = attribute.getAttributeType();
			if (type != null && attributeName.equals(type.getName())) {
				ret.add(attribute);
			}
		}
		
		return ret;
	}
	
	/**
	 * Convenience method to get all of this person's attributes that have a PersonAttributeType.id
	 * equal to <code>attributeTypeId</code>.
	 * 
	 * @param attributeTypeId
	 * <strong>Should</strong> return empty list when matching personAttribute by id is voided
	 * <strong>Should</strong> return list of person attributes based on AttributeTypeId
	 */
	public List<PersonAttribute> getAttributes(Integer attributeTypeId) {
		List<PersonAttribute> ret = new ArrayList<>();
		
		for (PersonAttribute attribute : getActiveAttributes()) {
			if (attributeTypeId.equals(attribute.getAttributeType().getPersonAttributeTypeId())) {
				ret.add(attribute);
			}
		}
		
		return ret;
	}
	
	/**
	 * Convenience method to get all of this person's attributes that have a PersonAttributeType
	 * equal to <code>personAttributeType</code>.
	 * 
	 * @param personAttributeType
	 */
	public List<PersonAttribute> getAttributes(PersonAttributeType personAttributeType) {
		List<PersonAttribute> ret = new ArrayList<>();
		for (PersonAttribute attribute : getAttributes()) {
			if (personAttributeType.equals(attribute.getAttributeType()) && !attribute.getVoided()) {
				ret.add(attribute);
			}
		}
		return ret;
	}
	
	/**
	 * Convenience method to get this person's active attributes in map form: &lt;String,
	 * PersonAttribute&gt;.
	 */
	public Map<String, PersonAttribute> getAttributeMap() {
		if (attributeMap != null) {
			return attributeMap;
		}
		
		log.debug("Current Person Attributes: \n{}", printAttributes());
		
		attributeMap = new HashMap<>();
		for (PersonAttribute attribute : getActiveAttributes()) {
			attributeMap.put(attribute.getAttributeType().getName(), attribute);
		}
		
		return attributeMap;
	}
	
	/**
	 * Convenience method to get all of this person's attributes (including voided ones) in map
	 * form: &lt;String, PersonAttribute&gt;.
	 * 
	 * @return All person's attributes in map form
	 * @since 1.12
	 */
	public Map<String, PersonAttribute> getAllAttributeMap() {
		if (allAttributeMap != null) {
			return allAttributeMap;
		}
		
		log.debug("Current Person Attributes: \n{}", printAttributes());
		
		allAttributeMap = new HashMap<>();
		for (PersonAttribute attribute : getAttributes()) {
			allAttributeMap.put(attribute.getAttributeType().getName(), attribute);
		}
		
		return allAttributeMap;
	}
	
	/**
	 * Convenience method for viewing all of the person's current attributes
	 * 
	 * @return Returns a string with all the attributes
	 */
	public String printAttributes() {
		StringBuilder s = new StringBuilder("");
		
		for (PersonAttribute attribute : getAttributes()) {
			s.append(attribute.getAttributeType()).append(" : ").append(attribute.getValue()).append(" : voided? ")
			        .append(attribute.getVoided()).append("\n");
		}
		
		return s.toString();
	}
	
	/**
	 * Convenience method to add the <code>name</code> to this person's name list if the name
	 * doesn't exist already.
	 * 
	 * @param name
	 */
	public void addName(PersonName name) {
		if (name != null) {
			name.setPerson(this);
			if (names == null) {
				names = new TreeSet<>();
			}
			if (!OpenmrsUtil.collectionContains(names, name)) {
				names.add(name);
			}
		}
	}
	
	/**
	 * Convenience method remove the <code>name</code> from this person's name list if the name
	 * exists already.
	 * 
	 * @param name
	 */
	public void removeName(PersonName name) {
		if (names != null) {
			names.remove(name);
		}
	}
	
	/**
	 * Convenience method to add the <code>address</code> to this person's address list if the
	 * address doesn't exist already.
	 * 
	 * @param address
	 * <strong>Should</strong> not add a person address with blank fields
	 */
	public void addAddress(PersonAddress address) {
		if (address != null) {
			address.setPerson(this);
			if (addresses == null) {
				addresses = new TreeSet<>();
			}
			if (!OpenmrsUtil.collectionContains(addresses, address) && !address.isBlank()) {
				addresses.add(address);
			}
		}
	}
	
	/**
	 * Convenience method to remove the <code>address</code> from this person's address list if the
	 * address exists already.
	 * 
	 * @param address
	 */
	public void removeAddress(PersonAddress address) {
		if (addresses != null) {
			addresses.remove(address);
		}
	}
	
	/**
	 * Convenience method to get the {@link PersonName} object that is marked as "preferred". <br>
	 * <br>
	 * If two names are marked as preferred (or no names), the database ordering comes into effect
	 * and the one that was created most recently will be returned. <br>
	 * <br>
	 * This method will never return a voided name, even if it is marked as preferred. <br>
	 * <br>
	 * Null is returned if this person has no names or all voided names.
	 * 
	 * @return the "preferred" person name.
	 * @see #getNames()
	 * @see PersonName#getPreferred()
	 * <strong>Should</strong> get preferred and not-voided person name if exist
	 * <strong>Should</strong> get not-voided person name if preferred address does not exist
	 * <strong>Should</strong> get voided person address if person is voided and not-voided address does not exist
	 * <strong>Should</strong> return null if person is not-voided and have voided names
	 */
	public PersonName getPersonName() {
		// normally the DAO layer returns these in the correct order, i.e. preferred and non-voided first, but it's possible that someone
		// has fetched a Person, changed their names around, and then calls this method, so we have to be careful.
		if (getNames() != null && !getNames().isEmpty()) {
			for (PersonName name : getNames()) {
				if (name.getPreferred() && !name.getVoided()) {
					return name;
				}
			}
			for (PersonName name : getNames()) {
				if (!name.getVoided()) {
					return name;
				}
			}
			
			if (getVoided()) {
				return getNames().iterator().next();
			}
		}
		return null;
	}
	
	/**
	 * Convenience method to get the given name attribute on this person's preferred PersonName
	 * 
	 * @return String given name of the person
	 */
	public String getGivenName() {
		PersonName personName = getPersonName();
		if (personName == null) {
			return "";
		} else {
			return personName.getGivenName();
		}
	}
	
	/**
	 * Convenience method to get the middle name attribute on this person's preferred PersonName
	 * 
	 * @return String middle name of the person
	 */
	public String getMiddleName() {
		PersonName personName = getPersonName();
		if (personName == null) {
			return "";
		} else {
			return personName.getMiddleName();
		}
	}
	
	/**
	 * Convenience method to get the family name attribute on this person's preferred PersonName
	 * 
	 * @return String family name of the person
	 */
	public String getFamilyName() {
		PersonName personName = getPersonName();
		if (personName == null) {
			return "";
		} else {
			return personName.getFamilyName();
		}
	}
	
	/**
	 * Convenience method to get the {@link PersonAddress} object that is marked as "preferred". <br>
	 * <br>
	 * If two addresses are marked as preferred (or no addresses), the database ordering comes into
	 * effect and the one that was created most recently will be returned. <br>
	 * <br>
	 * This method will never return a voided address, even if it is marked as preferred. <br>
	 * <br>
	 * Null is returned if this person has no addresses or all voided addresses.
	 * 
	 * @return the "preferred" person address.
	 * @see #getAddresses()
	 * @see PersonAddress#getPreferred()
	 * <strong>Should</strong> get preferred and not-voided person address if exist
	 * <strong>Should</strong> get not-voided person address if preferred address does not exist
	 * <strong>Should</strong> get voided person address if person is voided and not-voided address does not exist
	 * <strong>Should</strong> return null if person is not-voided and have voided address
	 */
	public PersonAddress getPersonAddress() {
		// normally the DAO layer returns these in the correct order, i.e. preferred and non-voided first, but it's possible that someone
		// has fetched a Person, changed their addresses around, and then calls this method, so we have to be careful.
		if (getAddresses() != null && !getAddresses().isEmpty()) {
			for (PersonAddress addr : getAddresses()) {
				if (addr.getPreferred() && !addr.getVoided()) {
					return addr;
				}
			}
			for (PersonAddress addr : getAddresses()) {
				if (!addr.getVoided()) {
					return addr;
				}
			}
			
			if (getVoided()) {
				return getAddresses().iterator().next();
			}
		}
		return null;
	}
	
	/**
	 * Convenience method to calculate this person's age based on the birthdate For a person who
	 * lived 1990 to 2000, age would be -5 in 1985, 5 in 1995, 10 in 2000, and 10 2010.
	 * 
	 * @return Returns age as an Integer.
	 * <strong>Should</strong> get correct age after death
	 */
	public Integer getAge() {
		return getAge(null);
	}
	
	/**
	 * Convenience method: calculates the person's age on a given date based on the birthdate
	 * 
	 * @param onDate (null defaults to today)
	 * @return int value of the person's age
	 * <strong>Should</strong> get age before birthday
	 * <strong>Should</strong> get age on birthday with no minutes defined
	 * <strong>Should</strong> get age on birthday with minutes defined
	 * <strong>Should</strong> get age after birthday
	 * <strong>Should</strong> get age after death
	 * <strong>Should</strong> get age with given date after death
	 * <strong>Should</strong> get age with given date before death
	 * <strong>Should</strong> get age with given date before birth
	 */
	public Integer getAge(Date onDate) {
		if (birthdate == null) {
			return null;
		}
		
		// Use default end date as today.
		Calendar today = Calendar.getInstance();
		// But if given, use the given date.
		if (onDate != null) {
			today.setTime(onDate);
		}
		
		// If date given is after date of death then use date of death as end date
		if (getDeathDate() != null && today.getTime().after(getDeathDate())) {
			today.setTime(getDeathDate());
		}
		
		Calendar bday = Calendar.getInstance();
		bday.setTime(birthdate);
		
		int age = today.get(Calendar.YEAR) - bday.get(Calendar.YEAR);
		
		// Adjust age when today's date is before the person's birthday
		int todaysMonth = today.get(Calendar.MONTH);
		int bdayMonth = bday.get(Calendar.MONTH);
		int todaysDay = today.get(Calendar.DAY_OF_MONTH);
		int bdayDay = bday.get(Calendar.DAY_OF_MONTH);
		
		if (todaysMonth < bdayMonth) {
			age--;
		} else if (todaysMonth == bdayMonth && todaysDay < bdayDay) {
			// we're only comparing on month and day, not minutes, etc
			age--;
		}
		
		return age;
	}
	/**
	 * Method to get the age of a person in months.
	 *
	 * @return the age in months as an Integer e.g. 20 (to mean 20 months)
	 *
	 * @since 2.7.0
	 */
	public Integer getAgeInMonths() {
		return getAgeInChronoUnit(ChronoUnit.MONTHS);
	}
	/**
	 * Method to get the age of a person in weeks.
	 *
	 * @return the age in weeks as an Integer e.g. 20 (to mean 20 weeks)
	 *
	 * @since 2.7.0
	 */
	public Integer getAgeInWeeks() {
		return getAgeInChronoUnit(ChronoUnit.WEEKS);
	}
	/**
	 * Method to get the age of a person in days.
	 *
	 * @return the age in days as an Integer e.g. 20 (to mean 20 days)
	 *
	 * @since 2.7.0
	 */
	public Integer getAgeInDays() {
		return getAgeInChronoUnit(ChronoUnit.DAYS);
	}
	/**
	 * Gets the age of a person with the specified ChronoUnit.
	 *
	 * @param chronoUnit the unit of precision for the age calculation (e.g. WEEKS, MONTHS, YEARS)
	 * @return the age in the specified unit as an Integer
	 *
	 * @since 2.7.0
	 */
	private Integer getAgeInChronoUnit(ChronoUnit chronoUnit) {
		if (this.birthdate == null) {
			return null;
		}
		LocalDate birthDate = new java.sql.Date(this.birthdate.getTime()).toLocalDate();
		LocalDate endDate = LocalDate.now();
		// If date given is after date of death then use date of death as end date
		if (this.deathDate != null) {
			LocalDate deathDate = new java.sql.Date(this.deathDate.getTime()).toLocalDate();
			if (endDate.isAfter(deathDate)) {
				endDate = deathDate;
			}
		}
		switch (chronoUnit) {
			case DAYS:
				return (int) ChronoUnit.DAYS.between(birthDate, endDate);
			case WEEKS:
				return (int) ChronoUnit.WEEKS.between(birthDate, endDate);
			case MONTHS:
				return (int) ChronoUnit.MONTHS.between(birthDate, endDate);
			default:
				throw new IllegalArgumentException("Unsupported ChronoUnit: " + chronoUnit);
		}
	}
	
	/**
	 * Convenience method: sets a person's birth date from an age as of the given date Also sets
	 * flag indicating that the birth date is inexact. This sets the person's birth date to January
	 * 1 of the year that matches this age and date
	 * 
	 * @param age (the age to set)
	 * @param ageOnDate (null defaults to today)
	 */
	public void setBirthdateFromAge(int age, Date ageOnDate) {
		Calendar c = Calendar.getInstance();
		c.setTime(ageOnDate == null ? new Date() : ageOnDate);
		c.set(Calendar.DATE, 1);
		c.set(Calendar.MONTH, Calendar.JANUARY);
		c.add(Calendar.YEAR, -1 * age);
		setBirthdate(c.getTime());
		setBirthdateEstimated(true);
		
	}
	
	public User getPersonChangedBy() {
		return personChangedBy;
	}
	
	public void setPersonChangedBy(User changedBy) {
		this.personChangedBy = changedBy;
		this.setChangedBy(changedBy);
	}
	
	public Date getPersonDateChanged() {
		return personDateChanged;
	}
	
	public void setPersonDateChanged(Date dateChanged) {
		this.personDateChanged = dateChanged;
		this.setDateChanged(dateChanged);
	}
	
	public User getPersonCreator() {
		return personCreator;
	}
	
	public void setPersonCreator(User creator) {
		this.personCreator = creator;
		this.setCreator(creator);
	}
	
	public Date getPersonDateCreated() {
		return personDateCreated;
	}
	
	public void setPersonDateCreated(Date dateCreated) {
		this.personDateCreated = dateCreated;
		this.setDateCreated(dateCreated);
	}
	
	public Date getPersonDateVoided() {
		return personDateVoided;
	}
	
	public void setPersonDateVoided(Date dateVoided) {
		this.personDateVoided = dateVoided;
		this.setDateVoided(dateVoided);
	}
	
	public void setPersonVoided(Boolean voided) {
		this.personVoided = voided;
		this.setVoided(voided);
	}
	
	public Boolean getPersonVoided() {
		return personVoided;
	}
	
	/**
	 * @deprecated as of 2.0, use {@link #getPersonVoided()}
	 */
	@Deprecated
	@JsonIgnore
	public Boolean isPersonVoided() {
		return getPersonVoided();
	}
	
	public User getPersonVoidedBy() {
		return personVoidedBy;
	}
	
	public void setPersonVoidedBy(User voidedBy) {
		this.personVoidedBy = voidedBy;
		this.setVoidedBy(voidedBy);
	}
	
	public String getPersonVoidReason() {
		return personVoidReason;
	}
	
	public void setPersonVoidReason(String voidReason) {
		this.personVoidReason = voidReason;
		this.setVoidReason(voidReason);
	}
	
	/**
	 * @return true/false whether this person is a patient or not
	 * @deprecated as of 2.0, use {@link #getIsPatient()}
	 */
	@Deprecated
	@JsonIgnore
	@NotAudited
	public boolean isPatient() {
		return getIsPatient();
	}
	
	@NotAudited
	public boolean getIsPatient() {
		return isPatient;
	}
	
	/**
	 * This should only be set by the database layer by looking at whether a row exists in the
	 * patient table
	 * 
	 * @param isPatient whether this person is a patient or not
	 */
	protected void setPatient(boolean isPatient) {
		this.isPatient = isPatient;
	}
	
	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return "Person(personId=" + personId + ")";
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#getId()
	 */
	@Override
	public Integer getId() {
		
		return getPersonId();
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#setId(java.lang.Integer)
	 */
	@Override
	public void setId(Integer id) {
		setPersonId(id);
		
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api.context;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.stream.Collectors;
import org.apache.commons.collections.CollectionUtils;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.APIAuthenticationException;
import org.openmrs.api.APIException;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.db.ContextDAO;
import org.openmrs.module.DaemonToken;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleException;
import org.openmrs.module.ModuleFactory;
import org.openmrs.scheduler.Task;
import org.openmrs.scheduler.timer.TimerSchedulerTask;
import org.openmrs.util.OpenmrsSecurityManager;
import org.openmrs.util.OpenmrsThreadPoolHolder;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
/**
 * This class allows certain tasks to run with elevated privileges. Primary use is scheduling and
 * module startup when there is no user to authenticate as.
 */
public final class Daemon {
	
	/**
	 * The uuid defined for the daemon user object
	 */
	static final String DAEMON_USER_UUID = "A4F30A1B-5EB9-11DF-A648-37A07F9C90FB";
	
	private static final ThreadLocal<Boolean> isDaemonThread = new ThreadLocal<>();
	
	private static final ThreadLocal<User> daemonThreadUser = new ThreadLocal<>();
	
	/**
	 * private constructor to override the default constructor to prevent it from being instantiated.
	 */
	private Daemon() {
	}
	
	/**
	 * @see #startModule(Module, boolean, AbstractRefreshableApplicationContext)
	 */
	public static Module startModule(Module module) throws ModuleException {
		return startModule(module, false, null);
	}
	
	/**
	 * This method should not be called directly. The {@link ModuleFactory#startModule(Module)}
	 * method uses this to start the given module in a new thread that is authenticated as the
	 * daemon user. <br>
	 * If a non-null application context is passed in, it gets refreshed to make the module's
	 * services available
	 *
	 * @param module the module to start
	 * @param isOpenmrsStartup Specifies whether this module is being started at application startup
	 *            or not
	 * @param applicationContext the spring application context instance to refresh
	 * @return the module returned from {@link ModuleFactory#startModuleInternal(Module)}
	 */
	public static Module startModule(final Module module, final boolean isOpenmrsStartup,
	        final AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (callerClass != Daemon.class && callerClass != ModuleFactory.class) {
			throw new APIException("Module.factory.only", new Object[] { callerClass.getName() });
		}
		
		Future<Module> moduleStartFuture = runInDaemonThreadInternal(() -> ModuleFactory.startModuleInternal(module, isOpenmrsStartup, applicationContext));
		
		// wait for the "startModule" thread to finish
		try {
			return moduleStartFuture.get();
		}
		catch (InterruptedException e) {
			// ignore
		} catch (ExecutionException e) {
			if (e.getCause() instanceof ModuleException) {
				throw (ModuleException) e.getCause();
			} else {
				throw new ModuleException("Unable to start module " + module.getName(), e);
			}
		}
		return module;
	}
	/**
	 * This method should not be called directly, only {@link ContextDAO#createUser(User, String, List)} can
	 * legally invoke this method.
	 * 
	 * @param user A new user to be created.
	 * @param password The password to set for the new user.
	 * @param roleNames A list of role names to fetch the roles to add to the user.
	 * @return The newly created user
	 * 
	 * <strong>Should</strong> only allow the creation of new users, not the edition of existing ones
	 * 
	 * @since 2.3.0
	 */
	public static User createUser(User user, String password, List<String> roleNames) throws Exception {
		// quick check to make sure we're only being called by ourselves
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (!ContextDAO.class.isAssignableFrom(callerClass)) {
			throw new APIException("Context.DAO.only", new Object[] { callerClass.getName() });
		}
		// create a new thread and execute that task in it
		Future<User> userFuture = runInDaemonThreadInternal(() -> {
			if ((user.getId() != null && Context.getUserService().getUser(user.getId()) != null) || Context.getUserService().getUserByUuid(user.getUuid()) != null || Context.getUserService().getUserByUsername(user.getUsername()) != null || (user.getEmail() != null && Context.getUserService().getUserByUsernameOrEmail(user.getEmail()) != null) ) {
				throw new APIException("User.creating.already.exists", new Object[] { user.getDisplayString() });
			}
			if (!CollectionUtils.isEmpty(roleNames)) {
				List<Role> roles = roleNames.stream().map(roleName -> Context.getUserService().getRole(roleName)).collect(Collectors.toList());
				roles.forEach(user::addRole);
			}
			return Context.getUserService().createUser(user, password);
		});
		// wait for the 'create user' thread to finish
		try {
			return userFuture.get();
		}
		catch (InterruptedException e) {
			// ignore
		}
		catch (ExecutionException e) {
			if (e.getCause() instanceof Exception) {
				throw (Exception) e.getCause();
			} else {
				throw new RuntimeException(e.getCause());
			}
		}
		return null;
	}	
	
	/**
	 * Executes the given task in a new thread that is authenticated as the daemon user. <br>
	 * <br>
	 * This can only be called from {@link TimerSchedulerTask} during actual task execution
	 *
	 * @param task the task to run
	 * <strong>Should</strong> not be called from other methods other than TimerSchedulerTask
	 * <strong>Should</strong> not throw error if called from a TimerSchedulerTask class
	 */
	public static void executeScheduledTask(final Task task) throws Exception {
		// quick check to make sure we're only being called by ourselves
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (!TimerSchedulerTask.class.isAssignableFrom(callerClass)) {
			throw new APIException("Scheduler.timer.task.only", new Object[] { callerClass.getName() });
		}
		
		Future<?> scheduleTaskFuture = runInDaemonThreadInternal(() -> TimerSchedulerTask.execute(task));
		
		// wait for the "executeTaskThread" thread to finish
		try {
			scheduleTaskFuture.get();
		}
		catch (InterruptedException e) {
			// ignore
		} catch (ExecutionException e) {
			if (e.getCause() instanceof Exception) {
				throw (Exception) e.getCause();
			} else {
				throw new RuntimeException(e.getCause());
			}
		}
	}
	
	/**
	 * Call this method if you are inside a Daemon thread (for example in a Module activator or a
	 * scheduled task) and you want to start up a new parallel Daemon thread. You may only call this
	 * method from a Daemon thread.
	 *
	 * @param runnable what to run in a new thread
	 * @return the newly spawned {@link Thread}
	 * @deprecated As of 2.7.0, consider using {@link #runNewDaemonTask(Runnable)} instead
	 */
	@Deprecated
	public static Thread runInNewDaemonThread(final Runnable runnable) {
		// make sure we're already in a daemon thread
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		// the previous implementation ensured that Thread.start() was called before this function returned
		// since we cannot guarantee that the executor will run the thread when `execute()` is called, we need another
		// mechanism to ensure the submitted Runnable was actually started.
		final CountDownLatch countDownLatch = new CountDownLatch(1);
		
		// we should consider making DaemonThread public, so the caller can access returnedObject and exceptionThrown
		DaemonThread thread = new DaemonThread() {
			
			@Override
			public void run() {
				isDaemonThread.set(true);
				try {
					Context.openSession();
					countDownLatch.countDown();
					//Suppressing sonar issue "squid:S1217"
					//We intentionally do not start a new thread yet, rather wrap the run call in a session.
					runnable.run();
				}
				finally {
					try {
						Context.closeSession();
					} finally {
						isDaemonThread.remove();
						daemonThreadUser.remove();
					}
				}
			}
		};
		
		OpenmrsThreadPoolHolder.threadExecutor.execute(thread);
		// do not return until the thread is actually started to emulate the previous behaviour
		try {
			countDownLatch.await();
		} catch (InterruptedException ignored) {
		}
		return thread;
	}
	/**
	 * Call this method if you are inside a Daemon thread (for example in a Module activator or a
	 * scheduled task) and you want to start up a new parallel Daemon thread. You may only call this
	 * method from a Daemon thread.
	 *
	 * @param callable what to run in a new thread
	 * @return a future that completes when the task is done;
	 * @since 2.7.0
	 */
	@SuppressWarnings({"squid:S1217", "unused"})
	public static <T> Future<T> runInNewDaemonThread(final Callable<T> callable) {
		// make sure we're already in a daemon thread
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		return runInDaemonThreadInternal(callable);
	}
	/**
	 * Call this method if you are inside a Daemon thread (for example in a Module activator or a
	 * scheduled task) and you want to start up a new parallel Daemon thread. You may only call this
	 * method from a Daemon thread.
	 *
	 * @param runnable what to run in a new thread
	 * @return a future that completes when the task is done;
	 * @since 2.7.0
	 */
	@SuppressWarnings({"squid:S1217", "unused"})
	public static Future<?> runNewDaemonTask(final Runnable runnable) {
		// make sure we're already in a daemon thread
		if (!isDaemonThread()) {
			throw new APIAuthenticationException("Only daemon threads can spawn new daemon threads");
		}
		
		return runInDaemonThreadInternal(runnable);
	}
	
	/**
	 * @return true if the current thread was started by this class and so is a daemon thread that
	 *         has all privileges
	 * @see Context#hasPrivilege(String)
	 */
	public static boolean isDaemonThread() {
		Boolean b = isDaemonThread.get();
		if (b == null || !b) {
			// Allow functions in Daemon and WebDaemon to be treated as a DaemonThread
			Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(1);
			return callerClass.equals(Daemon.class) || callerClass.getName().equals("org.openmrs.web.WebDaemon");
		} else {
			return true;
		}
	}
	
	/**
	 * Calls the {@link OpenmrsService#onStartup()} method, as a daemon, for an instance
	 * implementing the {@link OpenmrsService} interface.
	 *
	 * @param service instance implementing the {@link OpenmrsService} interface.
	 * @since 1.9
	 */
	public static void runStartupForService(final OpenmrsService service) throws ModuleException {
		Class<?> callerClass = new OpenmrsSecurityManager().getCallerClass(0);
		if (callerClass != ServiceContext.class) {
			throw new APIException("Service.context.only", new Object[] { callerClass.getName() });
		}
		
		Future<?> future = runInDaemonThreadInternal(service::onStartup);
		
		// wait for the "onStartup" thread to finish
		try {
			future.get();
		}
		catch (InterruptedException e) {
			// ignore
		}
		catch (ExecutionException e) {
			if (e.getCause() instanceof ModuleException) {
				throw (ModuleException) e.getCause();
			} else {
				throw new ModuleException("Unable to run onStartup() method of service {}", service.getClass().getSimpleName(), e);
			}
		}
	}
	
	/**
	 * Executes the given runnable in a new thread that is authenticated as the daemon user.
	 *
	 * @param runnable an object implementing the {@link Runnable} interface.
	 * @param token the token required to run code as the daemon user
	 * @return the newly spawned {@link Thread}
	 * @since 1.9.2
	 * @deprecated Since 2.7.0 use {@link #runInDaemonThreadWithoutResult(Runnable, DaemonToken)} instead
	 */
	@Deprecated
	@SuppressWarnings({"squid:S1217", "unused"})
	public static Thread runInDaemonThread(final Runnable runnable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token " + token);
		}
		
		DaemonThread thread = new DaemonThread() {
			@Override
			public void run() {
				isDaemonThread.set(true);
				try {
					Context.openSession();
					//Suppressing sonar issue "squid:S1217"
					//We intentionally do not start a new thread yet, rather wrap the run call in a session.
					runnable.run();
				}
				finally {
					try {
						Context.closeSession();
					} finally {
						isDaemonThread.remove();
						daemonThreadUser.remove();
					}
				}
			}
		};
		OpenmrsThreadPoolHolder.threadExecutor.execute(thread);
		return thread;
	}
	/**
	 * Executes the given runnable in a new thread that is authenticated as the daemon user.
	 *
	 * @param callable an object implementing the {@link Callable<T>} interface to be run
	 * @param token the token required to run code as the daemon user
	 * @return the newly spawned {@link Thread}
	 * @since 2.7.0
	 */
	@SuppressWarnings({"squid:S1217", "unused"})
	public static <T> Future<T> runInDaemonThread(final Callable<T> callable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token");
		}
		
		return runInDaemonThreadInternal(callable);
	}
	/**
	 * Executes the given runnable in a new thread that is authenticated as the daemon user.
	 *
	 * @param runnable an object implementing the {@link Runnable} interface to be run
	 * @param token the token required to run code as the daemon user
	 * @return the newly spawned {@link Thread}
	 * @since 2.7.0
	 */
	@SuppressWarnings("squid:S1217")
	public static Future<?> runInDaemonThreadWithoutResult(final Runnable runnable, DaemonToken token) {
		if (!ModuleFactory.isTokenValid(token)) {
			throw new ContextAuthenticationException("Invalid token");
		}
		return runInDaemonThreadInternal(runnable);
	}
	
	/**
	 * Executes the given runnable in a new thread that is authenticated as the daemon user and wait
	 * for the thread to finish.
	 *
	 * @param runnable an object implementing the {@link Runnable} interface.
	 * @param token the token required to run code as the daemon user
	 * @since 2.7.0
	 */
	public static void runInDaemonThreadAndWait(final Runnable runnable, DaemonToken token) {
		Future<?> daemonThread = runInDaemonThreadWithoutResult(runnable, token);
		
		try {
			daemonThread.get();
		}
		catch (InterruptedException | ExecutionException e) {
			// Ignored
		}
	}
	
	private static <T> Future<T> runInDaemonThreadInternal(Callable<T> callable) {
		return OpenmrsThreadPoolHolder.threadExecutor.submit(() -> {
			isDaemonThread.set(true);
			try {
				Context.openSession();
				return callable.call();
			}
			finally {
				try {
					Context.closeSession();
				} finally {
					isDaemonThread.remove();
					daemonThreadUser.remove();
				}
			}
		});
	}
	
	private static Future<?> runInDaemonThreadInternal(Runnable runnable) {
		// for Threads, we used to guarantee that Thread.start() was called before the function returned
		// since we cannot guarantee that the executor actually started executing the thread, we use a CountDownLatch
		// to emulate this behaviour when the user submits a Thread. Other runnables are unaffected.
		CountDownLatch countDownLatch = getCountDownLatch(runnable instanceof Thread);
		Future<?> result = OpenmrsThreadPoolHolder.threadExecutor.submit(() -> {
			isDaemonThread.set(true);
			try {
				Context.openSession();
				countDownLatch.countDown();
				runnable.run();
			}
			finally {
				try {
					Context.closeSession();
				} finally {
					isDaemonThread.remove();
					daemonThreadUser.remove();
				}
			}
		});
		
		try {
			countDownLatch.await();
		} catch (InterruptedException ignored) {}
		
		return result;
	}
	private static CountDownLatch getCountDownLatch(boolean isThread) {
		return isThread ? new CountDownLatch(1) : new CountDownLatch(0);
	}
	/**
	 * Thread class used by the {@link Daemon#startModule(Module)} and
	 * {@link Daemon#executeScheduledTask(Task)} methods so that the returned object and the
	 * exception thrown can be returned to calling class
	 */
	protected static class DaemonThread extends Thread {
		
		/**
		 * The object returned from the method called in {@link #run()}
		 */
		protected Object returnedObject = null;
		
		/**
		 * The exception thrown (if any) by the method called in {@link #run()}
		 */
		protected Exception exceptionThrown = null;
		
		/**
		 * Gets the exception thrown (if any) by the method called in {@link #run()}
		 *
		 * @return the thrown exception (if any).
		 */
		public Exception getExceptionThrown() {
			return exceptionThrown;
		}
	}
	
	/**
	 * Checks whether user is Daemon.
	 * However, this is not the preferred method for checking to see if the current thread is a daemon thread,
	 * 				rather use {@link #isDaemonThread()}.
	 * isDaemonThread is preferred for checking to see if you are in that thread or if the current thread is daemon.
	 *
	 * @param user user whom we are checking if daemon
	 * @return true if user is Daemon
	 */
	public static boolean isDaemonUser(User user) {
		return DAEMON_USER_UUID.equals(user.getUuid());
	}
	
	/**
	 * @return the current thread daemon user or null if not assigned
	 * @since 2.0.0, 1.12.0, 1.11.6, 1.10.4, 1.9.11
	 */
	public static User getDaemonThreadUser() {
		if (isDaemonThread()) {
			User user = daemonThreadUser.get();
			if (user == null) {
				user = Context.getContextDAO().getUserByUuid(DAEMON_USER_UUID);
				daemonThreadUser.set(user);
			}
			return user;
		} else {
			return null;
		}
	}
	public static String getDaemonUserUuid() {
		return DAEMON_USER_UUID;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api;
import org.openmrs.api.context.Context;
/**
 * Represents often fatal errors that occur within the API infrastructure. All service methods
 * should be marked as possibly throwing this exception. The preferred methods to use in this
 * exception is the {@link #APIException(String, Throwable)} or the {@link #APIException(String)}
 */
public class APIException extends RuntimeException {
	
	public static final long serialVersionUID = 12121212L;
	
	/**
	 * Default empty constructor. If at all possible, don't use this one, but use the
	 * {@link #APIException(String)} constructor to specify a helpful message to the end user
	 */
	public APIException() {
	}
	
	/**
	 * General constructor to give the end user a helpful message that relates to why this error
	 * occurred.
	 * 
	 * @param message helpful message string for the end user
	 */
	public APIException(String message) {
		super(message);
	}
	
	/**
	 * General constructor to give the end user a helpful message and to also propagate the parent
	 * error exception message.
	 * 
	 * @param message helpful message string for the end user
	 * @param cause the parent exception cause that this APIException is wrapping around
	 */
	public APIException(String message, Throwable cause) {
		super(message, cause);
	}
	
	/**
	 * Constructor used to simply chain a parent exception cause to an APIException. Preference
	 * should be given to the {@link #APIException(String, Throwable)} constructor if at all
	 * possible instead of this one.
	 * 
	 * @param cause the parent exception cause that this APIException is wrapping around
	 */
	public APIException(Throwable cause) {
		super(cause);
	}
	
	/**
	 * Constructor to give the end user a helpful message that relates to why this error occurred.
	 * 
	 * @param messageKey message code to retrieve
	 * @param parameters message parameters
	 */
	public APIException(String messageKey, Object[] parameters) {
		super(Context.getMessageSourceService().getMessage(messageKey, parameters, Context.getLocale()));
	}
	
	/**
	 * Constructor to give the end user a helpful message and to also propagate the parent
	 * error exception message..
	 *
	 * @param messageKey message code to retrieve
	 * @param parameters message parameters
	 * @param cause the parent exception cause that this APIException is wrapping around   
	 */
	public APIException(String messageKey, Object[] parameters, Throwable cause) {
		super(Context.getMessageSourceService().getMessage(messageKey, parameters, Context.getLocale()), cause);
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import org.hibernate.envers.Audited;
import org.openmrs.util.RoleConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * A Role is just an aggregater of {@link Privilege}s. {@link User}s contain a number of roles
 * (Users DO NOT contain any privileges directly) Roles can be grouped by inheriting other roles. If
 * a user is given Role A that inherits from Role B, the user has all rights/abilities for both Role
 * A's privileges and for Role B's privileges.
 *
 * @see Privilege
 */
@Audited
public class Role extends BaseChangeableOpenmrsMetadata {
	
	public static final long serialVersionUID = 1234233L;
	
	private static final Logger log = LoggerFactory.getLogger(Role.class);
	
	// Fields
	
	private String role;
	
	private Set<Privilege> privileges;
	
	private Set<Role> inheritedRoles;
	
	private Set<Role> childRoles;
	
	// Constructors
	
	/** default constructor */
	public Role() {
	}
	
	/** constructor with id */
	public Role(String role) {
		this.role = role;
	}
	
	/** constructor with all database required properties */
	public Role(String role, String description) {
		this.role = role;
		setDescription(description);
	}
	
	/**
	 * @return Returns the privileges.
	 */
	public Set<Privilege> getPrivileges() {
		return privileges;
	}
	
	/**
	 * @param privileges The privileges to set.
	 */
	public void setPrivileges(Set<Privilege> privileges) {
		this.privileges = privileges;
	}
	
	@Override
	public String getName() {
		return this.getRole();
	}
	
	/**
	 * Adds the given Privilege to the list of privileges
	 *
	 * @param privilege Privilege to add
	 */
	public void addPrivilege(Privilege privilege) {
		if (privileges == null) {
			privileges = new HashSet<>();
		}
		if (privilege != null && !containsPrivilege(privileges, privilege.getPrivilege())) {
			privileges.add(privilege);
		}
	}
	
	private boolean containsPrivilege(Collection<Privilege> privileges, String privilegeName) {
		for (Privilege privilege : privileges) {
			if (privilege.getPrivilege().equals(privilegeName)) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Removes the given Privilege from the list of privileges
	 *
	 * @param privilege Privilege to remove
	 */
	public void removePrivilege(Privilege privilege) {
		if (privileges != null) {
			privileges.remove(privilege);
		}
	}
	
	/**
	 * @return Returns the role.
	 */
	public String getRole() {
		return role;
	}
	
	/**
	 * @param role The role to set.
	 */
	public void setRole(String role) {
		this.role = role;
	}
	
	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return this.role;
	}
	
	/**
	 * Looks for the given <code>privilegeName</code> privilege name in this roles privileges. This
	 * method does not recurse through the inherited roles
	 *
	 * @param privilegeName String name of a privilege
	 * @return true/false whether this role has the given privilege
	 * <strong>Should</strong> return false if not found
	 * <strong>Should</strong> return true if found
	 * <strong>Should</strong> not fail given null parameter
	 * <strong>Should</strong> return true for any privilegeName if super user
	 */
	public boolean hasPrivilege(String privilegeName) {
		
		if (RoleConstants.SUPERUSER.equals(this.role)) {
			return true;
		}
		
		if (privileges != null) {
			for (Privilege p : privileges) {
				if (p.getPrivilege().equalsIgnoreCase(privilegeName)) {
					return true;
				}
			}
		}
		
		return false;
	}
	
	/**
	 * @return Returns the inheritedRoles.
	 */
	public Set<Role> getInheritedRoles() {
		if (inheritedRoles == null) {
			inheritedRoles = new HashSet<>();
		}
		return inheritedRoles;
	}
	
	/**
	 * @param inheritedRoles The inheritedRoles to set.
	 */
	public void setInheritedRoles(Set<Role> inheritedRoles) {
		this.inheritedRoles = inheritedRoles;
	}
	
	/**
	 * Convenience method to test whether or not this role extends/ inherits from any other roles
	 *
	 * @return true/false whether this role inherits from other roles
	 */
	public boolean inheritsRoles() {
		return getInheritedRoles() != null && !getInheritedRoles().isEmpty();
	}
	
	/**
	 * Recursive (if need be) method to return all parent roles of this role
	 *
	 * <strong>Should</strong> only return parent roles
	 * @return Return this role's parents
	 */
	public Set<Role> getAllParentRoles() {
		Set<Role> parents = new HashSet<>();
		if (inheritsRoles()) {
			parents.addAll(this.recurseOverParents(parents));
		}
		return parents;
	}
	
	/**
	 * Returns the full set of roles be looping over inherited roles. Duplicate roles are dropped.
	 *
	 * @param total Roles already looped over
	 * @return Set&lt;Role&gt; Current and inherited roles
	 */
	public Set<Role> recurseOverParents(final Set<Role> total) {
		if (!this.inheritsRoles()) {
			return total;
		}
		Set<Role> allRoles = new HashSet<>(total);
		Set<Role> myRoles = new HashSet<>(this.getInheritedRoles());
		myRoles.removeAll(total);
		// prevent an obvious looping problem
		myRoles.remove(this); 
		allRoles.addAll(myRoles);
		
		for (Role r : myRoles) {
			if (r.inheritsRoles()) {
				allRoles.addAll(r.recurseOverParents(allRoles));
			}
		}
		
		log.debug("Total roles: {}", allRoles);
		
		return allRoles;
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#getId()
	 */
	@Override
	public Integer getId() {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#setId(java.lang.Integer)
	 */
	@Override
	public void setId(Integer id) {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * @since 1.9
	 * @return immediate children
	 */
	public Set<Role> getChildRoles() {
		if (childRoles == null) {
			childRoles = new HashSet<>();
		}
		return childRoles;
	}
	
	/**
	 * @since 1.9
	 * @param childRoles the immediate children to set
	 */
	public void setChildRoles(Set<Role> childRoles) {
		this.childRoles = childRoles;
	}
	
	/**
	 * Convenience method to test whether or not this role is a parent of another role
	 *
	 * @return true/false whether this role is a parent of another role
	 * @since 1.9
	 */
	public boolean hasChildRoles() {
		return getChildRoles() != null && !getChildRoles().isEmpty();
	}
	
	/**
	 * Recursive (if need be) method to return all child roles of this role
	 *
	 * <strong>Should</strong> only return child roles
	 * @return this role's children
	 * @since 1.9
	 */
	public Set<Role> getAllChildRoles() {
		Set<Role> children = new HashSet<>();
		if (hasChildRoles()) {
			children.addAll(this.recurseOverChildren(children));
		}
		return children;
	}
	
	/**
	 * Returns the full set of child roles be looping over children. Duplicate roles are dropped.
	 *
	 * @param total Roles already looped over
	 * @return Set&lt;Role&gt; Current and child roles
	 * @since 1.9
	 */
	public Set<Role> recurseOverChildren(final Set<Role> total) {
		if (!this.hasChildRoles()) {
			return total;
		}
		Set<Role> allRoles = new HashSet<>(total);
		Set<Role> myRoles = new HashSet<>(this.getChildRoles());
		myRoles.removeAll(total);
		// prevent an obvious looping problem
		myRoles.remove(this); 
		allRoles.addAll(myRoles);
		
		for (Role r : myRoles) {
			if (r.hasChildRoles()) {
				allRoles.addAll(r.recurseOverChildren(allRoles));
			}
		}
		
		log.debug("Total roles: {}", allRoles);
		
		return allRoles;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs;
import org.hibernate.envers.Audited;
/**
 * Privilege
 * 
 * @version 1.0
 */
@Audited
public class Privilege extends BaseChangeableOpenmrsMetadata {
	
	public static final long serialVersionUID = 312L;
	
	// Fields
	
	private String privilege;
	
	// Constructors
	
	/** default constructor */
	public Privilege() {
	}
	
	/** constructor with id */
	public Privilege(String privilege) {
		this.privilege = privilege;
	}
	
	public Privilege(String privilege, String description) {
		this.privilege = privilege;
		setDescription(description);
	}
	
	// Property accessors
	
	/**
	 * @return Returns the privilege.
	 */
	public String getPrivilege() {
		return privilege;
	}
	
	/**
	 * @param privilege The privilege to set.
	 */
	public void setPrivilege(String privilege) {
		this.privilege = privilege;
	}
	
	@Override
	public String getName() {
		return this.getPrivilege();
	}
	
	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return this.privilege;
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#getId()
	 */
	@Override
	public Integer getId() {
		throw new UnsupportedOperationException();
		
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#setId(java.lang.Integer)
	 */
	@Override
	public void setId(Integer id) {
		throw new UnsupportedOperationException();
		
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.MapKeyColumn;
import javax.persistence.Table;
import javax.persistence.Transient;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;
import org.hibernate.annotations.Cascade;
import org.hibernate.annotations.CascadeType;
import org.hibernate.annotations.GenericGenerator;
import org.hibernate.annotations.LazyCollection;
import org.hibernate.annotations.LazyCollectionOption;
import org.hibernate.annotations.Parameter;
import org.hibernate.envers.Audited;
import org.hibernate.envers.NotAudited;
import org.openmrs.api.context.Context;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.RoleConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * Defines a User Account in the system. This account belongs to a {@link Person} in the system,
 * although that person may have other user accounts. Users have login credentials
 * (username/password) and can have special user properties. User properties are just simple
 * key-value pairs for either quick info or display specific info that needs to be persisted (like
 * locale preferences, search options, etc)
 */
@Entity
@Table(name = "users")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
@Audited
public class User extends BaseOpenmrsObject implements java.io.Serializable, Attributable<User>, Auditable, Retireable {
	
	public static final long serialVersionUID = 2L ;
	
	private static final Logger log = LoggerFactory.getLogger(User.class);
	
	// Fields
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "users_user_id_seq")
	@GenericGenerator(
		name = "users_user_id_seq",
		strategy = "native",
		parameters = @Parameter(name = "sequence", value = "users_user_id_seq")
	)
	@Column(name = "user_id")
	private Integer userId;
	@ManyToOne
	@JoinColumn(name = "person_id", nullable = false)
	@LazyCollection(LazyCollectionOption.FALSE)
	@Cascade(CascadeType.SAVE_UPDATE)
	private Person person;
	@Column(name = "system_id", nullable = false, length = 50)
	private String systemId;
	@Column(name = "username", length = 50)
	private String username;
	@Column(name = "email", length = 255, unique = true)
	private String email;
	@ManyToMany
	@JoinTable(name = "user_role", joinColumns = @JoinColumn(name = "user_id"), inverseJoinColumns = @JoinColumn(name = "role"))
	@LazyCollection(LazyCollectionOption.FALSE)
	@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
	@Cascade({ CascadeType.SAVE_UPDATE, CascadeType.MERGE, CascadeType.EVICT })
	private Set<Role> roles;
	@ElementCollection
	@CollectionTable(name = "user_property", joinColumns = @JoinColumn(name = "user_id", nullable = false))
	@MapKeyColumn(name = "property", length = 255)
	@Column(name = "property_value", length = Integer.MAX_VALUE)
	@Cascade({ CascadeType.SAVE_UPDATE, CascadeType.MERGE, CascadeType.EVICT })
	@NotAudited
	private Map<String, String> userProperties;
	@Transient
	private List<Locale> proficientLocales = null;
	@Transient
	private String parsedProficientLocalesProperty = "";
	@ManyToOne
	@JoinColumn(name = "creator", nullable = false)
	private User creator;
	@Column(name = "date_created", nullable = false, length = 19)
	private Date dateCreated;
	@ManyToOne
	@JoinColumn(name = "changed_by")
	private User changedBy;
	@Column(name = "date_changed", length = 19)
	private Date dateChanged;
	@Column(name = "retired", nullable = false, length = 1)
	private boolean retired;
	@ManyToOne
	@JoinColumn(name = "retired_by")
	private User retiredBy;
	@Column(name = "date_retired", length = 19)
	private Date dateRetired;
	@Column(name = "retire_reason", length = 255)
	private String retireReason;
	
	// Constructors
	
	/** default constructor */
	public User() {
	}
	
	/** constructor with id */
	public User(Integer userId) {
		this.userId = userId;
	}
	
	/** constructor with person object */
	public User(Person person) {
		this.person = person;
	}
	
	/**
	 * Return true if this user has all privileges
	 * 
	 * @return true/false if this user is defined as a super user
	 */
	public boolean isSuperUser() {
		return containsRole(RoleConstants.SUPERUSER);
	}
	
	/**
	 * This method shouldn't be used directly. Use org.openmrs.api.context.Context#hasPrivilege so that
	 * anonymous/authenticated/proxy privileges are all included Return true if this user has the
	 * specified privilege
	 * 
	 * @param privilege
	 * @return true/false depending on whether user has specified privilege
	 */
	public boolean hasPrivilege(String privilege) {
		
		// All authenticated users have the "" (empty) privilege
		if (StringUtils.isEmpty(privilege)) {
			return true;
		}
		
		if (isSuperUser()) {
			return true;
		}
		
		Set<Role> tmproles = getAllRoles();
		
		// loop over the roles and check each for the privilege
		for (Role tmprole : tmproles) {
			if (tmprole.hasPrivilege(privilege)) {
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Check if this user has the given String role
	 * 
	 * @param r String name of a role to check
	 * @return Returns true if this user has the specified role, false otherwise
	 */
	public boolean hasRole(String r) {
		return hasRole(r, false);
	}
	
	/**
	 * Checks if this user has the given String role
	 * 
	 * @param r String name of a role to check
	 * @param ignoreSuperUser If this is false, then this method will always return true for a
	 *            superuser.
	 * @return Returns true if the user has the given role, or if ignoreSuperUser is false and the user
	 *         is a superUser
	 */
	public boolean hasRole(String r, boolean ignoreSuperUser) {
		if (!ignoreSuperUser && isSuperUser()) {
			return true;
		}
		
		if (roles == null) {
			return false;
		}
		
		Set<Role> tmproles = getAllRoles();
		
		log.debug("User # {} has roles: {}", userId, tmproles);
		
		return containsRole(r);
	}
	
	/**
	 * Checks if the user has a given role. Role name comparisons are not case sensitive.
	 * 
	 * @param roleName the name of the role to check
	 * @return true if the user has the given role, else false
	 * <strong>Should</strong> return true if the user has the given role
	 * <strong>Should</strong> return false if the user does not have the given role
	 * <strong>Should</strong> be case insensitive
	 */
	public boolean containsRole(String roleName) {
		for (Role role : getAllRoles()) {
			if (role.getRole().equalsIgnoreCase(roleName)) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Get <i>all</i> privileges this user has. This delves into all of the roles that a person has,
	 * appending unique privileges
	 * 
	 * @return Collection of complete Privileges this user has
	 */
	public Collection<Privilege> getPrivileges() {
		Set<Privilege> privileges = new HashSet<>();
		Set<Role> tmproles = getAllRoles();
		
		Role role;
		for (Role tmprole : tmproles) {
			role = tmprole;
			Collection<Privilege> privs = role.getPrivileges();
			if (privs != null) {
				privileges.addAll(privs);
			}
		}
		
		return privileges;
	}
	
	// Property accessors
	
	/**
	 * Returns all roles attributed to this user by expanding the role list to include the parents of
	 * the assigned roles
	 * 
	 * @return all roles (inherited from parents and given) for this user
	 */
	public Set<Role> getAllRoles() {
		// the user's immediate roles
		Set<Role> baseRoles = new HashSet<>();
		
		// the user's complete list of roles including
		// the parent roles of their immediate roles
		Set<Role> totalRoles = new HashSet<>();
		if (getRoles() != null) {
			baseRoles.addAll(getRoles());
			totalRoles.addAll(getRoles());
		}
		
		log.debug("User's base roles: {}", baseRoles);
		
		try {
			for (Role r : baseRoles) {
				totalRoles.addAll(r.getAllParentRoles());
			}
		}
		catch (ClassCastException e) {
			log.error("Error converting roles for user: " + this);
			log.error("baseRoles.class: " + baseRoles.getClass().getName());
			log.error("baseRoles: " + baseRoles.toString());
			for (Role baseRole : baseRoles) {
				log.error("baseRole: '" + baseRole + "'");
			}
		}
		return totalRoles;
	}
	
	/**
	 * @return Returns the roles.
	 */
	public Set<Role> getRoles() {
		return roles;
	}
	
	/**
	 * @param roles The roles to set.
	 */
	public void setRoles(Set<Role> roles) {
		this.roles = roles;
	}
	
	/**
	 * Add the given Role to the list of roles for this User
	 * 
	 * @param role
	 * @return Returns this user with the given role attached
	 */
	public User addRole(Role role) {
		if (roles == null) {
			roles = new HashSet<>();
		}
		if (!roles.contains(role) && role != null) {
			roles.add(role);
		}
		
		return this;
	}
	
	/**
	 * Remove the given Role from the list of roles for this User
	 * 
	 * @param role
	 * @return this user with the given role removed
	 */
	public User removeRole(Role role) {
		if (roles != null) {
			roles.remove(role);
		}
		
		return this;
	}
	
	/**
	 * @see org.openmrs.Attributable#findPossibleValues(java.lang.String)
	 */
	@Override
	@Deprecated
	public List<User> findPossibleValues(String searchText) {
		try {
			return Context.getUserService().getUsersByName(searchText, "", false);
		}
		catch (Exception e) {
			return Collections.emptyList();
		}
	}
	
	/**
	 * @see org.openmrs.Attributable#getPossibleValues()
	 */
	@Override
	@Deprecated
	public List<User> getPossibleValues() {
		try {
			return Context.getUserService().getAllUsers();
		}
		catch (Exception e) {
			return Collections.emptyList();
		}
	}
	
	/**
	 * @see org.openmrs.Attributable#hydrate(java.lang.String)
	 */
	@Override
	public User hydrate(String userId) {
		try {
			return Context.getUserService().getUser(Integer.valueOf(userId));
		}
		catch (Exception e) {
			return new User();
		}
	}
	
	/**
	 * @see org.openmrs.Attributable#serialize()
	 */
	@Override
	public String serialize() {
		if (getUserId() != null) {
			return "" + getUserId();
		} else {
			return "";
		}
	}
	
	/**
	 * @see org.openmrs.Attributable#getDisplayString()
	 */
	@Override
	public String getDisplayString() {
		String returnString = "";
		if (getPersonName() != null) {
			returnString += getPersonName().getFullName() + " ";
		}
		
		returnString += "(" + getUsername() + ")";
		return returnString;
		
	}
	
	/**
	 * @return Returns the systemId.
	 */
	public String getSystemId() {
		return systemId;
	}
	
	/**
	 * @param systemId The systemId to set.
	 */
	public void setSystemId(String systemId) {
		this.systemId = systemId;
	}
	
	/**
	 * @return Returns the userId.
	 */
	public Integer getUserId() {
		return userId;
	}
	
	/**
	 * @param userId The userId to set.
	 */
	public void setUserId(Integer userId) {
		this.userId = userId;
	}
	
	/**
	 * @return the person
	 * @since 1.6
	 */
	public Person getPerson() {
		return person;
	}
	
	/**
	 * @return the person, creating a new object if person is null
	 */
	private Person getPersonMaybeCreate() {
		if (person == null) {
			person = new Person();
		}
		return person;
	}
	
	/**
	 * @param person the person to set
	 * @since 1.6
	 */
	public void setPerson(Person person) {
		this.person = person;
	}
	
	/**
	 * @return Returns the username.
	 */
	public String getUsername() {
		return username;
	}
	
	/**
	 * @param username The username to set.
	 */
	public void setUsername(String username) {
		this.username = username;
	}
	
	/**
	 * @since 2.2
	 * @return Returns the email.
	 */
	public String getEmail() {
		return email;
	}
	
	/**
	 * @since 2.2
	 * @param email The email to set.
	 */
	public void setEmail(String email) {
		this.email = email;
	}
	
	@Override
	public String toString() {
		return StringUtils.isNotBlank(username) ? username : systemId;
	}
	
	/**
	 * @return Returns the userProperties.
	 */
	public Map<String, String> getUserProperties() {
		if (userProperties == null) {
			userProperties = new HashMap<>();
		}
		return userProperties;
	}
	
	/**
	 * @param userProperties A Map&lt;String,String&gt; of the properties to set.
	 */
	public void setUserProperties(Map<String, String> userProperties) {
		this.userProperties = userProperties;
	}
	
	/**
	 * Convenience method. Adds the given property to the user's properties
	 */
	public void setUserProperty(String prop, String value) {
		getUserProperties().put(prop, value);
	}
	
	/**
	 * Convenience method. Removes the given property from the user's properties
	 */
	public void removeUserProperty(String prop) {
		if (getUserProperties() != null && userProperties.containsKey(prop)) {
			userProperties.remove(prop);
		}
	}
	
	/**
	 * Get prop property from this user's properties. If prop is not found in properties, return empty
	 * string
	 * 
	 * @param prop
	 * @return property value
	 */
	public String getUserProperty(String prop) {
		if (getUserProperties() != null && userProperties.containsKey(prop)) {
			return userProperties.get(prop);
		}
		
		return "";
	}
	
	/**
	 * Get prop property from this user's properties. If prop is not found in properties, return
	 * <code>defaultValue</code>
	 * 
	 * @param prop
	 * @param defaultValue
	 * @return property value
	 * @see #getUserProperty(java.lang.String)
	 */
	public String getUserProperty(String prop, String defaultValue) {
		if (getUserProperties() != null && userProperties.containsKey(prop)) {
			return userProperties.get(prop);
		}
		
		return defaultValue;
	}
	
	/**
	 * @see Person#addName(PersonName)
	 */
	public void addName(PersonName name) {
		getPersonMaybeCreate().addName(name);
	}
	
	/**
	 * @see Person#getPersonName()
	 */
	public PersonName getPersonName() {
		return getPerson() == null ? null : getPerson().getPersonName();
	}
	
	/**
	 * Get givenName on the Person this user account belongs to
	 * 
	 * @see Person#getGivenName()
	 */
	public String getGivenName() {
		return getPerson() == null ? null : getPerson().getGivenName();
	}
	
	/**
	 * Get familyName on the Person this user account belongs to
	 * 
	 * @see Person#getFamilyName()
	 */
	public String getFamilyName() {
		return getPerson() == null ? null : getPerson().getFamilyName();
	}
	
	/**
	 * @see org.openmrs.Person#getNames()
	 */
	public Set<PersonName> getNames() {
		return person.getNames();
	}
	
	/**
	 * Returns a list of Locales for which the User is considered proficient.
	 * 
	 * @return List of the User's proficient locales
	 */
	public List<Locale> getProficientLocales() {
		String proficientLocalesProperty = getUserProperty(OpenmrsConstants.USER_PROPERTY_PROFICIENT_LOCALES);
		
		if ((proficientLocales == null)
		        || (!OpenmrsUtil.nullSafeEquals(parsedProficientLocalesProperty, proficientLocalesProperty))) {
			parsedProficientLocalesProperty = proficientLocalesProperty;
			proficientLocales = new ArrayList<>();
			if (proficientLocalesProperty != null) {
				String[] proficientLocalesArray = proficientLocalesProperty.split(",");
				for (String proficientLocaleSpec : proficientLocalesArray) {
					if (proficientLocaleSpec.length() > 0) {
						Locale proficientLocale = LocaleUtility.fromSpecification(proficientLocaleSpec);
						if (!proficientLocales.contains(proficientLocale)) {
							proficientLocales.add(proficientLocale);
							if (StringUtils.isNotEmpty(proficientLocale.getCountry())) {
								// add the language also
								Locale languageOnlyLocale = LocaleUtility.fromSpecification(proficientLocale.getLanguage());
								if (!proficientLocales.contains(languageOnlyLocale)) {
									proficientLocales.add(LocaleUtility.fromSpecification(proficientLocale.getLanguage()));
								}
							}
						}
					}
				}
			}
		}
		
		// return a copy so that the list isn't changed by other processes
		return new ArrayList<>(proficientLocales);
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#getId()
	 */
	@Override
	public Integer getId() {
		return getUserId();
	}
	
	/**
	 * @since 1.5
	 * @see org.openmrs.OpenmrsObject#setId(java.lang.Integer)
	 */
	@Override
	public void setId(Integer id) {
		setUserId(id);
	}
	
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
	
    @Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	@Override
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	@Override
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	@Override
	public Boolean isRetired() {
		return retired;
	}
	
    @Override
	public Boolean getRetired() {
		return retired;
	}
	@Override
	public void setRetired(Boolean retired) {
		this.retired = retired;
	}
	@Override
	public User getRetiredBy() {
		return retiredBy;
	}
	@Override
	public void setRetiredBy(User retiredBy) {
		this.retiredBy = retiredBy;
	}
	@Override
	public Date getDateRetired() {
		return dateRetired;
	}
	@Override
	public void setDateRetired(Date dateRetired) {
		this.dateRetired = dateRetired;
	}
	@Override
	public String getRetireReason() {
		return retireReason;
	}
	@Override
	public void setRetireReason(String retireReason) {
		this.retireReason = retireReason;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.scheduler.tasks;
import org.apache.commons.lang.StringUtils;
import org.openmrs.User;
import org.openmrs.api.UserService;
import org.openmrs.api.context.Context;
import org.openmrs.util.OpenmrsConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
/**
 * A scheduled task that automatically retires users after the set number of days of inactivity. 
 * The inactivity duration is set as a global property. 
 * <a href="https://openmrs.atlassian.net/wiki/spaces/docs/pages/101318663/Creating+Auto-Deactivating+User+Task">Documentation</a>
 * {@link OpenmrsConstants#GP_NUMBER_OF_DAYS_TO_AUTO_RETIRE_USERS}
 * 
 * @since 2.7.0
 */
public class AutoRetireUsersTask extends AbstractTask {
	
	private static final Logger log = LoggerFactory.getLogger(AutoRetireUsersTask.class);
	private static final String AUTO_RETIRE_REASON = "User retired due to inactivity";
	/**
	 * @see org.openmrs.scheduler.tasks.AbstractTask#execute()
	 */
	@Override
	public void execute() {
		if (!isExecuting) {
			log.debug("Auto-retiring users task Started");
			
			startExecuting();
			
			try {
				UserService userService = Context.getUserService();
				Set<User> usersToRetire = getUsersToRetire(userService);
				
				usersToRetire.forEach(user -> userService.retireUser(user, AUTO_RETIRE_REASON));
			} catch (Exception e) {
				log.error("Error occurred while auto-retiring users: ", e);
			} finally {
				log.debug("Auto-retiring users task ended");
				stopExecuting();
			}
		}
	}
	private Set<User> getUsersToRetire(UserService userService) {
		final List<User> allUsers = userService.getAllUsers();
		String numberOfDaysToRetire = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GP_NUMBER_OF_DAYS_TO_AUTO_RETIRE_USERS);
		
		if (StringUtils.isBlank(numberOfDaysToRetire)) {
			return Collections.emptySet();
		}
		
		long numberOfMillisecondsToRetire = TimeUnit.DAYS.toMillis(Long.parseLong(numberOfDaysToRetire));
		return allUsers.stream()
			.filter(user -> !user.isSuperUser() 
				&& !user.isRetired() 
				&& userInactivityExceedsDaysToRetire(user, numberOfMillisecondsToRetire)
			)
			.collect(Collectors.toSet());
	}
	private boolean userInactivityExceedsDaysToRetire(User user, long numberOfMillisecondsToRetire) {
		String lastLoginTimeString = Context.getUserService().getLastLoginTime(user);
		if (StringUtils.isNotBlank(lastLoginTimeString)) {
			long lastLoginTime = Long.parseLong(lastLoginTimeString);
			return System.currentTimeMillis() - lastLoginTime >= numberOfMillisecondsToRetire;
		} else {
			Date dateCreated = user.getDateCreated();
			
			if (dateCreated != null) {
				return System.currentTimeMillis() - dateCreated.getTime() >= numberOfMillisecondsToRetire;
			}
		}
		
		return false;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.notification.impl;
import java.io.Serializable;
import java.util.Date;
import java.util.List;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import org.openmrs.api.context.Daemon;
import org.openmrs.api.impl.BaseOpenmrsService;
import org.openmrs.notification.Alert;
import org.openmrs.notification.AlertRecipient;
import org.openmrs.notification.AlertService;
import org.openmrs.notification.db.AlertDAO;
import org.openmrs.util.RoleConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;
/**
 * This class should not be instantiated by itself.
 *
 * @see org.openmrs.notification.AlertService
 */
@Transactional
public class AlertServiceImpl extends BaseOpenmrsService implements Serializable, AlertService {
	
	private static final long serialVersionUID = 564561231321112365L;
	
	private static final Logger log = LoggerFactory.getLogger(AlertServiceImpl.class);
	
	private AlertDAO dao;
	
	/**
	 * Default constructor
	 */
	public AlertServiceImpl() {
	}
	
	/**
	 * @see org.openmrs.notification.AlertService#setAlertDAO(org.openmrs.notification.db.AlertDAO)
	 */
	@Override
	public void setAlertDAO(AlertDAO dao) {
		this.dao = dao;
	}
	
	/**
	 * @see org.openmrs.notification.AlertService#saveAlert(org.openmrs.notification.Alert)
	 */
	@Override
	public Alert saveAlert(Alert alert) throws APIException {
		log.debug("Create a alert " + alert);
		
		if (alert.getCreator() == null) {
			alert.setCreator(Context.getAuthenticatedUser());
		}
		if (alert.getDateCreated() == null) {
			alert.setDateCreated(new Date());
		}
		
		if (alert.getAlertId() != null) {
			alert.setChangedBy(Context.getAuthenticatedUser());
			alert.setDateChanged(new Date());
		}
		
		// Make sure all recipients are assigned to this alert
		if (alert.getRecipients() != null) {
			for (AlertRecipient recipient : alert.getRecipients()) {
				if (!alert.equals(recipient.getAlert())) {
					recipient.setAlert(alert);
				}
			}
		}
		
		return dao.saveAlert(alert);
	}
	/**
	 * @see org.openmrs.notification.AlertService#getAlert(java.lang.Integer)
	 */
	@Override
	@Transactional(readOnly = true)
	public Alert getAlert(Integer alertId) throws APIException {
		return dao.getAlert(alertId);
	}
	
	/**
	 * @see org.openmrs.notification.AlertService#purgeAlert(org.openmrs.notification.Alert)
	 */
	@Override
	public void purgeAlert(Alert alert) throws APIException {
		dao.deleteAlert(alert);
	}
	
	/**
	 * @see org.openmrs.notification.AlertService#getAllActiveAlerts(org.openmrs.User)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Alert> getAllActiveAlerts(User user) throws APIException {
		log.debug("Getting all active alerts for user " + user);
		return Context.getAlertService().getAlerts(user, true, false);
	}
	
	/**
	 * @see org.openmrs.notification.AlertService#getAlertsByUser(org.openmrs.User)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Alert> getAlertsByUser(User user) throws APIException {
		log.debug("Getting unread alerts for user " + user);
		
		if (user == null) {
			if (Context.isAuthenticated()) {
				user = Context.getAuthenticatedUser();
			} else {
				user = new User();
			}
		}
		
		return Context.getAlertService().getAlerts(user, false, false);
	}
	/**
	 * @see org.openmrs.notification.AlertService#getAlerts(org.openmrs.User, boolean, boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Alert> getAlerts(User user, boolean includeRead, boolean includeExpired) throws APIException {
		log.debug("Getting alerts for user " + user + " read? " + includeRead + " expired? " + includeExpired);
		return dao.getAlerts(user, includeRead, includeExpired);
	}
	
	/**
	 * @see org.openmrs.notification.AlertService#getAllAlerts()
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Alert> getAllAlerts() throws APIException {
		log.debug("Getting alerts for all users");
		return Context.getAlertService().getAllAlerts(false);
	}
	
	/**
	 * @see org.openmrs.notification.AlertService#getAllAlerts(boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Alert> getAllAlerts(boolean includeExpired) throws APIException {
		log.debug("Getting alerts for all users");
		return dao.getAllAlerts(includeExpired);
	}
	
	/**
	 * @see org.openmrs.notification.AlertService#notifySuperUsers(String, Exception, Object...)
	 */
	@Override
	public void notifySuperUsers(String messageCode, Exception cause, Object... messageArguments) {
		
		// Generate an internationalized error message with the beginning of the stack trace from cause added onto the end
		String message = Context.getMessageSourceService().getMessage(messageCode, messageArguments, Context.getLocale());
		
		if (cause != null) {
			StringBuilder stackTrace = new StringBuilder();
			// get the first two lines of the stack trace ( no more can fit in the alert text )
			
			for (StackTraceElement traceElement : cause.getStackTrace()) {
				stackTrace.append(traceElement);
				stackTrace.append("\n");
				if (stackTrace.length() >= Alert.TEXT_MAX_LENGTH) {
					break;
				}
			}
			
			message = message + ":" + stackTrace;
			
			//limit message to Alert.TEXT_MAX_LENGTH
			message = message.substring(0, Math.min(message.length(), Alert.TEXT_MAX_LENGTH));
		}
		
		//Send an alert to all administrators
		Alert alert = new Alert(message, Context.getUserService().getUsersByRole(new Role(RoleConstants.SUPERUSER)));
		
		// Set the alert so that if any administrator 'reads' it it will be marked as read for everyone who received it
		alert.setSatisfiedByAny(true);
		
		//If there is not user creator for the alert ( because it is being created at start-up )create a user
		if (alert.getCreator() == null) { 
			User daemonUser = Context.getUserService().getUserByUuid(Daemon.getDaemonUserUuid());
			alert.setCreator(daemonUser);
		} 
		
		// save the alert to send it to all administrators
		Context.getAlertService().saveAlert(alert);
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api.impl;
import org.apache.commons.lang.RandomStringUtils;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Person;
import org.openmrs.Privilege;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.annotation.Authorized;
import org.openmrs.annotation.Logging;
import org.openmrs.api.*;
import org.openmrs.api.context.Context;
import org.openmrs.api.context.Daemon;
import org.openmrs.api.db.DAOException;
import org.openmrs.api.db.LoginCredential;
import org.openmrs.api.db.UserDAO;
import org.openmrs.messagesource.MessageSourceService;
import org.openmrs.notification.MessageException;
import org.openmrs.patient.impl.LuhnIdentifierValidator;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.util.RoleConstants;
import org.openmrs.util.Security;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.transaction.annotation.Transactional;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;
/**
 * Default implementation of the user service. This class should not be used on its own. The current
 * OpenMRS implementation should be fetched from the Context
 *
 * @see org.openmrs.api.UserService
 * @see org.openmrs.api.context.Context
 */
@Transactional
public class UserServiceImpl extends BaseOpenmrsService implements UserService {
	
	private static final Logger log = LoggerFactory.getLogger(UserServiceImpl.class);
	
	protected UserDAO dao;
	
	private static final int MAX_VALID_TIME = 12 * 60 * 60 * 1000; //Period of 12 hours
	
	private static final int MIN_VALID_TIME = 60 * 1000; //Period of 1 minute
	
	private static final int DEFAULT_VALID_TIME = 10 * 60 * 1000; //Default time of 10 minute
	
	public UserServiceImpl() {
	}
	
	public void setUserDAO(UserDAO dao) {
		this.dao = dao;
	}
	
	/**
	 * @return the validTime for which the password reset activation key will be valid
	 */
	private int getValidTime() {
		String validTimeGp = Context.getAdministrationService()
			.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_RESET_VALIDTIME);
		final int validTime = StringUtils.isBlank(validTimeGp) ? DEFAULT_VALID_TIME : Integer.parseInt(validTimeGp);
		//if valid time is less that a minute or greater than 12hrs reset valid time to 1 minutes else set it to the required time.
		return (validTime < MIN_VALID_TIME) || (validTime > MAX_VALID_TIME) ? DEFAULT_VALID_TIME : validTime;
	}
	
	/**
	 * @see org.openmrs.api.UserService#createUser(org.openmrs.User, java.lang.String)
	 */
	@Override
	public User createUser(User user, String password) throws APIException {
		if (user.getUserId() != null) {
			throw new APIException("This method can be used for only creating new users");
		}
		
		Context.requirePrivilege(PrivilegeConstants.ADD_USERS);
		
		checkPrivileges(user);
		
		// if a password wasn't supplied, throw an error
		if (password == null || password.length() < 1) {
			throw new APIException("User.creating.password.required", (Object[]) null);
		}
		
		if (hasDuplicateUsername(user)) {
			throw new DAOException("Username " + user.getUsername() + " or system id " + user.getSystemId()
				+ " is already in use.");
		}
		
		// TODO Check required fields for user!!
		OpenmrsUtil.validatePassword(user.getUsername(), password, user.getSystemId());
		
		return dao.saveUser(user, password);
	}
	
	/**
	 * @see org.openmrs.api.UserService#getUser(java.lang.Integer)
	 */
	@Override
	@Transactional(readOnly = true)
	public User getUser(Integer userId) throws APIException {
		return dao.getUser(userId);
	}
	
	/**
	 * @see org.openmrs.api.UserService#getUserByUsername(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public User getUserByUsername(String username) throws APIException {
		return dao.getUserByUsername(username);
	}
	
	/**
	 * @see org.openmrs.api.UserService#hasDuplicateUsername(org.openmrs.User)
	 */
	@Override
	@Transactional(readOnly = true)
	public boolean hasDuplicateUsername(User user) throws APIException {
		return dao.hasDuplicateUsername(user.getUsername(), user.getSystemId(), user.getUserId());
	}
	
	/**
	 * @see org.openmrs.api.UserService#getUsersByRole(org.openmrs.Role)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<User> getUsersByRole(Role role) throws APIException {
		List<Role> roles = new ArrayList<>();
		roles.add(role);
		
		return Context.getUserService().getUsers(null, roles, false);
	}
	
	/**
	 * @see org.openmrs.api.UserService#saveUser(org.openmrs.User)
	 */
	@Override
	@CacheEvict(value = "userSearchLocales", allEntries = true)
	public User saveUser(User user) throws APIException {
		if (user.getUserId() == null) {
			throw new APIException("This method can be called only to update existing users");
		}
		
		Context.requirePrivilege(PrivilegeConstants.EDIT_USERS);
		
		checkPrivileges(user);
		
		if (hasDuplicateUsername(user)) {
			throw new DAOException("Username " + user.getUsername() + " or system id " + user.getSystemId()
				+ " is already in use.");
		}
		
		return dao.saveUser(user, null);
	}
	
	public User voidUser(User user, String reason) throws APIException {
		return Context.getUserService().retireUser(user, reason);
	}
	
	/**
	 * @see org.openmrs.api.UserService#retireUser(org.openmrs.User, java.lang.String)
	 */
	@Override
	public User retireUser(User user, String reason) throws APIException {
		user.setRetired(true);
		user.setRetireReason(reason);
		user.setRetiredBy(Context.getAuthenticatedUser());
		user.setDateRetired(new Date());
		
		return saveUser(user);
	}
	
	public User unvoidUser(User user) throws APIException {
		return Context.getUserService().unretireUser(user);
	}
	
	/**
	 * @see org.openmrs.api.UserService#unretireUser(org.openmrs.User)
	 */
	@Override
	public User unretireUser(User user) throws APIException {
		user.setRetired(false);
		user.setRetireReason(null);
		user.setRetiredBy(null);
		user.setDateRetired(null);
		
		return saveUser(user);
	}
	
	/**
	 * @see org.openmrs.api.UserService#getAllUsers()
	 */
	@Override
	@Transactional(readOnly = true)
	public List<User> getAllUsers() throws APIException {
		return dao.getAllUsers();
	}
	
	/**
	 * @see org.openmrs.api.UserService#getAllPrivileges()
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Privilege> getAllPrivileges() throws APIException {
		return dao.getAllPrivileges();
	}
	
	/**
	 * @see org.openmrs.api.UserService#getPrivilege(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public Privilege getPrivilege(String p) throws APIException {
		return dao.getPrivilege(p);
	}
	
	/**
	 * @see org.openmrs.api.UserService#purgePrivilege(org.openmrs.Privilege)
	 */
	@Override
	public void purgePrivilege(Privilege privilege) throws APIException {
		if (OpenmrsUtil.getCorePrivileges().keySet().contains(privilege.getPrivilege())) {
			throw new APIException("Privilege.cannot.delete.core", (Object[]) null);
		}
		
		dao.deletePrivilege(privilege);
	}
	
	/**
	 * @see org.openmrs.api.UserService#savePrivilege(org.openmrs.Privilege)
	 */
	@Override
	public Privilege savePrivilege(Privilege privilege) throws APIException {
		return dao.savePrivilege(privilege);
	}
	
	/**
	 * @see org.openmrs.api.UserService#getAllRoles()
	 */
	@Override
	@Transactional(readOnly = true)
	public List<Role> getAllRoles() throws APIException {
		return dao.getAllRoles();
	}
	
	/**
	 * @see org.openmrs.api.UserService#getRole(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public Role getRole(String r) throws APIException {
		return dao.getRole(r);
	}
	
	/**
	 * @see org.openmrs.api.UserService#purgeRole(org.openmrs.Role)
	 */
	@Override
	public void purgeRole(Role role) throws APIException {
		if (role == null || role.getRole() == null) {
			return;
		}
		
		if (OpenmrsUtil.getCoreRoles().keySet().contains(role.getRole())) {
			throw new APIException("Role.cannot.delete.core", (Object[]) null);
		}
		
		if (role.hasChildRoles()) {
			throw new CannotDeleteRoleWithChildrenException();
		}
		
		dao.deleteRole(role);
	}
	
	/**
	 * @see org.openmrs.api.UserService#saveRole(org.openmrs.Role)
	 */
	@Override
	public Role saveRole(Role role) throws APIException {
		// make sure one of the parents of this role isn't itself...this would
		// cause an infinite loop
		if (role.getAllParentRoles().contains(role)) {
			throw new APIException("Role.cannot.inherit.descendant", (Object[]) null);
		}
		
		checkPrivileges(role);
		
		return dao.saveRole(role);
	}
	
	/**
	 * @see org.openmrs.api.UserService#changePassword(java.lang.String, java.lang.String)
	 */
	@Override
	public void changePassword(String oldPassword, String newPassword) throws APIException {
		User user = Context.getAuthenticatedUser();
		changePassword(user, oldPassword, newPassword);
	}
	
	/**
	 * @see org.openmrs.api.UserService#changeHashedPassword(User, String, String)
	 */
	@Override
	public void changeHashedPassword(User user, String hashedPassword, String salt) throws APIException {
		dao.changeHashedPassword(user, hashedPassword, salt);
	}
	
	/**
	 * @see org.openmrs.api.UserService#changeQuestionAnswer(User, String, String)
	 */
	@Override
	public void changeQuestionAnswer(User u, String question, String answer) throws APIException {
		dao.changeQuestionAnswer(u, question, answer);
	}
	
	/**
	 * @see org.openmrs.api.UserService#changeQuestionAnswer(java.lang.String, java.lang.String,
	 * java.lang.String)
	 */
	@Override
	public void changeQuestionAnswer(String pw, String q, String a) {
		dao.changeQuestionAnswer(pw, q, a);
	}
	
	/**
	 * @see org.openmrs.api.UserService#isSecretAnswer(org.openmrs.User, java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public boolean isSecretAnswer(User u, String answer) {
		return dao.isSecretAnswer(u, answer);
	}
	
	/**
	 * @see org.openmrs.api.UserService#getUsersByName(java.lang.String, java.lang.String, boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<User> getUsersByName(String givenName, String familyName, boolean includeVoided) throws APIException {
		return dao.getUsersByName(givenName, familyName, includeVoided);
	}
	
	/**
	 * @see org.openmrs.api.UserService#getUsersByPerson(org.openmrs.Person, boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<User> getUsersByPerson(Person person, boolean includeRetired) throws APIException {
		return dao.getUsersByPerson(person, includeRetired);
	}
	
	/**
	 * @see org.openmrs.api.UserService#getUsers(java.lang.String, java.util.List, boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<User> getUsers(String nameSearch, List<Role> roles, boolean includeVoided) throws APIException {
		return Context.getUserService().getUsers(nameSearch, roles, includeVoided, null, null);
	}
	
	/**
	 * Convenience method to check if the authenticated user has all privileges they are giving out
	 *
	 * @param user user that has privileges
	 */
	private void checkPrivileges(User user) {
		List<String> requiredPrivs = user.getAllRoles().stream().peek(this::checkSuperUserPrivilege)
			.map(Role::getPrivileges).filter(Objects::nonNull).flatMap(Collection::stream)
			.map(Privilege::getPrivilege).filter(p -> !Context.hasPrivilege(p)).sorted().collect(Collectors.toList());
		if (requiredPrivs.size() == 1) {
			throw new APIException("User.you.must.have.privilege", new Object[] { requiredPrivs.get(0) });
		} else if (requiredPrivs.size() > 1) {
			throw new APIException("User.you.must.have.privileges", new Object[] { String.join(", ", requiredPrivs) });
		}
	}
	
	private void checkSuperUserPrivilege(Role r) {
		if (r.getRole().equals(RoleConstants.SUPERUSER)
			&& !Context.hasPrivilege(PrivilegeConstants.ASSIGN_SYSTEM_DEVELOPER_ROLE)) {
			throw new APIException("User.you.must.have.role", new Object[] { RoleConstants.SUPERUSER });
		}
	}
	
	/**
	 * @see org.openmrs.api.UserService#setUserProperty(User, String, String)
	 */
	@Override
	public User setUserProperty(User user, String key, String value) {
		if (user != null) {
			if (!Context.hasPrivilege(PrivilegeConstants.EDIT_USERS) && !user.equals(Context.getAuthenticatedUser())) {
				throw new APIException("you.are.not.authorized.change.properties", new Object[] { user.getUserId() });
			}
			
			user.setUserProperty(key, value);
			try {
				Context.addProxyPrivilege(PrivilegeConstants.EDIT_USERS);
				Context.getUserService().saveUser(user);
			}
			finally {
				Context.removeProxyPrivilege(PrivilegeConstants.EDIT_USERS);
			}
		}
		
		return user;
	}
	
	/**
	 * @see org.openmrs.api.UserService#removeUserProperty(org.openmrs.User, java.lang.String)
	 */
	@Override
	public User removeUserProperty(User user, String key) {
		if (user != null) {
			
			// if the current user isn't allowed to edit users and
			// the user being edited is not the current user, throw an
			// exception
			if (!Context.hasPrivilege(PrivilegeConstants.EDIT_USERS) && !user.equals(Context.getAuthenticatedUser())) {
				throw new APIException("you.are.not.authorized.change.properties", new Object[] { user.getUserId() });
			}
			
			user.removeUserProperty(key);
			
			try {
				Context.addProxyPrivilege(PrivilegeConstants.EDIT_USERS);
				Context.getUserService().saveUser(user);
			}
			finally {
				Context.removeProxyPrivilege(PrivilegeConstants.EDIT_USERS);
			}
		}
		
		return user;
	}
	
	/**
	 * Generates system ids based on the following algorithm scheme: user_id-check digit
	 *
	 * @see org.openmrs.api.UserService#generateSystemId()
	 */
	@Override
	@Transactional(readOnly = true)
	public String generateSystemId() {
		// Hardcoding Luhn algorithm since all existing openmrs user ids have
		// had check digits generated this way.
		LuhnIdentifierValidator liv = new LuhnIdentifierValidator();
		
		String systemId;
		Integer offset = 0;
		do {
			// generate and increment the system id if necessary
			Integer generatedId = dao.generateSystemId() + offset++;
			
			systemId = generatedId.toString();
			
			try {
				systemId = liv.getValidIdentifier(systemId);
			}
			catch (Exception e) {
				log.error("error getting check digit", e);
				return systemId;
			}
			
			// loop until we find a system id that no one has 
		} while (dao.hasDuplicateUsername(null, systemId, null));
		
		return systemId;
	}
	
	/**
	 * @see org.openmrs.api.UserService#purgeUser(org.openmrs.User)
	 */
	@Override
	public void purgeUser(User user) throws APIException {
		dao.deleteUser(user);
	}
	
	/**
	 * @see org.openmrs.api.UserService#purgeUser(org.openmrs.User, boolean)
	 */
	@Override
	public void purgeUser(User user, boolean cascade) throws APIException {
		if (cascade) {
			throw new APIException("cascade.do.not.think", (Object[]) null);
		}
		
		dao.deleteUser(user);
	}
	
	/**
	 * Convenience method to check if the authenticated user has all privileges they are giving out
	 * to the new role
	 *
	 * @param role
	 */
	private void checkPrivileges(Role role) {
		Optional.ofNullable(role.getPrivileges())
			.map(p -> p.stream().filter(pr -> !Context.hasPrivilege(pr.getPrivilege())).map(Privilege::getPrivilege)
				.distinct().collect(Collectors.joining(", ")))
			.ifPresent(missing -> {
				if (StringUtils.isNotBlank(missing)) {
					throw new APIException("Role.you.must.have.privileges", new Object[] { missing });
				}
			});
	}
	
	/**
	 * @see org.openmrs.api.UserService#getPrivilegeByUuid(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public Privilege getPrivilegeByUuid(String uuid) throws APIException {
		return dao.getPrivilegeByUuid(uuid);
	}
	
	/**
	 * @see org.openmrs.api.UserService#getRoleByUuid(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public Role getRoleByUuid(String uuid) throws APIException {
		return dao.getRoleByUuid(uuid);
	}
	
	/**
	 * @see org.openmrs.api.UserService#getUserByUuid(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public User getUserByUuid(String uuid) throws APIException {
		return dao.getUserByUuid(uuid);
	}
	
	/**
	 * @see UserService#getCountOfUsers(String, List, boolean)
	 */
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfUsers(String name, List<Role> roles, boolean includeRetired) {
		if (name != null) {
			name = StringUtils.replace(name, ", ", " ");
		}
		
		// if the authenticated role is in the list of searched roles, then all
		// persons should be searched
		Role authRole = getRole(RoleConstants.AUTHENTICATED);
		if (roles.contains(authRole)) {
			return dao.getCountOfUsers(name, new ArrayList<>(), includeRetired);
		}
		
		return dao.getCountOfUsers(name, roles, includeRetired);
	}
	
	/**
	 * @see UserService#getUsers(String, List, boolean, Integer, Integer)
	 */
	@Override
	@Transactional(readOnly = true)
	public List<User> getUsers(String name, List<Role> roles, boolean includeRetired, Integer start, Integer length)
		throws APIException {
		if (name != null) {
			name = StringUtils.replace(name, ", ", " ");
		}
		
		if (roles == null) {
			roles = new ArrayList<>();
		}
		
		// if the authenticated role is in the list of searched roles, then all
		// persons should be searched
		Role authRole = getRole(RoleConstants.AUTHENTICATED);
		if (roles.contains(authRole)) {
			return dao.getUsers(name, new ArrayList<>(), includeRetired, start, length);
		}
		
		// add the requested roles and all child roles for consideration
		Set<Role> allRoles = new HashSet<>();
		for (Role r : roles) {
			allRoles.add(r);
			allRoles.addAll(r.getAllChildRoles());
		}
		
		return dao.getUsers(name, new ArrayList<>(allRoles), includeRetired, start, length);
	}
	
	@Override
	public User saveUserProperty(String key, String value) {
		User user = Context.getAuthenticatedUser();
		if (user == null) {
			throw new APIException("no.authenticated.user.found", (Object[]) null);
		}
		user.setUserProperty(key, value);
		return dao.saveUser(user, null);
	}
	
	@Override
	public User saveUserProperties(Map<String, String> properties) {
		User user = Context.getAuthenticatedUser();
		if (user == null) {
			throw new APIException("no.authenticated.user.found", (Object[]) null);
		}
		user.getUserProperties().clear();
		for (Map.Entry<String, String> entry : properties.entrySet()) {
			user.setUserProperty(entry.getKey(), entry.getValue());
		}
		return dao.saveUser(user, null);
	}
	
	/**
	 * @see UserService#changePassword(User, String, String)
	 */
	@Override
	@Authorized(PrivilegeConstants.EDIT_USER_PASSWORDS)
	@Logging(ignoredArgumentIndexes = { 1, 2 })
	public void changePassword(User user, String oldPassword, String newPassword) throws APIException {
		if (user.getUserId() == null) {
			throw new APIException("user.must.exist", (Object[]) null);
		}
		
		if (oldPassword == null) {
			if (!Context.hasPrivilege(PrivilegeConstants.EDIT_USER_PASSWORDS)) {
				throw new APIException("null.old.password.privilege.required", (Object[]) null);
			}
		} else if (!dao.getLoginCredential(user).checkPassword(oldPassword)) {
			throw new APIException("old.password.not.correct", (Object[]) null);
			
		} else if (oldPassword.equals(newPassword)) {
			throw new APIException("new.password.equal.to.old", (Object[]) null);
		}
		
		if (("admin".equals(user.getSystemId()) || "admin".equals(user.getUsername())) && Boolean.parseBoolean(
			Context.getRuntimeProperties().getProperty(ADMIN_PASSWORD_LOCKED_PROPERTY, "false"))) {
			throw new APIException("admin.password.is.locked");
		}
		
		updatePassword(user, newPassword);
	}
	
	@Override
	public void changePassword(User user, String newPassword) {
		updatePassword(user, newPassword);
	}
	
	private void updatePassword(User user, String newPassword) {
		OpenmrsUtil.validatePassword(user.getUsername(), newPassword, user.getSystemId());
		dao.changePassword(user, newPassword);
	}
	
	@Override
	public void changePasswordUsingSecretAnswer(String secretAnswer, String pw) throws APIException {
		User user = Context.getAuthenticatedUser();
		if (!isSecretAnswer(user, secretAnswer)) {
			throw new APIException("secret.answer.not.correct", (Object[]) null);
		}
		updatePassword(user, pw);
	}
	
	@Override
	public String getSecretQuestion(User user) throws APIException {
		if (user.getUserId() != null) {
			LoginCredential loginCredential = dao.getLoginCredential(user);
			return loginCredential.getSecretQuestion();
		} else {
			return null;
		}
	}
	
	/**
	 * @see org.openmrs.api.UserService#getUserByUsernameOrEmail(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public User getUserByUsernameOrEmail(String usernameOrEmail) {
		if (StringUtils.isNotBlank(usernameOrEmail)) {
			User user = dao.getUserByEmail(usernameOrEmail);
			if (user == null) {
				return getUserByUsername(usernameOrEmail);
			}
			return user;
		}
		throw new APIException("error.usernameOrEmail.notNullOrBlank", (Object[]) null);
	}
	
	/**
	 * @see org.openmrs.api.UserService#getUserByActivationKey(java.lang.String)
	 */
	@Override
	@Transactional(readOnly = true)
	public User getUserByActivationKey(String activationKey) {
		LoginCredential loginCred = dao.getLoginCredentialByActivationKey(activationKey);
		if (loginCred != null) {
			String[] credTokens = loginCred.getActivationKey().split(":");
			if (System.currentTimeMillis() <= Long.parseLong(credTokens[1])) {
				return getUser(loginCred.getUserId());
			}
		}
		return null;
	}
	
	/**
	 * @throws APIException
	 * @throws MessageException
	 * @see org.openmrs.api.UserService#setUserActivationKey(org.openmrs.User)
	 */
	@Override
	public User setUserActivationKey(User user) throws MessageException {
		String token = RandomStringUtils.randomAlphanumeric(20);
		long time = System.currentTimeMillis() + getValidTime();
		String hashedKey = Security.encodeString(token);
		String activationKey = hashedKey + ":" + time;
		LoginCredential credentials = dao.getLoginCredential(user);
		credentials.setActivationKey(activationKey);
		dao.setUserActivationKey(credentials);
		
		MessageSourceService messages = Context.getMessageSourceService();
		AdministrationService adminService = Context.getAdministrationService();
		Locale locale = getDefaultLocaleForUser(user);
		
		//		Delete this method call when removing {@link OpenmrsConstants#GP_HOST_URL}
		copyHostURLGlobalPropertyToPasswordResetGlobalProperty(adminService);
		
		String link = adminService.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_RESET_URL)
			.replace("{activationKey}", token);
		
		Properties mailProperties = Context.getMailProperties();
		
		String sender = mailProperties.getProperty("mail.from");
		
		String subject = messages.getMessage("mail.passwordreset.subject", null, locale);
		
		String msg = messages.getMessage("mail.passwordreset.content", null, locale)
			.replace("{name}", user.getUsername())
			.replace("{link}", link)
			.replace("{time}", String.valueOf(getValidTime() / 60000));
		
		Context.getMessageService().sendMessage(user.getEmail(), sender, subject, msg);
		
		return user;
	}
	
	/**
	 * Delete this method when deleting {@link OpenmrsConstants#GP_HOST_URL}
	 */
	private void copyHostURLGlobalPropertyToPasswordResetGlobalProperty(AdministrationService adminService) {
		String hostURLGP = adminService.getGlobalProperty(OpenmrsConstants.GP_HOST_URL);
		String passwordResetGP = adminService.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_RESET_URL);
		if (StringUtils.isNotBlank(hostURLGP) && StringUtils.isBlank(passwordResetGP)) {
			adminService.setGlobalProperty(OpenmrsConstants.GP_PASSWORD_RESET_URL, hostURLGP);
		}
	}
	
	/**
	 * @see UserService#getDefaultLocaleForUser(User)
	 */
	@Override
	public Locale getDefaultLocaleForUser(User user) {
		Locale locale = null;
		if (user != null) {
			try {
				String preferredLocale = user.getUserProperty(OpenmrsConstants.USER_PROPERTY_DEFAULT_LOCALE);
				if (StringUtils.isNotBlank(preferredLocale)) {
					locale = LocaleUtility.fromSpecification(preferredLocale);
				}
			}
			catch (Exception e) {
				log.warn("Unable to parse user locale into a Locale", e);
			}
		}
		if (locale == null) {
			locale = Context.getLocale();
		}
		return locale;
	}
	
	/**
	 * @see org.openmrs.api.UserService#changePasswordUsingActivationKey(String, String);
	 */
	@Override
	public void changePasswordUsingActivationKey(String activationKey, String newPassword) {
		User user = getUserByActivationKey(activationKey);
		if (user == null) {
			throw new InvalidActivationKeyException("activation.key.not.correct");
		}
		
		updatePassword(user, newPassword);
	}
	/**
	 * @see org.openmrs.api.UserService#getLastLoginTime(User)
	 */
	public String getLastLoginTime(User user) {
		return dao.getLastLoginTime(user);
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api.context;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import org.aopalliance.aop.Advice;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.CohortService;
import org.openmrs.api.ConceptService;
import org.openmrs.api.ConditionService;
import org.openmrs.api.DatatypeService;
import org.openmrs.api.DiagnosisService;
import org.openmrs.api.EncounterService;
import org.openmrs.api.FormService;
import org.openmrs.api.LocationService;
import org.openmrs.api.MedicationDispenseService;
import org.openmrs.api.ObsService;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.OrderService;
import org.openmrs.api.OrderSetService;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.ProviderService;
import org.openmrs.api.SerializationService;
import org.openmrs.api.ServiceNotFoundException;
import org.openmrs.api.UserService;
import org.openmrs.api.VisitService;
import org.openmrs.hl7.HL7Service;
import org.openmrs.logic.LogicService;
import org.openmrs.messagesource.MessageSourceService;
import org.openmrs.messagesource.impl.DefaultMessageSourceServiceImpl;
import org.openmrs.notification.AlertService;
import org.openmrs.notification.MessageService;
import org.openmrs.scheduler.SchedulerService;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsThreadPoolHolder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Advisor;
import org.springframework.aop.framework.Advised;
import org.springframework.aop.framework.ProxyFactory;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
/**
 * Represents an OpenMRS <code>Service Context</code>, which returns the services represented
 * throughout the system. <br>
 * <br>
 * This class should not be access directly, but rather used through the <code>Context</code> class. <br>
 * <br>
 * This class is essentially static and only one instance is kept because this is fairly
 * heavy-weight. Spring takes care of filling in the actual service implementations via dependency
 * injection. See the /metadata/api/spring/applicationContext-service.xml file. <br>
 * <br>
 * Module services are also accessed through this class. See {@link #getService(Class)}
 *
 * @see org.openmrs.api.context.Context
 */
public class ServiceContext implements ApplicationContextAware {
	
	private static final Logger log = LoggerFactory.getLogger(ServiceContext.class);
	private ApplicationContext applicationContext;
	
	private static boolean refreshingContext = false;
	
	private static final Object refreshingContextLock = new Object();
	
	/**
	 * Static variable holding whether or not to use the system classloader. By default this is
	 * false so the openmrs classloader is used instead
	 */
	private boolean useSystemClassLoader = false;
	
	// Cached service objects
	Map<Class, Object> services = new HashMap<>();
	
	// Advisors added to services by this service
	Map<Class, Set<Advisor>> addedAdvisors = new HashMap<>();
	
	// Advice added to services by this service
	Map<Class, Set<Advice>> addedAdvice = new HashMap<>();
	
	/**
	 * Services implementing the OpenmrsService interface for each module. The map is keyed by the
	 * full class name including package.
	 *
	 * @since 1.9
	 */
	Map<String, OpenmrsService> moduleOpenmrsServices = new HashMap<>();
	
	/**
	 * The default constructor is private so as to keep only one instance per java vm.
	 *
	 * @see ServiceContext#getInstance()
	 */
	private ServiceContext() {
		log.debug("Instantiating service context");
	}
	
	private static class ServiceContextHolder {
		private ServiceContextHolder() {
		}
		private static ServiceContext instance = null;
	}
	
	/**
	 * There should only be one ServiceContext per openmrs (java virtual machine). This method
	 * should be used when wanting to fetch the service context Note: The ServiceContext shouldn't
	 * be used independently. All calls should go through the Context
	 *
	 * @return This VM's current ServiceContext.
	 * @see org.openmrs.api.context.Context
	 */
	public static ServiceContext getInstance() {
		if (ServiceContextHolder.instance == null) {
			ServiceContextHolder.instance = new ServiceContext();
		}
		
		return ServiceContextHolder.instance;
	}
	
	/**
	 * Null out the current instance of the ServiceContext. This should be used when modules are
	 * refreshing (being added/removed) and/or openmrs is shutting down
	 */
	public static void destroyInstance() {
		if (ServiceContextHolder.instance != null && ServiceContextHolder.instance.services != null) {
			for (Map.Entry<Class, Object> entry : ServiceContextHolder.instance.services.entrySet()) {
				log.debug("Service - {} : {}", entry.getKey().getName(), entry.getValue());
			}
			
			// Remove advice and advisors that this service added
			for (Class serviceClass : ServiceContextHolder.instance.services.keySet()) {
				ServiceContextHolder.instance.removeAddedAOP(serviceClass);
			}
			
			if (ServiceContextHolder.instance.services != null) {
				ServiceContextHolder.instance.services.clear();
				ServiceContextHolder.instance.services = null;
			}
			
			if (ServiceContextHolder.instance.addedAdvisors != null) {
				ServiceContextHolder.instance.addedAdvisors.clear();
				ServiceContextHolder.instance.addedAdvisors = null;
			}
			
			if (ServiceContextHolder.instance.addedAdvice != null) {
				ServiceContextHolder.instance.addedAdvice.clear();
				ServiceContextHolder.instance.addedAdvice = null;
			}
		}
		
		if (ServiceContextHolder.instance != null) {
			ServiceContextHolder.instance.applicationContext = null;
			
			if (ServiceContextHolder.instance.moduleOpenmrsServices != null) {
				ServiceContextHolder.instance.moduleOpenmrsServices.clear();
				ServiceContextHolder.instance.moduleOpenmrsServices = null;
			}
		}
		log.debug("Destroying ServiceContext instance: {}", ServiceContextHolder.instance);
		ServiceContextHolder.instance = null;
	}
	
	/**
	 * @return encounter-related services
	 */
	public EncounterService getEncounterService() {
		return getService(EncounterService.class);
	}
	
	/**
	 * @return location services
	 */
	public LocationService getLocationService() {
		return getService(LocationService.class);
	}
	
	/**
	 * @return observation services
	 */
	public ObsService getObsService() {
		return getService(ObsService.class);
	}
	
	/**
	 * @return condition related service
	 * 
	 * @since 2.2
	 */
	public ConditionService getConditionService() {
		return getService(ConditionService.class);
	}
	
	/**
	 * @param conditionService condition related service
	 *            
	 * @since 2.2   
	 */
	public void setConditionService(ConditionService conditionService) {
		setService(ConditionService.class, conditionService);
	}
	/**
	 * @return diagnosis related service
	 *
	 * @since 2.2
	 */
	public DiagnosisService getDiagnosisService() {
		return getService(DiagnosisService.class);
	}
	/**
	 * @param diagnosisService diagnosis related service
	 *
	 * @since 2.2
	 */
	public void setDiagnosisService(DiagnosisService diagnosisService) {
		setService(DiagnosisService.class, diagnosisService);
	}
	/**
	 * @return MedicationDispense related service
	 * @since 2.6.0
	 */
	public MedicationDispenseService getMedicationDispenseService() {
		return getService(MedicationDispenseService.class);
	}
	/**
	 * @param medicationDispenseService MedicationDispense related service
	 * @since 2.6.0
	 */
	public void setMedicationDispenseService(MedicationDispenseService medicationDispenseService) {
		setService(MedicationDispenseService.class, medicationDispenseService);
	}
	
	/**
	 * @return cohort related service
	 */
	public CohortService getCohortService() {
		return getService(CohortService.class);
	}
	
	/**
	 * @param cs cohort related service
	 */
	public void setCohortService(CohortService cs) {
		setService(CohortService.class, cs);
	}
	
	/**
	 * @return order set service
	 */
	public OrderSetService getOrderSetService() {
		return getService(OrderSetService.class);
	}
	
	/**
	 * @return order service
	 */
	public OrderService getOrderService() {
		return getService(OrderService.class);
	}
	
	/**
	 * @return form service
	 */
	public FormService getFormService() {
		return getService(FormService.class);
	}
	
	/**
	 * @return serialization service
	 */
	public SerializationService getSerializationService() {
		return getService(SerializationService.class);
	}
	
	/**
	 * @return admin-related services
	 */
	public AdministrationService getAdministrationService() {
		return getService(AdministrationService.class);
	}
	
	/**
	 * @return programWorkflowService
	 */
	public ProgramWorkflowService getProgramWorkflowService() {
		return getService(ProgramWorkflowService.class);
	}
	/**
	 * @return logicService
	 */
	public LogicService getLogicService() {
		return getService(LogicService.class);
	}
	
	/**
	 * @return scheduler service
	 */
	public SchedulerService getSchedulerService() {
		return getService(SchedulerService.class);
	}
	
	/**
	 * Set the scheduler service.
	 *
	 * @param schedulerService
	 */
	public void setSchedulerService(SchedulerService schedulerService) {
		setService(SchedulerService.class, schedulerService);
	}
	
	/**
	 * @return alert service
	 */
	public AlertService getAlertService() {
		return getService(AlertService.class);
	}
	
	/**
	 * @param alertService
	 */
	public void setAlertService(AlertService alertService) {
		setService(AlertService.class, alertService);
	}
	
	/**
	 * @param programWorkflowService
	 */
	public void setProgramWorkflowService(ProgramWorkflowService programWorkflowService) {
		setService(ProgramWorkflowService.class, programWorkflowService);
	}
	/**
	 * @param logicService
	 */
	public void setLogicService(LogicService logicService) {
		setService(LogicService.class, logicService);
	}
	
	/**
	 * @return message service
	 */
	public MessageService getMessageService() {
		return getService(MessageService.class);
	}
	
	/**
	 * Sets the message service.
	 *
	 * @param messageService
	 */
	public void setMessageService(MessageService messageService) {
		setService(MessageService.class, messageService);
	}
	
	/**
	 * @return the hl7Service
	 */
	public HL7Service getHL7Service() {
		return getService(HL7Service.class);
	}
	
	/**
	 * @param hl7Service the hl7Service to set
	 */
	public void setHl7Service(HL7Service hl7Service) {
		setService(HL7Service.class, hl7Service);
	}
	
	/**
	 * @param administrationService the administrationService to set
	 */
	public void setAdministrationService(AdministrationService administrationService) {
		setService(AdministrationService.class, administrationService);
	}
	
	/**
	 * @param encounterService the encounterService to set
	 */
	public void setEncounterService(EncounterService encounterService) {
		setService(EncounterService.class, encounterService);
	}
	
	/**
	 * @param locationService the LocationService to set
	 */
	public void setLocationService(LocationService locationService) {
		setService(LocationService.class, locationService);
	}
	
	/**
	 * @param formService the formService to set
	 */
	public void setFormService(FormService formService) {
		setService(FormService.class, formService);
	}
	
	/**
	 * @param obsService the obsService to set
	 */
	public void setObsService(ObsService obsService) {
		setService(ObsService.class, obsService);
	}
	/**
	 * @param orderService the orderService to set
	 */
	public void setOrderService(OrderService orderService) {
		setService(OrderService.class, orderService);
	}
	
	/**
	 * @param orderSetService the orderSetService to set
	 */
	public void setOrderSetService(OrderSetService orderSetService) {
		setService(OrderSetService.class, orderSetService);
	}
	
	/**
	 * @param serializationService
	 */
	public void setSerializationService(SerializationService serializationService) {
		setService(SerializationService.class, serializationService);
	}
	
	/**
	 * @return patient related services
	 */
	public PatientService getPatientService() {
		return getService(PatientService.class);
	}
	
	/**
	 * @param patientService the patientService to set
	 */
	public void setPatientService(PatientService patientService) {
		setService(PatientService.class, patientService);
	}
	
	/**
	 * @return person related services
	 */
	public PersonService getPersonService() {
		return getService(PersonService.class);
	}
	
	/**
	 * @param personService the personService to set
	 */
	public void setPersonService(PersonService personService) {
		setService(PersonService.class, personService);
	}
	
	/**
	 * @return concept related services
	 */
	public ConceptService getConceptService() {
		return getService(ConceptService.class);
	}
	
	/**
	 * @param conceptService the conceptService to set
	 */
	public void setConceptService(ConceptService conceptService) {
		setService(ConceptService.class, conceptService);
	}
	
	/**
	 * @return user-related services
	 */
	public UserService getUserService() {
		return getService(UserService.class);
	}
	
	/**
	 * @param userService the userService to set
	 */
	public void setUserService(UserService userService) {
		setService(UserService.class, userService);
	}
	
	/**
	 * Gets the MessageSourceService used in the context.
	 *
	 * @return MessageSourceService
	 */
	public MessageSourceService getMessageSourceService() {
		try {
			return getService(MessageSourceService.class);
		}
		catch (APIException ex) {
			//must be a service not found exception because of spring not being started
			return DefaultMessageSourceServiceImpl.getInstance();
		}
	}
	
	/**
	 * Sets the MessageSourceService used in the context.
	 *
	 * @param messageSourceService the MessageSourceService to use
	 */
	public void setMessageSourceService(MessageSourceService messageSourceService) {
		setService(MessageSourceService.class, messageSourceService);
	}
	
	/**
	 * @param cls
	 * @param advisor
	 */
	public void addAdvisor(Class cls, Advisor advisor) {
		Advised advisedService = (Advised) services.get(cls);
		if (advisedService.indexOf(advisor) < 0) {
			advisedService.addAdvisor(advisor);
		}
		addedAdvisors.computeIfAbsent(cls, k -> new HashSet<>());
		getAddedAdvisors(cls).add(advisor);
	}
	
	/**
	 * @param cls
	 * @param advice
	 */
	public void addAdvice(Class cls, Advice advice) {
		Advised advisedService = (Advised) services.get(cls);
		if (advisedService.indexOf(advice) < 0) {
			advisedService.addAdvice(advice);
		}
		addedAdvice.computeIfAbsent(cls, k -> new HashSet<>());
		getAddedAdvice(cls).add(advice);
	}
	
	/**
	 * @param cls
	 * @param advisor
	 */
	public void removeAdvisor(Class cls, Advisor advisor) {
		Advised advisedService = (Advised) services.get(cls);
		advisedService.removeAdvisor(advisor);
		getAddedAdvisors(cls).remove(advisor);
	}
	
	/**
	 * @param cls
	 * @param advice
	 */
	public void removeAdvice(Class cls, Advice advice) {
		Advised advisedService = (Advised) services.get(cls);
		advisedService.removeAdvice(advice);
		getAddedAdvice(cls).remove(advice);
	}
	
	/**
	 * Moves advisors and advice added by ServiceContext from the source service to the target one.
	 *
	 * @param source the existing service
	 * @param target the new service
	 */
	private void moveAddedAOP(Advised source, Advised target) {
		Class serviceClass = source.getClass();
		Set<Advisor> existingAdvisors = getAddedAdvisors(serviceClass);
		for (Advisor advisor : existingAdvisors) {
			target.addAdvisor(advisor);
			source.removeAdvisor(advisor);
		}
		
		Set<Advice> existingAdvice = getAddedAdvice(serviceClass);
		for (Advice advice : existingAdvice) {
			target.addAdvice(advice);
			source.removeAdvice(advice);
		}
	}
	
	/**
	 * Removes all advice and advisors added by ServiceContext.
	 *
	 * @param cls the class of the cached service to cleanup
	 */
	private void removeAddedAOP(Class cls) {
		removeAddedAdvisors(cls);
		removeAddedAdvice(cls);
	}
	
	/**
	 * Removes all the advisors added by ServiceContext.
	 *
	 * @param cls the class of the cached service to cleanup
	 */
	private void removeAddedAdvisors(Class cls) {
		Advised advisedService = (Advised) services.get(cls);
		Set<Advisor> advisorsToRemove = addedAdvisors.get(cls);
		if (advisedService != null && advisorsToRemove != null) {
			for (Advisor advisor : advisorsToRemove.toArray(new Advisor[] {})) {
				removeAdvisor(cls, advisor);
			}
		}
	}
	
	/**
	 * Returns the set of advisors added by ServiceContext.
	 *
	 * @param cls the class of the cached service
	 * @return the set of advisors or an empty set
	 */
	@SuppressWarnings("unchecked")
	private Set<Advisor> getAddedAdvisors(Class cls) {
		Set<Advisor> result = addedAdvisors.get(cls);
		return (Set<Advisor>) (result == null ? Collections.emptySet() : result);
	}
	
	/**
	 * Removes all the advice added by the ServiceContext.
	 *
	 * @param cls the class of the caches service to cleanup
	 */
	private void removeAddedAdvice(Class cls) {
		Advised advisedService = (Advised) services.get(cls);
		Set<Advice> adviceToRemove = addedAdvice.get(cls);
		if (advisedService != null && adviceToRemove != null) {
			for (Advice advice : adviceToRemove.toArray(new Advice[] {})) {
				removeAdvice(cls, advice);
			}
		}
	}
	
	/**
	 * Returns the set of advice added by ServiceContext.
	 *
	 * @param cls the class of the cached service
	 * @return the set of advice or an empty set
	 */
	@SuppressWarnings("unchecked")
	private Set<Advice> getAddedAdvice(Class cls) {
		Set<Advice> result = addedAdvice.get(cls);
		return (Set<Advice>) (result == null ? Collections.emptySet() : result);
	}
	
	/**
	 * Returns the current proxy that is stored for the Class <code>cls</code>
	 *
	 * @param cls
	 * @return Object that is a proxy for the <code>cls</code> class
	 */
	@SuppressWarnings("unchecked")
	public <T> T getService(Class<? extends T> cls) {
		if (log.isTraceEnabled()) {
			log.trace("Getting service: " + cls);
		}
		
		// if the context is refreshing, wait until it is
		// done -- otherwise a null service might be returned
		synchronized (refreshingContextLock) {
			try {
				while (refreshingContext) {
					log.debug("Waiting to get service: {} while the context is being refreshed", cls);
					
					refreshingContextLock.wait();
					
					log.debug("Finished waiting to get service {} while the context was being refreshed", cls);
				}
				
			}
			catch (InterruptedException e) {
				log.warn("Refresh lock was interrupted", e);
			}
		}
		
		Object service = services.get(cls);
		if (service == null) {
			throw new ServiceNotFoundException(cls);
		}
		
		return (T) service;
	}
	
	/**
	 * Allow other services to be added to our service layer
	 *
	 * @param cls Interface to proxy
	 * @param classInstance the actual instance of the <code>cls</code> interface
	 */
	public void setService(Class<?> cls, Object classInstance) {
		log.debug("Setting service: {}", cls);
		
		if (cls != null && classInstance != null) {
			try {
				Advised cachedService = (Advised) services.get(cls);
				boolean noExistingService = cachedService == null;
				boolean replacingService = cachedService != null && cachedService != classInstance;
				boolean serviceAdvised = classInstance instanceof Advised;
				
				if (noExistingService || replacingService) {
					
					Advised advisedService;
					
					if (!serviceAdvised) {
						// Adding a bare service, wrap with AOP proxy
						Class[] interfaces = { cls };
						ProxyFactory factory = new ProxyFactory(interfaces);
						factory.setTarget(classInstance);
						advisedService = (Advised) factory.getProxy(OpenmrsClassLoader.getInstance());
					} else {
						advisedService = (Advised) classInstance;
					}
					
					if (replacingService) {
						moveAddedAOP(cachedService, advisedService);
					}
					
					services.put(cls, advisedService);
				}
				log.debug("Service: {} set successfully", cls);
			}
			catch (Exception e) {
				throw new APIException("service.unable.create.proxy.factory", new Object[] { classInstance.getClass()
				        .getName() }, e);
			}
			
		}
	}
	
	/**
	 * Allow other services to be added to our service layer <br>
	 * <br>
	 * Classes will be found/loaded with the ModuleClassLoader <br>
	 * <br>
	 * <code>params</code>[0] = string representing the service interface<br>
	 * <code>params</code>[1] = service instance
	 *
	 * @param params list of parameters
	 */
	public void setModuleService(List<Object> params) {
		String classString = (String) params.get(0);
		Object classInstance = params.get(1);
		
		if (classString == null || classInstance == null) {
			throw new APIException(
			        String.format("Unable to find service as unexpected null value found for class [%s] or instance [%s]",
			            classString, classInstance));
		}
		
		Class cls = null;
		
		// load the given 'classString' class from either the openmrs class
		// loader or the system class loader depending on if we're in a testing
		// environment or not (system == testing, openmrs == normal)
		try {
			if (!useSystemClassLoader) {
				cls = OpenmrsClassLoader.getInstance().loadClass(classString);
				
				if (cls != null && log.isDebugEnabled()) {
					try {
						log.debug("cls classloader: {} uid: {}", cls.getClass().getClassLoader(),
						    cls.getClass().getClassLoader().hashCode());
					}
					catch (Exception e) { /*pass*/}
				}
			} else if (useSystemClassLoader) {
				try {
					cls = Class.forName(classString);
					log.debug("cls2 classloader: {} uid: {}", cls.getClass().getClassLoader(),
					    cls.getClass().getClassLoader().hashCode());
					//pay attention that here, cls = Class.forName(classString), the system class loader and
					//cls2 is the openmrs class loader, like above.
					log.debug("cls==cls2: {}",
					    String.valueOf(cls == OpenmrsClassLoader.getInstance().loadClass(classString)));
				}
				catch (Exception e) { /*pass*/}
			}
		}
		catch (ClassNotFoundException e) {
			throw new APIException("Unable to find service as class not found: " + classString, e);
		}
		
		// add this module service to the normal list of services
		setService(cls, classInstance);
		
		//Run onStartup for all services implementing the OpenmrsService interface.
		if (OpenmrsService.class.isAssignableFrom(classInstance.getClass())) {
			moduleOpenmrsServices.put(classString, (OpenmrsService) classInstance);
			runOpenmrsServiceOnStartup((OpenmrsService) classInstance, classString);
		}
	}
	
	/**
	 * Set this service context to use the system class loader if the
	 * <code>useSystemClassLoader</code> is set to true. If false, the openmrs class loader is used
	 * to load module services
	 *
	 * @param useSystemClassLoader true/false whether to use the system class loader
	 */
	public void setUseSystemClassLoader(boolean useSystemClassLoader) {
		this.useSystemClassLoader = useSystemClassLoader;
	}
	
	/**
	 * Checks if we are using the system class loader.
	 *
	 * @return true if using the system class loader, else false.
	 */
	public boolean isUseSystemClassLoader() {
		return useSystemClassLoader;
	}
	
	public static void setRefreshingContext(boolean refreshingContext) {
		ServiceContext.refreshingContext = refreshingContext;
	}
	
	/**
	 * Should be called <b>right before</b> any spring context refresh This forces all calls to
	 * getService to wait until <code>doneRefreshingContext</code> is called
	 */
	public void startRefreshingContext() {
		synchronized (refreshingContextLock) {
			log.info("Refreshing Context");
			setRefreshingContext(true);
		}
	}
	
	/**
	 * Should be called <b>right after</b> any spring context refresh This wakes up all calls to
	 * getService that were waiting because <code>startRefreshingContext</code> was called
	 */
	public void doneRefreshingContext() {
		synchronized (refreshingContextLock) {
			log.info("Done refreshing Context");
			setRefreshingContext(false);
			refreshingContextLock.notifyAll();
		}
	}
	
	/**
	 * Returns true/false whether startRefreshingContext() has been called without a subsequent call
	 * to doneRefreshingContext() yet. All methods involved in starting/stopping a module should
	 * call this if a service method is needed -- otherwise a deadlock will occur.
	 *
	 * @return true/false whether the services are currently blocking waiting for a call to
	 *         doneRefreshingContext()
	 */
	public boolean isRefreshingContext() {
		synchronized (refreshingContextLock) {
			return refreshingContext;
		}
	}
	
	/**
	 * Retrieves all Beans which have been registered in the Spring {@link ApplicationContext} that
	 * match the given object type (including subclasses).
	 * <p>
	 * <b>NOTE: This method introspects top-level beans only.</b> It does <i>not</i> check nested
	 * beans which might match the specified type as well.
	 *
	 * @see ApplicationContext#getBeansOfType(Class)
	 * @param type the type of Bean to retrieve from the Spring {@link ApplicationContext}
	 * @return a List of all registered Beans that are valid instances of the passed type
	 * @since 1.5
	 * <strong>Should</strong> return a list of all registered beans of the passed type
	 * <strong>Should</strong> return beans registered in a module
	 * <strong>Should</strong> return an empty list if no beans have been registered of the passed type
	 */
	
	public <T> List<T> getRegisteredComponents(Class<T> type) {
		Map<String, T> m = getRegisteredComponents(applicationContext, type);
		log.trace("getRegisteredComponents({}) = {}", type, m);
		return new ArrayList<>(m.values());
	}
	
	/**
	 * Retrieves a bean that match the given type (including subclasses) and name.
	 *
	 * @param beanName the name of registered bean to retrieve
	 * @param type the type of bean to retrieve 
	 * @return bean of passed type
	 *
	 * @since 1.9.4
	 */
	public <T> T getRegisteredComponent(String beanName, Class<T> type) throws APIException {
		try {
			return applicationContext.getBean(beanName, type);
		}
		catch (BeansException beanException) {
			throw new APIException("service.error.during.getting.component", null, beanException);
		}
	}
	
	/**
	 * Private method which returns all components registered in a Spring applicationContext of a
	 * given type This method recurses through each parent ApplicationContext
	 *
	 * @param context - The applicationContext to check
	 * @param type - The type of component to retrieve
	 * @return all components registered in a Spring applicationContext of a given type
	 */
	private <T> Map<String, T> getRegisteredComponents(ApplicationContext context, Class<T> type) {
		Map<String, T> registeredComponents = context.getBeansOfType(type);
		log.trace("getRegisteredComponents({}, {}) = {}", context, type, registeredComponents);
		Map<String, T> components = new HashMap<>(registeredComponents);
		if (context.getParent() != null) {
			components.putAll(getRegisteredComponents(context.getParent(), type));
		}
		return components;
	}
	
	/**
	 * @param applicationContext the applicationContext to set
	 */
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) {
		this.applicationContext = applicationContext;
	}
	
	public ApplicationContext getApplicationContext() {
		return applicationContext;
	}
	
	/**
	 * Calls the {@link OpenmrsService#onStartup()} method for an instance implementing the
	 * {@link OpenmrsService} interface.
	 *
	 * @param openmrsService instance implementing the {@link OpenmrsService} interface.
	 * @param classString the full instance class name including the package name.
	 * @since 1.9
	 */
	private void runOpenmrsServiceOnStartup(final OpenmrsService openmrsService, final String classString) {
		OpenmrsThreadPoolHolder.threadExecutor.execute(() -> {
			try {
				synchronized (refreshingContextLock) {
					//Need to wait for application context to finish refreshing otherwise we get into trouble.
					while (refreshingContext) {
						log.debug("Waiting to get service: {} while the context is being refreshed", classString);
	
						refreshingContextLock.wait();
	
						log.debug("Finished waiting to get service {} while the context was being refreshed", classString);
					}
				}
	
				Daemon.runStartupForService(openmrsService);
			}
				catch (InterruptedException e) {
				log.warn("Refresh lock was interrupted while waiting to run OpenmrsService.onStartup() for "
					+ classString, e);
			}
		});
	}
	
	/**
	 * Gets a list of services implementing the {@link OpenmrsService} interface, for a given
	 * module.
	 *
	 * @param modulePackage the module's package name.
	 * @return the list of service instances.
	 * @since 1.9
	 */
	public List<OpenmrsService> getModuleOpenmrsServices(String modulePackage) {
		List<OpenmrsService> openmrsServices = new ArrayList<>();
		
		for (Entry<String, OpenmrsService> entry : moduleOpenmrsServices.entrySet()) {
			if (entry.getKey().startsWith(modulePackage)) {
				openmrsServices.add(entry.getValue());
			}
		}
		
		return openmrsServices;
	}
	
	/**
	 * Gets the visit service.
	 *
	 * @return visit service.
	 * @since 1.9
	 **/
	public VisitService getVisitService() {
		return getService(VisitService.class);
	}
	
	/**
	 * Sets the visit service.
	 *
	 * @param visitService the visitService to set
	 * @since 1.9
	 **/
	public void setVisitService(VisitService visitService) {
		setService(VisitService.class, visitService);
	}
	
	/**
	 * Gets the provider service.
	 *
	 * @return provider service.
	 * @since 1.9
	 **/
	
	public ProviderService getProviderService() {
		return getService(ProviderService.class);
	}
	
	/**
	 * Sets the provider service.
	 *
	 * @param providerService the providerService to set
	 * @since 1.9
	 **/
	public void setProviderService(ProviderService providerService) {
		setService(ProviderService.class, providerService);
	}
	
	/**
	 * Gets the datatype service
	 *
	 * @return custom datatype service
	 * @since 1.9
	 */
	public DatatypeService getDatatypeService() {
		return getService(DatatypeService.class);
	}
	
	/**
	 * Sets the datatype service
	 *
	 * @param datatypeService the datatypeService to set
	 * @since 1.9
	 */
	public void setDatatypeService(DatatypeService datatypeService) {
		setService(DatatypeService.class, datatypeService);
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.util;
import org.openmrs.annotation.AddOnStartup;
import org.openmrs.annotation.HasAddOnStartupPrivileges;
/**
 * Contains all privilege names and their descriptions. Some of privilege names may be marked with
 * AddOnStartup annotation.
 * 
 * @see org.openmrs.annotation.AddOnStartup
 * @since 1.8
 */
@HasAddOnStartupPrivileges
public class PrivilegeConstants {
	private PrivilegeConstants() {
	}
	@AddOnStartup(description = "Able to get concept entries")
	public static final String GET_CONCEPTS = "Get Concepts";
	
	@AddOnStartup(description = "Able to get concept proposals to the system")
	public static final String GET_CONCEPT_PROPOSALS = "Get Concept Proposals";
	
	@AddOnStartup(description = "Able to get users in OpenMRS")
	public static final String GET_USERS = "Get Users";
	
	@AddOnStartup(description = "Able to get patient encounters")
	public static final String GET_ENCOUNTERS = "Get Encounters";
	
	@AddOnStartup(description = "Able to get encounter types")
	public static final String GET_ENCOUNTER_TYPES = "Get Encounter Types";
	
	@AddOnStartup(description = "Able to get locations")
	public static final String GET_LOCATIONS = "Get Locations";
	
	@AddOnStartup(description = "Able to get patient observations")
	public static final String GET_OBS = "Get Observations";
	
	@AddOnStartup(description = "Able to get patient notes")
	public static final String GET_NOTE = "Get Notes";
	
	@AddOnStartup(description = "Able to get patients")
	public static final String GET_PATIENTS = "Get Patients";
	
	@AddOnStartup(description = "Able to get patient identifiers")
	public static final String GET_PATIENT_IDENTIFIERS = "Get Patient Identifiers";
	
	@AddOnStartup(description = "Able to get patient cohorts")
	public static final String GET_PATIENT_COHORTS = "Get Patient Cohorts";
	
	@AddOnStartup(description = "Able to get orders")
	public static final String GET_ORDERS = "Get Orders";
	
	@AddOnStartup(description = "Able to get forms")
	public static final String GET_FORMS = "Get Forms";
	
	@AddOnStartup(description = "Able to get patient identifier types")
	public static final String GET_IDENTIFIER_TYPES = "Get Identifier Types";
	
	@AddOnStartup(description = "Able to get concept classes")
	public static final String GET_CONCEPT_CLASSES = "Get Concept Classes";
	
	@AddOnStartup(description = "Able to get concept datatypes")
	public static final String GET_CONCEPT_DATATYPES = "Get Concept Datatypes";
	
	@AddOnStartup(description = "Able to get user privileges")
	public static final String GET_PRIVILEGES = "Get Privileges";
	
	@AddOnStartup(description = "Able to get user roles")
	public static final String GET_ROLES = "Get Roles";
	
	@AddOnStartup(description = "Able to get field types")
	public static final String GET_FIELD_TYPES = "Get Field Types";
	
	@AddOnStartup(description = "Able to get order types")
	public static final String GET_ORDER_TYPES = "Get Order Types";
	
	@AddOnStartup(description = "Able to get relationship types")
	public static final String GET_RELATIONSHIP_TYPES = "Get Relationship Types";
	
	@AddOnStartup(description = "Able to get concept sources")
	public static final String GET_CONCEPT_SOURCES = "Get Concept Sources";
	
	@AddOnStartup(description = "Able to get concept map types")
	public static final String GET_CONCEPT_MAP_TYPES = "Get Concept Map Types";
	
	@AddOnStartup(description = "Able to get concept reference terms")
	public static final String GET_CONCEPT_REFERENCE_TERMS = "Get Concept Reference Terms";
	
	@AddOnStartup(description = "Able to get patient programs")
	public static final String GET_PROGRAMS = "Get Programs";
	
	@AddOnStartup(description = "Able to get which programs that patients are in")
	public static final String GET_PATIENT_PROGRAMS = "Get Patient Programs";
	
	@AddOnStartup(description = "Able to get global properties on the administration screen")
	public static final String GET_GLOBAL_PROPERTIES = "Get Global Properties";
	
	@AddOnStartup(description = "Able to get person attribute types")
	public static final String GET_PERSON_ATTRIBUTE_TYPES = "Get Person Attribute Types";
	
	@AddOnStartup(description = "Able to get provider attribute types")
	public static final String GET_PROVIDER_ATTRIBUTE_TYPES = "Get Provider Attribute Types";
	
	@AddOnStartup(description = "Able to get person objects")
	public static final String GET_PERSONS = "Get People";
	
	@AddOnStartup(description = "Able to get relationships")
	public static final String GET_RELATIONSHIPS = "Get Relationships";
	
	@AddOnStartup(description = "Able to get database changes from the admin screen")
	public static final String GET_DATABASE_CHANGES = "Get Database Changes";
	
	@AddOnStartup(description = "Able to get problems")
	public static final String GET_PROBLEMS = "Get Problems";
	
	@AddOnStartup(description = "Able to get allergies")
	public static final String GET_ALLERGIES = "Get Allergies";
	
	@AddOnStartup(description = "Able to add/edit/delete HL7 messages")
	public static final String MANAGE_HL7_MESSAGES = "Manage HL7 Messages";
	
	public static final String PURGE_HL7_MESSAGES = "Purge HL7 Messages";
	
	@AddOnStartup(description = "Able to get an HL7 Source")
	public static final String GET_HL7_SOURCE = "Get HL7 Source";
	
	@AddOnStartup(description = "Able to get an HL7 Queue item")
	public static final String GET_HL7_IN_QUEUE = "Get HL7 Inbound Queue";
	
	@AddOnStartup(description = "Able to get an HL7 archive item")
	public static final String GET_HL7_IN_ARCHIVE = "Get HL7 Inbound Archive";
	
	@AddOnStartup(description = "Able to get an HL7 error item")
	public static final String GET_HL7_IN_EXCEPTION = "Get HL7 Inbound Exception";
	
	@AddOnStartup(description = "Able to get visit types")
	public static final String GET_VISIT_TYPES = "Get Visit Types";
	
	@AddOnStartup(description = "Able to get visits")
	public static final String GET_VISITS = "Get Visits";
	
	@AddOnStartup(description = "Able to get visit attribute types")
	public static final String GET_VISIT_ATTRIBUTE_TYPES = "Get Visit Attribute Types";
	
	@AddOnStartup(description = "Able to get location attribute types")
	public static final String GET_LOCATION_ATTRIBUTE_TYPES = "Get Location Attribute Types";
	
	@AddOnStartup(description = "Able to get Provider")
	public static final String GET_PROVIDERS = "Get Providers";
	
	@AddOnStartup(description = "Able to get encounter roles")
	public static final String GET_ENCOUNTER_ROLES = "Get Encounter Roles";
	
	@AddOnStartup(description = "Able to add/edit/delete concept entries")
	public static final String MANAGE_CONCEPTS = "Manage Concepts";
	
	public static final String PURGE_CONCEPTS = "Purge Concepts";
	
	@AddOnStartup(description = "Able to add/edit/delete concept name tags")
	public static final String MANAGE_CONCEPT_NAME_TAGS = "Manage Concept Name tags";
	
	@AddOnStartup(description = "Able to add concept proposals to the system")
	public static final String ADD_CONCEPT_PROPOSALS = "Add Concept Proposals";
	
	@AddOnStartup(description = "Able to edit concept proposals in the system")
	public static final String EDIT_CONCEPT_PROPOSALS = "Edit Concept Proposals";
	
	@AddOnStartup(description = "Able to delete concept proposals from the system")
	public static final String DELETE_CONCEPT_PROPOSALS = "Delete Concept Proposals";
	
	public static final String PURGE_CONCEPT_PROPOSALS = "Purge Concept Proposals";
	
	@AddOnStartup(description = "Able to add users to OpenMRS")
	public static final String ADD_USERS = "Add Users";
	
	@AddOnStartup(description = "Able to edit users in OpenMRS")
	public static final String EDIT_USERS = "Edit Users";
	
	@AddOnStartup(description = "Able to delete users in OpenMRS")
	public static final String DELETE_USERS = "Delete Users";
	
	public static final String PURGE_USERS = "Purge Users";
	
	@AddOnStartup(description = "Able to change the passwords of users in OpenMRS")
	public static final String EDIT_USER_PASSWORDS = "Edit User Passwords";
	
	@AddOnStartup(description = "Able to add patient encounters")
	public static final String ADD_ENCOUNTERS = "Add Encounters";
	
	@AddOnStartup(description = "Able to edit patient encounters")
	public static final String EDIT_ENCOUNTERS = "Edit Encounters";
	
	@AddOnStartup(description = "Able to delete patient encounters")
	public static final String DELETE_ENCOUNTERS = "Delete Encounters";
	
	public static final String PURGE_ENCOUNTERS = "Purge Encounters";
	
	@AddOnStartup(description = "Able to add/edit/retire encounter types")
	public static final String MANAGE_ENCOUNTER_TYPES = "Manage Encounter Types";
	
	public static final String PURGE_ENCOUNTER_TYPES = "Purge Encounter Types";
	
	@AddOnStartup(description = "Able to choose encounter visit handler and enable/disable encounter visits")
	public static final String CONFIGURE_VISITS = "Configure Visits";
	
	@AddOnStartup(description = "Able to add/edit/delete locations")
	public static final String MANAGE_LOCATIONS = "Manage Locations";
	
	public static final String PURGE_LOCATIONS = "Purge Locations";
	
	@AddOnStartup(description = "Able to add/edit/delete location tags")
	public static final String MANAGE_LOCATION_TAGS = "Manage Location Tags";
	
	@AddOnStartup(description = "Able to add/edit/delete address templates")
	public static final String MANAGE_ADDRESS_TEMPLATES = "Manage Address Templates";
	
	public static final String PURGE_LOCATION_TAGS = "Purge Location Tags";
	
	@AddOnStartup(description = "Able to add patient observations")
	public static final String ADD_OBS = "Add Observations";
	
	@AddOnStartup(description = "Able to edit patient observations")
	public static final String EDIT_OBS = "Edit Observations";
	
	@AddOnStartup(description = "Able to delete patient observations")
	public static final String DELETE_OBS = "Delete Observations";
	
	public static final String PURGE_OBS = "Purge Observations";
	
	@AddOnStartup(description = "Able to edit patient notes")
	public static final String EDIT_NOTE = "Edit Notes";
	
	@AddOnStartup(description = "Able to delete patient notes")
	public static final String DELETE_NOTE = "Delete Notes";
	
	@AddOnStartup(description = "Able to add patients")
	public static final String ADD_PATIENTS = "Add Patients";
	
	@AddOnStartup(description = "Able to edit patients")
	public static final String EDIT_PATIENTS = "Edit Patients";
	
	@AddOnStartup(description = "Able to delete patients")
	public static final String DELETE_PATIENTS = "Delete Patients";
	
	public static final String PURGE_PATIENTS = "Purge Patients";
	
	@AddOnStartup(description = "Able to add patient identifiers")
	public static final String ADD_PATIENT_IDENTIFIERS = "Add Patient Identifiers";
	
	@AddOnStartup(description = "Able to edit patient identifiers")
	public static final String EDIT_PATIENT_IDENTIFIERS = "Edit Patient Identifiers";
	
	@AddOnStartup(description = "Able to delete patient identifiers")
	public static final String DELETE_PATIENT_IDENTIFIERS = "Delete Patient Identifiers";
	
	public static final String PURGE_PATIENT_IDENTIFIERS = "Purge Patient Identifiers";
	
	@AddOnStartup(description = "Able to add a cohort to the system")
	public static final String ADD_COHORTS = "Add Cohorts";
	
	@AddOnStartup(description = "Able to add a cohort to the system")
	public static final String EDIT_COHORTS = "Edit Cohorts";
	
	@AddOnStartup(description = "Able to add a cohort to the system")
	public static final String DELETE_COHORTS = "Delete Cohorts";
	
	public static final String PURGE_COHORTS = "Purge Cohorts";
	
	@AddOnStartup(description = "Able to add orders")
	public static final String ADD_ORDERS = "Add Orders";
	
	@AddOnStartup(description = "Able to edit orders")
	public static final String EDIT_ORDERS = "Edit Orders";
	
	@AddOnStartup(description = "Able to delete orders")
	public static final String DELETE_ORDERS = "Delete Orders";
	
	public static final String PURGE_ORDERS = "Purge Orders";
	
	@AddOnStartup(description = "Able to add/edit/delete forms")
	public static final String MANAGE_FORMS = "Manage Forms";
	
	public static final String PURGE_FORMS = "Purge Forms";
	
	// This name is historic, since that's what it was originally called in the
	// infopath formentry module
	@AddOnStartup(description = "Able to fill out forms")
	public static final String FORM_ENTRY = "Form Entry";
	
	@AddOnStartup(description = "Able to add/edit/retire patient identifier types")
	public static final String MANAGE_IDENTIFIER_TYPES = "Manage Identifier Types";
	
	public static final String PURGE_IDENTIFIER_TYPES = "Purge Identifier Types";
	
	@AddOnStartup(description = "Able to add/edit/retire concept classes")
	public static final String MANAGE_CONCEPT_CLASSES = "Manage Concept Classes";
	
	public static final String PURGE_CONCEPT_CLASSES = "Purge Concept Classes";
	
	@AddOnStartup(description = "Able to add/edit/retire concept datatypes")
	public static final String MANAGE_CONCEPT_DATATYPES = "Manage Concept Datatypes";
	
	public static final String PURGE_CONCEPT_DATATYPES = "Purge Concept Datatypes";
	
	@AddOnStartup(description = "Able to add/edit/delete privileges")
	public static final String MANAGE_PRIVILEGES = "Manage Privileges";
	
	public static final String PURGE_PRIVILEGES = "Purge Privileges";
	
	@AddOnStartup(description = "Able to add/edit/delete user roles")
	public static final String MANAGE_ROLES = "Manage Roles";
	
	public static final String PURGE_ROLES = "Purge Roles";
	
	@AddOnStartup(description = "Able to add/edit/retire field types")
	public static final String MANAGE_FIELD_TYPES = "Manage Field Types";
	
	public static final String PURGE_FIELD_TYPES = "Purge Field Types";
	
	@AddOnStartup(description = "Able to add/edit/retire order types")
	public static final String MANAGE_ORDER_TYPES = "Manage Order Types";
	
	public static final String PURGE_ORDER_TYPES = "Purge Order Types";
	
	@AddOnStartup(description = "Able to add/edit/retire relationship types")
	public static final String MANAGE_RELATIONSHIP_TYPES = "Manage Relationship Types";
	
	public static final String PURGE_RELATIONSHIP_TYPES = "Purge Relationship Types";
	
	@AddOnStartup(description = "Able to add/edit/delete user alerts")
	public static final String MANAGE_ALERTS = "Manage Alerts";
	
	@AddOnStartup(description = "Able to add/edit/delete concept sources")
	public static final String MANAGE_CONCEPT_SOURCES = "Manage Concept Sources";
	
	@AddOnStartup(description = "Able to add/edit/retire concept map types")
	public static final String MANAGE_CONCEPT_MAP_TYPES = "Manage Concept Map Types";
	
	public static final String PURGE_CONCEPT_MAP_TYPES = "Purge Concept Map Types";
	
	@AddOnStartup(description = "Able to add/edit/retire reference terms")
	public static final String MANAGE_CONCEPT_REFERENCE_TERMS = "Manage Concept Reference Terms";
	
	public static final String CREATE_REFERENCE_TERMS_WHILE_EDITING_CONCEPTS = "Create Reference Terms While Editing Concepts";
	
	public static final String PURGE_CONCEPT_REFERENCE_TERMS = "Purge Concept Reference Terms";
	
	public static final String PURGE_CONCEPT_SOURCES = "Purge Concept Sources";
	
	@AddOnStartup(description = "Able to view the navigation menu (Home, View Patients, Dictionary, Administration, My Profile")
	public static final String VIEW_NAVIGATION_MENU = "View Navigation Menu";
	
	@AddOnStartup(description = "Able to view the 'Administration' link in the navigation bar")
	public static final String VIEW_ADMIN_FUNCTIONS = "View Administration Functions";
	
	@AddOnStartup(description = "Able to view and fill out unpublished forms")
	public static final String VIEW_UNPUBLISHED_FORMS = "View Unpublished Forms";
	
	@AddOnStartup(description = "Able to add/view/delete patient programs")
	public static final String MANAGE_PROGRAMS = "Manage Programs";
	
	@AddOnStartup(description = "Able to add patients to programs")
	public static final String ADD_PATIENT_PROGRAMS = "Add Patient Programs";
	
	@AddOnStartup(description = "Able to edit patients in programs")
	public static final String EDIT_PATIENT_PROGRAMS = "Edit Patient Programs";
	
	@AddOnStartup(description = "Able to delete patients from programs")
	public static final String DELETE_PATIENT_PROGRAMS = "Delete Patient Programs";
	
	public static final String PURGE_PATIENT_PROGRAMS = "Purge Patient Programs";
	
	@AddOnStartup(description = "Able to add/edit global properties")
	public static final String MANAGE_GLOBAL_PROPERTIES = "Manage Global Properties";
	
	public static final String PURGE_GLOBAL_PROPERTIES = "Purge Global Properties";
	
	@AddOnStartup(description = "Able to add/remove modules to the system")
	public static final String MANAGE_MODULES = "Manage Modules";
	
	@AddOnStartup(description = "Able to add/edit/remove scheduled tasks")
	public static final String MANAGE_SCHEDULER = "Manage Scheduler";
	
	@AddOnStartup(description = "Able to add/edit/retire person attribute types")
	public static final String MANAGE_PERSON_ATTRIBUTE_TYPES = "Manage Person Attribute Types";
	
	public static final String PURGE_PERSON_ATTRIBUTE_TYPES = "Purge Person Attribute Types";
	
	@AddOnStartup(description = "Able to add person objects")
	public static final String ADD_PERSONS = "Add People";
	
	@AddOnStartup(description = "Able to add person objects")
	public static final String EDIT_PERSONS = "Edit People";
	
	@AddOnStartup(description = "Able to delete objects")
	public static final String DELETE_PERSONS = "Delete People";
	
	public static final String PURGE_PERSONS = "Purge People";
	
	@AddOnStartup(description = "Able to add relationships")
	public static final String ADD_RELATIONSHIPS = "Add Relationships";
	
	@AddOnStartup(description = "Able to edit relationships")
	public static final String EDIT_RELATIONSHIPS = "Edit Relationships";
	
	@AddOnStartup(description = "Able to delete relationships")
	public static final String DELETE_RELATIONSHIPS = "Delete Relationships";
	
	public static final String PURGE_RELATIONSHIPS = "Purge Relationships";
	
	@AddOnStartup(description = "Able to view/add/edit the implementation id for the system")
	public static final String MANAGE_IMPLEMENTATION_ID = "Manage Implementation Id";
	
	public static final String SQL_LEVEL_ACCESS = "SQL Level Access";
	
	@AddOnStartup(description = "Add problems")
	public static final String ADD_PROBLEMS = "Add Problems";
	
	@AddOnStartup(description = "Able to edit problems")
	public static final String EDIT_PROBLEMS = "Edit Problems";
	
	@AddOnStartup(description = "Remove problems")
	public static final String DELETE_PROBLEMS = "Remove Problems";
	
	@AddOnStartup(description = "Add allergies")
	public static final String ADD_ALLERGIES = "Add Allergies";
	
	@AddOnStartup(description = "Able to edit allergies")
	public static final String EDIT_ALLERGIES = "Edit Allergies";
	
	@AddOnStartup(description = "Remove allergies")
	public static final String DELETE_ALLERGIES = "Remove Allergies";
	
	@AddOnStartup(description = "Able to view/add/remove the concept stop words")
	public static final String MANAGE_CONCEPT_STOP_WORDS = "Manage Concept Stop Words";
	
	@AddOnStartup(description = "Able to add an HL7 Source")
	public static final String PRIV_ADD_HL7_SOURCE = "Add HL7 Source";
	
	@AddOnStartup(description = "Able to update an HL7 Source")
	public static final String PRIV_UPDATE_HL7_SOURCE = "Update HL7 Source";
	
	public static final String PRIV_PURGE_HL7_SOURCE = "Purge HL7 Source";
	
	@AddOnStartup(description = "Able to add an HL7 Queue item")
	public static final String PRIV_ADD_HL7_IN_QUEUE = "Add HL7 Inbound Queue";
	
	@AddOnStartup(description = "Able to update an HL7 Queue item")
	public static final String PRIV_UPDATE_HL7_IN_QUEUE = "Update HL7 Inbound Queue";
	
	@AddOnStartup(description = "Able to delete an HL7 Queue item")
	public static final String PRIV_DELETE_HL7_IN_QUEUE = "Delete HL7 Inbound Queue";
	
	public static final String PRIV_PURGE_HL7_IN_QUEUE = "Purge HL7 Inbound Queue";
	
	@AddOnStartup(description = "Able to add an HL7 archive item")
	public static final String PRIV_ADD_HL7_IN_ARCHIVE = "Add HL7 Inbound Archive";
	
	@AddOnStartup(description = "Able to update an HL7 archive item")
	public static final String PRIV_UPDATE_HL7_IN_ARCHIVE = "Update HL7 Inbound Archive";
	
	@AddOnStartup(description = "Able to delete/retire an HL7 archive item")
	public static final String PRIV_DELETE_HL7_IN_ARCHIVE = "Delete HL7 Inbound Archive";
	
	public static final String PRIV_PURGE_HL7_IN_ARCHIVE = "Purge HL7 Inbound Archive";
	
	@AddOnStartup(description = "Able to add an HL7 error item")
	public static final String PRIV_ADD_HL7_IN_EXCEPTION = "Add HL7 Inbound Exception";
	
	@AddOnStartup(description = "Able to update an HL7 archive item")
	public static final String PRIV_UPDATE_HL7_IN_EXCEPTION = "Update HL7 Inbound Exception";
	
	@AddOnStartup(description = "Able to delete an HL7 archive item")
	public static final String PRIV_DELETE_HL7_IN_EXCEPTION = "Delete HL7 Inbound Exception";
	
	public static final String PRIV_PURGE_HL7_IN_EXCEPTION = "Purge HL7 Inbound Exception";
	
	@AddOnStartup(description = "Able to add/edit/delete visit types")
	public static final String MANAGE_VISIT_TYPES = "Manage Visit Types";
	
	@AddOnStartup(description = "Able to add visits")
	public static final String ADD_VISITS = "Add Visits";
	
	@AddOnStartup(description = "Able to edit visits")
	public static final String EDIT_VISITS = "Edit Visits";
	
	@AddOnStartup(description = "Able to delete visits")
	public static final String DELETE_VISITS = "Delete Visits";
	
	public static final String PURGE_VISITS = "Purge Visits";
	
	@AddOnStartup(description = "Able to add/edit/retire visit attribute types")
	public static final String MANAGE_VISIT_ATTRIBUTE_TYPES = "Manage Visit Attribute Types";
	
	public static final String PURGE_VISIT_ATTRIBUTE_TYPES = "Purge Visit Attribute Types";
	
	@AddOnStartup(description = "Able to add/edit/retire location attribute types")
	public static final String MANAGE_LOCATION_ATTRIBUTE_TYPES = "Manage Location Attribute Types";
	
	public static final String PURGE_LOCATION_ATTRIBUTE_TYPES = "Purge Location Attribute Types";
	
	@AddOnStartup(description = "Able to edit Provider")
	public static final String MANAGE_PROVIDERS = "Manage Providers";
	
	public static final String PURGE_PROVIDERS = "Purge Providers";
	
	public static final String PURGE_ENCOUNTER_ROLES = "Purge Encounter Roles";
	
	@AddOnStartup(description = "Able to add/edit/retire encounter roles")
	public static final String MANAGE_ENCOUNTER_ROLES = "Manage Encounter Roles";
	
	@AddOnStartup(description = "Able to assign System Developer role")
	public static final String ASSIGN_SYSTEM_DEVELOPER_ROLE = "Assign System Developer Role";
	
	@AddOnStartup(description = "Able to get Order Frequencies")
	public static final String GET_ORDER_FREQUENCIES = "Get Order Frequencies";
	
	@AddOnStartup(description = "Able to add/edit/retire Order Frequencies")
	public static final String MANAGE_ORDER_FREQUENCIES = "Manage Order Frequencies";
	
	public static final String PURGE_ORDER_FREQUENCIES = "Purge Order Frequencies";
	
	@AddOnStartup(description = "Able to get Care Settings")
	public static final String GET_CARE_SETTINGS = "Get Care Settings";
	@AddOnStartup(description = "Able to manage the search index")
	public static final String MANAGE_SEARCH_INDEX = "Manage Search Index";
	@AddOnStartup(description = "Able to add, edit, delete allergies")
	public static final String MODIFY_ALLERGIES = "Task: Modify Allergies";
	@AddOnStartup(description = "Able to get order sets")
	public static final String GET_ORDER_SETS = "Get Order Sets";
	
	@AddOnStartup(description = "Able to manage order sets")
	public static final String MANAGE_ORDER_SETS = "Manage Order Sets";
	@AddOnStartup(description = "Able to get concept attribute types")
	public static final String GET_CONCEPT_ATTRIBUTE_TYPES = "Get Concept Attribute Types";
	@AddOnStartup(description = "Able to add/edit/retire concept attribute types")
	public static final String MANAGE_CONCEPT_ATTRIBUTE_TYPES = "Manage Concept Attribute Types";
	public static final String PURGE_CONCEPT_ATTRIBUTE_TYPES = "Purge Concept Attribute Types";
	@AddOnStartup(description = "Able to edit conditions")
	public static final String EDIT_CONDITIONS = "Edit Conditions";
	@AddOnStartup(description = "Able to get conditions")
	public static final String GET_CONDITIONS = "Get Conditions";
	@AddOnStartup(description = "Able to delete conditions")
	public static final String DELETE_CONDITIONS = "Delete Conditions";
	@AddOnStartup(description = "Able to edit diagnoses")
	public static final String EDIT_DIAGNOSES = "Edit Diagnoses";
	@AddOnStartup(description = "Able to get diagnoses")
	public static final String GET_DIAGNOSES = "Get Diagnoses";
	@AddOnStartup(description = "Able to delete diagnoses")
	public static final String DELETE_DIAGNOSES = "Delete Diagnoses";
	@AddOnStartup(description = "Able to get diagnoses attribute types")
	public static final String GET_DIAGNOSES_ATTRIBUTE_TYPES = "Get Diagnoses Attribute Types";
	@AddOnStartup(description = "Able to get order set attribute types")
	public static final String GET_ORDER_SET_ATTRIBUTE_TYPES = "Get Order Set Attribute Types";
	@AddOnStartup(description = "Able to add/edit/retire order set attribute types")
	public static final String MANAGE_ORDER_SET_ATTRIBUTE_TYPES = "Manage Order Set Attribute Types";
	public static final String PURGE_ORDER_SET_ATTRIBUTE_TYPES = "Purge Order Set Attribute Types";
	@AddOnStartup(description = "Able to get Medication Dispenses")
	public static final String GET_MEDICATION_DISPENSE = "Get Medication Dispense";
	
	@AddOnStartup(description = "Able to edit Medication Dispenses")
	public static final String EDIT_MEDICATION_DISPENSE = "Edit Medication Dispense";
	@AddOnStartup(description = "Able to delete Medication Dispenses")
	public static final String DELETE_MEDICATION_DISPENSE = "Delete Medication Dispense";
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.propertyeditor;
import java.beans.PropertyEditorSupport;
import org.openmrs.Role;
import org.openmrs.api.UserService;
import org.openmrs.api.context.Context;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;
/**
 * Allows for serializing/deserializing an object to a string so that Spring knows how to pass
 * an object back and forth through an html form or other medium. <br>
 * <br>
 * In version 1.9, added ability for this to also retrieve objects by uuid
 *
 * @see Role
 */
public class RoleEditor extends PropertyEditorSupport {
	
	private static final Logger log = LoggerFactory.getLogger(RoleEditor.class);
	
	public RoleEditor() {
	}
	
	/**
	 * <strong>Should</strong> set using name
	 * <strong>Should</strong> set using uuid
	 */
	@Override
	public void setAsText(String text) throws IllegalArgumentException {
		UserService es = Context.getUserService();
		if (StringUtils.hasText(text)) {
			try {
				Role r = es.getRole(text);
				setValue(r);
				//when a role is not found, no exception is generated. throw one to execute the catch block
				if (r == null) {
					throw new Exception();
				}
			}
			catch (Exception ex) {
				Role r = es.getRoleByUuid(text);
				setValue(r);
				if (r == null) {
					log.error("Error setting text: " + text, ex);
					throw new IllegalArgumentException("Role not found: " + ex.getMessage());
				}
			}
		} else {
			setValue(null);
		}
	}
	
	@Override
	public String getAsText() {
		Role r = (Role) getValue();
		if (r == null) {
			return "";
		} else {
			return r.getRole();
		}
	}
	
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.api.handler;
import java.util.Date;
import org.openmrs.Person;
import org.openmrs.User;
import org.openmrs.annotation.Handler;
import org.openmrs.aop.RequiredDataAdvice;
import org.openmrs.api.UserService;
import org.openmrs.api.context.Context;
/**
 * This class sets the personVoid* attributes on the given {@link Person} object when a void* method
 * is called with this class. This differs from the {@link BaseVoidHandler} because the Person
 * object contains personVoided* attributes instead of the normal voided attributes
 *
 * @see RequiredDataAdvice
 * @see UnvoidHandler
 * @since 1.5
 */
@Handler(supports = Person.class)
public class PersonVoidHandler implements VoidHandler<Person> {
	
	/**
	 * Sets all personVoid* attributes to the given parameters.
	 *
	 * @see org.openmrs.api.handler.RequiredDataHandler#handle(org.openmrs.OpenmrsObject,
	 *      org.openmrs.User, java.util.Date, java.lang.String)
	 * <strong>Should</strong> set the personVoided bit
	 * <strong>Should</strong> set the personVoidReason
	 * <strong>Should</strong> set personVoidedBy
	 * <strong>Should</strong> not set personVoidedBy if non null
	 * <strong>Should</strong> set personDateVoided
	 * <strong>Should</strong> not set personDateVoided if non null
	 * <strong>Should</strong> not set the personVoidReason if already personVoided
	 * <strong>Should</strong> retire users
	 */
	@Override
	public void handle(Person person, User voidingUser, Date voidedDate, String voidReason) {
		
		// skip over all work if the object is already voided
		if (!person.getPersonVoided()) {
			if (person.getPersonId() != null) {
				// Skip if person is not persisted
				UserService us = Context.getUserService();
				for (User user : us.getUsersByPerson(person, false)) {
					us.retireUser(user, voidReason);
				}
			}
			
			person.setPersonVoided(true);
			person.setPersonVoidReason(voidReason);
			
			if (person.getPersonVoidedBy() == null) {
				person.setPersonVoidedBy(voidingUser);
			}
			if (person.getPersonDateVoided() == null) {
				person.setPersonDateVoided(voidedDate);
			}
		}
	}
	
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 * 
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.web.filter.initialization;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Base64.Encoder;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Random;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.zip.ZipInputStream;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import liquibase.changelog.ChangeSet;
import org.apache.commons.io.IOUtils;
import org.openmrs.ImplementationId;
import org.openmrs.api.APIAuthenticationException;
import org.openmrs.api.PasswordException;
import org.openmrs.api.UserService;
import org.openmrs.api.context.Context;
import org.openmrs.api.context.ContextAuthenticationException;
import org.openmrs.api.context.UsernamePasswordCredentials;
import org.openmrs.api.impl.UserServiceImpl;
import org.openmrs.liquibase.ChangeLogDetective;
import org.openmrs.liquibase.ChangeLogVersionFinder;
import org.openmrs.module.MandatoryModuleException;
import org.openmrs.module.OpenmrsCoreModuleException;
import org.openmrs.module.web.WebModuleUtil;
import org.openmrs.util.DatabaseUpdateException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.liquibase.ChangeSetExecutorCallback;
import org.openmrs.util.DatabaseUpdaterLiquibaseProvider;
import org.openmrs.util.DatabaseUtil;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsThreadPoolHolder;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.util.Security;
import org.openmrs.web.Listener;
import org.openmrs.web.WebConstants;
import org.openmrs.web.WebDaemon;
import org.openmrs.web.filter.StartupFilter;
import org.openmrs.web.filter.update.UpdateFilter;
import org.openmrs.web.filter.util.CustomResourceLoader;
import org.openmrs.web.filter.util.ErrorMessageConstants;
import org.openmrs.web.filter.util.FilterUtil;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;
import org.springframework.web.context.ContextLoader;
/**
 * This is the first filter that is processed. It is only active when starting OpenMRS for the very
 * first time. It will redirect all requests to the {@link WebConstants#SETUP_PAGE_URL} if the
 * {@link Listener} wasn't able to find any runtime properties
 */
public class InitializationFilter extends StartupFilter {
	
	private static final org.slf4j.Logger log = LoggerFactory.getLogger(InitializationFilter.class);
	
	private static final String DATABASE_POSTGRESQL = "postgresql";
	
	private static final String DATABASE_MYSQL = "mysql";
	
	private static final String DATABASE_SQLSERVER = "sqlserver";
	
	private static final String DATABASE_H2 = "h2";
	
	private static final String LIQUIBASE_DEMO_DATA = "liquibase-demo-data.xml";
	
	/**
	 * The very first page of wizard, that asks user for select his preferred language
	 */
	private static final String CHOOSE_LANG = "chooselang.vm";
	
	/**
	 * The second page of the wizard that asks for simple or advanced installation.
	 */
	private static final String INSTALL_METHOD = "installmethod.vm";
	
	/**
	 * The simple installation setup page.
	 */
	private static final String SIMPLE_SETUP = "simplesetup.vm";
	
	/**
	 * The first page of the advanced installation of the wizard that asks for a current or past
	 * database
	 */
	private static final String DATABASE_SETUP = "databasesetup.vm";
	
	/**
	 * The page from where the user specifies the url to a remote system, username and password
	 */
	private static final String TESTING_REMOTE_DETAILS_SETUP = "remotedetails.vm";
	
	/**
	 * The velocity macro page to redirect to if an error occurs or on initial startup
	 */
	private static final String DEFAULT_PAGE = CHOOSE_LANG;
	
	/**
	 * This page asks whether database tables/demo data should be inserted and what the
	 * username/password that will be put into the runtime properties is
	 */
	private static final String DATABASE_TABLES_AND_USER = "databasetablesanduser.vm";
	
	/**
	 * This page lets the user define the admin user
	 */
	private static final String ADMIN_USER_SETUP = "adminusersetup.vm";
	
	/**
	 * This page lets the user pick an implementation id
	 */
	private static final String IMPLEMENTATION_ID_SETUP = "implementationidsetup.vm";
	
	/**
	 * This page asks for settings that will be put into the runtime properties files
	 */
	private static final String OTHER_RUNTIME_PROPS = "otherruntimeproperties.vm";
	
	/**
	 * A page that tells the user that everything is collected and will now be processed
	 */
	private static final String WIZARD_COMPLETE = "wizardcomplete.vm";
	
	/**
	 * A page that lists off what is happening while it is going on. This page has ajax that callst he
	 * {@value #PROGRESS_VM_AJAXREQUEST} page
	 */
	private static final String PROGRESS_VM = "progress.vm";
	
	/**
	 * This url is called by javascript to get the status of the install
	 */
	private static final String PROGRESS_VM_AJAXREQUEST = "progress.vm.ajaxRequest";
	
	public static final String RELEASE_TESTING_MODULE_PATH = "/module/releasetestinghelper/";
	
	/**
	 * The model object that holds all the properties that the rendered templates use. All attributes on
	 * this object are made available to all templates via reflection in the
	 * {@link org.openmrs.web.filter.StartupFilter#renderTemplate(String, Map, HttpServletResponse)} method.
	 */
	private InitializationWizardModel wizardModel = null;
	
	private InitializationCompletion initJob;
	
	/**
	 * Variable set to true as soon as the installation begins and set to false when the process ends
	 * This thread should only be accesses through the synchronized method.
	 */
	private static boolean isInstallationStarted = false;
	
	// the actual driver loaded by the DatabaseUpdater class
	private String loadedDriverString;
	
	/**
	 * Variable set at the end of the wizard when spring is being restarted
	 */
	private static boolean initializationComplete = false;
	
	protected synchronized void setInitializationComplete(boolean initializationComplete) {
		InitializationFilter.initializationComplete = initializationComplete;
	}
	
	/**
	 * Called by {@link #doFilter(ServletRequest, ServletResponse, FilterChain)} on GET requests
	 *
	 * @param httpRequest
	 * @param httpResponse
	 */
	@Override
	protected void doGet(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
		throws IOException, ServletException {
		loadInstallationScriptIfPresent();
		
		// we need to save current user language in references map since it will be used when template
		// will be rendered
		if (httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE) == null) {
			checkLocaleAttributesForFirstTime(httpRequest);
		}
		
		Map<String, Object> referenceMap = new HashMap<>();
		String page = httpRequest.getParameter("page");
		
		referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE, httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
		
		httpResponse.setHeader("Cache-Control", "no-cache");
		
		// if any body has already started installation and this is not an ajax request for the progress
		if (isInstallationStarted() && !PROGRESS_VM_AJAXREQUEST.equals(page)) {
			referenceMap.put("isInstallationStarted", true);
			httpResponse.setContentType("text/html");
			renderTemplate(PROGRESS_VM, referenceMap, httpResponse);
		} else if (PROGRESS_VM_AJAXREQUEST.equals(page)) {
			httpResponse.setContentType("text/json");
			Map<String, Object> result = new HashMap<>();
			if (initJob != null) {
				result.put("hasErrors", initJob.hasErrors());
				if (initJob.hasErrors()) {
					result.put("errorPage", initJob.getErrorPage());
					errors.putAll(initJob.getErrors());
				}
				
				result.put("initializationComplete", isInitializationComplete());
				result.put("message", initJob.getMessage());
				result.put("actionCounter", initJob.getStepsComplete());
				if (!isInitializationComplete()) {
					result.put("executingTask", initJob.getExecutingTask());
					result.put("executedTasks", initJob.getExecutedTasks());
					result.put("completedPercentage", initJob.getCompletedPercentage());
				}
				
				addLogLinesToResponse(result);
			}
			
			PrintWriter writer = httpResponse.getWriter();
			writer.write(toJSONString(result));
			writer.close();
		} else if (InitializationWizardModel.INSTALL_METHOD_AUTO.equals(wizardModel.installMethod)
			|| httpRequest.getServletPath().equals("/" + AUTO_RUN_OPENMRS)) {
			autoRunOpenMRS(httpRequest);
			referenceMap.put("isInstallationStarted", true);
			httpResponse.setContentType("text/html");
			renderTemplate(PROGRESS_VM, referenceMap, httpResponse);
		} else if (page == null) {
			httpResponse.setContentType("text/html");// if any body has already started installation
			
			//If someone came straight here without setting the hidden page input,
			// then we need to clear out all the passwords
			clearPasswords();
			
			renderTemplate(DEFAULT_PAGE, referenceMap, httpResponse);
		} else if (INSTALL_METHOD.equals(page)) {
			// get props and render the second page
			File runtimeProperties = getRuntimePropertiesFile();
			
			if (!runtimeProperties.exists()) {
				try {
					runtimeProperties.createNewFile();
					// reset the error objects in case of refresh
					wizardModel.canCreate = true;
					wizardModel.cannotCreateErrorMessage = "";
				}
				catch (IOException io) {
					wizardModel.canCreate = false;
					wizardModel.cannotCreateErrorMessage = io.getMessage();
				}
				
				// check this before deleting the file again
				wizardModel.canWrite = runtimeProperties.canWrite();
				
				// delete the file again after testing the create/write
				// so that if the user stops the webapp before finishing
				// this wizard, they can still get back into it
				runtimeProperties.delete();
				
			} else {
				wizardModel.canWrite = runtimeProperties.canWrite();
				
				wizardModel.databaseConnection = Context.getRuntimeProperties().getProperty("connection.url",
					wizardModel.databaseConnection);
				
				wizardModel.currentDatabaseUsername = Context.getRuntimeProperties().getProperty("connection.username",
					wizardModel.currentDatabaseUsername);
				
				wizardModel.currentDatabasePassword = Context.getRuntimeProperties().getProperty("connection.password",
					wizardModel.currentDatabasePassword);
			}
			
			wizardModel.runtimePropertiesPath = runtimeProperties.getAbsolutePath();
			
			// do step one of the wizard
			httpResponse.setContentType("text/html");
			renderTemplate(INSTALL_METHOD, referenceMap, httpResponse);
		}
	}
	
	private void loadInstallationScriptIfPresent() {
		Properties script = getInstallationScript();
		if (!script.isEmpty()) {
			wizardModel.installMethod = script.getProperty("install_method", wizardModel.installMethod);
			
			wizardModel.databaseConnection = script.getProperty("connection.url", wizardModel.databaseConnection);
			wizardModel.databaseDriver = script.getProperty("connection.driver_class", wizardModel.databaseDriver);
			wizardModel.currentDatabaseUsername = script.getProperty("connection.username",
				wizardModel.currentDatabaseUsername);
			wizardModel.currentDatabasePassword = script.getProperty("connection.password",
				wizardModel.currentDatabasePassword);
			
			String hasCurrentOpenmrsDatabase = script.getProperty("has_current_openmrs_database");
			if (hasCurrentOpenmrsDatabase != null) {
				wizardModel.hasCurrentOpenmrsDatabase = Boolean.valueOf(hasCurrentOpenmrsDatabase);
			}
			wizardModel.createDatabaseUsername = script.getProperty("create_database_username",
				wizardModel.createDatabaseUsername);
			wizardModel.createDatabasePassword = script.getProperty("create_database_password",
				wizardModel.createDatabasePassword);
			
			String createTables = script.getProperty("create_tables");
			if (createTables != null) {
				wizardModel.createTables = Boolean.valueOf(createTables);
			}
			
			String createDatabaseUser = script.getProperty("create_database_user");
			if (createDatabaseUser != null) {
				wizardModel.createDatabaseUser = Boolean.valueOf(createDatabaseUser);
			}
			wizardModel.createUserUsername = script.getProperty("create_user_username", wizardModel.createUserUsername);
			wizardModel.createUserPassword = script.getProperty("create_user_password", wizardModel.createUserPassword);
			
			String addDemoData = script.getProperty("add_demo_data");
			if (addDemoData != null) {
				wizardModel.addDemoData = Boolean.valueOf(addDemoData);
			}
			
			String moduleWebAdmin = script.getProperty("module_web_admin");
			if (moduleWebAdmin != null) {
				wizardModel.moduleWebAdmin = Boolean.valueOf(moduleWebAdmin);
			}
			
			String autoUpdateDatabase = script.getProperty("auto_update_database");
			if (autoUpdateDatabase != null) {
				wizardModel.autoUpdateDatabase = Boolean.valueOf(autoUpdateDatabase);
			}
			
			wizardModel.adminUserPassword = script.getProperty("admin_user_password", wizardModel.adminUserPassword);
		}
	}
	
	private void clearPasswords() {
		wizardModel.databaseRootPassword = "";
		wizardModel.createDatabasePassword = "";
		wizardModel.createUserPassword = "";
		wizardModel.currentDatabasePassword = "";
		wizardModel.remotePassword = "";
	}
	
	/**
	 * Called by {@link #doFilter(ServletRequest, ServletResponse, FilterChain)} on POST requests
	 *
	 * @param httpRequest
	 * @param httpResponse
	 */
	@Override
	protected void doPost(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
		throws IOException, ServletException {
		String page = httpRequest.getParameter("page");
		Map<String, Object> referenceMap = new HashMap<>();
		// we need to save current user language in references map since it will be used when template
		// will be rendered
		if (httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE) != null) {
			referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE,
				httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
		}
		
		// if any body has already started installation
		if (isInstallationStarted()) {
			referenceMap.put("isInstallationStarted", true);
			httpResponse.setContentType("text/html");
			renderTemplate(PROGRESS_VM, referenceMap, httpResponse);
			return;
		}
		if (DEFAULT_PAGE.equals(page)) {
			// get props and render the first page
			File runtimeProperties = getRuntimePropertiesFile();
			if (!runtimeProperties.exists()) {
				try {
					runtimeProperties.createNewFile();
					// reset the error objects in case of refresh
					wizardModel.canCreate = true;
					wizardModel.cannotCreateErrorMessage = "";
				}
				catch (IOException io) {
					wizardModel.canCreate = false;
					wizardModel.cannotCreateErrorMessage = io.getMessage();
				}
				// check this before deleting the file again
				wizardModel.canWrite = runtimeProperties.canWrite();
				
				// delete the file again after testing the create/write
				// so that if the user stops the webapp before finishing
				// this wizard, they can still get back into it
				runtimeProperties.delete();
			} else {
				wizardModel.canWrite = runtimeProperties.canWrite();
				
				wizardModel.databaseConnection = Context.getRuntimeProperties().getProperty("connection.url",
					wizardModel.databaseConnection);
				
				wizardModel.currentDatabaseUsername = Context.getRuntimeProperties().getProperty("connection.username",
					wizardModel.currentDatabaseUsername);
				
				wizardModel.currentDatabasePassword = Context.getRuntimeProperties().getProperty("connection.password",
					wizardModel.currentDatabasePassword);
			}
			
			wizardModel.runtimePropertiesPath = runtimeProperties.getAbsolutePath();
			
			checkLocaleAttributes(httpRequest);
			referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE,
				httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
			log.info("Locale stored in session is " + httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
			
			httpResponse.setContentType("text/html");
			// otherwise do step one of the wizard
			renderTemplate(INSTALL_METHOD, referenceMap, httpResponse);
		} else if (INSTALL_METHOD.equals(page)) {
			if (goBack(httpRequest)) {
				referenceMap.put(FilterUtil.REMEMBER_ATTRIBUTE,
					httpRequest.getSession().getAttribute(FilterUtil.REMEMBER_ATTRIBUTE) != null);
				referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE,
					httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
				renderTemplate(CHOOSE_LANG, referenceMap, httpResponse);
				return;
			}
			wizardModel.installMethod = httpRequest.getParameter("install_method");
			if (InitializationWizardModel.INSTALL_METHOD_SIMPLE.equals(wizardModel.installMethod)) {
				page = SIMPLE_SETUP;
			} else if (InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod)) {
				page = TESTING_REMOTE_DETAILS_SETUP;
				wizardModel.currentStepNumber = 1;
				wizardModel.numberOfSteps = skipDatabaseSetupPage() ? 1 : 3;
			} else {
				page = DATABASE_SETUP;
				wizardModel.currentStepNumber = 1;
				wizardModel.numberOfSteps = 5;
			}
			renderTemplate(page, referenceMap, httpResponse);
		} // simple method
		else if (SIMPLE_SETUP.equals(page)) {
			if (goBack(httpRequest)) {
				renderTemplate(INSTALL_METHOD, referenceMap, httpResponse);
				return;
			}
			wizardModel.databaseConnection = httpRequest.getParameter("database_connection");
			;
			
			wizardModel.createDatabaseUsername = Context.getRuntimeProperties().getProperty("connection.username",
				wizardModel.createDatabaseUsername);
			
			wizardModel.createUserUsername = wizardModel.createDatabaseUsername;
			
			wizardModel.databaseRootPassword = httpRequest.getParameter("database_root_password");
			checkForEmptyValue(wizardModel.databaseRootPassword, errors, ErrorMessageConstants.ERROR_DB_PSDW_REQ);
			
			wizardModel.hasCurrentOpenmrsDatabase = false;
			wizardModel.createTables = true;
			// default wizardModel.databaseName is openmrs
			// default wizardModel.createDatabaseUsername is root
			wizardModel.createDatabasePassword = wizardModel.databaseRootPassword;
			wizardModel.addDemoData = "yes".equals(httpRequest.getParameter("add_demo_data"));
			
			wizardModel.hasCurrentDatabaseUser = false;
			wizardModel.createDatabaseUser = true;
			// default wizardModel.createUserUsername is root
			wizardModel.createUserPassword = wizardModel.databaseRootPassword;
			
			wizardModel.moduleWebAdmin = true;
			wizardModel.autoUpdateDatabase = false;
			
			wizardModel.adminUserPassword = InitializationWizardModel.ADMIN_DEFAULT_PASSWORD;
			
			createSimpleSetup(httpRequest.getParameter("database_root_password"), httpRequest.getParameter("add_demo_data"));
			
			try {
				loadedDriverString = DatabaseUtil.loadDatabaseDriver(wizardModel.databaseConnection,
					wizardModel.databaseDriver);
			}
			catch (ClassNotFoundException e) {
				errors.put(ErrorMessageConstants.ERROR_DB_DRIVER_CLASS_REQ, null);
				renderTemplate(page, referenceMap, httpResponse);
				return;
			}
			
			if (errors.isEmpty()) {
				page = WIZARD_COMPLETE;
			}
			renderTemplate(page, referenceMap, httpResponse);
		} // step one
		else if (DATABASE_SETUP.equals(page)) {
			if (goBack(httpRequest)) {
				wizardModel.currentStepNumber -= 1;
				if (InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod)) {
					renderTemplate(TESTING_REMOTE_DETAILS_SETUP, referenceMap, httpResponse);
				} else {
					renderTemplate(INSTALL_METHOD, referenceMap, httpResponse);
				}
				return;
			}
			
			wizardModel.databaseConnection = httpRequest.getParameter("database_connection");
			checkForEmptyValue(wizardModel.databaseConnection, errors, ErrorMessageConstants.ERROR_DB_CONN_REQ);
			
			wizardModel.databaseDriver = httpRequest.getParameter("database_driver");
			checkForEmptyValue(wizardModel.databaseConnection, errors, ErrorMessageConstants.ERROR_DB_DRIVER_REQ);
			
			loadedDriverString = loadDriver(wizardModel.databaseConnection, wizardModel.databaseDriver);
			if (!StringUtils.hasText(loadedDriverString)) {
				errors.put(ErrorMessageConstants.ERROR_DB_DRIVER_CLASS_REQ, null);
				renderTemplate(page, referenceMap, httpResponse);
				return;
			}
			
			//TODO make each bit of page logic a (unit testable) method
			
			// asked the user for their desired database name
			
			if ("yes".equals(httpRequest.getParameter("current_openmrs_database"))) {
				wizardModel.databaseName = httpRequest.getParameter("openmrs_current_database_name");
				checkForEmptyValue(wizardModel.databaseName, errors, ErrorMessageConstants.ERROR_DB_CURR_NAME_REQ);
				wizardModel.hasCurrentOpenmrsDatabase = true;
				// TODO check to see if this is an active database
				
			} else {
				// mark this wizard as a "to create database" (done at the end)
				wizardModel.hasCurrentOpenmrsDatabase = false;
				
				wizardModel.createTables = true;
				
				wizardModel.databaseName = httpRequest.getParameter("openmrs_new_database_name");
				checkForEmptyValue(wizardModel.databaseName, errors, ErrorMessageConstants.ERROR_DB_NEW_NAME_REQ);
				// TODO create database now to check if its possible?
				
				wizardModel.createDatabaseUsername = httpRequest.getParameter("create_database_username");
				checkForEmptyValue(wizardModel.createDatabaseUsername, errors, ErrorMessageConstants.ERROR_DB_USER_NAME_REQ);
				wizardModel.createDatabasePassword = httpRequest.getParameter("create_database_password");
				checkForEmptyValue(wizardModel.createDatabasePassword, errors, ErrorMessageConstants.ERROR_DB_USER_PSWD_REQ);
			}
			
			if (errors.isEmpty()) {
				page = DATABASE_TABLES_AND_USER;
				
				if (InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod)) {
					wizardModel.currentStepNumber = 3;
				} else {
					wizardModel.currentStepNumber = 2;
				}
			}
			
			renderTemplate(page, referenceMap, httpResponse);
			
		} // step two
		else if (DATABASE_TABLES_AND_USER.equals(page)) {
			
			if (goBack(httpRequest)) {
				wizardModel.currentStepNumber -= 1;
				renderTemplate(DATABASE_SETUP, referenceMap, httpResponse);
				return;
			}
			
			if (wizardModel.hasCurrentOpenmrsDatabase) {
				wizardModel.createTables = "yes".equals(httpRequest.getParameter("create_tables"));
			}
			
			wizardModel.addDemoData = "yes".equals(httpRequest.getParameter("add_demo_data"));
			
			if ("yes".equals(httpRequest.getParameter("current_database_user"))) {
				wizardModel.currentDatabaseUsername = httpRequest.getParameter("current_database_username");
				checkForEmptyValue(wizardModel.currentDatabaseUsername, errors,
					ErrorMessageConstants.ERROR_DB_CUR_USER_NAME_REQ);
				wizardModel.currentDatabasePassword = httpRequest.getParameter("current_database_password");
				checkForEmptyValue(wizardModel.currentDatabasePassword, errors,
					ErrorMessageConstants.ERROR_DB_CUR_USER_PSWD_REQ);
				wizardModel.hasCurrentDatabaseUser = true;
				wizardModel.createDatabaseUser = false;
			} else {
				wizardModel.hasCurrentDatabaseUser = false;
				wizardModel.createDatabaseUser = true;
				// asked for the root mysql username/password
				wizardModel.createUserUsername = httpRequest.getParameter("create_user_username");
				checkForEmptyValue(wizardModel.createUserUsername, errors, ErrorMessageConstants.ERROR_DB_USER_NAME_REQ);
				wizardModel.createUserPassword = httpRequest.getParameter("create_user_password");
				checkForEmptyValue(wizardModel.createUserPassword, errors, ErrorMessageConstants.ERROR_DB_USER_PSWD_REQ);
			}
			
			if (errors.isEmpty()) { // go to next page
				page = InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod) ? WIZARD_COMPLETE
					: OTHER_RUNTIME_PROPS;
			}
			
			renderTemplate(page, referenceMap, httpResponse);
		} // step three
		else if (OTHER_RUNTIME_PROPS.equals(page)) {
			
			if (goBack(httpRequest)) {
				renderTemplate(DATABASE_TABLES_AND_USER, referenceMap, httpResponse);
				return;
			}
			
			wizardModel.moduleWebAdmin = "yes".equals(httpRequest.getParameter("module_web_admin"));
			wizardModel.autoUpdateDatabase = "yes".equals(httpRequest.getParameter("auto_update_database"));
			
			if (wizardModel.createTables) { // go to next page if they are creating tables
				page = ADMIN_USER_SETUP;
			} else { // skip a page
				page = IMPLEMENTATION_ID_SETUP;
			}
			
			renderTemplate(page, referenceMap, httpResponse);
			
		} // optional step four
		else if (ADMIN_USER_SETUP.equals(page)) {
			
			if (goBack(httpRequest)) {
				renderTemplate(OTHER_RUNTIME_PROPS, referenceMap, httpResponse);
				return;
			}
			
			wizardModel.adminUserPassword = httpRequest.getParameter("new_admin_password");
			String adminUserConfirm = httpRequest.getParameter("new_admin_password_confirm");
			
			// throw back to admin user if passwords don't match
			if (!wizardModel.adminUserPassword.equals(adminUserConfirm)) {
				errors.put(ErrorMessageConstants.ERROR_DB_ADM_PSWDS_MATCH, null);
				renderTemplate(ADMIN_USER_SETUP, referenceMap, httpResponse);
				return;
			}
			
			// throw back if the user didn't put in a password
			if ("".equals(wizardModel.adminUserPassword)) {
				errors.put(ErrorMessageConstants.ERROR_DB_ADM_PSDW_EMPTY, null);
				renderTemplate(ADMIN_USER_SETUP, referenceMap, httpResponse);
				return;
			}
			
			try {
				OpenmrsUtil.validatePassword("admin", wizardModel.adminUserPassword, "admin");
			}
			catch (PasswordException p) {
				errors.put(ErrorMessageConstants.ERROR_DB_ADM_PSDW_WEAK, null);
				renderTemplate(ADMIN_USER_SETUP, referenceMap, httpResponse);
				return;
			}
			
			if (errors.isEmpty()) { // go to next page
				page = IMPLEMENTATION_ID_SETUP;
			}
			
			renderTemplate(page, referenceMap, httpResponse);
			
		} // optional step five
		else if (IMPLEMENTATION_ID_SETUP.equals(page)) {
			
			if (goBack(httpRequest)) {
				if (wizardModel.createTables) {
					renderTemplate(ADMIN_USER_SETUP, referenceMap, httpResponse);
				} else {
					renderTemplate(OTHER_RUNTIME_PROPS, referenceMap, httpResponse);
				}
				return;
			}
			
			wizardModel.implementationIdName = httpRequest.getParameter("implementation_name");
			wizardModel.implementationId = httpRequest.getParameter("implementation_id");
			wizardModel.implementationIdPassPhrase = httpRequest.getParameter("pass_phrase");
			wizardModel.implementationIdDescription = httpRequest.getParameter("description");
			
			// throw back if the user-specified ID is invalid (contains ^ or |).
			if (wizardModel.implementationId.indexOf('^') != -1 || wizardModel.implementationId.indexOf('|') != -1) {
				errors.put(ErrorMessageConstants.ERROR_DB_IMPL_ID_REQ, null);
				renderTemplate(IMPLEMENTATION_ID_SETUP, referenceMap, httpResponse);
				return;
			}
			
			if (errors.isEmpty()) { // go to next page
				page = WIZARD_COMPLETE;
			}
			
			renderTemplate(page, referenceMap, httpResponse);
		} else if (WIZARD_COMPLETE.equals(page)) {
			
			if (goBack(httpRequest)) {
				
				if (InitializationWizardModel.INSTALL_METHOD_SIMPLE.equals(wizardModel.installMethod)) {
					page = SIMPLE_SETUP;
				} else if (InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod)) {
					if (skipDatabaseSetupPage()) {
						page = TESTING_REMOTE_DETAILS_SETUP;
					} else {
						page = DATABASE_TABLES_AND_USER;
					}
				} else {
					page = IMPLEMENTATION_ID_SETUP;
				}
				renderTemplate(page, referenceMap, httpResponse);
				return;
			}
			
			wizardModel.tasksToExecute = new ArrayList<>();
			createDatabaseTask();
			if (InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod)) {
				wizardModel.importTestData = true;
				wizardModel.createTables = false;
				wizardModel.addDemoData = false;
				//if we have a runtime properties file
				if (skipDatabaseSetupPage()) {
					wizardModel.hasCurrentOpenmrsDatabase = false;
					wizardModel.hasCurrentDatabaseUser = true;
					wizardModel.createDatabaseUser = false;
					Properties props = OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME);
					wizardModel.currentDatabaseUsername = props.getProperty("connection.username");
					wizardModel.currentDatabasePassword = props.getProperty("connection.password");
					wizardModel.createDatabaseUsername = wizardModel.currentDatabaseUsername;
					wizardModel.createDatabasePassword = wizardModel.currentDatabasePassword;
				}
				
				wizardModel.tasksToExecute.add(WizardTask.IMPORT_TEST_DATA);
				wizardModel.tasksToExecute.add(WizardTask.ADD_MODULES);
			} else {
				createTablesTask();
				createDemoDataTask();
			}
			wizardModel.tasksToExecute.add(WizardTask.UPDATE_TO_LATEST);
			
			referenceMap.put("tasksToExecute", wizardModel.tasksToExecute);
			startInstallation();
			renderTemplate(PROGRESS_VM, referenceMap, httpResponse);
		} else if (TESTING_REMOTE_DETAILS_SETUP.equals(page)) {
			if (goBack(httpRequest)) {
				wizardModel.currentStepNumber -= 1;
				renderTemplate(INSTALL_METHOD, referenceMap, httpResponse);
				return;
			}
			
			wizardModel.remoteUrl = httpRequest.getParameter("remoteUrl");
			checkForEmptyValue(wizardModel.remoteUrl, errors, "install.testing.remote.url.required");
			if (errors.isEmpty()) {
				//Check if the remote system is running
				if (TestInstallUtil.testConnection(wizardModel.remoteUrl)) {
					//Check if the test module is installed by connecting to its setting page
					if (TestInstallUtil
						.testConnection(wizardModel.remoteUrl.concat(RELEASE_TESTING_MODULE_PATH + "settings.htm"))) {
						
						wizardModel.remoteUsername = httpRequest.getParameter("username");
						wizardModel.remotePassword = httpRequest.getParameter("password");
						checkForEmptyValue(wizardModel.remoteUsername, errors, "install.testing.username.required");
						checkForEmptyValue(wizardModel.remotePassword, errors, "install.testing.password.required");
						
						if (errors.isEmpty()) {
							//check if the username and password are valid
							try {
								TestInstallUtil.getResourceInputStream(
									wizardModel.remoteUrl + RELEASE_TESTING_MODULE_PATH + "verifycredentials.htm",
									wizardModel.remoteUsername, wizardModel.remotePassword);
							}
							catch (APIAuthenticationException e) {
								log.debug("Error generated: ", e);
								page = TESTING_REMOTE_DETAILS_SETUP;
								errors.put(ErrorMessageConstants.UPDATE_ERROR_UNABLE_AUTHENTICATE, null);
								renderTemplate(page, referenceMap, httpResponse);
								return;
							}
							
							//If we have a runtime properties file, get the database setup details from it
							if (skipDatabaseSetupPage()) {
								Properties props = OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME);
								wizardModel.databaseConnection = props.getProperty("connection.url");
								loadedDriverString = loadDriver(wizardModel.databaseConnection, wizardModel.databaseDriver);
								if (!StringUtils.hasText(loadedDriverString)) {
									page = TESTING_REMOTE_DETAILS_SETUP;
									errors.put(ErrorMessageConstants.ERROR_DB_DRIVER_CLASS_REQ, null);
									renderTemplate(page, referenceMap, httpResponse);
									return;
								}
								
								wizardModel.databaseName = InitializationWizardModel.DEFAULT_DATABASE_NAME;
								page = WIZARD_COMPLETE;
							} else {
								page = DATABASE_SETUP;
								wizardModel.currentStepNumber = 2;
							}
							msgs.put("install.testing.testingModuleFound", null);
						} else {
							renderTemplate(page, referenceMap, httpResponse);
							return;
						}
					} else {
						errors.put("install.testing.noTestingModule", null);
					}
				} else {
					errors.put("install.testing.invalidProductionUrl", new Object[] { wizardModel.remoteUrl });
				}
			}
			
			renderTemplate(page, referenceMap, httpResponse);
		}
	}
	
	private void startInstallation() {
		//if no one has run any installation
		if (!isInstallationStarted()) {
			initJob = new InitializationCompletion();
			setInstallationStarted(true);
			initJob.start();
		}
	}
	
	private void createDemoDataTask() {
		if (wizardModel.addDemoData) {
			wizardModel.tasksToExecute.add(WizardTask.ADD_DEMO_DATA);
		}
	}
	
	private void createTablesTask() {
		if (wizardModel.createTables) {
			wizardModel.tasksToExecute.add(WizardTask.CREATE_TABLES);
			wizardModel.tasksToExecute.add(WizardTask.ADD_CORE_DATA);
		}
	}
	
	private void createDatabaseTask() {
		if (!wizardModel.hasCurrentOpenmrsDatabase) {
			wizardModel.tasksToExecute.add(WizardTask.CREATE_SCHEMA);
		}
		if (wizardModel.createDatabaseUser) {
			wizardModel.tasksToExecute.add(WizardTask.CREATE_DB_USER);
		}
	}
	
	private void createSimpleSetup(String databaseRootPassword, String addDemoData) {
		setDatabaseNameIfInTestMode();
		wizardModel.databaseConnection = Context.getRuntimeProperties().getProperty("connection.url",
			wizardModel.databaseConnection);
		
		wizardModel.createDatabaseUsername = Context.getRuntimeProperties().getProperty("connection.username",
			wizardModel.createDatabaseUsername);
		
		wizardModel.createUserUsername = wizardModel.createDatabaseUsername;
		
		wizardModel.databaseRootPassword = databaseRootPassword;
		checkForEmptyValue(wizardModel.databaseRootPassword, errors, ErrorMessageConstants.ERROR_DB_PSDW_REQ);
		
		wizardModel.hasCurrentOpenmrsDatabase = false;
		wizardModel.createTables = true;
		// default wizardModel.databaseName is openmrs
		// default wizardModel.createDatabaseUsername is root
		wizardModel.createDatabasePassword = wizardModel.databaseRootPassword;
		wizardModel.addDemoData = "yes".equals(addDemoData);
		
		wizardModel.hasCurrentDatabaseUser = false;
		wizardModel.createDatabaseUser = true;
		// default wizardModel.createUserUsername is root
		wizardModel.createUserPassword = wizardModel.databaseRootPassword;
		
		wizardModel.moduleWebAdmin = true;
		wizardModel.autoUpdateDatabase = false;
		
		wizardModel.adminUserPassword = InitializationWizardModel.ADMIN_DEFAULT_PASSWORD;
	}
	
	private void setDatabaseNameIfInTestMode() {
		if (OpenmrsUtil.isTestMode()) {
			wizardModel.databaseName = OpenmrsUtil.getOpenMRSVersionInTestMode();
		}
	}
	
	private void autoRunOpenMRS(HttpServletRequest httpRequest) {
		File runtimeProperties = getRuntimePropertiesFile();
		wizardModel.runtimePropertiesPath = runtimeProperties.getAbsolutePath();
		
		if (!InitializationWizardModel.INSTALL_METHOD_AUTO.equals(wizardModel.installMethod)) {
			if (httpRequest.getParameter("database_user_name") != null) {
				wizardModel.createDatabaseUsername = httpRequest.getParameter("database_user_name");
			}
			
			createSimpleSetup(httpRequest.getParameter("database_root_password"), "yes");
		}
		
		checkLocaleAttributes(httpRequest);
		try {
			loadedDriverString = DatabaseUtil.loadDatabaseDriver(wizardModel.databaseConnection, wizardModel.databaseDriver);
		}
		catch (ClassNotFoundException e) {
			errors.put(ErrorMessageConstants.ERROR_DB_DRIVER_CLASS_REQ, null);
			return;
		}
		wizardModel.tasksToExecute = new ArrayList<>();
		createDatabaseTask();
		createTablesTask();
		createDemoDataTask();
		wizardModel.tasksToExecute.add(WizardTask.UPDATE_TO_LATEST);
		startInstallation();
	}
	
	/**
	 * This method should be called after the user has left wizard's first page (i.e. choose language).
	 * It checks if user has changed any of locale related parameters and makes appropriate corrections
	 * with filter's model or/and with locale attribute inside user's session.
	 *
	 * @param httpRequest the http request object
	 */
	private void checkLocaleAttributes(HttpServletRequest httpRequest) {
		String localeParameter = httpRequest.getParameter(FilterUtil.LOCALE_ATTRIBUTE);
		Boolean rememberLocale = false;
		// we need to check if user wants that system will remember his selection of language
		if (httpRequest.getParameter(FilterUtil.REMEMBER_ATTRIBUTE) != null) {
			rememberLocale = true;
		}
		if (localeParameter != null) {
			String storedLocale = null;
			if (httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE) != null) {
				storedLocale = httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE).toString();
			}
			// if user has changed locale parameter to new one
			// or chooses it parameter at first page loading
			if (storedLocale == null || !storedLocale.equals(localeParameter)) {
				log.info("Stored locale parameter to session " + localeParameter);
				httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, localeParameter);
			}
			if (rememberLocale) {
				httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, localeParameter);
				httpRequest.getSession().setAttribute(FilterUtil.REMEMBER_ATTRIBUTE, true);
				wizardModel.localeToSave = localeParameter;
			} else {
				// we need to reset it if it was set before
				httpRequest.getSession().setAttribute(FilterUtil.REMEMBER_ATTRIBUTE, null);
				wizardModel.localeToSave = null;
			}
		}
	}
	
	/**
	 * It sets locale parameter for current session when user is making first GET http request to
	 * application. It retrieves user locale from request object and checks if this locale is supported
	 * by application. If not, it uses {@link Locale#ENGLISH} by default
	 *
	 * @param httpRequest the http request object
	 */
	public void checkLocaleAttributesForFirstTime(HttpServletRequest httpRequest) {
		Locale locale = httpRequest.getLocale();
		if (CustomResourceLoader.getInstance(httpRequest).getAvailablelocales().contains(locale)) {
			httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, locale.toString());
		} else {
			httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, Locale.ENGLISH.toString());
		}
	}
	
	/**
	 * Verify the database connection works.
	 *
	 * @param connectionUsername
	 * @param connectionPassword
	 * @param databaseConnectionFinalUrl
	 * @return true/false whether it was verified or not
	 */
	private boolean verifyConnection(String connectionUsername, String connectionPassword,
		String databaseConnectionFinalUrl) {
		try {
			// verify connection
			//Set Database Driver using driver String
			Class.forName(loadedDriverString).newInstance();
			Connection tempConnection = DriverManager.getConnection(databaseConnectionFinalUrl, connectionUsername,
				connectionPassword);
			tempConnection.close();
			return true;
			
		}
		catch (Exception e) {
			errors.put("User account " + connectionUsername + " does not work. " + e.getMessage()
					+ " See the error log for more details",
				null); // TODO internationalize this
			log.warn("Error while checking the connection user account", e);
			return false;
		}
	}
	
	/**
	 * Convenience method to load the runtime properties file.
	 *
	 * @return the runtime properties file.
	 */
	private File getRuntimePropertiesFile() {
		File file;
		
		String pathName = OpenmrsUtil.getRuntimePropertiesFilePathName(WebConstants.WEBAPP_NAME);
		if (pathName != null) {
			file = new File(pathName);
		} else {
			file = new File(OpenmrsUtil.getApplicationDataDirectory(), getRuntimePropertiesFileName());
		}
		
		log.debug("Using file: " + file.getAbsolutePath());
		
		return file;
	}
	
	private String getRuntimePropertiesFileName() {
		String fileName = OpenmrsUtil.getRuntimePropertiesFileNameInTestMode();
		if (fileName == null) {
			fileName = WebConstants.WEBAPP_NAME + "-runtime.properties";
		}
		return fileName;
	}
	
	/**
	 * @see org.openmrs.web.filter.StartupFilter#getTemplatePrefix()
	 */
	@Override
	protected String getTemplatePrefix() {
		return "org/openmrs/web/filter/initialization/";
	}
	
	/**
	 * @see org.openmrs.web.filter.StartupFilter#getUpdateFilterModel()
	 */
	@Override
	protected Object getUpdateFilterModel() {
		return wizardModel;
	}
	
	/**
	 * @see org.openmrs.web.filter.StartupFilter#skipFilter(HttpServletRequest)
	 */
	@Override
	public boolean skipFilter(HttpServletRequest httpRequest) {
		// If progress.vm makes an ajax request even immediately after initialization has completed
		// let the request pass in order to let progress.vm load the start page of OpenMRS
		// (otherwise progress.vm is displayed "forever")
		return !PROGRESS_VM_AJAXREQUEST.equals(httpRequest.getParameter("page")) && !initializationRequired();
	}
	
	/**
	 * Public method that returns true if database+runtime properties initialization is required
	 *
	 * @return true if this initialization wizard needs to run
	 */
	public static boolean initializationRequired() {
		return !isInitializationComplete();
	}
	
	/**
	 * @param isInstallationStarted the value to set
	 */
	protected static synchronized void setInstallationStarted(boolean isInstallationStarted) {
		InitializationFilter.isInstallationStarted = isInstallationStarted;
	}
	
	/**
	 * @return true if installation has been started
	 */
	protected static boolean isInstallationStarted() {
		return isInstallationStarted;
	}
	
	/**
	 * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)
	 */
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		super.init(filterConfig);
		wizardModel = new InitializationWizardModel();
		DatabaseDetective databaseDetective = new DatabaseDetective();
		//set whether need to do initialization work
		if (databaseDetective.isDatabaseEmpty(OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME))) {
			//if runtime-properties file doesn't exist, have to do initialization work
			setInitializationComplete(false);
		} else {
			//if database is not empty, then let UpdaterFilter to judge whether need database update
			setInitializationComplete(true);
		}
	}
	
	private void importTestDataSet(InputStream in, String connectionUrl, String connectionUsername,
		String connectionPassword) throws IOException {
		File tempFile = null;
		FileOutputStream fileOut = null;
		try {
			ZipInputStream zipIn = new ZipInputStream(in);
			zipIn.getNextEntry();
			
			tempFile = File.createTempFile("testDataSet", "dump");
			fileOut = new FileOutputStream(tempFile);
			
			IOUtils.copy(zipIn, fileOut);
			
			fileOut.close();
			zipIn.close();
			
			//Cater for the stand-alone connection url with has :mxj:
			if (connectionUrl.contains(":mxj:")) {
				connectionUrl = connectionUrl.replace(":mxj:", ":");
			}
			
			URI uri = URI.create(connectionUrl.substring(5)); //remove 'jdbc:' prefix to conform to the URI format
			String host = uri.getHost();
			int port = uri.getPort();
			
			TestInstallUtil.addTestData(host, port, wizardModel.databaseName, connectionUsername, connectionPassword,
				tempFile.getAbsolutePath());
		}
		finally {
			IOUtils.closeQuietly(in);
			IOUtils.closeQuietly(fileOut);
			
			if (tempFile != null) {
				tempFile.delete();
			}
		}
	}
	
	private boolean isCurrentDatabase(String database) {
		return wizardModel.databaseConnection.contains(database);
	}
	
	/**
	 * @param silent if this statement fails do not display stack trace or record an error in the wizard
	 *            object.
	 * @param user username to connect with
	 * @param pw password to connect with
	 * @param sql String containing sql and question marks
	 * @param args the strings to fill into the question marks in the given sql
	 * @return result of executeUpdate or -1 for error
	 */
	private int executeStatement(boolean silent, String user, String pw, String sql, String... args) {
		
		Connection connection = null;
		Statement statement = null;
		try {
			String replacedSql = sql;
			
			// TODO how to get the driver for the other dbs...
			if (isCurrentDatabase(DATABASE_MYSQL)) {
				Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
			} else if (isCurrentDatabase(DATABASE_POSTGRESQL)) {
				Class.forName("org.postgresql.Driver").newInstance();
				replacedSql = replacedSql.replaceAll("`", "\"");
			} else {
				replacedSql = replacedSql.replaceAll("`", "\"");
			}
			
			String tempDatabaseConnection;
			if (sql.contains("create database")) {
				tempDatabaseConnection = wizardModel.databaseConnection.replace("@DBNAME@",
					""); // make this dbname agnostic so we can create the db
			} else {
				tempDatabaseConnection = wizardModel.databaseConnection.replace("@DBNAME@", wizardModel.databaseName);
			}
			
			connection = DriverManager.getConnection(tempDatabaseConnection, user, pw);
			
			for (String arg : args) {
				arg = arg.replace(";", "&#094"); // to prevent any sql injection
				replacedSql = replacedSql.replaceFirst("\\?", arg);
			}
			
			// run the sql statement
			statement = connection.createStatement();
			
			return statement.executeUpdate(replacedSql);
			
		}
		catch (SQLException sqlex) {
			if (!silent) {
				// log and add error
				log.warn("error executing sql: " + sql, sqlex);
				errors.put("Error executing sql: " + sql + " - " + sqlex.getMessage(), null);
			}
		}
		catch (InstantiationException | ClassNotFoundException | IllegalAccessException e) {
			log.error("Error generated", e);
		}
		finally {
			try {
				if (statement != null) {
					statement.close();
				}
			}
			catch (SQLException e) {
				log.warn("Error while closing statement");
			}
			try {
				
				if (connection != null) {
					connection.close();
				}
			}
			catch (Exception e) {
				log.warn("Error while closing connection", e);
			}
		}
		
		return -1;
	}
	
	/**
	 * Convenience variable to know if this wizard has completed successfully and that this wizard does
	 * not need to be executed again
	 *
	 * @return true if this has been run already
	 */
	private static synchronized boolean isInitializationComplete() {
		return initializationComplete;
	}
	
	/**
	 * Check if the given value is null or a zero-length String
	 *
	 * @param value the string to check
	 * @param errors the list of errors to append the errorMessage to if value is empty
	 * @param errorMessageCode the string with code of error message translation to append if value is
	 *            empty
	 * @return true if the value is non-empty
	 */
	private boolean checkForEmptyValue(String value, Map<String, Object[]> errors, String errorMessageCode) {
		if (!StringUtils.isEmpty(value)) {
			return true;
		}
		errors.put(errorMessageCode, null);
		return false;
	}
	
	/**
	 * Separate thread that will run through all tasks to complete the initialization. The database is
	 * created, user's created, etc here
	 */
	private class InitializationCompletion {
		
		private final Future<Void> future;
		
		private int steps = 0;
		
		private String message = "";
		
		private Map<String, Object[]> errors = new HashMap<>();
		
		private String errorPage = null;
		
		private boolean erroneous = false;
		
		private int completedPercentage = 0;
		
		private WizardTask executingTask;
		
		private List<WizardTask> executedTasks = new ArrayList<>();
		
		public synchronized void reportError(String error, String errorPage, Object... params) {
			errors.put(error, params);
			this.errorPage = errorPage;
			erroneous = true;
		}
		
		public synchronized boolean hasErrors() {
			return erroneous;
		}
		
		public synchronized String getErrorPage() {
			return errorPage;
		}
		
		public synchronized Map<String, Object[]> getErrors() {
			return errors;
		}
		
		/**
		 * Start the completion stage. This fires up the thread to do all the work.
		 */
		public void start() {
			setStepsComplete(0);
			setInitializationComplete(false);
		}
		
		public void waitForCompletion() {
			try {
				future.get();
			} catch (InterruptedException | ExecutionException e) {
				throw new RuntimeException(e);
			}
		}
		
		protected synchronized void setStepsComplete(int steps) {
			this.steps = steps;
		}
		
		protected synchronized int getStepsComplete() {
			return steps;
		}
		
		public synchronized String getMessage() {
			return message;
		}
		
		public synchronized void setMessage(String message) {
			this.message = message;
			setStepsComplete(getStepsComplete() + 1);
		}
		
		/**
		 * @return the executingTask
		 */
		protected synchronized WizardTask getExecutingTask() {
			return executingTask;
		}
		
		/**
		 * @return the completedPercentage
		 */
		protected synchronized int getCompletedPercentage() {
			return completedPercentage;
		}
		
		/**
		 * @param completedPercentage the completedPercentage to set
		 */
		protected synchronized void setCompletedPercentage(int completedPercentage) {
			this.completedPercentage = completedPercentage;
		}
		
		/**
		 * Adds a task that has been completed to the list of executed tasks
		 *
		 * @param task
		 */
		protected synchronized void addExecutedTask(WizardTask task) {
			this.executedTasks.add(task);
		}
		
		/**
		 * @param executingTask the executingTask to set
		 */
		protected synchronized void setExecutingTask(WizardTask executingTask) {
			this.executingTask = executingTask;
		}
		
		/**
		 * @return the executedTasks
		 */
		protected synchronized List<WizardTask> getExecutedTasks() {
			return this.executedTasks;
		}
		
		/**
		 * This class does all the work of creating the desired database, user, updates, etc
		 */
		public InitializationCompletion() {
			Runnable r = new Runnable() {
				
				/**
				 * TODO split this up into multiple testable methods
				 *
				 * @see java.lang.Runnable#run()
				 */
				@Override
				public void run() {
					try {
						String connectionUsername;
						StringBuilder connectionPassword = new StringBuilder();
						ChangeLogDetective changeLogDetective = new ChangeLogDetective();
						ChangeLogVersionFinder changeLogVersionFinder = new ChangeLogVersionFinder();
						
						if (!wizardModel.hasCurrentOpenmrsDatabase) {
							setMessage("Create database");
							setExecutingTask(WizardTask.CREATE_SCHEMA);
							// connect via jdbc and create a database
							String sql;
							if (isCurrentDatabase(DATABASE_MYSQL)) {
								sql = "create database if not exists `?` default character set utf8";
							} else if (isCurrentDatabase(DATABASE_POSTGRESQL)) {
								sql = "create database `?` encoding 'utf8'";
							} else if (isCurrentDatabase(DATABASE_H2)) {
								sql = null;
							} else {
								sql = "create database `?`";
							}
							
							int result;
							if (sql != null) {
								result = executeStatement(false, wizardModel.createDatabaseUsername,
									wizardModel.createDatabasePassword, sql, wizardModel.databaseName);
							} else {
								result = 1;
							}
							// throw the user back to the main screen if this error occurs
							if (result < 0) {
								reportError(ErrorMessageConstants.ERROR_DB_CREATE_NEW, DEFAULT_PAGE);
								return;
							} else {
								wizardModel.workLog.add("Created database " + wizardModel.databaseName);
							}
							
							addExecutedTask(WizardTask.CREATE_SCHEMA);
						}
						
						if (wizardModel.createDatabaseUser) {
							setMessage("Create database user");
							setExecutingTask(WizardTask.CREATE_DB_USER);
							connectionUsername = wizardModel.databaseName + "_user";
							if (connectionUsername.length() > 16) {
								connectionUsername = wizardModel.databaseName.substring(0, 11)
									+ "_user"; // trim off enough to leave space for _user at the end
							}
							
							connectionPassword.append("");
							// generate random password from this subset of alphabet
							// intentionally left out these characters: ufsb$() to prevent certain words forming randomly
							String chars = "acdeghijklmnopqrtvwxyzACDEGHIJKLMNOPQRTVWXYZ0123456789.|~@#^&";
							Random r = new Random();
							StringBuilder randomStr = new StringBuilder("");
							for (int x = 0; x < 12; x++) {
								randomStr.append(chars.charAt(r.nextInt(chars.length())));
							}
							connectionPassword.append(randomStr);
							
							// connect via jdbc with root user and create an openmrs user
							String host = "'%'";
							if (wizardModel.databaseConnection.contains("localhost")
								|| wizardModel.databaseConnection.contains("127.0.0.1")) {
								host = "'localhost'";
							}
							
							String sql = "";
							if (isCurrentDatabase(DATABASE_MYSQL)) {
								sql = "drop user '?'@" + host;
							} else if (isCurrentDatabase(DATABASE_POSTGRESQL)) {
								sql = "drop user `?`";
							}
							
							executeStatement(true, wizardModel.createUserUsername, wizardModel.createUserPassword, sql,
								connectionUsername);
							
							if (isCurrentDatabase(DATABASE_MYSQL)) {
								sql = "create user '?'@" + host + " identified by '?'";
							} else if (isCurrentDatabase(DATABASE_POSTGRESQL)) {
								sql = "create user `?` with password '?'";
							}
							
							if (-1 != executeStatement(false, wizardModel.createUserUsername, wizardModel.createUserPassword,
								sql, connectionUsername, connectionPassword.toString())) {
								wizardModel.workLog.add("Created user " + connectionUsername);
							} else {
								// if error occurs stop
								reportError(ErrorMessageConstants.ERROR_DB_CREATE_DB_USER, DEFAULT_PAGE);
								return;
							}
							
							// grant the roles
							int result = 1;
							if (isCurrentDatabase(DATABASE_MYSQL)) {
								sql = "GRANT ALL ON `?`.* TO '?'@" + host;
								result = executeStatement(false, wizardModel.createUserUsername,
									wizardModel.createUserPassword, sql, wizardModel.databaseName, connectionUsername);
							} else if (isCurrentDatabase(DATABASE_POSTGRESQL)) {
								sql = "ALTER USER `?` WITH SUPERUSER";
								result = executeStatement(false, wizardModel.createUserUsername,
									wizardModel.createUserPassword, sql, connectionUsername);
							}
							
							// throw the user back to the main screen if this error occurs
							if (result < 0) {
								reportError(ErrorMessageConstants.ERROR_DB_GRANT_PRIV, DEFAULT_PAGE);
								return;
							} else {
								wizardModel.workLog.add("Granted user " + connectionUsername + " all privileges to database "
									+ wizardModel.databaseName);
							}
							
							addExecutedTask(WizardTask.CREATE_DB_USER);
						} else {
							connectionUsername = wizardModel.currentDatabaseUsername;
							connectionPassword.setLength(0);
							connectionPassword.append(wizardModel.currentDatabasePassword);
						}
						
						String finalDatabaseConnectionString = wizardModel.databaseConnection.replace("@DBNAME@",
							wizardModel.databaseName);
						
						finalDatabaseConnectionString = finalDatabaseConnectionString.replace("@APPLICATIONDATADIR@",
							OpenmrsUtil.getApplicationDataDirectory().replace("\\", "/"));
						
						// verify that the database connection works
						if (!verifyConnection(connectionUsername, connectionPassword.toString(),
							finalDatabaseConnectionString)) {
							setMessage("Verify that the database connection works");
							// redirect to setup page if we got an error
							reportError("Unable to connect to database", DEFAULT_PAGE);
							return;
						}
						
						// save the properties for startup purposes
						Properties runtimeProperties = new Properties();
						
						runtimeProperties.put("connection.url", finalDatabaseConnectionString);
						runtimeProperties.put("connection.username", connectionUsername);
						runtimeProperties.put("connection.password", connectionPassword.toString());
						if (StringUtils.hasText(wizardModel.databaseDriver)) {
							runtimeProperties.put("connection.driver_class", wizardModel.databaseDriver);
						}
						if (finalDatabaseConnectionString.contains(DATABASE_POSTGRESQL)) {
							runtimeProperties.put("hibernate.dialect", "org.hibernate.dialect.PostgreSQL82Dialect");
						}
						if (finalDatabaseConnectionString.contains(DATABASE_SQLSERVER)) {
							runtimeProperties.put("hibernate.dialect", "org.hibernate.dialect.SQLServerDialect");
						}
						if (finalDatabaseConnectionString.contains(DATABASE_H2)) {
							runtimeProperties.put("hibernate.dialect", "org.hibernate.dialect.H2Dialect");
						}
						runtimeProperties.put("module.allow_web_admin", wizardModel.moduleWebAdmin.toString());
						runtimeProperties.put("auto_update_database", wizardModel.autoUpdateDatabase.toString());
						final Encoder base64 = Base64.getEncoder();
						runtimeProperties.put(OpenmrsConstants.ENCRYPTION_VECTOR_RUNTIME_PROPERTY,
							new String(base64.encode(Security.generateNewInitVector()), StandardCharsets.UTF_8));
						runtimeProperties.put(OpenmrsConstants.ENCRYPTION_KEY_RUNTIME_PROPERTY,
							new String(base64.encode(Security.generateNewSecretKey()), StandardCharsets.UTF_8));
						
						Properties properties = Context.getRuntimeProperties();
						properties.putAll(runtimeProperties);
						runtimeProperties = properties;
						Context.setRuntimeProperties(runtimeProperties);
						
						/**
						 * A callback class that prints out info about liquibase changesets
						 */
						class PrintingChangeSetExecutorCallback implements ChangeSetExecutorCallback {
							
							private int i = 1;
							
							private String message;
							
							public PrintingChangeSetExecutorCallback(String message) {
								this.message = message;
							}
							
							/**
							 * @see ChangeSetExecutorCallback#executing(liquibase.changelog.ChangeSet, int)
							 */
							@Override
							public void executing(ChangeSet changeSet, int numChangeSetsToRun) {
								setMessage(message + " (" + i++ + "/" + numChangeSetsToRun + "): Author: "
									+ changeSet.getAuthor() + " Comments: " + changeSet.getComments() + " Description: "
									+ changeSet.getDescription());
								float numChangeSetsToRunFloat = (float) numChangeSetsToRun;
								float j = (float) i;
								setCompletedPercentage(Math.round(j * 100 / numChangeSetsToRunFloat));
							}
							
						}
						
						if (wizardModel.createTables) {
							// use liquibase to create core data + tables
							try {
								String liquibaseSchemaFileName = changeLogVersionFinder.getLatestSchemaSnapshotFilename()
									.get();
								String liquibaseCoreDataFileName = changeLogVersionFinder.getLatestCoreDataSnapshotFilename()
									.get();
								
								setMessage("Executing " + liquibaseSchemaFileName);
								setExecutingTask(WizardTask.CREATE_TABLES);
								
								log.debug("executing Liquibase file '{}' ", liquibaseSchemaFileName);
								
								DatabaseUpdater.executeChangelog(liquibaseSchemaFileName,
									new PrintingChangeSetExecutorCallback("OpenMRS schema file"));
								addExecutedTask(WizardTask.CREATE_TABLES);
								
								//reset for this task
								setCompletedPercentage(0);
								setExecutingTask(WizardTask.ADD_CORE_DATA);
								
								log.debug("executing Liquibase file '{}' ", liquibaseCoreDataFileName);
								
								DatabaseUpdater.executeChangelog(liquibaseCoreDataFileName,
									new PrintingChangeSetExecutorCallback("OpenMRS core data file"));
								wizardModel.workLog.add("Created database tables and added core data");
								addExecutedTask(WizardTask.ADD_CORE_DATA);
								
							}
							catch (Exception e) {
								reportError(ErrorMessageConstants.ERROR_DB_CREATE_TABLES_OR_ADD_DEMO_DATA, DEFAULT_PAGE,
									e.getMessage());
								log.warn("Error while trying to create tables and demo data", e);
							}
						}
						
						if (wizardModel.importTestData) {
							try {
								setMessage("Importing test data");
								setExecutingTask(WizardTask.IMPORT_TEST_DATA);
								setCompletedPercentage(0);
								
								try {
									InputStream inData = TestInstallUtil.getResourceInputStream(
										wizardModel.remoteUrl + RELEASE_TESTING_MODULE_PATH + "generateTestDataSet.form",
										wizardModel.remoteUsername, wizardModel.remotePassword);
									
									setCompletedPercentage(40);
									setMessage("Loading imported test data...");
									importTestDataSet(inData, finalDatabaseConnectionString, connectionUsername,
										connectionPassword.toString());
									wizardModel.workLog.add("Imported test data");
									addExecutedTask(WizardTask.IMPORT_TEST_DATA);
									
									//reset the progress for the next task
									setCompletedPercentage(0);
									setMessage("Importing modules from remote server...");
									setExecutingTask(WizardTask.ADD_MODULES);
									
									InputStream inModules = TestInstallUtil.getResourceInputStream(
										wizardModel.remoteUrl + RELEASE_TESTING_MODULE_PATH + "getModules.htm",
										wizardModel.remoteUsername, wizardModel.remotePassword);
									
									setCompletedPercentage(90);
									setMessage("Adding imported modules...");
									if (!TestInstallUtil.addZippedTestModules(inModules)) {
										reportError(ErrorMessageConstants.ERROR_DB_UNABLE_TO_ADD_MODULES, DEFAULT_PAGE, "");
										return;
									} else {
										wizardModel.workLog.add("Added Modules");
										addExecutedTask(WizardTask.ADD_MODULES);
									}
								}
								catch (APIAuthenticationException e) {
									log.warn("Unable to authenticate as a User with the System Developer role");
									reportError(ErrorMessageConstants.UPDATE_ERROR_UNABLE_AUTHENTICATE,
										TESTING_REMOTE_DETAILS_SETUP, "");
									return;
								}
							}
							catch (Exception e) {
								reportError(ErrorMessageConstants.ERROR_DB_IMPORT_TEST_DATA, DEFAULT_PAGE, e.getMessage());
								log.warn("Error while trying to import test data", e);
								return;
							}
						}
						
						// add demo data only if creating tables fresh and user selected the option add demo data
						if (wizardModel.createTables && wizardModel.addDemoData) {
							try {
								setMessage("Adding demo data");
								setCompletedPercentage(0);
								setExecutingTask(WizardTask.ADD_DEMO_DATA);
								
								log.debug("executing Liquibase file '{}' ", LIQUIBASE_DEMO_DATA);
								
								DatabaseUpdater.executeChangelog(LIQUIBASE_DEMO_DATA,
									new PrintingChangeSetExecutorCallback("OpenMRS demo patients, users, and forms"));
								wizardModel.workLog.add("Added demo data");
								
								addExecutedTask(WizardTask.ADD_DEMO_DATA);
							}
							catch (Exception e) {
								reportError(ErrorMessageConstants.ERROR_DB_CREATE_TABLES_OR_ADD_DEMO_DATA, DEFAULT_PAGE,
									e.getMessage());
								log.warn("Error while trying to add demo data", e);
							}
						}
						
						// update the database to the latest version
						try {
							setMessage("Updating the database to the latest version");
							setCompletedPercentage(0);
							setExecutingTask(WizardTask.UPDATE_TO_LATEST);
							
							String version = null;
							
							if (wizardModel.createTables) {
								version = changeLogVersionFinder.getLatestSnapshotVersion().get();
							} else {
								version = changeLogDetective.getInitialLiquibaseSnapshotVersion(DatabaseUpdater.CONTEXT,
									new DatabaseUpdaterLiquibaseProvider());
							}
							
							log.debug(
								"updating the database with versions of liquibase-update-to-latest files greater than '{}'",
								version);
							
							List<String> changelogs = changeLogVersionFinder
								.getUpdateFileNames(changeLogVersionFinder.getUpdateVersionsGreaterThan(version));
							
							for (String changelog : changelogs) {
								log.debug("applying Liquibase changelog '{}'", changelog);
								
								DatabaseUpdater.executeChangelog(changelog,
									new PrintingChangeSetExecutorCallback("executing Liquibase changelog " + changelog));
							}
							addExecutedTask(WizardTask.UPDATE_TO_LATEST);
						}
						catch (Exception e) {
							reportError(ErrorMessageConstants.ERROR_DB_UPDATE_TO_LATEST, DEFAULT_PAGE, e.getMessage());
							log.warn("Error while trying to update to the latest database version", e);
							return;
						}
						
						setExecutingTask(null);
						setMessage("Starting OpenMRS");
						
						// start spring
						// after this point, all errors need to also call: contextLoader.closeWebApplicationContext(event.getServletContext())
						// logic copied from org.springframework.web.context.ContextLoaderListener
						ContextLoader contextLoader = new ContextLoader();
						contextLoader.initWebApplicationContext(filterConfig.getServletContext());
						
						// output properties to the openmrs runtime properties file so that this wizard is not run again
						FileOutputStream fos = null;
						try {
							fos = new FileOutputStream(getRuntimePropertiesFile());
							OpenmrsUtil.storeProperties(runtimeProperties, fos,
								"Auto generated by OpenMRS initialization wizard");
							wizardModel.workLog.add("Saved runtime properties file " + getRuntimePropertiesFile());
							
							/*
							 * Fix file readability permissions:
							 * first revoke read permission from everyone, then set read permissions for only the user
							 * there is no function to set specific readability for only one user
							 * and revoke everyone else's, therefore this is the only way to accomplish this.
							 */
							wizardModel.workLog.add("Adjusting file posix properties to user readonly");
							if (getRuntimePropertiesFile().setReadable(false, false)
								&& getRuntimePropertiesFile().setReadable(true)) {
								wizardModel.workLog
									.add("Successfully adjusted RuntimePropertiesFile to disallow world to read it");
							} else {
								wizardModel.workLog
									.add("Unable to adjust RuntimePropertiesFile to disallow world to read it");
							}
							// don't need to catch errors here because we tested it at the beginning of the wizard
						}
						finally {
							if (fos != null) {
								fos.close();
							}
						}
						
						Context.openSession();
						
						if (!"".equals(wizardModel.implementationId)) {
							try {
								Context.addProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
								Context.addProxyPrivilege(PrivilegeConstants.MANAGE_CONCEPT_SOURCES);
								Context.addProxyPrivilege(PrivilegeConstants.GET_CONCEPT_SOURCES);
								Context.addProxyPrivilege(PrivilegeConstants.MANAGE_IMPLEMENTATION_ID);
								
								ImplementationId implId = new ImplementationId();
								implId.setName(wizardModel.implementationIdName);
								implId.setImplementationId(wizardModel.implementationId);
								implId.setPassphrase(wizardModel.implementationIdPassPhrase);
								implId.setDescription(wizardModel.implementationIdDescription);
								
								Context.getAdministrationService().setImplementationId(implId);
							}
							catch (Exception e) {
								reportError(ErrorMessageConstants.ERROR_SET_INPL_ID, DEFAULT_PAGE, e.getMessage());
								log.warn("Implementation ID could not be set.", e);
								Context.shutdown();
								WebModuleUtil.shutdownModules(filterConfig.getServletContext());
								contextLoader.closeWebApplicationContext(filterConfig.getServletContext());
								return;
							}
							finally {
								Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
								Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_CONCEPT_SOURCES);
								Context.removeProxyPrivilege(PrivilegeConstants.GET_CONCEPT_SOURCES);
								Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_IMPLEMENTATION_ID);
							}
						}
						
						try {
							// change the admin user password from "test" to what they input above
							if (wizardModel.createTables) {
								try {
									Context.authenticate(new UsernamePasswordCredentials("admin", "test"));
									
									Properties props = Context.getRuntimeProperties();
									String initValue = props.getProperty(UserService.ADMIN_PASSWORD_LOCKED_PROPERTY);
									props.setProperty(UserService.ADMIN_PASSWORD_LOCKED_PROPERTY, "false");
									Context.setRuntimeProperties(props);
									
									Context.getUserService().changePassword("test", wizardModel.adminUserPassword);
									
									if (initValue == null) {
										props.remove(UserService.ADMIN_PASSWORD_LOCKED_PROPERTY);
									} else {
										props.setProperty(UserService.ADMIN_PASSWORD_LOCKED_PROPERTY, initValue);
									}
									Context.setRuntimeProperties(props);
									Context.logout();
								}
								catch (ContextAuthenticationException ex) {
									log.info("No need to change admin password.", ex);
								}
							}
						}
						catch (Exception e) {
							Context.shutdown();
							WebModuleUtil.shutdownModules(filterConfig.getServletContext());
							contextLoader.closeWebApplicationContext(filterConfig.getServletContext());
							reportError(ErrorMessageConstants.ERROR_COMPLETE_STARTUP, DEFAULT_PAGE, e.getMessage());
							log.warn("Unable to complete the startup.", e);
							return;
						}
						
						try {
							// Update PostgreSQL Sequences after insertion of core data
							Context.getAdministrationService().updatePostgresSequence();
						}
						catch (Exception e) {
							log.warn("Not able to update PostgreSQL sequence. Startup failed for PostgreSQL", e);
							reportError(ErrorMessageConstants.ERROR_COMPLETE_STARTUP, DEFAULT_PAGE, e.getMessage());
							return;
						}
						
						// set this so that the wizard isn't run again on next page load
						Context.closeSession();
						
						// start openmrs
						try {
							UpdateFilter.setUpdatesRequired(false);
							WebDaemon.startOpenmrs(filterConfig.getServletContext());
						}
						catch (DatabaseUpdateException updateEx) {
							log.warn("Error while running the database update file", updateEx);
							reportError(ErrorMessageConstants.ERROR_DB_UPDATE, DEFAULT_PAGE, updateEx.getMessage());
							return;
						}
						catch (InputRequiredException inputRequiredEx) {
							// TODO display a page looping over the required input and ask the user for each.
							// 		When done and the user and put in their say, call DatabaseUpdater.update(Map);
							//		with the user's question/answer pairs
							log.warn(
								"Unable to continue because user input is required for the db updates and we cannot do anything about that right now");
							reportError(ErrorMessageConstants.ERROR_INPUT_REQ, DEFAULT_PAGE);
							return;
						}
						catch (MandatoryModuleException mandatoryModEx) {
							log.warn(
								"A mandatory module failed to start. Fix the error or unmark it as mandatory to continue.",
								mandatoryModEx);
							reportError(ErrorMessageConstants.ERROR_MANDATORY_MOD_REQ, DEFAULT_PAGE,
								mandatoryModEx.getMessage());
							return;
						}
						catch (OpenmrsCoreModuleException coreModEx) {
							log.warn(
								"A core module failed to start. Make sure that all core modules (with the required minimum versions) are installed and starting properly.",
								coreModEx);
							reportError(ErrorMessageConstants.ERROR_CORE_MOD_REQ, DEFAULT_PAGE, coreModEx.getMessage());
							return;
						}
						
						// TODO catch openmrs errors here and drop the user back out to the setup screen
						
					}
					catch (IOException e) {
						reportError(ErrorMessageConstants.ERROR_COMPLETE_STARTUP, DEFAULT_PAGE, e.getMessage());
					}
					finally {
						if (!hasErrors()) {
							// set this so that the wizard isn't run again on next page load
							setInitializationComplete(true);
							// we should also try to store selected by user language
							// if user wants to system will do it for him 
							FilterUtil.storeLocale(wizardModel.localeToSave);
						}
						setInstallationStarted(false);
					}
				}
			};
			
			future = OpenmrsThreadPoolHolder.threadExecutor.submit(() -> { r.run(); return null; });
		}
	}
	
	/**
	 * Convenience method that loads the database driver
	 *
	 * @param connection the database connection string
	 * @param databaseDriver the database driver class name to load
	 * @return the loaded driver string
	 */
	public static String loadDriver(String connection, String databaseDriver) {
		String loadedDriverString = null;
		try {
			loadedDriverString = DatabaseUtil.loadDatabaseDriver(connection, databaseDriver);
			log.info("using database driver :" + loadedDriverString);
		}
		catch (ClassNotFoundException e) {
			log.error("The given database driver class was not found. "
				+ "Please ensure that the database driver jar file is on the class path "
				+ "(like in the webapp's lib folder)");
		}
		
		return loadedDriverString;
	}
	
	/**
	 * Utility method that checks if there is a runtime properties file containing database connection
	 * credentials
	 *
	 * @return
	 */
	private static boolean skipDatabaseSetupPage() {
		Properties props = OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME);
		return (props != null && StringUtils.hasText(props.getProperty("connection.url"))
			&& StringUtils.hasText(props.getProperty("connection.username"))
			&& StringUtils.hasText(props.getProperty("connection.password")));
	}
	
	/**
	 * Utility methods that checks if the user clicked the back image
	 *
	 * @param httpRequest
	 * @return
	 */
	private static boolean goBack(HttpServletRequest httpRequest) {
		return "Back".equals(httpRequest.getParameter("back"))
			|| (httpRequest.getParameter("back.x") != null && httpRequest.getParameter("back.y") != null);
	}
	
	/**
	 * Convenience method to get custom installation script
	 *
	 * @return Properties from custom installation script or empty if none specified
	 * @throws RuntimeException if path to installation script is invalid
	 */
	private Properties getInstallationScript() {
		Properties prop = new Properties();
		
		String fileName = System.getProperty("OPENMRS_INSTALLATION_SCRIPT");
		if (fileName == null) {
			return prop;
		}
		if (fileName.startsWith("classpath:")) {
			fileName = fileName.substring(10);
			InputStream input = null;
			try {
				input = getClass().getClassLoader().getResourceAsStream(fileName);
				prop.load(input);
				log.info("Using installation script from classpath: " + fileName);
				
				input.close();
			}
			catch (IOException ex) {
				log.error("Failed to load installation script from classpath: " + fileName, ex);
				throw new RuntimeException(ex);
			}
			finally {
				IOUtils.closeQuietly(input);
			}
		} else {
			File file = new File(fileName);
			if (file.exists()) {
				InputStream input = null;
				try {
					input = new FileInputStream(fileName);
					prop.load(input);
					log.info("Using installation script from absolute path: " + file.getAbsolutePath());
					
					input.close();
				}
				catch (IOException ex) {
					log.error("Failed to load installation script from absolute path: " + file.getAbsolutePath(), ex);
					throw new RuntimeException(ex);
				}
				finally {
					IOUtils.closeQuietly(input);
				}
			}
		}
		return prop;
	}
}
/**
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
 * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
 *
 * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
 * graphic logo is a trademark of OpenMRS Inc.
 */
package org.openmrs.propertyeditor;
import java.beans.PropertyEditorSupport;
import org.openmrs.Privilege;
import org.openmrs.api.UserService;
import org.openmrs.api.context.Context;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;
/**
 * Allows for serializing/deserializing an object to a string so that Spring knows how to pass
 * an object back and forth through an html form or other medium. <br>
 * <br>
 * In version 1.9, added ability for this to also retrieve objects by uuid
 *
 * @see Privilege
 */
public class PrivilegeEditor extends PropertyEditorSupport {
	
	private static final Logger log = LoggerFactory.getLogger(PrivilegeEditor.class);
	
	public PrivilegeEditor() {
	}
	
	/**
	 * <strong>Should</strong> set using name
	 * <strong>Should</strong> set using uuid
	 */
	@Override
	public void setAsText(String text) throws IllegalArgumentException {
		UserService es = Context.getUserService();
		if (StringUtils.hasText(text)) {
			try {
				Privilege p = es.getPrivilege(text);
				setValue(p);
				//when a privilege is not found, no exception is generated. throw one to execute the catch block
				if (p == null) {
					throw new Exception();
				}
			}
			catch (Exception ex) {
				Privilege p = es.getPrivilegeByUuid(text);
				setValue(p);
				if (p == null) {
					log.error("Error setting text: " + text, ex);
					throw new IllegalArgumentException("Privilege not found: " + ex.getMessage());
				}
			}
		} else {
			setValue(null);
		}
	}
	
	@Override
	public String getAsText() {
		Privilege p = (Privilege) getValue();
		if (p == null) {
			return "";
		} else {
			return p.getPrivilege();
		}
	}
	
}