package io.vavr.collection;
import io.vavr.PartialFunction;
import io.vavr.Tuple;
import io.vavr.Tuple2;
import io.vavr.Tuple3;
import io.vavr.collection.List.Nil;
import io.vavr.collection.Tree.*;
import io.vavr.control.Option;
import java.io.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.Collector;
import static io.vavr.collection.Tree.Order.PRE_ORDER;
import static io.vavr.collection.Tree.*;
public interface Tree<T> extends Traversable<T>, Serializable {
    long serialVersionUID = 1L;
    static <T> Collector<T, ArrayList<T>, Tree<T>> collector() {
        final Supplier<ArrayList<T>> supplier = ArrayList::new;
        final BiConsumer<ArrayList<T>, T> accumulator = ArrayList::add;
        final BinaryOperator<ArrayList<T>> combiner = (left, right) -> {
            left.addAll(right);
            return left;
        };
        final Function<ArrayList<T>, Tree<T>> finisher = Tree::ofAll;
        return Collector.of(supplier, accumulator, combiner, finisher);
    }
    static <T> Empty<T> empty() {
        return Empty.instance();
    }
    @SuppressWarnings("unchecked")
    static <T> Tree<T> narrow(Tree<? extends T> tree) {
        return (Tree<T>) tree;
    }
    static <T> Node<T> of(T value) {
        return new Node<>(value, io.vavr.collection.List.empty());
    }
    @SuppressWarnings("varargs")
    @SafeVarargs
    static <T> Node<T> of(T value, Node<T>... children) {
        Objects.requireNonNull(children, "children is null");
        return new Node<>(value, io.vavr.collection.List.of(children));
    }
    static <T> Node<T> of(T value, Iterable<Node<T>> children) {
        Objects.requireNonNull(children, "children is null");
        return new Node<>(value, io.vavr.collection.List.ofAll(children));
    }
    @SuppressWarnings("varargs")
    @SafeVarargs
    static <T> Tree<T> of(T... values) {
        Objects.requireNonNull(values, "values is null");
        final io.vavr.collection.List<T> list = io.vavr.collection.List.of(values);
        return list.isEmpty() ? Empty.instance() : new Node<>(list.head(), list.tail().map(Tree::of));
    }
    @SuppressWarnings("unchecked")
    static <T> Tree<T> ofAll(Iterable<? extends T> iterable) {
        Objects.requireNonNull(iterable, "iterable is null");
        if (iterable instanceof Tree) {
            return (Tree<T>) iterable;
        } else {
            final io.vavr.collection.List<T> list = io.vavr.collection.List.ofAll(iterable);
            return list.isEmpty() ? Empty.instance() : new Node<>(list.head(), list.tail().map(Tree::of));
        }
    }
    static <T> Tree<T> ofAll(java.util.stream.Stream<? extends T> javaStream) {
        Objects.requireNonNull(javaStream, "javaStream is null");
        return ofAll(io.vavr.collection.Iterator.ofAll(javaStream.iterator()));
    }
    static <T> Tree<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
        Objects.requireNonNull(f, "f is null");
        return io.vavr.collection.Collections.tabulate(n, f, empty(), Tree::of);
    }
    static <T> Tree<T> fill(int n, Supplier<? extends T> s) {
        Objects.requireNonNull(s, "s is null");
        return io.vavr.collection.Collections.fill(n, s, empty(), Tree::of);
    }
    static <T> Tree<T> fill(int n, T element) {
        return io.vavr.collection.Collections.fillObject(n, element, empty(), Tree::of);
    }
    static <T> Node<T> recurse(T seed, Function<? super T, ? extends Iterable<? extends T>> descend) {
        Objects.requireNonNull(descend, "descend is null");
        return Tree.of(seed, Stream.of(seed).flatMap(descend).map(children -> recurse(children, descend)));
    }
    static <T, ID> List<Node<T>> build(Iterable<? extends T> source, Function<? super T, ? extends ID> idMapper, Function<? super T, ? extends ID> parentMapper) {
        Objects.requireNonNull(source, "source is null");
        Objects.requireNonNull(source, "idMapper is null");
        Objects.requireNonNull(source, "parentMapper is null");
        final List<T> list = List.ofAll(source);
        final Map<ID, List<T>> byParent = list.groupBy(parentMapper);
        final Function<? super T, Iterable<? extends T>> descend = idMapper
                .andThen(byParent::get)
                .andThen(o -> o.getOrElse(List::empty));
        final List<T> roots = byParent.get(null).getOrElse(List::empty);
        return roots.map(v -> recurse(v, descend));
    }
    @Override
    default <R> Tree<R> collect(PartialFunction<? super T, ? extends R> partialFunction) {
        return ofAll(iterator().<R> collect(partialFunction));
    }
    T getValue();
    io.vavr.collection.List<Node<T>> getChildren();
    boolean isLeaf();
    default boolean isBranch() {
        return !(isEmpty() || isLeaf());
    }
    @Override
    default boolean isAsync() {
        return false;
    }
    @Override
    default boolean isDistinct() {
        return false;
    }
    @Override
    default boolean isLazy() {
        return false;
    }
    @Override
    default boolean isSequential() {
        return true;
    }
    default io.vavr.collection.Iterator<T> iterator(Order order) {
        return values(order).iterator();
    }
    String toLispString();
    default <U> U transform(Function<? super Tree<T>, ? extends U> f) {
        Objects.requireNonNull(f, "f is null");
        return f.apply(this);
    }
    default Seq<Node<T>> traverse() {
        return traverse(PRE_ORDER);
    }
    default Seq<Node<T>> traverse(Order order) {
        Objects.requireNonNull(order, "order is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            final Node<T> node = (Node<T>) this;
            switch (order) {
                case PRE_ORDER:
                    return TreeModule.traversePreOrder(node);
                case IN_ORDER:
                    return TreeModule.traverseInOrder(node);
                case POST_ORDER:
                    return TreeModule.traversePostOrder(node);
                case LEVEL_ORDER:
                    return TreeModule.traverseLevelOrder(node);
                default:
                    throw new IllegalStateException("Unknown order: " + order.name());
            }
        }
    }
    default Seq<T> values() {
        return traverse(PRE_ORDER).map(Node::getValue);
    }
    default Seq<T> values(Order order) {
        return traverse(order).map(Node::getValue);
    }
    default int branchCount() {
        if (isEmpty() || isLeaf()) {
            return 0;
        } else {
            return getChildren().foldLeft(1, (count, child) -> count + child.branchCount());
        }
    }
    default int leafCount() {
        if (isEmpty()) {
            return 0;
        } else if (isLeaf()) {
            return 1;
        } else {
            return getChildren().foldLeft(0, (count, child) -> count + child.leafCount());
        }
    }
    default int nodeCount() {
        return length();
    }
    @Override
    default Seq<T> distinct() {
        return values().distinct();
    }
    @Override
    default Seq<T> distinctBy(Comparator<? super T> comparator) {
        Objects.requireNonNull(comparator, "comparator is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().distinctBy(comparator);
        }
    }
    @Override
    default <U> Seq<T> distinctBy(Function<? super T, ? extends U> keyExtractor) {
        Objects.requireNonNull(keyExtractor, "keyExtractor is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().distinctBy(keyExtractor);
        }
    }
    @Override
    default Seq<T> drop(int n) {
        if (n >= length()) {
            return Stream.empty();
        } else {
            return values().drop(n);
        }
    }
    @Override
    default Seq<T> dropRight(int n) {
        if (n >= length()) {
            return Stream.empty();
        } else {
            return values().dropRight(n);
        }
    }
    @Override
    default Seq<T> dropUntil(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        return dropWhile(predicate.negate());
    }
    @Override
    default Seq<T> dropWhile(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().dropWhile(predicate);
        }
    }
    @Override
    default Seq<T> filter(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().filter(predicate);
        }
    }
    @Override
    default Seq<T> reject(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().reject(predicate);
        }
    }
    @Override
    default <U> Tree<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper) {
        Objects.requireNonNull(mapper, "mapper is null");
        return isEmpty() ? Empty.instance() : TreeModule.flatMap((Node<T>) this, mapper);
    }
    @Override
    default <U> U foldRight(U zero, BiFunction<? super T, ? super U, ? extends U> f) {
        Objects.requireNonNull(f, "f is null");
        if (isEmpty()) {
            return zero;
        } else {
            return iterator().foldRight(zero, f);
        }
    }
    @SuppressWarnings("unchecked")
    @Override
    default <C> Map<C, Seq<T>> groupBy(Function<? super T, ? extends C> classifier) {
        return io.vavr.collection.Collections.groupBy(values(), classifier, Stream::ofAll);
    }
    @Override
    default io.vavr.collection.Iterator<Seq<T>> grouped(int size) {
        return sliding(size, size);
    }
    @Override
    default boolean hasDefiniteSize() {
        return true;
    }
    @Override
    default T head() {
        if (isEmpty()) {
            throw new NoSuchElementException("head of empty tree");
        } else {
            return iterator().next();
        }
    }
    @Override
    default Seq<T> init() {
        if (isEmpty()) {
            throw new UnsupportedOperationException("init of empty tree");
        } else {
            return values().init();
        }
    }
    @Override
    default Option<Seq<T>> initOption() {
        return isEmpty() ? Option.none() : Option.some(init());
    }
    @Override
    default boolean isTraversableAgain() {
        return true;
    }
    @Override
    default io.vavr.collection.Iterator<T> iterator() {
        return values().iterator();
    }
    @Override
    default <U> Tree<U> map(Function<? super T, ? extends U> mapper) {
        Objects.requireNonNull(mapper, "mapper is null");
        return isEmpty() ? Empty.instance() : TreeModule.map((Node<T>) this, mapper);
    }
    @Override
    default Tree<T> orElse(Iterable<? extends T> other) {
        return isEmpty() ? ofAll(other) : this;
    }
    @Override
    default Tree<T> orElse(Supplier<? extends Iterable<? extends T>> supplier) {
        return isEmpty() ? ofAll(supplier.get()) : this;
    }
    @SuppressWarnings("unchecked")
    @Override
    default Tuple2<Seq<T>, Seq<T>> partition(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        if (isEmpty()) {
            return Tuple.of(Stream.empty(), Stream.empty());
        } else {
            return (Tuple2<Seq<T>, Seq<T>>) values().partition(predicate);
        }
    }
    @Override
    default Tree<T> peek(Consumer<? super T> action) {
        Objects.requireNonNull(action, "action is null");
        if (!isEmpty()) {
            action.accept(head());
        }
        return this;
    }
    @Override
    default Tree<T> replace(T currentElement, T newElement) {
        if (isEmpty()) {
            return Empty.instance();
        } else {
            return TreeModule.replace((Node<T>) this, currentElement, newElement);
        }
    }
    @Override
    default Tree<T> replaceAll(T currentElement, T newElement) {
        return map(t -> Objects.equals(t, currentElement) ? newElement : t);
    }
    @Override
    default Seq<T> retainAll(Iterable<? extends T> elements) {
        Objects.requireNonNull(elements, "elements is null");
        return values().retainAll(elements);
    }
    @Override
    default Seq<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
        return scanLeft(zero, operation);
    }
    @Override
    default <U> Seq<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation) {
        return io.vavr.collection.Collections.scanLeft(this, zero, operation, io.vavr.collection.Iterator::toStream);
    }
    @Override
    default <U> Seq<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
        return io.vavr.collection.Collections.scanRight(this, zero, operation, io.vavr.collection.Iterator::toStream);
    }
    @Override
    default io.vavr.collection.Iterator<Seq<T>> slideBy(Function<? super T, ?> classifier) {
        return iterator().slideBy(classifier);
    }
    @Override
    default io.vavr.collection.Iterator<Seq<T>> sliding(int size) {
        return sliding(size, 1);
    }
    @Override
    default io.vavr.collection.Iterator<Seq<T>> sliding(int size, int step) {
        return iterator().sliding(size, step);
    }
    @SuppressWarnings("unchecked")
    @Override
    default Tuple2<Seq<T>, Seq<T>> span(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        if (isEmpty()) {
            return Tuple.of(Stream.empty(), Stream.empty());
        } else {
            return (Tuple2<Seq<T>, Seq<T>>) values().span(predicate);
        }
    }
    @Override
    default String stringPrefix() {
        return "Tree";
    }
    @Override
    default Seq<T> tail() {
        if (isEmpty()) {
            throw new UnsupportedOperationException("tail of empty tree");
        } else {
            return values().tail();
        }
    }
    @Override
    default Option<Seq<T>> tailOption() {
        return isEmpty() ? Option.none() : Option.some(tail());
    }
    @Override
    default Seq<T> take(int n) {
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().take(n);
        }
    }
    @Override
    default Seq<T> takeRight(int n) {
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().takeRight(n);
        }
    }
    @Override
    default Seq<T> takeUntil(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        return values().takeUntil(predicate);
    }
    @Override
    default Seq<T> takeWhile(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        return values().takeWhile(predicate);
    }
    @SuppressWarnings("unchecked")
    @Override
    default <T1, T2> Tuple2<Tree<T1>, Tree<T2>> unzip(
            Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper) {
        Objects.requireNonNull(unzipper, "unzipper is null");
        if (isEmpty()) {
            return Tuple.of(Empty.instance(), Empty.instance());
        } else {
            return (Tuple2<Tree<T1>, Tree<T2>>) (Object) TreeModule.unzip((Node<T>) this, unzipper);
        }
    }
    @SuppressWarnings("unchecked")
    @Override
    default <T1, T2, T3> Tuple3<Tree<T1>, Tree<T2>, Tree<T3>> unzip3(
            Function<? super T, Tuple3<? extends T1, ? extends T2, ? extends T3>> unzipper) {
        Objects.requireNonNull(unzipper, "unzipper is null");
        if (isEmpty()) {
            return Tuple.of(Empty.instance(), Empty.instance(), Empty.instance());
        } else {
            return (Tuple3<Tree<T1>, Tree<T2>, Tree<T3>>) (Object) TreeModule.unzip3((Node<T>) this, unzipper);
        }
    }
    @Override
    default <U> Tree<Tuple2<T, U>> zip(Iterable<? extends U> that) {
        return zipWith(that, Tuple::of);
    }
    @Override
    default <U, R> Tree<R> zipWith(Iterable<? extends U> that, BiFunction<? super T, ? super U, ? extends R> mapper) {
        Objects.requireNonNull(that, "that is null");
        Objects.requireNonNull(mapper, "mapper is null");
        if (isEmpty()) {
            return Empty.instance();
        } else {
            return TreeModule.zip((Node<T>) this, that.iterator(), mapper);
        }
    }
    @Override
    default <U> Tree<Tuple2<T, U>> zipAll(Iterable<? extends U> that, T thisElem, U thatElem) {
        Objects.requireNonNull(that, "that is null");
        if (isEmpty()) {
            return io.vavr.collection.Iterator.<U> ofAll(that).map(elem -> Tuple.of(thisElem, elem)).toTree();
        } else {
            final java.util.Iterator<? extends U> thatIter = that.iterator();
            final Tree<Tuple2<T, U>> tree = TreeModule.zipAll((Node<T>) this, thatIter, thatElem);
            if (thatIter.hasNext()) {
                final Iterable<Node<Tuple2<T, U>>> remainder = io.vavr.collection.Iterator
                        .ofAll(thatIter)
                        .map(elem -> of(Tuple.of(thisElem, elem)));
                return new Node<>(tree.getValue(), tree.getChildren().appendAll(remainder));
            } else {
                return tree;
            }
        }
    }
    @Override
    default Tree<Tuple2<T, Integer>> zipWithIndex() {
        return zipWithIndex(Tuple::of);
    }
    @Override
    default <U> Tree<U> zipWithIndex(BiFunction<? super T, ? super Integer, ? extends U> mapper) {
        Objects.requireNonNull(mapper, "mapper is null");
        return zipWith(io.vavr.collection.Iterator.from(0), mapper);
    }
    @Override
    boolean equals(Object o);
    @Override
    int hashCode();
    @Override
    String toString();
    String draw();
    final class Node<T> implements Tree<T>, Serializable {
        private static final long serialVersionUID = 1L;
        @SuppressWarnings("serial") 
        private final T value;
        private final io.vavr.collection.List<Node<T>> children;
        private final int size;
        public Node(T value, io.vavr.collection.List<Node<T>> children) {
            Objects.requireNonNull(children, "children is null");
            this.value = value;
            this.children = children;
            this.size = children.foldLeft(1, (acc, child) -> acc + child.size);
        }
        @Override
        public io.vavr.collection.List<Node<T>> getChildren() {
            return children;
        }
        @Override
        public T getValue() {
            return value;
        }
        @Override
        public boolean isEmpty() {
            return false;
        }
        @Override
        public int length() {
            return size;
        }
        @Override
        public boolean isLeaf() {
            return size == 1;
        }
        @Override
        public T last() {
            return children.isEmpty() ? value : children.last().last();
        }
        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof Node) {
                final Node<?> that = (Node<?>) o;
                return Objects.equals(this.getValue(), that.getValue())
                        && Objects.equals(this.getChildren(), that.getChildren());
            } else {
                return false;
            }
        }
        @Override
        public int hashCode() {
            return Tuple.hash(value, children);
        }
        @Override
        public String toString() {
            return mkString(stringPrefix() + "(", ", ", ")");
        }
        @Override
        public String toLispString() {
            return toLispString(this);
        }
        @Override
        public String draw() {
            final StringBuilder builder = new StringBuilder();
            drawAux("", builder);
            return builder.toString();
        }
        private void drawAux(String indent, StringBuilder builder) {
            builder.append(value);
            for (io.vavr.collection.List<Node<T>> it = children; !it.isEmpty(); it = it.tail()) {
                final boolean isLast = it.tail().isEmpty();
                builder.append('\n')
                        .append(indent)
                        .append(isLast ? "└──" : "├──");
                it.head().drawAux(indent + (isLast ? "   " : "│  "), builder);
            }
        }
        private static String toLispString(Tree<?> tree) {
            final String value = String.valueOf(tree.getValue());
            if (tree.isLeaf()) {
                return value;
            } else {
                final String children = tree.getChildren().map(child -> toLispString(child)).mkString(" ");
                return "(" + value + " " + children + ")";
            }
        }
        @GwtIncompatible("The Java serialization protocol is explicitly not supported")
        private Object writeReplace() {
            return new SerializationProxy<>(this);
        }
        @GwtIncompatible("The Java serialization protocol is explicitly not supported")
        private void readObject(ObjectInputStream stream) throws InvalidObjectException {
            throw new InvalidObjectException("Proxy required");
        }
        @GwtIncompatible("The Java serialization protocol is explicitly not supported")
        private static final class SerializationProxy<T> implements Serializable {
            private static final long serialVersionUID = 1L;
            private transient Node<T> node;
            SerializationProxy(Node<T> node) {
                this.node = node;
            }
            private void writeObject(ObjectOutputStream s) throws IOException {
                s.defaultWriteObject();
                s.writeObject(node.value);
                s.writeObject(node.children);
            }
            @SuppressWarnings("unchecked")
            private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {
                s.defaultReadObject();
                final T value = (T) s.readObject();
                final io.vavr.collection.List<Node<T>> children = (io.vavr.collection.List<Node<T>>) s.readObject();
                node = new Node<>(value, children);
            }
            private Object readResolve() {
                return node;
            }
        }
    }
    final class Empty<T> implements Tree<T>, Serializable {
        private static final long serialVersionUID = 1L;
        private static final Empty<?> INSTANCE = new Empty<>();
        private Empty() {
        }
        @SuppressWarnings("unchecked")
        public static <T> Empty<T> instance() {
            return (Empty<T>) INSTANCE;
        }
        @Override
        public io.vavr.collection.List<Node<T>> getChildren() {
            return Nil.instance();
        }
        @Override
        public T getValue() {
            throw new UnsupportedOperationException("getValue of empty Tree");
        }
        @Override
        public boolean isEmpty() {
            return true;
        }
        @Override
        public int length() {
            return 0;
        }
        @Override
        public boolean isLeaf() {
            return false;
        }
        @Override
        public T last() {
            throw new NoSuchElementException("last of empty tree");
        }
        @Override
        public boolean equals(Object o) {
            return o == this;
        }
        @Override
        public int hashCode() {
            return 1;
        }
        @Override
        public String toString() {
            return stringPrefix() + "()";
        }
        @Override
        public String toLispString() {
            return "()";
        }
        @Override
        public String draw() { return "▣"; }
        private Object readResolve() {
            return INSTANCE;
        }
    }
    enum Order {
        PRE_ORDER,
        IN_ORDER,
        POST_ORDER,
        LEVEL_ORDER
    }
}
interface TreeModule {
    @SuppressWarnings("unchecked")
    static <T, U> Tree<U> flatMap(Node<T> node, Function<? super T, ? extends Iterable<? extends U>> mapper) {
        final Tree<U> mapped = ofAll(mapper.apply(node.getValue()));
        if (mapped.isEmpty()) {
            return empty();
        } else {
            final io.vavr.collection.List<Node<U>> children = (io.vavr.collection.List<Node<U>>) (Object) node
                    .getChildren()
                    .map(child -> flatMap(child, mapper))
                    .filter(Tree::nonEmpty);
            return of(mapped.get(), children.prependAll(mapped.getChildren()));
        }
    }
    static <T, U> Node<U> map(Node<T> node, Function<? super T, ? extends U> mapper) {
        final U value = mapper.apply(node.getValue());
        final io.vavr.collection.List<Node<U>> children = node.getChildren().map(child -> map(child, mapper));
        return new Node<>(value, children);
    }
    static <T> Node<T> replace(Node<T> node, T currentElement, T newElement) {
        if (Objects.equals(node.getValue(), currentElement)) {
            return new Node<>(newElement, node.getChildren());
        } else {
            for (Node<T> child : node.getChildren()) {
                final Node<T> newChild = replace(child, currentElement, newElement);
                final boolean found = newChild != child;
                if (found) {
                    final io.vavr.collection.List<Node<T>> newChildren = node.getChildren().replace(child, newChild);
                    return new Node<>(node.getValue(), newChildren);
                }
            }
            return node;
        }
    }
    static <T> Stream<Node<T>> traversePreOrder(Node<T> node) {
        return node.getChildren().foldLeft(Stream.of(node),
                (acc, child) -> acc.appendAll(traversePreOrder(child)));
    }
    static <T> Stream<Node<T>> traverseInOrder(Node<T> node) {
        if (node.isLeaf()) {
            return Stream.of(node);
        } else {
            final io.vavr.collection.List<Node<T>> children = node.getChildren();
            return children
                    .tail()
                    .foldLeft(Stream.<Node<T>> empty(), (acc, child) -> acc.appendAll(traverseInOrder(child)))
                    .prepend(node)
                    .prependAll(traverseInOrder(children.head()));
        }
    }
    static <T> Stream<Node<T>> traversePostOrder(Node<T> node) {
        return node
                .getChildren()
                .foldLeft(Stream.<Node<T>> empty(), (acc, child) -> acc.appendAll(traversePostOrder(child)))
                .append(node);
    }
    static <T> Stream<Node<T>> traverseLevelOrder(Node<T> node) {
        Stream<Node<T>> result = Stream.empty();
        final java.util.Queue<Node<T>> queue = new java.util.LinkedList<>();
        queue.add(node);
        while (!queue.isEmpty()) {
            final Node<T> next = queue.remove();
            result = result.prepend(next);
            queue.addAll(next.getChildren().toJavaList());
        }
        return result.reverse();
    }
    static <T, T1, T2> Tuple2<Node<T1>, Node<T2>> unzip(Node<T> node,
            Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper) {
        final Tuple2<? extends T1, ? extends T2> value = unzipper.apply(node.getValue());
        final io.vavr.collection.List<Tuple2<Node<T1>, Node<T2>>> children = node
                .getChildren()
                .map(child -> unzip(child, unzipper));
        final Node<T1> node1 = new Node<>(value._1, children.map(t -> t._1));
        final Node<T2> node2 = new Node<>(value._2, children.map(t -> t._2));
        return Tuple.of(node1, node2);
    }
    static <T, T1, T2, T3> Tuple3<Node<T1>, Node<T2>, Node<T3>> unzip3(Node<T> node,
            Function<? super T, Tuple3<? extends T1, ? extends T2, ? extends T3>> unzipper) {
        final Tuple3<? extends T1, ? extends T2, ? extends T3> value = unzipper.apply(node.getValue());
        final io.vavr.collection.List<Tuple3<Node<T1>, Node<T2>, Node<T3>>> children = node.getChildren()
                .map(child -> unzip3(child, unzipper));
        final Node<T1> node1 = new Node<>(value._1, children.map(t -> t._1));
        final Node<T2> node2 = new Node<>(value._2, children.map(t -> t._2));
        final Node<T3> node3 = new Node<>(value._3, children.map(t -> t._3));
        return Tuple.of(node1, node2, node3);
    }
    @SuppressWarnings("unchecked")
    static <T, U, R> Tree<R> zip(Node<T> node, java.util.Iterator<? extends U> that, BiFunction<? super T, ? super U, ? extends R> mapper) {
        if (!that.hasNext()) {
            return Empty.instance();
        } else {
            final R value = mapper.apply(node.getValue(), that.next());
            final io.vavr.collection.List<Node<R>> children = (io.vavr.collection.List<Node<R>>) (Object) node
                    .getChildren()
                    .map(child -> zip(child, that, mapper))
                    .filter(Tree::nonEmpty);
            return new Node<>(value, children);
        }
    }
    @SuppressWarnings("unchecked")
    static <T, U> Tree<Tuple2<T, U>> zipAll(Node<T> node, java.util.Iterator<? extends U> that, U thatElem) {
        if (!that.hasNext()) {
            return node.map(value -> Tuple.of(value, thatElem));
        } else {
            final Tuple2<T, U> value = Tuple.of(node.getValue(), that.next());
            final io.vavr.collection.List<Node<Tuple2<T, U>>> children = (io.vavr.collection.List<Node<Tuple2<T, U>>>) (Object) node
                    .getChildren()
                    .map(child -> zipAll(child, that, thatElem))
                    .filter(Tree::nonEmpty);
            return new Node<>(value, children);
        }
    }
}
package io.vavr.collection;
import io.vavr.PartialFunction;
import io.vavr.Tuple;
import io.vavr.Tuple2;
import io.vavr.Tuple3;
import io.vavr.collection.List.Nil;
import io.vavr.collection.Tree.*;
import io.vavr.control.Option;
import java.io.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.Collector;
import static io.vavr.collection.Tree.Order.PRE_ORDER;
import static io.vavr.collection.Tree.*;
public interface Tree<T> extends Traversable<T>, Serializable {
    long serialVersionUID = 1L;
    static <T> Collector<T, ArrayList<T>, Tree<T>> collector() {
        final Supplier<ArrayList<T>> supplier = ArrayList::new;
        final BiConsumer<ArrayList<T>, T> accumulator = ArrayList::add;
        final BinaryOperator<ArrayList<T>> combiner = (left, right) -> {
            left.addAll(right);
            return left;
        };
        final Function<ArrayList<T>, Tree<T>> finisher = Tree::ofAll;
        return Collector.of(supplier, accumulator, combiner, finisher);
    }
    static <T> Empty<T> empty() {
        return Empty.instance();
    }
    @SuppressWarnings("unchecked")
    static <T> Tree<T> narrow(Tree<? extends T> tree) {
        return (Tree<T>) tree;
    }
    static <T> Node<T> of(T value) {
        return new Node<>(value, io.vavr.collection.List.empty());
    }
    @SuppressWarnings("varargs")
    @SafeVarargs
    static <T> Node<T> of(T value, Node<T>... children) {
        Objects.requireNonNull(children, "children is null");
        return new Node<>(value, io.vavr.collection.List.of(children));
    }
    static <T> Node<T> of(T value, Iterable<Node<T>> children) {
        Objects.requireNonNull(children, "children is null");
        return new Node<>(value, io.vavr.collection.List.ofAll(children));
    }
    @SuppressWarnings("varargs")
    @SafeVarargs
    static <T> Tree<T> of(T... values) {
        Objects.requireNonNull(values, "values is null");
        final io.vavr.collection.List<T> list = io.vavr.collection.List.of(values);
        return list.isEmpty() ? Empty.instance() : new Node<>(list.head(), list.tail().map(Tree::of));
    }
    @SuppressWarnings("unchecked")
    static <T> Tree<T> ofAll(Iterable<? extends T> iterable) {
        Objects.requireNonNull(iterable, "iterable is null");
        if (iterable instanceof Tree) {
            return (Tree<T>) iterable;
        } else {
            final io.vavr.collection.List<T> list = io.vavr.collection.List.ofAll(iterable);
            return list.isEmpty() ? Empty.instance() : new Node<>(list.head(), list.tail().map(Tree::of));
        }
    }
    static <T> Tree<T> ofAll(java.util.stream.Stream<? extends T> javaStream) {
        Objects.requireNonNull(javaStream, "javaStream is null");
        return ofAll(io.vavr.collection.Iterator.ofAll(javaStream.iterator()));
    }
    static <T> Tree<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
        Objects.requireNonNull(f, "f is null");
        return io.vavr.collection.Collections.tabulate(n, f, empty(), Tree::of);
    }
    static <T> Tree<T> fill(int n, Supplier<? extends T> s) {
        Objects.requireNonNull(s, "s is null");
        return io.vavr.collection.Collections.fill(n, s, empty(), Tree::of);
    }
    static <T> Tree<T> fill(int n, T element) {
        return io.vavr.collection.Collections.fillObject(n, element, empty(), Tree::of);
    }
    static <T> Node<T> recurse(T seed, Function<? super T, ? extends Iterable<? extends T>> descend) {
        Objects.requireNonNull(descend, "descend is null");
        return Tree.of(seed, Stream.of(seed).flatMap(descend).map(children -> recurse(children, descend)));
    }
    static <T, ID> List<Node<T>> build(Iterable<? extends T> source, Function<? super T, ? extends ID> idMapper, Function<? super T, ? extends ID> parentMapper) {
        Objects.requireNonNull(source, "source is null");
        Objects.requireNonNull(source, "idMapper is null");
        Objects.requireNonNull(source, "parentMapper is null");
        final List<T> list = List.ofAll(source);
        final Map<ID, List<T>> byParent = list.groupBy(parentMapper);
        final Function<? super T, Iterable<? extends T>> descend = idMapper
                .andThen(byParent::get)
                .andThen(o -> o.getOrElse(List::empty));
        final List<T> roots = byParent.get(null).getOrElse(List::empty);
        return roots.map(v -> recurse(v, descend));
    }
    @Override
    default <R> Tree<R> collect(PartialFunction<? super T, ? extends R> partialFunction) {
        return ofAll(iterator().<R> collect(partialFunction));
    }
    T getValue();
    io.vavr.collection.List<Node<T>> getChildren();
    boolean isLeaf();
    default boolean isBranch() {
        return !(isEmpty() || isLeaf());
    }
    @Override
    default boolean isAsync() {
        return false;
    }
    @Override
    default boolean isDistinct() {
        return false;
    }
    @Override
    default boolean isLazy() {
        return false;
    }
    @Override
    default boolean isSequential() {
        return true;
    }
    default io.vavr.collection.Iterator<T> iterator(Order order) {
        return values(order).iterator();
    }
    String toLispString();
    default <U> U transform(Function<? super Tree<T>, ? extends U> f) {
        Objects.requireNonNull(f, "f is null");
        return f.apply(this);
    }
    default Seq<Node<T>> traverse() {
        return traverse(PRE_ORDER);
    }
    default Seq<Node<T>> traverse(Order order) {
        Objects.requireNonNull(order, "order is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            final Node<T> node = (Node<T>) this;
            switch (order) {
                case PRE_ORDER:
                    return TreeModule.traversePreOrder(node);
                case IN_ORDER:
                    return TreeModule.traverseInOrder(node);
                case POST_ORDER:
                    return TreeModule.traversePostOrder(node);
                case LEVEL_ORDER:
                    return TreeModule.traverseLevelOrder(node);
                default:
                    throw new IllegalStateException("Unknown order: " + order.name());
            }
        }
    }
    default Seq<T> values() {
        return traverse(PRE_ORDER).map(Node::getValue);
    }
    default Seq<T> values(Order order) {
        return traverse(order).map(Node::getValue);
    }
    default int branchCount() {
        if (isEmpty() || isLeaf()) {
            return 0;
        } else {
            return getChildren().foldLeft(1, (count, child) -> count + child.branchCount());
        }
    }
    default int leafCount() {
        if (isEmpty()) {
            return 0;
        } else if (isLeaf()) {
            return 1;
        } else {
            return getChildren().foldLeft(0, (count, child) -> count + child.leafCount());
        }
    }
    default int nodeCount() {
        return length();
    }
    @Override
    default Seq<T> distinct() {
        return values().distinct();
    }
    @Override
    default Seq<T> distinctBy(Comparator<? super T> comparator) {
        Objects.requireNonNull(comparator, "comparator is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().distinctBy(comparator);
        }
    }
    @Override
    default <U> Seq<T> distinctBy(Function<? super T, ? extends U> keyExtractor) {
        Objects.requireNonNull(keyExtractor, "keyExtractor is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().distinctBy(keyExtractor);
        }
    }
    @Override
    default Seq<T> drop(int n) {
        if (n >= length()) {
            return Stream.empty();
        } else {
            return values().drop(n);
        }
    }
    @Override
    default Seq<T> dropRight(int n) {
        if (n >= length()) {
            return Stream.empty();
        } else {
            return values().dropRight(n);
        }
    }
    @Override
    default Seq<T> dropUntil(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        return dropWhile(predicate.negate());
    }
    @Override
    default Seq<T> dropWhile(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().dropWhile(predicate);
        }
    }
    @Override
    default Seq<T> filter(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().filter(predicate);
        }
    }
    @Override
    default Seq<T> reject(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().reject(predicate);
        }
    }
    @Override
    default <U> Tree<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper) {
        Objects.requireNonNull(mapper, "mapper is null");
        return isEmpty() ? Empty.instance() : TreeModule.flatMap((Node<T>) this, mapper);
    }
    @Override
    default <U> U foldRight(U zero, BiFunction<? super T, ? super U, ? extends U> f) {
        Objects.requireNonNull(f, "f is null");
        if (isEmpty()) {
            return zero;
        } else {
            return iterator().foldRight(zero, f);
        }
    }
    @SuppressWarnings("unchecked")
    @Override
    default <C> Map<C, Seq<T>> groupBy(Function<? super T, ? extends C> classifier) {
        return io.vavr.collection.Collections.groupBy(values(), classifier, Stream::ofAll);
    }
    @Override
    default io.vavr.collection.Iterator<Seq<T>> grouped(int size) {
        return sliding(size, size);
    }
    @Override
    default boolean hasDefiniteSize() {
        return true;
    }
    @Override
    default T head() {
        if (isEmpty()) {
            throw new NoSuchElementException("head of empty tree");
        } else {
            return iterator().next();
        }
    }
    @Override
    default Seq<T> init() {
        if (isEmpty()) {
            throw new UnsupportedOperationException("init of empty tree");
        } else {
            return values().init();
        }
    }
    @Override
    default Option<Seq<T>> initOption() {
        return isEmpty() ? Option.none() : Option.some(init());
    }
    @Override
    default boolean isTraversableAgain() {
        return true;
    }
    @Override
    default io.vavr.collection.Iterator<T> iterator() {
        return values().iterator();
    }
    @Override
    default <U> Tree<U> map(Function<? super T, ? extends U> mapper) {
        Objects.requireNonNull(mapper, "mapper is null");
        return isEmpty() ? Empty.instance() : TreeModule.map((Node<T>) this, mapper);
    }
    @Override
    default Tree<T> orElse(Iterable<? extends T> other) {
        return isEmpty() ? ofAll(other) : this;
    }
    @Override
    default Tree<T> orElse(Supplier<? extends Iterable<? extends T>> supplier) {
        return isEmpty() ? ofAll(supplier.get()) : this;
    }
    @SuppressWarnings("unchecked")
    @Override
    default Tuple2<Seq<T>, Seq<T>> partition(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        if (isEmpty()) {
            return Tuple.of(Stream.empty(), Stream.empty());
        } else {
            return (Tuple2<Seq<T>, Seq<T>>) values().partition(predicate);
        }
    }
    @Override
    default Tree<T> peek(Consumer<? super T> action) {
        Objects.requireNonNull(action, "action is null");
        if (!isEmpty()) {
            action.accept(head());
        }
        return this;
    }
    @Override
    default Tree<T> replace(T currentElement, T newElement) {
        if (isEmpty()) {
            return Empty.instance();
        } else {
            return TreeModule.replace((Node<T>) this, currentElement, newElement);
        }
    }
    @Override
    default Tree<T> replaceAll(T currentElement, T newElement) {
        return map(t -> Objects.equals(t, currentElement) ? newElement : t);
    }
    @Override
    default Seq<T> retainAll(Iterable<? extends T> elements) {
        Objects.requireNonNull(elements, "elements is null");
        return values().retainAll(elements);
    }
    @Override
    default Seq<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
        return scanLeft(zero, operation);
    }
    @Override
    default <U> Seq<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation) {
        return io.vavr.collection.Collections.scanLeft(this, zero, operation, io.vavr.collection.Iterator::toStream);
    }
    @Override
    default <U> Seq<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
        return io.vavr.collection.Collections.scanRight(this, zero, operation, io.vavr.collection.Iterator::toStream);
    }
    @Override
    default io.vavr.collection.Iterator<Seq<T>> slideBy(Function<? super T, ?> classifier) {
        return iterator().slideBy(classifier);
    }
    @Override
    default io.vavr.collection.Iterator<Seq<T>> sliding(int size) {
        return sliding(size, 1);
    }
    @Override
    default io.vavr.collection.Iterator<Seq<T>> sliding(int size, int step) {
        return iterator().sliding(size, step);
    }
    @SuppressWarnings("unchecked")
    @Override
    default Tuple2<Seq<T>, Seq<T>> span(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        if (isEmpty()) {
            return Tuple.of(Stream.empty(), Stream.empty());
        } else {
            return (Tuple2<Seq<T>, Seq<T>>) values().span(predicate);
        }
    }
    @Override
    default String stringPrefix() {
        return "Tree";
    }
    @Override
    default Seq<T> tail() {
        if (isEmpty()) {
            throw new UnsupportedOperationException("tail of empty tree");
        } else {
            return values().tail();
        }
    }
    @Override
    default Option<Seq<T>> tailOption() {
        return isEmpty() ? Option.none() : Option.some(tail());
    }
    @Override
    default Seq<T> take(int n) {
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().take(n);
        }
    }
    @Override
    default Seq<T> takeRight(int n) {
        if (isEmpty()) {
            return Stream.empty();
        } else {
            return values().takeRight(n);
        }
    }
    @Override
    default Seq<T> takeUntil(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        return values().takeUntil(predicate);
    }
    @Override
    default Seq<T> takeWhile(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
        return values().takeWhile(predicate);
    }
    @SuppressWarnings("unchecked")
    @Override
    default <T1, T2> Tuple2<Tree<T1>, Tree<T2>> unzip(
            Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper) {
        Objects.requireNonNull(unzipper, "unzipper is null");
        if (isEmpty()) {
            return Tuple.of(Empty.instance(), Empty.instance());
        } else {
            return (Tuple2<Tree<T1>, Tree<T2>>) (Object) TreeModule.unzip((Node<T>) this, unzipper);
        }
    }
    @SuppressWarnings("unchecked")
    @Override
    default <T1, T2, T3> Tuple3<Tree<T1>, Tree<T2>, Tree<T3>> unzip3(
            Function<? super T, Tuple3<? extends T1, ? extends T2, ? extends T3>> unzipper) {
        Objects.requireNonNull(unzipper, "unzipper is null");
        if (isEmpty()) {
            return Tuple.of(Empty.instance(), Empty.instance(), Empty.instance());
        } else {
            return (Tuple3<Tree<T1>, Tree<T2>, Tree<T3>>) (Object) TreeModule.unzip3((Node<T>) this, unzipper);
        }
    }
    @Override
    default <U> Tree<Tuple2<T, U>> zip(Iterable<? extends U> that) {
        return zipWith(that, Tuple::of);
    }
    @Override
    default <U, R> Tree<R> zipWith(Iterable<? extends U> that, BiFunction<? super T, ? super U, ? extends R> mapper) {
        Objects.requireNonNull(that, "that is null");
        Objects.requireNonNull(mapper, "mapper is null");
        if (isEmpty()) {
            return Empty.instance();
        } else {
            return TreeModule.zip((Node<T>) this, that.iterator(), mapper);
        }
    }
    @Override
    default <U> Tree<Tuple2<T, U>> zipAll(Iterable<? extends U> that, T thisElem, U thatElem) {
        Objects.requireNonNull(that, "that is null");
        if (isEmpty()) {
            return io.vavr.collection.Iterator.<U> ofAll(that).map(elem -> Tuple.of(thisElem, elem)).toTree();
        } else {
            final java.util.Iterator<? extends U> thatIter = that.iterator();
            final Tree<Tuple2<T, U>> tree = TreeModule.zipAll((Node<T>) this, thatIter, thatElem);
            if (thatIter.hasNext()) {
                final Iterable<Node<Tuple2<T, U>>> remainder = io.vavr.collection.Iterator
                        .ofAll(thatIter)
                        .map(elem -> of(Tuple.of(thisElem, elem)));
                return new Node<>(tree.getValue(), tree.getChildren().appendAll(remainder));
            } else {
                return tree;
            }
        }
    }
    @Override
    default Tree<Tuple2<T, Integer>> zipWithIndex() {
        return zipWithIndex(Tuple::of);
    }
    @Override
    default <U> Tree<U> zipWithIndex(BiFunction<? super T, ? super Integer, ? extends U> mapper) {
        Objects.requireNonNull(mapper, "mapper is null");
        return zipWith(io.vavr.collection.Iterator.from(0), mapper);
    }
    @Override
    boolean equals(Object o);
    @Override
    int hashCode();
    @Override
    String toString();
    String draw();
    final class Node<T> implements Tree<T>, Serializable {
        private static final long serialVersionUID = 1L;
        @SuppressWarnings("serial") 
        private final T value;
        private final io.vavr.collection.List<Node<T>> children;
        private final int size;
        public Node(T value, io.vavr.collection.List<Node<T>> children) {
            Objects.requireNonNull(children, "children is null");
            this.value = value;
            this.children = children;
            this.size = children.foldLeft(1, (acc, child) -> acc + child.size);
        }
        @Override
        public io.vavr.collection.List<Node<T>> getChildren() {
            return children;
        }
        @Override
        public T getValue() {
            return value;
        }
        @Override
        public boolean isEmpty() {
            return false;
        }
        @Override
        public int length() {
            return size;
        }
        @Override
        public boolean isLeaf() {
            return size == 1;
        }
        @Override
        public T last() {
            return children.isEmpty() ? value : children.last().last();
        }
        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof Node) {
                final Node<?> that = (Node<?>) o;
                return Objects.equals(this.getValue(), that.getValue())
                        && Objects.equals(this.getChildren(), that.getChildren());
            } else {
                return false;
            }
        }
        @Override
        public int hashCode() {
            return Tuple.hash(value, children);
        }
        @Override
        public String toString() {
            return mkString(stringPrefix() + "(", ", ", ")");
        }
        @Override
        public String toLispString() {
            return toLispString(this);
        }
        @Override
        public String draw() {
            final StringBuilder builder = new StringBuilder();
            drawAux("", builder);
            return builder.toString();
        }
        private void drawAux(String indent, StringBuilder builder) {
            builder.append(value);
            for (io.vavr.collection.List<Node<T>> it = children; !it.isEmpty(); it = it.tail()) {
                final boolean isLast = it.tail().isEmpty();
                builder.append('\n')
                        .append(indent)
                        .append(isLast ? "└──" : "├──");
                it.head().drawAux(indent + (isLast ? "   " : "│  "), builder);
            }
        }
        private static String toLispString(Tree<?> tree) {
            final String value = String.valueOf(tree.getValue());
            if (tree.isLeaf()) {
                return value;
            } else {
                final String children = tree.getChildren().map(child -> toLispString(child)).mkString(" ");
                return "(" + value + " " + children + ")";
            }
        }
        @GwtIncompatible("The Java serialization protocol is explicitly not supported")
        private Object writeReplace() {
            return new SerializationProxy<>(this);
        }
        @GwtIncompatible("The Java serialization protocol is explicitly not supported")
        private void readObject(ObjectInputStream stream) throws InvalidObjectException {
            throw new InvalidObjectException("Proxy required");
        }
        @GwtIncompatible("The Java serialization protocol is explicitly not supported")
        private static final class SerializationProxy<T> implements Serializable {
            private static final long serialVersionUID = 1L;
            private transient Node<T> node;
            SerializationProxy(Node<T> node) {
                this.node = node;
            }
            private void writeObject(ObjectOutputStream s) throws IOException {
                s.defaultWriteObject();
                s.writeObject(node.value);
                s.writeObject(node.children);
            }
            @SuppressWarnings("unchecked")
            private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {
                s.defaultReadObject();
                final T value = (T) s.readObject();
                final io.vavr.collection.List<Node<T>> children = (io.vavr.collection.List<Node<T>>) s.readObject();
                node = new Node<>(value, children);
            }
            private Object readResolve() {
                return node;
            }
        }
    }
    final class Empty<T> implements Tree<T>, Serializable {
        private static final long serialVersionUID = 1L;
        private static final Empty<?> INSTANCE = new Empty<>();
        private Empty() {
        }
        @SuppressWarnings("unchecked")
        public static <T> Empty<T> instance() {
            return (Empty<T>) INSTANCE;
        }
        @Override
        public io.vavr.collection.List<Node<T>> getChildren() {
            return Nil.instance();
        }
        @Override
        public T getValue() {
            throw new UnsupportedOperationException("getValue of empty Tree");
        }
        @Override
        public boolean isEmpty() {
            return true;
        }
        @Override
        public int length() {
            return 0;
        }
        @Override
        public boolean isLeaf() {
            return false;
        }
        @Override
        public T last() {
            throw new NoSuchElementException("last of empty tree");
        }
        @Override
        public boolean equals(Object o) {
            return o == this;
        }
        @Override
        public int hashCode() {
            return 1;
        }
        @Override
        public String toString() {
            return stringPrefix() + "()";
        }
        @Override
        public String toLispString() {
            return "()";
        }
        @Override
        public String draw() { return "▣"; }
        private Object readResolve() {
            return INSTANCE;
        }
    }
    enum Order {
        PRE_ORDER,
        IN_ORDER,
        POST_ORDER,
        LEVEL_ORDER
    }
}
interface TreeModule {
    @SuppressWarnings("unchecked")
    static <T, U> Tree<U> flatMap(Node<T> node, Function<? super T, ? extends Iterable<? extends U>> mapper) {
        final Tree<U> mapped = ofAll(mapper.apply(node.getValue()));
        if (mapped.isEmpty()) {
            return empty();
        } else {
            final io.vavr.collection.List<Node<U>> children = (io.vavr.collection.List<Node<U>>) (Object) node
                    .getChildren()
                    .map(child -> flatMap(child, mapper))
                    .filter(Tree::nonEmpty);
            return of(mapped.get(), children.prependAll(mapped.getChildren()));
        }
    }
    static <T, U> Node<U> map(Node<T> node, Function<? super T, ? extends U> mapper) {
        final U value = mapper.apply(node.getValue());
        final io.vavr.collection.List<Node<U>> children = node.getChildren().map(child -> map(child, mapper));
        return new Node<>(value, children);
    }
    static <T> Node<T> replace(Node<T> node, T currentElement, T newElement) {
        if (Objects.equals(node.getValue(), currentElement)) {
            return new Node<>(newElement, node.getChildren());
        } else {
            for (Node<T> child : node.getChildren()) {
                final Node<T> newChild = replace(child, currentElement, newElement);
                final boolean found = newChild != child;
                if (found) {
                    final io.vavr.collection.List<Node<T>> newChildren = node.getChildren().replace(child, newChild);
                    return new Node<>(node.getValue(), newChildren);
                }
            }
            return node;
        }
    }
    static <T> Stream<Node<T>> traversePreOrder(Node<T> node) {
        return node.getChildren().foldLeft(Stream.of(node),
                (acc, child) -> acc.appendAll(traversePreOrder(child)));
    }
    static <T> Stream<Node<T>> traverseInOrder(Node<T> node) {
        if (node.isLeaf()) {
            return Stream.of(node);
        } else {
            final io.vavr.collection.List<Node<T>> children = node.getChildren();
            return children
                    .tail()
                    .foldLeft(Stream.<Node<T>> empty(), (acc, child) -> acc.appendAll(traverseInOrder(child)))
                    .prepend(node)
                    .prependAll(traverseInOrder(children.head()));
        }
    }
    static <T> Stream<Node<T>> traversePostOrder(Node<T> node) {
        return node
                .getChildren()
                .foldLeft(Stream.<Node<T>> empty(), (acc, child) -> acc.appendAll(traversePostOrder(child)))
                .append(node);
    }
    static <T> Stream<Node<T>> traverseLevelOrder(Node<T> node) {
        Stream<Node<T>> result = Stream.empty();
        final java.util.Queue<Node<T>> queue = new java.util.LinkedList<>();
        queue.add(node);
        while (!queue.isEmpty()) {
            final Node<T> next = queue.remove();
            result = result.prepend(next);
            queue.addAll(next.getChildren().toJavaList());
        }
        return result.reverse();
    }
    static <T, T1, T2> Tuple2<Node<T1>, Node<T2>> unzip(Node<T> node,
            Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper) {
        final Tuple2<? extends T1, ? extends T2> value = unzipper.apply(node.getValue());
        final io.vavr.collection.List<Tuple2<Node<T1>, Node<T2>>> children = node
                .getChildren()
                .map(child -> unzip(child, unzipper));
        final Node<T1> node1 = new Node<>(value._1, children.map(t -> t._1));
        final Node<T2> node2 = new Node<>(value._2, children.map(t -> t._2));
        return Tuple.of(node1, node2);
    }
    static <T, T1, T2, T3> Tuple3<Node<T1>, Node<T2>, Node<T3>> unzip3(Node<T> node,
            Function<? super T, Tuple3<? extends T1, ? extends T2, ? extends T3>> unzipper) {
        final Tuple3<? extends T1, ? extends T2, ? extends T3> value = unzipper.apply(node.getValue());
        final io.vavr.collection.List<Tuple3<Node<T1>, Node<T2>, Node<T3>>> children = node.getChildren()
                .map(child -> unzip3(child, unzipper));
        final Node<T1> node1 = new Node<>(value._1, children.map(t -> t._1));
        final Node<T2> node2 = new Node<>(value._2, children.map(t -> t._2));
        final Node<T3> node3 = new Node<>(value._3, children.map(t -> t._3));
        return Tuple.of(node1, node2, node3);
    }
    @SuppressWarnings("unchecked")
    static <T, U, R> Tree<R> zip(Node<T> node, java.util.Iterator<? extends U> that, BiFunction<? super T, ? super U, ? extends R> mapper) {
        if (!that.hasNext()) {
            return Empty.instance();
        } else {
            final R value = mapper.apply(node.getValue(), that.next());
            final io.vavr.collection.List<Node<R>> children = (io.vavr.collection.List<Node<R>>) (Object) node
                    .getChildren()
                    .map(child -> zip(child, that, mapper))
                    .filter(Tree::nonEmpty);
            return new Node<>(value, children);
        }
    }
    @SuppressWarnings("unchecked")
    static <T, U> Tree<Tuple2<T, U>> zipAll(Node<T> node, java.util.Iterator<? extends U> that, U thatElem) {
        if (!that.hasNext()) {
            return node.map(value -> Tuple.of(value, thatElem));
        } else {
            final Tuple2<T, U> value = Tuple.of(node.getValue(), that.next());
            final io.vavr.collection.List<Node<Tuple2<T, U>>> children = (io.vavr.collection.List<Node<Tuple2<T, U>>>) (Object) node
                    .getChildren()
                    .map(child -> zipAll(child, that, thatElem))
                    .filter(Tree::nonEmpty);
            return new Node<>(value, children);
        }
    }
}