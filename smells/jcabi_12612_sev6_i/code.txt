/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.google.common.base.Optional;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.ParseException;
import java.util.Date;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
import lombok.ToString;
/**
 * Github event.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.4
 * @see <a href="https://developer.github.com/v3/issues/events/">Issue Events API</a>
 * @checkstyle MultipleStringLiterals (500 lines)
 */
@Immutable
@SuppressWarnings("PMD.TooManyMethods")
public interface Event extends Comparable<Event>, JsonReadable {
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String CLOSED = "closed";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String REOPENED = "reopened";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String SUBSCRIBED = "subscribed";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String MERGED = "merged";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String REFERENCED = "referenced";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String MENTIONED = "mentioned";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String ASSIGNED = "assigned";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String UNASSIGNED = "unassigned";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String LABELED = "labeled";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String UNLABELED = "unlabeled";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String MILESTONED = "milestoned";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String DEMILESTONED = "demilestoned";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String RENAMED = "renamed";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String LOCKED = "locked";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String UNLOCKED = "unlocked";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String HEAD_REF_DELETED = "head_ref_deleted";
    /**
     * Event type.
     * @see <a href="https://developer.github.com/v3/issues/events/">Event Types</a>
     */
    String HEAD_REF_RESTORED = "head_ref_restored";
    /**
     * Repository we're in.
     * @return Repo
     */
    Repo repo();
    /**
     * Get its number.
     * @return Issue number
     */
    int number();
    /**
     * Smart event with extra features.
     */
    @Immutable
    @ToString
    @Loggable(Loggable.DEBUG)
    @EqualsAndHashCode(of = { "event", "jsn" })
    final class Smart implements Event {
        /**
         * Encapsulated event.
         */
        private final transient Event event;
        /**
         * SmartJson object for convenient JSON parsing.
         */
        private final transient SmartJson jsn;
        /**
         * Public ctor.
         * @param evt Event
         */
        public Smart(final Event evt) {
            this.event = evt;
            this.jsn = new SmartJson(evt);
        }
        /**
         * Does it have an author?
         * @return TRUE if the author exists
         * @throws IOException If there is any I/O problem
         */
        public boolean hasAuthor() throws IOException {
            return !this.event.json().isNull("actor");
        }
        /**
         * Get its author.
         * @return Author of comment
         * @throws IOException If there is any I/O problem
         */
        public User author() throws IOException {
            return this.event.repo().github().users().get(
                this.event.json().getJsonObject("actor").getString("login")
            );
        }
        /**
         * Get its type.
         * @return State of issue
         * @throws IOException If there is any I/O problem
         */
        public String type() throws IOException {
            return this.jsn.text("event");
        }
        /**
         * Get its URL.
         * @return URL of issue
         * @throws IOException If there is any I/O problem
         */
        public URL url() throws IOException {
            try {
                return new URI(this.jsn.text("url")).toURL();
            } catch (final URISyntaxException ex) {
                throw new IllegalArgumentException(ex);
            }
        }
        /**
         * When this issue was created.
         * @return Date of creation
         * @throws IOException If there is any I/O problem
         */
        public Date createdAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("created_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IllegalStateException(ex);
            }
        }
        /**
         * Label that was added or removed in this event (if any).
         * @return Label that was added or removed
         * @throws IOException If there is any I/O problem
         * @since 0.24
         */
        public Optional<Label> label() throws IOException {
            Optional<Label> lab = Optional.absent();
            final JsonObject lbl = this.jsn.json().getJsonObject("label");
            if (lbl != null) {
                lab = Optional.of(
                    this.event.repo()
                        .labels()
                        .get(lbl.getString("name"))
                );
            }
            return lab;
        }
        @Override
        public Repo repo() {
            return this.event.repo();
        }
        @Override
        public int number() {
            return this.event.number();
        }
        @Override
        public JsonObject json() throws IOException {
            return this.event.json();
        }
        @Override
        public int compareTo(final Event obj) {
            return this.event.compareTo(obj);
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.ParseException;
import java.util.Date;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
import lombok.ToString;
/**
 * Github user.
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @checkstyle MultipleStringLiterals (500 lines)
 * @see <a href="https://developer.github.com/v3/users/">User API</a>
 * @since 0.1
 */
@Immutable
@SuppressWarnings({"PMD.TooManyMethods", "PMD.ExcessivePublicCount",
    "PMD.GodClass" })
public interface User extends JsonReadable, JsonPatchable {
    /**
     * Github we're in.
     * @return Github
     * @since 0.4
     */
    Github github();
    /**
     * Get his login.
     * @return Login name
     * @throws IOException If it fails
     */
    String login() throws IOException;
    /**
     * Get his organizations.
     * @return UserOrganizations organizations
     */
    UserOrganizations organizations();
    /**
     * Get his keys.
     * @return PublicKeys keys
     */
    PublicKeys keys();
    /**
     * Get user's emails.
     * @return User's emails
     * @since 0.8
     */
    UserEmails emails();
    /**
     * Notifications for this user.
     * Wraps the call "List your notifications". See "List your notifications"
     * at https://developer.github.com/v3/activity/notifications/
     * @see <a href="https://developer.github.com/v3/activity/notifications/#list-your-notifications">List your notifications</a>
     * @return Notifications for this user.
     * @throws IOException Thrown, if an error during sending request and/or
     *  receiving response occurs.
     */
    Notifications notifications() throws IOException;
    /**
     * Marks notifications as read.
     * @param lastread Describes the last point that notifications were
     *  checked.
     * @see <a href="https://developer.github.com/v3/activity/notifications/#mark-as-read">Mark as read</a>
     * @throws IOException Thrown, if an error during sending request and/or
     *  receiving response occurs.
     */
    void markAsRead(final Date lastread) throws IOException;
    /**
     * Smart user with extra features.
     * @see <a href="https://developer.github.com/v3/users/#get-a-single-user">Get a Single User</a>
     */
    @Immutable
    @ToString
    @Loggable(Loggable.DEBUG)
    @EqualsAndHashCode(of = { "user", "jsn" })
    final class Smart implements User {
        /**
         * Encapsulated user.
         */
        private final transient User user;
        /**
         * SmartJson object for convenient JSON parsing.
         */
        private final transient SmartJson jsn;
        /**
         * Public ctor.
         * @param usr User
         */
        public Smart(final User usr) {
            this.user = usr;
            this.jsn = new SmartJson(usr);
        }
        /**
         * Does it exist in GitHub?
         * @return TRUE if this user truly exists
         * @throws IOException If it fails
         * @since 0.34
         */
        public boolean exists() throws IOException {
            return new Existence(this.user).check();
        }
        /**
         * Get his ID.
         * @return Unique user ID
         * @throws IOException If it fails
         * @checkstyle MethodName (3 lines)
         */
        @SuppressWarnings("PMD.ShortMethodName")
        public int id() throws IOException {
            return this.user.json().getJsonNumber("id").intValue();
        }
        /**
         * Get his avatar URL.
         * @return URL of the avatar
         * @throws IOException If it fails
         */
        public URL avatarUrl() throws IOException {
            try {
                return new URI(this.jsn.text("avatar_url")).toURL();
            } catch (final URISyntaxException ex) {
                throw new IllegalArgumentException(ex);
            }
        }
        /**
         * Get his URL.
         * @return URL of the user
         * @throws IOException If it fails
         */
        public URL url() throws IOException {
            try {
                return new URI(this.jsn.text("url")).toURL();
            } catch (final URISyntaxException ex) {
                throw new IllegalArgumentException(ex);
            }
        }
        /**
         * Get his name.
         * @return User name
         * @throws IOException If it fails
         */
        public String name() throws IOException {
            final JsonObject json = this.json();
            if (!json.containsKey("name")) {
                throw new IllegalStateException(
                    String.format(
                        // @checkstyle LineLength (1 line)
                        "User %s doesn't have a name specified in his/her Github account; use #hasName() first.",
                        this.login()
                    )
                );
            }
            return json.getString("name");
        }
        /**
         * Check if user has name.
         * @return True if user has name
         * @throws IOException If it fails
         */
        public boolean hasName() throws IOException {
            return this.json().containsKey("name");
        }
        /**
         * Get his company.
         * @return Company name
         * @throws IOException If it fails
         */
        public String company() throws IOException {
            return this.jsn.text("company");
        }
        /**
         * Get his location.
         * @return Location name
         * @throws IOException If it fails
         */
        public String location() throws IOException {
            return this.jsn.text("location");
        }
        /**
         * Get his email.
         * @return Email
         * @throws IOException If it fails
         */
        public String email() throws IOException {
            return this.jsn.text("email");
        }
        @Override
        public Github github() {
            return this.user.github();
        }
        @Override
        public String login() throws IOException {
            return this.user.login();
        }
        @Override
        public UserOrganizations organizations() {
            return this.user.organizations();
        }
        @Override
        public PublicKeys keys() {
            return this.user.keys();
        }
        @Override
        public UserEmails emails() {
            return this.user.emails();
        }
        @Override
        public Notifications notifications() throws IOException {
            return this.user.notifications();
        }
        @Override
        public void markAsRead(final Date lastread) throws IOException {
            this.user.markAsRead(lastread);
        }
        @Override
        public JsonObject json() throws IOException {
            return this.user.json();
        }
        @Override
        public void patch(
            final JsonObject json
        ) throws IOException {
            this.user.patch(json);
        }
        /**
         * Returns the value of html_url property of User's JSON.
         * @return The 'html_url' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String htmlUrl() throws IOException {
            return this.jsn.text("html_url");
        }
        /**
         * Returns the value of followers_url property of User's JSON.
         * @return The 'followers_url' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String followersUrl() throws IOException {
            return this.jsn.text("followers_url");
        }
        /**
         * Returns the value of following_url property of User's JSON.
         * @return The 'following_url' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String followingUrl() throws IOException {
            return this.jsn.text("following_url");
        }
        /**
         * Returns the value of gists_url property of User's JSON.
         * @return The 'gists_url' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String gistsUrl() throws IOException {
            return this.jsn.text("gists_url");
        }
        /**
         * Returns the value of starred_url property of User's JSON.
         * @return The 'starred_url' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String starredUrl() throws IOException {
            return this.jsn.text("starred_url");
        }
        /**
         * Returns the value of subscriptions_url property of User's JSON.
         * @return The 'subscriptions_url' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String subscriptionsUrl() throws IOException {
            return this.jsn.text("subscriptions_url");
        }
        /**
         * Returns the value of organizations_url property of User's JSON.
         * @return The 'organizations_url' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String organizationsUrl() throws IOException {
            return this.jsn.text("organizations_url");
        }
        /**
         * Returns the value of repos_url property of User's JSON.
         * @return The 'repos_url' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String reposUrl() throws IOException {
            return this.jsn.text("repos_url");
        }
        /**
         * Returns the value of events_url property of User's JSON.
         * @return The 'events_url' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String eventsUrl() throws IOException {
            return this.jsn.text("events_url");
        }
        /**
         * Returns the value of received_events_url property of User's JSON.
         * @return The 'received_events_url' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String receivedEventsUrl() throws IOException {
            return this.jsn.text("received_events_url");
        }
        /**
         * Returns the value of type property of User's JSON.
         * @return The 'type' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String type() throws IOException {
            return this.jsn.text("type");
        }
        /**
         * Returns the value of site_admin property of User's JSON.
         * @return The 'site_admin' property value.
         * @throws IOException If any I/O error occurs.
         */
        public boolean siteAdmin() throws IOException {
            return "true".equals(this.jsn.text("site_admin"));
        }
        /**
         * Returns the value of blog property of User's JSON.
         * @return The 'blog' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String blog() throws IOException {
            return this.jsn.text("blog");
        }
        /**
         * Returns the value of hireable property of User's JSON.
         * @return The 'hireable' property value.
         * @throws IOException If any I/O error occurs.
         */
        public boolean hireable() throws IOException {
            return "true".equals(this.jsn.text("hireable"));
        }
        /**
         * Returns the value of bio property of User's JSON.
         * @return The 'bio' property value.
         * @throws IOException If any I/O error occurs.
         */
        public String bio() throws IOException {
            return this.jsn.text("bio");
        }
        /**
         * Returns the value of public_repos property of User's JSON.
         * @return The 'public_repos' property value.
         * @throws IOException If any I/O error occurs.
         */
        public int publicRepos() throws IOException {
            return Integer.parseInt(this.jsn.text("public_repos"));
        }
        /**
         * Returns the value of public_gists property of User's JSON.
         * @return The 'public_gists' property value.
         * @throws IOException If any I/O error occurs.
         */
        public int publicGists() throws IOException {
            return Integer.parseInt(this.jsn.text("public_gists"));
        }
        /**
         * Returns the value of followers property of User's JSON.
         * @return The 'followers' property value.
         * @throws IOException If any I/O error occurs.
         */
        public int followersCount() throws IOException {
            return Integer.parseInt(this.jsn.text("followers"));
        }
        /**
         * Returns the value of following property of User's JSON.
         * @return The 'following' property value.
         * @throws IOException If any I/O error occurs.
         */
        public int followingCount() throws IOException {
            return Integer.parseInt(this.jsn.text("following"));
        }
        /**
         * Returns the value of created_at property of User's JSON.
         * @return The 'created_at' property value.
         * @throws IOException If any I/O error occurs.
         */
        public Github.Time created() throws IOException {
            try {
                return new Github.Time(this.jsn.text("created_at"));
            } catch (final ParseException ex) {
                throw new IllegalArgumentException(
                    "Cannot parse value of 'created_at' property",
                    ex
                );
            }
        }
        /**
         * Returns the value of updated_at property of User's JSON.
         * @return The 'updated_at' property value.
         * @throws IOException If any I/O error occurs.
         */
        public Github.Time updated() throws IOException {
            try {
                return new Github.Time(this.jsn.text("updated_at"));
            } catch (final ParseException ex) {
                throw new IllegalArgumentException(
                    "Cannot parse value of 'updated_at' property",
                    ex
                );
            }
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import java.io.StringReader;
import javax.json.Json;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import org.apache.commons.lang3.builder.CompareToBuilder;
/**
 * Github label.
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @checkstyle MultipleStringLiterals (500 lines)
 * @see <a href="https://developer.github.com/v3/issues/labels/">Labels API</a>
 * @since 0.1
 */
@Immutable
@SuppressWarnings("PMD.TooManyMethods")
public interface Label extends Comparable<Label>, JsonReadable, JsonPatchable {
    /**
     * The repo we're in.
     * @return Issue
     * @since 0.6
     */
    Repo repo();
    /**
     * Name of it.
     * @return Name
     */
    String name();
    /**
     * Smart Label with extra features.
     */
    @Immutable
    @ToString
    @Loggable(Loggable.DEBUG)
    @EqualsAndHashCode(of = { "label", "jsn" })
    final class Smart implements Label {
        /**
         * Encapsulated label.
         */
        private final transient Label label;
        /**
         * SmartJson object for convenient JSON parsing.
         */
        private final transient SmartJson jsn;
        /**
         * Public ctor.
         * @param lbl Label
         */
        public Smart(final Label lbl) {
            this.label = lbl;
            this.jsn = new SmartJson(lbl);
        }
        /**
         * Get its color.
         * @return Color of it
         * @throws IOException If there is any I/O problem
         */
        public String color() throws IOException {
            return this.jsn.text("color");
        }
        /**
         * Set its color.
         * @param color Color to set
         * @throws IOException If there is any I/O problem
         */
        public void color(final String color) throws IOException {
            this.label.patch(
                Json.createObjectBuilder().add("color", color).build()
            );
        }
        @Override
        public Repo repo() {
            return this.label.repo();
        }
        @Override
        public String name() {
            return this.label.name();
        }
        @Override
        public int compareTo(final Label lbl) {
            return this.label.compareTo(lbl);
        }
        @Override
        public void patch(final JsonObject json) throws IOException {
            this.label.patch(json);
        }
        @Override
        public JsonObject json() throws IOException {
            return this.label.json();
        }
    }
    /**
     * Unmodified Label with extra features.
     */
    @Immutable
    @ToString
    @Loggable(Loggable.DEBUG)
    @EqualsAndHashCode(of = { "repo", "obj" })
    final class Unmodified implements Label {
        /**
         * Encapsulated Repo.
         */
        private final transient Repo repo;
        /**
         * Encapsulated String.
         */
        private final transient String obj;
        /**
         * Public ctor.
         * @param rep Repo
         * @param object String
         */
        public Unmodified(
            final Repo rep, final String object
        ) {
            this.repo = rep;
            this.obj = object;
        }
        @Override
        public Repo repo() {
            return this.repo;
        }
        @Override
        public String name() {
            return this.json().getString("name");
        }
        @Override
        public int compareTo(final Label label) {
            return new CompareToBuilder()
                .append(this.repo().coordinates(), label.repo().coordinates())
                .append(this.obj, label.name())
                .build();
        }
        @Override
        public void patch(final JsonObject json) {
            throw new UnsupportedOperationException("#patch()");
        }
        @Override
        public JsonObject json() {
            return Json.createReader(new StringReader(this.obj)).readObject();
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import java.util.EnumMap;
/**
 * Github search.
 *
 * @author Carlos Miranda (miranda.cma@gmail.com)
 * @version $Id$
 * @since 0.8
 * @see <a href="https://developer.github.com/v3/search/">Search API</a>
 */
@Immutable
@SuppressWarnings("PMD.AvoidDuplicateLiterals")
public interface Search {
    /**
     * Github we're in.
     *
     * @return Github
     */
    Github github();
    /**
     * Search repositories.
     *
     * @param keywords The search keywords
     * @param sort The sort field
     * @param order The sort order
     * @return Repos
     * @see <a href="https://developer.github.com/v3/search/#search-repositories">Search repositories</a>
     */
    Iterable<Repo> repos(
        String keywords,
        String sort,
        Order order
    );
    /**
     * Search issues.
     *
     * @param keywords The search keywords
     * @param sort The sort field
     * @param order The sort order
     * @param qualifiers The search qualifier
     * @return Issues
     * @see <a href="https://developer.github.com/v3/search/#search-issues">Search issues</a>
     * @checkstyle ParameterNumberCheck (7 lines)
     */
    Iterable<Issue> issues(
        String keywords,
        String sort,
        Order order,
        EnumMap<Qualifier, String> qualifiers);
    /**
     * Search users.
     *
     * @param keywords The search keywords
     * @param sort The sort field
     * @param order The sort order
     * @return Users
     * @see <a href="https://developer.github.com/v3/search/#search-users">Search users</a>
     */
    Iterable<User> users(
        String keywords,
        String sort,
        Order order);
    /**
     * Search code.
     *
     * @param keywords The search keywords
     * @param sort The sort field
     * @param order The sort order
     * @return Contents
     * @see <a href="https://developer.github.com/v3/search/#search-code">Search code</a>
     */
    Iterable<Content> codes(
        String keywords,
        String sort,
        Order order);
    enum Qualifier implements StringEnum {
        /**
         * The search by issues or pull request only.
         */
        TYPE("type"),
        /**
         * Qualifies which fields are searched.
         * <p>With this qualifier you can restrict the search to just
         * the title, body, comments, or any combination of these.</p>
         */
        IN("in"),
        /**
         * Finds issues created by a certain user.
         */
        AUTHOR("author"),
        /**
         * Finds issues that are assigned to a certain user.
         */
        ASSIGNEE("assignee"),
        /**
         * Finds issues that mention a certain user.
         */
        MENTIONS("mentions"),
        /**
         * Finds issues that a certain user commented on.
         */
        COMMENTER("commenter"),
        /**
         * Finds issues that were either created by a certain user.
         * <p>Or assigned to that user, mention that user,
         *  or were commented on by that user.</p>
         */
        INVOLVES("involves"),
        /**
         * Finds issues or pull requests which mention a particular team within
         * an organization which the user is a member of.
        */
        TEAM("team"),
        /**
         * Filter issues based on whether they’re open or closed.
         */
        STATE("state"),
        /**
         * Filters issues based on their labels.
         */
        LABEL("label"),
        /**
         * Filters items missing certain metadata.
         */
        NO("no"),
        /**
         * Searches for issues within repositories matching a certain language.
         */
        LANGUAGE("language"),
        /**
         * Searches for items within repositories that match a certain state.
         */
        IS("is"),
        /**
         * Filters issues based on date of creation.
         */
        CREATED("created"),
        /**
         * Filters issues based on date last updated.
         */
        UPDATED("updated"),
        /**
         * Filters pull requests based on the date when they were merged.
         */
        MERGED("merged"),
        /**
         * Filters issues based on the date when they were closed.
         */
        CLOSED("closed"),
        /**
         * Filters issues based on the quantity of comments.
         */
        COMMENTS("comments"),
        /**
         * Limits searches to a specific user.
         */
        USER("user"),
        /**
         * Limits searches to a specific repository.
         */
        REPO("repo");
        /**
         * Search qualifier.
         */
        private final transient String qualifier;
        /**
         * Ctor.
         * @param key Search qualifier
         */
        Qualifier(final String key) {
            this.qualifier = key;
        }
        /**
         * Get search qualifier.
         * @return String
         */
        @Override
        public String identifier() {
            return this.qualifier;
        }
    }
    enum Order implements StringEnum {
        /**
         * Sorting ascending.
         */
        ASC("asc"),
        /**
         * Sorting descending.
         */
        DESC("desc");
        /**
         * The sort order.
         */
        private final transient String order;
        /**
         * Ctor.
         * @param key The sort order
         */
        Order(final String key) {
            this.order = key;
        }
        /**
         * Get sort order.
         * @return String
         */
        @Override
        public String identifier() {
            return this.order;
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.http.Request;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
/**
 * Github client, starting point to the entire library.
 *
 * <p>This is how you start communicating with Github API:
 *
 * <pre> Github github = new RtGithub(oauthKey);
 * Repo repo = github.repos().get(
 *     new Coordinates.Simple("jcabi/jcabi-github")
 * );
 * Issues issues = repo.issues();
 * Issue issue = issues.post("issue title", "issue body");</pre>
 *
 * <p>It is strongly recommended to use
 * {@link com.jcabi.http.wire.RetryWire} to avoid
 * accidental I/O exceptions:
 *
 * <pre> Github github = new RtGithub(
 *   new RtGithub(oauthKey)
 *     .entry()
 *     .through(RetryWire.class)
 * );</pre>
 *
 * <p>The interfaces in this packages are trying to cover as much
 * as possible of Github API. However, there are parts of API that are
 * rarely used and making Java classes for them is not an effective
 * idea. That's why {@code Github} class has {@link #entry()} method,
 * which returns an entry point to the RESTful API. For example, you
 * want to use
 * <a href="https://developer.github.com/v3/search/#search-repositories">"Search
 * Repositories"</a> feature of Github:
 *
 * <pre> Github github = new RtGithub(oauthKey);
 * int found = github.entry()
 *   .uri().path("/search/repositories").back()
 *   .method(Request.GET)
 *   .fetch()
 *   .as(JsonResponse.class)
 *   .getJsonObject()
 *   .getNumber("total_count")
 *   .intValue();</pre>
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.1
 */
@Immutable
@SuppressWarnings("PMD.TooManyMethods")
public interface Github {
    /**
     * RESTful request, an entry point to the Github API.
     * @return Request
     */
    Request entry();
    /**
     * Get repositories.
     * @return Repositories
     */
    Repos repos();
    /**
     * Get Gists API entry point.
     * @return Gists API entry point
     */
    Gists gists();
    /**
     * Get Users API entry point.
     * @return Users API entry point
     * @since 0.4
     */
    Users users();
    /**
     * Get Organizations API entry point.
     * @return Organizations API entry point
     * @since 0.24
     */
    Organizations organizations();
    /**
     * Get Markdown API entry point.
     * @return Markdown API entry point
     * @since 0.6
     */
    Markdown markdown();
    /**
     * Rate limit API entry point.
     * @return Rate limit API
     * @since 0.6
     */
    Limits limits();
    /**
     * Search API entry point.
     * @return Search API
     * @since 0.8
     */
    Search search();
    /**
     * Get gitignores.
     * @return Gitignotes API
     * @see <a href="https://developer.github.com/v3/gitignore/">Gitignore API</a>
     * @since 0.8
     */
    Gitignores gitignores();
    /**
     * Get meta information.
     * @return JSON with meta
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/meta/">Meta API</a>
     * @since 0.6
     */
    JsonObject meta() throws IOException;
    /**
     * Get emojis.
     * @return JSON with emojis
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/emojis/">Emojis API</a>
     * @since 0.6
     */
    JsonObject emojis() throws IOException;
    /**
     * Time in Github JSON.
     * @see <a href="https://developer.github.com/v3/#schema">Schema</a>
     * @since 0.2
     */
    @Immutable
    @EqualsAndHashCode(of = { "msec" })
    final class Time {
        /**
         * Pattern to present day in ISO-8601.
         */
        public static final String FORMAT_ISO = "yyyy-MM-dd'T'HH:mm:ss'Z'";
        /**
         * The time zone we're in.
         */
        public static final TimeZone TIMEZONE = TimeZone.getTimeZone("UTC");
        /**
         * Encapsulated time in milliseconds.
         */
        private final transient long msec;
        /**
         * Ctor.
         */
        public Time() {
            this(new Date());
        }
        /**
         * Ctor.
         * @param text ISO date/time
         * @throws ParseException If fails
         */
        public Time(final String text) throws ParseException {
            this(Github.Time.format().parse(text));
        }
        /**
         * Ctor.
         * @param date Date to encapsulate
         */
        public Time(final Date date) {
            this(date.getTime());
        }
        /**
         * Ctor.
         * @param millis Milliseconds
         */
        public Time(final long millis) {
            this.msec = millis;
        }
        @Override
        public String toString() {
            return Github.Time.format().format(this.date());
        }
        /**
         * Get date.
         * @return Date
         */
        public Date date() {
            return new Date(this.msec);
        }
        /**
         * Make format.
         * @return Date format
         */
        private static DateFormat format() {
            final DateFormat fmt = new SimpleDateFormat(
                Github.Time.FORMAT_ISO, Locale.ENGLISH
            );
            fmt.setTimeZone(Github.Time.TIMEZONE);
            return fmt;
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import javax.json.JsonObject;
import javax.json.JsonValue;
import lombok.EqualsAndHashCode;
import lombok.ToString;
/**
 * Github repository.
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.1
 * @checkstyle MultipleStringLiterals (500 lines)
 */
@Immutable
@SuppressWarnings({"PMD.TooManyMethods", "PMD.ExcessivePublicCount"})
public interface Repo extends JsonReadable, JsonPatchable, Comparable<Repo> {
    /**
     * Get its owner.
     * @return Github
     */
    Github github();
    /**
     * Get its coordinates.
     * @return Coordinates
     */
    Coordinates coordinates();
    /**
     * Iterate issues.
     * @return Issues
     */
    Issues issues();
    /**
     * Iterate milestones.
     * @return Milestones
     * @since 0.7
     */
    Milestones milestones();
    /**
     * Pull requests.
     * @return Pulls
     */
    Pulls pulls();
    /**
     * Hooks.
     * @return Hooks
     * @since 0.8
     */
    Hooks hooks();
    /**
     * Get all issue events for the repository.
     * @return Issue events
     * @see <a href="https://developer.github.com/v3/issues/events/#list-events-for-a-repository">List Events for a Repository</a>
     */
    IssueEvents issueEvents();
    /**
     * Get all labels of the repo.
     * @return Labels
     * @see <a href="https://developer.github.com/v3/issues/labels/">Labels API</a>
     */
    Labels labels();
    /**
     * Get all available assignees to which issues may be assigned.
     * @return Assignees
     * @see <a href="https://developer.github.com/v3/issues/assignees/">Assignees API</a>
     */
    Assignees assignees();
    /**
     * Get all releases of the repo.
     * @return Releases
     * @see <a href="https://developer.github.com/v3/repos/releases/">Releases API</a>
     */
    Releases releases();
    /**
     * Get all deploy keys of the repo.
     * @return DeployKeys
     * @see <a href="https://developer.github.com/v3/repos/keys/">Deploy Keys API</a>
     */
    DeployKeys keys();
    /**
     * Get all forks of the repo.
     * @return Forks
     * @see <a href="https://developer.github.com/v3/repos/forks/">Forks API</a>
     */
    Forks forks();
    /**
     * Get repository's commits.
     * @return Commits
     * @see <a href="https://developer.github.com/v3/repos/commits/">Commits API</a>
     */
    RepoCommits commits();
    /**
     * Get repository's branches.
     * @return Branches
     * @see <a href="https://developer.github.com/v3/repos/#list-branches">List Branches API</a>
     */
    Branches branches();
    /**
     * Get all contents of the repo.
     * @return Contents
     * @see <a href="https://developer.github.com/v3/repos/contents/">Contents API</a>
     */
    Contents contents();
    /**
     * Gel all collaborators.
     * @return Collaborators
     * @see <a href="https://developer.github.com/v3/repos/collaborators/">Collaborators API</a>
     */
    Collaborators collaborators();
    /**
     * Get the Git API entry point.
     * @return Collaborators
     * @see <a href="https://developer.github.com/v3/git/">Git Data API</a>
     */
    Git git();
    /**
     * Get Starring API.
     * @return Stars
     * @see <a href="https://developer.github.com/v3/activity/starring/">Starring API</a>
     * @since 0.15
     */
    Stars stars();
    /**
     * Get Notifications API.
     * @return Stars
     * @see <a href="https://developer.github.com/v3/activity/notifications/">Notifications API</a>
     * @since 0.15
     */
    Notifications notifications();
    /**
     * Get languages for the specified repository.
     * @return Languages
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/repos/#list-languages">List languages</a>
     * @since 0.15
     */
    Iterable<Language> languages() throws IOException;
    /**
     * Get default branch.
     *
     * @return Default branch.
     * @throws IOException If there is any I/O problem.
     */
    Branch defaultBranch() throws IOException;
    /**
     * Lists the people that have starred the repository.
     * @return Lists the people that have starred the repository.
     */
    Stargazers stargazers();
    /**
     * Smart Repo with extra features.
     */
    @Immutable
    @ToString
    @Loggable(Loggable.DEBUG)
    @EqualsAndHashCode(of = {"repo", "jsn"})
    final class Smart implements Repo {
        /**
         * Encapsulated Repo.
         */
        private final transient Repo repo;
        /**
         * SmartJson object for convenient JSON parsing.
         */
        private final transient SmartJson jsn;
        /**
         * Public ctor.
         * @param rep Repo
         */
        public Smart(
            final Repo rep
        ) {
            this.repo = rep;
            this.jsn = new SmartJson(rep);
        }
        /**
         * Does this Repo actually exist in Github?
         * @return True if it exists, false otherwise.
         * @throws IOException If there is any I/O problem.
         */
        public boolean exists() throws IOException {
            return new Existence(this.repo).check();
        }
        /**
         * Does it have a description.
         * @return TRUE if description is present
         * @throws IOException If there is any I/O problem
         */
        public boolean hasDescription() throws IOException {
            return this.jsn.hasNotNull("description");
        }
        /**
         * Get its description.
         * @return Description
         * @throws IOException If there is any I/O problem
         */
        public String description() throws IOException {
            return this.jsn.text("description");
        }
        /**
         * Is it private?.
         * @return TRUE if it's private
         * @throws IOException If there is any I/O problem
         */
        public boolean isPrivate() throws IOException {
            return Boolean.parseBoolean(
                this.json()
                    .getOrDefault("private", JsonValue.FALSE)
                    .toString().replace("\"", "")
            );
        }
        @Override
        public Github github() {
            return this.repo.github();
        }
        @Override
        public Coordinates coordinates() {
            return this.repo.coordinates();
        }
        @Override
        public Issues issues() {
            return this.repo.issues();
        }
        @Override
        public Milestones milestones() {
            return this.repo.milestones();
        }
        @Override
        public Pulls pulls() {
            return this.repo.pulls();
        }
        @Override
        public Hooks hooks() {
            return this.repo.hooks();
        }
        @Override
        public IssueEvents issueEvents() {
            return this.repo.issueEvents();
        }
        @Override
        public Labels labels() {
            return this.repo.labels();
        }
        @Override
        public Assignees assignees() {
            return this.repo.assignees();
        }
        @Override
        public Releases releases() {
            return this.repo.releases();
        }
        @Override
        public DeployKeys keys() {
            return this.repo.keys();
        }
        @Override
        public Forks forks() {
            return this.repo.forks();
        }
        @Override
        public Contents contents() {
            return this.repo.contents();
        }
        @Override
        public Collaborators collaborators() {
            return this.repo.collaborators();
        }
        @Override
        public Git git() {
            return this.repo.git();
        }
        @Override
        public Stars stars() {
            return this.repo.stars();
        }
        @Override
        public Notifications notifications() {
            return this.repo.notifications();
        }
        @Override
        public Iterable<Language> languages() throws IOException {
            return this.repo.languages();
        }
        @Override
        public Branch defaultBranch() throws IOException {
            return this.repo.defaultBranch();
        }
        @Override
        public Stargazers stargazers() {
            throw new UnsupportedOperationException(
                "stargazers() not yet implemented"
            );
        }
        @Override
        public void patch(
            final JsonObject json
        ) throws IOException {
            this.repo.patch(json);
        }
        @Override
        public RepoCommits commits() {
            return this.repo.commits();
        }
        @Override
        public Branches branches() {
            return this.repo.branches();
        }
        @Override
        public JsonObject json() throws IOException {
            return this.repo.json();
        }
        @Override
        public int compareTo(final Repo repos) {
            return this.repo.compareTo(repos);
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.ParseException;
import java.util.Date;
import javax.json.Json;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
import lombok.ToString;
/**
 * Github pull request.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.3
 * @see <a href="https://developer.github.com/v3/pulls/">Pull Request API</a>
 * @checkstyle MultipleStringLiterals (500 lines)
 *
 */
@Immutable
@SuppressWarnings("PMD.TooManyMethods")
public interface Pull extends Comparable<Pull>, JsonReadable, JsonPatchable {
    /**
     * Repo we're in.
     * @return Repo
     */
    Repo repo();
    /**
     * Get its number.
     * @return Pull request number
     */
    int number();
    /**
     * Get its base ref.
     * @return Base ref
     * @throws IOException If there is any I/O problem
     */
    PullRef base() throws IOException;
    /**
     * Get its head ref.
     * @return Head ref
     * @throws IOException If there is any I/O problem
     */
    PullRef head() throws IOException;
    /**
     * Get all commits of the pull request.
     * @return Commits
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request">List Commits on a Pull Request</a>
     */
    Iterable<Commit> commits() throws IOException;
    /**
     * List all files of the pull request.
     * @return Files
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/pulls/#list-pull-requests-files">List Pull Request Files</a>
     */
    Iterable<JsonObject> files() throws IOException;
    /**
     * Merge it.
     * @param msg Commit message
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/pulls/#merge-a-pull-request-merge-buttontrade">Merge a Pull Request</a>
     */
    void merge(String msg)
        throws IOException;
    /**
     * Merge it.
     * @param msg Commit message
     * @param sha Optional SHA hash for head comparison
     * @return State of the Merge
     * @throws IOException IOException If there is any I/O problem
     */
    MergeState merge(String msg,
        String sha
    ) throws IOException;
    /**
     * Get Pull Comments.
     * @return Comments.
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/pulls/#link-relations">Link Relations - Review Comments</a>
     */
    PullComments comments() throws IOException;
    /**
     * Get Pull Checks.
     * @return Checks.
     * @throws IOException If there is any I/O problem.
     * @see <a href="https://developer.github.com/v3/checks/runs/">Checks API</a>
     * @since 1.6.0
     */
    Checks checks() throws IOException;
    /**
     * Smart pull request with extra features.
     */
    @Immutable
    @ToString
    @Loggable(Loggable.DEBUG)
    @EqualsAndHashCode(of = {"pull", "jsn"})
    final class Smart implements Pull {
        /**
         * Encapsulated pull request.
         */
        private final transient Pull pull;
        /**
         * SmartJson object for convenient JSON parsing.
         */
        private final transient SmartJson jsn;
        /**
         * Public ctor.
         * @param pll Pull request
         */
        public Smart(
            final Pull pll
        ) {
            this.pull = pll;
            this.jsn = new SmartJson(pll);
        }
        /**
         * Is it open?
         * @return TRUE if it's open
         * @throws IOException If there is any I/O problem
         */
        public boolean isOpen() throws IOException {
            return Issue.OPEN_STATE.equals(this.state());
        }
        /**
         * Get its state.
         * @return State of pull request
         * @throws IOException If there is any I/O problem
         */
        public String state() throws IOException {
            return this.jsn.text("state");
        }
        /**
         * Change its state.
         * @param state State of pull request
         * @throws IOException If there is any I/O problem
         */
        public void state(
            final String state
        ) throws IOException {
            this.pull.patch(
                Json.createObjectBuilder().add("state", state).build()
            );
        }
        /**
         * Get its title.
         * @return Title of pull request
         * @throws IOException If there is any I/O problem
         */
        public String title() throws IOException {
            return this.jsn.text("title");
        }
        /**
         * Change its title.
         * @param text Title of pull request
         * @throws IOException If there is any I/O problem
         */
        public void title(
            final String text
        ) throws IOException {
            this.pull.patch(
                Json.createObjectBuilder().add("title", text).build()
            );
        }
        /**
         * Get its body.
         * @return Body of pull request
         * @throws IOException If there is any I/O problem
         */
        public String body() throws IOException {
            return this.jsn.text("body");
        }
        /**
         * Change its body.
         * @param text Body of pull request
         * @throws IOException If there is any I/O problem
         */
        public void body(
            final String text
        ) throws IOException {
            this.pull.patch(
                Json.createObjectBuilder().add("body", text).build()
            );
        }
        /**
         * Get its URL.
         * @return URL of pull request
         * @throws IOException If there is any I/O problem
         */
        public URL url() throws IOException {
            try {
                return new URI(this.jsn.text("url")).toURL();
            } catch (final URISyntaxException ex) {
                throw new IllegalArgumentException(ex);
            }
        }
        /**
         * Get its HTML URL.
         * @return URL of pull request
         * @throws IOException If there is any I/O problem
         */
        public URL htmlUrl() throws IOException {
            try {
                return new URI(this.jsn.text("html_url")).toURL();
            } catch (final URISyntaxException ex) {
                throw new IllegalArgumentException(ex);
            }
        }
        /**
         * When this pull request was created.
         * @return Date of creation
         * @throws IOException If there is any I/O problem
         */
        public Date createdAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("created_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IllegalStateException(ex);
            }
        }
        /**
         * When this pull request was updated.
         * @return Date of update
         * @throws IOException If there is any I/O problem
         */
        public Date updatedAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("updated_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IllegalStateException(ex);
            }
        }
        /**
         * When this pull request was closed.
         * @return Date of closing
         * @throws IOException If there is any I/O problem
         */
        public Date closedAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("closed_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IllegalStateException(ex);
            }
        }
        /**
         * When this pull request was merged.
         * @return Date of merging
         * @throws IOException If there is any I/O problem
         */
        public Date mergedAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("merged_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IllegalStateException(ex);
            }
        }
        /**
         * Get its author.
         * @return Author of pull request (who submitted it)
         * @throws IOException If there is any I/O problem
         */
        public User author() throws IOException {
            return this.pull.repo().github().users().get(
                this.jsn.value(
                    "user", JsonObject.class
                ).getString("login")
            );
        }
        /**
         * Get an issue where the pull request is submitted.
         * @return Issue
         */
        public Issue issue() {
            return this.pull.repo().issues().get(this.pull.number());
        }
        /**
         * Get comments count.
         * @return Count of comments
         * @throws IOException If there is any I/O problem
         * @since 0.8
         */
        public int commentsCount() throws IOException {
            return this.jsn.number("comments");
        }
        @Override
        public Repo repo() {
            return this.pull.repo();
        }
        @Override
        public int number() {
            return this.pull.number();
        }
        @Override
        public Iterable<Commit> commits() throws IOException {
            return this.pull.commits();
        }
        @Override
        public Iterable<JsonObject> files() throws IOException {
            return this.pull.files();
        }
        @Override
        public void merge(
            final String msg
        ) throws IOException {
            this.pull.merge(msg);
        }
        @Override
        public MergeState merge(
            final String msg,
            final String sha
        )
            throws IOException {
            return this.pull.merge(msg, sha);
        }
        @Override
        public PullComments comments() throws IOException {
            return this.pull.comments();
        }
        /**
         * Retrieve a PR check runs.
         * @return Checks
         * @throws IOException If there is any I/O problem.
         * @since 1.6.0
         */
        @Override
        public Checks checks() throws IOException {
            return this.pull.checks();
        }
        @Override
        public JsonObject json() throws IOException {
            return this.pull.json();
        }
        @Override
        public void patch(
            final JsonObject json
        ) throws IOException {
            this.pull.patch(json);
        }
        @Override
        public int compareTo(
            final Pull obj
        ) {
            return this.pull.compareTo(obj);
        }
        @Override
        public PullRef base() throws IOException {
            return this.pull.base();
        }
        @Override
        public PullRef head() throws IOException {
            return this.pull.head();
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import javax.json.JsonNumber;
import javax.json.JsonObject;
import javax.json.JsonString;
import javax.json.JsonValue;
import javax.json.JsonValue.ValueType;
import lombok.EqualsAndHashCode;
import lombok.ToString;
/**
 * Smart JSON (supplementary help class).
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.5
 */
@Immutable
@ToString
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = "object")
@SuppressWarnings("PMD.AvoidDuplicateLiterals")
final class SmartJson {
    /**
     * Encapsulated JSON object.
     */
    private final transient JsonReadable object;
    /**
     * Public ctor.
     * @param obj Readable object
     */
    SmartJson(final JsonReadable obj) {
        this.object = obj;
    }
    /**
     * Get its property as string.
     * @param name Name of the property
     * @return Value
     * @throws IOException If there is any I/O problem
     */
    public String text(
        final String name
    ) throws IOException {
        return this.value(name, JsonString.class).getString();
    }
    /**
     * Get its property as number.
     * @param name Name of the property
     * @return Value
     * @throws IOException If there is any I/O problem
     */
    public int number(
        final String name
    ) throws IOException {
        return this.value(name, JsonNumber.class).intValue();
    }
    /**
     * Get JSON.
     * @return JSON
     * @throws IOException If there is any I/O problem
     * @since 0.14
     */
    public JsonObject json() throws IOException {
        return this.object.json();
    }
    /**
     * Get its property as custom type.
     * @param name Name of the property
     * @param type Type of result expected
     * @return Value
     * @throws IOException If there is any I/O problem
     * @param <T> Type expected
     */
    public <T> T value(
        final String name,
        final Class<T> type
    ) throws IOException {
        final JsonObject json = this.json();
        if (!json.containsKey(name)) {
            throw new IllegalStateException(
                String.format(
                    "'%s' is absent in JSON: %s", name, json
                )
            );
        }
        final JsonValue value = json.get(name);
        if (value == null) {
            throw new IllegalStateException(
                String.format(
                    "'%s' is NULL in %s", name, json
                )
            );
        }
        if (value.getClass().isAssignableFrom(type)) {
            throw new IllegalStateException(
                String.format(
                    "'%s' is not of type %s", name, type
                )
            );
        }
        return type.cast(value);
    }
    /**
     * Checks if a certain key is present
     *  AND its ValueType isn't ValueType.NULL.
     * @param name Name of the key which ValueType should be checked.
     * @return Returns <code>true</code> if key <code>name</code> is present
     *  and its ValueType isn't ValueType.NULL, <code>false</code> otherwise.
     * @throws IOException If there is any I/O problem
     */
    public boolean hasNotNull(
        final String name
    ) throws IOException {
        final JsonValue value = this.object.json().get(name);
        return value != null
            && !ValueType.NULL.equals(value.getValueType());
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import javax.json.Json;
import javax.json.JsonArray;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
import lombok.ToString;
/**
 * Github issue.
 *
 * <p>Use a supplementary "smart" decorator to get other properties
 * from an issue, for example:
 *
 * <pre> Issue.Smart issue = new Issue.Smart(origin);
 * if (issue.isOpen()) {
 *   issue.close();
 * }</pre>
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.1
 * @see <a href="https://developer.github.com/v3/issues/">Issues API</a>
 * @todo #1462:30min Implement lock reason validation. According to
 *  documentation lock reason must belong to a specific value domain. This
 *  validation must be performed in lock method and tests must be added to
 *  ensure that the class is accepting the correct values and rejecting the
 *  wrong ones.
 * @checkstyle MultipleStringLiterals (500 lines)
 */
@Immutable
@SuppressWarnings
    (
        {
            "PMD.TooManyMethods", "PMD.GodClass", "PMD.ExcessivePublicCount"
        }
    )
public interface Issue extends Comparable<Issue>, JsonReadable, JsonPatchable {
    /**
     * Issue state.
     */
    String OPEN_STATE = "open";
    /**
     * Issue state.
     */
    String CLOSED_STATE = "closed";
    /**
     * Repository we're in.
     * @return Repo
     */
    Repo repo();
    /**
     * Get its number.
     * @return Issue number
     */
    int number();
    /**
     * Get all comments of the issue.
     * @return Comments
     * @see <a href="https://developer.github.com/v3/issues/comments/">Issue Comments API</a>
     */
    Comments comments();
    /**
     * Get all labels of the issue.
     * @return Labels
     * @see <a href="https://developer.github.com/v3/issues/labels/">Labels API</a>
     */
    IssueLabels labels();
    /**
     * Get all events of the issue.
     * @return Events
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/issues/events/#list-events-for-an-issue">List Events for an Issue</a>
     */
    Iterable<Event> events() throws IOException;
    /**
     * Does this issue exist in Github?
     * @return TRUE if this issue exists
     * @throws IOException If there is any I/O problem
     */
    boolean exists() throws IOException;
    /**
     * Adds the reaction to the issue.
     * @param reaction Reaction to be added.
     * @throws IOException If there is any I/O problem
     */
    void react(Reaction reaction) throws IOException;
    /**
     * List the reactions of the issue.
     * @return Issue reactions.
     */
    Iterable<Reaction> reactions();
    /**
     * Locks the issue.
     * @param reason Lock reason
     */
    void lock(String reason);
    /**
     * Unlocks the issue.
     */
    void unlock();
    /**
     * The issue conversation is locked?
     * @return If the issue is locked.
     */
    boolean isLocked();
    /**
     * Smart Issue with extra features.
     */
    @Immutable
    @ToString
    @Loggable(Loggable.DEBUG)
    @EqualsAndHashCode(of = {"issue", "jsn"})
    final class Smart implements Issue {
        /**
         * Encapsulated issue.
         */
        private final transient Issue issue;
        /**
         * SmartJson object for convenient JSON parsing.
         */
        private final transient SmartJson jsn;
        /**
         * Public ctor.
         * @param iss Issue
         */
        public Smart(final Issue iss) {
            this.issue = iss;
            this.jsn = new SmartJson(iss);
        }
        /**
         * Get its author.
         * @return Author of issue (who submitted it)
         * @throws IOException If there is any I/O problem
         */
        public User author() throws IOException {
            return this.issue.repo().github().users().get(
                this.jsn.value(
                    "user", JsonObject.class
                ).getString("login")
            );
        }
        /**
         * Is it open?
         * @return TRUE if it's open
         * @throws IOException If there is any I/O problem
         */
        public boolean isOpen() throws IOException {
            return Issue.OPEN_STATE.equals(this.state());
        }
        /**
         * Open it (make sure it's open).
         * @throws IOException If there is any I/O problem
         */
        public void open() throws IOException {
            this.state(Issue.OPEN_STATE);
        }
        /**
         * Close it (make sure it's closed).
         * @throws IOException If there is any I/O problem
         */
        public void close() throws IOException {
            this.state(Issue.CLOSED_STATE);
        }
        /**
         * Get its state.
         * @return State of issue
         * @throws IOException If there is any I/O problem
         */
        public String state() throws IOException {
            return this.jsn.text("state");
        }
        /**
         * Change its state.
         * @param state State of issue
         * @throws IOException If there is any I/O problem
         */
        public void state(final String state) throws IOException {
            this.issue.patch(
                Json.createObjectBuilder().add("state", state).build()
            );
        }
        /**
         * Get its title.
         * @return Title of issue
         * @throws IOException If there is any I/O problem
         */
        public String title() throws IOException {
            return this.jsn.text("title");
        }
        /**
         * Change its title.
         * @param text Title of issue
         * @throws IOException If there is any I/O problem
         */
        public void title(final String text) throws IOException {
            this.issue.patch(
                Json.createObjectBuilder().add("title", text).build()
            );
        }
        /**
         * Get its body.
         * @return Body of issue
         * @throws IOException If there is any I/O problem
         */
        public String body() throws IOException {
            return this.jsn.text("body");
        }
        /**
         * Change its body.
         * @param text Body of issue
         * @throws IOException If there is any I/O problem
         */
        public void body(final String text) throws IOException {
            this.issue.patch(
                Json.createObjectBuilder().add("body", text).build()
            );
        }
        /**
         * Has body?
         * @return TRUE if body exists
         * @throws IOException If there is any I/O problem
         * @since 0.22
         */
        public boolean hasBody() throws IOException {
            return this.jsn.hasNotNull("body");
        }
        /**
         * Has assignee?
         * @return TRUE if assignee exists
         * @throws IOException If there is any I/O problem
         */
        public boolean hasAssignee() throws IOException {
            return this.jsn.hasNotNull("assignee");
        }
        /**
         * Get its assignee.
         * @return User Assignee of issue
         * @throws IOException If there is any I/O problem
         */
        public User assignee() throws IOException {
            if (!this.hasAssignee()) {
                throw new IllegalArgumentException(
                    String.format(
                        "issue #%d doesn't have an assignee, use hasAssignee()",
                        this.number()
                    )
                );
            }
            return this.issue.repo().github().users().get(
                this.jsn.value(
                    "assignee", JsonObject.class
                ).getString("login")
            );
        }
        /**
         * Assign this issue to another user.
         * @param login Login of the user to assign to
         * @throws IOException If there is any I/O problem
         */
        public void assign(final String login) throws IOException {
            this.issue.patch(
                Json.createObjectBuilder().add("assignee", login).build()
            );
        }
        /**
         * Get its URL.
         * @return URL of issue
         * @throws IOException If there is any I/O problem
         */
        public URL url() throws IOException {
            try {
                return new URI(this.jsn.text("url")).toURL();
            } catch (final URISyntaxException ex) {
                throw new IllegalArgumentException(ex);
            }
        }
        /**
         * Get its HTML URL.
         * @return URL of issue
         * @throws IOException If there is any I/O problem
         */
        public URL htmlUrl() throws IOException {
            try {
                return new URI(this.jsn.text("html_url")).toURL();
            } catch (final URISyntaxException ex) {
                throw new IllegalArgumentException(ex);
            }
        }
        /**
         * When this issue was created.
         * @return Date of creation
         * @throws IOException If there is any I/O problem
         */
        public Date createdAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("created_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IllegalStateException(ex);
            }
        }
        /**
         * When this issue was closed.
         * @return Date of creation
         * @throws IOException If there is any I/O problem
         * @since 0.34
         */
        public Date closedAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("closed_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IllegalStateException(ex);
            }
        }
        /**
         * When this issue was updated.
         * @return Date of update
         * @throws IOException If there is any I/O problem
         */
        public Date updatedAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("updated_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IllegalStateException(ex);
            }
        }
        /**
         * Is it a pull request?
         * @return TRUE if it is a pull request
         * @throws IOException If there is any I/O problem
         */
        public boolean isPull() throws IOException {
            return this.json().containsKey("pull_request")
                && !this.jsn.value("pull_request", JsonObject.class)
                .isNull("html_url");
        }
        /**
         * Get pull request.
         * @return Pull request
         * @throws IOException If there is any I/O problem
         */
        public Pull pull() throws IOException {
            final String url = this.jsn.value(
                "pull_request", JsonObject.class
            ).getString("html_url");
            return this.issue.repo().pulls().get(
                Integer.parseInt(url.substring(url.lastIndexOf('/') + 1))
            );
        }
        /**
         * Get the latest event of a given type.
         * Throws {@link IllegalStateException} if the issue has no events of
         * the given type.
         * @param type Type of event
         * @return Latest event of the given type
         * @throws IOException If there is any I/O problem
         */
        public Event latestEvent(final String type) throws IOException {
            final Iterable<Event.Smart> events = new Smarts<>(
                this.issue.events()
            );
            Event found = null;
            for (final Event.Smart event : events) {
                if (event.type().equals(type) && (found == null
                    || found.number() < event.number())) {
                    found = event;
                }
            }
            if (found == null) {
                throw new IllegalStateException(
                    String.format(
                        "event of type '%s' not found in issue #%d",
                        type, this.issue.number()
                    )
                );
            }
            return found;
        }
        /**
         * Get read-only labels.
         * @return Collection of labels
         * @throws IOException If there is any I/O problem
         * @since 0.6.2
         */
        public IssueLabels roLabels() throws IOException {
            final Collection<JsonObject> array =
                this.jsn.value("labels", JsonArray.class)
                    .getValuesAs(JsonObject.class);
            final Collection<Label> labels = new ArrayList<>(array.size());
            for (final JsonObject obj : array) {
                labels.add(
                    new Label.Unmodified(
                        this.repo(),
                        obj.toString()
                    )
                );
            }
            // @checkstyle AnonInnerLength (1 line)
            return new IssueLabels() {
                @Override
                public Issue issue() {
                    return Issue.Smart.this;
                }
                @Override
                public void add(
                    final Iterable<String> labels) {
                    throw new UnsupportedOperationException(
                        "The issue is read-only."
                    );
                }
                @Override
                public void replace(
                    final Iterable<String> labels) {
                    throw new UnsupportedOperationException(
                        "The issue is read-only."
                    );
                }
                @Override
                public Iterable<Label> iterate() {
                    return labels;
                }
                @Override
                public void remove(
                    final String name) {
                    throw new UnsupportedOperationException(
                        "This issue is read-only."
                    );
                }
                @Override
                public void clear() {
                    throw new UnsupportedOperationException(
                        "This issue is read-only."
                    );
                }
            };
        }
        /**
         * Does issue have milestone?
         * @return True if has
         * @throws IOException If fails
         */
        public boolean hasMilestone() throws IOException {
            return this.jsn.hasNotNull("milestone");
        }
        /**
         * Get milestone for this issue.
         * @return Milestone
         * @throws IOException If fails
         */
        public Milestone milestone() throws IOException {
            return this.repo().milestones().get(
                this.jsn.value("milestone", JsonObject.class)
                    .getInt("number")
            );
        }
        /**
         * Add issueto milestone.
         * @param milestone Milestone
         * @throws IOException If fails
         */
        public void milestone(final Milestone milestone) throws IOException {
            this.patch(
                Json.createObjectBuilder().add(
                    "milestone", milestone.number()
                ).build()
            );
        }
        @Override
        public Repo repo() {
            return this.issue.repo();
        }
        @Override
        public int number() {
            return this.issue.number();
        }
        @Override
        public Comments comments() {
            return this.issue.comments();
        }
        @Override
        public IssueLabels labels() {
            return this.issue.labels();
        }
        @Override
        public Iterable<Event> events() throws IOException {
            return this.issue.events();
        }
        @Override
        public JsonObject json() throws IOException {
            return this.issue.json();
        }
        @Override
        public void patch(final JsonObject json) throws IOException {
            this.issue.patch(json);
        }
        @Override
        public int compareTo(final Issue obj) {
            return this.issue.compareTo(obj);
        }
        @Override
        public boolean exists() throws IOException {
            return new Existence(this.issue).check();
        }
        @Override
        public void react(final Reaction reaction) {
            throw new UnsupportedOperationException("react() not implemented");
        }
        @Override
        public Collection<Reaction> reactions() {
            throw new UnsupportedOperationException(
                "reactions() not implemented"
            );
        }
        @Override
        public void lock(final String reason) {
            throw new UnsupportedOperationException("lock not implemented");
        }
        @Override
        public void unlock() {
            throw new UnsupportedOperationException("unlock not implemented");
        }
        @Override
        public boolean isLocked() {
            throw new UnsupportedOperationException("isLocked not implemented");
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import lombok.EqualsAndHashCode;
import lombok.ToString;
/**
 * Github labels of an issue.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.1
 * @see <a href="https://developer.github.com/v3/issues/labels/">Labels API</a>
 */
@Immutable
@SuppressWarnings("PMD.TooManyMethods")
public interface IssueLabels {
    /**
     * The issue we're in.
     * @return Issue
     */
    Issue issue();
    /**
     * Add new labels.
     * @param labels The labels to add
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue">Add labels to an issue</a>
     */
    void add(Iterable<String> labels) throws IOException;
    /**
     * Replace all labels.
     * @param labels The labels to save
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/issues/labels/#replace-all-labels-for-an-issue">Replace all labels for an issue</a>
     */
    void replace(Iterable<String> labels) throws IOException;
    /**
     * Iterate them all.
     * @return Iterator of labels
     * @see <a href="https://developer.github.com/v3/issues/labels/#list-labels-on-an-issue">List Labels on an Issue</a>
     */
    Iterable<Label> iterate();
    /**
     * Remove label by name.
     * @param name Name of the label to remove
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/issues/labels/#remove-a-label-from-an-issue">Remove a Label from an Issue</a>
     */
    void remove(String name) throws IOException;
    /**
     * Remove all labels.
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue">Remove all labels from an issue</a>
     */
    void clear() throws IOException;
    /**
     * Smart IssueLabels with extra features.
     */
    @Immutable
    @ToString
    @Loggable(Loggable.DEBUG)
    @EqualsAndHashCode(of = "labels")
    final class Smart implements IssueLabels {
        /**
         * Encapsulated labels.
         */
        private final transient IssueLabels labels;
        /**
         * Public ctor.
         * @param lbl Labels
         */
        public Smart(final IssueLabels lbl) {
            this.labels = lbl;
        }
        /**
         * Label exists?
         * @param name Name of the label
         * @return TRUE if it exists
         */
        public boolean contains(final String name) {
            boolean contains = false;
            for (final Label label : this.labels.iterate()) {
                if (label.name().equals(name)) {
                    contains = true;
                    break;
                }
            }
            return contains;
        }
        /**
         * Get label by name (runtime exception if absent).
         * @param name Name of the label
         * @return Label found (exception if not found)
         * @since 0.7
         */
        public Label get(final String name) {
            Label label = null;
            int count = 0;
            for (final Label opt : this.labels.iterate()) {
                if (opt.name().equals(name)) {
                    label = opt;
                    break;
                }
                ++count;
            }
            if (label == null) {
                throw new IllegalArgumentException(
                    String.format(
                        // @checkstyle LineLength (1 line)
                        "label '%s' not found among %d others, use #contains() first",
                        name, count
                    )
                );
            }
            return label;
        }
        /**
         * Add label if it is absent, don't touch its color if exists.
         * @param name Name of the label
         * @return TRUE if it was added
         * @throws IOException If there is any I/O problem
         */
        public boolean addIfAbsent(final String name) throws IOException {
            final boolean added;
            if (this.contains(name)) {
                added = false;
            } else {
                new Labels.Smart(this.labels.issue().repo().labels())
                    .createOrGet(name);
                this.labels.add(Collections.singletonList(name));
                added = true;
            }
            return added;
        }
        /**
         * Add label if it is absent, and set its color in any case.
         * @param name Name of the label
         * @param color Color to set
         * @return TRUE if it was added
         * @throws IOException If there is any I/O problem
         * @since 0.7
         */
        public boolean addIfAbsent(
            final String name, final String color
        ) throws IOException {
            Label label = null;
            for (final Label opt : new Bulk<>(this.labels.iterate())) {
                if (opt.name().equals(name)) {
                    label = opt;
                    break;
                }
            }
            boolean added = false;
            if (label == null) {
                added = true;
                label = new Labels.Smart(this.labels.issue().repo().labels())
                    .createOrGet(name, color);
                this.labels.add(Collections.singletonList(name));
            }
            final Label.Smart smart = new Label.Smart(label);
            if (!smart.color().equals(color)) {
                smart.color(color);
            }
            return added;
        }
        /**
         * Select all labels with the given color.
         * @param color Color
         * @return Collection of labels with the provided color
         * @throws IOException If there is any I/O problem
         * @since 0.7
         */
        public Collection<Label> findByColor(final String color)
            throws IOException {
            final Collection<Label> found = new LinkedList<>();
            for (final Label label : this.labels.iterate()) {
                if (new Label.Smart(label).color().equals(color)) {
                    found.add(label);
                }
            }
            return found;
        }
        /**
         * Remove label if it exists (do nothing otherwise).
         * @param name Label to remove
         * @return TRUE if it was removed, FALSE otherwise
         * @throws IOException If there is any I/O problem
         * @since 0.7
         */
        public boolean removeIfExists(final String name)
            throws IOException {
            boolean removed = false;
            for (final Label label : this.labels.iterate()) {
                if (label.name().equals(name)) {
                    this.remove(name);
                    removed = true;
                    break;
                }
            }
            return removed;
        }
        @Override
        public Issue issue() {
            return this.labels.issue();
        }
        @Override
        public void add(final Iterable<String> names) throws IOException {
            this.labels.add(names);
        }
        @Override
        public void replace(final Iterable<String> names) throws IOException {
            this.labels.replace(names);
        }
        @Override
        public Iterable<Label> iterate() {
            return this.labels.iterate();
        }
        @Override
        public void remove(final String name) throws IOException {
            this.labels.remove(name);
        }
        @Override
        public void clear() throws IOException {
            this.labels.clear();
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import java.io.IOException;
import java.util.Date;
/**
 * Github comments.
 *
 * <p>Use this class to get access to all comments in an issue, for example:
 *
 * <pre> issue = // ... get it somewhere
 * Comments comments = issue.comments();
 * Comment comment = comments.post("Hi, how are you?");</pre>
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.1
 * @see <a href="https://developer.github.com/v3/issues/comments/">Issue Comments API</a>
 */
@Immutable
public interface Comments {
    /**
     * The issue we're in.
     * @return Issue
     */
    Issue issue();
    /**
     * Get comment by number.
     * @param number Comment number
     * @return Comment
     * @see <a href="https://developer.github.com/v3/issues/comments/#get-a-single-comment">Get a Single Comment</a>
     */
    Comment get(long number);
    /**
     * Iterate them all.
     * @param since Since when? Just give {@code new Date(0)} if you want
     *  all comments.
     * @return All comments
     * @see <a href="https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue">List Comments on an Issue</a>
     */
    Iterable<Comment> iterate(Date since);
    /**
     * Post new comment.
     * @param text Text of comment to post in Markdown format
     * @return Comment
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/issues/comments/#create-a-comment">Create a Comment</a>
     */
    Comment post(String text) throws IOException;
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.ParseException;
import java.util.Collection;
import java.util.Date;
import javax.json.Json;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
import lombok.ToString;
/**
 * Github issue comment.
 *
 * <p>Comment implements {@link JsonReadable}, that's how you can get its full
 * details in JSON format. For example, to get its author's Github login
 * you get the entire JSON and then gets its element:
 *
 * <pre>String login = comment.json()
 *   .getJsonObject("user")
 *   .getString("login");</pre>
 *
 * <p>However, it's better to use a supplementary "smart" decorator, which
 * automates most of these operations:
 *
 * <pre>String login = new Comment.Smart(comment).author().login();</pre>
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @author Paulo Lobo (pauloeduardolobo@gmail.com)
 * @version $Id$
 * @since 0.1
 * @see <a href="https://developer.github.com/v3/issues/comments/">Issue Comments API</a>
 * @checkstyle MultipleStringLiterals (500 lines)
 */
@Immutable
@SuppressWarnings("PMD.TooManyMethods")
public interface Comment
    extends Comparable<Comment>, JsonReadable, JsonPatchable {
    /**
     * The issue it's in.
     * @return Owner of the comment
     */
    Issue issue();
    /**
     * Number.
     * @return Comment number
     */
    long number();
    /**
     * Delete the comment.
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/issues/comments/#delete-a-comment">Delete a Comment</a>
     */
    void remove() throws IOException;
    /**
     * Adds the reaction to the comment.
     * @param reaction Reaction to be added.
     * @throws IOException In case something goes wrong.
     */
    void react(Reaction reaction) throws IOException;
    /**
     * List the reactions of the comment.
     * @return Comment reactions.
     */
    Iterable<Reaction> reactions();
    /**
     * Smart comment with additional features.
     */
    @Immutable
    @ToString
    @Loggable(Loggable.DEBUG)
    @EqualsAndHashCode(of = { "comment", "jsn" })
    final class Smart implements Comment {
        /**
         * Encapsulated comment.
         */
        private final transient Comment comment;
        /**
         * SmartJson object for convenient JSON parsing.
         */
        private final transient SmartJson jsn;
        /**
         * Public ctor.
         * @param cmt Comment
         */
        public Smart(final Comment cmt) {
            this.comment = cmt;
            this.jsn = new SmartJson(cmt);
        }
        /**
         * Get its author.
         * @return Author of comment
         * @throws IOException If there is any I/O problem
         */
        public User author() throws IOException {
            return this.comment.issue().repo().github().users().get(
                this.comment.json().getJsonObject("user").getString("login")
            );
        }
        /**
         * Get its body.
         * @return Body of comment
         * @throws IOException If there is any I/O problem
         */
        public String body() throws IOException {
            return this.jsn.text("body");
        }
        /**
         * Change comment body.
         * @param text Body of comment
         * @throws IOException If there is any I/O problem
         */
        public void body(final String text) throws IOException {
            this.comment.patch(
                Json.createObjectBuilder().add("body", text).build()
            );
        }
        /**
         * Get its URL.
         * @return URL of comment
         * @throws IOException If there is any I/O problem
         */
        public URL url() throws IOException {
            try {
                return new URI(this.jsn.text("url")).toURL();
            } catch (final URISyntaxException ex) {
                throw new IllegalArgumentException(ex);
            }
        }
        /**
         * When this comment was created.
         * @return Date of creation
         * @throws IOException If there is any I/O problem
         */
        public Date createdAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("created_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IOException(ex);
            }
        }
        /**
         * When this comment was updated last time.
         * @return Date of update
         * @throws IOException If there is any I/O problem
         */
        public Date updatedAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("updated_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IOException(ex);
            }
        }
        @Override
        public Issue issue() {
            return this.comment.issue();
        }
        @Override
        public long number() {
            return this.comment.number();
        }
        @Override
        public void remove() throws IOException {
            this.comment.remove();
        }
        @Override
        public void react(final Reaction reaction) {
            throw new UnsupportedOperationException("react() not implemented");
        }
        @Override
        public Collection<Reaction> reactions() {
            throw new UnsupportedOperationException(
                "reactions() not implemented"
            );
        }
        @Override
        public JsonObject json() throws IOException {
            return this.comment.json();
        }
        @Override
        public void patch(final JsonObject json) throws IOException {
            this.comment.patch(json);
        }
        @Override
        public int compareTo(final Comment obj) {
            return this.comment.compareTo(obj);
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.http.Request;
import com.jcabi.http.response.JsonResponse;
import com.jcabi.http.response.RestResponse;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.util.Date;
import javax.json.Json;
import javax.json.JsonStructure;
import lombok.EqualsAndHashCode;
/**
 * Github comments.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.1
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = { "request", "owner" })
final class RtComments implements Comments {
    /**
     * API entry point.
     */
    private final transient Request entry;
    /**
     * RESTful request.
     */
    private final transient Request request;
    /**
     * Owner of comments.
     */
    private final transient Issue owner;
    /**
     * Public ctor.
     * @param req Request
     * @param issue Issue
     */
    RtComments(final Request req, final Issue issue) {
        this.entry = req;
        final Coordinates coords = issue.repo().coordinates();
        this.request = this.entry.uri()
            .path("/repos")
            .path(coords.user())
            .path(coords.repo())
            .path("/issues")
            .path(Integer.toString(issue.number()))
            .path("/comments")
            .back();
        this.owner = issue;
    }
    @Override
    public String toString() {
        return this.request.uri().get().toString();
    }
    @Override
    public Issue issue() {
        return this.owner;
    }
    @Override
    public Comment get(final long number) {
        return new RtComment(this.entry, this.owner, number);
    }
    @Override
    public Comment post(final String text) throws IOException {
        final JsonStructure json = Json.createObjectBuilder()
            .add("body", text)
            .build();
        return this.get(
            this.request.method(Request.POST)
                .body().set(json).back()
                .fetch()
                .as(RestResponse.class)
                .assertStatus(HttpURLConnection.HTTP_CREATED)
                .as(JsonResponse.class)
                // @checkstyle MultipleStringLiterals (1 line)
                .json().readObject().getJsonNumber("id").longValue()
        );
    }
    @Override
    public Iterable<Comment> iterate(final Date since) {
        return new RtPagination<>(
            this.request.uri()
                .queryParam("since", new Github.Time(since))
                .back(),
            object -> this.get(object.getJsonNumber("id").longValue())
        );
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github.safe;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.github.Comment;
import com.jcabi.github.Issue;
import com.jcabi.github.Reaction;
import com.jcabi.github.mock.MkGithub;
import com.jcabi.log.Logger;
import java.io.IOException;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
/**
 * Safe comment.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @author Paulo Lobo (pauloeduardolobo@gmail.com)
 * @version $Id$
 * @since 0.34
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = "origin")
public final class SfComment implements Comment {
    /**
     * Original comment.
     */
    private final transient Comment origin;
    /**
     * Public ctor.
     * @param cmt The original comment
     */
    public SfComment(final Comment cmt) {
        this.origin = cmt;
    }
    @Override
    public String toString() {
        return this.origin.toString();
    }
    @Override
    public Issue issue() {
        return this.origin.issue();
    }
    @Override
    public long number() {
        return this.origin.number();
    }
    @Override
    public void remove() throws IOException {
        try {
            this.origin.remove();
        } catch (final AssertionError ex) {
            Logger.warn(this, "Failed to remove comment: %[exception]s", ex);
        }
    }
    @Override
    public void react(final Reaction reaction) throws IOException {
        this.origin.react(reaction);
    }
    @Override
    public Iterable<Reaction> reactions() {
        return this.origin.reactions();
    }
    @Override
    public int compareTo(final Comment cmt) {
        return this.origin.compareTo(cmt);
    }
    @Override
    public void patch(final JsonObject json) throws IOException {
        try {
            this.origin.patch(json);
        } catch (final AssertionError ex) {
            Logger.warn(this, "Failed to path comment: %[exception]s", ex);
        }
    }
    @Override
    public JsonObject json() throws IOException {
        JsonObject json;
        try {
            json = this.origin.json();
        } catch (final AssertionError ex) {
            final String author = new Issue.Smart(
                new SfIssue(this.origin.issue())
            ).author().login();
            json = new MkGithub(author).randomRepo()
                .issues().create("", "")
                .comments().post("deleted comment").json();
            Logger.warn(this, "failed to fetch comment: %[exception]s", ex);
        }
        return json;
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.http.Request;
import com.jcabi.http.response.RestResponse;
import java.io.IOException;
import java.net.HttpURLConnection;
import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonStructure;
import lombok.EqualsAndHashCode;
/**
 * Github comment.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @author Paulo Lobo (pauloeduardolobo@gmail.com)
 * @version $Id$
 * @since 0.1
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = { "request", "owner", "num" })
final class RtComment implements Comment {
    /**
     * Content field name.
     */
    private static final String CONTENT = "content";
    /**
     * RESTful request.
     */
    private final transient Request request;
    /**
     * Issue we're in.
     */
    private final transient Issue owner;
    /**
     * Comment number.
     */
    private final transient long num;
    /**
     * Public ctor.
     * @param req RESTful request
     * @param issue Owner of this comment
     * @param number Number of the get
     */
    RtComment(final Request req, final Issue issue, final long number) {
        final Coordinates coords = issue.repo().coordinates();
        this.request = req.uri()
            .path("/repos")
            .path(coords.user())
            .path(coords.repo())
            .path("/issues")
            .path("/comments")
            .path(Long.toString(number))
            .back();
        this.owner = issue;
        this.num = number;
    }
    @Override
    public String toString() {
        return this.request.uri().get().toString();
    }
    @Override
    public Issue issue() {
        return this.owner;
    }
    @Override
    public long number() {
        return this.num;
    }
    @Override
    public void remove() throws IOException {
        this.request.method(Request.DELETE).fetch()
            .as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);
    }
    @Override
    public JsonObject json() throws IOException {
        return new RtJson(this.request).fetch();
    }
    @Override
    public void patch(final JsonObject json) throws IOException {
        new RtJson(this.request).patch(json);
    }
    @Override
    public int compareTo(
        final Comment comment
    ) {
        return Long.compare(this.number(), comment.number());
    }
    @Override
    public void react(final Reaction reaction) throws IOException {
        final JsonStructure json = Json.createObjectBuilder()
            .add(RtComment.CONTENT, reaction.type())
            .build();
        this.request.method(Request.POST)
            .body().set(json).back()
            .fetch().as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_OK);
    }
    @Override
    public Iterable<Reaction> reactions() {
        return new RtPagination<>(
            this.request.uri().path("/reactions").back(),
            object -> new Reaction.Simple(object.getString(RtComment.CONTENT))
        );
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import java.io.IOException;
import java.util.EnumMap;
import java.util.Map;
/**
 * Github issues.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @author Chris Rebert (github@chrisrebert.com)
 * @version $Id$
 * @since 0.1
 * @see <a href="https://developer.github.com/v3/issues/">Issues API</a>
 */
@Immutable
public interface Issues {
    /**
     * Owner of them.
     * @return Repo
     */
    Repo repo();
    /**
     * Get specific issue by number.
     * @param number Issue number
     * @return Issue
     * @see <a href="https://developer.github.com/v3/issues/#get-a-single-issue">Get a Single Issue</a>
     */
    Issue get(int number);
    /**
     * Create new issue.
     * @param title Title
     * @param body Body of it
     * @return Issue just created
     * @throws IOException If there is any I/O problem
     * @see <a href="https://developer.github.com/v3/issues/#create-an-issue">Create an Issue</a>
     */
    Issue create(String title, String body) throws IOException;
    /**
     * Iterate them all.
     * @param params Iterating parameters, as requested by API
     * @return Iterator of issues
     * @see <a href="https://developer.github.com/v3/issues/#list-issues">List Issues</a>
     */
    Iterable<Issue> iterate(Map<String, String> params);
    /**
     * Search for issues within the given repository.
     *
     * @param sort The sort field
     * @param direction The sort direction
     * @param qualifiers The search qualifier
     * @return Issues
     * @since 0.22.0
     * @see <a href="https://developer.github.com/v3/issues/#list-issues-for-a-repository">List issues for a repository</a>
     */
    Iterable<Issue> search(
        Sort sort, Search.Order direction,
        EnumMap<Qualifier, String> qualifiers);
    enum Qualifier implements StringEnum {
        /**
         * Filter issues based on which milestone they are assigned to.
         * "none" means no assigned milestone. "*" means any milestone.
         */
        MILESTONE("milestone"),
        /**
         * Filter issues based on whether they're open or closed.
         */
        STATE("state"),
        /**
         * Finds issues that are assigned to a certain user.
         * "none" means no assigned user. "*" means assigned to any user.
         */
        ASSIGNEE("assignee"),
        /**
         * Finds issues created by a certain user.
         */
        CREATOR("creator"),
        /**
         * Finds issues that mention a certain user.
         */
        MENTIONED("mentioned"),
        /**
         * Filters issues based on their labels,
         * as a comma-separated list of label names.
         * An issue must have all of the labels in the list in order to
         * appear in the search results.
         */
        LABELS("labels"),
        /**
         * Filters issues based on date last updated (as an ISO 8601 timestamp).
         */
        SINCE("since");
        /**
         * Search qualifier.
         */
        private final transient String qualifier;
        /**
         * Ctor.
         * @param key Search qualifier
         */
        Qualifier(final String key) {
            this.qualifier = key;
        }
        /**
         * Get search qualifier.
         * @return String
         */
        @Override
        public String identifier() {
            return this.qualifier;
        }
    }
    enum Sort implements StringEnum {
        /**
         * Issue creation timestamp.
         */
        CREATED("created"),
        /**
         * Issue last updated timestamp.
         */
        UPDATED("updated"),
        /**
         * Number of comments on the issue.
         */
        COMMENTS("comments");
        /**
         * Search results sort field.
         */
        private final transient String sort;
        /**
         * Ctor.
         * @param field Search results sort field
         */
        Sort(final String field) {
            this.sort = field;
        }
        /**
         * Get search results sort field.
         * @return String
         */
        @Override
        public String identifier() {
            return this.sort;
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github.safe;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.github.Comments;
import com.jcabi.github.Event;
import com.jcabi.github.Issue;
import com.jcabi.github.IssueLabels;
import com.jcabi.github.Reaction;
import com.jcabi.github.Repo;
import com.jcabi.github.mock.MkGithub;
import com.jcabi.log.Logger;
import java.io.IOException;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
/**
 * Safe issue.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.36
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = "origin")
@SuppressWarnings("PMD.TooManyMethods")
public final class SfIssue implements Issue {
    /**
     * Original issue.
     */
    private final transient Issue origin;
    /**
     * Public ctor.
     * @param issue The original issue
     */
    public SfIssue(final Issue issue) {
        this.origin = issue;
    }
    @Override
    public String toString() {
        return this.origin.toString();
    }
    @Override
    public JsonObject json() throws IOException {
        JsonObject json;
        try {
            json = this.origin.json();
        } catch (final AssertionError ex) {
            json = new MkGithub().randomRepo()
                .issues().create("", "").json();
            Logger.warn(this, "failed to fetch issue: %[exception]s", ex);
        }
        return json;
    }
    @Override
    public void patch(final JsonObject json) throws IOException {
        try {
            this.origin.patch(json);
        } catch (final AssertionError ex) {
            Logger.warn(this, "failed to patch issue: %[exception]s", ex);
        }
    }
    @Override
    public Repo repo() {
        return this.origin.repo();
    }
    @Override
    public int number() {
        return this.origin.number();
    }
    @Override
    public Comments comments() {
        return new SfComments(this.origin.comments());
    }
    @Override
    public IssueLabels labels() {
        return this.origin.labels();
    }
    @Override
    public Iterable<Event> events() throws IOException {
        return this.origin.events();
    }
    @Override
    public boolean exists() throws IOException {
        return this.origin.exists();
    }
    @Override
    public int compareTo(final Issue issue) {
        return this.origin.compareTo(issue);
    }
    @Override
    public void react(final Reaction reaction) throws IOException {
        this.origin.react(reaction);
    }
    @Override
    public Iterable<Reaction> reactions() {
        return this.origin.reactions();
    }
    @Override
    public void lock(final String reason) {
        this.origin.lock(reason);
    }
    @Override
    public void unlock() {
        this.origin.unlock();
    }
    @Override
    public boolean isLocked() {
        return this.origin.isLocked();
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github.safe;
import com.google.common.collect.Iterables;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.github.Comment;
import com.jcabi.github.Comments;
import com.jcabi.github.Issue;
import com.jcabi.github.mock.MkGithub;
import com.jcabi.log.Logger;
import java.io.IOException;
import java.util.Date;
import lombok.EqualsAndHashCode;
/**
 * Safe comments.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.34
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = "origin")
public final class SfComments implements Comments {
    /**
     * Original comments.
     */
    private final transient Comments origin;
    /**
     * Public ctor.
     * @param cmt The original comment
     */
    public SfComments(final Comments cmt) {
        this.origin = cmt;
    }
    @Override
    public String toString() {
        return this.origin.toString();
    }
    @Override
    public Issue issue() {
        return this.origin.issue();
    }
    @Override
    public Comment get(final long number) {
        return new SfComment(this.origin.get(number));
    }
    @Override
    public Iterable<Comment> iterate(final Date since) {
        return Iterables.transform(
            this.origin.iterate(since),
            input -> new SfComment(input)
        );
    }
    @Override
    public Comment post(final String text) throws IOException {
        Comment cmt;
        try {
            cmt = this.origin.post(text);
        } catch (final AssertionError ex) {
            Logger.warn(this, "Failed to post to GitHub: %[exception]s", ex);
            cmt = new MkGithub().randomRepo()
                .issues().create("", "")
                .comments().post(text);
        }
        return cmt;
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github.mock;
import com.google.common.base.Optional;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.github.Comments;
import com.jcabi.github.Coordinates;
import com.jcabi.github.Event;
import com.jcabi.github.Issue;
import com.jcabi.github.IssueLabels;
import com.jcabi.github.Label;
import com.jcabi.github.Reaction;
import com.jcabi.github.Repo;
import com.jcabi.xml.XML;
import java.io.IOException;
import java.util.Collection;
import java.util.Map;
import javax.json.Json;
import javax.json.JsonArrayBuilder;
import javax.json.JsonObject;
import javax.json.JsonObjectBuilder;
import javax.json.JsonValue;
import lombok.EqualsAndHashCode;
/**
 * Mock Github issue.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.5
 * @checkstyle ClassDataAbstractionCoupling (500 lines)
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = { "storage", "self", "coords", "num" })
@SuppressWarnings("PMD.TooManyMethods")
final class MkIssue implements Issue {
    /**
     * Storage.
     */
    private final transient MkStorage storage;
    /**
     * Login of the user logged in.
     */
    private final transient String self;
    /**
     * Repo name.
     */
    private final transient Coordinates coords;
    /**
     * Issue number.
     */
    private final transient int num;
    /**
     * Public ctor.
     * @param stg Storage
     * @param login User to login
     * @param rep Repo
     * @param number Issue number
     * @checkstyle ParameterNumber (5 lines)
     */
    MkIssue(
        final MkStorage stg,
        final String login,
        final Coordinates rep,
        final int number
    ) {
        this.storage = stg;
        this.self = login;
        this.coords = rep;
        this.num = number;
    }
    @Override
    public String toString() {
        return Integer.toString(this.num);
    }
    @Override
    public Repo repo() {
        return new MkRepo(this.storage, this.self, this.coords);
    }
    @Override
    public int number() {
        return this.num;
    }
    @Override
    public Comments comments() {
        try {
            return new MkComments(
                this.storage, this.self, this.coords, this.num
            );
        } catch (final IOException ex) {
            throw new IllegalStateException(ex);
        }
    }
    @Override
    public IssueLabels labels() {
        try {
            return new MkIssueLabels(
                this.storage, this.self, this.coords, this.num
            );
        } catch (final IOException ex) {
            throw new IllegalStateException(ex);
        }
    }
    @Override
    public Iterable<Event> events() throws IOException {
        return new MkIterable<>(
            this.storage,
            String.format(
                // @checkstyle LineLength (1 line)
                "/github/repos/repo[@coords='%s']/issue-events/issue-event[issue='%s']",
                this.coords,
                this.num
            ),
            new MkIssueEventMapping(this)
        );
    }
    @Override
    public boolean exists() throws IOException {
        return this.storage.xml().xpath(
            String.format("%s/number/text()", this.xpath())
        ).size() == 1;
    }
    @Override
    public int compareTo(
        final Issue issue
    ) {
        return this.number() - issue.number();
    }
    @Override
    public void patch(
        final JsonObject json
    ) throws IOException {
        final Issue.Smart smart = new Issue.Smart(this);
        final boolean was = smart.isOpen();
        new JsonPatch(this.storage).patch(this.xpath(), json);
        final boolean now = smart.isOpen();
        if (now != was) {
            final String type;
            if (now) {
                type = Event.REOPENED;
            } else {
                type = Event.CLOSED;
            }
            new MkIssueEvents(this.storage, this.self, this.coords)
                .create(type, this.num, this.self, Optional.<String>absent());
        }
    }
    @Override
    public JsonObject json() throws IOException {
        final XML xml = this.storage.xml();
        final JsonObject obj = new JsonNode(
            xml.nodes(this.xpath()).get(0)
        ).json();
        final JsonObjectBuilder json = Json.createObjectBuilder();
        for (final Map.Entry<String, JsonValue> val: obj.entrySet()) {
            json.add(val.getKey(), val.getValue());
        }
        final JsonArrayBuilder array = Json.createArrayBuilder();
        for (final Label label : this.labels().iterate()) {
            array.add(
                Json.createObjectBuilder().add("name", label.name()).build()
            );
        }
        final JsonObjectBuilder res = json
            .add("labels", array)
            .add(
                // @checkstyle MultipleStringLiteralsCheck (1 line)
                "assignee",
                Json.createObjectBuilder().add(
                    "login", obj.getString("assignee", "")
                ).build()
            );
        final JsonObjectBuilder pull = Json.createObjectBuilder();
        final String html = "html_url";
        if (xml.nodes(
                String.format(
                    // @checkstyle LineLengthCheck (1 line)
                    "/github/repos/repo[@coords='%s']/pulls/pull/number[text() = '%d']",
                    this.coords,
                    this.num
                )
            ).isEmpty()) {
            pull.addNull(html);
        } else {
            pull.add(
                html,
                String.format(
                    "https://%s/pulls/%d",
                    this.coords,
                    this.num
                )
            );
        }
        return res.add("pull_request", pull.build()).build();
    }
    @Override
    public void react(final Reaction reaction) {
        throw new UnsupportedOperationException("react() not implemented");
    }
    @Override
    public Collection<Reaction> reactions() {
        throw new UnsupportedOperationException("reactions() not implemented");
    }
    @Override
    public void lock(final String reason) {
        throw new UnsupportedOperationException("lock not implemented");
    }
    @Override
    public void unlock() {
        throw new UnsupportedOperationException("unlock not implemented");
    }
    @Override
    public boolean isLocked() {
        throw new UnsupportedOperationException("isLocked not implemented");
    }
    /**
     * XPath of this element in XML tree.
     * @return XPath
     */
    private String xpath() {
        return String.format(
            "/github/repos/repo[@coords='%s']/issues/issue[number='%d']",
            this.coords, this.num
        );
    }
    private static class MkIssueEventMapping
        implements MkIterable.Mapping<Event> {
        /**
         * Issue events.
         */
        private final transient MkIssueEvents evts;
        /**
         * Constructor.
         * @param issue Mock issue to get events from
         * @throws IOException If there is any I/O problem
         */
        public MkIssueEventMapping(
            final MkIssue issue
        ) throws IOException {
            this.evts = new MkIssueEvents(
                issue.storage,
                issue.self,
                issue.coords
            );
        }
        @Override
        public Event map(
            final XML xml
        ) {
            return this.evts.get(
                Integer.parseInt(xml.xpath("number/text()").get(0))
            );
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github.mock;
import com.google.common.base.Optional;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.github.Coordinates;
import com.jcabi.github.Event;
import com.jcabi.github.Issue;
import com.jcabi.github.IssueLabels;
import com.jcabi.github.Label;
import java.io.IOException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import org.xembly.Directives;
/**
 * Mock Github labels.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.5
 */
@Immutable
@Loggable(Loggable.DEBUG)
@ToString
@EqualsAndHashCode(of = { "storage", "repo", "ticket" })
final class MkIssueLabels implements IssueLabels {
    /**
     * Storage.
     */
    private final transient MkStorage storage;
    /**
     * Login of the user logged in.
     */
    private final transient String self;
    /**
     * Repo name.
     */
    private final transient Coordinates repo;
    /**
     * Issue number.
     */
    private final transient int ticket;
    /**
     * Public ctor.
     * @param stg Storage
     * @param login Login
     * @param rep Repo
     * @param issue Issue number
     * @throws IOException If fails
     * @checkstyle ParameterNumber (5 lines)
     */
    MkIssueLabels(
        final MkStorage stg,
        final String login,
        final Coordinates rep,
        final int issue
    ) throws IOException {
        this.storage = stg;
        this.self = login;
        this.repo = rep;
        this.ticket = issue;
        this.storage.apply(
            new Directives().xpath(
                String.format(
                    // @checkstyle LineLength (1 line)
                    "/github/repos/repo[@coords='%s']/issues/issue[number='%d']",
                    rep, this.ticket
                )
            ).addIf("labels")
        );
    }
    @Override
    public Issue issue() {
        return new MkIssue(this.storage, this.self, this.repo, this.ticket);
    }
    @Override
    public void add(final Iterable<String> labels
    ) throws IOException {
        final Collection<String> existing = this.labels();
        final Set<String> added = new HashSet<>();
        final Directives dirs = new Directives().xpath(this.xpath());
        for (final String label : labels) {
            dirs.add("label").set(label).up();
            if (!existing.contains(label)) {
                added.add(label);
            }
        }
        this.storage.apply(dirs);
        if (!added.isEmpty()) {
            final MkIssueEvents events = new MkIssueEvents(
                this.storage,
                this.self,
                this.repo
            );
            for (final String label : added) {
                events.create(
                    Event.LABELED,
                    this.ticket,
                    this.self,
                    Optional.of(label)
                );
            }
        }
    }
    @Override
    public void replace(final Iterable<String> labels
    ) throws IOException {
        this.clear();
        this.add(labels);
    }
    @Override
    public Iterable<Label> iterate() {
        return new MkIterable<>(
            this.storage,
            String.format("%s/*", this.xpath()),
            xml -> new MkLabel(
                this.storage,
                this.self,
                this.repo,
                xml.xpath("./text()").get(0)
            )
        );
    }
    @Override
    public void remove(final String name
    ) throws IOException {
        if (this.labels().contains(name)) {
            this.storage.apply(
                new Directives().xpath(
                    String.format("%s/label[.='%s']", this.xpath(), name)
                ).remove()
            );
            new MkIssueEvents(
                this.storage,
                this.self,
                this.repo
            ).create(
                Event.UNLABELED,
                this.ticket,
                this.self,
                Optional.of(name)
            );
        }
    }
    @Override
    public void clear() throws IOException {
        for (final String label : this.labels()) {
            this.remove(label);
        }
    }
    /**
     * XPath of this element in XML tree.
     * @return XPath
     */
    private String xpath() {
        return String.format(
            "/github/repos/repo[@coords='%s']/issues/issue[number='%d']/labels",
            this.repo, this.ticket
        );
    }
    /**
     * Returns a set of all of the issue's labels.
     * @return Set of label names
     */
    private Collection<String> labels() {
        final Set<String> labels = new HashSet<>();
        for (final Label label : this.iterate()) {
            labels.add(label.name());
        }
        return labels;
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github.mock;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.github.Comment;
import com.jcabi.github.Comments;
import com.jcabi.github.Coordinates;
import com.jcabi.github.Github;
import com.jcabi.github.Issue;
import com.jcabi.log.Logger;
import java.io.IOException;
import java.util.Date;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import org.xembly.Directives;
/**
 * Mock Github comments.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.5
 */
@Immutable
@Loggable(Loggable.DEBUG)
@ToString
@EqualsAndHashCode(of = { "storage", "self", "repo", "ticket" })
final class MkComments implements Comments {
    /**
     * Storage.
     */
    private final transient MkStorage storage;
    /**
     * Login of the user logged in.
     */
    private final transient String self;
    /**
     * Repo name.
     */
    private final transient Coordinates repo;
    /**
     * Issue number.
     */
    private final transient int ticket;
    /**
     * Public ctor.
     * @param stg Storage
     * @param login User to login
     * @param rep Repo
     * @param issue Issue number
     * @throws IOException If there is any I/O problem
     * @checkstyle ParameterNumber (5 lines)
     */
    MkComments(
        final MkStorage stg,
        final String login,
        final Coordinates rep,
        final int issue
    ) throws IOException {
        this.storage = stg;
        this.self = login;
        this.repo = rep;
        this.ticket = issue;
        this.storage.apply(
            new Directives().xpath(
                String.format(
                    // @checkstyle LineLength (1 line)
                    "/github/repos/repo[@coords='%s']/issues/issue[number='%d']",
                    this.repo, this.ticket
                )
            ).addIf("comments")
        );
    }
    @Override
    public Issue issue() {
        return new MkIssue(this.storage, this.self, this.repo, this.ticket);
    }
    @Override
    public Comment get(final long number) {
        return new MkComment(
            this.storage, this.self, this.repo, this.ticket, number
        );
    }
    @Override
    public Iterable<Comment> iterate(final Date since) {
        return new MkIterable<>(
            this.storage,
            String.format("%s/comment", this.xpath()),
            xml -> this.get(
                Long.parseLong(xml.xpath("number/text()").get(0))
            )
        );
    }
    @Override
    public Comment post(
        final String text
    ) throws IOException {
        this.storage.lock();
        final long number;
        try {
            final String timestamp = new Github.Time().toString();
            number = 1 + this.storage.xml()
                .nodes("//comment/number").size();
            this.storage.apply(
                new Directives().xpath(this.xpath()).add("comment")
                    .add("number").set(Long.toString(number)).up()
                    .add("url")
                    .set(
                        String.format(
                            // @checkstyle LineLength (1 line)
                            "https://api.jcabi-github.invalid/repos/%s/%s/issues/comments/%d",
                            this.repo.user(),
                            this.repo.repo(),
                            number
                    )
                )
                    .up()
                    .add("body").set(text).up()
                    .add("user")
                        .add("login").set(this.self).up()
                    .up()
                    .add("created_at").set(timestamp).up()
                    .add("updated_at").set(timestamp)
            );
        } finally {
            this.storage.unlock();
        }
        Logger.info(
            this, "comment #%d posted to issue #%d by %s: %[text]s",
            number, this.issue().number(), this.self, text
        );
        return this.get(number);
    }
    /**
     * XPath of this element in XML tree.
     * @return XPath
     */
    private String xpath() {
        return String.format(
            // @checkstyle LineLength (1 line)
            "/github/repos/repo[@coords='%s']/issues/issue[number='%d']/comments",
            this.repo, this.ticket
        );
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import lombok.EqualsAndHashCode;
/**
 * Check if a Github JSON object actually exists on the server.
 *
 * @author Mihai Andronache (amihaiemil@gmail.com)
 * @version $Id$
 * @since 0.38
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = "readable")
final class Existence {
    /**
     * Checked object.
     */
    private final transient JsonReadable readable;
    /**
     * Ctor.
     * @param rdbl Checked object.
     */
    Existence(final JsonReadable rdbl) {
        this.readable = rdbl;
    }
    /**
     * Check existence.
     * @return True if exists, false otherwise.
     * @throws IOException If there is a networking problem.
     */
    public boolean check() throws IOException {
        boolean exists = true;
        try {
            this.readable.json();
        } catch (final AssertionError ex) {
            exists = false;
        } catch (final IndexOutOfBoundsException ex) {
            exists = false;
        }
        return exists;
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.ParseException;
import java.util.Date;
import javax.json.Json;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
import lombok.ToString;
/**
 * Github Milestone.
 *
 * <p>Use a supplementary "smart" decorator to get other properties
 * from an milestone, for example:
 *
 * <pre> Milestone.Smart milestone = new Milestone.Smart(origin);
 * if (milestone.isOpen()) {
 *   milestone.close();
 * }
 * </pre>
 *
 * @author Paul Polishchuk (ppol@ua.fm)
 * @version $Id$
 * @see <a href="https://developer.github.com/v3/issues/milestones/">Milestones API</a>
 * @since 0.7
 */
@Immutable
@SuppressWarnings("PMD.TooManyMethods")
public interface Milestone extends Comparable<Milestone>,
    JsonReadable, JsonPatchable {
    /**
     * Milestone state.
     */
    String OPEN_STATE = "open";
    /**
     * Milestone state.
     */
    String CLOSED_STATE = "closed";
    /**
     * Repository we're in.
     * @return Repo
     */
    Repo repo();
    /**
     * Get its number.
     * @return Milestone number
     */
    int number();
    /**
     * Smart Milestone with extra features.
     */
    @Immutable
    @ToString
    @Loggable(Loggable.DEBUG)
    @EqualsAndHashCode(of = { "milestone", "jsn" })
    final class Smart implements Milestone {
        /**
         * Name of mailestone state attribute.
         */
        private static final String STATE = "state";
        /**
         * Name of mailestone description attribute.
         */
        private static final String DESCRIPTION = "description";
        /**
         * Name of mailestone title attribute.
         */
        private static final String TITLE = "title";
        /**
         * Name of mailestone due_on attribute.
         */
        private static final String DUE_ON = "due_on";
        /**
         * Encapsulated milestone.
         */
        private final transient Milestone milestone;
        /**
         * SmartJson object for convenient JSON parsing.
         */
        private final transient SmartJson jsn;
        /**
         * Public ctor.
         * @param mls Issue
         */
        public Smart(
            final Milestone mls
        ) {
            this.milestone = mls;
            this.jsn = new SmartJson(mls);
        }
        /**
         * Get its creator.
         * @return Creator of milestone (who submitted it)
         * @throws java.io.IOException If there is any I/O problem
         */
        public User creator() throws IOException {
            return this.milestone.repo().github().users().get(
                this.jsn.value(
                    "creator", JsonObject.class
                ).getString("login")
            );
        }
        /**
         * Is it open?
         * @return TRUE if it's open
         * @throws IOException If there is any I/O problem
         */
        public boolean isOpen() throws IOException {
            return Milestone.OPEN_STATE.equals(this.state());
        }
        /**
         * Open it (make sure it's open).
         * @throws IOException If there is any I/O problem
         */
        public void open() throws IOException {
            this.state(Milestone.OPEN_STATE);
        }
        /**
         * Close it (make sure it's closed).
         * @throws IOException If there is any I/O problem
         */
        public void close() throws IOException {
            this.state(Milestone.CLOSED_STATE);
        }
        /**
         * Get its state.
         * @return State of milestone
         * @throws IOException If there is any I/O problem
         */
        public String state() throws IOException {
            return this.jsn.text(STATE);
        }
        /**
         * Change its state.
         * @param state State of milestone
         * @throws IOException If there is any I/O problem
         */
        public void state(
            final String state
        ) throws IOException {
            this.milestone.patch(
                Json.createObjectBuilder().add(STATE, state).build()
            );
        }
        /**
         * Get its title.
         * @return Title of milestone
         * @throws IOException If there is any I/O problem
         */
        public String title() throws IOException {
            return this.jsn.text(TITLE);
        }
        /**
         * Change its title.
         * @param title Title of milestone
         * @throws IOException If there is any I/O problem
         */
        public void title(
            final String title
        ) throws IOException {
            this.milestone.patch(
                Json.createObjectBuilder().add(TITLE, title).build()
            );
        }
        /**
         * Get its description.
         * @return Title of milestone
         * @throws IOException If there is any I/O problem
         */
        public String description() throws IOException {
            return this.jsn.text(DESCRIPTION);
        }
        /**
         * Change its description.
         * @param description Description of milestone
         * @throws IOException If there is any I/O problem
         */
        public void description(
            final String description
        ) throws IOException {
            this.milestone.patch(
                Json.createObjectBuilder()
                    .add(DESCRIPTION, description).build()
            );
        }
        /**
         * Get its URL.
         * @return URL of milestone
         * @throws IOException If there is any I/O problem
         */
        public URL url() throws IOException {
            try {
                return new URI(this.jsn.text("url")).toURL();
            } catch (final URISyntaxException ex) {
                throw new IllegalArgumentException(ex);
            }
        }
        /**
         * When this milestone was created.
         * @return Date of creation
         * @throws IOException If there is any I/O problem
         */
        public Date createdAt() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text("created_at")
                ).date();
            } catch (final ParseException ex) {
                throw new IllegalStateException(ex);
            }
        }
        /**
         * The milestone due date.
         * @return The milestone due date
         * @throws IOException If there is any I/O problem
         */
        public Date dueOn() throws IOException {
            try {
                return new Github.Time(
                    this.jsn.text(DUE_ON)
                ).date();
            } catch (final ParseException ex) {
                throw new IllegalStateException(ex);
            }
        }
        /**
         * Change milestone due date.
         * @param dueon New milestone due date
         * @throws IOException If there is any I/O problem
         */
        public void dueOn(
            final Date dueon
        ) throws IOException {
            this.milestone.patch(
                Json.createObjectBuilder()
                    .add(DUE_ON, new Github.Time(dueon).toString()).build()
            );
        }
        /**
         * Get number of open issues.
         * @return Number of open issues
         * @throws IOException If there is any I/O problem
         */
        public int openIssues() throws IOException {
            return this.jsn.number("open_issues");
        }
        /**
         * Get number of closed issues.
         * @return Number of closed issues
         * @throws IOException If there is any I/O problem
         */
        public int closedIssues() throws IOException {
            return this.jsn.number("closed_issues");
        }
        @Override
        public Repo repo() {
            return this.milestone.repo();
        }
        @Override
        public int number() {
            return this.milestone.number();
        }
        @Override
        public JsonObject json() throws IOException {
            return this.milestone.json();
        }
        @Override
        public void patch(
            final JsonObject json
        ) throws IOException {
            this.milestone.patch(json);
        }
        @Override
        public int compareTo(
            final Milestone obj
        ) {
            return this.milestone.compareTo(obj);
        }
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github.mock;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.github.Coordinates;
import com.jcabi.github.Github;
import com.jcabi.github.Issue;
import com.jcabi.github.Issues;
import com.jcabi.github.Repo;
import com.jcabi.github.Search;
import com.jcabi.log.Logger;
import java.io.IOException;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import org.xembly.Directives;
/**
 * Mock Github issues.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.5
 */
@Immutable
@Loggable(Loggable.DEBUG)
@ToString
@EqualsAndHashCode(of = { "storage", "self", "coords" })
final class MkIssues implements Issues {
    /**
     * Storage.
     */
    private final transient MkStorage storage;
    /**
     * Login of the user logged in.
     */
    private final transient String self;
    /**
     * Repo name.
     */
    private final transient Coordinates coords;
    /**
     * Public ctor.
     * @param stg Storage
     * @param login User to login
     * @param rep Repo
     * @throws IOException If there is any I/O problem
     */
    MkIssues(
        final MkStorage stg,
        final String login,
        final Coordinates rep
    ) throws IOException {
        this.storage = stg;
        this.self = login;
        this.coords = rep;
        this.storage.apply(
            new Directives().xpath(
                String.format(
                    "/github/repos/repo[@coords='%s']",
                    this.coords
                )
            ).addIf("issues")
        );
    }
    @Override
    public Repo repo() {
        return new MkRepo(this.storage, this.self, this.coords);
    }
    @Override
    public Issue get(final int number) {
        return new MkIssue(this.storage, this.self, this.coords, number);
    }
    @Override
    public Issue create(final String title,
        final String body
    )
        throws IOException {
        this.storage.lock();
        final int number;
        try {
            number = 1 + this.storage.xml().xpath(
                String.format("%s/issue/number/text()", this.xpath())
            ).size();
            this.storage.apply(
                new Directives().xpath(this.xpath()).add("issue")
                    .add("number").set(Integer.toString(number)).up()
                    .add("state").set(Issue.OPEN_STATE).up()
                    .add("title").set(title).up()
                    .add("body").set(body).up()
                    .add("created_at").set(new Github.Time().toString()).up()
                    .add("updated_at").set(new Github.Time().toString()).up()
                    .add("url").set("http://localhost/1").up()
                    .add("html_url").set("http://localhost/2").up()
                    .add("user").add("login").set(this.self).up().up()
            );
        } finally {
            this.storage.unlock();
        }
        Logger.info(
            this, "issue #%d created in %s by %s: %[text]s",
            number, this.repo().coordinates(), this.self, title
        );
        return this.get(number);
    }
    @Override
    public Iterable<Issue> iterate(final Map<String, String> params
    ) {
        return new MkIterable<>(
            this.storage,
            String.format("%s/issue", this.xpath()),
            xml -> this.get(
                Integer.parseInt(xml.xpath("number/text()").get(0))
            )
        );
    }
    @Override
    @SuppressWarnings("PMD.UseConcurrentHashMap")
    public Iterable<Issue> search(
        final Sort sort,
        final Search.Order direction,
        final EnumMap<Qualifier, String> qualifiers) {
        final Map<String, String> params = new HashMap<>();
        for (final EnumMap.Entry<Qualifier, String> entry : qualifiers
            .entrySet()) {
            params.put(entry.getKey().identifier(), entry.getValue());
        }
        params.put("sort", sort.identifier());
        params.put("direction", direction.identifier());
        return this.iterate(params);
    }
    /**
     * XPath of this element in XML tree.
     * @return XPath
     */
    private String xpath() {
        return String.format(
            "/github/repos/repo[@coords='%s']/issues",
            this.coords
        );
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.http.Request;
import com.jcabi.http.response.JsonResponse;
import com.jcabi.http.response.RestResponse;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;
import javax.json.Json;
import javax.json.JsonStructure;
import lombok.EqualsAndHashCode;
/**
 * Github issues.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.1
 * @checkstyle MultipleStringLiterals (500 lines)
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = { "entry", "request", "owner" })
final class RtIssues implements Issues {
    /**
     * API entry point.
     */
    private final transient Request entry;
    /**
     * RESTful request.
     */
    private final transient Request request;
    /**
     * Repository.
     */
    private final transient Repo owner;
    /**
     * Public ctor.
     * @param req Request
     * @param repo Repository
     */
    RtIssues(final Request req, final Repo repo) {
        this.entry = req;
        final Coordinates coords = repo.coordinates();
        this.request = this.entry.uri()
            .path("/repos")
            .path(coords.user())
            .path(coords.repo())
            .path("/issues")
            .back();
        this.owner = repo;
    }
    @Override
    public String toString() {
        return this.request.uri().get().toString();
    }
    @Override
    public Repo repo() {
        return this.owner;
    }
    @Override
    public Issue get(final int number) {
        return new RtIssue(this.entry, this.owner, number);
    }
    @Override
    public Issue create(
        final String title,
        final String body)
        throws IOException {
        final JsonStructure json = Json.createObjectBuilder()
            .add("title", title)
            .add("body", body)
            .build();
        return this.get(
            this.request.method(Request.POST)
                .body().set(json).back()
                .fetch().as(RestResponse.class)
                .assertStatus(HttpURLConnection.HTTP_CREATED)
                .as(JsonResponse.class)
                .json().readObject().getInt("number")
        );
    }
    @Override
    public Iterable<Issue> iterate(
        final Map<String, String> params) {
        return new RtPagination<>(
            this.request.uri().queryParams(params).back(),
            object -> this.get(object.getInt("number"))
        );
    }
    @Override
    @SuppressWarnings("PMD.UseConcurrentHashMap")
    public Iterable<Issue> search(
        final Sort sort,
        final Search.Order direction,
        final EnumMap<Qualifier, String> qualifiers) {
        final Map<String, String> params = new HashMap<>();
        for (final EnumMap.Entry<Qualifier, String> pair : qualifiers
            .entrySet()) {
            params.put(pair.getKey().identifier(), pair.getValue());
        }
        params.put("sort", sort.identifier());
        params.put("direction", direction.identifier());
        return this.iterate(params);
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.http.Request;
import com.jcabi.http.response.RestResponse;
import java.io.IOException;
import java.net.HttpURLConnection;
import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonStructure;
import lombok.EqualsAndHashCode;
/**
 * Github issue.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.1
 * @checkstyle MultipleStringLiterals (500 lines)
 * @checkstyle ClassDataAbstractionCouplingCheck (500 lines)
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = { "request", "owner", "num" })
@SuppressWarnings("PMD.TooManyMethods")
final class RtIssue implements Issue {
    /**
     * Content constant.
     */
    private static final String CONTENT = "content";
    /**
     * API entry point.
     */
    private final transient Request entry;
    /**
     * RESTful request.
     */
    private final transient Request request;
    /**
     * Repository we're in.
     */
    private final transient Repo owner;
    /**
     * Issue number.
     */
    private final transient int num;
    /**
     * Public ctor.
     * @param req Request
     * @param repo Repository
     * @param number Number of the get
     */
    RtIssue(final Request req, final Repo repo, final int number) {
        this.entry = req;
        final Coordinates coords = repo.coordinates();
        this.request = this.entry.uri()
            .path("/repos")
            .path(coords.user())
            .path(coords.repo())
            .path("/issues")
            .path(Integer.toString(number))
            .back();
        this.owner = repo;
        this.num = number;
    }
    @Override
    public String toString() {
        return this.request.uri().get().toString();
    }
    @Override
    public Repo repo() {
        return this.owner;
    }
    @Override
    public int number() {
        return this.num;
    }
    @Override
    public Comments comments() {
        return new RtComments(this.entry, this);
    }
    @Override
    public IssueLabels labels() {
        return new RtIssueLabels(this.entry, this);
    }
    @Override
    public Iterable<Event> events() {
        return new RtPagination<>(
            this.request.uri().path("/events").back(),
            object -> new RtEvent(
                this.entry,
                this.owner,
                object.getInt("id")
            )
        );
    }
    @Override
    public boolean exists() throws IOException {
        return new Existence(this).check();
    }
    @Override
    public void react(final Reaction reaction) throws IOException {
        final JsonStructure json = Json.createObjectBuilder()
            .add(RtIssue.CONTENT, reaction.type())
            .build();
        this.request.method(Request.POST)
            .body().set(json).back()
            .fetch().as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_OK);
    }
    @Override
    public Iterable<Reaction> reactions() {
        return new RtPagination<>(
            this.request.uri().path("/reactions").back(),
            object -> new Reaction.Simple(object.getString(RtIssue.CONTENT))
        );
    }
    @Override
    public void lock(final String reason) {
        final JsonStructure json = Json.createObjectBuilder()
            .add("lock_reason", reason)
            .build();
        try {
            this.request.method(Request.PUT).uri().path("/lock").back()
                .body().set(json).back()
                .fetch()
                .as(RestResponse.class)
                .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);
        } catch (final IOException error) {
            throw new IllegalStateException(error);
        }
    }
    @Override
    public void unlock() {
        try {
            this.request.method(Request.DELETE).uri().path("/lock").back()
                .fetch()
                .as(RestResponse.class)
                .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);
        } catch (final IOException error) {
            throw new IllegalStateException(error);
        }
    }
    @Override
    public boolean isLocked() {
        boolean locked = false;
        try {
            locked ^=
                this.request.method(Request.PUT).uri().path("/lock").back()
                .fetch()
                .as(RestResponse.class)
                .assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body()
                .get().isEmpty();
        } catch (final IOException error) {
            locked = false;
        }
        return locked;
    }
    @Override
    public JsonObject json() throws IOException {
        return new RtJson(this.request).fetch();
    }
    @Override
    public void patch(final JsonObject json) throws IOException {
        new RtJson(this.request).patch(json);
    }
    @Override
    public int compareTo(
        final Issue issue
    ) {
        return this.number() - issue.number();
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github.mock;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.github.Comment;
import com.jcabi.github.Coordinates;
import com.jcabi.github.Issue;
import com.jcabi.github.Reaction;
import java.io.IOException;
import java.util.Collection;
import javax.json.JsonObject;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import org.xembly.Directives;
/**
 * Mock Github comment.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.5
 */
@Immutable
@Loggable(Loggable.DEBUG)
@ToString
@EqualsAndHashCode(of = { "storage", "self", "repo", "ticket", "num" })
final class MkComment implements Comment {
    /**
     * Storage.
     */
    private final transient MkStorage storage;
    /**
     * Login of the user logged in.
     */
    private final transient String self;
    /**
     * Repo name.
     */
    private final transient Coordinates repo;
    /**
     * Issue number.
     */
    private final transient int ticket;
    /**
     * Comment number.
     */
    private final transient long num;
    /**
     * Public ctor.
     * @param stg Storage
     * @param login User to login
     * @param rep Repo
     * @param issue Issue number
     * @param number Comment number
     * @checkstyle ParameterNumber (5 lines)
     */
    MkComment(
        final MkStorage stg,
        final String login,
        final Coordinates rep,
        final int issue,
        final long number
    ) {
        this.storage = stg;
        this.self = login;
        this.repo = rep;
        this.ticket = issue;
        this.num = number;
    }
    @Override
    public Issue issue() {
        return new MkIssue(this.storage, this.self, this.repo, this.ticket);
    }
    @Override
    public long number() {
        return this.num;
    }
    @Override
    public void remove() throws IOException {
        this.storage.apply(
            new Directives().xpath(this.xpath()).strict(1).remove()
        );
    }
    @Override
    public int compareTo(
        final Comment comment
    ) {
        return Long.compare(this.number(), comment.number());
    }
    @Override
    public void patch(
        final JsonObject json
    ) throws IOException {
        new JsonPatch(this.storage).patch(this.xpath(), json);
    }
    @Override
    public JsonObject json() throws IOException {
        return new JsonNode(
            this.storage.xml().nodes(this.xpath()).get(0)
        ).json();
    }
    @Override
    public void react(final Reaction reaction) {
        throw new UnsupportedOperationException("react() not implemented");
    }
    @Override
    public Collection<Reaction> reactions() {
        throw new UnsupportedOperationException("reactions() not implemented");
    }
    /**
     * XPath of this element in XML tree.
     * @return XPath
     */
    private String xpath() {
        return String.format(
            // @checkstyle LineLength (1 line)
            "/github/repos/repo[@coords='%s']/issues/issue[number='%d']/comments/comment[number='%d']",
            this.repo, this.ticket, this.num
        );
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.http.Request;
import com.jcabi.http.response.JsonResponse;
import com.jcabi.http.response.RestResponse;
import java.io.IOException;
import java.net.HttpURLConnection;
import javax.json.Json;
import javax.json.JsonArrayBuilder;
import javax.json.JsonStructure;
import lombok.EqualsAndHashCode;
/**
 * Github get labels.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.1
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = "entry")
final class RtIssueLabels implements IssueLabels {
    /**
     * RESTful entry.
     */
    private final transient Request entry;
    /**
     * RESTful entry.
     */
    private final transient Request request;
    /**
     * Which issue we belong to.
     */
    private final transient Issue owner;
    /**
     * Public ctor.
     * @param req Request
     * @param issue Issue we're in
     */
    RtIssueLabels(final Request req, final Issue issue) {
        this.owner = issue;
        final Coordinates coords = issue.repo().coordinates();
        this.entry = req;
        this.request = req.uri()
            .path("/repos")
            .path(coords.user())
            .path(coords.repo())
            .path("/issues")
            .path(Integer.toString(issue.number()))
            .path("/labels")
            .back();
    }
    @Override
    public String toString() {
        return this.request.uri().get().toString();
    }
    @Override
    public Issue issue() {
        return this.owner;
    }
    @Override
    public void add(final Iterable<String> labels) throws IOException {
        JsonArrayBuilder builder = Json.createArrayBuilder();
        for (final String label : labels) {
            builder = builder.add(label);
        }
        final JsonStructure json = builder.build();
        this.request.method(Request.POST)
            .body().set(json).back()
            .fetch()
            .as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_OK)
            .as(JsonResponse.class)
            .json().readArray();
    }
    @Override
    public void replace(final Iterable<String> labels) throws IOException {
        JsonArrayBuilder builder = Json.createArrayBuilder();
        for (final String label : labels) {
            builder = builder.add(label);
        }
        final JsonStructure json = builder.build();
        this.request.method(Request.PUT)
            .body().set(json).back()
            .fetch()
            .as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_OK)
            .as(JsonResponse.class)
            .json().readArray();
    }
    @Override
    public void remove(final String name) throws IOException {
        this.request.method(Request.DELETE)
            .uri().path(name).back()
            .fetch()
            .as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_OK);
    }
    @Override
    public void clear() throws IOException {
        this.request.method(Request.DELETE)
            .fetch()
            .as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);
    }
    @Override
    public Iterable<Label> iterate() {
        return new RtPagination<>(
            this.request,
            object -> new RtLabel(
                this.entry,
                this.owner.repo(),
                object.getString("name")
            )
        );
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github.mock;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.github.Coordinates;
import com.jcabi.github.Issue;
import com.jcabi.github.Pull;
import com.jcabi.github.Pulls;
import com.jcabi.github.Repo;
import java.io.IOException;
import java.util.Map;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import org.xembly.Directives;
/**
 * Mock Github pull requests.
 *
 * @author Yegor Bugayenko (yegor256@gmail.com)
 * @version $Id$
 * @since 0.5
 */
@Immutable
@Loggable(Loggable.DEBUG)
@ToString
@EqualsAndHashCode(of = { "storage", "self", "coords" })
final class MkPulls implements Pulls {
    /**
     * The separator between the username and
     * the branch name in the base/head parameters
     * when creating a pull request.
     */
    private static final String USER_BRANCH_SEP = ":";
    /**
     * Storage.
     */
    private final transient MkStorage storage;
    /**
     * Login of the user logged in.
     */
    private final transient String self;
    /**
     * Repo name.
     */
    private final transient Coordinates coords;
    /**
     * Public ctor.
     * @param stg Storage
     * @param login User to login
     * @param rep Repo
     * @throws IOException If there is any I/O problem
     */
    MkPulls(
        final MkStorage stg,
        final String login,
        final Coordinates rep
    ) throws IOException {
        this.storage = stg;
        this.self = login;
        this.coords = rep;
        this.storage.apply(
            new Directives().xpath(
                String.format(
                    "/github/repos/repo[@coords='%s']",
                    this.coords
                )
            ).addIf("pulls")
        );
    }
    @Override
    public Repo repo() {
        return new MkRepo(this.storage, this.self, this.coords);
    }
    @Override
    public Pull get(final int number) {
        return new MkPull(this.storage, this.self, this.coords, number);
    }
    @Override
    public Pull create(
        final String title,
        final String head,
        final String base
    ) throws IOException {
        if (head.isEmpty()) {
            throw new IllegalArgumentException("head cannot be empty!");
        }
        if (base.isEmpty()) {
            throw new IllegalArgumentException("base cannot be empty!");
        }
        final String canonical;
        if (head.contains(MkPulls.USER_BRANCH_SEP)) {
            canonical = head;
        } else {
            canonical = String.format(
                "%s%s%s",
                this.coords.user(),
                MkPulls.USER_BRANCH_SEP,
                head
            );
        }
        this.storage.lock();
        final int number;
        try {
            final Issue issue = this.repo().issues().create(title, "some body");
            number = issue.number();
            this.storage.apply(
                new Directives().xpath(this.xpath()).add("pull")
                    .add("number").set(Integer.toString(number)).up()
                    .add("head").set(canonical).up()
                    .add("base").set(base).up()
                    .add("checks").up()
                    .add("user")
                    .add("login").set(this.self)
                    .up()
            );
        } finally {
            this.storage.unlock();
        }
        return this.get(number);
    }
    @Override
    public Iterable<Pull> iterate(final Map<String, String> params) {
        return new MkIterable<>(
            this.storage,
            String.format("%s/pull", this.xpath()),
            xml -> this.get(
                Integer.parseInt(xml.xpath("number/text()").get(0))
            )
        );
    }
    /**
     * XPath of this element in XML tree.
     * @return XPath
     */
    private String xpath() {
        return String.format(
            "/github/repos/repo[@coords='%s']/pulls",
            this.coords
        );
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.http.Request;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.EnumMap;
import java.util.regex.Pattern;
import lombok.EqualsAndHashCode;
/**
 * Github Search.
 *
 * @author Carlos Miranda (miranda.cma@gmail.com)
 * @version $Id$
 * @since 0.8
 * @checkstyle ClassDataAbstractionCouplingCheck (500 lines)
 */
@Immutable
@Loggable(Loggable.DEBUG)
@EqualsAndHashCode(of = "ghub")
@SuppressWarnings("PMD.AvoidDuplicateLiterals")
final class RtSearch implements Search {
    /**
     * Slash pattern for url splitting.
     */
    private static final Pattern SLASH = Pattern.compile("/");
    /**
     * Equals pattern for query splitting.
     */
    private static final Pattern QUERY = Pattern.compile("=");
    /**
     * Github.
     */
    private final transient Github ghub;
    /**
     * RESTful Request to search.
     */
    private final transient Request request;
    /**
     * Public ctor.
     * @param github Github
     * @param req RESTful API entry point
     */
    RtSearch(final Github github, final Request req) {
        this.ghub = github;
        this.request = req.uri().path("/search").back();
    }
    @Override
    public Github github() {
        return this.ghub;
    }
    @Override
    public Iterable<Repo> repos(
        final String keywords,
        final String sort,
        final Order order) {
        return new RtSearchPagination<>(
            this.request, "repositories", keywords, sort, order.identifier(),
            object -> this.github().repos().get(
                new Coordinates.Simple(object.getString("full_name"))
            )
        );
    }
    //@checkstyle ParameterNumberCheck (5 lines)
    @Override
    public Iterable<Issue> issues(final String keywords, final String sort,
        final Order order, final EnumMap<Qualifier, String> qualifiers) {
        final StringBuilder keyword = new StringBuilder(keywords);
        for (final EnumMap.Entry<Qualifier, String> entry : qualifiers
            .entrySet()) {
            keyword.append('+').append(entry.getKey().identifier())
                .append(':').append(entry.getValue());
        }
        return new RtSearchPagination<>(
            this.request,
            "issues",
            keyword.toString(),
            sort,
            order.identifier(),
            object -> {
                try {
                    final String[] parts = RtSearch.SLASH.split(
                        // @checkstyle MultipleStringLiteralsCheck (1 line)
                        new URI(object.getString("url")).getPath()
                    );
                    return this.ghub.repos().get(
                        // @checkstyle MagicNumber (1 line)
                        new Coordinates.Simple(parts[2], parts[3])
                    ).issues().get(object.getInt("number"));
                } catch (final URISyntaxException ex) {
                    throw new IllegalStateException(ex);
                }
            }
        );
    }
    @Override
    public Iterable<User> users(
        final String keywords,
        final String sort,
        final Order order) {
        return new RtSearchPagination<>(
            this.request, "users", keywords, sort, order.identifier(),
            object -> this.ghub.users().get(
                object.getString("login")
            )
        );
    }
    @Override
    public Iterable<Content> codes(
        final String keywords,
        final String sort,
        final Order order) {
        return new RtSearchPagination<>(
            this.request, "code", keywords, sort, order.identifier(),
            // @checkstyle AnonInnerLengthCheck (25 lines)
            object -> {
                try {
                    // @checkstyle MultipleStringLiteralsCheck (1 line)
                    final URI uri = new URI(object.getString("url"));
                    final String[] parts = RtSearch.SLASH.split(
                        uri.getPath()
                    );
                    final String ref = RtSearch.QUERY.split(
                        uri.getQuery()
                    )[1];
                    return this.ghub.repos().get(
                        // @checkstyle MagicNumber (1 line)
                        new Coordinates.Simple(parts[2], parts[3])
                    ).contents().get(object.getString("path"), ref);
                } catch (final URISyntaxException ex) {
                    throw new IllegalStateException(ex);
                } catch (final IOException ex) {
                    throw new IllegalStateException(ex);
                }
            }
        );
    }
}
/**
 * Copyright (c) 2013-2024, jcabi.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the jcabi.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jcabi.github.mock;
import com.jcabi.aspects.Immutable;
import com.jcabi.aspects.Loggable;
import com.jcabi.github.Content;
import com.jcabi.github.Coordinates;
import com.jcabi.github.Github;
import com.jcabi.github.Issue;
import com.jcabi.github.Repo;
import com.jcabi.github.Search;
import com.jcabi.github.User;
import java.util.EnumMap;
import lombok.EqualsAndHashCode;
import lombok.ToString;
/**
 * Mock Github search.
 *
 * @author Carlos Miranda (miranda.cma@gmail.com)
 * @version $Id$
 * @checkstyle ClassDataAbstractionCouplingCheck (500 lines)
 */
@Immutable
@Loggable(Loggable.DEBUG)
@ToString
@EqualsAndHashCode(of = { "storage", "self" })
final class MkSearch implements Search {
    /**
     * Storage.
     */
    private final transient MkStorage storage;
    /**
     * Login of the user logged in.
     */
    private final transient String self;
    /**
     * Public ctor.
     *
     * @param stg Storage
     * @param login User to login
     */
    MkSearch(
        final MkStorage stg,
        final String login
    ) {
        this.storage = stg;
        this.self = login;
    }
    @Override
    public Github github() {
        return new MkGithub(this.storage, this.self);
    }
    @Override
    public Iterable<Repo> repos(
        final String keywords,
        final String sort,
        final Order order
    ) {
        return new MkIterable<>(
            this.storage,
            "/github/repos/repo",
            xml -> new MkRepo(
                this.storage, this.self,
                new Coordinates.Simple(xml.xpath("@coords").get(0))
            )
        );
    }
    //@checkstyle ParameterNumberCheck (5 lines)
    @Override
    public Iterable<Issue> issues(final String keywords, final String sort,
        final Order order, final EnumMap<Qualifier, String> qualifiers
    ) {
        return new MkIterable<>(
            this.storage,
            "/github/repos/repo/issues/issue",
            xml -> new MkIssue(
                this.storage, this.self,
                new Coordinates.Simple(
                    xml.xpath("../../@coords").get(0)
                ),
                Integer.parseInt(xml.xpath("number/text()").get(0))
            )
        );
    }
    @Override
    public Iterable<User> users(
        final String keywords,
        final String sort,
        final Order order
    ) {
        return new MkIterable<>(
            this.storage,
            "/github/users/user",
            xml -> new MkUser(
                this.storage,
                xml.xpath("login/text()").get(0)
            )
        );
    }
    @Override
    public Iterable<Content> codes(
        final String keywords,
        final String sort,
        final Order order
    ) {
        return new MkIterable<>(
            this.storage,
            "/github/repos/repo/name",
            xml -> new MkContent(
                this.storage,
                this.self,
                new Coordinates.Simple(this.self, "repo"),
                "/path/to/search",
                "master"
            )
        );
    }
}