package bsh;
public class Types
{
	public static final int CAST=0, ASSIGNMENT=1;
	static final int 
		JAVA_BASE_ASSIGNABLE = 1,
		JAVA_BOX_TYPES_ASSIGABLE = 2,
		JAVA_VARARGS_ASSIGNABLE = 3,
		BSH_ASSIGNABLE = 4;
	static final int
		FIRST_ROUND_ASSIGNABLE = JAVA_BASE_ASSIGNABLE,
		LAST_ROUND_ASSIGNABLE = BSH_ASSIGNABLE;
	static Primitive VALID_CAST = new Primitive(1);
	static Primitive INVALID_CAST = new Primitive(-1);
    public static Class[] getTypes( Object[] args )
    {
        if ( args == null )
            return new Class[0];
        Class[] types = new Class[ args.length ];
        for( int i=0; i<args.length; i++ )
        {
			if ( args[i] == null )
				types[i] = null;
            else
			if ( args[i] instanceof Primitive )
                types[i] = ((Primitive)args[i]).getType();
            else
                types[i] = args[i].getClass();
        }
        return types;
    }
	public static boolean isSignatureAssignable( Class[] from, Class[] to, int round )
	{
		if ( round != JAVA_VARARGS_ASSIGNABLE && from.length != to.length )
			return false;
		switch ( round )
		{
			case JAVA_BASE_ASSIGNABLE:
				for( int i=0; i<from.length; i++ )
					if ( !isJavaBaseAssignable( to[i], from[i] ) )
						return false;
				return true;
			case JAVA_BOX_TYPES_ASSIGABLE:
				for( int i=0; i<from.length; i++ )
					if ( !isJavaBoxTypesAssignable( to[i], from[i] ) )
						return false;
				return true;
			case JAVA_VARARGS_ASSIGNABLE:
				return isSignatureVarargsAssignable( from, to );
			case BSH_ASSIGNABLE:
				for( int i=0; i<from.length; i++ )
					if ( !isBshAssignable( to[i], from[i] ) )
						return false;
				return true;
			default:
				throw new InterpreterError("bad case");
		}
	}
	private static boolean isSignatureVarargsAssignable(
		Class[] from, Class[] to )
	{
		return false;
	}
	public static boolean isJavaAssignable( Class lhsType, Class rhsType ) {
		return isJavaBaseAssignable( lhsType, rhsType )
			|| isJavaBoxTypesAssignable( lhsType, rhsType );
	}
	public static boolean isJavaBaseAssignable( Class<?> lhsType, Class<?> rhsType )
	{
		if ( lhsType == null )
			return false;
		if ( rhsType == null )
			return !lhsType.isPrimitive();
		if ( lhsType.isPrimitive() && rhsType.isPrimitive() )
		{
			if ( lhsType == rhsType )
				return true;
			if ( (rhsType == Byte.TYPE) &&
				(lhsType == Short.TYPE || lhsType == Integer.TYPE
				|| lhsType == Long.TYPE || lhsType == Float.TYPE
				|| lhsType == Double.TYPE))
                    return true;
            if ( (rhsType == Short.TYPE) &&
				(lhsType == Integer.TYPE || lhsType == Long.TYPE ||
                lhsType == Float.TYPE || lhsType == Double.TYPE))
                    return true;
            if ((rhsType == Character.TYPE) &&
				(lhsType == Integer.TYPE || lhsType == Long.TYPE ||
                lhsType == Float.TYPE || lhsType == Double.TYPE))
                    return true;
            if ((rhsType == Integer.TYPE) &&
				(lhsType == Long.TYPE || lhsType == Float.TYPE ||
                lhsType == Double.TYPE))
                    return true;
            if ((rhsType == Long.TYPE) &&
				(lhsType == Float.TYPE || lhsType == Double.TYPE))
                return true;
            if ((rhsType == Float.TYPE) && (lhsType == Double.TYPE))
                return true;
        }
        else
            if ( lhsType.isAssignableFrom(rhsType) )
                return true;
        return false;
    }
	public static boolean isJavaBoxTypesAssignable(
		Class lhsType, Class rhsType )
	{
		if ( lhsType == null )
			return false;
		if ( lhsType == Object.class )
			return true;
		if ( lhsType == Number.class
			&& rhsType != Character.TYPE
			&& rhsType != Boolean.TYPE
		)
			return true;
		if ( Primitive.wrapperMap.get( lhsType ) == rhsType )
			return true;
		return false;
	}
	public static boolean isBshAssignable( Class toType, Class fromType )
	{
		try {
			return castObject(
				toType, fromType, null,
				ASSIGNMENT, true
			) == VALID_CAST;
		} catch ( UtilEvalError e ) {
			throw new InterpreterError("err in cast check: "+e);
		}
	}
	public static Object castObject(
		Object fromValue, Class toType, int operation )
		throws UtilEvalError
	{
		if ( fromValue == null )
			throw new InterpreterError("null fromValue");
		Class fromType =
			fromValue instanceof Primitive ?
				((Primitive)fromValue).getType()
				: fromValue.getClass();
		return castObject(
			toType, fromType, fromValue, operation, false );
	}
	private static Object castObject(
		Class<?> toType, Class<?> fromType, Object fromValue,
		int operation, boolean checkOnly )
		throws UtilEvalError
	{
		if ( checkOnly && fromValue != null )
			throw new InterpreterError("bad cast params 1");
		if ( !checkOnly && fromValue == null )
			throw new InterpreterError("bad cast params 2");
		if ( fromType == Primitive.class )
			throw new InterpreterError("bad from Type, need to unwrap");
		if ( fromValue == Primitive.NULL && fromType != null )
			throw new InterpreterError("inconsistent args 1");
		if ( fromValue == Primitive.VOID && fromType != Void.TYPE )
			throw new InterpreterError("inconsistent args 2");
		if ( toType == Void.TYPE )
			throw new InterpreterError("loose toType should be null");
		if ( toType == null || toType == fromType )
			return checkOnly ? VALID_CAST :
				fromValue;
        if ( toType.isPrimitive() )
		{
			if ( fromType == Void.TYPE || fromType == null 
				|| fromType.isPrimitive() )
			{
				return Primitive.castPrimitive( 
					toType, fromType, (Primitive)fromValue, 
					checkOnly, operation );
			} else
			{
				if ( Primitive.isWrapperType( fromType ) )
				{
					Class unboxedFromType = Primitive.unboxType( fromType );
					Primitive primFromValue;
					if ( checkOnly ) 
						primFromValue = null; 
					else
						primFromValue = (Primitive)Primitive.wrap( 
							fromValue, unboxedFromType );
					return Primitive.castPrimitive( 
						toType, unboxedFromType, primFromValue, 
						checkOnly, operation );
				} else
				{
					if ( checkOnly )
						return INVALID_CAST;
					else
						throw castError( toType, fromType, operation );
				}
			}
        }
		if ( fromType == Void.TYPE || fromType == null
			|| fromType.isPrimitive() )
		{
			if ( Primitive.isWrapperType( toType )
				&& fromType != Void.TYPE && fromType != null )
			{
				return checkOnly ? VALID_CAST :
					Primitive.castWrapper( 
						Primitive.unboxType(toType), 
						((Primitive)fromValue).getValue() );
			}
			if ( toType == Object.class 
				&& fromType != Void.TYPE && fromType != null )
			{
				return checkOnly ? VALID_CAST :
					((Primitive)fromValue).getValue();
			}
			return Primitive.castPrimitive( 
				toType, fromType, (Primitive)fromValue, checkOnly, operation );
		}
		if ( toType.isAssignableFrom( fromType ) )
			return checkOnly ? VALID_CAST : 
				fromValue;
		if ( toType.isInterface() 
			&& bsh.This.class.isAssignableFrom( fromType ) 
		)
			return checkOnly ? VALID_CAST : 
				((bsh.This)fromValue).getInterface( toType );
		if ( Primitive.isWrapperType( toType ) 
			&& Primitive.isWrapperType( fromType ) 
		)
			return checkOnly ? VALID_CAST :
				Primitive.castWrapper( toType, fromValue );
		if ( checkOnly )
			return INVALID_CAST;
		else
			throw castError( toType, fromType , operation  );
	}
    public static UtilEvalError castError(
		Class lhsType, Class rhsType, int operation   ) 
    {
		return castError( 
			Reflect.normalizeClassName(lhsType),
			Reflect.normalizeClassName(rhsType), operation  );
    }
    public static UtilEvalError castError(
		String lhs, String rhs, int operation   ) 
    {
		if ( operation == ASSIGNMENT )
			return new UtilEvalError (
				"Can't assign " + rhs + " to "+ lhs );
		Exception cce = new ClassCastException(
			"Cannot cast " + rhs + " to " + lhs );
		return new UtilTargetError( cce );
    }
}
package bsh;
import bsh.ast.SimpleNode;
public class UtilTargetError extends UtilEvalError
{
	public Throwable t;
	public UtilTargetError( String message, Throwable t ) {
		super( message );
		this.t = t;
	}
	public UtilTargetError( Throwable t ) {
		this( null, t );
	}
	public EvalError toEvalError( 
		String msg, SimpleNode node, CallStack callstack  )
	{
		if ( msg == null )
			msg = getMessage();
		else
			msg = msg + ": " + getMessage();
		return new TargetError( msg, t, node, callstack, false );
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.ArrayList;
public final class Reflect {
	public static Object invokeObjectMethod(Object object, String methodName, Object[] args, BshEvaluatingVisitor visitor, SimpleNode callerInfo) throws ReflectError, EvalError, InvocationTargetException {
		if (object instanceof This && !This.isExposedThisMethod(methodName)) {
			return ((This) object).invokeMethod(methodName, args, visitor.getInterpreter(), visitor.getCallstack(), callerInfo, false);
		}
		try {
			BshClassManager bcm = visitor.getInterpreter() == null ? null : visitor.getInterpreter().getClassManager();
			Class clas = object.getClass();
			Method method = resolveExpectedJavaMethod(bcm, clas, object, methodName, args, false);
			return invokeMethod(method, object, args);
		} catch (UtilEvalError e) {
			throw e.toEvalError(callerInfo, visitor.getCallstack());
		}
	}
	public static Object invokeStaticMethod(BshClassManager bcm, Class clas, String methodName, Object[] args) throws ReflectError, UtilEvalError, InvocationTargetException {
		Interpreter.debug("invoke static Method");
		Method method = resolveExpectedJavaMethod(bcm, clas, null, methodName, args, true);
		return invokeMethod(method, null, args);
	}
	public static Object invokeMethod(Method method, Object object, Object[] args) throws ReflectError, InvocationTargetException {
		if (args == null) {
			args = new Object[0];
		}
		logInvokeMethod("Invoking method (entry): ", method, args);
		boolean isVarArgs = method.isVarArgs();
		Class[] types = method.getParameterTypes();
		Object[] tmpArgs = new Object[types.length];
		int fixedArgLen = types.length;
		if (isVarArgs) {
			if (fixedArgLen == args.length && types[fixedArgLen - 1].isAssignableFrom(args[fixedArgLen - 1].getClass())) {
				isVarArgs = false;
			} else {
				fixedArgLen--;
			}
		}
		try {
			for (int i = 0; i < fixedArgLen; i++) {
				tmpArgs[i] = Types.castObject(args[i], types[i], Types.ASSIGNMENT);
			}
			if (isVarArgs) {
				Class varType = types[fixedArgLen].getComponentType();
				Object varArgs = Array.newInstance(varType, args.length - fixedArgLen);
				for (int i = fixedArgLen, j = 0; i < args.length; i++, j++) {
					Array.set(varArgs, j, Primitive.unwrap(Types.castObject(args[i], varType, Types.ASSIGNMENT)));
				}
				tmpArgs[fixedArgLen] = varArgs;
			}
		} catch (UtilEvalError e) {
			throw new InterpreterError("illegal argument type in method invocation: " + e);
		}
		tmpArgs = Primitive.unwrap(tmpArgs);
		logInvokeMethod("Invoking method (after massaging values): ", method, tmpArgs);
		try {
			Object returnValue = method.invoke(object, tmpArgs);
			if (returnValue == null) {
				returnValue = Primitive.NULL;
			}
			Class returnType = method.getReturnType();
			return Primitive.wrap(returnValue, returnType);
		} catch (IllegalAccessException e) {
			throw new ReflectError("Cannot access method " + StringUtil.methodString(method.getName(), method.getParameterTypes()) + " in '" + method.getDeclaringClass() + "' :" + e, e);
		}
	}
	public static Object getIndex(Object array, int index) throws ReflectError, UtilTargetError {
		if (Interpreter.DEBUG) {
			Interpreter.debug("getIndex: " + array + ", index=" + index);
		}
		try {
			Object val = Array.get(array, index);
			return Primitive.wrap(val, array.getClass().getComponentType());
		} catch (ArrayIndexOutOfBoundsException e1) {
			throw new UtilTargetError(e1);
		} catch (Exception e) {
			throw new ReflectError("Array access:" + e);
		}
	}
	public static void setIndex(Object array, int index, Object val) throws ReflectError, UtilTargetError {
		try {
			val = Primitive.unwrap(val);
			Array.set(array, index, val);
		} catch (ArrayStoreException e2) {
			throw new UtilTargetError(e2);
		} catch (IllegalArgumentException e1) {
			throw new UtilTargetError(new ArrayStoreException(e1.toString()));
		} catch (Exception e) {
			throw new ReflectError("Array access:" + e);
		}
	}
	public static Object getStaticFieldValue(Class clas, String fieldName) throws UtilEvalError, ReflectError {
		return getFieldValue(clas, null, fieldName, true);
	}
	public static Object getObjectFieldValue(Object object, String fieldName) throws UtilEvalError, ReflectError {
		if (object instanceof This) {
			return ((This) object).namespace.getVariable(fieldName);
		} else if (object == Primitive.NULL) {
			throw new UtilTargetError(new NullPointerException("Attempt to access field '" + fieldName + "' on null value"));
		} else {
			try {
				return getFieldValue(object.getClass(), object, fieldName, false);
			} catch (ReflectError e) {
				if (hasObjectPropertyGetter(object.getClass(), fieldName)) {
					return getObjectProperty(object, fieldName);
				} else {
					throw e;
				}
			}
		}
	}
	public static LHS getLHSStaticField(Class clas, String fieldName) throws UtilEvalError, ReflectError {
		Field f = resolveExpectedJavaField(clas, fieldName, true);
		return new LHS(f);
	}
	public static LHS getLHSObjectField(Object object, String fieldName) throws UtilEvalError, ReflectError {
		if (object instanceof This) {
			boolean recurse = false;
			return new LHS(((This) object).namespace, fieldName, recurse);
		}
		try {
			Field f = resolveExpectedJavaField(object.getClass(), fieldName, false);
			return new LHS(object, f);
		} catch (ReflectError e) {
			if (hasObjectPropertySetter(object.getClass(), fieldName)) {
				return new LHS(object, fieldName);
			} else {
				throw e;
			}
		}
	}
	private static Object getFieldValue(Class clas, Object object, String fieldName, boolean staticOnly) throws UtilEvalError, ReflectError {
		try {
			Field f = resolveExpectedJavaField(clas, fieldName, staticOnly);
			Object value = f.get(object);
			Class returnType = f.getType();
			return Primitive.wrap(value, returnType);
		} catch (NullPointerException e) { 
			throw new ReflectError("???" + fieldName + " is not a static field.");
		} catch (IllegalAccessException e) {
			throw new ReflectError("Can't access field: " + fieldName);
		}
	}
	protected static Field resolveJavaField(Class clas, String fieldName, boolean staticOnly) throws UtilEvalError {
		try {
			return resolveExpectedJavaField(clas, fieldName, staticOnly);
		} catch (ReflectError e) {
			return null;
		}
	}
	protected static Field resolveExpectedJavaField(Class clas, String fieldName, boolean staticOnly) throws UtilEvalError, ReflectError {
		Field field;
		try {
			if (Capabilities.haveAccessibility()) {
				field = findAccessibleField(clas, fieldName);
			} else
			{
				field = clas.getField(fieldName);
			}
		} catch (NoSuchFieldException e) {
			throw new ReflectError("No such field: " + fieldName, e);
		} catch (SecurityException e) {
			throw new UtilTargetError("Security Exception while searching fields of: " + clas, e);
		}
		if (staticOnly && !Modifier.isStatic(field.getModifiers())) {
			throw new UtilEvalError("Can't reach instance field: " + fieldName + " from static context: " + clas.getName());
		}
		return field;
	}
	private static Field findAccessibleField(Class clas, String fieldName) throws UtilEvalError, NoSuchFieldException {
		Field field;
		try {
			field = clas.getField(fieldName);
			field.setAccessible(true);
			return field;
		} catch (NoSuchFieldException e) {
		}
		while (clas != null) {
			try {
				field = clas.getDeclaredField(fieldName);
				field.setAccessible(true);
				return field;
			} catch (NoSuchFieldException e) {
			}
			clas = clas.getSuperclass();
		}
		throw new NoSuchFieldException(fieldName);
	}
	protected static Method resolveExpectedJavaMethod(BshClassManager bcm, Class clas, Object object, String name, Object[] args, boolean staticOnly) throws ReflectError, UtilEvalError {
		if (object == Primitive.NULL) {
			throw new UtilTargetError(new NullPointerException("Attempt to invoke method " + name + " on null value"));
		}
		Class[] types = Types.getTypes(args);
		Method method = resolveJavaMethod(bcm, clas, name, types, staticOnly);
		if (method == null) {
			throw new ReflectError((staticOnly ? "Static method " : "Method ") + StringUtil.methodString(name, types) + " not found in class'" + clas.getName() + "'");
		}
		return method;
	}
	protected static Method resolveJavaMethod(BshClassManager bcm, Class clas, String name, Class[] types, boolean staticOnly) throws UtilEvalError {
		if (clas == null) {
			throw new InterpreterError("null class");
		}
		Method method = null;
		if (bcm == null) {
			Interpreter.debug("resolveJavaMethod UNOPTIMIZED lookup");
		} else {
			method = bcm.getResolvedMethod(clas, name, types, staticOnly);
		}
		if (method == null) {
			boolean publicOnly = !Capabilities.haveAccessibility();
			try {
				method = findOverloadedMethod(clas, name, types, publicOnly);
			} catch (SecurityException e) {
				throw new UtilTargetError("Security Exception while searching methods of: " + clas, e);
			}
			checkFoundStaticMethod(method, staticOnly, clas);
			if (method != null && (!publicOnly || isPublic(method))) {
				method.setAccessible(true);
			}
			if (method != null && bcm != null) {
				bcm.cacheResolvedMethod(clas, types, method);
			}
		}
		return method;
	}
	private static Method findOverloadedMethod(Class baseClass, String methodName, Class[] types, boolean publicOnly) {
		if (Interpreter.DEBUG) {
			Interpreter.debug("Searching for method: " + StringUtil.methodString(methodName, types) + " in '" + baseClass.getName() + "'");
		}
		List<Method> publicMethods = new ArrayList<Method>();
		List<Method> nonPublicMethods = publicOnly ? null : new ArrayList<Method>();
		gatherMethodsRecursive(baseClass, methodName, types.length, publicMethods, nonPublicMethods);
		if (Interpreter.DEBUG) {
			Interpreter.debug("Looking for most specific method: " + methodName);
		}
		Method method = findMostSpecificMethod(types, publicMethods);
		if (method == null && nonPublicMethods != null) {
			method = findMostSpecificMethod(types, nonPublicMethods);
		}
		return method;
	}
	private static void gatherMethodsRecursive(Class baseClass, String methodName, int numArgs, List<Method> publicMethods, List<Method> nonPublicMethods) {
		Class superclass = baseClass.getSuperclass();
		if (superclass != null) {
			gatherMethodsRecursive(superclass, methodName, numArgs, publicMethods, nonPublicMethods);
		}
		boolean isPublicClass = isPublic(baseClass);
		if (isPublicClass || nonPublicMethods != null) {
			Method[] methods = nonPublicMethods == null ? baseClass.getMethods() : baseClass.getDeclaredMethods();
			for (Method m : methods) {
				if (m.getName().equals(methodName) && (m.isVarArgs() ? m.getParameterTypes().length - 1 <= numArgs : m.getParameterTypes().length == numArgs)) {
					if (isPublicClass && isPublic(m)) {
						publicMethods.add(m);
					} else if (nonPublicMethods != null) {
						nonPublicMethods.add(m);
					}
				}
			}
		}
		for (Class intf : baseClass.getInterfaces()) {
			gatherMethodsRecursive(intf, methodName, numArgs, publicMethods, nonPublicMethods);
		}
	}
	public static Object constructObject(Class clas, Object[] args) throws ReflectError, InvocationTargetException {
		if (clas.isInterface()) {
			throw new ReflectError("Can't create instance of an interface: " + clas);
		}
		Class[] types = Types.getTypes(args);
		Constructor[] constructors = Capabilities.haveAccessibility() ? clas.getDeclaredConstructors() : clas.getConstructors();
		if (Interpreter.DEBUG) {
			Interpreter.debug("Looking for most specific constructor: " + clas);
		}
		Constructor con = findMostSpecificConstructor(types, constructors);
		if (con == null) {
			throw cantFindConstructor(clas, types);
		}
		if (!isPublic(con)) {
			con.setAccessible(true);
		}
		args = Primitive.unwrap(args);
		try {
			return con.newInstance(args);
		} catch (InstantiationException e) {
			throw new ReflectError("The class " + clas + " is abstract ");
		} catch (IllegalAccessException e) {
			throw new ReflectError("We don't have permission to create an instance." + "Use setAccessibility(true) to enable access.");
		} catch (IllegalArgumentException e) {
			throw new ReflectError("The number of arguments was wrong");
		}
	}
	static Constructor findMostSpecificConstructor(Class[] idealMatch, Constructor[] constructors) {
		int match = findMostSpecificConstructorIndex(idealMatch, constructors);
		return (match == -1) ? null : constructors[match];
	}
	static int findMostSpecificConstructorIndex(Class[] idealMatch, Constructor[] constructors) {
		Class[][] candidates = new Class[constructors.length][];
		for (int i = 0; i < candidates.length; i++) {
			candidates[i] = constructors[i].getParameterTypes();
		}
		return findMostSpecificSignature(idealMatch, candidates);
	}
	private static Method findMostSpecificMethod(Class[] idealMatch, List<Method> methods) {
		List<Class[]> candidateSigs = new ArrayList<Class[]>();
		List<Method> methodList = new ArrayList<Method>();
		for (Method method : methods) {
			Class[] parameterTypes = method.getParameterTypes();
			methodList.add(method);
			candidateSigs.add(parameterTypes);
			if (method.isVarArgs()) {
				Class[] candidateSig = new Class[idealMatch.length];
				int j = 0;
				for (; j < parameterTypes.length - 1; j++) {
					candidateSig[j] = parameterTypes[j];
				}
				Class varType = parameterTypes[j].getComponentType();
				for (; j < idealMatch.length; j++) {
					candidateSig[j] = varType;
				}
				methodList.add(method);
				candidateSigs.add(candidateSig);
			}
		}
		int match = findMostSpecificSignature(idealMatch, candidateSigs.toArray(new Class[candidateSigs.size()][]));
		return match == -1 ? null : methodList.get(match);
	}
	static int findMostSpecificSignature(Class[] idealMatch, Class[][] candidates) {
		for (int round = Types.FIRST_ROUND_ASSIGNABLE; round <= Types.LAST_ROUND_ASSIGNABLE; round++) {
			Class[] bestMatch = null;
			int bestMatchIndex = -1;
			for (int i = 0; i < candidates.length; i++) {
				Class[] targetMatch = candidates[i];
				if (Types.isSignatureAssignable(idealMatch, targetMatch, round) && ((bestMatch == null) || Types.isSignatureAssignable(targetMatch, bestMatch, Types.JAVA_BASE_ASSIGNABLE))) {
					bestMatch = targetMatch;
					bestMatchIndex = i;
				}
			}
			if (bestMatch != null) {
				return bestMatchIndex;
			}
		}
		return -1;
	}
	private static String accessorName(String getorset, String propName) {
		return getorset + String.valueOf(Character.toUpperCase(propName.charAt(0))) + propName.substring(1);
	}
	public static boolean hasObjectPropertyGetter(Class clas, String propName) {
		if (clas == Primitive.class) {
			return false;
		}
		String getterName = accessorName("get", propName);
		try {
			clas.getMethod(getterName, new Class[0]);
			return true;
		} catch (NoSuchMethodException e) {  }
		getterName = accessorName("is", propName);
		try {
			Method m = clas.getMethod(getterName, new Class[0]);
			return (m.getReturnType() == Boolean.TYPE);
		} catch (NoSuchMethodException e) {
			return false;
		}
	}
	public static boolean hasObjectPropertySetter(Class clas, String propName) {
		String setterName = accessorName("set", propName);
		Method[] methods = clas.getMethods();
		for (Method method : methods) {
			if (method.getName().equals(setterName)) {
				return true;
			}
		}
		return false;
	}
	public static Object getObjectProperty(Object obj, String propName) throws UtilEvalError, ReflectError {
		Object[] args = new Object[]{};
		Interpreter.debug("property access: ");
		Method method = null;
		Exception e1 = null, e2 = null;
		try {
			String accessorName = accessorName("get", propName);
			method = resolveExpectedJavaMethod(null, obj.getClass(), obj, accessorName, args, false);
		} catch (Exception e) {
			e1 = e;
		}
		if (method == null) {
			try {
				String accessorName = accessorName("is", propName);
				method = resolveExpectedJavaMethod(null, obj.getClass(), obj, accessorName, args, false);
				if (method.getReturnType() != Boolean.TYPE) {
					method = null;
				}
			} catch (Exception e) {
				e2 = e;
			}
		}
		if (method == null) {
			throw new ReflectError("Error in property getter: " + e1 + (e2 != null ? " : " + e2 : ""));
		}
		try {
			return invokeMethod(method, obj, args);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Property accessor threw exception: " + e.getTargetException());
		}
	}
	public static void setObjectProperty(Object obj, String propName, Object value) throws ReflectError, UtilEvalError {
		String accessorName = accessorName("set", propName);
		Object[] args = new Object[]{value};
		Interpreter.debug("property access: ");
		try {
			Method method = resolveExpectedJavaMethod(null, obj.getClass(), obj, accessorName, args, false);
			invokeMethod(method, obj, args);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Property accessor threw exception: " + e.getTargetException());
		}
	}
	public static String normalizeClassName(Class type) {
		if (!type.isArray()) {
			return type.getName();
		}
		StringBuilder className = new StringBuilder();
		try {
			className.append(getArrayBaseType(type).getName()).append(' ');
			for (int i = 0; i < getArrayDimensions(type); i++) {
				className.append("[]");
			}
		} catch (ReflectError e) {
		}
		return className.toString();
	}
	public static int getArrayDimensions(Class arrayClass) {
		if (!arrayClass.isArray()) {
			return 0;
		}
		return arrayClass.getName().lastIndexOf('[') + 1;  
	}
	public static Class getArrayBaseType(Class arrayClass) throws ReflectError {
		if (!arrayClass.isArray()) {
			throw new ReflectError("The class is not an array.");
		}
		return arrayClass.getComponentType();
	}
	public static Object invokeCompiledCommand(Class commandClass, Object[] args, BshEvaluatingVisitor visitor) throws UtilEvalError {
		Object[] invokeArgs = new Object[args.length + 2];
		invokeArgs[0] = visitor.getInterpreter();
		invokeArgs[1] = visitor.getCallstack();
		System.arraycopy(args, 0, invokeArgs, 2, args.length);
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		try {
			return Reflect.invokeStaticMethod(bcm, commandClass, "invoke", invokeArgs);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Error in compiled command: " + e.getTargetException(), e);
		} catch (ReflectError e) {
			throw new UtilEvalError("Error invoking compiled command: " + e, e);
		}
	}
	private static void logInvokeMethod(String msg, Method method, Object[] args) {
		if (Interpreter.DEBUG) {
			Interpreter.debug(msg + method + " with args:");
			for (int i = 0; i < args.length; i++) {
				final Object arg = args[i];
				Interpreter.debug("args[" + i + "] = " + arg + " type = " + (arg == null ? "<unkown>" : arg.getClass()));
			}
		}
	}
	private static void checkFoundStaticMethod(Method method, boolean staticOnly, Class clas) throws UtilEvalError {
		if (method != null && staticOnly && !isStatic(method)) {
			throw new UtilEvalError("Cannot reach instance method: " + StringUtil.methodString(method.getName(), method.getParameterTypes()) + " from static context: " + clas.getName());
		}
	}
	private static ReflectError cantFindConstructor(Class clas, Class[] types) {
		if (types.length == 0) {
			return new ReflectError("Can't find default constructor for: " + clas);
		} else {
			return new ReflectError("Can't find constructor: " + StringUtil.methodString(clas.getName(), types) + " in class: " + clas.getName());
		}
	}
	private static boolean isPublic(Class c) {
		return Modifier.isPublic(c.getModifiers());
	}
	private static boolean isPublic(Method m) {
		return Modifier.isPublic(m.getModifiers());
	}
	private static boolean isPublic(Constructor c) {
		return Modifier.isPublic(c.getModifiers());
	}
	private static boolean isStatic(Method m) {
		return Modifier.isStatic(m.getModifiers());
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.*;
import java.util.Map;
import java.util.HashMap;
public final class This implements java.io.Serializable, Runnable 
{
	final NameSpace namespace;
	transient Interpreter declaringInterpreter;
	private Map<Integer,Object> interfaces;
	private final InvocationHandler invocationHandler = new Handler();
    static This getThis( 
		NameSpace namespace, Interpreter declaringInterpreter ) 
	{
		return new This( namespace, declaringInterpreter );
    }
	public Object getInterface( Class clas ) 
	{
		return getInterface( new Class[] { clas } );
	}
	public Object getInterface( Class [] ca ) 
	{
		if ( interfaces == null )
			interfaces = new HashMap<Integer,Object>();
		int hash = 21;
		for(int i=0; i<ca.length; i++)
			hash *= ca[i].hashCode() + 3;
		Integer hashKey = new Integer(hash);
		Object interf = interfaces.get( hashKey );
		if ( interf == null ) 
		{
			ClassLoader classLoader = ca[0].getClassLoader(); 
			interf = Proxy.newProxyInstance( 
				classLoader, ca, invocationHandler );
			interfaces.put( hashKey, interf );
		}
		return interf;
	}
	class Handler implements InvocationHandler, java.io.Serializable 
	{
		public Object invoke( Object proxy, Method method, Object[] args ) 
			throws Throwable
		{
			try { 
				return invokeImpl( proxy, method, args );
			} catch ( TargetError te ) {
				Throwable t = te.getTarget();
				Class<? extends Throwable> c = t.getClass();
				String msg = t.getMessage();
				try {
					Throwable t2 = msg==null 
						? c.getConstructor().newInstance()
						: c.getConstructor(String.class).newInstance(msg)
					;
					t2.initCause(te);
					throw t2;
				} catch(NoSuchMethodException e) {
					throw t;
				}
			} catch ( EvalError ee ) {
				if ( Interpreter.DEBUG ) 
					Interpreter.debug( "EvalError in scripted interface: "
					+ This.this.toString() + ": "+ ee );
				throw ee;
			}
		}
		public Object invokeImpl( Object proxy, Method method, Object[] args ) 
			throws EvalError 
		{
			String methodName = method.getName();
			CallStack callstack = new CallStack( namespace );
			BshMethod equalsMethod = null;
			try {
				equalsMethod = namespace.getMethod( 
					"equals", new Class [] { Object.class } );
			} catch ( UtilEvalError e ) { }
			if ( methodName.equals("equals" ) && equalsMethod == null ) {
				Object obj = args[0];
				return proxy == obj;
			}
			BshMethod toStringMethod = null;
			try {
				toStringMethod = 
					namespace.getMethod( "toString", new Class [] { } );
			} catch ( UtilEvalError e ) { }
			if ( methodName.equals("toString" ) && toStringMethod == null)
			{
				Class [] ints = proxy.getClass().getInterfaces();
				StringBuilder sb = new StringBuilder( 
					This.this.toString() + "\nimplements:" );
				for(int i=0; i<ints.length; i++)
					sb.append( " "+ ints[i].getName() 
						+ ((ints.length > 1)?",":"") );
				return sb.toString();
			}
			Class [] paramTypes = method.getParameterTypes();
			return Primitive.unwrap( 
				invokeMethod( methodName, Primitive.wrap(args, paramTypes) ) );
		}
	}
	This( NameSpace namespace, Interpreter declaringInterpreter ) {
		this.namespace = namespace; 
		this.declaringInterpreter = declaringInterpreter;
	}
	public NameSpace getNameSpace() {
		return namespace;
	}
	public String toString() {
		return "'this' reference to Bsh object: " + namespace;
	}
	public void run() {
		try {
			invokeMethod( "run", new Object[0] );
		} catch( EvalError e ) {
			declaringInterpreter.error(
				"Exception in runnable:" + e );
		}
	}
	public Object invokeMethod( String name, Object [] args ) 
		throws EvalError
	{
		return invokeMethod( 
			name, args, null, null, null, 
			false );
	}
	public Object invokeMethod( 
		String methodName, Object [] args, 
		Interpreter interpreter, CallStack callstack, SimpleNode callerInfo,
		boolean declaredOnly  ) 
		throws EvalError
	{
		if ( args == null ) {
			args = new Object[0];
		} else {
			Object [] oa = new Object [args.length];
			for(int i=0; i<args.length; i++)
				oa[i] = ( args[i] == null ? Primitive.NULL : args[i] );
			args = oa;
		}
		if ( interpreter == null )
			interpreter = declaringInterpreter;
		if ( callstack == null )
			callstack = new CallStack( namespace );
		if ( callerInfo == null )
			callerInfo = SimpleNode.JAVACODE;
		Class [] types = Types.getTypes( args );
		BshMethod bshMethod = null;
		try {
			bshMethod = namespace.getMethod( methodName, types, declaredOnly );
		} catch ( UtilEvalError e ) {
		}
		if ( bshMethod != null )
			return bshMethod.invoke( args, new BshEvaluatingVisitor(callstack,  interpreter), callerInfo );
		if ( methodName.equals("toString") && args.length==0 )
			return toString();
		if ( methodName.equals("hashCode") && args.length==0 )
			return new Integer(this.hashCode());
		if ( methodName.equals("equals") && args.length==1 ) {
			Object obj = args[0];
			return new Boolean( this == obj );
		}
		if ( methodName.equals("clone") && args.length==0 ) {
			NameSpace ns = new NameSpace(namespace,namespace.getName()+" clone");
			try {
				for( String varName : namespace.getVariableNames() ) {
					ns.setLocalVariable(varName,namespace.getVariable(varName,false),false);
				}
				for( BshMethod method : namespace.getMethods() ) {
					ns.setMethod(method);
				}
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( SimpleNode.JAVACODE, callstack ); 
			}
			return ns.getThis(declaringInterpreter);
		}
		try {
			bshMethod = namespace.getMethod( 
				"invoke", new Class [] { null, null } );
		} catch ( UtilEvalError e ) {  }
		if ( bshMethod != null )
			return bshMethod.invoke( new Object [] { methodName, args }, 
				new BshEvaluatingVisitor(callstack,  interpreter), callerInfo );
		throw new EvalError("Method " + 
			StringUtil.methodString( methodName, types ) +
			" not found in bsh scripted object: "+ namespace.getName(), 
			callerInfo, callstack );
	}
	public static void bind( 
		This ths, NameSpace namespace, Interpreter declaringInterpreter ) 
	{ 
		ths.namespace.setParent( namespace ); 
		ths.declaringInterpreter = declaringInterpreter;
	}
	static boolean isExposedThisMethod( String name ) 
	{
		return 
			name.equals("getClass") 
			|| name.equals("invokeMethod")
			|| name.equals("getInterface")
			|| name.equals("wait") 
			|| name.equals("notify")
			|| name.equals("notifyAll");
	}
}
package bsh;
import bsh.ast.SimpleNode;
public class InterpreterError extends RuntimeException {
	public InterpreterError(final String s) {
		super(s);
	}
    public InterpreterError(final String s, final SimpleNode node) {
        super(s + " (at " + node.getSourceFile() + ":" + node.getLineNumber() + "\n" + node.getText());
    }
	public InterpreterError(final String s, final Throwable cause) {
		super(s, cause);
	}
}
package bsh;
import bsh.ast.*;
import bsh.interpreter.BshEvaluatingVisitor;
import bsh.interpreter.BshInterpreterUtil;
import org.objectweb.asm.*;
import org.objectweb.asm.Type;
import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.List;
public class ClassGeneratorUtil implements Opcodes {
	static final String BSHSTATIC = "_bshStatic";
	private static final String BSHTHIS = "_bshThis";
	static final String BSHSUPER = "_bshSuper";
	static final String BSHINIT = "_bshInstanceInitializer";
	private static final String BSHCONSTRUCTORS = "_bshConstructors";
	private static final int DEFAULTCONSTRUCTOR = -1;
	private static final String OBJECT = "Ljava/lang/Object;";
	private final String className;
	private final String fqClassName;
	private final Class superClass;
	private final String superClassName;
	private final Class[] interfaces;
	private final Variable[] vars;
	private final Constructor[] superConstructors;
	private final DelayedEvalBshMethod[] constructors;
	private final DelayedEvalBshMethod[] methods;
	private final NameSpace classStaticNameSpace;
	private final Modifiers classModifiers;
	private boolean isInterface;
	public ClassGeneratorUtil(Modifiers classModifiers, String className, String packageName, Class superClass, Class[] interfaces, Variable[] vars, DelayedEvalBshMethod[] bshmethods, NameSpace classStaticNameSpace, boolean isInterface) {
		this.classModifiers = classModifiers;
		this.className = className;
		if (packageName != null) {
			this.fqClassName = packageName.replace('.', '/') + "/" + className;
		} else {
			this.fqClassName = className;
		}
		if (superClass == null) {
			superClass = Object.class;
		}
		this.superClass = superClass;
		this.superClassName = Type.getInternalName(superClass);
		if (interfaces == null) {
			interfaces = new Class[0];
		}
		this.interfaces = interfaces;
		this.vars = vars;
		this.classStaticNameSpace = classStaticNameSpace;
		this.superConstructors = superClass.getDeclaredConstructors();
		List consl = new ArrayList();
		List methodsl = new ArrayList();
		String classBaseName = getBaseName(className); 
		for (DelayedEvalBshMethod bshmethod : bshmethods) {
			if (bshmethod.getName().equals(classBaseName)) {
				consl.add(bshmethod);
			} else {
				methodsl.add(bshmethod);
			}
		}
		this.constructors = (DelayedEvalBshMethod[]) consl.toArray(new DelayedEvalBshMethod[consl.size()]);
		this.methods = (DelayedEvalBshMethod[]) methodsl.toArray(new DelayedEvalBshMethod[methodsl.size()]);
		try {
			classStaticNameSpace.setLocalVariable(BSHCONSTRUCTORS, constructors, false);
		} catch (UtilEvalError e) {
			throw new InterpreterError("can't set cons var");
		}
		this.isInterface = isInterface;
	}
	public byte[] generateClass() {
		int classMods = getASMModifiers(classModifiers) | ACC_PUBLIC;
		if (isInterface) {
			classMods |= (ACC_INTERFACE|ACC_ABSTRACT);
		}
		String[] interfaceNames = new String[interfaces.length + (isInterface ? 0 : 1)]; 
		for (int i = 0; i < interfaces.length; i++) {
			interfaceNames[i] = Type.getInternalName(interfaces[i]);
		}
		if ( ! isInterface) {
			interfaceNames[interfaces.length] = Type.getInternalName(GeneratedClass.class);
		}
		String sourceFile = "BeanShell Generated via ASM (www.objectweb.org)";
		ClassWriter cw = new ClassWriter(0);
		cw.visit(Opcodes.V1_6, classMods, fqClassName, null, superClassName, interfaceNames);
		if ( ! isInterface) {
			generateField(BSHTHIS + className, "Lbsh/This;", ACC_PUBLIC, cw);
			generateField(BSHSTATIC + className, "Lbsh/This;", ACC_PUBLIC + ACC_STATIC, cw);
		}
		for (Variable var : vars) {
			String type = var.getTypeDescriptor();
			if (var.hasModifier("private") || type == null) {
				continue;
			}
			int modifiers;
			if (isInterface) {
				modifiers = ACC_PUBLIC | ACC_STATIC | ACC_FINAL;
			} else {
				modifiers = getASMModifiers(var.getModifiers());
			}
			generateField(var.getName(), type, modifiers, cw);
		}
		boolean hasConstructor = false;
		for (int i = 0; i < constructors.length; i++) {
			if (constructors[i].hasModifier("private")) {
				continue;
			}
			int modifiers = getASMModifiers(constructors[i].getModifiers());
			generateConstructor(i, constructors[i].getParamTypeDescriptors(), modifiers, cw);
			hasConstructor = true;
		}
		if ( ! isInterface &&  ! hasConstructor) {
			generateConstructor(DEFAULTCONSTRUCTOR, new String[0], ACC_PUBLIC, cw);
		}
		for (DelayedEvalBshMethod method : methods) {
			String returnType = method.getReturnTypeDescriptor();
			if (method.hasModifier("private") ) {
				continue;
			}
			int modifiers = getASMModifiers(method.getModifiers());
			if (isInterface) {
				modifiers |= (ACC_PUBLIC | ACC_ABSTRACT);
			}
			generateMethod(className, fqClassName, method.getName(), returnType, method.getParamTypeDescriptors(), modifiers, cw);
			boolean isStatic = (modifiers & ACC_STATIC) > 0;
			boolean overridden = classContainsMethod(superClass, method.getName(), method.getParamTypeDescriptors());
			if (!isStatic && overridden) {
				generateSuperDelegateMethod(superClassName, method.getName(), returnType, method.getParamTypeDescriptors(), modifiers, cw);
			}
		}
		return cw.toByteArray();
	}
	private static int getASMModifiers(Modifiers modifiers) {
		int mods = 0;
		if (modifiers == null) {
			return mods;
		}
		if (modifiers.hasModifier("public")) {
			mods += ACC_PUBLIC;
		}
		if (modifiers.hasModifier("protected")) {
			mods += ACC_PROTECTED;
		}
		if (modifiers.hasModifier("static")) {
			mods += ACC_STATIC;
		}
		if (modifiers.hasModifier("synchronized")) {
			mods += ACC_SYNCHRONIZED;
		}
		if (modifiers.hasModifier("abstract")) {
			mods += ACC_ABSTRACT;
		}
		return mods;
	}
	private static void generateField(String fieldName, String type, int modifiers, ClassWriter cw) {
		cw.visitField(modifiers, fieldName, type, null, null);
	}
	private static void generateMethod(String className, String fqClassName, String methodName, String returnType, String[] paramTypes, int modifiers, ClassWriter cw) {
		String[] exceptions = null;
		boolean isStatic = (modifiers & ACC_STATIC) != 0;
		if (returnType == null) 
		{
			returnType = OBJECT;
		}
		String methodDescriptor = getMethodDescriptor(returnType, paramTypes);
		MethodVisitor cv = cw.visitMethod(modifiers, methodName, methodDescriptor, null, exceptions);
		if ((modifiers & ACC_ABSTRACT) != 0) {
			return;
		}
		if (isStatic) {
			cv.visitFieldInsn(GETSTATIC, fqClassName, BSHSTATIC + className, "Lbsh/This;");
		} else {
			cv.visitVarInsn(ALOAD, 0);
			cv.visitFieldInsn(GETFIELD, fqClassName, BSHTHIS + className, "Lbsh/This;");
		}
		cv.visitLdcInsn(methodName);
		generateParameterReifierCode(paramTypes, isStatic, cv);
		cv.visitInsn(ACONST_NULL); 
		cv.visitInsn(ACONST_NULL); 
		cv.visitInsn(ACONST_NULL); 
		cv.visitInsn(ICONST_1);
		cv.visitMethodInsn(INVOKEVIRTUAL, "bsh/This", "invokeMethod", Type.getMethodDescriptor(Type.getType(Object.class),
                new Type[]{Type.getType(String.class), Type.getType(Object[].class), Type.getType(Interpreter.class),
                        Type.getType(CallStack.class), Type.getType(SimpleNode.class), Type.getType(Boolean.TYPE)}));
		cv.visitMethodInsn(INVOKESTATIC, "bsh/Primitive", "unwrap", "(Ljava/lang/Object;)Ljava/lang/Object;");
		generateReturnCode(returnType, cv);
	    cv.visitMaxs(20, 20);
	}
	public void generateConstructor(int index, String[] paramTypes, int modifiers, ClassWriter cw) {
		final int argsVar = paramTypes.length + 1;
		final int consArgsVar = paramTypes.length + 2;
		String[] exceptions = null;
		String methodDescriptor = getMethodDescriptor("V", paramTypes);
		MethodVisitor cv = cw.visitMethod(modifiers, "<init>", methodDescriptor, null, exceptions);
		generateParameterReifierCode(paramTypes, false, cv);
		cv.visitVarInsn(ASTORE, argsVar);
		generateConstructorSwitch(index, argsVar, consArgsVar, cv);
		cv.visitVarInsn(ALOAD, 0);
		cv.visitLdcInsn(className);
		cv.visitVarInsn(ALOAD, argsVar);
		cv.visitMethodInsn(INVOKESTATIC, "bsh/ClassGeneratorUtil", "initInstance", "(L" + GeneratedClass.class.getName().replace('.', '/') + ";Ljava/lang/String;[Ljava/lang/Object;)V");
		cv.visitInsn(RETURN);
		cv.visitMaxs(20, 20);
	}
	void generateConstructorSwitch(int consIndex, int argsVar, int consArgsVar, MethodVisitor cv) {
		Label defaultLabel = new Label();
		Label endLabel = new Label();
		int cases = superConstructors.length + constructors.length;
		Label[] labels = new Label[cases];
		for (int i = 0; i < cases; i++) {
			labels[i] = new Label();
		}
		cv.visitLdcInsn(superClass.getName()); 
		cv.visitFieldInsn(GETSTATIC, fqClassName, BSHSTATIC + className, "Lbsh/This;");
		cv.visitVarInsn(ALOAD, argsVar);
		cv.visitIntInsn(BIPUSH, consIndex);
		cv.visitMethodInsn(INVOKESTATIC, "bsh/ClassGeneratorUtil", "getConstructorArgs", "(Ljava/lang/String;Lbsh/This;[Ljava/lang/Object;I)" + "Lbsh/ClassGeneratorUtil$ConstructorArgs;");
		cv.visitVarInsn(ASTORE, consArgsVar);
		cv.visitVarInsn(ALOAD, consArgsVar);
		cv.visitFieldInsn(GETFIELD, "bsh/ClassGeneratorUtil$ConstructorArgs", "selector", "I");
		cv.visitTableSwitchInsn(0, cases - 1, defaultLabel, labels);
		int index = 0;
		for (int i = 0; i < superConstructors.length; i++, index++) {
			doSwitchBranch(index, superClassName, getTypeDescriptors(superConstructors[i].getParameterTypes()), endLabel, labels, consArgsVar, cv);
		}
		for (int i = 0; i < constructors.length; i++, index++) {
			doSwitchBranch(index, fqClassName, constructors[i].getParamTypeDescriptors(), endLabel, labels, consArgsVar, cv);
		}
		cv.visitLabel(defaultLabel);
		cv.visitVarInsn(ALOAD, 0); 
		cv.visitMethodInsn(INVOKESPECIAL, superClassName, "<init>", "()V");
		cv.visitLabel(endLabel);
	}
	private static void doSwitchBranch(int index, String targetClassName, String[] paramTypes, Label endLabel, Label[] labels, int consArgsVar, MethodVisitor cv) {
		cv.visitLabel(labels[index]);
		cv.visitVarInsn(ALOAD, 0); 
		for (String type : paramTypes) {
			final String method;
			if (type.equals("Z")) {
				method = "getBoolean";
			} else if (type.equals("B")) {
				method = "getByte";
			} else if (type.equals("C")) {
				method = "getChar";
			} else if (type.equals("S")) {
				method = "getShort";
			} else if (type.equals("I")) {
				method = "getInt";
			} else if (type.equals("J")) {
				method = "getLong";
			} else if (type.equals("D")) {
				method = "getDouble";
			} else if (type.equals("F")) {
				method = "getFloat";
			} else {
				method = "getObject";
			}
			cv.visitVarInsn(ALOAD, consArgsVar); 
			String className = "bsh/ClassGeneratorUtil$ConstructorArgs";
			String retType;
			if (method.equals("getObject")) {
				retType = OBJECT;
			} else {
				retType = type;
			}
			cv.visitMethodInsn(INVOKEVIRTUAL, className, method, "()" + retType);
			if (method.equals("getObject")) {
				cv.visitTypeInsn(CHECKCAST, descriptorToClassName(type));
			}
		}
		String descriptor = getMethodDescriptor("V", paramTypes);
		cv.visitMethodInsn(INVOKESPECIAL, targetClassName, "<init>", descriptor);
		cv.visitJumpInsn(GOTO, endLabel);
	}
	private static String getMethodDescriptor(String returnType, String[] paramTypes) {
		StringBuilder sb = new StringBuilder("(");
		for (String paramType : paramTypes) {
			sb.append(paramType);
		}
		sb.append(')').append(returnType);
		return sb.toString();
	}
	private static void generateSuperDelegateMethod(String superClassName, String methodName, String returnType, String[] paramTypes, int modifiers, ClassWriter cw) {
		String[] exceptions = null;
		if (returnType == null) 
		{
			returnType = OBJECT;
		}
		String methodDescriptor = getMethodDescriptor(returnType, paramTypes);
		MethodVisitor cv = cw.visitMethod(modifiers, "_bshSuper" + methodName, methodDescriptor, null, exceptions);
		cv.visitVarInsn(ALOAD, 0);
		int localVarIndex = 1;
		for (String paramType : paramTypes) {
			if (isPrimitive(paramType)) {
				cv.visitVarInsn(ILOAD, localVarIndex);
			} else {
				cv.visitVarInsn(ALOAD, localVarIndex);
			}
			localVarIndex += ((paramType.equals("D") || paramType.equals("J")) ? 2 : 1);
		}
		cv.visitMethodInsn(INVOKESPECIAL, superClassName, methodName, methodDescriptor);
		generatePlainReturnCode(returnType, cv);
		cv.visitMaxs(20, 20);
	}
	boolean classContainsMethod(Class clas, String methodName, String[] paramTypes) {
		while (clas != null) {
			Method[] methods = clas.getDeclaredMethods();
			for (Method method : methods) {
				if (method.getName().equals(methodName)) {
					String[] methodParamTypes = getTypeDescriptors(method.getParameterTypes());
					boolean found = true;
					for (int j = 0; j < methodParamTypes.length; j++) {
						if (!paramTypes[j].equals(methodParamTypes[j])) {
							found = false;
							break;
						}
					}
					if (found) {
						return true;
					}
				}
			}
			clas = clas.getSuperclass();
		}
		return false;
	}
	private static void generatePlainReturnCode(String returnType, MethodVisitor cv) {
		if (returnType.equals("V")) {
			cv.visitInsn(RETURN);
		} else if (isPrimitive(returnType)) {
			int opcode = IRETURN;
			if (returnType.equals("D")) {
				opcode = DRETURN;
			} else if (returnType.equals("F")) {
				opcode = FRETURN;
			} else if (returnType.equals("J"))  
			{
				opcode = LRETURN;
			}
			cv.visitInsn(opcode);
		} else {
			cv.visitTypeInsn(CHECKCAST, descriptorToClassName(returnType));
			cv.visitInsn(ARETURN);
		}
	}
	private static void generateParameterReifierCode(String[] paramTypes, boolean isStatic, final MethodVisitor cv) {
		cv.visitIntInsn(SIPUSH, paramTypes.length);
		cv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
		int localVarIndex = isStatic ? 0 : 1;
		for (int i = 0; i < paramTypes.length; ++i) {
			String param = paramTypes[i];
			cv.visitInsn(DUP);
			cv.visitIntInsn(SIPUSH, i);
			if (isPrimitive(param)) {
				int opcode;
				if (param.equals("F")) {
					opcode = FLOAD;
				} else if (param.equals("D")) {
					opcode = DLOAD;
				} else if (param.equals("J")) {
					opcode = LLOAD;
				} else {
					opcode = ILOAD;
				}
				String type = "bsh/Primitive";
				cv.visitTypeInsn(NEW, type);
				cv.visitInsn(DUP);
				cv.visitVarInsn(opcode, localVarIndex);
				String desc = param; 
				cv.visitMethodInsn(INVOKESPECIAL, type, "<init>", "(" + desc + ")V");
			} else {
				cv.visitVarInsn(ALOAD, localVarIndex);
			}
			cv.visitInsn(AASTORE);
			localVarIndex += ((param.equals("D") || param.equals("J")) ? 2 : 1);
		}
	}
	private static void generateReturnCode(String returnType, MethodVisitor cv) {
		if (returnType.equals("V")) {
			cv.visitInsn(POP);
			cv.visitInsn(RETURN);
		} else if (isPrimitive(returnType)) {
			int opcode = IRETURN;
			String type;
			String meth;
			if (returnType.equals("B")) {
				type = "java/lang/Byte";
				meth = "byteValue";
			} else if (returnType.equals("I")) {
				type = "java/lang/Integer";
				meth = "intValue";
			} else if (returnType.equals("Z")) {
				type = "java/lang/Boolean";
				meth = "booleanValue";
			} else if (returnType.equals("D")) {
				opcode = DRETURN;
				type = "java/lang/Double";
				meth = "doubleValue";
			} else if (returnType.equals("F")) {
				opcode = FRETURN;
				type = "java/lang/Float";
				meth = "floatValue";
			} else if (returnType.equals("J")) {
				opcode = LRETURN;
				type = "java/lang/Long";
				meth = "longValue";
			} else if (returnType.equals("C")) {
				type = "java/lang/Character";
				meth = "charValue";
			} else  {
				type = "java/lang/Short";
				meth = "shortValue";
			}
			String desc = returnType;
			cv.visitTypeInsn(CHECKCAST, type); 
			cv.visitMethodInsn(INVOKEVIRTUAL, type, meth, "()" + desc);
			cv.visitInsn(opcode);
		} else {
			cv.visitTypeInsn(CHECKCAST, descriptorToClassName(returnType));
			cv.visitInsn(ARETURN);
		}
	}
	public static ConstructorArgs getConstructorArgs(String superClassName, This classStaticThis, Object[] consArgs, int index) {
		DelayedEvalBshMethod[] constructors;
		try {
			constructors = (DelayedEvalBshMethod[]) classStaticThis.getNameSpace().getVariable(BSHCONSTRUCTORS);
		} catch (Exception e) {
			throw new InterpreterError("unable to get instance initializer: " + e);
		}
		if (index == DEFAULTCONSTRUCTOR) 
		{
			return ConstructorArgs.DEFAULT;
		} 
		DelayedEvalBshMethod constructor = constructors[index];
		if (constructor.methodBody.jjtGetNumChildren() == 0) {
			return ConstructorArgs.DEFAULT;
		} 
		String altConstructor = null;
		BSHArguments argsNode = null;
		SimpleNode firstStatement = (SimpleNode) constructor.methodBody.jjtGetChild(0);
		if (firstStatement instanceof BSHPrimaryExpression) {
			firstStatement = (SimpleNode) firstStatement.jjtGetChild(0);
		}
		if (firstStatement instanceof BSHMethodInvocation) {
			BSHMethodInvocation methodNode = (BSHMethodInvocation) firstStatement;
			BSHAmbiguousName methodName = methodNode.getNameNode();
			if (methodName.text.equals("super") || methodName.text.equals("this")) {
				altConstructor = methodName.text;
				argsNode = methodNode.getArgsNode();
			}
		}
		if (altConstructor == null) {
			return ConstructorArgs.DEFAULT;
		} 
		NameSpace consArgsNameSpace = new NameSpace(classStaticThis.getNameSpace(), "consArgs");
		String[] consArgNames = constructor.getParameterNames();
		Class[] consArgTypes = constructor.getParameterTypes();
		for (int i = 0; i < consArgs.length; i++) {
			try {
				consArgsNameSpace.setTypedVariable(consArgNames[i], consArgTypes[i], consArgs[i], null);
			} catch (UtilEvalError e) {
				throw new InterpreterError("err setting local cons arg:" + e);
			}
		}
		CallStack callstack = new CallStack();
		callstack.push(consArgsNameSpace);
		Object[] args;
		Interpreter interpreter = classStaticThis.declaringInterpreter;
		try {
			args = new BshEvaluatingVisitor(callstack, interpreter).getArguments(argsNode);
		} catch (EvalError e) {
			throw new InterpreterError("Error evaluating constructor args: " + e);
		}
		Class[] argTypes = Types.getTypes(args);
		args = Primitive.unwrap(args);
		Class superClass = interpreter.getClassManager().classForName(superClassName);
		if (superClass == null) {
			throw new InterpreterError("can't find superclass: " + superClassName);
		}
		Constructor[] superCons = superClass.getDeclaredConstructors();
		if (altConstructor.equals("super")) {
			int i = Reflect.findMostSpecificConstructorIndex(argTypes, superCons);
			if (i == -1) {
				throw new InterpreterError("can't find constructor for args!");
			}
			return new ConstructorArgs(i, args);
		}
		Class[][] candidates = new Class[constructors.length][];
		for (int i = 0; i < candidates.length; i++) {
			candidates[i] = constructors[i].getParameterTypes();
		}
		int i = Reflect.findMostSpecificSignature(argTypes, candidates);
		if (i == -1) {
			throw new InterpreterError("can't find constructor for args 2!");
		}
		int selector = i + superCons.length;
		int ourSelector = index + superCons.length;
		if (selector == ourSelector) {
			throw new InterpreterError("Recusive constructor call.");
		}
		return new ConstructorArgs(selector, args);
	}
	private static final ThreadLocal<NameSpace> CONTEXT_NAMESPACE = new ThreadLocal<NameSpace>();
	private static final ThreadLocal<Interpreter> CONTEXT_INTERPRETER = new ThreadLocal<Interpreter>();
	public static void registerConstructorContext(CallStack callstack, Interpreter interpreter) {
		if (callstack != null) {
			CONTEXT_NAMESPACE.set(callstack.top());
		} else {
			CONTEXT_NAMESPACE.remove();
		}
		if (interpreter != null) {
			CONTEXT_INTERPRETER.set(interpreter);
		} else {
			CONTEXT_INTERPRETER.remove();
		}
	}
	public static void initInstance(GeneratedClass instance, String className, Object[] args) {
		Class[] sig = Types.getTypes(args);
		CallStack callstack = new CallStack();
		Interpreter interpreter;
		NameSpace instanceNameSpace;
		This instanceThis = getClassInstanceThis(instance, className);
		if (instanceThis == null) {
			This classStaticThis = getClassStaticThis(instance.getClass(), className);
			interpreter = CONTEXT_INTERPRETER.get();
			if (interpreter == null) {
				interpreter = classStaticThis.declaringInterpreter;
			}
			BSHBlock instanceInitBlock;
			try {
				instanceInitBlock = (BSHBlock) classStaticThis.getNameSpace().getVariable(BSHINIT);
			} catch (Exception e) {
				throw new InterpreterError("unable to get instance initializer: " + e);
			}
			if (CONTEXT_NAMESPACE.get() != null) {
				instanceNameSpace = classStaticThis.getNameSpace().copy();
				instanceNameSpace.setParent(CONTEXT_NAMESPACE.get());
			} else {
				instanceNameSpace = new NameSpace(classStaticThis.getNameSpace(), className); 
			}
			instanceNameSpace.isClass = true;
			instanceThis = instanceNameSpace.getThis(interpreter);
			try {
				LHS lhs = Reflect.getLHSObjectField(instance, BSHTHIS + className);
				lhs.assign(instanceThis, false);
			} catch (Exception e) {
				throw new InterpreterError("Error in class gen setup: " + e);
			}
			instanceNameSpace.setClassInstance(instance);
			callstack.push(instanceNameSpace);
			try { 
				new BshEvaluatingVisitor(callstack, interpreter).evalBlock(instanceInitBlock, true, ClassGenerator.ClassNodeFilter.CLASSINSTANCE);
			} catch (Exception e) {
				throw new InterpreterError("Error in class initialization: " + e, e);
			}
			callstack.pop();
		} else {
			interpreter = instanceThis.declaringInterpreter;
			instanceNameSpace = instanceThis.getNameSpace();
		}
		String constructorName = getBaseName(className);
		try {
			BshMethod constructor = instanceNameSpace.getMethod(constructorName, sig, true);
			if (args.length > 0 && constructor == null) {
				throw new InterpreterError("Can't find constructor: " + className);
			}
			if (constructor != null) {
				constructor.invoke(args, new BshEvaluatingVisitor(callstack,  interpreter),
                        null, false);
			}
		} catch (Throwable e) {
			if (e instanceof TargetError) {
				e = (Exception) ((TargetError) e).getTarget();
			}
			if (e instanceof InvocationTargetException) {
				e = (Exception) ((InvocationTargetException) e).getTargetException();
			}
			throw new InterpreterError("Error in class initialization: " + e);
		}
	}
	private static This getClassStaticThis(Class clas, String className) {
		try {
			return (This) Reflect.getStaticFieldValue(clas, BSHSTATIC + className);
		} catch (Exception e) {
			throw new InterpreterError("Unable to get class static space: " + e);
		}
	}
	static This getClassInstanceThis(Object instance, String className) {
		try {
			Object o = Reflect.getObjectFieldValue(instance, BSHTHIS + className);
			return (This) Primitive.unwrap(o); 
		} catch (Exception e) {
			throw new InterpreterError("Generated class: Error getting This" + e);
		}
	}
	private static boolean isPrimitive(String typeDescriptor) {
		return typeDescriptor.length() == 1; 
	}
	private static String[] getTypeDescriptors(Class[] cparams) {
		String[] sa = new String[cparams.length];
		for (int i = 0; i < sa.length; i++) {
			sa[i] = BshInterpreterUtil.getTypeDescriptor(cparams[i]);
		}
		return sa;
	}
	private static String descriptorToClassName(String s) {
		if (s.startsWith("[") || !s.startsWith("L")) {
			return s;
		}
		return s.substring(1, s.length() - 1);
	}
	private static String getBaseName(String className) {
		int i = className.indexOf("$");
		if (i == -1) {
			return className;
		}
		return className.substring(i + 1);
	}
	public static class ConstructorArgs {
		public static final ConstructorArgs DEFAULT = new ConstructorArgs();
		public int selector = DEFAULTCONSTRUCTOR;
		Object[] args;
		int arg;
		ConstructorArgs() {
		}
		ConstructorArgs(int selector, Object[] args) {
			this.selector = selector;
			this.args = args;
		}
		Object next() {
			return args[arg++];
		}
		public boolean getBoolean() {
			return (Boolean) next();
		}
		public byte getByte() {
			return (Byte) next();
		}
		public char getChar() {
			return (Character) next();
		}
		public short getShort() {
			return (Short) next();
		}
		public int getInt() {
			return (Integer) next();
		}
		public long getLong() {
			return (Long) next();
		}
		public double getDouble() {
			return (Double) next();
		}
		public float getFloat() {
			return (Float) next();
		}
		public Object getObject() {
			return next();
		}
	}
}
package bsh;
import java.io.ObjectStreamException;
import java.util.HashMap;
import java.util.Map;
public final class Primitive implements ParserConstants, java.io.Serializable
{
	static final Map<Class,Class> wrapperMap = new HashMap<Class,Class>();
	static {
		wrapperMap.put( Boolean.TYPE, Boolean.class );
		wrapperMap.put( Byte.TYPE, Byte.class );
		wrapperMap.put( Short.TYPE, Short.class );
		wrapperMap.put( Character.TYPE, Character.class );
		wrapperMap.put( Integer.TYPE, Integer.class );
		wrapperMap.put( Long.TYPE, Long.class );
		wrapperMap.put( Float.TYPE, Float.class );
		wrapperMap.put( Double.TYPE, Double.class );
		wrapperMap.put( Boolean.class, Boolean.TYPE );
		wrapperMap.put( Byte.class, Byte.TYPE );
		wrapperMap.put( Short.class, Short.TYPE );
		wrapperMap.put( Character.class, Character.TYPE );
		wrapperMap.put( Integer.class, Integer.TYPE );
		wrapperMap.put( Long.class, Long.TYPE );
		wrapperMap.put( Float.class, Float.TYPE );
		wrapperMap.put( Double.class, Double.TYPE );
	}
    private Object value;
    private static class Special implements java.io.Serializable
    {
        private Special() { }
        public static final Special NULL_VALUE = new Special()
        {
            private Object readResolve() throws ObjectStreamException
            {
                return Special.NULL_VALUE;
            }
        };
        public static final Special VOID_TYPE = new Special()
        {
            private Object readResolve() throws ObjectStreamException
            {
                return Special.VOID_TYPE;
            }
        };
    }
    public static final Primitive NULL = new Primitive(Special.NULL_VALUE);
    public static final Primitive VOID = new Primitive(Special.VOID_TYPE);
    private Object readResolve() throws ObjectStreamException
    {
        if (value == Special.NULL_VALUE)
        {
            return Primitive.NULL;
        }
        else if (value == Special.VOID_TYPE)
        {
            return Primitive.VOID;
        }
        else
        {
            return this;
        }
    }
    public Primitive( Object value )
    {
        if ( value == null )
            throw new InterpreterError(
				"Use Primitve.NULL instead of Primitive(null)");
		if ( value != Special.NULL_VALUE 
			&& value != Special.VOID_TYPE &&
			!isWrapperType( value.getClass() ) 
		)
            throw new InterpreterError( "Not a wrapper type: "+value);
        this.value = value;
    }
    public Primitive(boolean value) { this(new Boolean(value)); }
    public Primitive(byte value) { this(new Byte(value)); }
    public Primitive(short value) { this(new Short(value)); }
    public Primitive(char value) { this(new Character(value)); }
    public Primitive(int value) { this(new Integer(value)); }
    public Primitive(long value) { this(new Long(value)); }
    public Primitive(float value) { this(new Float(value)); }
    public Primitive(double value) { this(new Double(value)); }
    public Object getValue()
    {
        if ( value == Special.NULL_VALUE )
            return null;
        else 
		if ( value == Special.VOID_TYPE )
                throw new InterpreterError("attempt to unwrap void type");
        else
            return value;
    }
    public String toString()
    {
        if(value == Special.NULL_VALUE)
            return "null";
        else if(value == Special.VOID_TYPE)
            return "void";
        else
            return value.toString();
    }
    public Class getType()
    {
		if ( this == Primitive.VOID )
			return Void.TYPE;
		if ( this == Primitive.NULL )
			return null;
		return unboxType( value.getClass() );
    }
    public static Object binaryOperation(
		Object obj1, Object obj2, int kind)
        throws UtilEvalError
    {
        if ( obj1 == NULL || obj2 == NULL )
            throw new UtilEvalError(
				"Null value or 'null' literal in binary operation");
        if ( obj1 == VOID || obj2 == VOID )
            throw new UtilEvalError(
			"Undefined variable, class, or 'void' literal in binary operation");
		Class lhsOrgType = obj1.getClass();
		Class rhsOrgType = obj2.getClass();
        if ( obj1 instanceof Primitive )
            obj1 = ((Primitive)obj1).getValue();
        if ( obj2 instanceof Primitive )
            obj2 = ((Primitive)obj2).getValue();
        Object[] operands = promotePrimitives(obj1, obj2);
        Object lhs = operands[0];
        Object rhs = operands[1];
        if(lhs.getClass() != rhs.getClass())
            throw new UtilEvalError("Type mismatch in operator.  " 
			+ lhs.getClass() + " cannot be used with " + rhs.getClass() );
		Object result;
		try {
			result = binaryOperationImpl( lhs, rhs, kind );
		} catch ( ArithmeticException e ) {
			throw new UtilTargetError( "Arithemetic Exception in binary op", e);
		}
		if ( (lhsOrgType == Primitive.class && rhsOrgType == Primitive.class)
			|| result instanceof Boolean
		)
			return new Primitive( result );
		else
			return result;
    }
    public static Object binaryOperationImpl( Object lhs, Object rhs, int kind )
        throws UtilEvalError
	{
        if(lhs instanceof Boolean)
            return booleanBinaryOperation((Boolean)lhs, (Boolean)rhs, kind);
        else if(lhs instanceof Integer)
            return intBinaryOperation( (Integer)lhs, (Integer)rhs, kind );
        else if(lhs instanceof Long)
            return longBinaryOperation((Long)lhs, (Long)rhs, kind);
        else if(lhs instanceof Float)
            return floatBinaryOperation((Float)lhs, (Float)rhs, kind);
        else if(lhs instanceof Double)
            return doubleBinaryOperation( (Double)lhs, (Double)rhs, kind);
        else
            throw new UtilEvalError("Invalid types in binary operator" );
	}
    public static Boolean booleanBinaryOperation(Boolean B1, Boolean B2, int kind)
    {
        boolean lhs = B1.booleanValue();
        boolean rhs = B2.booleanValue();
        switch(kind)
        {
            case EQ:
                return new Boolean(lhs == rhs);
            case NE:
                return new Boolean(lhs != rhs);
            case BOOL_OR:
            case BOOL_ORX:
            case BIT_OR:
                return new Boolean( lhs || rhs );
            case BOOL_AND:
            case BOOL_ANDX:
            case BIT_AND:
                return new Boolean( lhs && rhs );
            case XOR:
                return new Boolean( lhs ^ rhs );
            default:
                throw new InterpreterError("unimplemented binary operator");
        }
    }
    public static Object longBinaryOperation(Long L1, Long L2, int kind)
    {
        long lhs = L1.longValue();
        long rhs = L2.longValue();
        switch(kind)
        {
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            case PLUS:
                return new Long(lhs + rhs);
            case MINUS:
                return new Long(lhs - rhs);
            case STAR:
                return new Long(lhs * rhs);
            case SLASH:
                return new Long(lhs / rhs);
            case MOD:
                return new Long(lhs % rhs);
            case LSHIFT:
            case LSHIFTX:
                return new Long(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Long(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Long(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Long(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Long(lhs | rhs);
            case XOR:
                return new Long(lhs ^ rhs);
            default:
                throw new InterpreterError(
					"Unimplemented binary long operator");
        }
    }
    public static Object intBinaryOperation(Integer I1, Integer I2, int kind)
    {
        int lhs = I1.intValue();
        int rhs = I2.intValue();
        switch(kind)
        {
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            case PLUS:
                return new Integer(lhs + rhs);
            case MINUS:
                return new Integer(lhs - rhs);
            case STAR:
                return new Integer(lhs * rhs);
            case SLASH:
                return new Integer(lhs / rhs);
            case MOD:
                return new Integer(lhs % rhs);
            case LSHIFT:
            case LSHIFTX:
                return new Integer(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Integer(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Integer(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Integer(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Integer(lhs | rhs);
            case XOR:
                return new Integer(lhs ^ rhs);
            default:
                throw new InterpreterError(
					"Unimplemented binary integer operator");
        }
    }
    public static Object doubleBinaryOperation(Double D1, Double D2, int kind)
        throws UtilEvalError
    {
        double lhs = D1.doubleValue();
        double rhs = D2.doubleValue();
        switch(kind)
        {
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            case PLUS:
                return new Double(lhs + rhs);
            case MINUS:
                return new Double(lhs - rhs);
            case STAR:
                return new Double(lhs * rhs);
            case SLASH:
                return new Double(lhs / rhs);
            case MOD:
                return new Double(lhs % rhs);
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError("Can't shift doubles");
            default:
                throw new InterpreterError(
					"Unimplemented binary double operator");
        }
    }
    public static Object floatBinaryOperation(Float F1, Float F2, int kind)
        throws UtilEvalError
    {
        float lhs = F1.floatValue();
        float rhs = F2.floatValue();
        switch(kind)
        {
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            case PLUS:
                return new Float(lhs + rhs);
            case MINUS:
                return new Float(lhs - rhs);
            case STAR:
                return new Float(lhs * rhs);
            case SLASH:
                return new Float(lhs / rhs);
            case MOD:
                return new Float(lhs % rhs);
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError("Can't shift floats ");
            default:
                throw new InterpreterError(
					"Unimplemented binary float operator");
        }
    }
    public static Object promoteToInteger(Object wrapper )
    {
        if(wrapper instanceof Character)
            return new Integer(((Character)wrapper).charValue());
        else if((wrapper instanceof Byte) || (wrapper instanceof Short))
            return new Integer(((Number)wrapper).intValue());
        return wrapper;
    }
    public static Object[] promotePrimitives(Object lhs, Object rhs)
    {
        lhs = promoteToInteger(lhs);
        rhs = promoteToInteger(rhs);
        if((lhs instanceof Number) && (rhs instanceof Number))
        {
            Number lnum = (Number)lhs;
            Number rnum = (Number)rhs;
            boolean b;
            if((b = (lnum instanceof Double)) || (rnum instanceof Double))
            {
                if(b)
                    rhs = new Double(rnum.doubleValue());
                else
                    lhs = new Double(lnum.doubleValue());
            }
            else if((b = (lnum instanceof Float)) || (rnum instanceof Float))
            {
                if(b)
                    rhs = new Float(rnum.floatValue());
                else
                    lhs = new Float(lnum.floatValue());
            }
            else if((b = (lnum instanceof Long)) || (rnum instanceof Long))
            {
                if(b)
                    rhs = new Long(rnum.longValue());
                else
                    lhs = new Long(lnum.longValue());
            }
        }
        return new Object[] { lhs, rhs };
    }
    public static Primitive unaryOperation(Primitive val, int kind)
        throws UtilEvalError
    {
        if (val == NULL)
            throw new UtilEvalError(
				"illegal use of null object or 'null' literal");
        if (val == VOID)
            throw new UtilEvalError(
				"illegal use of undefined object or 'void' literal");
        Class operandType = val.getType();
        Object operand = promoteToInteger(val.getValue());
        if ( operand instanceof Boolean )
            return new Primitive(booleanUnaryOperation((Boolean)operand, kind));
        else if(operand instanceof Integer)
        {
            int result = intUnaryOperation((Integer)operand, kind);
            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Primitive((byte)result);
                if(operandType == Short.TYPE)
                    return new Primitive((short)result);
                if(operandType == Character.TYPE)
                    return new Primitive((char)result);
            }
            return new Primitive(result);
        }
        else if(operand instanceof Long)
            return new Primitive(longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Primitive(floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Primitive(doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError(
				"An error occurred.  Please call technical support.");
    }
    public static boolean booleanUnaryOperation(Boolean B, int kind)
		throws UtilEvalError
    {
        boolean operand = B.booleanValue();
        switch(kind)
        {
            case BANG:
                return !operand;
            default:
                throw new UtilEvalError("Operator inappropriate for boolean");
        }
    }
    public static int intUnaryOperation(Integer I, int kind)
    {
        int operand = I.intValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError("bad integer unaryOperation");
        }
    }
    public static long longUnaryOperation(Long L, int kind)
    {
        long operand = L.longValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError("bad long unaryOperation");
        }
    }
    public static float floatUnaryOperation(Float F, int kind)
    {
        float operand = F.floatValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError("bad float unaryOperation");
        }
    }
    public static double doubleUnaryOperation(Double D, int kind)
    {
        double operand = D.doubleValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError("bad double unaryOperation");
        }
    }
    public int intValue() throws UtilEvalError
    {
        if(value instanceof Number)
            return((Number)value).intValue();
        else
            throw new UtilEvalError("Primitive not a number");
    }
    public boolean booleanValue() throws UtilEvalError
    {
        if(value instanceof Boolean)
            return((Boolean)value).booleanValue();
        else
            throw new UtilEvalError("Primitive not a boolean");
    }
	public boolean isNumber() {
		return ( !(value instanceof Boolean) 
			&& !(this == NULL) && !(this == VOID) );
	}
    public Number numberValue() throws UtilEvalError
    {
		Object value = this.value;
		if (value instanceof Character)
			value = new Integer(((Character)value).charValue());
        if (value instanceof Number)
            return (Number)value;
        else
            throw new UtilEvalError("Primitive not a number");
    }
	public boolean equals( Object obj ) 
	{
		if ( obj instanceof Primitive )
			return ((Primitive)obj).value.equals( this.value );
		else
			return false;
	}
	public int hashCode() 
	{
		return this.value.hashCode() * 21; 
	}
	public static Object unwrap( Object obj ) 
	{
        if (obj == Primitive.VOID)
            return null;
        if (obj instanceof Primitive)
            return((Primitive)obj).getValue();
        else
            return obj;
	}
    public static Object [] unwrap( Object[] args )
    {
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = unwrap( args[i] );
		return oa;
    }
    public static Object [] wrap( Object[] args, Class [] paramTypes )
    {
		if ( args == null )
			return null;
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = wrap( args[i], paramTypes[i] );
		return oa;
    }
    public static Object wrap(
		Object value, Class type )
    {
        if ( type == Void.TYPE )
            return Primitive.VOID;
        if ( value == null )
            return Primitive.NULL;
		if ( type.isPrimitive() )
			return new Primitive( value );
		return value;
    }
	public static Primitive getDefaultValue( Class type )
	{
		if ( type == null || !type.isPrimitive() )
			return Primitive.NULL;
		if ( type == Boolean.TYPE )
			return new Primitive( false );
		try {
			return new Primitive((int)0).castToType( type, Types.CAST );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError( "bad cast" );
		}
	}
	public static Class boxType( Class primitiveType )
	{
		Class c = wrapperMap.get( primitiveType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			"Not a primitive type: "+ primitiveType );
	}
	public static Class unboxType( Class wrapperType )
	{
		Class c = wrapperMap.get( wrapperType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			"Not a primitive wrapper type: "+wrapperType );
	}
	public Primitive castToType( Class toType, int operation ) 
		throws UtilEvalError
	{
		return castPrimitive( 
			toType, getType(), this, 
			false, operation );
	}
	static Primitive castPrimitive( 
		Class toType, Class fromType, Primitive fromValue, 
		boolean checkOnly, int operation ) 
		throws UtilEvalError
	{
		if ( checkOnly && fromValue != null )
			throw new InterpreterError("bad cast param 1");
		if ( !checkOnly && fromValue == null )
			throw new InterpreterError("bad cast param 2");
		if ( fromType != null && !fromType.isPrimitive() )
			throw new InterpreterError("bad fromType:" +fromType);
		if ( fromValue == Primitive.NULL && fromType != null )
			throw new InterpreterError("inconsistent args 1");
		if ( fromValue == Primitive.VOID && fromType != Void.TYPE )
			throw new InterpreterError("inconsistent args 2");
		if ( fromType == Void.TYPE )
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( Reflect.normalizeClassName(toType), 
					"void value", operation );
		Object value = null; 
		if ( fromValue != null )
			value = fromValue.getValue();
		if ( toType.isPrimitive() )
		{
			if ( fromType == null )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError(
						"primitive type:" + toType, "Null value", operation );
		} else
		{
			if ( fromType == null )
				return checkOnly ? Types.VALID_CAST : 
					Primitive.NULL;
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError(
						"object type:" + toType, "primitive value", operation);
		}
		if ( fromType == Boolean.TYPE )
		{
			if ( toType != Boolean.TYPE )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError( toType, fromType, operation );
			return checkOnly ? Types.VALID_CAST :
				fromValue;
		}
		if ( operation == Types.ASSIGNMENT 
			&& !Types.isJavaAssignable( toType, fromType ) 
		) {
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( toType, fromType, operation );
		}
		return checkOnly ? Types.VALID_CAST :
			new Primitive( castWrapper(toType, value) );
	}
	public static boolean isWrapperType( Class type )
	{
		return wrapperMap.get( type ) != null && !type.isPrimitive();
	}
	static Object castWrapper( 
		Class toType, Object value ) 
	{
		if ( !toType.isPrimitive() )
			throw new InterpreterError("invalid type in castWrapper: "+toType);
		if ( value == null )
			throw new InterpreterError("null value in castWrapper, guard");
		if ( value instanceof Boolean )
		{
			if ( toType != Boolean.TYPE )
				throw new InterpreterError("bad wrapper cast of boolean");
			else
				return value;
		}
		if ( value instanceof Character )
			value = new Integer(((Character)value).charValue());
		if ( !(value instanceof Number) )
			throw new InterpreterError("bad type in cast");
		Number number = (Number)value;
		if (toType == Byte.TYPE)
			return new Byte(number.byteValue());
		if (toType == Short.TYPE)
			return new Short(number.shortValue());
		if (toType == Character.TYPE)
			return new Character((char)number.intValue());
		if (toType == Integer.TYPE)
			return new Integer(number.intValue());
		if (toType == Long.TYPE)
			return new Long(number.longValue());
		if (toType == Float.TYPE)
			return new Float(number.floatValue());
		if (toType == Double.TYPE)
			return new Double(number.doubleValue());
		throw new InterpreterError("error in wrapper cast");
	}
}
package bsh;
import bsh.ast.*;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.*;
import java.util.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public final class ClassGenerator {
    private static ClassGenerator cg;
	private static final String DEBUG_DIR = System.getProperty("bsh.debugClasses");
	public static ClassGenerator getClassGenerator() {
        if (cg == null) {
            cg = new ClassGenerator();
        }
        return cg;
    }
    public Class generateClass(String name, Modifiers modifiers, Class[] interfaces,
                               Class superClass, BSHBlock block, boolean isInterface,
                               CallStack callstack, Interpreter interpreter) throws EvalError {
        return generateClassImpl(name, modifiers, interfaces, superClass, block, isInterface,
                new BshEvaluatingVisitor(callstack, interpreter));
    }
    public Object invokeSuperclassMethod(BshClassManager bcm, Object instance,
                                         String methodName, Object[] args) throws UtilEvalError,
            ReflectError, InvocationTargetException {
        return invokeSuperclassMethodImpl(bcm, instance, methodName, args);
    }
    public void setInstanceNameSpaceParent(Object instance, String className, NameSpace parent) {
        This ithis = ClassGeneratorUtil.getClassInstanceThis(instance, className);
        ithis.getNameSpace().setParent(parent);
    }
    public static Class generateClassImpl(String name, Modifiers modifiers, Class[] interfaces,
            Class superClass, BSHBlock block, boolean isInterface,
            BshEvaluatingVisitor visitor) throws EvalError {
        try {
            Capabilities.setAccessibility(true);
        } catch (Capabilities.Unavailable e) {
            throw new EvalError("Defining classes currently requires reflective Accessibility.",
                    block, visitor.getCallstack());
        }
        NameSpace enclosingNameSpace = visitor.getCallstack().top();
        String packageName = enclosingNameSpace.getPackage();
        String className = enclosingNameSpace.isClass ? (enclosingNameSpace.getName() + "$" + name) : name;
        String fqClassName = packageName == null ? className : packageName + "." + className;
        BshClassManager bcm = visitor.getInterpreter().getClassManager();
        bcm.definingClass(fqClassName);
        NameSpace classStaticNameSpace = new NameSpace(enclosingNameSpace, className);
        classStaticNameSpace.isClass = true;
        visitor.getCallstack().push(classStaticNameSpace);
        visitor.evalBlock(block, true, ClassNodeFilter.CLASSCLASSES);
        Variable[] variables = getDeclaredVariables(block, visitor, packageName);
        DelayedEvalBshMethod[] methods = getDeclaredMethods(block, visitor, packageName);
        ClassGeneratorUtil classGenerator = new ClassGeneratorUtil(modifiers, className, packageName, superClass, interfaces, variables, methods, classStaticNameSpace, isInterface);
        byte[] code = classGenerator.generateClass();
		if (DEBUG_DIR != null) try {
            FileOutputStream out = new FileOutputStream(DEBUG_DIR + '/' + className + ".class");
            out.write(code);
            out.close();
        } catch (IOException e) {
            throw new IllegalStateException("cannot create file " + DEBUG_DIR + '/' + className + ".class", e);
        }
        Class genClass = bcm.defineClass(fqClassName, code);
        enclosingNameSpace.importClass(fqClassName.replace('$', '.'));
        try {
            classStaticNameSpace.setLocalVariable(ClassGeneratorUtil.BSHINIT, block, false);
        } catch (UtilEvalError e) {
            throw new InterpreterError("unable to init static: " + e);
        }
        classStaticNameSpace.setClassStatic(genClass);
        visitor.evalBlock(block, true, ClassNodeFilter.CLASSSTATIC);
        visitor.getCallstack().pop();
        if ( ! genClass.isInterface()) {
            String bshStaticFieldName = ClassGeneratorUtil.BSHSTATIC + className;
            try {
                LHS lhs = Reflect.getLHSStaticField(genClass, bshStaticFieldName);
                lhs.assign(classStaticNameSpace.getThis(visitor.getInterpreter()), false);
            } catch (Exception e) {
                throw new InterpreterError("Error in class gen setup: " + e);
            }
        }
        bcm.doneDefiningClass(fqClassName);
        return genClass;
    }
    static Variable[] getDeclaredVariables(BSHBlock body, BshEvaluatingVisitor visitor, String defaultPackage) {
        List<Variable> vars = new ArrayList<Variable>();
        for (int child = 0; child < body.jjtGetNumChildren(); child++) {
            SimpleNode node = (SimpleNode) body.jjtGetChild(child);
            if (node instanceof BSHTypedVariableDeclaration) {
                BSHTypedVariableDeclaration tvd = (BSHTypedVariableDeclaration) node;
                Modifiers modifiers = tvd.modifiers;
                String type = visitor.getTypeDescriptor(tvd.getTypeNode(), defaultPackage);
                BSHVariableDeclarator[] vardec = tvd.getDeclarators();
                for (BSHVariableDeclarator aVardec : vardec) {
                    String name = aVardec.name;
                    try {
                        Variable var = new Variable(name, type, null, modifiers);
                        vars.add(var);
                    } catch (UtilEvalError e) {
                    }
                }
            }
        }
        return vars.toArray(new Variable[vars.size()]);
    }
    static DelayedEvalBshMethod[] getDeclaredMethods(BSHBlock body,
           BshEvaluatingVisitor visitor, String defaultPackage) throws EvalError {
        List<DelayedEvalBshMethod> methods = new ArrayList<DelayedEvalBshMethod>();
        for (int child = 0; child < body.jjtGetNumChildren(); child++) {
            SimpleNode node = (SimpleNode) body.jjtGetChild(child);
            if (node instanceof BSHMethodDeclaration) {
                BSHMethodDeclaration md = (BSHMethodDeclaration) node;
                md.insureNodesParsed();
                Modifiers modifiers = md.modifiers;
                String name = md.name;
                String returnType = visitor.getReturnTypeDescriptor(md, defaultPackage);
                BSHReturnType returnTypeNode = visitor.getReturnTypeNode(md);
                BSHFormalParameters paramTypesNode = md.paramsNode;
                String[] paramTypes = visitor.getTypeDescriptors(paramTypesNode, defaultPackage);
                DelayedEvalBshMethod bm = new DelayedEvalBshMethod(name, returnType, returnTypeNode,
                        md.paramsNode.getParamNames(), paramTypes, paramTypesNode, md.blockNode,
                        null, modifiers,
                        visitor);
                methods.add(bm);
            }
        }
        return methods.toArray(new DelayedEvalBshMethod[methods.size()]);
    }
    static class ClassNodeFilter implements BSHBlock.NodeFilter {
        public static final int STATIC = 0, INSTANCE = 1, CLASSES = 2;
        public static ClassNodeFilter CLASSSTATIC = new ClassNodeFilter(STATIC);
        public static ClassNodeFilter CLASSINSTANCE = new ClassNodeFilter(INSTANCE);
        public static ClassNodeFilter CLASSCLASSES = new ClassNodeFilter(CLASSES);
        int context;
        private ClassNodeFilter(int context) {
            this.context = context;
        }
        public boolean isVisible(SimpleNode node) {
            if (context == CLASSES) return node instanceof BSHClassDeclaration;
            if (node instanceof BSHClassDeclaration) return false;
            if (context == STATIC) return isStatic(node);
            if (context == INSTANCE) return !isStatic(node);
            return true;
        }
        boolean isStatic(SimpleNode node) {
            if (node instanceof BSHTypedVariableDeclaration)
                return ((BSHTypedVariableDeclaration) node).modifiers != null
                        && ((BSHTypedVariableDeclaration) node).modifiers.hasModifier("static");
            if (node instanceof BSHMethodDeclaration)
                return ((BSHMethodDeclaration) node).modifiers != null
                        && ((BSHMethodDeclaration) node).modifiers.hasModifier("static");
            if (node instanceof BSHBlock) return false;
            return false;
        }
    }
    public static Object invokeSuperclassMethodImpl(BshClassManager bcm, Object instance,
                                                    String methodName, Object[] args)
            throws UtilEvalError, ReflectError, InvocationTargetException {
        String superName = ClassGeneratorUtil.BSHSUPER + methodName;
        Class clas = instance.getClass();
        Method superMethod = Reflect.resolveJavaMethod(bcm, clas, superName, Types.getTypes(args), false);
        if (superMethod != null) return Reflect.invokeMethod(superMethod, instance, args);
        Class superClass = clas.getSuperclass();
        superMethod = Reflect.resolveExpectedJavaMethod(bcm, superClass, instance, methodName, args, false);
        return Reflect.invokeMethod(superMethod, instance, args);
    }
}
package bsh;
import bsh.ast.SimpleNode;
public class UtilEvalError extends Exception 
{
	protected UtilEvalError() {
	}
	public UtilEvalError( String s ) {
		super(s);
	}
	public UtilEvalError( String s, Throwable cause ) {
		super(s,cause);
	}
	public EvalError toEvalError( 
		String msg, SimpleNode node, CallStack callstack  )
	{
		if ( Interpreter.DEBUG )
			printStackTrace();
		if ( msg == null )
			msg = "";
		else
			msg = msg + ": ";
		return new EvalError( msg+getMessage(), node, callstack, this );
	}
	public EvalError toEvalError ( SimpleNode node, CallStack callstack ) 
	{
		return toEvalError( null, node, callstack );
	}
}
package bsh;
import java.util.*;
public class StringUtil {
	public static String [] split( String s, String delim) {
		List<String> v = new ArrayList<String>();
		StringTokenizer st = new StringTokenizer(s, delim);
		while ( st.hasMoreTokens() )
			v.add( st.nextToken() );
		return v.toArray(new String[0]);
	}
	public static String maxCommonPrefix( String one, String two ) {
		int i=0;
		while( one.regionMatches( 0, two, 0, i ) )
			i++;
		return one.substring(0, i-1);
	}
    public static String methodString(String name, Class[] types)
    {
        StringBuilder sb = new StringBuilder(name + "(");
        if ( types.length > 0 )
			sb.append(" ");
        for( int i=0; i<types.length; i++ )
        {
            Class c = types[i];
            sb.append( ( (c == null) ? "null" : c.getName() ) 
				+ ( i < (types.length-1) ? ", " : " " ) );
        }
        sb.append(")");
        return sb.toString();
    }
    public static String normalizeClassName( Class type )
	{
		return Reflect.normalizeClassName( type );
	}
}
package bsh;
import java.lang.reflect.Field;
import java.util.Hashtable;
public class LHS implements ParserConstants, java.io.Serializable
{
	NameSpace nameSpace;
	boolean localVar;
	static final int
		VARIABLE = 0,
		FIELD = 1,
		PROPERTY = 2,
		INDEX = 3,
		METHOD_EVAL = 4;
	int type;
	String varName;
	String propName;
	Field field;
	Object object;
	int index;
	public LHS( NameSpace nameSpace, String varName )
	{
throw new Error("namespace lhs");
	}
	public LHS( NameSpace nameSpace, String varName, boolean localVar )
	{
		type = VARIABLE;
		this.localVar = localVar;
		this.varName = varName;
		this.nameSpace = nameSpace;
	}
	public LHS( Field field )
	{
		type = FIELD;
		this.object = null;
		this.field = field;
	}
	public LHS( Object object, Field field )
	{
		if ( object == null)
			throw new NullPointerException("constructed empty LHS");
		type = FIELD;
		this.object = object;
		this.field = field;
	}
	public LHS( Object object, String propName )
	{
		if(object == null)
			throw new NullPointerException("constructed empty LHS");
		type = PROPERTY;
		this.object = object;
		this.propName = propName;
	}
	public LHS( Object array, int index )
	{
		if(array == null)
			throw new NullPointerException("constructed empty LHS");
		type = INDEX;
		this.object = array;
		this.index = index;
	}
	public Object getValue() throws UtilEvalError
	{
		if ( type == VARIABLE )
			return nameSpace.getVariable( varName );
		if (type == FIELD)
			try {
				Object o = field.get( object );
				return Primitive.wrap( o, field.getType() );
			} catch(IllegalAccessException e2) {
				throw new UtilEvalError("Can't read field: " + field);
			}
		if ( type == PROPERTY )
			try {
				return Reflect.getObjectProperty(object, propName);
			}
			catch(ReflectError e) {
				Interpreter.debug(e.getMessage());
				throw new UtilEvalError("No such property: " + propName);
			}
		if ( type == INDEX )
			try {
				return Reflect.getIndex(object, index);
			}
			catch(Exception e) {
				throw new UtilEvalError("Array access: " + e);
			}
		throw new InterpreterError("LHS type");
	}
	public Object assign( Object val, boolean strictJava ) 
		throws UtilEvalError
	{
		if ( type == VARIABLE )
		{
			if ( localVar )
				nameSpace.setLocalVariable( varName, val, strictJava );
			else
				nameSpace.setVariable( varName, val, strictJava );
		} else 
		if ( type == FIELD )
		{
			try {
				Object fieldVal = val instanceof Primitive ?  
					((Primitive)val).getValue() : val;
				field.setAccessible(true);
				field.set( object, fieldVal );
				return val;
			}
			catch( NullPointerException e) {   
    			throw new UtilEvalError(
					"LHS ("+field.getName()+") not a static field.",e);
			}     
   			catch( IllegalAccessException e2) {   
				throw new UtilEvalError(
					"LHS ("+field.getName()+") can't access field: "+e2,e2);
			}     
			catch( IllegalArgumentException e3) 
			{
				String type = val instanceof Primitive ?
					((Primitive)val).getType().getName()
					: val.getClass().getName();
				throw new UtilEvalError(
					"Argument type mismatch. " + (val == null ? "null" : type )
					+ " not assignable to field "+field.getName());
			}
		}
		else 
		if ( type == PROPERTY )
		{
			CollectionManager cm = CollectionManager.getCollectionManager();
			if ( cm.isMap( object ) )
				cm.putInMap( object, propName, val );
			else
				try {
					Reflect.setObjectProperty(object, propName, val);
				}
				catch(ReflectError e) {
					Interpreter.debug("Assignment: " + e.getMessage());
					throw new UtilEvalError("No such property: " + propName);
				}
		} else 
		if ( type == INDEX )
			try {
				Reflect.setIndex(object, index, val);
			} catch ( UtilTargetError e1 ) { 
				throw e1;
			} catch ( Exception e ) {
				throw new UtilEvalError("Assignment: " + e.getMessage());
			}
		else
			throw new InterpreterError("unknown lhs");
		return val;
	}
	public String toString() { 
		return "LHS: "
			+((field!=null)? "field = "+field.toString():"")
			+(varName!=null ? " varName = "+varName: "")
			+(nameSpace!=null ? " nameSpace = "+nameSpace.toString(): "");
	}
}
package bsh;
import bsh.ast.SimpleNode;
public class EvalError extends Error
{
	private SimpleNode node;
	private String message;
	private final CallStack callstack;
	public EvalError( String s, SimpleNode node, CallStack callstack, Throwable cause ) {
		this(s,node,callstack);
		initCause(cause);
	}
	public EvalError( String s, SimpleNode node, CallStack callstack ) {
		this.message = s;
		this.node = node;
		this.callstack = callstack==null ? null : callstack.copy();
	}
	public String getMessage() 
	{
		String trace;
		if ( node != null )
			trace = " : at Line: "+ node.getLineNumber() 
				+ " : in file: "+ node.getSourceFile()
				+ " : "+node.getText();
		else
			trace = ": <at unknown location>";
		if ( callstack != null )
			trace = trace +"\n" + getScriptStackTrace();
		return getRawMessage() + trace;
	}
	public void reThrow( String msg ) 
		throws EvalError 
	{
		prependMessage( msg );
		throw this;
	}
	SimpleNode getNode() {
		return node;
	}
	void setNode( SimpleNode node ) {
		this.node = node;
	}
	public String getErrorText() { 
		if ( node != null )
			return node.getText() ;
		else
			return "<unknown error>";
	}
	public int getErrorLineNumber() { 
		if ( node != null )
			return node.getLineNumber() ;
		else
			return -1;
	}
	public String getErrorSourceFile() {
		if ( node != null )
			return node.getSourceFile() ;
		else
			return "<unknown file>";
	}
	public String getScriptStackTrace() 
	{
		if ( callstack == null )
			return "<Unknown>";
		String trace = "";
		CallStack stack = callstack.copy();
		while ( stack.depth() > 0 ) 
		{
			NameSpace ns = stack.pop();
			SimpleNode node = ns.getNode();
			if ( ns.isMethod )
			{
				trace = trace + "\nCalled from method: " + ns.getName();
				if ( node != null )
					trace += " : at Line: "+ node.getLineNumber() 
						+ " : in file: "+ node.getSourceFile()
						+ " : "+node.getText();
			}
		}
		return trace;
	}
	public String getRawMessage() { return message; }
	private void prependMessage( String s ) 
	{ 
		if ( s == null )
			return;
		if ( message == null )
			message = s;
		else
			message = s + " : "+ message;
	}
}
package bsh.ast;
import bsh.*;
public class SimpleNode implements Node
{
	public static SimpleNode JAVACODE =
		new SimpleNode( -1 ) {
			public String getSourceFile() {
				return "<Called from Java Code>";
			}
			public int getLineNumber() {
				return -1;
			}
			public String getText()  {
				return "<Compiled Java Code>";
			}
		};
	protected Node parent;
	protected Node[] children;
	protected int id;
	public Token firstToken, lastToken;
	String sourceFile;
	public SimpleNode(int i) {
		id = i;
	}
	public void jjtOpen() { }
	public void jjtClose() { }
	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }
	public void jjtAddChild(Node n, int i)
	{
		if (children == null)
			children = new Node[i + 1];
		else
			if (i >= children.length)
			{
				Node c[] = new Node[i + 1];
				System.arraycopy(children, 0, c, 0, children.length);
				children = c;
			}
		children[i] = n;
	}
	public Node jjtGetChild(int i) { 
		return children[i]; 
	}
	public SimpleNode getChild( int i ) {
		return (SimpleNode)jjtGetChild(i);
	}
	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}
	public String toString() { return ParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }
	public void dump(String prefix)
	{
		System.out.println(toString(prefix));
		if(children != null)
		{
			for(int i = 0; i < children.length; ++i)
			{
				SimpleNode n = (SimpleNode)children[i];
				if (n != null)
				{
					n.dump(prefix + " ");
				}
			}
		}
	}
	public void prune() {
		jjtSetParent( null );
	}
	public void setSourceFile( String sourceFile ) {
		this.sourceFile = sourceFile;
	}
	public String getSourceFile() {
		if ( sourceFile == null )
			if ( parent != null )
				return ((SimpleNode)parent).getSourceFile();
			else
				return "<unknown file>";
		else
			return sourceFile;
	}
	public int getLineNumber() {
		return firstToken.beginLine;
	}
	public String getText() 
	{
		StringBuilder text = new StringBuilder();
		Token t = firstToken;
		while ( t!=null ) {
			text.append(t.image);
			if ( !t.image.equals(".") )
				text.append(" ");
			if ( t==lastToken ||
				t.image.equals("{") || t.image.equals(";") )
				break;
			t=t.next;
		}
		return text.toString();
	}
    public <T> T accept(BshNodeVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
package bsh;
import bsh.ast.BSHBlock;
import bsh.ast.BSHMethodDeclaration;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
public class BshMethod 
	implements java.io.Serializable 
{
	NameSpace declaringNameSpace;
	Modifiers modifiers;
	private String name;
	private Class creturnType;
	private String [] paramNames;
	private int numArgs;
	private Class [] cparamTypes;
	BSHBlock methodBody;
	private Method javaMethod;
	private Object javaObject;
	public BshMethod(
		BSHMethodDeclaration method,
		NameSpace declaringNameSpace, Modifiers modifiers ) 
	{
		this( method.name, method.returnType, method.paramsNode.getParamNames(),
			method.paramsNode.paramTypes, method.blockNode, declaringNameSpace,
			modifiers );
	}
	public BshMethod(
		String name, Class returnType, String [] paramNames,
		Class [] paramTypes, BSHBlock methodBody, 
		NameSpace declaringNameSpace, Modifiers modifiers
	) {
		this.name = name;
		this.creturnType = returnType;
		this.paramNames = paramNames;
		if ( paramNames != null )
			this.numArgs = paramNames.length;
		this.cparamTypes = paramTypes;
		this.methodBody = methodBody;
		this.declaringNameSpace = declaringNameSpace;
		this.modifiers = modifiers;
	}
	public BshMethod( Method method, Object object )
	{
		this( method.getName(), method.getReturnType(), null,
			method.getParameterTypes(), null, 
			null, null );
		this.javaMethod = method;
		this.javaObject = object;
	}
	public Class [] getParameterTypes() { return cparamTypes; }
	public String [] getParameterNames() { return paramNames; }
	public Class getReturnType() { return creturnType; }
	public Modifiers getModifiers() { return modifiers; }
	public String getName() { return name; }
	public Object invoke( 
		Object[] argValues, BshEvaluatingVisitor visitor )
		throws EvalError 
	{
		return invoke( argValues, visitor, null, false );
	}
	public Object invoke( 
		Object[] argValues, BshEvaluatingVisitor visitor,
			SimpleNode callerInfo )
		throws EvalError 
	{
		return invoke( argValues, visitor, callerInfo, false );
	}
	public Object invoke(
		Object[] argValues, BshEvaluatingVisitor visitor,
			SimpleNode callerInfo, boolean overrideNameSpace ) 
		throws EvalError 
	{
		if ( argValues != null )
			for (int i=0; i<argValues.length; i++)
				if ( argValues[i] == null )
					throw new Error("HERE!");
		if ( javaMethod != null )
			try {
				return Reflect.invokeMethod(
					javaMethod, javaObject, argValues ); 
			} catch ( ReflectError e ) {
				throw new EvalError(
					"Error invoking Java method: "+e, callerInfo, visitor.getCallstack() );
			} catch ( InvocationTargetException e2 ) {
				throw new TargetError( 
					"Exception invoking imported object method.", 
					e2, callerInfo, visitor.getCallstack(), true );
			}
		if ( modifiers != null && modifiers.hasModifier("synchronized") )
		{
			Object lock;
			if ( declaringNameSpace.isClass )
			{
				try {
					lock = declaringNameSpace.getClassInstance();
				} catch ( UtilEvalError e ) {
					throw new InterpreterError(
						"Can't get class instance for synchronized method.");
				}
			} else
				lock = declaringNameSpace.getThis(visitor.getInterpreter()); 
			synchronized( lock ) 
			{
				return invokeImpl( 
					argValues, visitor,
					callerInfo, overrideNameSpace );
			}
		} else
			return invokeImpl( argValues, visitor, callerInfo,
				overrideNameSpace );
	}
	private Object invokeImpl(
		Object[] argValues, BshEvaluatingVisitor visitor,
			SimpleNode callerInfo, boolean overrideNameSpace ) 
		throws EvalError 
	{
		Class returnType = getReturnType();
		Class [] paramTypes = getParameterTypes();
		if ( visitor.getCallstack() == null )
            visitor = new BshEvaluatingVisitor(new CallStack(declaringNameSpace), visitor.getInterpreter());
		if ( argValues == null )
			argValues = new Object [] { };
		if ( argValues.length != numArgs ) 
		{
			throw new EvalError( 
				"Wrong number of arguments for local method: " 
				+ name, callerInfo, visitor.getCallstack() );
		}
		NameSpace localNameSpace;
		if ( overrideNameSpace )
			localNameSpace = visitor.getCallstack().top();
		else
		{
			localNameSpace = new NameSpace( declaringNameSpace, name );
			localNameSpace.isMethod = true;
		}
		localNameSpace.setNode( callerInfo );
		for(int i=0; i<numArgs; i++)
		{
			if ( paramTypes[i] != null ) 
			{
				try {
					argValues[i] =
						Types.castObject( argValues[i], paramTypes[i], Types.ASSIGNMENT );
				}
				catch( UtilEvalError e) {
					throw new EvalError(
						"Invalid argument: " 
						+ "`"+paramNames[i]+"'" + " for method: " 
						+ name + " : " + 
						e.getMessage(), callerInfo, visitor.getCallstack() );
				}
				try {
					localNameSpace.setTypedVariable( paramNames[i], 
						paramTypes[i], argValues[i], null);
				} catch ( UtilEvalError e2 ) {
					throw e2.toEvalError( "Typed method parameter assignment", 
						callerInfo, visitor.getCallstack()  );
				}
			} 
			else  
			{
				if ( argValues[i] == Primitive.VOID)
					throw new EvalError(
						"Undefined variable or class name, parameter: " +
						paramNames[i] + " to method: " 
						+ name, callerInfo, visitor.getCallstack() );
				else
					try {
						localNameSpace.setLocalVariable(
							paramNames[i], argValues[i],
							visitor.getInterpreter().getStrictJava() );
					} catch ( UtilEvalError e3 ) {
						throw e3.toEvalError( callerInfo, visitor.getCallstack() );
					}
			}
		}
		if ( !overrideNameSpace )
			visitor.getCallstack().push( localNameSpace );
        Object ret = visitor.evalBlock(methodBody, true);
		CallStack returnStack = visitor.getCallstack().copy();
		if ( !overrideNameSpace )
			visitor.getCallstack().pop();
		ReturnControl retControl = null;
		if ( ret instanceof ReturnControl )
		{
			retControl = (ReturnControl)ret;
			if ( retControl.kind == retControl.RETURN )
				ret = ((ReturnControl)ret).value;
			else 
				throw new EvalError("'continue' or 'break' in method body", 
					retControl.returnPoint, returnStack );
			if ( returnType == Void.TYPE && ret != Primitive.VOID )
				throw new EvalError( "Cannot return value from void method", 
				retControl.returnPoint, returnStack);
		}
		if ( returnType != null )
		{
			if ( returnType == Void.TYPE )
				return Primitive.VOID;
			try {
				ret =
					Types.castObject( ret, returnType, Types.ASSIGNMENT );
			} catch( UtilEvalError e )
			{
				SimpleNode node = callerInfo;
				if ( retControl != null )
					node = retControl.returnPoint;
				throw e.toEvalError(
					"Incorrect type returned from method: " 
					+ name + e.getMessage(), node, visitor.getCallstack() );
			}
		}
		return ret;
	}
	public boolean hasModifier( String name ) {
		return modifiers != null && modifiers.hasModifier(name);
	}
	public String toString() {
		return "Scripted Method: "
			+ StringUtil.methodString( name, getParameterTypes() ); 
	}
	public boolean equals(Object o) {
		if (o == null) {
			return false;
		}
		if (o == this) {
			return true;
		}
		if (o.getClass() == this.getClass()) {
			BshMethod m = (BshMethod)o;
			if( !name.equals(m.name) || numArgs!=m.numArgs )
				return false;
			for( int i=0; i<numArgs; i++ ) {
				if( !equal(cparamTypes[i],m.cparamTypes[i]) )
					return false;
			}
			return true;
		}
		return false;
	}
	private static boolean equal(Object obj1,Object obj2) {
		return obj1==null ? obj2==null : obj1.equals(obj2);
	}
	@Override
	public int hashCode() {
		int h = name.hashCode();
		for (Class<?> cparamType : cparamTypes) {
			h = h * 31 + cparamType.hashCode();
		}
		return h;
	}
}
package bsh.interpreter;
import bsh.*;
import bsh.ast.*;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
public class BshEvaluatingVisitor extends BshNodeVisitor<Object> {
    private CallStack callstack;
    private Interpreter interpreter;
    public BshEvaluatingVisitor(CallStack callstack, Interpreter interpreter) {
        this.callstack = callstack;
        this.interpreter = interpreter;
    }
    public CallStack getCallstack() {
        return callstack;
    }
    public Interpreter getInterpreter() {
        return interpreter;
    }
    @Override
    public Object visit(BSHAllocationExpression node) {
        SimpleNode type = (SimpleNode)node.jjtGetChild(0);
        SimpleNode args = (SimpleNode)node.jjtGetChild(1);
        if ( type instanceof BSHAmbiguousName)
        {
            BSHAmbiguousName name = (BSHAmbiguousName)type;
            if (args instanceof BSHArguments)
                return objectAllocation(node, name, (BSHArguments) args);
            else
                return objectArrayAllocation(node, name, (BSHArrayDimensions) args
                );
        }
        else
            return primitiveArrayAllocation(node, (BSHPrimitiveType) type,
                    (BSHArrayDimensions) args);
    }
    public Object objectAllocation(BSHAllocationExpression node,
            BSHAmbiguousName nameNode, BSHArguments argumentsNode)
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        Object[] args = getArguments(argumentsNode);
        if ( args == null)
            throw new EvalError( "Null args in new.", node, callstack );
        Object obj = ambiguousNameToObject(nameNode, false );
        obj = ambiguousNameToObject( nameNode, true );
        Class type = null;
        if ( obj instanceof ClassIdentifier )
            type = ((ClassIdentifier)obj).getTargetClass();
        else
            throw new EvalError(
                    "Unknown class: "+nameNode.text, node, callstack );
        boolean hasBody = node.jjtGetNumChildren() > 2;
        if ( hasBody )
        {
            BSHBlock body = (BSHBlock)node.jjtGetChild(2);
            if ( type.isInterface() )
                return constructWithInterfaceBody(node,
                        type, args, body);
            else
                return constructWithClassBody( node,
                        type, args, body );
        } else
            return constructObject(node, type, args );
    }
    public Object constructObject(BSHAllocationExpression node, Class<?> type, Object[] args ) throws EvalError {
        final boolean isGeneratedClass = GeneratedClass.class.isAssignableFrom(type);
        if (isGeneratedClass) {
            ClassGeneratorUtil.registerConstructorContext(callstack, interpreter);
        }
        Object obj;
        try {
            obj = Reflect.constructObject( type, args );
        } catch ( ReflectError e) {
            throw new EvalError(
                    "Constructor error: " + e.getMessage(), node, callstack );
        } catch (InvocationTargetException e) {
            Interpreter.debug("The constructor threw an exception:\n\t" + e.getTargetException());
            throw new TargetError("Object constructor", e.getTargetException(), node, callstack, true);
        } finally {
            if (isGeneratedClass) {
                ClassGeneratorUtil.registerConstructorContext(null, null); 
            }
        }
        String className = type.getName();
        if ( className.indexOf("$") == -1 )
            return obj;
        This ths = callstack.top().getThis( null );
        NameSpace instanceNameSpace =
                Name.getClassNameSpace( ths.getNameSpace() );
        if ( instanceNameSpace != null
                && className.startsWith( instanceNameSpace.getName() +"$")
                )
        {
            ClassGenerator.getClassGenerator().setInstanceNameSpaceParent(
                    obj, className, instanceNameSpace );
        }
        return obj;
    }
    public Object constructWithClassBody( BSHAllocationExpression node,
            Class type, Object[] args, BSHBlock block )
            throws EvalError
    {
        String name = callstack.top().getName() + "$" + (++node.innerClassCount);
        Modifiers modifiers = new Modifiers();
        modifiers.addModifier( Modifiers.CLASS, "public" );
        Class clas = ClassGenerator.getClassGenerator() .generateClass(
                name, modifiers, null, type,
                block, false, callstack, interpreter );
        try {
            return Reflect.constructObject( clas, args );
        } catch ( Exception e ) {
            Throwable cause = e;
            if ( e instanceof InvocationTargetException ) {
                cause = ((InvocationTargetException) e).getTargetException();
            }
            throw new EvalError("Error constructing inner class instance: "+e, node, callstack, cause);
        }
    }
    public Object constructWithInterfaceBody( BSHAllocationExpression node,
            Class type, Object[] args, BSHBlock body )
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        NameSpace local = new NameSpace(namespace, "AnonymousBlock");
        callstack.push(local);
        evalBlock(body, true);
        callstack.pop();
        local.importStatic( type );
        return local.getThis(interpreter).getInterface( type );
    }
    public Object objectArrayAllocation( BSHAllocationExpression node,
            BSHAmbiguousName nameNode, BSHArrayDimensions dimensionsNode )
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        Class type = ambiguousNameToClass( nameNode );
        if ( type == null )
            throw new EvalError( "Class " + nameNode.getName(namespace)
                    + " not found.", node, callstack );
        return arrayAllocation( node, dimensionsNode, type );
    }
    public Object primitiveArrayAllocation( BSHAllocationExpression node,
            BSHPrimitiveType typeNode, BSHArrayDimensions dimensionsNode
    )
            throws EvalError
    {
        Class type = typeNode.getType();
        return arrayAllocation(node, dimensionsNode, type );
    }
    public Object arrayAllocation( BSHAllocationExpression node,
            BSHArrayDimensions dimensionsNode, Class type)
            throws EvalError
    {
        Object result = evalArrayDimensions(dimensionsNode, type);
        if ( result != Primitive.VOID )
            return result;
        else
            return arrayNewInstance( node, type, dimensionsNode );
    }
    public Object arrayNewInstance( BSHAllocationExpression node,
            Class type, BSHArrayDimensions dimensionsNode )
            throws EvalError
    {
        if ( dimensionsNode.numUndefinedDims > 0 )
        {
            Object proto = Array.newInstance(
                    type, new int [dimensionsNode.numUndefinedDims] ); 
            type = proto.getClass();
        }
        try {
            return Array.newInstance(
                    type, dimensionsNode.definedDimensions);
        } catch( NegativeArraySizeException e1 ) {
            throw new TargetError( e1, node, callstack );
        } catch( Exception e ) {
            throw new EvalError("Can't construct primitive array: " +
                    e.getMessage(), node, callstack);
        }
    }
    @Override
    public Object visit(BSHAmbiguousName node) {
        throw new InterpreterError(
                "Don't know how to eval an ambiguous name!"
                        +"  Use toObject() if you want an object." );
    }
    public Object ambiguousNameToObject( BSHAmbiguousName node )
            throws EvalError
    {
        return ambiguousNameToObject( node, false );
    }
    public Object ambiguousNameToObject( BSHAmbiguousName node,
            boolean forceClass )
            throws EvalError
    {
        try {
            return
                    node.getName( callstack.top() ).toObject(
                            this, forceClass );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    public Class ambiguousNameToClass( BSHAmbiguousName node )
            throws EvalError
    {
        try {
            return node.getName( callstack.top() ).toClass();
        } catch ( ClassNotFoundException e ) {
            throw new EvalError( e.getMessage(), node, callstack, e );
        } catch ( UtilEvalError e2 ) {
            throw e2.toEvalError( node, callstack );
        }
    }
    public LHS ambiguousNameToLHS( BSHAmbiguousName node )
            throws EvalError
    {
        try {
            return node.getName( callstack.top() ).toLHS( this );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHArguments node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHArguments class.");
    }
    public Object[] getArguments( BSHArguments node )
            throws EvalError
    {
        Object[] args = new Object[node.jjtGetNumChildren()];
        for(int i = 0; i < args.length; i++)
        {
            args[i] = ((SimpleNode)node.jjtGetChild(i)).accept(this);
            if ( args[i] == Primitive.VOID )
                throw new EvalError( "Undefined argument: " +
                        ((SimpleNode)node.jjtGetChild(i)).getText(), node, callstack );
        }
        return args;
    }
    @Override
    public Object visit(BSHArrayDimensions node) {
        SimpleNode child = (SimpleNode)node.jjtGetChild(0);
        if (child instanceof BSHArrayInitializer)
        {
            if ( node.baseType == null )
                throw new EvalError(
                        "Internal Array Eval err:  unknown base type",
                        node, callstack );
            Object initValue = evalArrayInitializer(((BSHArrayInitializer) child),
                    node.baseType, node.numUndefinedDims, callstack, interpreter);
            Class arrayClass = initValue.getClass();
            int actualDimensions = Reflect.getArrayDimensions(arrayClass);
            node.definedDimensions = new int[ actualDimensions ];
            if ( node.definedDimensions.length != node.numUndefinedDims )
                throw new EvalError(
                        "Incompatible initializer. Allocation calls for a " +
                                node.numUndefinedDims+ " dimensional array, but initializer is a " +
                                actualDimensions + " dimensional array", node, callstack );
            Object arraySlice = initValue;
            for ( int i = 0; i < node.definedDimensions.length; i++ ) {
                node.definedDimensions[i] = Array.getLength(arraySlice);
                if ( node.definedDimensions[i] > 0 )
                    arraySlice = Array.get(arraySlice, 0);
            }
            return initValue;
        }
        else
        {
            node.definedDimensions = new int[ node.numDefinedDims ];
            for(int i = 0; i < node.numDefinedDims; i++)
            {
                try {
                    Object length = ((SimpleNode)node.jjtGetChild(i)).accept(this);
                    node.definedDimensions[i] = ((Primitive)length).intValue();
                }
                catch(Exception e)
                {
                    throw new EvalError(
                            "Array index: " + i +
                                    " does not evaluate to an integer", node, callstack );
                }
            }
        }
        return Primitive.VOID;
    }
    public Object evalArrayDimensions( BSHArrayDimensions node,
            Class type )
            throws EvalError
    {
        if ( Interpreter.DEBUG ) Interpreter.debug("array base type = "+type);
        node.baseType = type;
        return node.accept(this);
    }
    public Object evalArrayInitializer(BSHArrayInitializer nodeA, Class baseType, int dimensions,
                        CallStack callstack, Interpreter interpreter )
            throws EvalError
    {
        int numInitializers = nodeA.jjtGetNumChildren();
        int [] dima = new int [dimensions]; 
        dima[0] = numInitializers;
        Object initializers =  Array.newInstance( baseType, dima );
        for (int i = 0; i < numInitializers; i++)
        {
            SimpleNode childNode = (SimpleNode)nodeA.jjtGetChild(i);
            Object currentInitializer;
            if ( childNode instanceof BSHArrayInitializer ) {
                if ( dimensions < 2 )
                    throw new EvalError(
                            "Invalid Location for Intializer, position: "+i,
                            nodeA, callstack );
                currentInitializer =
                        evalArrayInitializer(((BSHArrayInitializer)childNode),
                                baseType, dimensions-1, callstack, interpreter);
            } else
                currentInitializer = childNode.accept(this);
            if ( currentInitializer == Primitive.VOID )
                throw new EvalError(
                        "Void in array initializer, position"+i, nodeA, callstack );
            Object value = currentInitializer;
            if ( dimensions == 1 )
            {
                try {
                    value = Types.castObject(
                            currentInitializer, baseType, Types.CAST );
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError(
                            "Error in array initializer", nodeA, callstack );
                }
                value = Primitive.unwrap( value );
            }
            try {
                Array.set(initializers, i, value);
            } catch( IllegalArgumentException e ) {
                Interpreter.debug("illegal arg"+e);
                throwTypeError( nodeA, baseType, currentInitializer, i, callstack );
            } catch( ArrayStoreException e ) { 
                Interpreter.debug("arraystore"+e);
                throwTypeError(nodeA, baseType, currentInitializer, i, callstack );
            }
        }
        return initializers;
    }
    private void throwTypeError( BSHArrayInitializer node,
            Class baseType, Object initializer, int argNum, CallStack callstack )
            throws EvalError
    {
        String rhsType;
        if (initializer instanceof Primitive)
            rhsType =
                    ((Primitive)initializer).getType().getName();
        else
            rhsType = Reflect.normalizeClassName(
                    initializer.getClass());
        throw new EvalError ( "Incompatible type: " + rhsType
                +" in initializer of array type: "+ baseType
                +" at position: "+argNum, node, callstack );
    }
    @Override
    public Object visit(BSHArrayInitializer node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHArrayInitializer class.");
    }
    @Override
    public Object visit(BSHAssignment node) {
        BSHPrimaryExpression lhsNode =
                (BSHPrimaryExpression)node.jjtGetChild(0);
        if ( lhsNode == null )
            throw new InterpreterError( "Error, null LHSnode" );
        boolean strictJava = interpreter.getStrictJava();
        LHS lhs = primaryExprToLHS(lhsNode);
        if ( lhs == null )
            throw new InterpreterError( "Error, null LHS" );
        Object lhsValue = null;
        if ( node.operator != ParserConstants.ASSIGN ) 
            try {
                lhsValue = lhs.getValue();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
        SimpleNode rhsNode = (SimpleNode)node.jjtGetChild(1);
        Object rhs;
        rhs = rhsNode.accept(this);
        if ( rhs == Primitive.VOID )
            throw new EvalError("Void assignment.", node, callstack );
        try {
            switch(node.operator)
            {
                case ParserConstants.ASSIGN:
                    return lhs.assign( rhs, strictJava );
                case ParserConstants.PLUSASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.PLUS), strictJava );
                case ParserConstants.MINUSASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.MINUS), strictJava );
                case ParserConstants.STARASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.STAR), strictJava );
                case ParserConstants.SLASHASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.SLASH), strictJava );
                case ParserConstants.ANDASSIGN:
                case ParserConstants.ANDASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.BIT_AND), strictJava );
                case ParserConstants.ORASSIGN:
                case ParserConstants.ORASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.BIT_OR), strictJava );
                case ParserConstants.XORASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.XOR), strictJava );
                case ParserConstants.MODASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.MOD), strictJava );
                case ParserConstants.LSHIFTASSIGN:
                case ParserConstants.LSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.LSHIFT), strictJava );
                case ParserConstants.RSIGNEDSHIFTASSIGN:
                case ParserConstants.RSIGNEDSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.RSIGNEDSHIFT ), strictJava );
                case ParserConstants.RUNSIGNEDSHIFTASSIGN:
                case ParserConstants.RUNSIGNEDSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.RUNSIGNEDSHIFT),
                            strictJava );
                default:
                    throw new InterpreterError(
                            "unimplemented operator in assignment BSH");
            }
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHBinaryExpression node) {
        Object lhs = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        if (node.kind == ParserConstants.INSTANCEOF)
        {
            if ( lhs == Primitive.NULL )
                return new Primitive(false);
            Class rhs = getType(((BSHType)node.jjtGetChild(1)));
            if ( lhs instanceof Primitive )
                if ( rhs == bsh.Primitive.class )
                    return new Primitive(true);
                else
                    return new Primitive(false);
            boolean ret = Types.isJavaBaseAssignable( rhs, lhs.getClass() );
            return new Primitive(ret);
        }
        if ( node.kind == ParserConstants.BOOL_AND || node.kind == ParserConstants.BOOL_ANDX ) {
            Object obj = lhs;
            if ( node.isPrimitiveValue(lhs) )
                obj = ((Primitive)lhs).getValue();
            if ( obj instanceof Boolean &&
                    ( ((Boolean)obj).booleanValue() == false ) )
                return new Primitive(false);
        }
        if ( node.kind == ParserConstants.BOOL_OR || node.kind == ParserConstants.BOOL_ORX ) {
            Object obj = lhs;
            if ( node.isPrimitiveValue(lhs) )
                obj = ((Primitive)lhs).getValue();
            if ( obj instanceof Boolean &&
                    ( ((Boolean)obj).booleanValue() == true ) )
                return new Primitive(true);
        }
        boolean isLhsWrapper = node.isWrapper(lhs);
        Object rhs = ((SimpleNode)node.jjtGetChild(1)).accept(this); 
        boolean isRhsWrapper = node.isWrapper(rhs);
        if (
                ( isLhsWrapper || node.isPrimitiveValue(lhs) )
                        && ( isRhsWrapper || node.isPrimitiveValue(rhs) )
                )
        {
            if ( (isLhsWrapper && isRhsWrapper && node.kind == ParserConstants.EQ))
            {
            } else
                try {
                    return Primitive.binaryOperation(lhs, rhs, node.kind);
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack  );
                }
        }
        switch(node.kind)
        {
            case ParserConstants.EQ:
                return new Primitive((lhs == rhs));
            case ParserConstants.NE:
                return new Primitive((lhs != rhs));
            case ParserConstants.PLUS:
                if(lhs instanceof String || rhs instanceof String)
                    return lhs.toString() + rhs.toString();
            default:
                if(lhs instanceof Primitive || rhs instanceof Primitive)
                    if ( lhs == Primitive.VOID || rhs == Primitive.VOID )
                        throw new EvalError(
                                "illegal use of undefined variable, class, or 'void' literal",
                                node, callstack );
                    else
                    if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                        throw new EvalError(
                                "illegal use of null value or 'null' literal", node, callstack);
                throw new EvalError("Operator: '" + ParserConstants.tokenImage[node.kind] +
                        "' inappropriate for objects", node, callstack );
        }
    }
    public Object evalBlock( BSHBlock node,
            boolean overrideNamespace )
            throws EvalError
    {
        Object syncValue = null;
        if ( node.isSynchronized )
        {
            SimpleNode exp = ((SimpleNode)node.jjtGetChild(0));
            syncValue = exp.accept(this);
        }
        Object ret;
        if ( node.isSynchronized ) 
            synchronized( syncValue )
            {
                ret = evalBlock(node, overrideNamespace, null);
            }
        else
            ret = evalBlock(node, overrideNamespace, null );
        return ret;
    }
    public Object evalBlock( BSHBlock block,
            boolean overrideNamespace, BSHBlock.NodeFilter nodeFilter )
            throws EvalError
    {
        Object ret = Primitive.VOID;
        NameSpace enclosingNameSpace = null;
        if ( !overrideNamespace )
        {
            enclosingNameSpace= callstack.top();
            BlockNameSpace bodyNameSpace =
                    new BlockNameSpace( enclosingNameSpace );
            callstack.swap( bodyNameSpace );
        }
        int startChild = block.isSynchronized ? 1 : 0;
        int numChildren = block.jjtGetNumChildren();
        try {
            for(int i=startChild; i<numChildren; i++)
            {
                SimpleNode node = ((SimpleNode)block.jjtGetChild(i));
                if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
                    continue;
                if ( node instanceof BSHClassDeclaration )
                    node.accept(this);
            }
            for(int i=startChild; i<numChildren; i++)
            {
                SimpleNode node = ((SimpleNode)block.jjtGetChild(i));
                if ( node instanceof BSHClassDeclaration )
                    continue;
                if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
                    continue;
                ret = node.accept(this);
                if ( ret instanceof ReturnControl )
                    break;
            }
        } finally {
            if ( !overrideNamespace )
                callstack.swap( enclosingNameSpace );
        }
        return ret;
    }
    @Override
    public Object visit(BSHBlock node) {
        return evalBlock(node, false);
    }
    @Override
    public Object visit(BSHCastExpression node) {
        NameSpace namespace = callstack.top();
        Class toType = getType(((BSHType)node.jjtGetChild(0)));
        SimpleNode expression = (SimpleNode)node.jjtGetChild(1);
        Object fromValue = expression.accept(this);
        Class fromType = fromValue.getClass();
        try {
            return Types.castObject( fromValue, toType, Types.CAST );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack  );
        }
    }
    @Override
    public Object visit(BSHClassDeclaration node) {
        synchronized (node) {
            if (node.generatedClass == null) {
                node.generatedClass = generateClass(node);
            }
            return node.generatedClass;
        }
    }
    public Class<?> generateClass(BSHClassDeclaration node) throws EvalError {
        int child = 0;
        Class superClass = null;
        if ( node.extend ) {
            BSHAmbiguousName superNode = (BSHAmbiguousName)node.jjtGetChild(child++);
            superClass = ambiguousNameToClass( superNode );
        }
        Class [] interfaces = new Class[node.numInterfaces];
        for( int i=0; i<node.numInterfaces; i++) {
            BSHAmbiguousName node1 = (BSHAmbiguousName)node.jjtGetChild(child++);
            interfaces[i] = ambiguousNameToClass(node1);
            if ( !interfaces[i].isInterface() )
                throw new EvalError(
                        "Type: "+node1.text+" is not an interface!",
                        node, callstack );
        }
        BSHBlock block;
        if ( child < node.jjtGetNumChildren() )
            block = (BSHBlock) node.jjtGetChild(child);
        else
            block = new BSHBlock( ParserTreeConstants.JJTBLOCK );
        return ClassGenerator.getClassGenerator().generateClass(
                node.name, node.modifiers, interfaces, superClass, block, node.isInterface,
                callstack, interpreter );
    }
    @Override
    public Object visit(BSHEnhancedForStatement node) {
        Class elementType = null;
        SimpleNode expression, statement=null;
        NameSpace enclosingNameSpace = callstack.top();
        SimpleNode firstNode =((SimpleNode)node.jjtGetChild(0));
        int nodeCount = node.jjtGetNumChildren();
        if ( firstNode instanceof BSHType )
        {
            elementType=getType(((BSHType)firstNode));
            expression=((SimpleNode)node.jjtGetChild(1));
            if ( nodeCount>2 )
                statement=((SimpleNode)node.jjtGetChild(2));
        } else
        {
            expression=firstNode;
            if ( nodeCount>1 )
                statement=((SimpleNode)node.jjtGetChild(1));
        }
        BlockNameSpace eachNameSpace = new BlockNameSpace( enclosingNameSpace );
        callstack.swap( eachNameSpace );
        final Object iteratee = expression.accept(this);
        if ( iteratee == Primitive.NULL )
            throw new EvalError("The collection, array, map, iterator, or " +
                    "enumeration portion of a for statement cannot be null.",
                    node, callstack );
        CollectionManager cm = CollectionManager.getCollectionManager();
        if ( !cm.isBshIterable( iteratee ) )
            throw new EvalError("Can't iterate over type: "
                    +iteratee.getClass(), node, callstack );
        Iterator iterator = cm.getBshIterator( iteratee );
        Object returnControl = Primitive.VOID;
        while( iterator.hasNext() )
        {
            try {
                Object value = iterator.next();
                if ( value == null )
                    value = Primitive.NULL;
                if ( elementType != null )
                    eachNameSpace.setTypedVariable(
                            node.varName, elementType,
                            value, new Modifiers() );
                else
                    eachNameSpace.setVariable( node.varName, value, false );
            } catch ( UtilEvalError e ) {
                throw e.toEvalError(
                        "for loop iterator variable:"+ node.varName, node, callstack );
            }
            boolean breakout = false; 
            if ( statement != null ) 
            {
                Object ret = statement.accept(this); 
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case ParserConstants.RETURN:
                            returnControl = ret;
                            breakout = true;
                            break;
                        case ParserConstants.CONTINUE:
                            break;
                        case ParserConstants.BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if (breakout)
                break;
        }
        callstack.swap(enclosingNameSpace);
        return returnControl;
    }
    @Override
    public Object visit(BSHFormalComment node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHFormalComment class.");
    }
    @Override
    public Object visit(BSHFormalParameter node) {
        if ( node.jjtGetNumChildren() > 0 )
            node.type = getType(((BSHType)node.jjtGetChild(0)));
        else
            node.type = node.UNTYPED;
        return node.type;
    }
    public String getFormalParameterTypeDescriptor( BSHFormalParameter node,
             String defaultPackage )
    {
        if ( node.jjtGetNumChildren() > 0 )
            return getTypeDescriptor(((BSHType) node.jjtGetChild(0)), defaultPackage);
        else
            return "Ljava/lang/Object;";  
    }
    @Override
    public Object visit(BSHFormalParameters node) {
        if ( node.paramTypes != null )
            return node.paramTypes;
        node.insureParsed();
        Class [] paramTypes = new Class[node.numArgs];
        for(int i=0; i<node.numArgs; i++)
        {
            BSHFormalParameter param = (BSHFormalParameter)node.jjtGetChild(i);
            paramTypes[i] = (Class)param.accept(this); 
        }
        node.paramTypes = paramTypes;
        return paramTypes;
    }
    public String [] getTypeDescriptors( BSHFormalParameters node, String defaultPackage )
    {
        if ( node.typeDescriptors != null )
            return node.typeDescriptors;
        node.insureParsed();
        String [] typeDesc = new String[node.numArgs];
        for(int i=0; i<node.numArgs; i++)
        {
            BSHFormalParameter param = (BSHFormalParameter)node.jjtGetChild(i);
            typeDesc[i] = getFormalParameterTypeDescriptor(param, defaultPackage );
        }
        node.typeDescriptors = typeDesc;
        return typeDesc;
    }
    @Override
    public Object visit(BSHForStatement node) {
        int i = 0;
        if(node.hasForInit)
            node.forInit = ((SimpleNode)node.jjtGetChild(i++));
        if(node.hasExpression)
            node.expression = ((SimpleNode)node.jjtGetChild(i++));
        if(node.hasForUpdate)
            node.forUpdate = ((SimpleNode)node.jjtGetChild(i++));
        if(i < node.jjtGetNumChildren()) 
            node.statement = ((SimpleNode)node.jjtGetChild(i));
        NameSpace enclosingNameSpace= callstack.top();
        BlockNameSpace forNameSpace = new BlockNameSpace( enclosingNameSpace );
        callstack.swap( forNameSpace );
        if ( node.hasForInit )
            node.forInit.accept(this);
        Object returnControl = Primitive.VOID;
        while(true)
        {
            if ( node.hasExpression )
            {
                boolean cond = BshInterpreterUtil.evaluateCondition(
                        node.expression, this);
                if ( !cond )
                    break;
            }
            boolean breakout = false; 
            if ( node.statement != null ) 
            {
                Object ret = node.statement.accept(this);
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case ParserConstants.RETURN:
                            returnControl = ret;
                            breakout = true;
                            break;
                        case ParserConstants.CONTINUE:
                            break;
                        case ParserConstants.BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if ( breakout )
                break;
            if ( node.hasForUpdate )
                node.forUpdate.accept(this);
        }
        callstack.swap( enclosingNameSpace );  
        return returnControl;
    }
    @Override
    public Object visit(BSHIfStatement node) {
        Object ret = null;
        if( BshInterpreterUtil.evaluateCondition(
                (SimpleNode) node.jjtGetChild(0), this) )
            ret = ((SimpleNode)node.jjtGetChild(1)).accept(this);
        else
        if(node.jjtGetNumChildren() > 2)
            ret = ((SimpleNode)node.jjtGetChild(2)).accept(this);
        if(ret instanceof ReturnControl)
            return ret;
        else
            return Primitive.VOID;
    }
    @Override
    public Object visit(BSHImportDeclaration node) {
        NameSpace namespace = callstack.top();
        if ( node.superImport )
            try {
                namespace.doSuperImport();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack  );
            }
        else
        {
            if ( node.staticImport )
            {
                if ( node.importPackage )
                {
                    Class clas = ambiguousNameToClass(((BSHAmbiguousName)node.jjtGetChild(0)));
                    namespace.importStatic( clas );
                } else
                    throw new EvalError(
                            "static field imports not supported yet",
                            node, callstack );
            } else
            {
                String name = ((BSHAmbiguousName)node.jjtGetChild(0)).text;
                if ( node.importPackage )
                    namespace.importPackage(name);
                else
                    namespace.importClass(name);
            }
        }
        return Primitive.VOID;
    }
    @Override
    public Object visit(BSHLiteral node) {
        if (node.value == null)
            throw new InterpreterError("Null in bsh literal: "+node.value);
        return node.value;
    }
    @Override
    public Object visit(BSHMethodDeclaration node) {
        node.returnType = evalMethodReturnType(node);
        evalNodes(node);
        NameSpace namespace = callstack.top();
        BshMethod bshMethod = new BshMethod( node, namespace, node.modifiers );
        try {
            namespace.setMethod( bshMethod );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError(node,callstack);
        }
        return Primitive.VOID;
    }
    public Class evalReturnType( BSHReturnType node ) throws EvalError
    {
        if ( node.isVoid )
            return Void.TYPE;
        else
            return getType(getTypeNode(node));
    }
    public BSHType getTypeNode(BSHReturnType node) {
        return (BSHType)node.jjtGetChild(0);
    }
    public String getTypeDescriptor( BSHReturnType node,
            String defaultPackage )
    {
        if ( node.isVoid )
            return "V";
        else
            return getTypeDescriptor(getTypeNode(node),
                    defaultPackage);
    }
    public String getReturnTypeDescriptor(BSHMethodDeclaration node,
            String defaultPackage )
    {
        node.insureNodesParsed();
        if ( node.returnTypeNode == null )
            return null;
        else
            return getTypeDescriptor(node.returnTypeNode, defaultPackage );
    }
    public BSHReturnType getReturnTypeNode(BSHMethodDeclaration node) {
        node.insureNodesParsed();
        return node.returnTypeNode;
    }
    public Class evalMethodReturnType( BSHMethodDeclaration node )
            throws EvalError
    {
        node.insureNodesParsed();
        if ( node.returnTypeNode != null )
            return evalReturnType(node.returnTypeNode);
        else
            return null;
    }
    public void evalNodes(BSHMethodDeclaration node)
            throws EvalError
    {
        node.insureNodesParsed();
        for(int i=node.firstThrowsClause; i<node.numThrows+node.firstThrowsClause; i++)
            ambiguousNameToClass(((BSHAmbiguousName)node.jjtGetChild(i)) );
        node.paramsNode.accept(this);
        if ( interpreter.getStrictJava() )
        {
            for(int i=0; i<node.paramsNode.paramTypes.length; i++)
                if ( node.paramsNode.paramTypes[i] == null )
                    throw new EvalError(
                            "(Strict Java Mode) Undeclared argument type, parameter: " +
                                    node.paramsNode.getParamNames()[i] + " in method: "
                                    + node.name, node, null );
            if ( node.returnType == null )
                throw new EvalError(
                        "(Strict Java Mode) Undeclared return type for method: "
                                + node.name, node, null );
        }
    }
    @Override
    public Object visit(BSHMethodInvocation node) {
        NameSpace namespace = callstack.top();
        BSHAmbiguousName nameNode = node.getNameNode();
        if ( namespace.getParent() != null && namespace.getParent().isClass
                && ( nameNode.text.equals("super") || nameNode.text.equals("this") )
                )
            return Primitive.VOID;
        Name name = nameNode.getName(namespace);
        Object[] args = getArguments(node.getArgsNode());
        try {
            return name.invokeMethod( this, args, node);
        } catch ( ReflectError e ) {
            throw new EvalError(
                    "Error in method invocation: " + e.getMessage(),
                    node, callstack, e );
        } catch ( InvocationTargetException e )
        {
            String msg = "Method Invocation "+name;
            Throwable te = e.getTargetException();
            boolean isNative = true;
            if ( te instanceof EvalError )
                if ( te instanceof TargetError )
                    isNative = ((TargetError)te).inNativeCode();
                else
                    isNative = false;
            throw new TargetError( msg, te, node, callstack, isNative );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHPackageDeclaration node) {
        BSHAmbiguousName name = (BSHAmbiguousName)node.jjtGetChild(0);
        NameSpace namespace = callstack.top();
        namespace.setPackage( name.text );
        namespace.importPackage( name.text );
        return Primitive.VOID;
    }
    private LHS primaryExprToLHS(BSHPrimaryExpression node)
            throws EvalError
    {
        Object obj = evalPrimaryExpr(node, true);
        if ( ! (obj instanceof LHS) )
            throw new EvalError("Can't assign to:", node, callstack );
        else
            return (LHS)obj;
    }
    private Object evalPrimaryExpr( BSHPrimaryExpression node, boolean toLHS )
            throws EvalError
    {
        Object obj = node.jjtGetChild(0);
        int numChildren = node.jjtGetNumChildren();
        for(int i=1; i<numChildren; i++)
            obj = doSuffix(((BSHPrimarySuffix)node.jjtGetChild(i)), obj, toLHS);
        if ( obj instanceof SimpleNode )
            if ( obj instanceof BSHAmbiguousName)
                if ( toLHS )
                    obj = ambiguousNameToLHS(((BSHAmbiguousName)obj));
                else
                    obj = ambiguousNameToObject(((BSHAmbiguousName)obj));
            else
                if ( toLHS )
                    throw new EvalError("Can't assign to prefix.",
                            node, callstack );
                else
                    obj = ((SimpleNode)obj).accept(this);
        if ( obj instanceof LHS )
            if ( toLHS )
                return obj;
            else
                try {
                    return ((LHS)obj).getValue();
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack );
                }
        else
            return obj;
    }
    @Override
    public Object visit(BSHPrimaryExpression node) {
        return evalPrimaryExpr(node, false);
    }
    private Object doSuffix( BSHPrimarySuffix node,
            Object obj, boolean toLHS)
            throws EvalError
    {
        if ( node.operation == BSHPrimarySuffix.CLASS )
            if ( obj instanceof BSHType) {
                if ( toLHS )
                    throw new EvalError("Can't assign .class",
                            node, callstack );
                NameSpace namespace = callstack.top();
                return getType(((BSHType)obj));
            } else
                throw new EvalError(
                        "Attempt to use .class suffix on non class.",
                        node, callstack );
        if ( obj instanceof SimpleNode )
            if ( obj instanceof BSHAmbiguousName)
                obj = ambiguousNameToObject(((BSHAmbiguousName)obj));
            else
                obj = ((SimpleNode)obj).accept(this);
        else
        if ( obj instanceof LHS )
            try {
                obj = ((LHS)obj).getValue();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
        try
        {
            switch(node.operation)
            {
                case BSHPrimarySuffix.INDEX:
                    return doIndex(node, obj, toLHS );
                case BSHPrimarySuffix.NAME:
                    return doName(node, obj, toLHS );
                case BSHPrimarySuffix.PROPERTY:
                    return doProperty( node, toLHS, obj);
                default:
                    throw new InterpreterError( "Unknown suffix type" );
            }
        }
        catch(ReflectError e)
        {
            throw new EvalError("reflection error: " + e, node, callstack, e );
        }
        catch(InvocationTargetException e)
        {
            throw new TargetError( "target exception", e.getTargetException(),
                    node, callstack, true);
        }
    }
    private Object doName( BSHPrimarySuffix node, Object obj, boolean toLHS)
            throws EvalError, ReflectError, InvocationTargetException
    {
        try {
            if ( node.field.equals("length") && obj.getClass().isArray() )
                if ( toLHS )
                    throw new EvalError(
                            "Can't assign array length", node, callstack );
                else
                    return new Primitive(Array.getLength(obj));
            if ( node.jjtGetNumChildren() == 0 )
                if ( toLHS )
                    return Reflect.getLHSObjectField(obj, node.field);
                else
                    return Reflect.getObjectFieldValue( obj, node.field );
            Object[] oa = getArguments(((BSHArguments)node.jjtGetChild(0)));
            try {
                return Reflect.invokeObjectMethod(
                        obj, node.field, oa, this, node );
            } catch ( ReflectError e ) {
                throw new EvalError(
                        "Error in method invocation: " + e.getMessage(),
                        node, callstack, e );
            } catch ( InvocationTargetException e )
            {
                String msg = "Method Invocation "+node.field;
                Throwable te = e.getTargetException();
                boolean isNative = true;
                if ( te instanceof EvalError )
                    if ( te instanceof TargetError )
                        isNative = ((TargetError)te).inNativeCode();
                    else
                        isNative = false;
                throw new TargetError( msg, te, node, callstack, isNative );
            }
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    private Object doIndex( BSHPrimarySuffix node,
            Object obj, boolean toLHS )
            throws EvalError, ReflectError
    {
        int index = BshInterpreterUtil.getIndexAux( obj, this, node );
        if ( toLHS )
            return new LHS(obj, index);
        else
            try {
                return Reflect.getIndex(obj, index);
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
    }
    private Object doProperty( BSHPrimarySuffix node, boolean toLHS, Object obj )
            throws EvalError
    {
        if(obj == Primitive.VOID)
            throw new EvalError(
                    "Attempt to access property on undefined variable or class name",
                    node, callstack );
        if ( obj instanceof Primitive )
            throw new EvalError("Attempt to access property on a primitive",
                    node, callstack );
        Object value = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        if ( !( value instanceof String ) )
            throw new EvalError(
                    "Property expression must be a String or identifier.",
                    node, callstack );
        if ( toLHS )
            return new LHS(obj, (String)value);
        CollectionManager cm = CollectionManager.getCollectionManager();
        if ( cm.isMap( obj ) )
        {
            Object val = cm.getFromMap( obj, value );
            return ( val == null ?  val = Primitive.NULL : val );
        }
        try {
            return Reflect.getObjectProperty( obj, (String)value );
        }
        catch ( UtilEvalError e)
        {
            throw e.toEvalError( "Property: "+value, node, callstack );
        }
        catch (ReflectError e)
        {
            throw new EvalError("No such property: " + value, node, callstack );
        }
    }
    @Override
    public Object visit(BSHPrimarySuffix node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimarySuffix class.", node);
    }
    @Override
    public Object visit(BSHPrimitiveType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimitiveType class.", node);
    }
    @Override
    public Object visit(BSHReturnStatement node) {
        Object value;
        if(node.jjtGetNumChildren() > 0)
            value = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        else
            value = Primitive.VOID;
        return new ReturnControl( node.kind, value, node );
    }
    @Override
    public Object visit(BSHReturnType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimarySuffix class.");
    }
    @Override
    public Object visit(BSHStatementExpressionList node) {
        int n = node.jjtGetNumChildren();
        for(int i=0; i<n; i++)
        {
            SimpleNode nn = ((SimpleNode)node.jjtGetChild(i));
            nn.accept(this);
        }
        return Primitive.VOID;
    }
    @Override
    public Object visit(BSHSwitchLabel node) {
        if ( node.isDefault )
            return null; 
        SimpleNode label = ((SimpleNode)node.jjtGetChild(0));
        return label.accept(this);
    }
    @Override
    public Object visit(BSHSwitchStatement node) {
        int numchild = node.jjtGetNumChildren();
        int child = 0;
        SimpleNode switchExp = ((SimpleNode)node.jjtGetChild(child++));
        Object switchVal = switchExp.accept(this);
        BSHSwitchLabel label;
        Object obj;
        ReturnControl returnControl=null;
        if ( child >= numchild )
            throw new EvalError("Empty switch statement.", node, callstack );
        label = ((BSHSwitchLabel)node.jjtGetChild(child++));
        while ( child < numchild && returnControl == null )
        {
            if ( label.isDefault
                    || primitiveEquals(node, switchVal, label.accept(this), switchExp) )  {
                while ( child < numchild )
                {
                    obj = node.jjtGetChild(child++);
                    if ( obj instanceof BSHSwitchLabel )
                        continue;
                    Object value =
                            ((SimpleNode)obj).accept(this);
                    if ( value instanceof ReturnControl ) {
                        returnControl = (ReturnControl)value;
                        break;
                    }
                }
            } else
            {
                while ( child < numchild )
                {
                    obj = node.jjtGetChild(child++);
                    if ( obj instanceof BSHSwitchLabel ) {
                        label = (BSHSwitchLabel)obj;
                        break;
                    }
                }
            }
        }
        if ( returnControl != null && returnControl.kind == ParserConstants.RETURN )
            return returnControl;
        else
            return Primitive.VOID;
    }
    public boolean primitiveEquals( BSHSwitchStatement node,
            Object switchVal, Object targetVal,
            SimpleNode switchExp  )
            throws EvalError
    {
        if ( switchVal instanceof Primitive || targetVal instanceof Primitive )
            try {
                Object result = Primitive.binaryOperation(
                        switchVal, targetVal, ParserConstants.EQ );
                result = Primitive.unwrap( result );
                return result.equals( Boolean.TRUE );
            } catch ( UtilEvalError e ) {
                throw e.toEvalError(
                        "Switch value: "+switchExp.getText()+": ",
                        node, callstack );
            }
        else
            return switchVal.equals( targetVal );
    }
    @Override
    public Object visit(BSHTernaryExpression node) {
        SimpleNode
                cond = (SimpleNode)node.jjtGetChild(0),
                evalTrue = (SimpleNode)node.jjtGetChild(1),
                evalFalse = (SimpleNode)node.jjtGetChild(2);
        if ( BshInterpreterUtil.evaluateCondition(cond, this) )
            return evalTrue.accept(this);
        else
            return evalFalse.accept(this);
    }
    @Override
    public Object visit(BSHThrowStatement node) {
        Object obj = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        if(!(obj instanceof Exception))
            throw new EvalError("Expression in 'throw' must be Exception type",
                    node, callstack );
        throw new TargetError( (Exception)obj, node, callstack );
    }
    @Override
    public Object visit(BSHTryStatement node) {
        BSHBlock tryBlock = ((BSHBlock)node.jjtGetChild(0));
        List<BSHFormalParameter> catchParams = new ArrayList<BSHFormalParameter>();
        List<BSHBlock> catchBlocks = new ArrayList<BSHBlock>();
        int nchild = node.jjtGetNumChildren();
        Node nodeObj = null;
        int i=1;
        while((i < nchild) && ((nodeObj = node.jjtGetChild(i++)) instanceof BSHFormalParameter))
        {
            catchParams.add((BSHFormalParameter)nodeObj);
            catchBlocks.add((BSHBlock)node.jjtGetChild(i++));
            nodeObj = null;
        }
        BSHBlock finallyBlock = null;
        if(nodeObj != null)
            finallyBlock = (BSHBlock)nodeObj;
        TargetError target = null;
        Throwable thrown = null;
        Object ret = null;
        int callstackDepth = callstack.depth();
        try {
            ret = tryBlock.accept(this);
        }
        catch( TargetError e ) {
            target = e;
            String stackInfo = "Bsh Stack: ";
            while ( callstack.depth() > callstackDepth )
                stackInfo += "\t" + callstack.pop() +"\n";
        }
        if ( target != null )
            thrown = target.getTarget();
        if (thrown != null)
        {
            int n = catchParams.size();
            for(i=0; i<n; i++)
            {
                BSHFormalParameter fp = catchParams.get(i);
                fp.accept(this);
                if ( fp.type == null && interpreter.getStrictJava() )
                    throw new EvalError(
                            "(Strict Java) Untyped catch block", node, callstack );
                if ( fp.type != null )
                    try {
                        thrown = (Throwable)Types.castObject(
                                thrown, fp.type, Types.ASSIGNMENT );
                    } catch( UtilEvalError e ) {
                        continue;
                    }
                BSHBlock cb = catchBlocks.get(i);
                NameSpace enclosingNameSpace = callstack.top();
                BlockNameSpace cbNameSpace =
                        new BlockNameSpace( enclosingNameSpace );
                try {
                    if ( fp.type == BSHFormalParameter.UNTYPED )
                        cbNameSpace.setBlockVariable( fp.name, thrown );
                    else
                    {
                        Modifiers modifiers = new Modifiers();
                        cbNameSpace.setTypedVariable(
                                fp.name, fp.type, thrown, new Modifiers() );
                    }
                } catch ( UtilEvalError e ) {
                    throw new InterpreterError(
                            "Unable to set var in catch block namespace." );
                }
                callstack.swap( cbNameSpace );
                try {
                    ret = cb.accept(this);
                } finally {
                    callstack.swap( enclosingNameSpace );
                }
                target = null;  
                break;
            }
        }
        if( finallyBlock != null ) {
            Object result = finallyBlock.accept(this);
            if( result instanceof ReturnControl )
                return result;
        }
        if(target != null)
            throw target;
        if(ret instanceof ReturnControl)
            return ret;
        else
            return Primitive.VOID;
    }
    @Override
    public Object visit(BSHType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHType class.", node);
    }
    public String getTypeDescriptor( BSHType node, String defaultPackage )
    {
        if ( node.descriptor != null )
            return node.descriptor;
        String descriptor;
        SimpleNode typeNode = node.getTypeNode();
        if ( typeNode instanceof BSHPrimitiveType)
            descriptor = BshInterpreterUtil.getTypeDescriptor( ((BSHPrimitiveType)typeNode).type );
        else
        {
            String clasName = ((BSHAmbiguousName)typeNode).text;
            BshClassManager bcm = interpreter.getClassManager();
            String definingClass = bcm.getClassBeingDefined( clasName );
            Class clas = null;
            if ( definingClass == null )
            {
                try {
                    clas = ambiguousNameToClass(((BSHAmbiguousName)typeNode) );
                } catch ( EvalError e ) {
                }
            } else
                clasName = definingClass;
            if ( clas != null )
            {
                descriptor = BshInterpreterUtil.getTypeDescriptor( clas );
            }else
            {
                if ( defaultPackage == null || Name.isCompound( clasName ) )
                    descriptor = "L" + clasName.replace('.','/') + ";";
                else
                    descriptor =
                            "L"+defaultPackage.replace('.','/')+"/"+clasName + ";";
            }
        }
        for(int i=0; i<node.arrayDims; i++)
            descriptor = "["+descriptor;
        node.descriptor = descriptor;
        return descriptor;
    }
    public Class getType(BSHType tnode)
            throws EvalError
    {
        if ( tnode.type != null )
            return tnode.type;
        SimpleNode node = tnode.getTypeNode();
        if ( node instanceof BSHPrimitiveType )
            tnode.baseType = ((BSHPrimitiveType)node).getType();
        else
            tnode.baseType = ambiguousNameToClass(((BSHAmbiguousName)node));
        if ( tnode.arrayDims > 0 ) {
            try {
                int[] dims = new int[tnode.arrayDims]; 
                Object obj = Array.newInstance(tnode.baseType, dims);
                tnode.type = obj.getClass();
            } catch(Exception e) {
                throw new EvalError("Couldn't construct array type",
                        tnode, callstack );
            }
        } else
            tnode.type = tnode.baseType;
        interpreter.getClassManager().addListener(tnode);
        return tnode.type;
    }
    @Override
    public Object visit(BSHTypedVariableDeclaration node) {
        try {
            NameSpace namespace = callstack.top();
            BSHType typeNode = node.getTypeNode();
            Class type = getType(typeNode);
            BSHVariableDeclarator [] bvda = node.getDeclarators();
            for (int i = 0; i < bvda.length; i++)
            {
                BSHVariableDeclarator dec = bvda[i];
                Object value = evalVariableDeclarator(dec, typeNode);
                try {
                    namespace.setTypedVariable(
                            dec.name, type, value, node.modifiers );
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack );
                }
            }
        } catch ( EvalError e ) {
            e.reThrow( "Typed variable declaration" );
        }
        return Primitive.VOID;
    }
    public Class evalType( BSHTypedVariableDeclaration node )
            throws EvalError
    {
        BSHType typeNode = node.getTypeNode();
        return getType( typeNode );
    }
    @Override
    public Object visit(BSHUnaryExpression node) {
        SimpleNode simpleNode = (SimpleNode)node.jjtGetChild(0);
        try {
            if ( node.kind == ParserConstants.INCR || node.kind == ParserConstants.DECR ) {
                LHS lhs = primaryExprToLHS((BSHPrimaryExpression) simpleNode);
                return node.lhsUnaryOperation(lhs, interpreter.getStrictJava());
            } else
                return
                        node.unaryOperation(simpleNode.accept(this), node.kind);
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    private Object evalVariableDeclarator(BSHVariableDeclarator node, BSHType typeNode)
            throws EvalError
    {
        Object value = null;
        if ( node.jjtGetNumChildren() > 0 )
        {
            SimpleNode initializer = (SimpleNode)node.jjtGetChild(0);
            if ( (typeNode != null)
                    && initializer instanceof BSHArrayInitializer
                    )
                value = evalArrayInitializer(((BSHArrayInitializer) initializer),
                        typeNode.getBaseType(), typeNode.getArrayDims(),
                        callstack, interpreter);
            else
                value = initializer.accept(this);
        }
        if ( value == Primitive.VOID )
            throw new EvalError("Void initializer.", node, callstack );
        return value;
    }
    @Override
    public Object visit(BSHVariableDeclarator node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHVariableDeclarator class.");
    }
    @Override
    public Object visit(BSHWhileStatement node) {
        int numChild = node.jjtGetNumChildren();
        final SimpleNode condExp;
        final SimpleNode body;
        if ( node.isDoStatement ) {
            condExp = (SimpleNode) node.jjtGetChild(1);
            body = (SimpleNode) node.jjtGetChild(0);
        } else {
            condExp = (SimpleNode) node.jjtGetChild(0);
            if ( numChild > 1 )	{
                body = (SimpleNode) node.jjtGetChild(1);
            } else {
                body = null;
            }
        }
        boolean doOnceFlag = node.isDoStatement;
        while (doOnceFlag || BshInterpreterUtil.evaluateCondition(condExp, this)) {
            doOnceFlag = false;
            if ( body == null ) {
                continue;
            }
            Object ret = body.accept(this);
            if (ret instanceof ReturnControl) {
                switch(( (ReturnControl)ret).kind ) {
                    case ParserConstants.RETURN:
                        return ret;
                    case ParserConstants.CONTINUE:
                        break;
                    case ParserConstants.BREAK:
                        return Primitive.VOID;
                }
            }
        }
        return Primitive.VOID;
    }
}
package	bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.Serializable;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Field;
public class NameSpace implements Serializable, BshClassManager.Listener, NameSource, Cloneable {
	private static final long serialVersionUID = 5004976946651004751L;
	public static final NameSpace JAVACODE = 
		new NameSpace((BshClassManager)null, "Called from compiled Java code.");
	static {
		JAVACODE.isMethod = true;
	}
	private String nsName; 
    private NameSpace parent;
    private Map<String,Variable> variables;
    private Map<String,List<BshMethod>> methods;
    protected Map<String,String> importedClasses;
    private List<String> importedPackages;
    private List<String> importedCommands;
	private List<Object> importedObjects;
	private List<Class> importedStatic;
	private String packageName;
	transient private BshClassManager classManager;
    private This thisReference;
    private Map<String,Name> names;
	SimpleNode callerInfoNode;
	public boolean isMethod;
	public boolean isClass;
	Class classStatic;	
	Object classInstance;
	void setClassStatic( Class clas ) {
		this.classStatic = clas;
		importStatic( clas );
	}
	void setClassInstance( Object instance ) {
		this.classInstance = instance;
		importObject( instance );
	}
	Object getClassInstance()
		throws UtilEvalError
	{
		if ( classInstance != null )
			return classInstance;
		if ( classStatic != null 
		)
			throw new UtilEvalError(
				"Can't refer to class instance from static context.");
		else
			throw new InterpreterError( 
				"Can't resolve class instance 'this' in: "+this);
	}
    transient private Map<String,Class> classCache;
    public NameSpace( NameSpace parent, String name ) 
	{
		this( parent, null, name );
	}
    public NameSpace( BshClassManager classManager, String name ) 
	{
		this( null, classManager, name );
	}
    public NameSpace( 
		NameSpace parent, BshClassManager classManager, String name ) 
	{
		setName(name);
		setParent(parent);
		setClassManager( classManager );
		if ( classManager != null )
			classManager.addListener(this);
    }
	public void setName( String name ) {
		this.nsName = name;
	}
	public String getName() {
		return this.nsName;
	}
	void setNode( SimpleNode node ) {
		callerInfoNode = node;
	}
	SimpleNode getNode() 
	{
		if ( callerInfoNode != null )
			return callerInfoNode;
		if ( parent != null )
			return parent.getNode();
		else
			return null;
	}
	public Object get( String name, Interpreter interpreter ) 
		throws UtilEvalError 
	{
		CallStack callstack = new CallStack( this );
		return getNameResolver( name ).toObject( new BshEvaluatingVisitor(callstack, interpreter) );
	}
    public void	setVariable( String name, Object value, boolean strictJava ) 
		throws UtilEvalError 
	{
		boolean recurse = Interpreter.LOCALSCOPING ? strictJava : true;
		setVariable( name, value, strictJava, recurse );
	}
    void setLocalVariable( 
		String name, Object value, boolean strictJava ) 
		throws UtilEvalError 
	{
		setVariable( name, value, strictJava, false );
	}
    void setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		ensureVariables();
		if ( value == null )
			throw new InterpreterError("null variable value");
		Variable existing = getVariableImpl( name, recurse );
		if ( existing != null )
		{
			try {
				existing.setValue( value, Variable.ASSIGNMENT );
			} catch ( UtilEvalError e ) {
				throw new UtilEvalError(
					"Variable assignment: " + name + ": " + e.getMessage());
			}
		} else 
		{
			if ( strictJava )
				throw new UtilEvalError(
					"(Strict Java mode) Assignment to undeclared variable: "
					+name );
			NameSpace varScope = this;
			varScope.variables.put( 
				name, new Variable( name, value, null ) );
			nameSpaceChanged();
    	}
	}
	private void ensureVariables() {
		if ( variables == null )
			variables =	new HashMap<String,Variable>();
	}
	public void unsetVariable( String name )
	{
		if ( variables != null )
		{
			variables.remove( name );
			nameSpaceChanged();
		}
	}
	public String [] getVariableNames() {
		if ( variables == null )
			return new String [0];
		else
			return variables.keySet().toArray(new String[0]);
	}
	public String [] getMethodNames() 
	{
		if ( methods == null )
			return new String [0];
		else
			return methods.keySet().toArray(new String[0]);
	}
	public BshMethod [] getMethods() 
	{
		if ( methods == null ) {
			return new BshMethod [0];
		} else {
			List<BshMethod> ret = new ArrayList<BshMethod>();
			for( List<BshMethod> list : methods.values() ) {
				ret.addAll(list);
			}
			return ret.toArray(new BshMethod[0]);
		}
	}
	public NameSpace getParent() {
		return parent;
	}
    public This getSuper( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getThis( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
    }
    public This getGlobal( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getGlobal( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
    }
    public This getThis( Interpreter declaringInterpreter ) 
	{
		if ( thisReference == null )
			thisReference = This.getThis( this, declaringInterpreter );
		return thisReference;
    }
	public BshClassManager getClassManager() 
	{
		if ( classManager != null )
			return classManager;
		if ( parent != null && parent != JAVACODE )
			return parent.getClassManager();
		classManager = BshClassManager.createClassManager( null );
		return classManager;
	}
	void setClassManager( BshClassManager classManager ) {
		this.classManager = classManager;
	}
	public void prune() 
	{
		if ( this.classManager == null )
			setClassManager( 
				BshClassManager.createClassManager( null ) );
		setParent( null );
	}
	public void setParent( NameSpace parent ) 
	{
		this.parent = parent;
		if ( parent == null )
			loadDefaultImports();
	}
    public Object getVariable( String name ) 
		throws UtilEvalError
	{
		return getVariable( name, true );
	}
    public Object getVariable( String name, boolean recurse ) 
		throws UtilEvalError
	{
		Variable var = getVariableImpl( name, recurse );
		return unwrapVariable( var );
    }
    protected Variable getVariableImpl( String name, boolean recurse ) 
		throws UtilEvalError
	{
		Variable var = null;
		if ( var == null && isClass )
			var = getImportedVar( name );
		if ( var == null && variables != null )
			var	= (Variable)variables.get(name);
		if ( var == null && !isClass )
			var = getImportedVar( name );
		if ( recurse && (var == null) && (parent != null) )
			var	= parent.getVariableImpl( name, recurse );
		return var;
    }
	public Variable [] getDeclaredVariables() 
	{
		if ( variables == null )
			return new Variable[0];
		return variables.values().toArray(new Variable[0]);
	}
	protected Object unwrapVariable( Variable var ) 
		throws UtilEvalError
	{
		return (var == null) ? Primitive.VOID :	var.getValue();
	}
    public void	setTypedVariable(
		String	name, Class type, Object value,	boolean	isFinal )
		throws UtilEvalError 
	{
		Modifiers modifiers = new Modifiers();
		if ( isFinal )
			modifiers.addModifier( Modifiers.FIELD, "final" );
		setTypedVariable( name, type, value, modifiers );
	}
    public void	setTypedVariable(
		String	name, Class type, Object value,	Modifiers modifiers )
		throws UtilEvalError 
	{
		ensureVariables();
		Variable existing = getVariableImpl( name, false );
		if ( existing != null ) 
		{
			if ( existing.getType() != null ) 
			{
				if ( existing.getType() != type )
				{
					throw new UtilEvalError( "Typed variable: "+name
						+" was previously declared with type: " 
						+ existing.getType() );
				} else 
				{
					existing.setValue( value, Variable.DECLARATION );
					return;
				}
			}
		} 
		variables.put( name, new Variable( name, type, value, modifiers ) );
    }
    public void	setMethod( BshMethod method )
		throws UtilEvalError
	{
		if ( methods == null )
			methods = new HashMap<String,List<BshMethod>>();
		String name = method.getName();
		List<BshMethod> list = methods.get(name);
		if ( list == null ) {
			methods.put(name, Collections.singletonList(method));
		} else {
			if( !(list instanceof ArrayList) ) {
				list = new ArrayList<BshMethod>(list);
				methods.put( name, list );
			}
			list.remove(method);
			list.add( method );
		}
    }
    public BshMethod getMethod( String name, Class [] sig ) 
		throws UtilEvalError
	{
		return getMethod( name, sig, false );
	}
    public BshMethod getMethod( 
		String name, Class [] sig, boolean declaredOnly ) 
		throws UtilEvalError
	{
		BshMethod method = null;
		if ( method == null && isClass && !declaredOnly )
			method = getImportedMethod( name, sig );
		if ( method == null && methods != null )
		{
			List<BshMethod> list = methods.get(name);
			if ( list != null ) 
			{
				Class [][] candidates = new Class[ list.size() ][];
				for( int i=0; i< candidates.length; i++ )
					candidates[i] = list.get(i).getParameterTypes();
				int match = 
					Reflect.findMostSpecificSignature( sig, candidates );
				if ( match != -1 )
					method = list.get(match);
			}
		}
		if ( method == null && !isClass && !declaredOnly )
			method = getImportedMethod( name, sig );
		if ( !declaredOnly && (method == null) && (parent != null) )
			return parent.getMethod( name, sig );
		return method;
    }
    public void	importClass(String name)
    {
		if ( importedClasses == null )
			importedClasses = new HashMap<String,String>();
		importedClasses.put( Name.suffix(name, 1), name );
		nameSpaceChanged();
    }
    public void	importPackage(String name)
    {
		if(importedPackages == null)
			importedPackages = new ArrayList<String>();
		importedPackages.remove( name );
		importedPackages.add(name);
		nameSpaceChanged();
    }
    public void	importCommands( String name )
    {
		if ( importedCommands == null )
			importedCommands = new ArrayList<String>();
		name = name.replace('.','/');
		if ( !name.startsWith("/") )
			name = "/"+name;
		if ( name.length() > 1 && name.endsWith("/") )
			name = name.substring( 0, name.length()-1 );
		importedCommands.remove( name );
		importedCommands.add(name);
		nameSpaceChanged();
    }
	public Object getCommand( 	
		String name, Class [] argTypes, Interpreter interpreter ) 
		throws UtilEvalError
	{
		if (Interpreter.DEBUG) Interpreter.debug("getCommand: "+name);
		BshClassManager bcm = interpreter.getClassManager();
		if ( importedCommands != null )
		{
			for(int i=importedCommands.size()-1; i>=0; i--)
			{
				String path = importedCommands.get(i);
				String scriptPath; 
				if ( path.equals("/") )
					scriptPath = path + name +".bsh";
				else
					scriptPath = path +"/"+ name +".bsh";
				Interpreter.debug("searching for script: "+scriptPath );
        		InputStream in = bcm.getResourceAsStream( scriptPath );
				if ( in != null )
					return loadScriptedCommand( 
						in, name, argTypes, scriptPath, interpreter );
				String className;
				if ( path.equals("/") )
					className = name;
				else
					className = path.substring(1).replace('/','.') +"."+name;
				Interpreter.debug("searching for class: "+className);
        		Class clas = bcm.classForName( className );
				if ( clas != null )
					return clas;
			}
		}
		if ( parent != null )
			return parent.getCommand( name, argTypes, interpreter );
		else
			return null;
	}
	protected BshMethod getImportedMethod( String name, Class [] sig ) 
		throws UtilEvalError
	{
		if ( importedObjects != null )
		for(int i=0; i<importedObjects.size(); i++)
		{
			Object object = importedObjects.get(i);
			Class clas = object.getClass();
			Method method = Reflect.resolveJavaMethod( 
				getClassManager(), clas, name, sig, false );
			if ( method != null )
				return new BshMethod( method, object );
		}
		if ( importedStatic!= null )
		for(int i=0; i<importedStatic.size(); i++)
		{
			Class clas = importedStatic.get(i);
			Method method = Reflect.resolveJavaMethod( 
				getClassManager(), clas, name, sig, true );
			if ( method != null )
				return new BshMethod( method, null );
		}
		return null;
	}
	protected Variable getImportedVar( String name ) 
		throws UtilEvalError
	{
		if ( importedObjects != null )
		for(int i=0; i<importedObjects.size(); i++)
		{
			Object object = importedObjects.get(i);
			Class clas = object.getClass();
			Field field = Reflect.resolveJavaField( 
				clas, name, false );
			if ( field != null )
				return new Variable( 
					name, field.getType(), new LHS( object, field ) );
		}
		if ( importedStatic!= null )
		for(int i=0; i<importedStatic.size(); i++)
		{
			Class clas = importedStatic.get(i);
			Field field = Reflect.resolveJavaField( 
				clas, name, true );
			if ( field != null )
				return new Variable( name, field.getType(), new LHS( field ) );
		}
		return null;
	}
	private BshMethod loadScriptedCommand( 
		InputStream in, String name, Class [] argTypes, String resourcePath, 
		Interpreter interpreter )
		throws UtilEvalError
	{
		try {
			interpreter.eval( 
				new InputStreamReader(in), this, resourcePath );
		} catch ( EvalError e ) {
			Interpreter.debug( e.toString() );
			throw new UtilEvalError( 
				"Error loading script: "+ e.getMessage(), e);
		}
		BshMethod meth = getMethod( name, argTypes );
		return meth;
	}
	void cacheClass( String name, Class c ) {
		if ( classCache == null ) {
			classCache = new HashMap<String,Class>();
		}
		classCache.put(name, c);
	}
    public Class getClass( String name )
		throws UtilEvalError
    {
		Class c = getClassImpl(name);
		if ( c != null )
			return c;
		else
			if ( parent != null )
				return parent.getClass( name );
			else
				return null;
	}
    private Class getClassImpl( String name )
		throws UtilEvalError
    {
		Class c = null;
		if (classCache != null) {
			c =	classCache.get(name);
			if ( c != null )
				return c;
		}
		boolean unqualifiedName = !Name.isCompound(name);
		if ( unqualifiedName ) 
		{
			if ( c == null )
				c = getImportedClassImpl( name );
			if ( c != null ) {
				cacheClass( name, c );
				return c;
			}
		}
		c = classForName( name );
		if ( c != null ) {
			if ( unqualifiedName )
				cacheClass( name, c );
			return c;
		}
		if ( Interpreter.DEBUG ) 
			Interpreter.debug("getClass(): " + name	+ " not	found in "+this);
		return null;
    }
    private Class getImportedClassImpl( String name )
		throws UtilEvalError
    {
		String fullname = null;
		if ( importedClasses != null )
			fullname = importedClasses.get(name);
		if ( fullname != null ) 
		{
			Class clas = classForName(fullname);
			if ( clas != null )
				return clas;
			if ( Name.isCompound( fullname ) )
				try {
					clas = getNameResolver( fullname ).toClass();
				} catch ( ClassNotFoundException e ) {  }
			else 
				if ( Interpreter.DEBUG ) Interpreter.debug(
					"imported unpackaged name not found:" +fullname);
			if ( clas != null ) {
				getClassManager().cacheClassInfo( fullname, clas );
				return clas;
			}
			return null;  
		}
		if ( importedPackages != null )
			for(int i=importedPackages.size()-1; i>=0; i--)
			{
				String s = importedPackages.get(i) + "." + name;
				Class c=classForName(s);
				if ( c != null )
					return c;
			}
		BshClassManager bcm = getClassManager();
		if ( bcm.hasSuperImport() ) 
		{
			String s = bcm.getClassNameByUnqName( name );
			if ( s != null )
				return classForName( s );
		}
		return null;
    }
	private Class classForName( String name ) 
	{
		return getClassManager().classForName( name );
	}
	public String [] getAllNames() 
	{
		List<String> list = new ArrayList<String>();
		getAllNamesAux( list );
		return list.toArray(new String[0]);
	}
	protected void getAllNamesAux( List<String> list ) 
	{
		list.addAll( variables.keySet() );
		list.addAll( methods.keySet() );
		if ( parent != null )
			parent.getAllNamesAux( list );
	}
	List<NameSource.Listener> nameSourceListeners;
	public void addNameSourceListener( NameSource.Listener listener ) {
		if ( nameSourceListeners == null )
			nameSourceListeners = new ArrayList<NameSource.Listener>();
		nameSourceListeners.add( listener );
	}
	public void doSuperImport() 
		throws UtilEvalError
	{
		getClassManager().doSuperImport();
	}
	public String toString() {
		return "NameSpace: " 
			+ ( nsName==null
				? super.toString()
				: nsName + " (" + super.toString() +")" )
			+ ( isClass ? " (isClass) " : "" )
			+ ( isMethod ? " (method) " : "" )
			+ ( classStatic != null ? " (class static) " : "" )
			+ ( classInstance != null ? " (class instance) " : "" );
	}
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException 
	{
		names = null;
		s.defaultWriteObject();
	}
	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter ) 
		throws EvalError
	{
		return invokeMethod( 
			methodName, args, interpreter, null, null );
	}
	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter, 
		CallStack callstack, SimpleNode callerInfo ) 
		throws EvalError
	{
		return getThis( interpreter ).invokeMethod( 
			methodName, args, interpreter, callstack, callerInfo,
			false );
	}
	public void classLoaderChanged() {
		nameSpaceChanged();
	}
	public void nameSpaceChanged() {
		classCache = null;
		names = null;
	}
    public void loadDefaultImports()
    {
		importClass("bsh.EvalError");
		importClass("bsh.Interpreter");
		importPackage("javax.swing.event");
		importPackage("javax.swing");
		importPackage("java.awt.event");
		importPackage("java.awt");
		importPackage("java.net");
		importPackage("java.util");
		importPackage("java.io");
		importPackage("java.lang");
		importCommands("/bsh/commands");
    }
	public Name getNameResolver( String ambigname )
	{
		if ( names == null )
			names = new HashMap<String,Name>();
		Name name = names.get( ambigname );
		if ( name == null ) {
			name = new Name( this, ambigname );
			names.put( ambigname, name );
		} 
		return name;
	}
	public int getInvocationLine() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getLineNumber();
		else
			return -1;
	}
	public String getInvocationText() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getText();
		else
			return "<invoked from Java code>";
	}
	public static Class identifierToClass( ClassIdentifier ci ) 
	{
		return ci.getTargetClass();
	}
	public void clear() 
	{
		variables = null;
		methods = null;
		importedClasses = null;
		importedPackages = null;
		importedCommands = null;
		importedObjects = null;
		if ( parent == null )
			loadDefaultImports();	
    	classCache = null;
		names = null;
	}
	public void importObject( Object obj ) 
	{
		if ( importedObjects == null )
			importedObjects = new ArrayList<Object>();
		importedObjects.remove( obj );
		importedObjects.add( obj );
		nameSpaceChanged();
	}
	public void importStatic( Class clas ) 
	{
		if ( importedStatic == null )
			importedStatic = new ArrayList<Class>();
		importedStatic.remove( clas );
		importedStatic.add( clas );
		nameSpaceChanged();
	}
	public void setPackage( String packageName )
	{
		this.packageName = packageName;
	}
	String getPackage() 
	{
		if ( packageName != null )
			return packageName;
		if ( parent != null )
			return parent.getPackage();
		return null;
	}
	NameSpace copy() {
		try {
			final NameSpace clone = (NameSpace) clone();
			clone.thisReference = null;
			clone.variables = clone(variables);
			clone.methods = clone(methods);
			clone.importedClasses = clone(importedClasses);
			clone.importedPackages = clone(importedPackages);
			clone.importedCommands = clone(importedCommands);
			clone.importedObjects = clone(importedObjects);
			clone.importedStatic = clone(importedStatic);
			clone.names = clone(names);
			return clone;
		} catch (CloneNotSupportedException e) {
			throw new IllegalStateException(e);
		}
	}
	private <K,V> Map<K,V> clone(final Map<K,V> map) {
		if (map == null) {
			return null;
		}
		return new HashMap<K,V>(map);
	}
	private <T> List<T> clone(final List<T> list) {
		if (list == null) {
			return null;
		}
		return new ArrayList<T>(list);
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.PrintStream;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
public class Interpreter 
	implements Runnable, ConsoleInterface,Serializable
{
	public static final String VERSION = "2.2b0";
	public static boolean DEBUG, TRACE, LOCALSCOPING;
	transient static PrintStream debug;
	static String systemLineSeparator = "\n"; 
	private static final This SYSTEM_OBJECT = This.getThis(new NameSpace(null, null, "bsh.system"), null);
	static {
		staticInit();
	}
	private boolean strictJava = false;
	transient Parser parser;
	NameSpace globalNameSpace;
	transient Reader in;
	transient PrintStream out;
	transient PrintStream err;
	ConsoleInterface console; 
	Interpreter parent;
	String sourceFileInfo;
	private boolean exitOnEOF = true;
	protected boolean 
		evalOnly, 		
		interactive;	
	private boolean showResults;
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace,
		Interpreter parent, String sourceFileInfo )
	{
		parser = new Parser( in );
		long t1 = 0;
		if (Interpreter.DEBUG) {
			t1=System.currentTimeMillis();
		}
		this.in = in;
		this.out = out;
		this.err = err;
		this.interactive = interactive;
		debug = err;
		this.parent = parent;
		if ( parent != null )
			setStrictJava( parent.getStrictJava() );
		this.sourceFileInfo = sourceFileInfo;
		BshClassManager bcm = BshClassManager.createClassManager( this );
		if ( namespace == null ) {
			globalNameSpace = new NameSpace( bcm, "global");
			initRootSystemObject();
		} else {
			globalNameSpace = namespace;
			try {
				if ( ! (globalNameSpace.getVariable("bsh") instanceof This)) {
					initRootSystemObject();
				}
			} catch (final UtilEvalError e) {
				throw new IllegalStateException(e);
			}
		}
		if ( interactive ) {
			loadRCFiles();
		}
		if ( Interpreter.DEBUG ) {
			long t2=System.currentTimeMillis();
			Interpreter.debug("Time to initialize interpreter: "+(t2-t1));
		}
	}
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace)
	{
		this( in, out, err, interactive, namespace, null, null );
	}
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, boolean interactive)
	{
		this(in, out, err, interactive, null);
	}
	public Interpreter(ConsoleInterface console, NameSpace globalNameSpace) {
		this( console.getIn(), console.getOut(), console.getErr(), 
			true, globalNameSpace );
		setConsole( console );
	}
	public Interpreter(ConsoleInterface console) {
		this(console, null);
	}
	public Interpreter()
	{
		this( new StringReader(""), 
			System.out, System.err, false, null );
		evalOnly = true;
		setu( "bsh.evalOnly", new Primitive(true) );
	}
	public void setConsole( ConsoleInterface console ) {
		this.console = console;
		setu( "bsh.console", console );
		setOut( console.getOut() );
		setErr( console.getErr() );
	}
	private void initRootSystemObject() 
	{
		BshClassManager bcm = getClassManager();
		setu("bsh", new NameSpace( bcm, "Bsh Object" ).getThis( this ) );
		setu( "bsh.system", SYSTEM_OBJECT);
		setu( "bsh.shared", SYSTEM_OBJECT); 
		This helpText = new NameSpace(bcm, "Bsh Command Help Text" ).getThis( this );
		setu( "bsh.help", helpText );
		try {
			setu( "bsh.cwd", System.getProperty("user.dir") );
		} catch ( SecurityException e ) { 
			setu( "bsh.cwd", "." );
		}
		setu( "bsh.interactive", new Primitive(interactive) );
		setu( "bsh.evalOnly", new Primitive(evalOnly) );
	}
	public void setNameSpace( NameSpace globalNameSpace ) {
		this.globalNameSpace = globalNameSpace;
	}
	public NameSpace getNameSpace() {
		return globalNameSpace;
	}
	public static void main( String [] args ) 
	{
		if ( args.length > 0 ) {
			String filename = args[0];
			String [] bshArgs;
			if ( args.length > 1 ) {
				bshArgs = new String [ args.length -1 ];
				System.arraycopy( args, 1, bshArgs, 0, args.length-1 );
			} else
				bshArgs = new String [0];
			Interpreter interpreter = new Interpreter();
			interpreter.setu( "bsh.args", bshArgs );
			try {
				Object result = 
					interpreter.source( filename, interpreter.globalNameSpace );
				if ( result instanceof Class )
					try {
						invokeMain( (Class)result, bshArgs );
					} catch ( Exception e ) 
					{
						Object o = e;
						if ( e instanceof InvocationTargetException )
							o = ((InvocationTargetException)e)
								.getTargetException();
						System.err.println(
							"Class: "+result+" main method threw exception:"+o);
					}
			} catch ( FileNotFoundException e ) {
				System.err.println("File not found: "+e);
			} catch ( TargetError e ) {
				System.err.println("Script threw exception: "+e);
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, System.err );
			} catch ( EvalError e ) {
				System.err.println("Evaluation Error: "+e);
			} catch ( IOException e ) {
				System.err.println("I/O Error: "+e);
			}
		} else 
		{
			InputStream src;
			if ( System.getProperty("os.name").startsWith("Windows") 
				&& System.getProperty("java.version").startsWith("1.1."))
			{
				src = new FilterInputStream(System.in) {
					public int available() throws IOException {
						return 0;
					}
				};
			}
			else
				src = System.in;
			Reader in = new CommandLineReader( new InputStreamReader(src));
			Interpreter interpreter = 
				new Interpreter( in, System.out, System.err, true );
			interpreter.run();
		}
	}
	public static void invokeMain( Class clas, String [] args ) 
		throws Exception
	{
		Method main = Reflect.resolveJavaMethod(
			null, clas, "main", 
			new Class [] { String [].class }, true );
		if ( main != null )
			main.invoke( null, new Object [] { args } );
	}
	public void run() 
	{
		if(evalOnly)
			throw new RuntimeException("bsh Interpreter: No stream");
		if ( interactive )
			try { 
				eval("printBanner();"); 
			} catch ( EvalError e ) {
				println(
					"BeanShell2 " + VERSION + " - http:
			}
		CallStack callstack = new CallStack( globalNameSpace );
        BshEvaluatingVisitor evaluator = new BshEvaluatingVisitor(callstack, this);
		SimpleNode node = null;
		boolean eof = false;
		while( !eof )
		{
			try
			{
				System.out.flush();
				System.err.flush();
				Thread.yield();  
				if ( interactive )
					print( getBshPrompt() );
				eof = Line();
				if( get_jjtree().nodeArity() > 0 )  
				{
					if( node != null )
						node.lastToken.next = null;  
					node = (SimpleNode)(get_jjtree().rootNode());
					if(DEBUG)
						node.dump(">");
                    Object ret = node.accept(evaluator);
					node.lastToken.next = null;  
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							"Callstack growing: "+callstack);
					if(ret instanceof ReturnControl)
						ret = ((ReturnControl)ret).value;
					if( ret != Primitive.VOID )
					{
						setu("$_", ret);
						if ( showResults )
							println("<" + ret + ">");
					}
				}
			}
			catch(ParseException e)
			{
				error("Parser Error: " + e.getMessage());
				if ( DEBUG )
					e.printStackTrace();
				if(!interactive)
					eof = true;
				parser.reInitInput(in);
			}
			catch(InterpreterError e)
			{
				error("Internal Error: " + e.getMessage());
				e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(TargetError e)
			{
				error("
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, err );
				if(!interactive)
					eof = true;
				setu("$_e", e.getTarget());
			}
			catch (EvalError e)
			{
				if ( interactive )
					error( "EvalError: "+e.getMessage() );
				else
					error( "EvalError: "+e.getRawMessage() );
				if(DEBUG)
					e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(Exception e)
			{
				error("Unknown error: " + e);
				if ( DEBUG )
					e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(TokenMgrError e)
			{
				error("Error parsing input: " + e);
				parser.reInitTokenInput( in );
				if(!interactive)
					eof = true;
			}
			finally
			{
				get_jjtree().reset();
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( globalNameSpace );
				}
			}
		}
		if ( interactive && exitOnEOF )
			System.exit(0);
	}
	public Object source( String filename, NameSpace nameSpace ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		File file = pathToFile( filename );
		if ( Interpreter.DEBUG ) debug("Sourcing file: "+file);
		Reader sourceIn = new BufferedReader( new FileReader(file) );
		try {
			return eval( sourceIn, nameSpace, filename );
		} finally {
			sourceIn.close();
		}
	}
	public Object source( String filename ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		return source( filename, globalNameSpace );
	}
	public Object eval( 
		Reader in, NameSpace nameSpace, String sourceFileInfo
			 ) 
		throws EvalError 
	{
		Object retVal = null;
		if ( Interpreter.DEBUG ) debug("eval: nameSpace = "+nameSpace);
		Interpreter localInterpreter = 
			new Interpreter( 
				in, out, err, false, nameSpace, this, sourceFileInfo  );
		CallStack callstack = new CallStack( nameSpace );
        BshEvaluatingVisitor evaluator = new BshEvaluatingVisitor(callstack, localInterpreter);
        SimpleNode node = null;
		boolean eof = false;
		while(!eof)
		{
			try
			{
				eof = localInterpreter.Line();
				if (localInterpreter.get_jjtree().nodeArity() > 0)
				{
					if( node != null )
						node.lastToken.next = null;  
					node = (SimpleNode)localInterpreter.get_jjtree().rootNode();
					node.setSourceFile( sourceFileInfo );
					if ( TRACE )
						println( "
                    retVal = node.accept(evaluator);
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							"Callstack growing: "+callstack);
					if ( retVal instanceof ReturnControl ) {
						retVal = ((ReturnControl)retVal).value;
						break; 
					}
					if ( localInterpreter.showResults 
						&& retVal != Primitive.VOID )
						println("<" + retVal + ">");
				}
			} catch(ParseException e) {
				if ( DEBUG )
					error( e.getMessage() );
				throw new EvalError("Error:", node, callstack, e);
			} catch ( InterpreterError e ) {
				e.printStackTrace();
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" internal Error: " 
					+ e.getMessage(), node, callstack);
			} catch ( TargetError e ) {
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow("Sourced file: "+sourceFileInfo);
			} catch ( EvalError e) {
				if ( DEBUG)
					e.printStackTrace();
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow( "Sourced file: "+sourceFileInfo );
			} catch ( Exception e) {
				if ( DEBUG)
					e.printStackTrace();
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" unknown error: " 
					+ e.getMessage(), node, callstack, e);
			} catch(TokenMgrError e) {
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" Token Parsing Error: " 
					+ e.getMessage(), node, callstack, e );
			} finally {
				localInterpreter.get_jjtree().reset();
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( nameSpace );
				}
			}
		}
		return Primitive.unwrap( retVal );
	}
	public Object eval( Reader in ) throws EvalError 
	{
		return eval( in, globalNameSpace, "eval stream" );
	}
	public Object eval( String statements ) throws EvalError {
		if ( Interpreter.DEBUG ) debug("eval(String): "+statements);
		return eval(statements, globalNameSpace);
	}
	public Object eval( String statements, NameSpace nameSpace ) 
		throws EvalError 
	{
		String s = ( statements.endsWith(";") ? statements : statements+";" );
		return eval( 
			new StringReader(s), nameSpace, 
			"inline evaluation of: ``"+ showEvalString(s)+"''" );
	}
	private String showEvalString( String s ) {
		s = s.replace('\n', ' ');
		s = s.replace('\r', ' ');
		if ( s.length() > 80 )
			s = s.substring( 0, 80 ) + " . . . ";
		return s;
	}
	public final void error( Object o ) {
		if ( console != null )
				console.error( "
		else {
			err.println("
			err.flush();
		}
	}
	public Reader getIn() { return in; }
	public PrintStream getOut() { return out; }
	public PrintStream getErr() { return err; }
	public final void println( Object o )
	{
		print( String.valueOf(o) + systemLineSeparator );
	}
	public final void print( Object o )
	{
		if (console != null) {
			console.print(o);
		} else {
			out.print(o);
			out.flush();
		}
	}
	public final static void debug(String s)
	{
		if ( DEBUG )
			debug.println("
	}
	public Object get( String name ) throws EvalError {
		try {
			Object ret = globalNameSpace.get( name, this );
			return Primitive.unwrap( ret );
		} catch ( UtilEvalError e ) { 
			throw e.toEvalError( SimpleNode.JAVACODE, new CallStack() ); 
		}
	}
	Object getu( String name ) {
		try { 
			return get( name );
		} catch ( EvalError e ) { 
			throw new InterpreterError("set: "+e);
		}
	}
	public void set( String name, Object value )
		throws EvalError 
	{
		if ( value == null )
			value = Primitive.NULL;
		CallStack callstack = new CallStack();
		try {
			if ( Name.isCompound( name ) ) 
			{
				LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( new BshEvaluatingVisitor(callstack,  this)	);
				lhs.assign( value, false );
			} else 
				globalNameSpace.setVariable( name, value, false );
		} catch ( UtilEvalError e ) { 
			throw e.toEvalError( SimpleNode.JAVACODE, callstack ); 
		}
	}
	void setu(String name, Object value) {
		try { 
			set(name, value);
		} catch ( EvalError e ) { 
			throw new InterpreterError("set: "+e);
		}
	}
	public void set(String name, long value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, int value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, double value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, float value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, boolean value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void unset( String name ) 
		throws EvalError 
	{
		CallStack callstack = new CallStack();
		try {
			LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( 
				new BshEvaluatingVisitor(callstack, this) );
			if ( lhs.type != LHS.VARIABLE )
				throw new EvalError("Can't unset, not a variable: "+name, 
					SimpleNode.JAVACODE, new CallStack() );
			lhs.nameSpace.unsetVariable( name );
		} catch ( UtilEvalError e ) {
			throw new EvalError( e.getMessage(), 
				SimpleNode.JAVACODE, new CallStack() );
		}
	}
	public Object getInterface( Class interf ) throws EvalError
	{
		return globalNameSpace.getThis( this ).getInterface( interf );
	}
	private JJTParserState get_jjtree() {
		return parser.jjtree;
	}
	private JavaCharStream get_jj_input_stream() {
		return parser.jj_input_stream;
	}
	private boolean Line() throws ParseException {
		return parser.Line();
	}
	void loadRCFiles() {
		try {
			String rcfile = 
				System.getProperty("user.home") + File.separator + ".bshrc";
			source( rcfile, globalNameSpace );
		} catch ( Exception e ) { 
			if ( Interpreter.DEBUG ) debug("Could not find rc file: "+e);
		}
	}
	public File pathToFile( String fileName ) 
		throws IOException
	{
		File file = new File( fileName );
		if ( !file.isAbsolute() ) {
			String cwd = (String)getu("bsh.cwd");
			file = new File( cwd + File.separator + fileName );
		}
		return new File( file.getCanonicalPath() );
	}
	public static void redirectOutputToFile( String filename ) 
	{
		try {
			PrintStream pout = new PrintStream( 
				new FileOutputStream( filename ) );
			System.setOut( pout );
			System.setErr( pout );
		} catch ( IOException e ) {
			System.err.println("Can't redirect output to file: "+filename );
		}
	}
	public void setClassLoader( ClassLoader externalCL ) {
		getClassManager().setClassLoader( externalCL );
	}
	public BshClassManager getClassManager() 
	{
		return getNameSpace().getClassManager();
	}
	public void setStrictJava( boolean b ) { 
		this.strictJava = b; 
	}
	public boolean getStrictJava() { 
		return this.strictJava;
	}
	static void staticInit() 
	{
		try {
			systemLineSeparator = System.getProperty("line.separator");
			debug = System.err;
			DEBUG = Boolean.getBoolean("debug");
			TRACE = Boolean.getBoolean("trace");
			LOCALSCOPING = Boolean.getBoolean("localscoping");
			String outfilename = System.getProperty("outfile");
			if ( outfilename != null )
				redirectOutputToFile( outfilename );
		} catch ( SecurityException e ) { 
			System.err.println("Could not init static:"+e);
		} catch ( Exception e ) {
			System.err.println("Could not init static(2):"+e);
		} catch ( Throwable e ) { 
			System.err.println("Could not init static(3):"+e);
		}
	}
	public String getSourceFileInfo() { 
		if ( sourceFileInfo != null )
			return sourceFileInfo;
		else
			return "<unknown source>";
	}
	public Interpreter getParent() {
		return parent;
	}
	public void setOut( PrintStream out ) {
		this.out = out;
	}
	public void setErr( PrintStream err ) {
		this.err = err;
	}
	private void readObject(ObjectInputStream stream) 
		throws java.io.IOException, ClassNotFoundException
	{
		stream.defaultReadObject();
		if ( console != null ) {
			setOut( console.getOut() );
			setErr( console.getErr() );
		} else {
			setOut( System.out );
			setErr( System.err );
		}
	}
	private String getBshPrompt() 
	{
		try {
			return (String)eval("getBshPrompt()");
		} catch ( Exception e ) {
			return "bsh % ";
		}
	}
	public void setExitOnEOF( boolean value ) {
		exitOnEOF = value; 
	}
	public void setShowResults( boolean showResults ) {
		this.showResults = showResults;
	}
	public boolean getShowResults()  {
		return showResults;
	}
	public static void setShutdownOnExit(final boolean value) {
		try {
			SYSTEM_OBJECT.getNameSpace().setVariable("shutdownOnExit", Boolean.valueOf(value), false);
		} catch (final UtilEvalError utilEvalError) {
			throw new IllegalStateException(utilEvalError);
		}
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
public class Name implements java.io.Serializable
{
	public NameSpace namespace;
	String value = null;
	private String evalName;
	private String lastEvalName;
	private static String FINISHED = null; 
	private Object evalBaseObject;	
	private int callstackDepth;		
	Class asClass;
	Class classOfStaticMethod;
	private void reset() {
		evalName = value;
		evalBaseObject = null;
		callstackDepth = 0;
	}
	Name( NameSpace namespace, String s )
	{
		this.namespace = namespace;
		value = s;
	}
	public Object toObject( BshEvaluatingVisitor visitor )
		throws UtilEvalError
	{
		return toObject( visitor, false );
	}
	synchronized public Object toObject( 
		BshEvaluatingVisitor visitor, boolean forceClass )
		throws UtilEvalError
	{
		reset();
		Object obj = null;
		while( evalName != null )
			obj = consumeNextObjectField(visitor, forceClass, false  );
		if ( obj == null )
			throw new InterpreterError("null value in toObject()");
		return obj;
	}
	private Object completeRound( 
		String lastEvalName, String nextEvalName, Object returnObject )
	{
		if ( returnObject == null )
			throw new InterpreterError("lastEvalName = "+lastEvalName);
		this.lastEvalName = lastEvalName;
		this.evalName = nextEvalName;
		this.evalBaseObject = returnObject;
		return returnObject;
	}
	private Object consumeNextObjectField( 	
		BshEvaluatingVisitor visitor,
		boolean forceClass, boolean autoAllocateThis ) 
		throws UtilEvalError
	{
		if ( (evalBaseObject == null && !isCompound(evalName) )
			&& !forceClass ) 
		{
			Object obj = resolveThisFieldReference( visitor,
				namespace, evalName, false );
			if ( obj != Primitive.VOID )
				return completeRound( evalName, FINISHED, obj );
		}
		String varName = prefix(evalName, 1);
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug("trying to resolve variable: " + varName);
			Object obj;
			if ( evalBaseObject == null ) {
				obj = resolveThisFieldReference(visitor, namespace, varName, false );
			} else {
				obj = resolveThisFieldReference(visitor,
					((This)evalBaseObject).namespace,
					varName, true );
			}
			if ( obj != Primitive.VOID ) 
			{
				if ( Interpreter.DEBUG ) 
					Interpreter.debug( "resolved variable: " + varName + 
					" in namespace: "+namespace);
				return completeRound( varName, suffix(evalName), obj );
			}
		}
		if ( evalBaseObject == null ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( "trying class: " + evalName);
			Class clas = null;
			int i = 1;
			String className = null;
			for(; i <= countParts(evalName); i++)
			{
				className = prefix(evalName, i);
				if ( (clas = namespace.getClass(className)) != null )
					break;
			}
			if ( clas != null )  {
				return completeRound(
					className,
					suffix( evalName, countParts(evalName)-i ),
					new ClassIdentifier(clas) 
				);
			}
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( "not a class, trying var prefix "+evalName );
		}
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass && autoAllocateThis )
		{
			NameSpace targetNameSpace = 
				( evalBaseObject == null ) ?  
					namespace : ((This)evalBaseObject).namespace;
			Object obj = new NameSpace( 
				targetNameSpace, "auto: "+varName ).getThis( visitor.getInterpreter() );
			targetNameSpace.setVariable( varName, obj, false );
			return completeRound( varName, suffix(evalName), obj );
		}
		if ( evalBaseObject == null ) {
			if ( !isCompound(evalName) ) {
				return completeRound( evalName, FINISHED, Primitive.VOID );
			} else
				throw new UtilEvalError(
					"Class or variable not found: " + evalName);
		}
		if ( evalBaseObject == Primitive.NULL) 
			throw new UtilTargetError( new NullPointerException( 
				"Null Pointer while evaluating: " +value ) );
		if ( evalBaseObject == Primitive.VOID) 
			throw new UtilEvalError(
				"Undefined variable or class name while evaluating: "+value);
		if ( evalBaseObject instanceof Primitive)
			throw new UtilEvalError("Can't treat primitive like an object. "+
			"Error while evaluating: "+value);
		if ( evalBaseObject instanceof ClassIdentifier ) 
		{
			Class clas = ((ClassIdentifier)evalBaseObject).getTargetClass();
			String field = prefix(evalName, 1);
			if ( field.equals("this") )
			{
				NameSpace ns = namespace;
				while ( ns != null )
				{
					if ( ns.classInstance != null 
						&& ns.classInstance.getClass() == clas 
					)
						return completeRound( 
							field, suffix(evalName), ns.classInstance );
					ns=ns.getParent();
				}
				throw new UtilEvalError(
					"Can't find enclosing 'this' instance of class: "+clas);
			}
			Object obj = null;
			try {
				if ( Interpreter.DEBUG ) 
					Interpreter.debug("Name call to getStaticFieldValue, class: "
						+clas+", field:"+field);
				obj = Reflect.getStaticFieldValue(clas, field);
			} catch( ReflectError e ) { 
				if ( Interpreter.DEBUG ) 
					Interpreter.debug("field reflect error: "+e);
			}
			if ( obj == null ) {
				String iclass = clas.getName()+"$"+field;
				Class c = namespace.getClass( iclass );
				if ( c != null )
					obj = new ClassIdentifier(c);
			}
			if ( obj == null )
				throw new UtilEvalError(
					"No static field or inner class: " 
					+ field + " of " + clas );
			return completeRound( field, suffix(evalName), obj );
		}
		if ( forceClass )
			throw new UtilEvalError( 
				value +" does not resolve to a class name." );
		String field = prefix(evalName, 1);
		if ( field.equals("length") && evalBaseObject.getClass().isArray() )
		{
			Object obj = new Primitive(Array.getLength(evalBaseObject));
			return completeRound( field, suffix(evalName), obj );
		}
		try {
			Object obj = Reflect.getObjectFieldValue(evalBaseObject, field);
			return completeRound( field, suffix(evalName), obj );
		} catch(ReflectError e) {  }
		throw new UtilEvalError(
			"Cannot access field: " + field + ", on object: " + evalBaseObject);
	}
	Object resolveThisFieldReference( BshEvaluatingVisitor visitor,
		NameSpace thisNameSpace,
		String varName, boolean specialFieldsVisible ) 
		throws UtilEvalError
	{
		if ( varName.equals("this") ) 
		{
			if ( specialFieldsVisible )
				throw new UtilEvalError("Redundant to call .this on This type");
			This ths = thisNameSpace.getThis( visitor.getInterpreter() );
			thisNameSpace= ths.getNameSpace();
			Object result = ths;
			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				if ( isCompound( evalName ) )
					result = classNameSpace.getThis( visitor.getInterpreter() );
				else
					result = classNameSpace.getClassInstance();
			}
			return result;
		}
		if ( varName.equals("super") ) 
		{
			This ths = thisNameSpace.getSuper( visitor.getInterpreter() );
			thisNameSpace = ths.getNameSpace();
			if ( 
				thisNameSpace.getParent() != null 
				&& thisNameSpace.getParent().isClass
			)
				ths = thisNameSpace.getParent().getThis( visitor.getInterpreter() );
			return ths;
		}
		Object obj = null;
		if ( varName.equals("global") )
			obj = thisNameSpace.getGlobal( visitor.getInterpreter() );
		if ( obj == null && specialFieldsVisible ) 
		{
			if (varName.equals("namespace"))
				obj = thisNameSpace;
			else if (varName.equals("variables"))
				obj = thisNameSpace.getVariableNames();
			else if (varName.equals("methods"))
				obj = thisNameSpace.getMethodNames();
			else if ( varName.equals("interpreter") )
				if ( lastEvalName.equals("this") )
					obj = visitor.getInterpreter();
				else
					throw new UtilEvalError(
						"Can only call .interpreter on literal 'this'");
		}
		if ( obj == null && specialFieldsVisible && varName.equals("caller") )
		{
			if ( lastEvalName.equals("this") || lastEvalName.equals("caller") ) 
			{
				if ( visitor.getInterpreter() == null )
					throw new InterpreterError("no callstack");
				obj = visitor.getCallstack().get( ++callstackDepth ).getThis(
					visitor.getInterpreter() );
			}
			else
				throw new UtilEvalError(
				"Can only call .caller on literal 'this' or literal '.caller'");
			return obj;
		}
		if ( obj == null && specialFieldsVisible 
			&& varName.equals("callstack") )
		{
			if ( lastEvalName.equals("this") ) 
			{
				if ( visitor.getCallstack() == null )
					throw new InterpreterError("no callstack");
				obj = visitor.getCallstack();
			}
			else
				throw new UtilEvalError(
				"Can only call .callstack on literal 'this'");
		}
		if ( obj == null )
			obj = thisNameSpace.getVariable(varName);
		if ( obj == null )
			throw new InterpreterError("null this field ref:"+varName);
		return obj;
	}
	public static NameSpace getClassNameSpace( NameSpace thisNameSpace )
	{
		if ( thisNameSpace.isClass )
			return thisNameSpace;
		if ( thisNameSpace.isMethod 
			&& thisNameSpace.getParent() != null 
			&& thisNameSpace.getParent().isClass
		)
			return thisNameSpace.getParent();
		return null;
	}
	synchronized public Class toClass() 
		throws ClassNotFoundException, UtilEvalError
	{
		if ( asClass != null )
			return asClass;
		reset();
		if ( evalName.equals("var") )
			return asClass = null;
		Class clas = namespace.getClass( evalName );
		if ( clas == null ) 
		{
			Object obj = null;
			try {
				obj = toObject( new BshEvaluatingVisitor(null, null), true );
			} catch ( UtilEvalError  e ) { }; 
			if ( obj instanceof ClassIdentifier )
				clas = ((ClassIdentifier)obj).getTargetClass();
		}
		if ( clas == null )
			throw new ClassNotFoundException(
				"Class: " + value+ " not found in namespace");
		asClass = clas;
		return asClass;
	}
	synchronized public LHS toLHS( 
		BshEvaluatingVisitor visitor )
		throws UtilEvalError
	{
		reset();
		LHS lhs;
		if ( !isCompound(evalName) ) 
		{
			if ( evalName.equals("this") )
				throw new UtilEvalError("Can't assign to 'this'." );
			lhs = new LHS( namespace, evalName, false);
			return lhs;
		}
		Object obj = null;
		try {
			while( evalName != null && isCompound( evalName ) )
			{
				obj = consumeNextObjectField( visitor,
					false, true );
			}
		} 
		catch( UtilEvalError e ) {
			throw new UtilEvalError( "LHS evaluation: " + e.getMessage() );
		}
		if ( evalName == null && obj instanceof ClassIdentifier )
			throw new UtilEvalError("Can't assign to class: " + value );
		if ( obj == null )
			throw new UtilEvalError("Error in LHS: " + value );
		if ( obj instanceof This )
		{
			if ( 
				evalName.equals("namespace")
				|| evalName.equals("variables")
				|| evalName.equals("methods")
				|| evalName.equals("caller")
			)
				throw new UtilEvalError(
					"Can't assign to special variable: "+evalName );
			Interpreter.debug("found This reference evaluating LHS");
			boolean localVar = !lastEvalName.equals("super");
			return new LHS( ((This)obj).namespace, evalName, localVar );
		}
		if ( evalName != null )
		{
			try {
				if ( obj instanceof ClassIdentifier ) 
				{
					Class clas = ((ClassIdentifier)obj).getTargetClass();
					lhs = Reflect.getLHSStaticField(clas, evalName);
					return lhs;
				} else {
					lhs = Reflect.getLHSObjectField(obj, evalName);
					return lhs;
				}
			} catch(ReflectError e) {
				throw new UtilEvalError("Field access: "+e);
			}
		}
		throw new InterpreterError("Internal error in lhs...");
	}
    public Object invokeMethod( BshEvaluatingVisitor visitor,
		Object[] args,
		SimpleNode callerInfo
	)
        throws UtilEvalError, EvalError, ReflectError, InvocationTargetException
    {
        String methodName = Name.suffix(value, 1);
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		NameSpace namespace = visitor.getCallstack().top();
        if ( classOfStaticMethod != null )
		{
			return Reflect.invokeStaticMethod( 
				bcm, classOfStaticMethod, methodName, args );
		}
		if ( !Name.isCompound(value) )
			return invokeLocalMethod( visitor,
				args, callerInfo );
        String prefix = Name.prefix(value);
		if ( prefix.equals("super") && Name.countParts(value) == 2 )
		{
			This ths = namespace.getThis( visitor.getInterpreter() );
			NameSpace thisNameSpace = ths.getNameSpace();
			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				Object instance = classNameSpace.getClassInstance();
				return ClassGenerator.getClassGenerator()
					.invokeSuperclassMethod( bcm, instance, methodName, args );
			}
		}
        Name targetName = namespace.getNameResolver( prefix );
        Object obj = targetName.toObject( visitor );
		if ( obj == Primitive.VOID ) 
			throw new UtilEvalError( "Attempt to resolve method: "+methodName
					+"() on undefined variable or class name: "+targetName);
        if ( !(obj instanceof ClassIdentifier) ) {
            if (obj instanceof Primitive) {
                if (obj == Primitive.NULL)
                    throw new UtilTargetError( new NullPointerException( 
						"Null Pointer in Method Invocation of " +methodName
							+"() on variable: "+targetName) );
				if ( Interpreter.DEBUG )
                	visitor.getInterpreter().debug(
					"Attempt to access method on primitive..." 
					+ " allowing bsh.Primitive to peek through for debugging");
            }
            return Reflect.invokeObjectMethod(obj, methodName, args, visitor, callerInfo );
        }
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug("invokeMethod: trying static - " + targetName);
        Class clas = ((ClassIdentifier)obj).getTargetClass();
		classOfStaticMethod = clas;
        if ( clas != null )
			return Reflect.invokeStaticMethod( bcm, clas, methodName, args );
		throw new UtilEvalError("invokeMethod: unknown target: " + targetName);
    }
    private Object invokeLocalMethod( BshEvaluatingVisitor visitor,
		Object[] args,
		SimpleNode callerInfo
	)
        throws EvalError
    {
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug( "invokeLocalMethod: " + value );
		if ( visitor.getInterpreter() == null )
			throw new InterpreterError(
				"invokeLocalMethod: interpreter = null");
		String commandName = value;
		Class [] argTypes = Types.getTypes( args );
        BshMethod meth = null;
		try {
			meth = namespace.getMethod( commandName, argTypes );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError(
				"Local method invocation", callerInfo, visitor.getCallstack() );
		}
        if ( meth != null )
			return meth.invoke( args, visitor, callerInfo );
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		Object commandObject;
		try {
			commandObject = namespace.getCommand( 
				commandName, argTypes, visitor.getInterpreter() );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError("Error loading command: ", 
				callerInfo, visitor.getCallstack() );
		}
		if ( commandObject == null )
		{
			BshMethod invokeMethod = null;
			try {
				invokeMethod = namespace.getMethod( 
					"invoke", new Class [] { null, null } );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(
					"Local method invocation", callerInfo, visitor.getCallstack() );
			}
			if ( invokeMethod != null )
				return invokeMethod.invoke( 
					new Object [] { commandName, args },
                        visitor,
					callerInfo );
            throw new EvalError( "Command not found: " 
				+StringUtil.methodString( commandName, argTypes ), 
				callerInfo, visitor.getCallstack() );
		}
		if ( commandObject instanceof BshMethod )
			return ((BshMethod)commandObject).invoke( 
				args, visitor, callerInfo );
		if ( commandObject instanceof Class )
			try {
				return Reflect.invokeCompiledCommand( 
					((Class)commandObject), args, visitor );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError("Error invoking compiled command: ",
				callerInfo, visitor.getCallstack() );
			}
		throw new InterpreterError("invalid command type");
    }
	public static boolean isCompound(String value)
	{
		return value.indexOf('.') != -1 ;
	}
	static int countParts(String value)
	{
		if(value == null)
			return 0;
		int count = 0;
		int index = -1;
		while((index = value.indexOf('.', index + 1)) != -1)
			count++;
		return count + 1;
	}
	static String prefix(String value)
	{
		if(!isCompound(value))
			return null;
		return prefix(value, countParts(value) - 1);
	}
	static String prefix(String value, int parts)
	{
		if (parts < 1 )
			return null;
		int count = 0;
		int index = -1;
		while( ((index = value.indexOf('.', index + 1)) != -1) 
			&& (++count < parts) )
		{ ; }
		return (index == -1) ? value : value.substring(0, index);
	}
	static String suffix(String name)
	{
		if(!isCompound(name))
			return null;
		return suffix(name, countParts(name) - 1);
	}
	public static String suffix(String value, int parts)
	{
		if (parts < 1)
			return null;
		int count = 0;
		int index = value.length() + 1;
		while ( ((index = value.lastIndexOf('.', index - 1)) != -1) 
			&& (++count < parts) );
		return (index == -1) ? value : value.substring(index + 1);
	}
	public String toString() { return value; }
}
package bsh;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.Collections;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
public class BshClassManager
{
	private Interpreter declaringInterpreter;
	protected ClassLoader externalClassLoader;
    protected transient Map<String,Class> absoluteClassCache = new Hashtable<String,Class>();
    protected transient Set<String> absoluteNonClasses = Collections.synchronizedSet(new HashSet<String>());
	protected transient volatile Map<SignatureKey,Method> resolvedObjectMethods = new Hashtable<SignatureKey,Method>();
	protected transient volatile Map<SignatureKey,Method> resolvedStaticMethods = new Hashtable<SignatureKey,Method>();
	private transient Set<String> definingClasses = Collections.synchronizedSet(new HashSet<String>());
	protected transient Map<String,String> definingClassesBaseNames = new Hashtable<String,String>();
	private static final Map<BshClassManager,Object> classManagers = Collections.synchronizedMap(new WeakHashMap<BshClassManager,Object>());
	static void clearResolveCache() {
		BshClassManager[] managers = (BshClassManager[])classManagers.keySet().toArray(new BshClassManager[0]);
		for( BshClassManager m : managers ) {
			m.resolvedObjectMethods = new Hashtable<SignatureKey,Method>();
			m.resolvedStaticMethods = new Hashtable<SignatureKey,Method>();
		}
	}
	public static BshClassManager createClassManager( Interpreter interpreter ) 
	{
		BshClassManager manager;
		if ( Capabilities.classExists("bsh.classpath.ClassManagerImpl") ) 
			try {
				Class clazz = Class.forName( "bsh.classpath.ClassManagerImpl" );
				manager = (BshClassManager) clazz.newInstance();
			} catch ( Exception e ) {
				throw new InterpreterError("Error loading classmanager", e);
			}
		else
			manager = new BshClassManager();
		if ( interpreter == null )
			interpreter = new Interpreter();
		manager.declaringInterpreter = interpreter;
		classManagers.put(manager,null);
		return manager;
	}
	public boolean classExists( String name ) {
		return ( classForName( name ) != null );
	}
	public Class classForName( String name ) 
	{
		if ( isClassBeingDefined( name ) )
			throw new InterpreterError(
				"Attempting to load class in the process of being defined: "
				+name );
		Class clas = null;
		try {
			clas = plainClassForName( name );
		} catch ( ClassNotFoundException e ) {  }
		return clas;
	}
	public Class plainClassForName( String name ) 
		throws ClassNotFoundException
	{
		Class c = null;
		if ( externalClassLoader != null )
			c = externalClassLoader.loadClass( name );
		else
			c = Class.forName( name );
		cacheClassInfo( name, c );
		return c;
	}
	public URL getResource( String path ) 
	{
		URL url = null;
		if ( externalClassLoader != null )
		{
			url = externalClassLoader.getResource( path.substring(1) );
		} 
		if ( url == null )
			url = Interpreter.class.getResource( path );
		return url;
	}
	public InputStream getResourceAsStream( String path ) 
	{
		InputStream in = null;
		if ( externalClassLoader != null )
		{
			in = externalClassLoader.getResourceAsStream( path.substring(1) );
		} 
		if ( in == null )
			in = Interpreter.class.getResourceAsStream( path );
		return in;
	}
	public void cacheClassInfo( String name, Class value ) {
		if ( value != null )
			absoluteClassCache.put( name, value );
		else
			absoluteNonClasses.add( name );
	}
	public void cacheResolvedMethod( 
		Class clas, Class [] types, Method method ) 
	{
		if ( Interpreter.DEBUG )
			Interpreter.debug(
				"cacheResolvedMethod putting: " + clas +" "+ method );
		SignatureKey sk = new SignatureKey( clas, method.getName(), types );
		if ( Modifier.isStatic( method.getModifiers() ) )
			resolvedStaticMethods.put( sk, method );
		else
			resolvedObjectMethods.put( sk, method );
	}
	protected Method getResolvedMethod( 
		Class clas, String methodName, Class [] types, boolean onlyStatic  ) 
	{
		SignatureKey sk = new SignatureKey( clas, methodName, types );
		Method method = resolvedStaticMethods.get( sk );
		if ( method == null && !onlyStatic)
			method = resolvedObjectMethods.get( sk );
		if ( Interpreter.DEBUG )
		{
			if ( method == null )
				Interpreter.debug(
					"getResolvedMethod cache MISS: " + clas +" - "+methodName );
			else
				Interpreter.debug(
					"getResolvedMethod cache HIT: " + clas +" - " +method );
		}
		return method;
	}
	protected void clearCaches() 
	{
		absoluteNonClasses = Collections.synchronizedSet(new HashSet<String>());
		absoluteClassCache = new Hashtable<String,Class>();
		resolvedObjectMethods = new Hashtable<SignatureKey,Method>();
		resolvedStaticMethods = new Hashtable<SignatureKey,Method>();
	}
	public void setClassLoader( ClassLoader externalCL ) 
	{
		externalClassLoader = externalCL;
		classLoaderChanged();
	}
	public void addClassPath( URL path )
		throws IOException {
	}
	public void reset() { 
		clearCaches();
	}
	public void setClassPath( URL [] cp ) 
		throws UtilEvalError
	{
		throw cmUnavailable();
	}
	public void reloadAllClasses() throws UtilEvalError {
		throw cmUnavailable();
	}
	public void reloadClasses( String [] classNames )
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	public void reloadPackage( String pack ) 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	protected void doSuperImport() 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	protected boolean hasSuperImport() 
	{
		return false;
	}
	protected String getClassNameByUnqName( String name ) 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	public void addListener( Listener l ) { }
	public void removeListener( Listener l ) { }
	public void dump( PrintWriter pw ) { 
		pw.println("BshClassManager: no class manager."); 
	}
	protected void definingClass( String className ) {
		String baseName = Name.suffix(className,1);
		int i = baseName.indexOf("$");
		if ( i != -1 )
			baseName = baseName.substring(i+1);
		String cur = definingClassesBaseNames.get( baseName );
		if ( cur != null )
			throw new InterpreterError("Defining class problem: "+className 
				+": BeanShell cannot yet simultaneously define two or more "
				+"dependant classes of the same name.  Attempt to define: "
				+ className +" while defining: "+cur 
			);
		definingClasses.add( className );
		definingClassesBaseNames.put( baseName, className );
	}
	protected boolean isClassBeingDefined( String className ) {
		return definingClasses.contains( className );
	}
	public String getClassBeingDefined( String className ) {
		String baseName = Name.suffix(className,1);
		return definingClassesBaseNames.get( baseName );
	}
	protected void doneDefiningClass( String className ) {
		String baseName = Name.suffix(className,1);
		definingClasses.remove( className );
		definingClassesBaseNames.remove( baseName );
	}
	public Class defineClass( String name, byte [] code ) 
	{
		throw new InterpreterError("Can't create class ("+name
			+") without class manager package.");
	}
	protected void classLoaderChanged() { }
	protected static UtilEvalError cmUnavailable() {
		return new Capabilities.Unavailable(
			"ClassLoading features unavailable.");
	}
	public static interface Listener 
	{
		public void classLoaderChanged();
	}
	static class SignatureKey
	{
		Class clas;
		Class [] types;
		String methodName;
		int hashCode = 0;
		SignatureKey( Class clas, String methodName, Class [] types ) {
			this.clas = clas;
			this.methodName = methodName;
			this.types = types;
		}
		public int hashCode() 
		{ 
			if ( hashCode == 0 ) 
			{
				hashCode = clas.hashCode() * methodName.hashCode();
				if ( types == null ) 
					return hashCode; 
				for( int i =0; i < types.length; i++ ) {
					int hc = types[i] == null ? 21 : types[i].hashCode();
					hashCode = hashCode*(i+1) + hc;
				}
			}
			return hashCode;
		}
		public boolean equals( Object o ) { 
			SignatureKey target = (SignatureKey)o;
			if ( types == null )
				return target.types == null;
			if ( clas != target.clas )
				return false;
			if ( !methodName.equals( target.methodName ) )
				return false;
			if ( types.length != target.types.length )
				return false;
			for( int i =0; i< types.length; i++ )
			{
				if ( types[i]==null ) 
				{
					if ( !(target.types[i]==null) )
						return false;
				} else 
					if ( !types[i].equals( target.types[i] ) )
						return false;
			}
			return true;
		}
	}
}
package bsh;
import java.util.Hashtable;
public class Capabilities 
{
	private static volatile boolean accessibility = false;
	public static boolean haveSwing() {
		return classExists( "javax.swing.JButton" );
	}
	public static boolean haveAccessibility() 
	{
		return accessibility;
	}
	public static void setAccessibility( boolean b ) 
		throws Unavailable
	{ 
		if ( b == false )
		{
			accessibility = false;
		} else {
			try {
				String.class.getDeclaredMethods();
			} catch ( SecurityException e ) {
				throw new Unavailable("Accessibility unavailable: "+e);
			}
			accessibility = true;
		}
		BshClassManager.clearResolveCache();
	}
	private static Hashtable classes = new Hashtable();
	public static boolean classExists( String name ) 
	{
		Object c = classes.get( name );
		if ( c == null ) {
			try {
				c = Class.forName( name );
			} catch ( ClassNotFoundException e ) { }
			if ( c != null )
				classes.put(c,"unused");
		}
		return c != null;
	}
	public static class Unavailable extends UtilEvalError
	{
		public Unavailable(String s ){ super(s); }
	}
}