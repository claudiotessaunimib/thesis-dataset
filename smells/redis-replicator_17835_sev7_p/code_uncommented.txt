package com.moilioncircle.redis.replicator.rdb;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FREQ;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_IDLE;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPMAP;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_INTSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_3;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STRING;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_ZIPLIST;
import static java.lang.Integer.parseInt;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.event.Event;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.datatype.AuxField;
import com.moilioncircle.redis.replicator.rdb.datatype.ContextKeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.DB;
import com.moilioncircle.redis.replicator.rdb.datatype.EvictType;
import com.moilioncircle.redis.replicator.rdb.datatype.ExpiredType;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyStringValueHash;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyStringValueList;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyStringValueModule;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyStringValueSet;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyStringValueStream;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyStringValueString;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyStringValueZSet;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.Module;
import com.moilioncircle.redis.replicator.rdb.datatype.Stream;
import com.moilioncircle.redis.replicator.rdb.datatype.ZSetEntry;
import com.moilioncircle.redis.replicator.rdb.module.ModuleParser;
import com.moilioncircle.redis.replicator.rdb.skip.SkipRdbParser;
import com.moilioncircle.redis.replicator.util.ByteArrayMap;
import com.moilioncircle.redis.replicator.util.Strings;
public class DefaultRdbVisitor extends RdbVisitor {
    protected static final Logger logger = LoggerFactory.getLogger(DefaultRdbVisitor.class);
    protected final Replicator replicator;
    protected final RdbValueVisitor valueVisitor;
    public DefaultRdbVisitor(Replicator replicator) {
        this(replicator, new DefaultRdbValueVisitor(replicator));
    }
    public DefaultRdbVisitor(Replicator replicator, RdbValueVisitor valueVisitor) {
        this.replicator = replicator;
        this.valueVisitor = valueVisitor;
    }
    @Override
    public String applyMagic(RedisInputStream in) throws IOException {
        String magic = BaseRdbParser.StringHelper.str(in, 5);
        if (!magic.equals("REDIS")) {
            throw new UnsupportedOperationException("can't read MAGIC STRING [REDIS] ,value:" + magic);
        }
        return magic;
    }
    @Override
    public int applyVersion(RedisInputStream in) throws IOException {
        int version = parseInt(BaseRdbParser.StringHelper.str(in, 4));
        if (version < 2 || version > 11) {
            throw new UnsupportedOperationException(String.valueOf("can't handle RDB format version " + version));
        }
        return version;
    }
    @Override
    public int applyType(RedisInputStream in) throws IOException {
        return in.read();
    }
    @Override
    public Event applyFunction(RedisInputStream in, int version) throws IOException {
        return valueVisitor.applyFunction(in, version);
    }
    @Override
    public Event applyFunction2(RedisInputStream in, int version) throws IOException {
        return valueVisitor.applyFunction2(in, version);
    }
    @Override
    public DB applySelectDB(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long dbNumber = parser.rdbLoadLen().len;
        return new DB(dbNumber);
    }
    @Override
    public DB applyResizeDB(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long dbsize = parser.rdbLoadLen().len;
        long expiresSize = parser.rdbLoadLen().len;
        DB db = context.getDb();
        if (db != null) db.setDbsize(dbsize);
        if (db != null) db.setExpires(expiresSize);
        return db;
    }
    @Override
    public Event applyAux(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        String auxKey = Strings.toString(parser.rdbLoadEncodedStringObject().first());
        String auxValue = Strings.toString(parser.rdbLoadEncodedStringObject().first());
        if (!auxKey.startsWith("%")) {
            if (logger.isInfoEnabled()) {
                logger.info("RDB {}: {}", auxKey, auxValue);
            }
            if (auxKey.equals("repl-stream-db")) replicator.getConfiguration().setReplStreamDB(parseInt(auxValue));
            return new AuxField(auxKey, auxValue);
        } else {
            if (logger.isWarnEnabled()) {
                logger.warn("unrecognized RDB AUX field: {}, value: {}", auxKey, auxValue);
            }
            return null;
        }
    }
    @Override
    public Event applyModuleAux(RedisInputStream in, int version) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadLen();
        parser.rdbLoadCheckModuleValue();
        return null;
    }
    @Override
    public long applyEof(RedisInputStream in, int version) throws IOException {
        if (version >= 5) return in.readLong(8);
        return 0L;
    }
    @Override
    public Event applyExpireTime(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long expiredSec = parser.rdbLoadTime();
        int type = applyType(in);
        context.setExpiredType(ExpiredType.SECOND);
        context.setExpiredValue(expiredSec);
        context.setValueRdbType(type);
        KeyValuePair<?, ?> kv;
        if (type == RDB_OPCODE_FREQ) {
            kv = (KeyValuePair<?, ?>) applyFreq(in, version, context);
        } else if (type == RDB_OPCODE_IDLE) {
            kv = (KeyValuePair<?, ?>) applyIdle(in, version, context);
        } else {
            kv = rdbLoadObject(in, version, context);
        }
        return kv;
    }
    @Override
    public Event applyExpireTimeMs(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long expiredMs = parser.rdbLoadMillisecondTime();
        int type = applyType(in);
        context.setExpiredType(ExpiredType.MS);
        context.setExpiredValue(expiredMs);
        context.setValueRdbType(type);
        KeyValuePair<?, ?> kv;
        if (type == RDB_OPCODE_FREQ) {
            kv = (KeyValuePair<?, ?>) applyFreq(in, version, context);
        } else if (type == RDB_OPCODE_IDLE) {
            kv = (KeyValuePair<?, ?>) applyIdle(in, version, context);
        } else {
            kv = rdbLoadObject(in, version, context);
        }
        return kv;
    }
    @Override
    public Event applyFreq(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        long lfuFreq = in.read();
        int valueType = applyType(in);
        context.setValueRdbType(valueType);
        context.setEvictType(EvictType.LFU);
        context.setEvictValue(lfuFreq);
        KeyValuePair<?, ?> kv = rdbLoadObject(in, version, context);
        return kv;
    }
    @Override
    public Event applyIdle(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long lruIdle = parser.rdbLoadLen().len;
        int valueType = applyType(in);
        context.setValueRdbType(valueType);
        context.setEvictType(EvictType.LRU);
        context.setEvictValue(lruIdle);
        KeyValuePair<?, ?> kv = rdbLoadObject(in, version, context);
        return kv;
    }
    @Override
    public Event applyString(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o0 = new KeyStringValueString();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        byte[] val = valueVisitor.applyString(in, version);
        o0.setValueRdbType(RDB_TYPE_STRING);
        o0.setValue(val);
        o0.setKey(key);
        return context.valueOf(o0);
    }
    @Override
    public Event applyList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], List<byte[]>> o1 = new KeyStringValueList();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        List<byte[]> list = valueVisitor.applyList(in, version);
        o1.setValueRdbType(RDB_TYPE_LIST);
        o1.setValue(list);
        o1.setKey(key);
        return context.valueOf(o1);
    }
    @Override
    public Event applySet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Set<byte[]>> o2 = new KeyStringValueSet();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Set<byte[]> set = valueVisitor.applySet(in, version);
        o2.setValueRdbType(RDB_TYPE_SET);
        o2.setValue(set);
        o2.setKey(key);
        return context.valueOf(o2);
    }
    @Override
    public Event applySetListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Set<byte[]>> o20 = new KeyStringValueSet();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Set<byte[]> set = valueVisitor.applySetListPack(in, version);
        o20.setValueRdbType(RDB_TYPE_SET_LISTPACK);
        o20.setValue(set);
        o20.setKey(key);
        return context.valueOf(o20);
    }
    @Override
    public Event applyZSet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Set<ZSetEntry>> o3 = new KeyStringValueZSet();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Set<ZSetEntry> zset = valueVisitor.applyZSet(in, version);
        o3.setValueRdbType(RDB_TYPE_ZSET);
        o3.setValue(zset);
        o3.setKey(key);
        return context.valueOf(o3);
    }
    @Override
    public Event applyZSet2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Set<ZSetEntry>> o5 = new KeyStringValueZSet();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Set<ZSetEntry> zset = valueVisitor.applyZSet2(in, version);
        o5.setValueRdbType(RDB_TYPE_ZSET_2);
        o5.setValue(zset);
        o5.setKey(key);
        return context.valueOf(o5);
    }
    @Override
    public Event applyHash(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Map<byte[], byte[]>> o4 = new KeyStringValueHash();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        ByteArrayMap map = valueVisitor.applyHash(in, version);
        o4.setValueRdbType(RDB_TYPE_HASH);
        o4.setValue(map);
        o4.setKey(key);
        return context.valueOf(o4);
    }
    @Override
    public Event applyHashZipMap(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Map<byte[], byte[]>> o9 = new KeyStringValueHash();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        ByteArrayMap map = valueVisitor.applyHashZipMap(in, version);
        o9.setValueRdbType(RDB_TYPE_HASH_ZIPMAP);
        o9.setValue(map);
        o9.setKey(key);
        return context.valueOf(o9);
    }
    @Override
    public Event applyListZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], List<byte[]>> o10 = new KeyStringValueList();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        List<byte[]> list = valueVisitor.applyListZipList(in, version);
        o10.setValueRdbType(RDB_TYPE_LIST_ZIPLIST);
        o10.setValue(list);
        o10.setKey(key);
        return context.valueOf(o10);
    }
    @Override
    public Event applySetIntSet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Set<byte[]>> o11 = new KeyStringValueSet();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Set<byte[]> set = valueVisitor.applySetIntSet(in, version);
        o11.setValueRdbType(RDB_TYPE_SET_INTSET);
        o11.setValue(set);
        o11.setKey(key);
        return context.valueOf(o11);
    }
    @Override
    public Event applyZSetZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Set<ZSetEntry>> o12 = new KeyStringValueZSet();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Set<ZSetEntry> zset = valueVisitor.applyZSetZipList(in, version);
        o12.setValueRdbType(RDB_TYPE_ZSET_ZIPLIST);
        o12.setValue(zset);
        o12.setKey(key);
        return context.valueOf(o12);
    }
    @Override
    public Event applyZSetListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Set<ZSetEntry>> o17 = new KeyStringValueZSet();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Set<ZSetEntry> zset = valueVisitor.applyZSetListPack(in, version);
        o17.setValueRdbType(RDB_TYPE_ZSET_LISTPACK);
        o17.setValue(zset);
        o17.setKey(key);
        return context.valueOf(o17);
    }
    @Override
    public Event applyHashZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Map<byte[], byte[]>> o13 = new KeyStringValueHash();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        ByteArrayMap map = valueVisitor.applyHashZipList(in, version);
        o13.setValueRdbType(RDB_TYPE_HASH_ZIPLIST);
        o13.setValue(map);
        o13.setKey(key);
        return context.valueOf(o13);
    }
    @Override
    public Event applyHashListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Map<byte[], byte[]>> o16 = new KeyStringValueHash();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        ByteArrayMap map = valueVisitor.applyHashListPack(in, version);
        o16.setValueRdbType(RDB_TYPE_HASH_LISTPACK);
        o16.setValue(map);
        o16.setKey(key);
        return context.valueOf(o16);
    }
    @Override
    public Event applyListQuickList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], List<byte[]>> o14 = new KeyStringValueList();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        List<byte[]> list = valueVisitor.applyListQuickList(in, version);
        o14.setValueRdbType(RDB_TYPE_LIST_QUICKLIST);
        o14.setValue(list);
        o14.setKey(key);
        return context.valueOf(o14);
    }
    @Override
    public Event applyListQuickList2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], List<byte[]>> o18 = new KeyStringValueList();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        List<byte[]> list = valueVisitor.applyListQuickList2(in, version);
        o18.setValueRdbType(RDB_TYPE_LIST_QUICKLIST_2);
        o18.setValue(list);
        o18.setKey(key);
        return context.valueOf(o18);
    }
    @Override
    public Event applyModule(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Module> o6 = new KeyStringValueModule();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Module module = valueVisitor.applyModule(in, version);
        o6.setValueRdbType(RDB_TYPE_MODULE);
        o6.setValue(module);
        o6.setKey(key);
        return context.valueOf(o6);
    }
    @Override
    public Event applyModule2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Module> o7 = new KeyStringValueModule();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Module module = valueVisitor.applyModule2(in, version);
        o7.setValueRdbType(RDB_TYPE_MODULE_2);
        o7.setValue(module);
        o7.setKey(key);
        return context.valueOf(o7);
    }
    @Override
    @SuppressWarnings("resource")
    public Event applyStreamListPacks(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Stream> o15 = new KeyStringValueStream();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Stream stream = valueVisitor.applyStreamListPacks(in, version);
        o15.setValueRdbType(RDB_TYPE_STREAM_LISTPACKS);
        o15.setValue(stream);
        o15.setKey(key);
        return context.valueOf(o15);
    }
    @Override
    @SuppressWarnings("resource")
    public Event applyStreamListPacks2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Stream> o19 = new KeyStringValueStream();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Stream stream = valueVisitor.applyStreamListPacks2(in, version);
        o19.setValueRdbType(RDB_TYPE_STREAM_LISTPACKS_2);
        o19.setValue(stream);
        o19.setKey(key);
        return context.valueOf(o19);
    }
    @Override
    @SuppressWarnings("resource")
    public Event applyStreamListPacks3(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Stream> o21 = new KeyStringValueStream();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        Stream stream = valueVisitor.applyStreamListPacks3(in, version);
        o21.setValueRdbType(RDB_TYPE_STREAM_LISTPACKS_3);
        o21.setValue(stream);
        o21.setKey(key);
        return context.valueOf(o21);
    }
    protected ModuleParser<? extends Module> lookupModuleParser(String moduleName, int moduleVersion) {
        return replicator.getModuleParser(moduleName, moduleVersion);
    }
    protected KeyValuePair<?, ?> rdbLoadObject(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        int valueType = context.getValueRdbType();
        switch (valueType) {
            case RDB_TYPE_STRING:
                return (KeyValuePair<?, ?>) applyString(in, version, context);
            case RDB_TYPE_LIST:
                return (KeyValuePair<?, ?>) applyList(in, version, context);
            case RDB_TYPE_SET:
                return (KeyValuePair<?, ?>) applySet(in, version, context);
            case RDB_TYPE_SET_LISTPACK:
                return (KeyValuePair<?, ?>) applySetListPack(in, version, context);
            case RDB_TYPE_ZSET:
                return (KeyValuePair<?, ?>) applyZSet(in, version, context);
            case RDB_TYPE_ZSET_2:
                return (KeyValuePair<?, ?>) applyZSet2(in, version, context);
            case RDB_TYPE_HASH:
                return (KeyValuePair<?, ?>) applyHash(in, version, context);
            case RDB_TYPE_HASH_ZIPMAP:
                return (KeyValuePair<?, ?>) applyHashZipMap(in, version, context);
            case RDB_TYPE_LIST_ZIPLIST:
                return (KeyValuePair<?, ?>) applyListZipList(in, version, context);
            case RDB_TYPE_SET_INTSET:
                return (KeyValuePair<?, ?>) applySetIntSet(in, version, context);
            case RDB_TYPE_ZSET_ZIPLIST:
                return (KeyValuePair<?, ?>) applyZSetZipList(in, version, context);
            case RDB_TYPE_ZSET_LISTPACK:
                return (KeyValuePair<?, ?>) applyZSetListPack(in, version, context);
            case RDB_TYPE_HASH_ZIPLIST:
                return (KeyValuePair<?, ?>) applyHashZipList(in, version, context);
            case RDB_TYPE_HASH_LISTPACK:
                return (KeyValuePair<?, ?>) applyHashListPack(in, version, context);
            case RDB_TYPE_LIST_QUICKLIST:
                return (KeyValuePair<?, ?>) applyListQuickList(in, version, context);
            case RDB_TYPE_LIST_QUICKLIST_2:
                return (KeyValuePair<?, ?>) applyListQuickList2(in, version, context);
            case RDB_TYPE_MODULE:
                return (KeyValuePair<?, ?>) applyModule(in, version, context);
            case RDB_TYPE_MODULE_2:
                return (KeyValuePair<?, ?>) applyModule2(in, version, context);
            case RDB_TYPE_STREAM_LISTPACKS:
                return (KeyValuePair<?, ?>) applyStreamListPacks(in, version, context);
            case RDB_TYPE_STREAM_LISTPACKS_2:
                return (KeyValuePair<?, ?>) applyStreamListPacks2(in, version, context);
            case RDB_TYPE_STREAM_LISTPACKS_3:
                return (KeyValuePair<?, ?>) applyStreamListPacks3(in, version, context);
            default:
                throw new AssertionError("unexpected value type:" + valueType);
        }
    }
}
package com.moilioncircle.redis.replicator.rdb;
import static com.moilioncircle.redis.replicator.Constants.MODULE_SET;
import static com.moilioncircle.redis.replicator.Constants.QUICKLIST_NODE_CONTAINER_PACKED;
import static com.moilioncircle.redis.replicator.Constants.QUICKLIST_NODE_CONTAINER_PLAIN;
import static com.moilioncircle.redis.replicator.Constants.RDB_LOAD_NONE;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_EOF;
import static com.moilioncircle.redis.replicator.Constants.STREAM_ITEM_FLAG_DELETED;
import static com.moilioncircle.redis.replicator.Constants.STREAM_ITEM_FLAG_SAMEFIELDS;
import static com.moilioncircle.redis.replicator.rdb.BaseRdbParser.StringHelper.listPackEntry;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.TreeMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.moilioncircle.redis.replicator.Constants;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.datatype.Function;
import com.moilioncircle.redis.replicator.rdb.datatype.Module;
import com.moilioncircle.redis.replicator.rdb.datatype.Stream;
import com.moilioncircle.redis.replicator.rdb.datatype.ZSetEntry;
import com.moilioncircle.redis.replicator.rdb.module.ModuleParser;
import com.moilioncircle.redis.replicator.rdb.skip.SkipRdbParser;
import com.moilioncircle.redis.replicator.util.ByteArray;
import com.moilioncircle.redis.replicator.util.ByteArrayList;
import com.moilioncircle.redis.replicator.util.ByteArrayMap;
import com.moilioncircle.redis.replicator.util.ByteArraySet;
import com.moilioncircle.redis.replicator.util.Strings;
@SuppressWarnings({"unchecked", "deprecation"})
public class DefaultRdbValueVisitor extends RdbValueVisitor {
    protected static final Logger logger = LoggerFactory.getLogger(DefaultRdbValueVisitor.class);
    protected final Replicator replicator;
    public DefaultRdbValueVisitor(final Replicator replicator) {
        this.replicator = replicator;
    }
    @Override
    public <T> T applyFunction(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        Function function = new Function();
        function.setName(parser.rdbLoadPlainStringObject().first());
        function.setEngineName(parser.rdbLoadPlainStringObject().first());
        long hasDesc = parser.rdbLoadLen().len;
        if (hasDesc == 1) {
            function.setDescription(parser.rdbLoadPlainStringObject().first());
        }
        function.setCode(parser.rdbLoadPlainStringObject().first());
        return (T) function;
    }
    @Override
    public <T> T applyFunction2(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        Function function = new Function();
        function.setCode(parser.rdbLoadPlainStringObject().first());
        return (T) function;
    }
    @Override
    public <T> T applyString(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        byte[] val = parser.rdbLoadEncodedStringObject().first();
        return (T) val;
    }
    @Override
    public <T> T applyList(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        List<byte[]> list = new ByteArrayList();
        while (len > 0) {
            byte[] element = parser.rdbLoadEncodedStringObject().first();
            list.add(element);
            len--;
        }
        return (T) list;
    }
    @Override
    public <T> T applySet(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        Set<byte[]> set = new ByteArraySet();
        while (len > 0) {
            byte[] element = parser.rdbLoadEncodedStringObject().first();
            set.add(element);
            len--;
        }
        return (T) set;
    }
    @Override
    public <T> T applySetListPack(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream listPack = new RedisInputStream(parser.rdbLoadPlainStringObject());
        Set<byte[]> set = new ByteArraySet();
        listPack.skip(4); 
        int len = listPack.readInt(2);
        while (len > 0) {
            byte[] element = listPackEntry(listPack);
            set.add(element);
            len--;
        }
        int lpend = listPack.read(); 
        if (lpend != 255) {
            throw new AssertionError("listpack expect 255 but " + lpend);
        }
        return (T) set;
    }
    @Override
    public <T> T applyZSet(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        Set<ZSetEntry> zset = new LinkedHashSet<>();
        while (len > 0) {
            byte[] element = parser.rdbLoadEncodedStringObject().first();
            double score = parser.rdbLoadDoubleValue();
            zset.add(new ZSetEntry(element, score));
            len--;
        }
        return (T) zset;
    }
    @Override
    public <T> T applyZSet2(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        Set<ZSetEntry> zset = new LinkedHashSet<>();
        while (len > 0) {
            byte[] element = parser.rdbLoadEncodedStringObject().first();
            double score = parser.rdbLoadBinaryDoubleValue();
            zset.add(new ZSetEntry(element, score));
            len--;
        }
        return (T) zset;
    }
    @Override
    public <T> T applyHash(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        ByteArrayMap map = new ByteArrayMap();
        while (len > 0) {
            byte[] field = parser.rdbLoadEncodedStringObject().first();
            byte[] value = parser.rdbLoadEncodedStringObject().first();
            map.put(field, value);
            len--;
        }
        return (T) map;
    }
    @Override
    public <T> T applyHashZipMap(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream stream = new RedisInputStream(parser.rdbLoadPlainStringObject());
        ByteArrayMap map = new ByteArrayMap();
        BaseRdbParser.LenHelper.zmlen(stream); 
        while (true) {
            int zmEleLen = BaseRdbParser.LenHelper.zmElementLen(stream);
            if (zmEleLen == 255) {
                return (T) map;
            }
            byte[] field = BaseRdbParser.StringHelper.bytes(stream, zmEleLen);
            zmEleLen = BaseRdbParser.LenHelper.zmElementLen(stream);
            if (zmEleLen == 255) {
                map.put(field, null);
                return (T) map;
            }
            int free = BaseRdbParser.LenHelper.free(stream);
            byte[] value = BaseRdbParser.StringHelper.bytes(stream, zmEleLen);
            BaseRdbParser.StringHelper.skip(stream, free);
            map.put(field, value);
        }
    }
    @Override
    public <T> T applyListZipList(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream stream = new RedisInputStream(parser.rdbLoadPlainStringObject());
        List<byte[]> list = new ByteArrayList();
        BaseRdbParser.LenHelper.zlbytes(stream); 
        BaseRdbParser.LenHelper.zltail(stream); 
        int zllen = BaseRdbParser.LenHelper.zllen(stream);
        for (int i = 0; i < zllen; i++) {
            byte[] e = BaseRdbParser.StringHelper.zipListEntry(stream);
            list.add(e);
        }
        int zlend = BaseRdbParser.LenHelper.zlend(stream);
        if (zlend != 255) {
            throw new AssertionError("zlend expect 255 but " + zlend);
        }
        return (T) list;
    }
    @Override
    public <T> T applySetIntSet(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream stream = new RedisInputStream(parser.rdbLoadPlainStringObject());
        Set<byte[]> set = new ByteArraySet();
        int encoding = BaseRdbParser.LenHelper.encoding(stream);
        long lenOfContent = BaseRdbParser.LenHelper.lenOfContent(stream);
        for (long i = 0; i < lenOfContent; i++) {
            switch (encoding) {
                case 2:
                    String element = String.valueOf(stream.readInt(2));
                    set.add(element.getBytes());
                    break;
                case 4:
                    element = String.valueOf(stream.readInt(4));
                    set.add(element.getBytes());
                    break;
                case 8:
                    element = String.valueOf(stream.readLong(8));
                    set.add(element.getBytes());
                    break;
                default:
                    throw new AssertionError("expect encoding [2,4,8] but:" + encoding);
            }
        }
        return (T) set;
    }
    @Override
    public <T> T applyZSetZipList(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream stream = new RedisInputStream(parser.rdbLoadPlainStringObject());
        Set<ZSetEntry> zset = new LinkedHashSet<>();
        BaseRdbParser.LenHelper.zlbytes(stream); 
        BaseRdbParser.LenHelper.zltail(stream); 
        int zllen = BaseRdbParser.LenHelper.zllen(stream);
        while (zllen > 0) {
            byte[] element = BaseRdbParser.StringHelper.zipListEntry(stream);
            zllen--;
            double score = Double.valueOf(Strings.toString(BaseRdbParser.StringHelper.zipListEntry(stream)));
            zllen--;
            zset.add(new ZSetEntry(element, score));
        }
        int zlend = BaseRdbParser.LenHelper.zlend(stream);
        if (zlend != 255) {
            throw new AssertionError("zlend expect 255 but " + zlend);
        }
        return (T) zset;
    }
    @Override
    public <T> T applyZSetListPack(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream listPack = new RedisInputStream(parser.rdbLoadPlainStringObject());
        Set<ZSetEntry> zset = new LinkedHashSet<>();
        listPack.skip(4); 
        int len = listPack.readInt(2);
        while (len > 0) {
            byte[] element = listPackEntry(listPack);
            len--;
            double score = Double.valueOf(Strings.toString(listPackEntry(listPack)));
            len--;
            zset.add(new ZSetEntry(element, score));
        }
        int lpend = listPack.read(); 
        if (lpend != 255) {
            throw new AssertionError("listpack expect 255 but " + lpend);
        }
        return (T) zset;
    }
    @Override
    public <T> T applyHashZipList(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream stream = new RedisInputStream(parser.rdbLoadPlainStringObject());
        ByteArrayMap map = new ByteArrayMap();
        BaseRdbParser.LenHelper.zlbytes(stream); 
        BaseRdbParser.LenHelper.zltail(stream); 
        int zllen = BaseRdbParser.LenHelper.zllen(stream);
        while (zllen > 0) {
            byte[] field = BaseRdbParser.StringHelper.zipListEntry(stream);
            zllen--;
            byte[] value = BaseRdbParser.StringHelper.zipListEntry(stream);
            zllen--;
            map.put(field, value);
        }
        int zlend = BaseRdbParser.LenHelper.zlend(stream);
        if (zlend != 255) {
            throw new AssertionError("zlend expect 255 but " + zlend);
        }
        return (T) map;
    }
    @Override
    public <T> T applyHashListPack(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream listPack = new RedisInputStream(parser.rdbLoadPlainStringObject());
        ByteArrayMap map = new ByteArrayMap();
        listPack.skip(4); 
        int len = listPack.readInt(2);
        while (len > 0) {
            byte[] field = listPackEntry(listPack);
            len--;
            byte[] value = listPackEntry(listPack);
            len--;
            map.put(field, value);
        }
        int lpend = listPack.read(); 
        if (lpend != 255) {
            throw new AssertionError("listpack expect 255 but " + lpend);
        }
        return (T) map;
    }
    @Override
    public <T> T applyListQuickList(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        List<byte[]> list = new ByteArrayList();
        for (long i = 0; i < len; i++) {
            RedisInputStream stream = new RedisInputStream(parser.rdbGenericLoadStringObject(RDB_LOAD_NONE));
            BaseRdbParser.LenHelper.zlbytes(stream); 
            BaseRdbParser.LenHelper.zltail(stream); 
            int zllen = BaseRdbParser.LenHelper.zllen(stream);
            for (int j = 0; j < zllen; j++) {
                byte[] e = BaseRdbParser.StringHelper.zipListEntry(stream);
                list.add(e);
            }
            int zlend = BaseRdbParser.LenHelper.zlend(stream);
            if (zlend != 255) {
                throw new AssertionError("zlend expect 255 but " + zlend);
            }
        }
        return (T) list;
    }
    @Override
    public <T> T applyListQuickList2(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        List<byte[]> list = new ByteArrayList();
        for (long i = 0; i < len; i++) {
            long container = parser.rdbLoadLen().len;
            ByteArray bytes = parser.rdbLoadPlainStringObject();
            if (container == QUICKLIST_NODE_CONTAINER_PLAIN) {
                list.add(bytes.first());
            } else if (container == QUICKLIST_NODE_CONTAINER_PACKED) {
                RedisInputStream listPack = new RedisInputStream(bytes);
                listPack.skip(4); 
                int innerLen = listPack.readInt(2);
                for (int j = 0; j < innerLen; j++) {
                    byte[] e = listPackEntry(listPack);
                    list.add(e);
                }
                int lpend = listPack.read(); 
                if (lpend != 255) {
                    throw new AssertionError("listpack expect 255 but " + lpend);
                }
            } else {
                throw new UnsupportedOperationException(String.valueOf(container));
            }
        }
        return (T) list;
    }
    @Override
    public <T> T applyModule(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        char[] c = new char[9];
        long moduleid = parser.rdbLoadLen().len;
        for (int i = 0; i < c.length; i++) {
            c[i] = MODULE_SET[(int) (moduleid >>> (10 + (c.length - 1 - i) * 6) & 63)];
        }
        String moduleName = new String(c);
        int moduleVersion = (int) (moduleid & 1023);
        ModuleParser<? extends Module> moduleParser = lookupModuleParser(moduleName, moduleVersion);
        if (moduleParser == null) {
            throw new NoSuchElementException("module parser[" + moduleName + ", " + moduleVersion + "] not register. rdb type: [RDB_TYPE_MODULE]");
        }
        Module module = moduleParser.parse(in, 1);
        return (T) module;
    }
    @Override
    public <T> T applyModule2(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        char[] c = new char[9];
        long moduleid = parser.rdbLoadLen().len;
        for (int i = 0; i < c.length; i++) {
            c[i] = MODULE_SET[(int) (moduleid >>> (10 + (c.length - 1 - i) * 6) & 63)];
        }
        String moduleName = new String(c);
        int moduleVersion = (int) (moduleid & 1023);
        ModuleParser<? extends Module> moduleParser = lookupModuleParser(moduleName, moduleVersion);
        Module module = null;
        if (moduleParser == null) {
            logger.warn("module parser[{}, {}] not register. rdb type: [RDB_TYPE_MODULE_2]. module parse skipped.", moduleName, moduleVersion);
            SkipRdbParser skipRdbParser = new SkipRdbParser(in);
            skipRdbParser.rdbLoadCheckModuleValue();
        } else {
            module = moduleParser.parse(in, 2);
            long eof = parser.rdbLoadLen().len;
            if (eof != RDB_MODULE_OPCODE_EOF) {
                throw new UnsupportedOperationException("The RDB file contains module data for the module '" + moduleName + "' that is not terminated by the proper module value EOF marker");
            }
        }
        return (T) module;
    }
    protected ModuleParser<? extends Module> lookupModuleParser(String moduleName, int moduleVersion) {
        return replicator.getModuleParser(moduleName, moduleVersion);
    }
    @Override
    public <T> T applyStreamListPacks(RedisInputStream in, int version) throws IOException {
        return applyStreamListPacks(in, version, Constants.RDB_TYPE_STREAM_LISTPACKS);
    }
    @Override
    public <T> T applyStreamListPacks2(RedisInputStream in, int version) throws IOException {
        return applyStreamListPacks(in, version, Constants.RDB_TYPE_STREAM_LISTPACKS_2);
    }
    @Override
    public <T> T applyStreamListPacks3(RedisInputStream in, int version) throws IOException {
        return applyStreamListPacks(in, version, Constants.RDB_TYPE_STREAM_LISTPACKS_3);
    }
    @SuppressWarnings("resource")
    protected <T> T applyStreamListPacks(RedisInputStream in, int version, int type) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        Stream stream = new Stream();
        NavigableMap<Stream.ID, Stream.Entry> entries = new TreeMap<>(Stream.ID.COMPARATOR);
        long listPacks = parser.rdbLoadLen().len;
        while (listPacks-- > 0) {
            RedisInputStream rawId = new RedisInputStream(parser.rdbLoadPlainStringObject());
            Stream.ID baseId = new Stream.ID(rawId.readLong(8, false), rawId.readLong(8, false));
            RedisInputStream listPack = new RedisInputStream(parser.rdbLoadPlainStringObject());
            listPack.skip(4); 
            listPack.skip(2); 
            long count = Long.parseLong(Strings.toString(listPackEntry(listPack))); 
            long deleted = Long.parseLong(Strings.toString(listPackEntry(listPack))); 
            int numFields = Integer.parseInt(Strings.toString(listPackEntry(listPack))); 
            byte[][] tempFields = new byte[numFields][];
            for (int i = 0; i < numFields; i++) {
                tempFields[i] = listPackEntry(listPack);
            }
            listPackEntry(listPack); 
            long total = count + deleted;
            while (total-- > 0) {
                Map<byte[], byte[]> fields = new ByteArrayMap();
                int flag = Integer.parseInt(Strings.toString(listPackEntry(listPack)));
                long ms = Long.parseLong(Strings.toString(listPackEntry(listPack)));
                long seq = Long.parseLong(Strings.toString(listPackEntry(listPack)));
                Stream.ID id = baseId.delta(ms, seq);
                boolean delete = (flag & STREAM_ITEM_FLAG_DELETED) != 0;
                if ((flag & STREAM_ITEM_FLAG_SAMEFIELDS) != 0) {
                    for (int i = 0; i < numFields; i++) {
                        byte[] value = listPackEntry(listPack);
                        byte[] field = tempFields[i];
                        fields.put(field, value);
                    }
                    entries.put(id, new Stream.Entry(id, delete, fields));
                } else {
                    numFields = Integer.parseInt(Strings.toString(listPackEntry(listPack)));
                    for (int i = 0; i < numFields; i++) {
                        byte[] field = listPackEntry(listPack);
                        byte[] value = listPackEntry(listPack);
                        fields.put(field, value);
                    }
                    entries.put(id, new Stream.Entry(id, delete, fields));
                }
                listPackEntry(listPack); 
            }
            int lpend = listPack.read(); 
            if (lpend != 255) {
                throw new AssertionError("listpack expect 255 but " + lpend);
            }
        }
        long length = parser.rdbLoadLen().len;
        Stream.ID lastId = new Stream.ID(parser.rdbLoadLen().len, parser.rdbLoadLen().len);
        Stream.ID firstId = null;
        Stream.ID maxDeletedEntryId = null;
        Long entriesAdded = null;
        if (type >= Constants.RDB_TYPE_STREAM_LISTPACKS_2) {
            firstId = new Stream.ID(parser.rdbLoadLen().len, parser.rdbLoadLen().len);
            maxDeletedEntryId = new Stream.ID(parser.rdbLoadLen().len, parser.rdbLoadLen().len);
            entriesAdded = parser.rdbLoadLen().len;
        }
        List<Stream.Group> groups = new ArrayList<>();
        long groupCount = parser.rdbLoadLen().len;
        while (groupCount-- > 0) {
            Stream.Group group = new Stream.Group();
            byte[] groupName = parser.rdbLoadPlainStringObject().first();
            Stream.ID groupLastId = new Stream.ID(parser.rdbLoadLen().len, parser.rdbLoadLen().len);
            Long entriesRead = null;
            if (type >= Constants.RDB_TYPE_STREAM_LISTPACKS_2) {
                entriesRead = parser.rdbLoadLen().len;
            }
            NavigableMap<Stream.ID, Stream.Nack> groupPendingEntries = new TreeMap<>(Stream.ID.COMPARATOR);
            long globalPel = parser.rdbLoadLen().len;
            while (globalPel-- > 0) {
                Stream.ID rawId = new Stream.ID(in.readLong(8, false), in.readLong(8, false));
                long deliveryTime = parser.rdbLoadMillisecondTime();
                long deliveryCount = parser.rdbLoadLen().len;
                groupPendingEntries.put(rawId, new Stream.Nack(rawId, null, deliveryTime, deliveryCount));
            }
            List<Stream.Consumer> consumers = new ArrayList<>();
            long consumerCount = parser.rdbLoadLen().len;
            while (consumerCount-- > 0) {
                Stream.Consumer consumer = new Stream.Consumer();
                byte[] consumerName = parser.rdbLoadPlainStringObject().first();
                long seenTime = parser.rdbLoadMillisecondTime();
                long activeTime = -1;
                if (type >= Constants.RDB_TYPE_STREAM_LISTPACKS_3) {
                    activeTime = parser.rdbLoadMillisecondTime();
                }
                NavigableMap<Stream.ID, Stream.Nack> consumerPendingEntries = new TreeMap<>(Stream.ID.COMPARATOR);
                long pel = parser.rdbLoadLen().len;
                while (pel-- > 0) {
                    Stream.ID rawId = new Stream.ID(in.readLong(8, false), in.readLong(8, false));
                    Stream.Nack nack = groupPendingEntries.get(rawId);
                    nack.setConsumer(consumer);
                    consumerPendingEntries.put(rawId, nack);
                }
                consumer.setName(consumerName);
                consumer.setSeenTime(seenTime);
                if (type >= Constants.RDB_TYPE_STREAM_LISTPACKS_3) {
                    consumer.setActiveTime(activeTime);
                }
                consumer.setPendingEntries(consumerPendingEntries);
                consumers.add(consumer);
            }
            group.setName(groupName);
            group.setLastId(groupLastId);
            if (type >= Constants.RDB_TYPE_STREAM_LISTPACKS_2) {
                group.setEntriesRead(entriesRead);
            }
            group.setPendingEntries(groupPendingEntries);
            group.setConsumers(consumers);
            groups.add(group);
        }
        stream.setLastId(lastId);
        if (type >= Constants.RDB_TYPE_STREAM_LISTPACKS_2) {
            stream.setFirstId(firstId);
            stream.setMaxDeletedEntryId(maxDeletedEntryId);
            stream.setEntriesAdded(entriesAdded);
        }
        stream.setEntries(entries);
        stream.setLength(length);
        stream.setGroups(groups);
        return (T) stream;
    }
}
package com.moilioncircle.redis.replicator.rdb;
import java.io.IOException;
import com.moilioncircle.redis.replicator.event.Event;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.datatype.ContextKeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.DB;
public abstract class RdbVisitor {
    public String applyMagic(RedisInputStream in) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public int applyVersion(RedisInputStream in) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public int applyType(RedisInputStream in) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyFunction(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyFunction2(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public DB applySelectDB(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public DB applyResizeDB(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public long applyEof(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyAux(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyModuleAux(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyExpireTime(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyExpireTimeMs(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyFreq(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyIdle(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyString(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applySet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applySetListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyZSet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyZSet2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyHash(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyHashZipMap(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyListZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applySetIntSet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyZSetZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyZSetListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyHashZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyHashListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyListQuickList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyListQuickList2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyModule(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyModule2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyStreamListPacks(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyStreamListPacks2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public Event applyStreamListPacks3(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
}
package com.moilioncircle.redis.replicator.rdb;
import java.io.IOException;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
public abstract class RdbValueVisitor {
    public <T> T applyFunction(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyFunction2(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyString(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyList(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applySet(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applySetListPack(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyZSet(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyZSet2(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyHash(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyHashZipMap(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyListZipList(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applySetIntSet(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyZSetZipList(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyZSetListPack(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyHashZipList(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyHashListPack(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyListQuickList(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyListQuickList2(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyModule(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyModule2(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyStreamListPacks(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyStreamListPacks2(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
    public <T> T applyStreamListPacks3(RedisInputStream in, int version) throws IOException {
        throw new UnsupportedOperationException("must implement this method.");
    }
}
package com.moilioncircle.redis.replicator.rdb;
import static com.moilioncircle.redis.replicator.Constants.RDB_14BITLEN;
import static com.moilioncircle.redis.replicator.Constants.RDB_32BITLEN;
import static com.moilioncircle.redis.replicator.Constants.RDB_64BITLEN;
import static com.moilioncircle.redis.replicator.Constants.RDB_6BITLEN;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENCVAL;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENC_INT16;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENC_INT32;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENC_INT8;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENC_LZF;
import static com.moilioncircle.redis.replicator.Constants.RDB_LOAD_ENC;
import static com.moilioncircle.redis.replicator.Constants.RDB_LOAD_PLAIN;
import static com.moilioncircle.redis.replicator.Constants.ZIP_INT_16B;
import static com.moilioncircle.redis.replicator.Constants.ZIP_INT_24B;
import static com.moilioncircle.redis.replicator.Constants.ZIP_INT_32B;
import static com.moilioncircle.redis.replicator.Constants.ZIP_INT_64B;
import static com.moilioncircle.redis.replicator.Constants.ZIP_INT_8B;
import java.io.IOException;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.util.ByteArray;
import com.moilioncircle.redis.replicator.util.Lzf;
public class BaseRdbParser {
    protected final RedisInputStream in;
    public BaseRdbParser(RedisInputStream in) {
        this.in = in;
    }
    public int rdbLoadTime() throws IOException {
        return in.readInt(4);
    }
    public long rdbLoadMillisecondTime() throws IOException {
        return in.readLong(8);
    }
    public Len rdbLoadLen() throws IOException {
        boolean isencoded = false;
        int rawByte = in.read();
        int type = (rawByte & 0xC0) >> 6;
        long value;
        if (type == RDB_ENCVAL) {
            isencoded = true;
            value = rawByte & 0x3F;
        } else if (type == RDB_6BITLEN) {
            value = rawByte & 0x3F;
        } else if (type == RDB_14BITLEN) {
            value = ((rawByte & 0x3F) << 8) | in.read();
        } else if (rawByte == RDB_32BITLEN) {
            value = in.readUInt(4, false);
        } else if (rawByte == RDB_64BITLEN) {
            value = in.readLong(8, false); 
        } else {
            throw new AssertionError("unexpected len-type:" + type);
        }
        return new Len(value, isencoded);
    }
    public ByteArray rdbLoadIntegerObject(int enctype, int flags) throws IOException {
        boolean plain = (flags & RDB_LOAD_PLAIN) != 0;
        boolean encode = (flags & RDB_LOAD_ENC) != 0;
        byte[] value;
        switch (enctype) {
            case RDB_ENC_INT8:
                value = in.readBytes(1).first();
                break;
            case RDB_ENC_INT16:
                value = in.readBytes(2).first();
                break;
            case RDB_ENC_INT32:
                value = in.readBytes(4).first();
                break;
            default:
                value = new byte[]{0x00};
                break;
        }
        if (plain) {
            return new ByteArray(value);
        } else if (encode) {
            return new ByteArray(String.valueOf(in.readInt(value)).getBytes());
        } else {
            return new ByteArray(value);
        }
    }
    public ByteArray rdbLoadLzfStringObject(int flags) throws IOException {
        boolean plain = (flags & RDB_LOAD_PLAIN) != 0;
        boolean encode = (flags & RDB_LOAD_ENC) != 0;
        long clen = rdbLoadLen().len;
        long len = rdbLoadLen().len;
        if (plain) {
            return Lzf.decode(in.readBytes(clen), len);
        } else if (encode) {
            return Lzf.decode(in.readBytes(clen), len);
        } else {
            return Lzf.decode(in.readBytes(clen), len);
        }
    }
    public ByteArray rdbGenericLoadStringObject(int flags) throws IOException {
        boolean plain = (flags & RDB_LOAD_PLAIN) != 0;
        boolean encode = (flags & RDB_LOAD_ENC) != 0;
        Len lenObj = rdbLoadLen();
        long len = (int) lenObj.len;
        boolean isencoded = lenObj.encoded;
        if (isencoded) {
            switch ((int) len) {
                case RDB_ENC_INT8:
                case RDB_ENC_INT16:
                case RDB_ENC_INT32:
                    return rdbLoadIntegerObject((int) len, flags);
                case RDB_ENC_LZF:
                    return rdbLoadLzfStringObject(flags);
                default:
                    throw new AssertionError("unknown RdbParser encoding type:" + len);
            }
        }
        if (plain) {
            return in.readBytes(len);
        } else if (encode) {
            return in.readBytes(len);
        } else {
            return in.readBytes(len);
        }
    }
    public ByteArray rdbLoadPlainStringObject() throws IOException {
        return rdbGenericLoadStringObject(RDB_LOAD_PLAIN);
    }
    public ByteArray rdbLoadEncodedStringObject() throws IOException {
        return rdbGenericLoadStringObject(RDB_LOAD_ENC);
    }
    public double rdbLoadDoubleValue() throws IOException {
        int len = in.read();
        switch (len) {
            case 255:
                return Double.NEGATIVE_INFINITY;
            case 254:
                return Double.POSITIVE_INFINITY;
            case 253:
                return Double.NaN;
            default:
                byte[] bytes = in.readBytes(len).first();
                return Double.valueOf(new String(bytes));
        }
    }
    public double rdbLoadBinaryDoubleValue() throws IOException {
        return Double.longBitsToDouble(in.readLong(8));
    }
    public float rdbLoadBinaryFloatValue() throws IOException {
        return Float.intBitsToFloat(in.readInt(4));
    }
    public static class Len {
        public final long len;
        public final boolean encoded;
        private Len(long len, boolean encoded) {
            this.len = len;
            this.encoded = encoded;
        }
    }
    public static class StringHelper {
        private StringHelper() {
        }
        public static String str(RedisInputStream in, int len) throws IOException {
            return in.readString(len);
        }
        public static byte[] bytes(RedisInputStream in, int len) throws IOException {
            return in.readBytes(len).first();
        }
        public static long skip(RedisInputStream in, long len) throws IOException {
            return in.skip(len);
        }
        public static byte[] zipListEntry(RedisInputStream in) throws IOException {
            int prevlen = in.read();
            if (prevlen >= 254) {
                prevlen = in.readInt(4);
            }
            int special = in.read();
            switch (special >> 6) {
                case 0:
                    int len = special & 0x3F;
                    return bytes(in, len);
                case 1:
                    len = ((special & 0x3F) << 8) | in.read();
                    return bytes(in, len);
                case 2:
                    len = in.readInt(4, false);
                    return bytes(in, len);
                default:
                    break;
            }
            switch (special) {
                case ZIP_INT_8B:
                    return String.valueOf(in.readInt(1)).getBytes();
                case ZIP_INT_16B:
                    return String.valueOf(in.readInt(2)).getBytes();
                case ZIP_INT_24B:
                    return String.valueOf(in.readInt(3)).getBytes();
                case ZIP_INT_32B:
                    return String.valueOf(in.readInt(4)).getBytes();
                case ZIP_INT_64B:
                    return String.valueOf(in.readLong(8)).getBytes();
                default:
                    return String.valueOf(special - 0xF1).getBytes();
            }
        }
        public static byte[] listPackEntry(RedisInputStream in) throws IOException {
            int special = in.read();
            byte[] value;
            long skip;
            if ((special & 0x80) == 0) {
                skip = 1;
                value = String.valueOf(special & 0x7F).getBytes();
            } else if ((special & 0xC0) == 0x80) {
                int len = special & 0x3F;
                skip = 1 + len;
                value = bytes(in, len);
            } else if ((special & 0xE0) == 0xC0) {
                skip = 2;
                int next = in.read();
                value = String.valueOf((((special & 0x1F) << 8) | next) << 19 >> 19).getBytes();
            } else if ((special & 0xFF) == 0xF1) {
                skip = 3;
                value = String.valueOf(in.readInt(2)).getBytes();
            } else if ((special & 0xFF) == 0xF2) {
                skip = 4;
                value = String.valueOf(in.readInt(3)).getBytes();
            } else if ((special & 0xFF) == 0xF3) {
                skip = 5;
                value = String.valueOf(in.readInt(4)).getBytes();
            } else if ((special & 0xFF) == 0xF4) {
                skip = 9;
                value = String.valueOf(in.readLong(8)).getBytes();
            } else if ((special & 0xF0) == 0xE0) {
                int len = ((special & 0x0F) << 8) | in.read();
                skip = 2 + len;
                value = bytes(in, len);
            } else if ((special & 0xFF) == 0xF0) {
                int len = in.readInt(4);
                skip = 5 + len;
                value = bytes(in, len);
            } else {
                throw new UnsupportedOperationException(String.valueOf(special));
            }
            if (skip <= 127) {
                in.skip(1);
            } else if (skip < 16383) {
                in.skip(2);
            } else if (skip < 2097151) {
                in.skip(3);
            } else if (skip < 268435455) {
                in.skip(4);
            } else {
                in.skip(5);
            }
            return value;
        }
    }
    public static class LenHelper {
        private LenHelper() {
        }
        public static int zmlen(RedisInputStream in) throws IOException {
            return in.read();
        }
        public static int free(RedisInputStream in) throws IOException {
            return in.read();
        }
        public static int zmElementLen(RedisInputStream in) throws IOException {
            int len = in.read();
            if (len >= 0 && len <= 253) {
                return len;
            } else if (len == 254) {
                return in.readInt(4, false);
            } else {
                return len;
            }
        }
        public static int zlbytes(RedisInputStream in) throws IOException {
            return in.readInt(4);
        }
        public static int zlend(RedisInputStream in) throws IOException {
            return in.read();
        }
        public static int zltail(RedisInputStream in) throws IOException {
            return in.readInt(4);
        }
        public static int zllen(RedisInputStream in) throws IOException {
            return in.readInt(2);
        }
        public static int encoding(RedisInputStream in) throws IOException {
            return in.readInt(4);
        }
        public static long lenOfContent(RedisInputStream in) throws IOException {
            return in.readUInt(4);
        }
    }
}
package com.moilioncircle.redis.replicator.rdb;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_AUX;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_EOF;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_EXPIRETIME;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_EXPIRETIME_MS;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FREQ;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FUNCTION;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FUNCTION2;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_IDLE;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_MODULE_AUX;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_RESIZEDB;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_SELECTDB;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPMAP;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_INTSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_3;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STRING;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_ZIPLIST;
import static com.moilioncircle.redis.replicator.Status.CONNECTED;
import static com.moilioncircle.redis.replicator.util.Tuples.of;
import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.moilioncircle.redis.replicator.AbstractReplicator;
import com.moilioncircle.redis.replicator.event.Event;
import com.moilioncircle.redis.replicator.event.PostRdbSyncEvent;
import com.moilioncircle.redis.replicator.event.PreRdbSyncEvent;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.datatype.ContextKeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.DB;
public class RdbParser {
    protected final RedisInputStream in;
    protected final RdbVisitor rdbVisitor;
    protected final AbstractReplicator replicator;
    protected static final Logger logger = LoggerFactory.getLogger(RdbParser.class);
    public RdbParser(RedisInputStream in, AbstractReplicator replicator) {
        this.in = in;
        this.replicator = replicator;
        this.rdbVisitor = this.replicator.getRdbVisitor();
    }
    public long parse() throws IOException {
        long offset = 0L;
        boolean discard = this.replicator.getConfiguration().isDiscardRdbEvent();
        if (!discard) this.replicator.submitEvent(new PreRdbSyncEvent(), of(0L, 0L));
        in.mark();
        rdbVisitor.applyMagic(in);
        int version = rdbVisitor.applyVersion(in);
        offset += in.unmark();
        DB db = null;
        loop:
        while (this.replicator.getStatus() == CONNECTED) {
            Event event = null;
            in.mark();
            int type = rdbVisitor.applyType(in);
            ContextKeyValuePair kv = new ContextKeyValuePair();
            kv.setDb(db);
            switch (type) {
                case RDB_OPCODE_EXPIRETIME:
                    event = rdbVisitor.applyExpireTime(in, version, kv);
                    break;
                case RDB_OPCODE_EXPIRETIME_MS:
                    event = rdbVisitor.applyExpireTimeMs(in, version, kv);
                    break;
                case RDB_OPCODE_FREQ:
                    event = rdbVisitor.applyFreq(in, version, kv);
                    break;
                case RDB_OPCODE_IDLE:
                    event = rdbVisitor.applyIdle(in, version, kv);
                    break;
                case RDB_OPCODE_AUX:
                    event = rdbVisitor.applyAux(in, version);
                    break;
                case RDB_OPCODE_MODULE_AUX:
                    event = rdbVisitor.applyModuleAux(in, version);
                    break;
                case RDB_OPCODE_FUNCTION:
                    event = rdbVisitor.applyFunction(in, version);
                    break;
                case RDB_OPCODE_FUNCTION2:
                    event = rdbVisitor.applyFunction2(in, version);
                    break;
                case RDB_OPCODE_RESIZEDB:
                    rdbVisitor.applyResizeDB(in, version, kv);
                    break;
                case RDB_OPCODE_SELECTDB:
                    db = rdbVisitor.applySelectDB(in, version);
                    break;
                case RDB_OPCODE_EOF:
                    long checksum = rdbVisitor.applyEof(in, version);
                    long start = offset;
                    offset += in.unmark();
                    if (!discard) this.replicator.submitEvent(new PostRdbSyncEvent(checksum), of(start, offset));
                    break loop;
                case RDB_TYPE_STRING:
                    event = rdbVisitor.applyString(in, version, kv);
                    break;
                case RDB_TYPE_LIST:
                    event = rdbVisitor.applyList(in, version, kv);
                    break;
                case RDB_TYPE_SET:
                    event = rdbVisitor.applySet(in, version, kv);
                    break;
                case RDB_TYPE_SET_LISTPACK:
                    event = rdbVisitor.applySetListPack(in, version, kv);
                    break;
                case RDB_TYPE_ZSET:
                    event = rdbVisitor.applyZSet(in, version, kv);
                    break;
                case RDB_TYPE_ZSET_2:
                    event = rdbVisitor.applyZSet2(in, version, kv);
                    break;
                case RDB_TYPE_HASH:
                    event = rdbVisitor.applyHash(in, version, kv);
                    break;
                case RDB_TYPE_HASH_ZIPMAP:
                    event = rdbVisitor.applyHashZipMap(in, version, kv);
                    break;
                case RDB_TYPE_LIST_ZIPLIST:
                    event = rdbVisitor.applyListZipList(in, version, kv);
                    break;
                case RDB_TYPE_SET_INTSET:
                    event = rdbVisitor.applySetIntSet(in, version, kv);
                    break;
                case RDB_TYPE_ZSET_ZIPLIST:
                    event = rdbVisitor.applyZSetZipList(in, version, kv);
                    break;
                case RDB_TYPE_ZSET_LISTPACK:
                    event = rdbVisitor.applyZSetListPack(in, version, kv);
                    break;
                case RDB_TYPE_HASH_ZIPLIST:
                    event = rdbVisitor.applyHashZipList(in, version, kv);
                    break;
                case RDB_TYPE_HASH_LISTPACK:
                    event = rdbVisitor.applyHashListPack(in, version, kv);
                    break;
                case RDB_TYPE_LIST_QUICKLIST:
                    event = rdbVisitor.applyListQuickList(in, version, kv);
                    break;
                case RDB_TYPE_LIST_QUICKLIST_2:
                    event = rdbVisitor.applyListQuickList2(in, version, kv);
                    break;
                case RDB_TYPE_MODULE:
                    event = rdbVisitor.applyModule(in, version, kv);
                    break;
                case RDB_TYPE_MODULE_2:
                    event = rdbVisitor.applyModule2(in, version, kv);
                    break;
                case RDB_TYPE_STREAM_LISTPACKS:
                    event = rdbVisitor.applyStreamListPacks(in, version, kv);
                    break;
                case RDB_TYPE_STREAM_LISTPACKS_2:
                    event = rdbVisitor.applyStreamListPacks2(in, version, kv);
                    break;
                case RDB_TYPE_STREAM_LISTPACKS_3:
                    event = rdbVisitor.applyStreamListPacks3(in, version, kv);
                    break;
                default:
                    throw new AssertionError("unexpected value type:" + type + ", check your ModuleParser or ValueIterableRdbVisitor.");
            }
            long start = offset;
            offset += in.unmark();
            if (event == null) continue;
            if (replicator.verbose() && logger.isDebugEnabled()) logger.debug("{}", event);
            if (!discard) this.replicator.submitEvent(event, of(start, offset));
        }
        return offset;
    }
}
package com.moilioncircle.redis.replicator.rdb;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_AUX;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_EOF;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_EXPIRETIME_MS;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_RESIZEDB;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_SELECTDB;
import static com.moilioncircle.redis.replicator.util.Strings.lappend;
import java.io.BufferedOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Queue;
import com.moilioncircle.redis.replicator.Configuration;
import com.moilioncircle.redis.replicator.client.RESP2;
import com.moilioncircle.redis.replicator.client.RESP2Client;
import com.moilioncircle.redis.replicator.io.CRCOutputStream;
import com.moilioncircle.redis.replicator.rdb.datatype.DB;
import com.moilioncircle.redis.replicator.util.ByteArray;
import com.moilioncircle.redis.replicator.util.type.Tuple2;
public class ScanRdbGenerator {
    private int db = 0;
    private RESP2Client client;
    protected final int port;
    protected final String host;
    private final CRCOutputStream out;
    private final Configuration configuration;
    private static Map<String, Integer> VERSIONS = new HashMap<>();
    static {
        VERSIONS.put("2.6", 6);
        VERSIONS.put("2.8", 6);
        VERSIONS.put("3.0", 6);
        VERSIONS.put("3.2", 7);
        VERSIONS.put("4.0", 8);
        VERSIONS.put("5.0", 9);
        VERSIONS.put("6.0", 9);
        VERSIONS.put("6.2", 9);
        VERSIONS.put("7.0", 10);
        VERSIONS.put("7.2", 11);
    }
    public ScanRdbGenerator(String host, int port, Configuration configuration, OutputStream out) {
        this.host = host;
        this.port = port;
        this.configuration = configuration;
        this.out = new CRCOutputStream(new BufferedOutputStream(out, this.configuration.getBufferSize()));
    }
    public void generate() throws IOException {
        try {
            this.client = new RESP2Client(host, port, configuration);
            int version = 0;
            String ver = null;
            String bits = null;
            RESP2.Node server = retry(client -> {
                RESP2Client.Command r = client.newCommand();
                return r.invoke("info", "server");
            });
            if (server.type == RESP2.Type.ERROR) {
                throw new IOException(server.getError());
            } else {
                String value = server.getString();
                String[] lines = value.split("\r\n");
                for (int i = 1; i < lines.length; i++) {
                    String[] kv = lines[i].split(":");
                    String key = kv[0];
                    if (key.equals("redis_version")) {
                        String val = kv[1];
                        ver = val;
                        val = val.substring(0, val.lastIndexOf('.'));
                        if (!VERSIONS.containsKey(val)) {
                            throw new AssertionError("unsupported redis version :" + val);
                        }
                        version = VERSIONS.get(val);
                    } else if (key.equals("arch_bits")) {
                        String val = kv[1];
                        bits = val;
                    }
                }
            }
            out.write("REDIS".getBytes());
            out.write(lappend(version, 4, '0').getBytes());
            if (version >= 7) {
                generateAux("redis-ver", ver);
                generateAux("redis-bits", bits);
                generateAux("ctime", String.valueOf(System.currentTimeMillis() / 1000L));
                RESP2.Node memory = retry(client -> {
                    RESP2Client.Command r = client.newCommand();
                    return r.invoke("info", "memory");
                });
                if (memory.type == RESP2.Type.STRING) {
                    String value = memory.getString();
                    String[] lines = value.split("\r\n");
                    for (int i = 1; i < lines.length; i++) {
                        String[] kv = lines[i].split(":");
                        String key = kv[0];
                        if (key.equals("used_memory")) {
                            String val = kv[1];
                            generateAux("used-mem", val);
                        }
                    }
                }
            }
            if (version >= 10) {
                RESP2.Node functions = retry(client -> {
                    RESP2Client.Command r = client.newCommand();
                    return r.invoke("function", "dump");
                });
                if (functions.type == RESP2.Type.ERROR) {
                    throw new IOException(functions.getError());
                } else {
                    ByteArray funcs = functions.getBytes();
                    if (funcs != null) {
                        funcs.writeTo(out, 0, funcs.length() - 10);
                    }
                }
            }
            RESP2.Node keyspace = retry(client -> {
                RESP2Client.Command r = client.newCommand();
                return r.invoke("info", "keyspace");
            });
            String[] line = keyspace.getString().split("\r\n");
            for (int i = 1; i < line.length; i++) {
                String[] ary = line[i].split(":");
                Integer dbnum = Integer.parseInt(ary[0].substring(2));
                ary = ary[1].split(",");
                long dbsize = Long.parseLong(ary[0].split("=")[1]);
                long expires = Long.parseLong(ary[1].split("=")[1]);
                DB db = new DB(dbnum, dbsize, expires);
                generateDB(db, version);
            }
            out.write(RDB_OPCODE_EOF);
            out.write(out.getCRC64());
            out.flush();
        } finally {
            close();
        }
    }
    private void generateAux(String key, String val) throws IOException {
        if (val == null) return;
        BaseRdbEncoder encoder = new BaseRdbEncoder();
        out.write(RDB_OPCODE_AUX);
        encoder.rdbGenericSaveStringObject(new ByteArray(key.getBytes()), out);
        encoder.rdbGenericSaveStringObject(new ByteArray(val.getBytes()), out);
    }
    private void generateDB(DB db, int version) throws IOException {
        BaseRdbEncoder encoder = new BaseRdbEncoder();
        RESP2.Node select = retry(client -> {
            RESP2Client.Command r = client.newCommand();
            return r.invoke("select", String.valueOf(db.getDbNumber()));
        });
        if (select.type == RESP2.Type.ERROR) {
            throw new IOException(select.getError());
        } else {
            this.db = (int) db.getDbNumber();
        }
        out.write(RDB_OPCODE_SELECTDB);
        encoder.rdbSaveLen(db.getDbNumber(), out);
        if (version >= 7) {
            out.write(RDB_OPCODE_RESIZEDB);
            encoder.rdbSaveLen(db.getDbsize(), out);
            encoder.rdbSaveLen(db.getExpires(), out);
        }
        String cursor = "0";
        String step = String.valueOf(configuration.getScanStep());
        do {
            String temp = cursor;
            RESP2.Node scan = retry(client -> {
                RESP2Client.Command r = client.newCommand();
                return r.invoke("scan", temp, "count", step);
            });
            if (scan.type == RESP2.Type.ERROR) {
                throw new IOException(scan.getError());
            }
            RESP2.Node[] ary = scan.getArray();
            cursor = ary[0].getString();
            RESP2Client.Command command = retry(client -> {
                RESP2Client.Command r = client.newCommand();
                RESP2.Node[] nodes = ary[1].getArray();
                for (int i = 0; i < nodes.length; i++) {
                    byte[] key = nodes[i].getBytes().first();
                    if (version >= 10) {
                        PExpireTimeNodeConsumer context = new PExpireTimeNodeConsumer();
                        r.post(context, "pexpiretime".getBytes(), key);
                        r.post(new DumpNodeConsumer(key, out, context), "dump".getBytes(), key);
                    } else {
                        PTTLNodeConsumer context = new PTTLNodeConsumer();
                        r.post(context, "pttl".getBytes(), key);
                        r.post(new DumpNodeConsumer(key, out, context), "dump".getBytes(), key);
                    }
                }
                return r;
            });
            retry(command);
        } while (!cursor.equals("0"));
    }
    private static interface TTLContext {
        Long getTTL();
    }
    private static class PTTLNodeConsumer implements RESP2Client.NodeConsumer, TTLContext {
        private Long ttl;
        @Override
        public Long getTTL() {
            return this.ttl;
        }
        @Override
        public void accept(RESP2.Node node) throws IOException {
            if (node.type == RESP2.Type.ERROR) {
                throw new IOException(node.getError());
            }
            Long ttl = node.getNumber();
            if (ttl >= 0) {
                this.ttl = System.currentTimeMillis() + ttl;
            }
        }
    }
    private static class PExpireTimeNodeConsumer implements RESP2Client.NodeConsumer, TTLContext {
        private Long ttl;
        @Override
        public Long getTTL() {
            return this.ttl;
        }
        @Override
        public void accept(RESP2.Node node) throws IOException {
            if (node.type == RESP2.Type.ERROR) {
                throw new IOException(node.getError());
            }
            Long ttl = node.getNumber();
            if (ttl >= 0) {
                this.ttl = ttl;
            }
        }
    }
    private static class DumpNodeConsumer implements RESP2Client.NodeConsumer {
        private byte[] key;
        private OutputStream out;
        private TTLContext context;
        private BaseRdbEncoder encoder = new BaseRdbEncoder();
        public DumpNodeConsumer(byte[] key, OutputStream out, TTLContext context) {
            this.key = key;
            this.out = out;
            this.context = context;
        }
        @Override
        public void accept(RESP2.Node node) throws IOException {
            if (node.type == RESP2.Type.ERROR) {
                throw new IOException(node.getError());
            }
            if (node.value != null) {
                Long ttl = context.getTTL();
                if (ttl != null) {
                    out.write(RDB_OPCODE_EXPIRETIME_MS);
                    encoder.rdbSaveMillisecondTime(ttl, out);
                }
                ByteArray value = node.getBytes();
                byte type = value.get(0);
                out.write(type);
                encoder.rdbGenericSaveStringObject(new ByteArray(key), out);
                value.writeTo(out, 1, value.length() - 11);
            }
        }
    }
    private RESP2Client recreate(RESP2Client prev, int db, IOException reason) throws IOException {
        IOException exception = reason;
        for (int i = 0; i < configuration.getRetries() || configuration.getRetries() <= 0; i++) {
            try {
                return RESP2Client.valueOf(prev, db, exception, i + 1);
            } catch (IOException e) {
                exception = e;
            }
        }
        throw exception;
    }
    private <T> T retry(RESP2Client.Function<RESP2Client, T> function) throws IOException {
        IOException exception = null;
        for (int i = 0; i < configuration.getRetries() || configuration.getRetries() <= 0; i++) {
            try {
                return function.apply(client);
            } catch (EOFException e) {
                throw e;
            } catch (IOException e) {
                exception = e;
                this.client = recreate(this.client, this.db, e);
            }
        }
        throw exception;
    }
    private void retry(RESP2Client.Command prev) throws IOException {
        IOException exception = null;
        for (int i = 0; i < configuration.getRetries() || configuration.getRetries() <= 0; i++) {
            try {
                prev.get();
                return;
            } catch (EOFException e) {
                throw e;
            } catch (IOException e) {
                exception = e;
                this.client = recreate(this.client, this.db, e);
                Queue<Tuple2<RESP2Client.NodeConsumer, byte[][]>> commands = prev.getCommands();
                RESP2Client.Command next = retry(client -> {
                    RESP2Client.Command r = client.newCommand();
                    while (!commands.isEmpty()) {
                        Tuple2<RESP2Client.NodeConsumer, byte[][]> tuple = commands.poll();
                        r.post(tuple.getV1(), tuple.getV2());
                    }
                    return r;
                });
                prev = next;
            }
        }
        throw exception;
    }
    private void close() {
        if (client != null) {
            try {
                client.close();
            } catch (IOException e) {
            }
        }
    }
}
package com.moilioncircle.redis.replicator.rdb;
import static com.moilioncircle.redis.replicator.Constants.RDB_14BITLEN;
import static com.moilioncircle.redis.replicator.Constants.RDB_32BITLEN;
import static com.moilioncircle.redis.replicator.Constants.RDB_64BITLEN;
import static com.moilioncircle.redis.replicator.Constants.RDB_6BITLEN;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENCVAL;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENC_LZF;
import static java.lang.Double.doubleToLongBits;
import static java.lang.Float.floatToIntBits;
import static java.nio.ByteOrder.BIG_ENDIAN;
import static java.nio.ByteOrder.LITTLE_ENDIAN;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import com.moilioncircle.redis.replicator.util.ByteArray;
import com.moilioncircle.redis.replicator.util.Lzf;
public class BaseRdbEncoder {
    public void rdbSaveTime(int time, OutputStream out) throws IOException {
        out.write(ByteBuffer.allocate(Integer.BYTES).order(LITTLE_ENDIAN).putInt(time).array());
    }
    public void rdbSaveMillisecondTime(long timestamp, OutputStream out) throws IOException {
        out.write(ByteBuffer.allocate(Long.BYTES).order(LITTLE_ENDIAN).putLong(timestamp).array());
    }
    public int rdbSaveLen(long len, OutputStream out) throws IOException {
        byte[] ary = toUnsigned(len);
        BigInteger value = new BigInteger(1, ary);
        if (value.compareTo(BigInteger.valueOf(0XFFFFFFFFL)) > 0) {
            out.write(RDB_64BITLEN);
            out.write(ByteBuffer.allocate(Long.BYTES).order(BIG_ENDIAN).put(ary).array());
            return 9;
        } else if (len < (1 << 6)) {
            out.write((byte) ((len & 0xFF) | (RDB_6BITLEN << 6)));
            return 1;
        } else if (len < (1 << 14)) {
            out.write((byte) (((len >> 8) & 0xFF) | (RDB_14BITLEN << 6)));
            out.write((byte) (len & 0xFF));
            return 2;
        } else if (len <= 0XFFFFFFFFL) {
            out.write(RDB_32BITLEN);
            out.write(ByteBuffer.allocate(Integer.BYTES).order(BIG_ENDIAN).putInt((int) len).array());
            return 5;
        } else {
            out.write(RDB_64BITLEN);
            out.write(ByteBuffer.allocate(Long.BYTES).order(BIG_ENDIAN).putLong(len).array());
            return 9;
        }
    }
    public byte[] rdbSaveLen(long len) throws IOException {
        byte[] ary = toUnsigned(len);
        BigInteger value = new BigInteger(1, ary);
        if (value.compareTo(BigInteger.valueOf(0XFFFFFFFFL)) > 0) {
            return ByteBuffer.allocate(9).order(BIG_ENDIAN).put((byte) RDB_64BITLEN).put(ary).array();
        } else if (len < (1 << 6)) {
            return new byte[]{(byte) ((len & 0xFF) | (RDB_6BITLEN << 6))};
        } else if (len < (1 << 14)) {
            return new byte[]{(byte) (((len >> 8) & 0xFF) | (RDB_14BITLEN << 6)), (byte) (len & 0xFF)};
        } else if (len <= 0XFFFFFFFFL) {
            return ByteBuffer.allocate(5).order(BIG_ENDIAN).put((byte) RDB_32BITLEN).putInt((int) len).array();
        } else {
            return ByteBuffer.allocate(9).order(BIG_ENDIAN).put((byte) RDB_64BITLEN).putLong(len).array();
        }
    }
    public void rdbSaveDoubleValue(double value, OutputStream out) throws IOException {
        if (value == Double.NEGATIVE_INFINITY) {
            out.write(255);
        } else if (value == Double.POSITIVE_INFINITY) {
            out.write(254);
        } else if (Double.isNaN(value)) {
            out.write(253);
        } else {
            String str = null;
            if (value == (double) (long) value) {
                str = Long.toString((long) value, 10);
            } else {
                str = String.format("%.17f", value);
            }
            out.write(str.length());
            out.write(str.getBytes());
        }
    }
    public void rdbSaveBinaryFloatValue(float value, OutputStream out) throws IOException {
        out.write(ByteBuffer.allocate(Long.BYTES).order(LITTLE_ENDIAN).putLong(floatToIntBits(value)).array());
    }
    public void rdbSaveBinaryDoubleValue(double value, OutputStream out) throws IOException {
        out.write(ByteBuffer.allocate(Long.BYTES).order(LITTLE_ENDIAN).putLong(doubleToLongBits(value)).array());
    }
    public void rdbSaveEncodedStringObject(ByteArray bytes, OutputStream out) throws IOException {
        ByteArray compressed = new ByteArray(bytes.length() - 3);
        long length = Lzf.encode(bytes, bytes.length(), compressed, 0);
        if (length <= 0) {
            rdbSavePlainStringObject(bytes, out);
        } else {
            int type = (RDB_ENCVAL << 6) | RDB_ENC_LZF;
            out.write(type);
            rdbSaveLen(length, out);
            rdbSaveLen(bytes.length(), out);
            out.write(compressed.first(), 0, (int) length);
        }
    }
    public void rdbGenericSaveStringObject(ByteArray bytes, OutputStream out) throws IOException {
        if (bytes.length() > 20) {
            rdbSaveEncodedStringObject(bytes, out);
        } else {
            rdbSavePlainStringObject(bytes, out);
        }
    }
    public void rdbSavePlainStringObject(ByteArray bytes, OutputStream out) throws IOException {
        rdbSaveLen(bytes.length(), out);
        out.write(bytes.first());
    }
    private byte[] toUnsigned(long value) {
        byte[] ary = new byte[8];
        for (int i = 0; i < 8; i++) {
            ary[7 - i] = (byte) ((value >>> (i << 3)) & 0xFF);
        }
        return ary;
    }
}
package com.moilioncircle.redis.replicator.rdb.datatype;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.BatchedKeyStringValueHash;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.BatchedKeyStringValueList;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.BatchedKeyStringValueModule;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.BatchedKeyStringValueSet;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.BatchedKeyStringValueStream;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.BatchedKeyStringValueString;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.BatchedKeyStringValueZSet;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.BatchedKeyValuePair;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.KeyStringValueByteArrayIterator;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.KeyStringValueMapEntryIterator;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.KeyStringValueZSetEntryIterator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class KeyValuePairs {
    public static KeyValuePair<byte[], byte[]> string(KeyValuePair<byte[], ?> raw, byte[] value) {
        KeyStringValueString kv = new KeyStringValueString();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static KeyValuePair<byte[], Module> module(KeyValuePair<byte[], ?> raw, Module value) {
        KeyStringValueModule kv = new KeyStringValueModule();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static KeyValuePair<byte[], Map<byte[], byte[]>> hash(KeyValuePair<byte[], ?> raw, Map<byte[], byte[]> value) {
        KeyStringValueHash kv = new KeyStringValueHash();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static KeyValuePair<byte[], List<byte[]>> list(KeyValuePair<byte[], ?> raw, List<byte[]> value) {
        KeyStringValueList kv = new KeyStringValueList();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static KeyValuePair<byte[], Set<byte[]>> set(KeyValuePair<byte[], ?> raw, Set<byte[]> value) {
        KeyStringValueSet kv = new KeyStringValueSet();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static KeyValuePair<byte[], Set<ZSetEntry>> zset(KeyValuePair<byte[], ?> raw, Set<ZSetEntry> value) {
        KeyStringValueZSet kv = new KeyStringValueZSet();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static KeyValuePair<byte[], Stream> stream(KeyValuePair<byte[], ?> raw, Stream value) {
        KeyStringValueStream kv = new KeyStringValueStream();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static KeyStringValueMapEntryIterator iterHash(KeyValuePair<byte[], ?> raw, Iterator<Map.Entry<byte[], byte[]>> value) {
        KeyStringValueMapEntryIterator kv = new KeyStringValueMapEntryIterator();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static KeyStringValueByteArrayIterator iterList(KeyValuePair<byte[], ?> raw, Iterator<byte[]> value) {
        KeyStringValueByteArrayIterator kv = new KeyStringValueByteArrayIterator();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static KeyStringValueByteArrayIterator iterSet(KeyValuePair<byte[], ?> raw, Iterator<byte[]> value) {
        KeyStringValueByteArrayIterator kv = new KeyStringValueByteArrayIterator();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static KeyStringValueZSetEntryIterator iterZset(KeyValuePair<byte[], ?> raw, Iterator<ZSetEntry> value) {
        KeyStringValueZSetEntryIterator kv = new KeyStringValueZSetEntryIterator();
        copy(raw, kv);
        kv.setValue(value);
        return kv;
    }
    public static BatchedKeyStringValueString string(KeyValuePair<byte[], ?> raw, byte[] value, int batch, boolean last) {
        BatchedKeyStringValueString kv = new BatchedKeyStringValueString();
        copy(raw, kv, batch, last);
        kv.setValue(value);
        return kv;
    }
    public static BatchedKeyStringValueModule module(KeyValuePair<byte[], ?> raw, Module value, int batch, boolean last) {
        BatchedKeyStringValueModule kv = new BatchedKeyStringValueModule();
        copy(raw, kv, batch, last);
        kv.setValue(value);
        return kv;
    }
    public static BatchedKeyStringValueHash hash(KeyValuePair<byte[], ?> raw, Map<byte[], byte[]> value, int batch, boolean last) {
        BatchedKeyStringValueHash kv = new BatchedKeyStringValueHash();
        copy(raw, kv, batch, last);
        kv.setValue(value);
        return kv;
    }
    public static BatchedKeyStringValueList list(KeyValuePair<byte[], ?> raw, List<byte[]> value, int batch, boolean last) {
        BatchedKeyStringValueList kv = new BatchedKeyStringValueList();
        copy(raw, kv, batch, last);
        kv.setValue(value);
        return kv;
    }
    public static BatchedKeyStringValueSet set(KeyValuePair<byte[], ?> raw, Set<byte[]> value, int batch, boolean last) {
        BatchedKeyStringValueSet kv = new BatchedKeyStringValueSet();
        copy(raw, kv, batch, last);
        kv.setValue(value);
        return kv;
    }
    public static BatchedKeyStringValueZSet zset(KeyValuePair<byte[], ?> raw, Set<ZSetEntry> value, int batch, boolean last) {
        BatchedKeyStringValueZSet kv = new BatchedKeyStringValueZSet();
        copy(raw, kv, batch, last);
        kv.setValue(value);
        return kv;
    }
    public static BatchedKeyStringValueStream stream(KeyValuePair<byte[], ?> raw, Stream value, int batch, boolean last) {
        BatchedKeyStringValueStream kv = new BatchedKeyStringValueStream();
        copy(raw, kv, batch, last);
        kv.setValue(value);
        return kv;
    }
    private static void copy(KeyValuePair<byte[], ?> source, KeyValuePair<byte[], ?> target) {
        target.setContext(source.getContext());
        target.setDb(source.getDb());
        target.setExpiredType(source.getExpiredType());
        target.setExpiredValue(source.getExpiredValue());
        target.setEvictType(source.getEvictType());
        target.setEvictValue(source.getEvictValue());
        target.setValueRdbType(source.getValueRdbType());
        target.setKey(source.getKey());
    }
    private static void copy(KeyValuePair<byte[], ?> source, BatchedKeyValuePair<byte[], ?> target, int batch, boolean last) {
        target.setContext(source.getContext());
        target.setDb(source.getDb());
        target.setExpiredType(source.getExpiredType());
        target.setExpiredValue(source.getExpiredValue());
        target.setEvictType(source.getEvictType());
        target.setEvictValue(source.getEvictValue());
        target.setValueRdbType(source.getValueRdbType());
        target.setKey(source.getKey());
        target.setBatch(batch);
        target.setLast(last);
    }
}
package com.moilioncircle.redis.replicator.rdb.datatype;
import com.moilioncircle.redis.replicator.util.Strings;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Objects;
public class ZSetEntry implements Serializable {
    private static final long serialVersionUID = 1L;
    private byte[] element;
    private double score;
    public ZSetEntry() {
    }
    public ZSetEntry(byte[] element, double score) {
        this.element = element;
        this.score = score;
    }
    public byte[] getElement() {
        return element;
    }
    public double getScore() {
        return score;
    }
    public void setElement(byte[] element) {
        this.element = element;
    }
    public void setScore(double score) {
        this.score = score;
    }
    @Override
    public String toString() {
        return "[" + Strings.toString(element) + ", " + score + "]";
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ZSetEntry zSetEntry = (ZSetEntry) o;
        return Double.compare(zSetEntry.score, score) == 0 &&
                Arrays.equals(element, zSetEntry.element);
    }
    @Override
    public int hashCode() {
        int result = Objects.hash(score);
        result = 31 * result + Arrays.hashCode(element);
        return result;
    }
}
package com.moilioncircle.redis.replicator.rdb.datatype;
import java.io.Serializable;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Objects;
import com.moilioncircle.redis.replicator.util.Strings;
public class Stream implements Serializable {
    private static final long serialVersionUID = 1L;
    private ID lastId;
    private ID firstId;
    private ID maxDeletedEntryId;
    private Long entriesAdded;
    private NavigableMap<ID, Entry> entries;
    private long length;
    private List<Group> groups;
    public Stream() {
    }
    public Stream(ID lastId, NavigableMap<ID, Entry> entries, long length, List<Group> groups) {
        this.lastId = lastId;
        this.entries = entries;
        this.length = length;
        this.groups = groups;
    }
    public Stream(ID lastId, NavigableMap<ID, Entry> entries, long length, List<Group> groups, ID firstId, ID maxDeletedEntryId, Long entriesAdded) {
        this(lastId, entries, length, groups);
        this.firstId = firstId;
        this.maxDeletedEntryId = maxDeletedEntryId;
        this.entriesAdded = entriesAdded;
    }
    public ID getLastId() {
        return lastId;
    }
    public void setLastId(ID lastId) {
        this.lastId = lastId;
    }
    public ID getFirstId() {
        return firstId;
    }
    public void setFirstId(ID firstId) {
        this.firstId = firstId;
    }
    public ID getMaxDeletedEntryId() {
        return maxDeletedEntryId;
    }
    public void setMaxDeletedEntryId(ID maxDeletedEntryId) {
        this.maxDeletedEntryId = maxDeletedEntryId;
    }
    public Long getEntriesAdded() {
        return entriesAdded;
    }
    public void setEntriesAdded(Long entriesAdded) {
        this.entriesAdded = entriesAdded;
    }
    public NavigableMap<ID, Entry> getEntries() {
        return entries;
    }
    public void setEntries(NavigableMap<ID, Entry> entries) {
        this.entries = entries;
    }
    public long getLength() {
        return length;
    }
    public void setLength(long length) {
        this.length = length;
    }
    public List<Group> getGroups() {
        return groups;
    }
    public void setGroups(List<Group> groups) {
        this.groups = groups;
    }
    @Override
    public String toString() {
        String r = "Stream{" + "lastId=" + lastId + ", length=" + length;
        r += ", firstId=" + firstId + ", maxDeletedEntryId=" + maxDeletedEntryId + ", entriesAdded=" + entriesAdded;
        if (groups != null && !groups.isEmpty()) r += ", groups=" + groups;
        if (entries != null && !entries.isEmpty()) r += ", entries=" + entries.size();
        return r + '}';
    }
    public static class Entry implements Serializable {
        private static final long serialVersionUID = 1L;
        private ID id;
        private boolean deleted;
        private Map<byte[], byte[]> fields;
        public Entry() {
        }
        public Entry(ID id, boolean deleted, Map<byte[], byte[]> fields) {
            this.id = id;
            this.deleted = deleted;
            this.fields = fields;
        }
        public ID getId() {
            return id;
        }
        public void setId(ID id) {
            this.id = id;
        }
        public boolean isDeleted() {
            return deleted;
        }
        public void setDeleted(boolean deleted) {
            this.deleted = deleted;
        }
        public Map<byte[], byte[]> getFields() {
            return fields;
        }
        public void setFields(Map<byte[], byte[]> fields) {
            this.fields = fields;
        }
        @Override
        public String toString() {
            return "Entry{" +
                    "id=" + id +
                    ", deleted=" + deleted +
                    ", fields=" + fields +
                    '}';
        }
    }
    public static class Group implements Serializable {
        private static final long serialVersionUID = 1L;
        private byte[] name;
        private ID lastId;
        private Long entriesRead;
        private NavigableMap<ID, Nack> pendingEntries;
        private List<Consumer> consumers;
        public Group() {
        }
        public Group(byte[] name, ID lastId, NavigableMap<ID, Nack> pendingEntries, List<Consumer> consumers) {
            this.name = name;
            this.lastId = lastId;
            this.pendingEntries = pendingEntries;
            this.consumers = consumers;
        }
        public Group(byte[] name, ID lastId, NavigableMap<ID, Nack> pendingEntries, List<Consumer> consumers, Long entriesRead) {
            this(name, lastId, pendingEntries, consumers);
            this.entriesRead = entriesRead;
        }
        public byte[] getName() {
            return name;
        }
        public void setName(byte[] name) {
            this.name = name;
        }
        public ID getLastId() {
            return lastId;
        }
        public void setLastId(ID lastId) {
            this.lastId = lastId;
        }
        public Long getEntriesRead() {
            return entriesRead;
        }
        public void setEntriesRead(Long entriesRead) {
            this.entriesRead = entriesRead;
        }
        public NavigableMap<ID, Nack> getPendingEntries() {
            return pendingEntries;
        }
        public void setPendingEntries(NavigableMap<ID, Nack> pendingEntries) {
            this.pendingEntries = pendingEntries;
        }
        public List<Consumer> getConsumers() {
            return consumers;
        }
        public void setConsumers(List<Consumer> consumers) {
            this.consumers = consumers;
        }
        @Override
        public String toString() {
            String r = "Group{" + "name='" + Strings.toString(name) + '\'' + ", lastId=" + lastId + ", entriesRead=" + entriesRead;
            if (consumers != null && !consumers.isEmpty()) r += ", consumers=" + consumers;
            if (pendingEntries != null && !pendingEntries.isEmpty()) r += ", gpel=" + pendingEntries.size();
            return r + '}';
        }
    }
    public static class Consumer implements Serializable {
        private static final long serialVersionUID = 1L;
        private byte[] name;
        private long seenTime;
        private long activeTime = -1; 
        private NavigableMap<ID, Nack> pendingEntries;
        public Consumer() {
        }
        public Consumer(byte[] name, long seenTime, NavigableMap<ID, Nack> pendingEntries) {
            this.name = name;
            this.seenTime = seenTime;
            this.pendingEntries = pendingEntries;
        }
        public byte[] getName() {
            return name;
        }
        public void setName(byte[] name) {
            this.name = name;
        }
        public long getSeenTime() {
            return seenTime;
        }
        public void setSeenTime(long seenTime) {
            this.seenTime = seenTime;
        }
        public long getActiveTime() {
            return activeTime;
        }
        public void setActiveTime(long activeTime) {
            this.activeTime = activeTime;
        }
        public NavigableMap<ID, Nack> getPendingEntries() {
            return pendingEntries;
        }
        public void setPendingEntries(NavigableMap<ID, Nack> pendingEntries) {
            this.pendingEntries = pendingEntries;
        }
        @Override
        public String toString() {
            String r = "Consumer{" + "name='" + Strings.toString(name) + '\'' + ", seenTime=" + seenTime + ", activeTime=" + activeTime;
            if (pendingEntries != null && !pendingEntries.isEmpty()) r += ", cpel=" + pendingEntries.size();
            return r + '}';
        }
    }
    public static class Nack implements Serializable {
        private static final long serialVersionUID = 1L;
        private ID id;
        private Consumer consumer;
        private long deliveryTime;
        private long deliveryCount;
        public Nack() {
        }
        public Nack(ID id, Consumer consumer, long deliveryTime, long deliveryCount) {
            this.id = id;
            this.consumer = consumer;
            this.deliveryTime = deliveryTime;
            this.deliveryCount = deliveryCount;
        }
        public ID getId() {
            return id;
        }
        public void setId(ID id) {
            this.id = id;
        }
        public Consumer getConsumer() {
            return consumer;
        }
        public void setConsumer(Consumer consumer) {
            this.consumer = consumer;
        }
        public long getDeliveryTime() {
            return deliveryTime;
        }
        public void setDeliveryTime(long deliveryTime) {
            this.deliveryTime = deliveryTime;
        }
        public long getDeliveryCount() {
            return deliveryCount;
        }
        public void setDeliveryCount(long deliveryCount) {
            this.deliveryCount = deliveryCount;
        }
        @Override
        public String toString() {
            return "Nack{" +
                    "id=" + id +
                    ", consumer=" + consumer +
                    ", deliveryTime=" + deliveryTime +
                    ", deliveryCount=" + deliveryCount +
                    '}';
        }
    }
    public static class ID implements Serializable, Comparable<ID> {
        private static final long serialVersionUID = 1L;
        public static Comparator<ID> COMPARATOR = comparator();
        private long ms;
        private long seq;
        public ID() {
        }
        public ID(long ms, long seq) {
            this.ms = ms;
            this.seq = seq;
        }
        public long getMs() {
            return ms;
        }
        public void setMs(long ms) {
            this.ms = ms;
        }
        public long getSeq() {
            return seq;
        }
        public void setSeq(long seq) {
            this.seq = seq;
        }
        public ID delta(long ms, long seq) {
            return new ID(this.ms + ms, this.seq + seq);
        }
        @Override
        public String toString() {
            return ms + "-" + seq;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            ID id = (ID) o;
            return ms == id.ms && seq == id.seq;
        }
        @Override
        public int hashCode() {
            return Objects.hash(ms, seq);
        }
        @Override
        public int compareTo(ID that) {
            int r = Long.compare(this.ms, that.ms);
            if (r == 0) return Long.compare(this.seq, that.seq);
            return r;
        }
        public static ID valueOf(String id) {
            int idx = id.indexOf('-');
            long ms = Long.parseLong(id.substring(0, idx));
            long seq = Long.parseLong(id.substring(idx + 1, id.length()));
            return new ID(ms, seq);
        }
        public static ID valueOf(String strMs, String strSeq) {
            long ms = Long.parseLong(strMs);
            long seq = Long.parseLong(strSeq);
            return new ID(ms, seq);
        }
        public static Comparator<ID> comparator() {
            return new Comparator<ID>() {
                @Override
                public int compare(ID o1, ID o2) {
                    return o1.compareTo(o2);
                }
            };
        }
    }
}
package com.moilioncircle.redis.replicator.rdb.datatype;
import com.moilioncircle.redis.replicator.event.AbstractEvent;
public class AuxField extends AbstractEvent {
    private static final long serialVersionUID = 1L;
    private String auxKey;
    private String auxValue;
    public AuxField() {
    }
    public AuxField(String auxKey, String auxValue) {
        this.auxKey = auxKey;
        this.auxValue = auxValue;
    }
    public String getAuxKey() {
        return auxKey;
    }
    public String getAuxValue() {
        return auxValue;
    }
    public void setAuxKey(String auxKey) {
        this.auxKey = auxKey;
    }
    public void setAuxValue(String auxValue) {
        this.auxValue = auxValue;
    }
    @Override
    public String toString() {
        return "AuxField{" +
                "auxKey='" + auxKey + '\'' +
                ", auxValue='" + auxValue + '\'' +
                '}';
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AuxField auxField = (AuxField) o;
        return auxKey.equals(auxField.auxKey);
    }
    @Override
    public int hashCode() {
        return auxKey.hashCode();
    }
}
package com.moilioncircle.redis.replicator.rdb.datatype;
import com.moilioncircle.redis.replicator.event.AbstractEvent;
public class KeyValuePair<K, V> extends AbstractEvent {
    private static final long serialVersionUID = 1L;
    protected DB db;
    protected int valueRdbType;
    protected ExpiredType expiredType = ExpiredType.NONE;
    protected Long expiredValue;
    protected EvictType evictType = EvictType.NONE;
    protected Long evictValue;
    protected K key;
    protected V value;
    public int getValueRdbType() {
        return valueRdbType;
    }
    public void setValueRdbType(int valueRdbType) {
        this.valueRdbType = valueRdbType;
    }
    public ExpiredType getExpiredType() {
        return expiredType;
    }
    public void setExpiredType(ExpiredType expiredType) {
        this.expiredType = expiredType;
    }
    public Long getExpiredValue() {
        return expiredValue;
    }
    public void setExpiredValue(Long expiredValue) {
        this.expiredValue = expiredValue;
    }
    public EvictType getEvictType() {
        return evictType;
    }
    public void setEvictType(EvictType evictType) {
        this.evictType = evictType;
    }
    public Long getEvictValue() {
        return evictValue;
    }
    public void setEvictValue(Long evictValue) {
        this.evictValue = evictValue;
    }
    public K getKey() {
        return key;
    }
    public void setKey(K key) {
        this.key = key;
    }
    public V getValue() {
        return value;
    }
    public void setValue(V value) {
        this.value = value;
    }
    public DB getDb() {
        return db;
    }
    public void setDb(DB db) {
        this.db = db;
    }
    public Integer getExpiredSeconds() {
        return expiredValue == null ? null : expiredValue.intValue();
    }
    public Long getExpiredMs() {
        return expiredValue;
    }
}
package com.moilioncircle.redis.replicator.rdb.datatype;
import com.moilioncircle.redis.replicator.event.AbstractEvent;
public class Function extends AbstractEvent {
    private static final long serialVersionUID = 1L;
    @Deprecated
    private byte[] name;
    @Deprecated
    private byte[] engineName;
    @Deprecated
    private byte[] description;
    private byte[] code;
    @Deprecated
    public byte[] getName() {
        return name;
    }
    @Deprecated
    public void setName(byte[] name) {
        this.name = name;
    }
    @Deprecated
    public byte[] getEngineName() {
        return engineName;
    }
    @Deprecated
    public void setEngineName(byte[] engineName) {
        this.engineName = engineName;
    }
    @Deprecated
    public byte[] getDescription() {
        return description;
    }
    @Deprecated
    public void setDescription(byte[] description) {
        this.description = description;
    }
    public byte[] getCode() {
        return code;
    }
    public void setCode(byte[] code) {
        this.code = code;
    }
}
package com.moilioncircle.redis.replicator.util;
import com.moilioncircle.redis.replicator.util.type.Tuple2;
import com.moilioncircle.redis.replicator.util.type.Tuple3;
import com.moilioncircle.redis.replicator.util.type.Tuple4;
import com.moilioncircle.redis.replicator.util.type.Tuple5;
public class Tuples {
    public static <T1, T2> Tuple2<T1, T2> of(T1 t1, T2 t2) {
        return new Tuple2<>(t1, t2);
    }
    public static <T1, T2, T3> Tuple3<T1, T2, T3> of(T1 t1, T2 t2, T3 t3) {
        return new Tuple3<>(t1, t2, t3);
    }
    public static <T1, T2, T3, T4> Tuple4<T1, T2, T3, T4> of(T1 t1, T2 t2, T3 t3, T4 t4) {
        return new Tuple4<>(t1, t2, t3, t4);
    }
    public static <T1, T2, T3, T4, T5> Tuple5<T1, T2, T3, T4, T5> of(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) {
        return new Tuple5<>(t1, t2, t3, t4, t5);
    }
}
package com.moilioncircle.redis.replicator.util;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.AbstractExecutorService;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import com.moilioncircle.redis.replicator.Configuration;
public class XScheduledExecutorService extends AbstractExecutorService implements ScheduledExecutorService {
    private final Configuration configuration;
    private final ScheduledExecutorService executor;
    public XScheduledExecutorService(Configuration configuration) {
        this.configuration = configuration;
        ScheduledExecutorService executor = configuration.getScheduledExecutor();
        if (executor != null) {
            this.executor = executor;
        } else {
            this.executor = Executors.newSingleThreadScheduledExecutor();
        }
    }
    public long terminate(long timeout, TimeUnit unit) throws InterruptedException {
        ScheduledExecutorService executor = configuration.getScheduledExecutor();
        if (executor != null) {
            return 0L;
        } else {
            return Concurrents.terminate(this.executor, timeout, unit);
        }
    }
    public long terminateQuietly(long timeout, TimeUnit unit) {
        ScheduledExecutorService executor = configuration.getScheduledExecutor();
        if (executor != null) {
            return 0L;
        } else {
            return Concurrents.terminateQuietly(this.executor, timeout, unit);
        }
    }
    @Override
    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        return executor.schedule(command, delay, unit);
    }
    @Override
    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
        return executor.schedule(callable, delay, unit);
    }
    @Override
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        return executor.scheduleAtFixedRate(command, initialDelay, period, unit);
    }
    @Override
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        return executor.scheduleWithFixedDelay(command, initialDelay, delay, unit);
    }
    @Override
    public void shutdown() {
        executor.shutdown();
    }
    @Override
    public boolean isShutdown() {
        return executor.isShutdown();
    }
    @Override
    public boolean isTerminated() {
        return executor.isTerminated();
    }
    @Override
    public List<Runnable> shutdownNow() {
        return executor.shutdownNow();
    }
    @Override
    public void execute(Runnable command) {
        executor.execute(command);
    }
    @Override
    public Future<?> submit(Runnable task) {
        return executor.submit(task);
    }
    @Override
    public <T> Future<T> submit(Callable<T> task) {
        return executor.submit(task);
    }
    @Override
    public <T> Future<T> submit(Runnable task, T result) {
        return executor.submit(task, result);
    }
    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return executor.awaitTermination(timeout, unit);
    }
    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return executor.invokeAll(tasks);
    }
    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return executor.invokeAny(tasks);
    }
    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
        return executor.invokeAll(tasks, timeout, unit);
    }
    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        return executor.invokeAny(tasks, timeout, unit);
    }
}
package com.moilioncircle.redis.replicator;
import com.moilioncircle.redis.replicator.event.EventListener;
import com.moilioncircle.redis.replicator.io.RawByteListener;
public interface ReplicatorListener {
    boolean addEventListener(EventListener listener);
    boolean removeEventListener(EventListener listener);
    boolean addRawByteListener(RawByteListener listener);
    boolean removeRawByteListener(RawByteListener listener);
    boolean addCloseListener(CloseListener listener);
    boolean removeCloseListener(CloseListener listener);
    boolean addExceptionListener(ExceptionListener listener);
    boolean removeExceptionListener(ExceptionListener listener);
    boolean addStatusListener(StatusListener listener);
    boolean removeStatusListener(StatusListener listener);
}
package com.moilioncircle.redis.replicator;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import com.moilioncircle.redis.replicator.event.Event;
import com.moilioncircle.redis.replicator.event.EventListener;
import com.moilioncircle.redis.replicator.io.RawByteListener;
public class AbstractReplicatorListener implements ReplicatorListener {
    protected final List<CloseListener> closeListeners = new CopyOnWriteArrayList<>();
    protected final List<EventListener> eventListeners = new CopyOnWriteArrayList<>();
    protected final List<StatusListener> statusListeners = new CopyOnWriteArrayList<>();
    protected final List<RawByteListener> rawByteListeners = new CopyOnWriteArrayList<>();
    protected final List<ExceptionListener> exceptionListeners = new CopyOnWriteArrayList<>();
    @Override
    public boolean addEventListener(EventListener listener) {
        return eventListeners.add(listener);
    }
    @Override
    public boolean removeEventListener(EventListener listener) {
        return eventListeners.remove(listener);
    }
    @Override
    public boolean addRawByteListener(RawByteListener listener) {
        return this.rawByteListeners.add(listener);
    }
    @Override
    public boolean removeRawByteListener(RawByteListener listener) {
        return this.rawByteListeners.remove(listener);
    }
    @Override
    public boolean addCloseListener(CloseListener listener) {
        return closeListeners.add(listener);
    }
    @Override
    public boolean removeCloseListener(CloseListener listener) {
        return closeListeners.remove(listener);
    }
    @Override
    public boolean addExceptionListener(ExceptionListener listener) {
        return exceptionListeners.add(listener);
    }
    @Override
    public boolean removeExceptionListener(ExceptionListener listener) {
        return exceptionListeners.remove(listener);
    }
    @Override
    public boolean addStatusListener(StatusListener listener) {
        return statusListeners.add(listener);
    }
    @Override
    public boolean removeStatusListener(StatusListener listener) {
        return statusListeners.remove(listener);
    }
    protected void doEventListener(Replicator replicator, Event event) {
        if (eventListeners.isEmpty()) return;
        for (EventListener listener : eventListeners) {
            listener.onEvent(replicator, event);
        }
    }
    protected void doCloseListener(Replicator replicator) {
        if (closeListeners.isEmpty()) return;
        for (CloseListener listener : closeListeners) {
            listener.handle(replicator);
        }
    }
    protected void doExceptionListener(Replicator replicator, Throwable throwable, Event event) {
        if (exceptionListeners.isEmpty()) return;
        for (ExceptionListener listener : exceptionListeners) {
            listener.handle(replicator, throwable, event);
        }
    }
    protected void doStatusListener(Replicator replicator, Status status) {
        if (statusListeners.isEmpty()) return;
        for (StatusListener listener : statusListeners) {
            listener.handle(replicator, status);
        }
    }
}
package com.moilioncircle.redis.replicator;
import static com.moilioncircle.redis.replicator.Status.CONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTING;
import static com.moilioncircle.redis.replicator.util.Strings.format;
import static com.moilioncircle.redis.replicator.util.Tuples.of;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Objects;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.moilioncircle.redis.replicator.cmd.Command;
import com.moilioncircle.redis.replicator.cmd.CommandName;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.RedisCodec;
import com.moilioncircle.redis.replicator.cmd.ReplyParser;
import com.moilioncircle.redis.replicator.cmd.TimestampEvent;
import com.moilioncircle.redis.replicator.event.PostCommandSyncEvent;
import com.moilioncircle.redis.replicator.event.PreCommandSyncEvent;
import com.moilioncircle.redis.replicator.io.PeekableInputStream;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.RdbParser;
import com.moilioncircle.redis.replicator.util.Strings;
public class RedisMixReplicator extends AbstractReplicator {
    protected static final Logger logger = LoggerFactory.getLogger(RedisMixReplicator.class);
    protected final ReplyParser replyParser;
    protected final PeekableInputStream peekable;
    public RedisMixReplicator(File file, Configuration configuration) throws FileNotFoundException {
        this(new FileInputStream(file), configuration);
    }
    public RedisMixReplicator(InputStream in, Configuration configuration) {
        Objects.requireNonNull(in);
        Objects.requireNonNull(configuration);
        this.configuration = configuration;
        if (in instanceof PeekableInputStream) {
            this.peekable = (PeekableInputStream) in;
        } else {
            in = this.peekable = new PeekableInputStream(in);
        }
        this.inputStream = new RedisInputStream(in, this.configuration.getBufferSize());
        this.inputStream.setRawByteListeners(this.rawByteListeners);
        this.replyParser = new ReplyParser(inputStream, new RedisCodec());
        builtInCommandParserRegister();
        if (configuration.isUseDefaultExceptionListener())
            addExceptionListener(new DefaultExceptionListener());
    }
    @Override
    protected void doOpen() throws IOException {
        configuration.setReplOffset(0L);
        if (peekable.peek() == 'R') {
            RdbParser parser = new RdbParser(inputStream, this);
            configuration.setReplOffset(parser.parse());
        }
        if (getStatus() != CONNECTED) return;
        submitEvent(new PreCommandSyncEvent());
        try {
            final long[] offset = new long[1];
            while (getStatus() == CONNECTED) {
                Object obj = replyParser.parse(len -> offset[0] = len);
                if (obj instanceof Object[]) {
                    if (verbose() && logger.isDebugEnabled())
                        logger.debug(format((Object[]) obj));
                    Object[] raw = (Object[]) obj;
                    CommandName name = CommandName.name(Strings.toString(raw[0]));
                    final CommandParser<? extends Command> parser;
                    if ((parser = commands.get(name)) == null) {
                        logger.warn("command [{}] not register. raw command:{}", name, format(raw));
                        configuration.addOffset(offset[0]);
                        offset[0] = 0L;
                        continue;
                    }
                    final long st = configuration.getReplOffset();
                    final long ed = st + offset[0];
                    submitEvent(parser.parse(raw), of(st, ed));
                } else if (obj instanceof TimestampEvent){
                    final long st = configuration.getReplOffset();
                    final long ed = st + offset[0];
                    submitEvent((TimestampEvent)obj, of(st, ed));
                } else {
                    logger.warn("unexpected redis reply:{}", obj);
                }
                configuration.addOffset(offset[0]);
                offset[0] = 0L;
            }
        } catch (EOFException ignore) {
            submitEvent(new PostCommandSyncEvent());
        }
    }
    @Override
    protected void doClose() throws IOException {
        compareAndSet(CONNECTED, DISCONNECTING);
        try {
            if (inputStream != null) {
                this.inputStream.setRawByteListeners(null);
                inputStream.close();
            }
        } catch (IOException ignore) {
        } finally {
            setStatus(DISCONNECTED);
        }
    }
}
package com.moilioncircle.redis.replicator;
import static com.moilioncircle.redis.replicator.Constants.DOLLAR;
import static com.moilioncircle.redis.replicator.Constants.STAR;
import static com.moilioncircle.redis.replicator.RedisSocketReplicator.SyncMode.PSYNC;
import static com.moilioncircle.redis.replicator.RedisSocketReplicator.SyncMode.SYNC;
import static com.moilioncircle.redis.replicator.RedisSocketReplicator.SyncMode.SYNC_LATER;
import static com.moilioncircle.redis.replicator.Status.CONNECTED;
import static com.moilioncircle.redis.replicator.Status.CONNECTING;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTING;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toInt;
import static com.moilioncircle.redis.replicator.util.Strings.format;
import static com.moilioncircle.redis.replicator.util.Strings.isEquals;
import static com.moilioncircle.redis.replicator.util.Tuples.of;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.util.Objects;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.moilioncircle.redis.replicator.cmd.BulkReplyHandler;
import com.moilioncircle.redis.replicator.cmd.Command;
import com.moilioncircle.redis.replicator.cmd.CommandName;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.RedisCodec;
import com.moilioncircle.redis.replicator.cmd.ReplyParser;
import com.moilioncircle.redis.replicator.cmd.impl.SelectCommand;
import com.moilioncircle.redis.replicator.event.EventListener;
import com.moilioncircle.redis.replicator.event.PostCommandSyncEvent;
import com.moilioncircle.redis.replicator.event.PreCommandSyncEvent;
import com.moilioncircle.redis.replicator.io.AsyncBufferedInputStream;
import com.moilioncircle.redis.replicator.io.RateLimitInputStream;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.io.RedisOutputStream;
import com.moilioncircle.redis.replicator.net.RedisSocketFactory;
import com.moilioncircle.redis.replicator.rdb.RdbParser;
import com.moilioncircle.redis.replicator.util.Strings;
import com.moilioncircle.redis.replicator.util.XScheduledExecutorService;
public class RedisSocketReplicator extends AbstractReplicator {
    protected static final Logger logger = LoggerFactory.getLogger(RedisSocketReplicator.class);
    protected int db = -1;
    protected Socket socket;
    protected ReplyParser replyParser;
    protected ScheduledFuture<?> heartbeat;
    protected RedisOutputStream outputStream;
    protected XScheduledExecutorService executor;
    protected final int port;
    protected final String host;
    protected final ReplFilter[] replFilters;
    protected final RedisSocketFactory socketFactory;
    protected final AtomicBoolean manual = new AtomicBoolean(false);
    public RedisSocketReplicator(String host, int port, Configuration configuration) {
        Objects.requireNonNull(host);
        if (port <= 0 || port > 65535) throw new IllegalArgumentException("illegal argument port: " + port);
        Objects.requireNonNull(configuration);
        this.host = host;
        this.port = port;
        this.configuration = configuration;
        this.socketFactory = new RedisSocketFactory(configuration);
        builtInCommandParserRegister();
        if (configuration.isUseDefaultExceptionListener())
            addExceptionListener(new DefaultExceptionListener());
        this.replFilters = configuration.getReplFilters();
        if (this.replFilters != null) {
            for (int i = 0; i < replFilters.length; i++) {
                replFilters[i] = new InitializedReplFilter(replFilters[i], this);
            }
        }
    }
    public String getHost() {
        return this.host;
    }
    public int getPort() {
        return this.port;
    }
    @Override
    public void open() throws IOException {
        manual.compareAndSet(true, false);
        this.executor = new XScheduledExecutorService(configuration);
        try {
            new RedisSocketReplicatorRetrier().retry(this);
        } finally {
            doClose();
            doCloseListener(this);
            this.executor.terminateQuietly(configuration.getConnectionTimeout(), MILLISECONDS);
        }
    }
    @Override
    public void close() throws IOException {
        super.close();
        manual.compareAndSet(false, true);
    }
    protected SyncMode trySync(final String reply) throws IOException {
        logger.info(reply);
        if (reply.startsWith("FULLRESYNC")) {
            this.db = -1;
            parseDump(this);
            String[] ary = reply.split(" ");
            configuration.setReplId(ary[1]);
            configuration.setReplOffset(Long.parseLong(ary[2]));
            return PSYNC;
        } else if (reply.startsWith("CONTINUE")) {
            String[] ary = reply.split(" ");
            String replId = configuration.getReplId();
            if (ary.length > 1 && replId != null && !replId.equals(ary[1])) configuration.setReplId(ary[1]);
            return PSYNC;
        } else if (reply.startsWith("NOMASTERLINK") || reply.startsWith("LOADING")) {
            return SYNC_LATER;
        } else {
            logger.info("SYNC");
            send("SYNC".getBytes());
            this.db = -1;
            parseDump(this);
            return SYNC;
        }
    }
    protected void parseDump(final AbstractReplicator replicator) throws IOException {
        byte[] rawReply = reply(new BulkReplyHandler() {
            @Override
            public byte[] handle(long len, RedisInputStream in) throws IOException {
                if (len != -1) {
                    logger.info("RDB dump file size:{}", len);
                } else {
                    logger.info("Disk-less replication.");
                }
                if (len != -1 && configuration.isDiscardRdbEvent()) {
                    logger.info("discard {} bytes", len);
                    in.skip(len);
                } else {
                    new RdbParser(in, replicator).parse();
                    if (len == -1) in.skip(40, false);
                }
                return "OK".getBytes();
            }
        });
        String reply = Strings.toString(rawReply);
        if (Objects.equals(reply, "OK")) return;
        throw new IOException("SYNC failed. reason : [" + reply + "]");
    }
    protected void establishConnection() throws IOException {
        connect();
        if (configuration.getAuthPassword() != null) auth(configuration.getAuthUser(), configuration.getAuthPassword());
        sendPing();
        sendSlavePort();
        sendSlaveIp();
        sendSlaveCapa("eof");
        sendSlaveCapa("psync2");
        if (this.replFilters != null) {
            for (ReplFilter filter : this.replFilters) {
                sendSlaveFilter(filter);
            }
        }
    }
    protected void auth(String user, String password) throws IOException {
        if (password != null) {
            String mask = "#" + Strings.mask(password);
            if (user == null) {
                logger.info("AUTH {}", mask);
                send("AUTH".getBytes(), password.getBytes());
            } else {
                logger.info("AUTH {} {}", user, mask);
                send("AUTH".getBytes(), user.getBytes(), password.getBytes());
            }
            final String reply = Strings.toString(reply());
            logger.info(reply);
            if (Objects.equals(reply, "OK")) return;
            if (reply.contains("no password") || reply.contains("without any password")) {
                if (user == null) {
                    logger.warn("[AUTH {}] failed. {}", mask, reply);
                } else {
                    logger.warn("[AUTH {} {}] failed. {}", user, mask, reply);
                }
                return;
            }
            if (user == null) {
                throw new AssertionError("[AUTH " + mask + "] failed. " + reply);
            } else {
                throw new AssertionError("[AUTH " + user + " " + mask + "] failed. " + reply);
            }
        }
    }
    protected void sendPing() throws IOException {
        logger.info("PING");
        send("PING".getBytes());
        final String reply = Strings.toString(reply());
        logger.info(reply);
        if ("PONG".equalsIgnoreCase(reply)) return;
        if (reply.contains("NOAUTH")) throw new AssertionError(reply);
        if (reply.contains("NOPERM")) throw new AssertionError(reply);
        if (reply.contains("operation not permitted")) throw new AssertionError("-NOAUTH Authentication required.");
        logger.warn("[PING] failed. {}", reply);
    }
    protected void sendSlavePort() throws IOException {
        logger.info("REPLCONF listening-port {}", socket.getLocalPort());
        send("REPLCONF".getBytes(), "listening-port".getBytes(), String.valueOf(socket.getLocalPort()).getBytes());
        final String reply = Strings.toString(reply());
        logger.info(reply);
        if (Objects.equals(reply, "OK")) return;
        logger.warn("[REPLCONF listening-port {}] failed. {}", socket.getLocalPort(), reply);
    }
    protected void sendSlaveIp() throws IOException {
        logger.info("REPLCONF ip-address {}", socket.getLocalAddress().getHostAddress());
        send("REPLCONF".getBytes(), "ip-address".getBytes(), socket.getLocalAddress().getHostAddress().getBytes());
        final String reply = Strings.toString(reply());
        logger.info(reply);
        if (Objects.equals(reply, "OK")) return;
        logger.warn("[REPLCONF ip-address {}] failed. {}", socket.getLocalAddress().getHostAddress(), reply);
    }
    protected void sendSlaveCapa(String cmd) throws IOException {
        logger.info("REPLCONF capa {}", cmd);
        send("REPLCONF".getBytes(), "capa".getBytes(), cmd.getBytes());
        final String reply = Strings.toString(reply());
        logger.info(reply);
        if (Objects.equals(reply, "OK")) return;
        logger.warn("[REPLCONF capa {}] failed. {}", cmd, reply);
    }
    protected void sendSlaveFilter(ReplFilter filter) throws IOException {
        String[] command = filter.command();
        String info = String.join(" ", command);
        logger.info(info);
        byte[][] args = new byte[command.length - 1][];
        for (int i = 1, j = 0; i < command.length; i++) {
            args[j++] = command[i].getBytes();
        }
        send(command[0].getBytes(), args);
        final String reply = Strings.toString(reply());
        logger.info(reply);
        if (Objects.equals(reply, "OK")) {
            EventListener listener = filter.listener(this);
            if (listener != null) {
                this.removeEventListener(listener);
                this.addEventListener(listener);
            }
            return;
        }
        logger.warn("[{}] failed. {}", info, reply);
    }
    protected void heartbeat() {
        assert heartbeat == null || heartbeat.isCancelled();
        heartbeat = executor.scheduleWithFixedDelay(new Runnable() {
            @Override
            public void run() {
                sendQuietly("REPLCONF".getBytes(), "ACK".getBytes(), String.valueOf(configuration.getReplOffset()).getBytes());
            }
        }, configuration.getHeartbeatPeriod(), configuration.getHeartbeatPeriod(), MILLISECONDS);
        logger.info("heartbeat started.");
    }
    protected void send(byte[] command) throws IOException {
        send(command, new byte[0][]);
    }
    protected void send(byte[] command, final byte[]... args) throws IOException {
        outputStream.write(STAR);
        outputStream.write(String.valueOf(args.length + 1).getBytes());
        outputStream.writeCrLf();
        outputStream.write(DOLLAR);
        outputStream.write(String.valueOf(command.length).getBytes());
        outputStream.writeCrLf();
        outputStream.write(command);
        outputStream.writeCrLf();
        for (final byte[] arg : args) {
            outputStream.write(DOLLAR);
            outputStream.write(String.valueOf(arg.length).getBytes());
            outputStream.writeCrLf();
            outputStream.write(arg);
            outputStream.writeCrLf();
        }
        outputStream.flush();
    }
    protected void sendQuietly(byte[] command, final byte[]... args) {
        try {
            send(command, args);
        } catch (IOException e) {
        }
    }
    @SuppressWarnings("unchecked")
    protected <T> T reply() throws IOException {
        return (T) replyParser.parse();
    }
    @SuppressWarnings("unchecked")
    protected <T> T reply(BulkReplyHandler handler) throws IOException {
        return (T) replyParser.parse(handler);
    }
    protected void connect() throws IOException {
        if (!compareAndSet(DISCONNECTED, CONNECTING)) return;
        try {
            socket = socketFactory.createSocket(host, port, configuration.getConnectionTimeout());
            outputStream = new RedisOutputStream(socket.getOutputStream());
            InputStream inputStream = socket.getInputStream();
            if (configuration.getAsyncCachedBytes() > 0) {
                inputStream = new AsyncBufferedInputStream(inputStream, configuration.getAsyncCachedBytes());
            }
            if (configuration.getRateLimit() > 0) {
                inputStream = new RateLimitInputStream(inputStream, configuration.getRateLimit());
            }
            this.inputStream = new RedisInputStream(inputStream, configuration.getBufferSize());
            this.inputStream.setRawByteListeners(this.rawByteListeners);
            replyParser = new ReplyParser(this.inputStream, new RedisCodec());
            logger.info("connected to redis-server[{}:{}]", host, port);
        } finally {
            setStatus(CONNECTED);
        }
    }
    @Override
    protected void doClose() throws IOException {
        compareAndSet(CONNECTED, DISCONNECTING);
        try {
            if (heartbeat != null) {
                if (!heartbeat.isCancelled()) heartbeat.cancel(true);
                logger.info("heartbeat canceled.");
            }
            try {
                if (inputStream != null) {
                    inputStream.setRawByteListeners(null);
                    inputStream.close();
                }
            } catch (IOException e) {
            }
            try {
                if (outputStream != null) outputStream.close();
            } catch (IOException e) {
            }
            try {
                if (socket != null && !socket.isClosed()) socket.close();
            } catch (IOException e) {
            }
            logger.info("socket closed. redis-server[{}:{}]", host, port);
        } finally {
            setStatus(DISCONNECTED);
        }
    }
    protected enum SyncMode {SYNC, PSYNC, SYNC_LATER}
    private class RedisSocketReplicatorRetrier extends AbstractReplicatorRetrier {
        @Override
        protected boolean connect() throws IOException {
            establishConnection();
            return true;
        }
        @Override
        protected boolean close(IOException reason) throws IOException {
            if (reason != null)
                logger.error("[redis-replicator] socket error. redis-server[{}:{}]", host, port, reason);
            doClose();
            if (reason != null)
                logger.info("reconnecting to redis-server[{}:{}]. retry times:{}", host, port, (retries + 1));
            return true;
        }
        @Override
        protected boolean isManualClosed() {
            return manual.get();
        }
        @Override
        protected boolean open() throws IOException {
            String replId = configuration.getReplId();
            long replOffset = configuration.getReplOffset();
            logger.info("PSYNC {} {}", replId, String.valueOf(replOffset >= 0 ? replOffset + 1 : replOffset));
            send("PSYNC".getBytes(), replId.getBytes(), String.valueOf(replOffset >= 0 ? replOffset + 1 : replOffset).getBytes());
            final String reply = Strings.toString(reply());
            SyncMode mode = trySync(reply);
            if (mode == PSYNC && getStatus() == CONNECTED) {
                heartbeat();
            } else if (mode == SYNC_LATER && getStatus() == CONNECTED) {
                return false;
            }
            if (getStatus() != CONNECTED) return true;
            submitEvent(new PreCommandSyncEvent());
            if (db != -1) {
                submitEvent(new SelectCommand(db));
            }
            final long[] offset = new long[1];
            while (getStatus() == CONNECTED) {
                Object obj = replyParser.parse(len -> offset[0] = len);
                if (obj instanceof Object[]) {
                    if (verbose() && logger.isDebugEnabled())
                        logger.debug(format((Object[]) obj));
                    Object[] raw = (Object[]) obj;
                    CommandName name = CommandName.name(Strings.toString(raw[0]));
                    final CommandParser<? extends Command> parser;
                    if ((parser = commands.get(name)) == null) {
                        logger.warn("command [{}] not register. raw command:{}", name, format(raw));
                        configuration.addOffset(offset[0]);
                        offset[0] = 0L;
                        continue;
                    }
                    final long st = configuration.getReplOffset();
                    final long ed = st + offset[0];
                    if (isEquals(Strings.toString(raw[0]), "SELECT")) {
                        db = toInt(raw[1]);
                        submitEvent(parser.parse(raw), of(st, ed));
                    } else if (isEquals(Strings.toString(raw[0]), "REPLCONF") && isEquals(Strings.toString(raw[1]), "GETACK")) {
                        if (mode == PSYNC) executor.execute(new Runnable() {
                            @Override
                            public void run() {
                                sendQuietly("REPLCONF".getBytes(), "ACK".getBytes(), String.valueOf(configuration.getReplOffset()).getBytes());
                            }
                        });
                    } else {
                        submitEvent(parser.parse(raw), of(st, ed));
                    }
                } else {
                    logger.warn("unexpected redis reply:{}", obj);
                }
                configuration.addOffset(offset[0]);
                offset[0] = 0L;
            }
            if (getStatus() == CONNECTED) {
                submitEvent(new PostCommandSyncEvent());
            }
            return true;
        }
    }
}
package com.moilioncircle.redis.replicator;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.util.Objects;
import com.moilioncircle.redis.replicator.cmd.Command;
import com.moilioncircle.redis.replicator.cmd.CommandName;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.event.EventListener;
import com.moilioncircle.redis.replicator.io.PeekableInputStream;
import com.moilioncircle.redis.replicator.io.RawByteListener;
import com.moilioncircle.redis.replicator.rdb.RdbVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.Module;
import com.moilioncircle.redis.replicator.rdb.module.ModuleParser;
public class RedisReplicator implements Replicator {
    protected Replicator replicator;
    public RedisReplicator(File file, FileType fileType, Configuration configuration) throws FileNotFoundException {
        switch (fileType) {
            case AOF:
                this.replicator = new RedisAofReplicator(file, configuration);
                break;
            case RDB:
                this.replicator = new RedisRdbReplicator(file, configuration);
                break;
            case MIXED:
                this.replicator = new RedisMixReplicator(file, configuration);
                break;
            default:
                throw new UnsupportedOperationException(fileType.toString());
        }
    }
    public RedisReplicator(InputStream in, FileType fileType, Configuration configuration) {
        switch (fileType) {
            case AOF:
                this.replicator = new RedisAofReplicator(in, configuration);
                break;
            case RDB:
                this.replicator = new RedisRdbReplicator(in, configuration);
                break;
            case MIXED:
                this.replicator = new RedisMixReplicator(in, configuration);
                break;
            default:
                throw new UnsupportedOperationException(fileType.toString());
        }
    }
    public RedisReplicator(String host, int port, Configuration configuration) {
        if (configuration.isEnableScan()) {
            this.replicator = new RedisScanReplicator(host, port, configuration);
        } else {
            this.replicator = new RedisSocketReplicator(host, port, configuration);
        }
    }
    public RedisReplicator(String uri) throws URISyntaxException, IOException {
        Objects.requireNonNull(uri);
        initialize(new RedisURI(uri), null);
    }
    public RedisReplicator(RedisURI uri) throws IOException {
        initialize(uri, null);
    }
    public RedisReplicator(String uri, SslConfiguration sslConfiguration) throws URISyntaxException, IOException {
        Objects.requireNonNull(uri);
        initialize(new RedisURI(uri), sslConfiguration);
    }
    public RedisReplicator(RedisURI uri, SslConfiguration sslConfiguration) throws IOException {
        initialize(uri, sslConfiguration);
    }
    private void initialize(RedisURI uri, SslConfiguration sslConfiguration) throws IOException {
        Objects.requireNonNull(uri);
        Configuration configuration = Configuration.valueOf(uri).merge(sslConfiguration);
        if (uri.getFileType() != null) {
            PeekableInputStream in = new PeekableInputStream(uri.toURL().openStream());
            switch (uri.getFileType()) {
                case AOF:
                    if (in.peek() == 'R') {
                        this.replicator = new RedisMixReplicator(in, configuration);
                    } else {
                        this.replicator = new RedisAofReplicator(in, configuration);
                    }
                    break;
                case RDB:
                    this.replicator = new RedisRdbReplicator(in, configuration);
                    break;
                case MIXED:
                    this.replicator = new RedisMixReplicator(in, configuration);
                    break;
                default:
                    throw new UnsupportedOperationException(uri.getFileType().toString());
            }
        } else {
            this.replicator = new RedisReplicator(uri.getHost(), uri.getPort(), configuration);
        }
    }
    @SuppressWarnings("unchecked")
    public <T extends Replicator> T getReplicator() {
        return (T) this.replicator;
    }
    @Override
    public boolean addRawByteListener(RawByteListener listener) {
        return replicator.addRawByteListener(listener);
    }
    @Override
    public boolean removeRawByteListener(RawByteListener listener) {
        return replicator.removeRawByteListener(listener);
    }
    @Override
    public void builtInCommandParserRegister() {
        replicator.builtInCommandParserRegister();
    }
    @Override
    public CommandParser<? extends Command> getCommandParser(CommandName command) {
        return replicator.getCommandParser(command);
    }
    @Override
    public <T extends Command> void addCommandParser(CommandName command, CommandParser<T> parser) {
        replicator.addCommandParser(command, parser);
    }
    @Override
    public CommandParser<? extends Command> removeCommandParser(CommandName command) {
        return replicator.removeCommandParser(command);
    }
    @Override
    public ModuleParser<? extends Module> getModuleParser(String moduleName, int moduleVersion) {
        return replicator.getModuleParser(moduleName, moduleVersion);
    }
    @Override
    public <T extends Module> void addModuleParser(String moduleName, int moduleVersion, ModuleParser<T> parser) {
        replicator.addModuleParser(moduleName, moduleVersion, parser);
    }
    @Override
    public ModuleParser<? extends Module> removeModuleParser(String moduleName, int moduleVersion) {
        return replicator.removeModuleParser(moduleName, moduleVersion);
    }
    @Override
    public void setRdbVisitor(RdbVisitor rdbVisitor) {
        replicator.setRdbVisitor(rdbVisitor);
    }
    @Override
    public RdbVisitor getRdbVisitor() {
        return replicator.getRdbVisitor();
    }
    @Override
    public boolean addEventListener(EventListener listener) {
        return replicator.addEventListener(listener);
    }
    @Override
    public boolean removeEventListener(EventListener listener) {
        return replicator.removeEventListener(listener);
    }
    @Override
    public boolean addCloseListener(CloseListener listener) {
        return replicator.addCloseListener(listener);
    }
    @Override
    public boolean removeCloseListener(CloseListener listener) {
        return replicator.removeCloseListener(listener);
    }
    @Override
    public boolean addExceptionListener(ExceptionListener listener) {
        return replicator.addExceptionListener(listener);
    }
    @Override
    public boolean removeExceptionListener(ExceptionListener listener) {
        return replicator.removeExceptionListener(listener);
    }
    @Override
    public boolean addStatusListener(StatusListener listener) {
        return replicator.addStatusListener(listener);
    }
    @Override
    public boolean removeStatusListener(StatusListener listener) {
        return replicator.removeStatusListener(listener);
    }
    @Override
    public boolean verbose() {
        return replicator.verbose();
    }
    @Override
    public Status getStatus() {
        return replicator.getStatus();
    }
    @Override
    public Configuration getConfiguration() {
        return replicator.getConfiguration();
    }
    @Override
    public void open() throws IOException {
        replicator.open();
    }
    @Override
    public void close() throws IOException {
        replicator.close();
    }
}
package com.moilioncircle.redis.replicator;
import static com.moilioncircle.redis.replicator.Status.CONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTING;
import static com.moilioncircle.redis.replicator.util.Strings.format;
import static com.moilioncircle.redis.replicator.util.Tuples.of;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Objects;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.moilioncircle.redis.replicator.cmd.Command;
import com.moilioncircle.redis.replicator.cmd.CommandName;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.RedisCodec;
import com.moilioncircle.redis.replicator.cmd.ReplyParser;
import com.moilioncircle.redis.replicator.cmd.TimestampEvent;
import com.moilioncircle.redis.replicator.event.PostCommandSyncEvent;
import com.moilioncircle.redis.replicator.event.PreCommandSyncEvent;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.util.Strings;
public class RedisAofReplicator extends AbstractReplicator {
    protected static final Logger logger = LoggerFactory.getLogger(RedisAofReplicator.class);
    protected final ReplyParser replyParser;
    public RedisAofReplicator(File file, Configuration configuration) throws FileNotFoundException {
        this(new FileInputStream(file), configuration);
    }
    public RedisAofReplicator(InputStream in, Configuration configuration) {
        Objects.requireNonNull(in);
        Objects.requireNonNull(configuration);
        this.configuration = configuration;
        this.inputStream = new RedisInputStream(in, this.configuration.getBufferSize());
        this.inputStream.setRawByteListeners(this.rawByteListeners);
        this.replyParser = new ReplyParser(inputStream, new RedisCodec());
        builtInCommandParserRegister();
        if (configuration.isUseDefaultExceptionListener())
            addExceptionListener(new DefaultExceptionListener());
    }
    @Override
    protected void doOpen() throws IOException {
        configuration.setReplOffset(0L);
        submitEvent(new PreCommandSyncEvent());
        try {
            final long[] offset = new long[1];
            while (getStatus() == CONNECTED) {
                Object obj = replyParser.parse(len -> offset[0] = len);
                if (obj instanceof Object[]) {
                    if (verbose() && logger.isDebugEnabled())
                        logger.debug(format((Object[]) obj));
                    Object[] raw = (Object[]) obj;
                    CommandName name = CommandName.name(Strings.toString(raw[0]));
                    final CommandParser<? extends Command> parser;
                    if ((parser = commands.get(name)) == null) {
                        logger.warn("command [{}] not register. raw command:{}", name, format(raw));
                        configuration.addOffset(offset[0]);
                        offset[0] = 0L;
                        continue;
                    }
                    final long st = configuration.getReplOffset();
                    final long ed = st + offset[0];
                    submitEvent(parser.parse(raw), of(st, ed));
                } else if (obj instanceof TimestampEvent){
                    final long st = configuration.getReplOffset();
                    final long ed = st + offset[0];
                    submitEvent((TimestampEvent)obj, of(st, ed));
                } else {
                    logger.warn("unexpected redis reply:{}", obj);
                }
                configuration.addOffset(offset[0]);
                offset[0] = 0L;
            }
        } catch (EOFException ignore) {
            submitEvent(new PostCommandSyncEvent());
        }
    }
    @Override
    protected void doClose() throws IOException {
        compareAndSet(CONNECTED, DISCONNECTING);
        try {
            if (inputStream != null) {
                this.inputStream.setRawByteListeners(null);
                inputStream.close();
            }
        } catch (IOException ignore) {
        } finally {
            setStatus(DISCONNECTED);
        }
    }
}
package com.moilioncircle.redis.replicator;
import static com.moilioncircle.redis.replicator.Status.CONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTING;
import java.io.EOFException;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.Objects;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.moilioncircle.redis.replicator.io.PeekableInputStream;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.io.XPipedInputStream;
import com.moilioncircle.redis.replicator.io.XPipedOutputStream;
import com.moilioncircle.redis.replicator.rdb.RdbParser;
import com.moilioncircle.redis.replicator.rdb.ScanRdbGenerator;
public class RedisScanReplicator extends AbstractReplicator implements Runnable {
    protected static final Logger logger = LoggerFactory.getLogger(RedisScanReplicator.class);
    protected final int port;
    protected final String host;
    protected volatile Throwable exception;
    protected XPipedOutputStream outputStream;
    protected final ThreadFactory threadFactory = Executors.defaultThreadFactory();
    public RedisScanReplicator(String host, int port, Configuration configuration) {
        Objects.requireNonNull(host);
        if (port <= 0 || port > 65535) throw new IllegalArgumentException("illegal argument port: " + port);
        Objects.requireNonNull(configuration);
        this.host = host;
        this.port = port;
        this.configuration = configuration;
        if (configuration.isUseDefaultExceptionListener())
            addExceptionListener(new DefaultExceptionListener());
    }
    public String getHost() {
        return this.host;
    }
    public int getPort() {
        return this.port;
    }
    @Override
    public void run() {
        try {
            ScanRdbGenerator generator = new ScanRdbGenerator(host, port, configuration, outputStream);
            generator.generate();
        } catch (EOFException ignore) {
        } catch (Throwable e) {
            this.exception = e;
            try {
                outputStream.close();
            } catch (IOException ignore) {
            }
        }
    }
    @Override
    protected void doOpen() throws IOException {
        this.outputStream = new XPipedOutputStream();
        PeekableInputStream in = new PeekableInputStream(new XPipedInputStream(outputStream, configuration.getAsyncCachedBytes()));
        this.inputStream = new RedisInputStream(in, this.configuration.getBufferSize());
        this.inputStream.setRawByteListeners(this.rawByteListeners);
        Thread worker = this.threadFactory.newThread(this);
        worker.start();
        try {
            if (in.peek() == 'R') {
                new RdbParser(inputStream, this).parse();
            }
        } catch (EOFException ignore) {
        }
        throwException(this.exception);
    }
    private void throwException(Throwable exception) throws IOException {
        if (exception != null) {
            if (exception instanceof IOException) {
                throw (IOException) exception;
            } else if (exception instanceof UncheckedIOException) {
                throw ((UncheckedIOException) exception).getCause();
            } else if (exception instanceof Error) {
                throw (Error) exception;
            } else if (exception instanceof RuntimeException) {
                throw (RuntimeException) exception;
            } else {
                throw new AssertionError(exception);
            }
        }
    }
    @Override
    protected void doClose() throws IOException {
        compareAndSet(CONNECTED, DISCONNECTING);
        try {
            if (inputStream != null) {
                this.inputStream.setRawByteListeners(null);
                inputStream.close();
            }
        } catch (IOException ignore) {
        } finally {
            setStatus(DISCONNECTED);
        }
    }
}
package com.moilioncircle.redis.replicator;
import static com.moilioncircle.redis.replicator.Status.CONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTING;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Objects;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.RdbParser;
public class RedisRdbReplicator extends AbstractReplicator {
    public RedisRdbReplicator(File file, Configuration configuration) throws FileNotFoundException {
        this(new FileInputStream(file), configuration);
    }
    public RedisRdbReplicator(InputStream in, Configuration configuration) {
        Objects.requireNonNull(in);
        Objects.requireNonNull(configuration);
        this.configuration = configuration;
        this.inputStream = new RedisInputStream(in, this.configuration.getBufferSize());
        this.inputStream.setRawByteListeners(this.rawByteListeners);
        if (configuration.isUseDefaultExceptionListener())
            addExceptionListener(new DefaultExceptionListener());
    }
    @Override
    protected void doOpen() throws IOException {
        try {
            new RdbParser(inputStream, this).parse();
        } catch (EOFException ignore) {
        }
    }
    @Override
    protected void doClose() throws IOException {
        compareAndSet(CONNECTED, DISCONNECTING);
        try {
            if (inputStream != null) {
                this.inputStream.setRawByteListeners(null);
                inputStream.close();
            }
        } catch (IOException ignore) {
        } finally {
            setStatus(DISCONNECTED);
        }
    }
}
package com.moilioncircle.redis.replicator;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import com.moilioncircle.redis.replicator.cmd.Command;
import com.moilioncircle.redis.replicator.cmd.CommandName;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.event.EventListener;
import com.moilioncircle.redis.replicator.io.RawByteListener;
import com.moilioncircle.redis.replicator.rdb.RdbVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.Module;
import com.moilioncircle.redis.replicator.rdb.module.ModuleParser;
public class AsyncRedisReplicator implements AsyncReplicator {
    protected final Replicator replicator;
    public AsyncRedisReplicator(File file, FileType fileType, Configuration configuration) throws FileNotFoundException {
        this.replicator = new RedisReplicator(file, fileType, configuration);
    }
    public AsyncRedisReplicator(InputStream in, FileType fileType, Configuration configuration) {
        this.replicator = new RedisReplicator(in, fileType, configuration);
    }
    public AsyncRedisReplicator(String host, int port, Configuration configuration) {
        this.replicator = new RedisReplicator(host, port, configuration);
    }
    public AsyncRedisReplicator(String uri) throws URISyntaxException, IOException {
        this.replicator = new RedisReplicator(uri);
    }
    public AsyncRedisReplicator(RedisURI uri) throws IOException {
        this.replicator = new RedisReplicator(uri);
    }
    public AsyncRedisReplicator(String uri, SslConfiguration sslConfiguration) throws URISyntaxException, IOException {
        this.replicator = new RedisReplicator(uri, sslConfiguration);
    }
    public AsyncRedisReplicator(RedisURI uri, SslConfiguration sslConfiguration) throws IOException {
        this.replicator = new RedisReplicator(uri, sslConfiguration);
    }
    @SuppressWarnings("unchecked")
    public <T extends Replicator> T getReplicator() {
        return (T) this.replicator;
    }
    @Override
    public boolean addRawByteListener(RawByteListener listener) {
        return replicator.addRawByteListener(listener);
    }
    @Override
    public boolean removeRawByteListener(RawByteListener listener) {
        return replicator.removeRawByteListener(listener);
    }
    @Override
    public void builtInCommandParserRegister() {
        replicator.builtInCommandParserRegister();
    }
    @Override
    public CommandParser<? extends Command> getCommandParser(CommandName command) {
        return replicator.getCommandParser(command);
    }
    @Override
    public <T extends Command> void addCommandParser(CommandName command, CommandParser<T> parser) {
        replicator.addCommandParser(command, parser);
    }
    @Override
    public CommandParser<? extends Command> removeCommandParser(CommandName command) {
        return replicator.removeCommandParser(command);
    }
    @Override
    public ModuleParser<? extends Module> getModuleParser(String moduleName, int moduleVersion) {
        return replicator.getModuleParser(moduleName, moduleVersion);
    }
    @Override
    public <T extends Module> void addModuleParser(String moduleName, int moduleVersion, ModuleParser<T> parser) {
        replicator.addModuleParser(moduleName, moduleVersion, parser);
    }
    @Override
    public ModuleParser<? extends Module> removeModuleParser(String moduleName, int moduleVersion) {
        return replicator.removeModuleParser(moduleName, moduleVersion);
    }
    @Override
    public void setRdbVisitor(RdbVisitor rdbVisitor) {
        replicator.setRdbVisitor(rdbVisitor);
    }
    @Override
    public RdbVisitor getRdbVisitor() {
        return replicator.getRdbVisitor();
    }
    @Override
    public boolean addEventListener(EventListener listener) {
        return replicator.addEventListener(listener);
    }
    @Override
    public boolean removeEventListener(EventListener listener) {
        return replicator.removeEventListener(listener);
    }
    @Override
    public boolean addCloseListener(CloseListener listener) {
        return replicator.addCloseListener(listener);
    }
    @Override
    public boolean removeCloseListener(CloseListener listener) {
        return replicator.removeCloseListener(listener);
    }
    @Override
    public boolean addExceptionListener(ExceptionListener listener) {
        return replicator.addExceptionListener(listener);
    }
    @Override
    public boolean removeExceptionListener(ExceptionListener listener) {
        return replicator.removeExceptionListener(listener);
    }
    @Override
    public boolean addStatusListener(StatusListener listener) {
        return replicator.addStatusListener(listener);
    }
    @Override
    public boolean removeStatusListener(StatusListener listener) {
        return replicator.removeStatusListener(listener);
    }
    @Override
    public boolean verbose() {
        return replicator.verbose();
    }
    @Override
    public Status getStatus() {
        return replicator.getStatus();
    }
    @Override
    public Configuration getConfiguration() {
        return replicator.getConfiguration();
    }
    @Override
    public CompletableFuture<Void> open(Executor executor) {
        Runnable runnable = () -> Replicators.open(replicator);
        if (executor == null) {
            return CompletableFuture.runAsync(runnable);
        } else {
            return CompletableFuture.runAsync(runnable, executor);
        }
    }
    @Override
    public CompletableFuture<Void> close(Executor executor) {
        Runnable runnable = () -> Replicators.close(replicator);
        if (executor == null) {
            return CompletableFuture.runAsync(runnable);
        } else {
            return CompletableFuture.runAsync(runnable, executor);
        }
    }
}
package com.moilioncircle.redis.replicator;
import static com.moilioncircle.redis.replicator.Status.CONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTED;
import static com.moilioncircle.redis.replicator.Status.DISCONNECTING;
import static com.moilioncircle.redis.replicator.util.Tuples.of;
import java.io.EOFException;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReference;
import com.moilioncircle.redis.replicator.cmd.Command;
import com.moilioncircle.redis.replicator.cmd.CommandName;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.parser.AppendParser;
import com.moilioncircle.redis.replicator.cmd.parser.BLMoveParser;
import com.moilioncircle.redis.replicator.cmd.parser.BRPopLPushParser;
import com.moilioncircle.redis.replicator.cmd.parser.BitFieldParser;
import com.moilioncircle.redis.replicator.cmd.parser.BitOpParser;
import com.moilioncircle.redis.replicator.cmd.parser.CopyParser;
import com.moilioncircle.redis.replicator.cmd.parser.DecrByParser;
import com.moilioncircle.redis.replicator.cmd.parser.DecrParser;
import com.moilioncircle.redis.replicator.cmd.parser.DelParser;
import com.moilioncircle.redis.replicator.cmd.parser.EvalParser;
import com.moilioncircle.redis.replicator.cmd.parser.EvalShaParser;
import com.moilioncircle.redis.replicator.cmd.parser.ExecParser;
import com.moilioncircle.redis.replicator.cmd.parser.ExpireAtParser;
import com.moilioncircle.redis.replicator.cmd.parser.ExpireParser;
import com.moilioncircle.redis.replicator.cmd.parser.FlushAllParser;
import com.moilioncircle.redis.replicator.cmd.parser.FlushDBParser;
import com.moilioncircle.redis.replicator.cmd.parser.FunctionParser;
import com.moilioncircle.redis.replicator.cmd.parser.GeoAddParser;
import com.moilioncircle.redis.replicator.cmd.parser.GeoSearchStoreParser;
import com.moilioncircle.redis.replicator.cmd.parser.GetSetParser;
import com.moilioncircle.redis.replicator.cmd.parser.HDelParser;
import com.moilioncircle.redis.replicator.cmd.parser.HIncrByParser;
import com.moilioncircle.redis.replicator.cmd.parser.HMSetParser;
import com.moilioncircle.redis.replicator.cmd.parser.HSetNxParser;
import com.moilioncircle.redis.replicator.cmd.parser.HSetParser;
import com.moilioncircle.redis.replicator.cmd.parser.IncrByParser;
import com.moilioncircle.redis.replicator.cmd.parser.IncrParser;
import com.moilioncircle.redis.replicator.cmd.parser.LInsertParser;
import com.moilioncircle.redis.replicator.cmd.parser.LMoveParser;
import com.moilioncircle.redis.replicator.cmd.parser.LPopParser;
import com.moilioncircle.redis.replicator.cmd.parser.LPushParser;
import com.moilioncircle.redis.replicator.cmd.parser.LPushXParser;
import com.moilioncircle.redis.replicator.cmd.parser.LRemParser;
import com.moilioncircle.redis.replicator.cmd.parser.LSetParser;
import com.moilioncircle.redis.replicator.cmd.parser.LTrimParser;
import com.moilioncircle.redis.replicator.cmd.parser.MSetNxParser;
import com.moilioncircle.redis.replicator.cmd.parser.MSetParser;
import com.moilioncircle.redis.replicator.cmd.parser.MoveParser;
import com.moilioncircle.redis.replicator.cmd.parser.MultiParser;
import com.moilioncircle.redis.replicator.cmd.parser.PExpireAtParser;
import com.moilioncircle.redis.replicator.cmd.parser.PExpireParser;
import com.moilioncircle.redis.replicator.cmd.parser.PFAddParser;
import com.moilioncircle.redis.replicator.cmd.parser.PFCountParser;
import com.moilioncircle.redis.replicator.cmd.parser.PFMergeParser;
import com.moilioncircle.redis.replicator.cmd.parser.PSetExParser;
import com.moilioncircle.redis.replicator.cmd.parser.PersistParser;
import com.moilioncircle.redis.replicator.cmd.parser.PingParser;
import com.moilioncircle.redis.replicator.cmd.parser.PublishParser;
import com.moilioncircle.redis.replicator.cmd.parser.RPopLPushParser;
import com.moilioncircle.redis.replicator.cmd.parser.RPopParser;
import com.moilioncircle.redis.replicator.cmd.parser.RPushParser;
import com.moilioncircle.redis.replicator.cmd.parser.RPushXParser;
import com.moilioncircle.redis.replicator.cmd.parser.RenameNxParser;
import com.moilioncircle.redis.replicator.cmd.parser.RenameParser;
import com.moilioncircle.redis.replicator.cmd.parser.ReplConfParser;
import com.moilioncircle.redis.replicator.cmd.parser.RestoreParser;
import com.moilioncircle.redis.replicator.cmd.parser.SAddParser;
import com.moilioncircle.redis.replicator.cmd.parser.SDiffStoreParser;
import com.moilioncircle.redis.replicator.cmd.parser.SInterStoreParser;
import com.moilioncircle.redis.replicator.cmd.parser.SMoveParser;
import com.moilioncircle.redis.replicator.cmd.parser.SPublishParser;
import com.moilioncircle.redis.replicator.cmd.parser.SRemParser;
import com.moilioncircle.redis.replicator.cmd.parser.SUnionStoreParser;
import com.moilioncircle.redis.replicator.cmd.parser.ScriptParser;
import com.moilioncircle.redis.replicator.cmd.parser.SelectParser;
import com.moilioncircle.redis.replicator.cmd.parser.SetBitParser;
import com.moilioncircle.redis.replicator.cmd.parser.SetExParser;
import com.moilioncircle.redis.replicator.cmd.parser.SetNxParser;
import com.moilioncircle.redis.replicator.cmd.parser.SetParser;
import com.moilioncircle.redis.replicator.cmd.parser.SetRangeParser;
import com.moilioncircle.redis.replicator.cmd.parser.SortParser;
import com.moilioncircle.redis.replicator.cmd.parser.SwapDBParser;
import com.moilioncircle.redis.replicator.cmd.parser.UnLinkParser;
import com.moilioncircle.redis.replicator.cmd.parser.XAckParser;
import com.moilioncircle.redis.replicator.cmd.parser.XAddParser;
import com.moilioncircle.redis.replicator.cmd.parser.XClaimParser;
import com.moilioncircle.redis.replicator.cmd.parser.XDelParser;
import com.moilioncircle.redis.replicator.cmd.parser.XGroupParser;
import com.moilioncircle.redis.replicator.cmd.parser.XSetIdParser;
import com.moilioncircle.redis.replicator.cmd.parser.XTrimParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZAddParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZDiffStoreParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZIncrByParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZInterStoreParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZPopMaxParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZPopMinParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZRemParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZRemRangeByLexParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZRemRangeByRankParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZRemRangeByScoreParser;
import com.moilioncircle.redis.replicator.cmd.parser.ZUnionStoreParser;
import com.moilioncircle.redis.replicator.event.AbstractEvent;
import com.moilioncircle.redis.replicator.event.Event;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.DefaultRdbVisitor;
import com.moilioncircle.redis.replicator.rdb.RdbVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.Module;
import com.moilioncircle.redis.replicator.rdb.module.ModuleKey;
import com.moilioncircle.redis.replicator.rdb.module.ModuleParser;
import com.moilioncircle.redis.replicator.util.type.Tuple2;
public abstract class AbstractReplicator extends AbstractReplicatorListener implements Replicator {
    protected Configuration configuration;
    protected RedisInputStream inputStream;
    protected RdbVisitor rdbVisitor = new DefaultRdbVisitor(this);
    protected final AtomicReference<Status> connected = new AtomicReference<>(DISCONNECTED);
    protected final Map<ModuleKey, ModuleParser<? extends Module>> modules = new ConcurrentHashMap<>();
    protected final Map<CommandName, CommandParser<? extends Command>> commands = new ConcurrentHashMap<>();
    @Override
    public CommandParser<? extends Command> getCommandParser(CommandName command) {
        return commands.get(command);
    }
    @Override
    public <T extends Command> void addCommandParser(CommandName command, CommandParser<T> parser) {
        commands.put(command, parser);
    }
    @Override
    public CommandParser<? extends Command> removeCommandParser(CommandName command) {
        return commands.remove(command);
    }
    @Override
    public ModuleParser<? extends Module> getModuleParser(String moduleName, int moduleVersion) {
        return modules.get(ModuleKey.key(moduleName, moduleVersion));
    }
    @Override
    public <T extends Module> void addModuleParser(String moduleName, int moduleVersion, ModuleParser<T> parser) {
        modules.put(ModuleKey.key(moduleName, moduleVersion), parser);
    }
    @Override
    public ModuleParser<? extends Module> removeModuleParser(String moduleName, int moduleVersion) {
        return modules.remove(ModuleKey.key(moduleName, moduleVersion));
    }
    public void submitEvent(Event event) {
        long offset = configuration.getReplOffset();
        submitEvent(event, of(offset, offset));
    }
    public void submitEvent(Event event, Tuple2<Long, Long> offsets) {
        try {
            dress(event, offsets);
            doEventListener(this, event);
        } catch (UncheckedIOException e) {
            throw e;
        } catch (Throwable e) {
            doExceptionListener(this, e, event);
        }
    }
    protected void dress(Event event, Tuple2<Long, Long> offsets) {
        if (event instanceof AbstractEvent) {
            ((AbstractEvent) event).getContext().setOffsets(offsets);
        }
    }
    protected boolean compareAndSet(Status prev, Status next) {
        boolean result = connected.compareAndSet(prev, next);
        if (result) doStatusListener(this, next);
        return result;
    }
    protected void setStatus(Status next) {
        connected.set(next);
        doStatusListener(this, next);
    }
    @Override
    public boolean verbose() {
        return configuration != null && configuration.isVerbose();
    }
    @Override
    public Status getStatus() {
        return connected.get();
    }
    @Override
    public Configuration getConfiguration() {
        return configuration;
    }
    @Override
    public void setRdbVisitor(RdbVisitor rdbVisitor) {
        this.rdbVisitor = rdbVisitor;
    }
    @Override
    public RdbVisitor getRdbVisitor() {
        return this.rdbVisitor;
    }
    @Override
    public void builtInCommandParserRegister() {
        addCommandParser(CommandName.name("PING"), new PingParser());
        addCommandParser(CommandName.name("APPEND"), new AppendParser());
        addCommandParser(CommandName.name("SET"), new SetParser());
        addCommandParser(CommandName.name("SETEX"), new SetExParser());
        addCommandParser(CommandName.name("MSET"), new MSetParser());
        addCommandParser(CommandName.name("DEL"), new DelParser());
        addCommandParser(CommandName.name("SADD"), new SAddParser());
        addCommandParser(CommandName.name("HMSET"), new HMSetParser());
        addCommandParser(CommandName.name("HSET"), new HSetParser());
        addCommandParser(CommandName.name("LSET"), new LSetParser());
        addCommandParser(CommandName.name("EXPIRE"), new ExpireParser());
        addCommandParser(CommandName.name("EXPIREAT"), new ExpireAtParser());
        addCommandParser(CommandName.name("GETSET"), new GetSetParser());
        addCommandParser(CommandName.name("HSETNX"), new HSetNxParser());
        addCommandParser(CommandName.name("MSETNX"), new MSetNxParser());
        addCommandParser(CommandName.name("PSETEX"), new PSetExParser());
        addCommandParser(CommandName.name("SETNX"), new SetNxParser());
        addCommandParser(CommandName.name("SETRANGE"), new SetRangeParser());
        addCommandParser(CommandName.name("HDEL"), new HDelParser());
        addCommandParser(CommandName.name("LPOP"), new LPopParser());
        addCommandParser(CommandName.name("LPUSH"), new LPushParser());
        addCommandParser(CommandName.name("LPUSHX"), new LPushXParser());
        addCommandParser(CommandName.name("LRem"), new LRemParser());
        addCommandParser(CommandName.name("RPOP"), new RPopParser());
        addCommandParser(CommandName.name("RPUSH"), new RPushParser());
        addCommandParser(CommandName.name("RPUSHX"), new RPushXParser());
        addCommandParser(CommandName.name("ZREM"), new ZRemParser());
        addCommandParser(CommandName.name("RENAME"), new RenameParser());
        addCommandParser(CommandName.name("INCR"), new IncrParser());
        addCommandParser(CommandName.name("DECR"), new DecrParser());
        addCommandParser(CommandName.name("INCRBY"), new IncrByParser());
        addCommandParser(CommandName.name("DECRBY"), new DecrByParser());
        addCommandParser(CommandName.name("PERSIST"), new PersistParser());
        addCommandParser(CommandName.name("SELECT"), new SelectParser());
        addCommandParser(CommandName.name("FLUSHALL"), new FlushAllParser());
        addCommandParser(CommandName.name("FLUSHDB"), new FlushDBParser());
        addCommandParser(CommandName.name("HINCRBY"), new HIncrByParser());
        addCommandParser(CommandName.name("ZINCRBY"), new ZIncrByParser());
        addCommandParser(CommandName.name("MOVE"), new MoveParser());
        addCommandParser(CommandName.name("SMOVE"), new SMoveParser());
        addCommandParser(CommandName.name("PFADD"), new PFAddParser());
        addCommandParser(CommandName.name("PFCOUNT"), new PFCountParser());
        addCommandParser(CommandName.name("PFMERGE"), new PFMergeParser());
        addCommandParser(CommandName.name("SDIFFSTORE"), new SDiffStoreParser());
        addCommandParser(CommandName.name("SINTERSTORE"), new SInterStoreParser());
        addCommandParser(CommandName.name("SUNIONSTORE"), new SUnionStoreParser());
        addCommandParser(CommandName.name("ZADD"), new ZAddParser());
        addCommandParser(CommandName.name("ZINTERSTORE"), new ZInterStoreParser());
        addCommandParser(CommandName.name("ZUNIONSTORE"), new ZUnionStoreParser());
        addCommandParser(CommandName.name("BRPOPLPUSH"), new BRPopLPushParser());
        addCommandParser(CommandName.name("LINSERT"), new LInsertParser());
        addCommandParser(CommandName.name("RENAMENX"), new RenameNxParser());
        addCommandParser(CommandName.name("RESTORE"), new RestoreParser());
        addCommandParser(CommandName.name("PEXPIRE"), new PExpireParser());
        addCommandParser(CommandName.name("PEXPIREAT"), new PExpireAtParser());
        addCommandParser(CommandName.name("GEOADD"), new GeoAddParser());
        addCommandParser(CommandName.name("EVAL"), new EvalParser());
        addCommandParser(CommandName.name("EVALSHA"), new EvalShaParser());
        addCommandParser(CommandName.name("SCRIPT"), new ScriptParser());
        addCommandParser(CommandName.name("PUBLISH"), new PublishParser());
        addCommandParser(CommandName.name("BITOP"), new BitOpParser());
        addCommandParser(CommandName.name("BITFIELD"), new BitFieldParser());
        addCommandParser(CommandName.name("SETBIT"), new SetBitParser());
        addCommandParser(CommandName.name("SREM"), new SRemParser());
        addCommandParser(CommandName.name("UNLINK"), new UnLinkParser());
        addCommandParser(CommandName.name("SWAPDB"), new SwapDBParser());
        addCommandParser(CommandName.name("MULTI"), new MultiParser());
        addCommandParser(CommandName.name("EXEC"), new ExecParser());
        addCommandParser(CommandName.name("ZREMRANGEBYSCORE"), new ZRemRangeByScoreParser());
        addCommandParser(CommandName.name("ZREMRANGEBYRANK"), new ZRemRangeByRankParser());
        addCommandParser(CommandName.name("ZREMRANGEBYLEX"), new ZRemRangeByLexParser());
        addCommandParser(CommandName.name("LTRIM"), new LTrimParser());
        addCommandParser(CommandName.name("SORT"), new SortParser());
        addCommandParser(CommandName.name("RPOPLPUSH"), new RPopLPushParser());
        addCommandParser(CommandName.name("ZPOPMIN"), new ZPopMinParser());
        addCommandParser(CommandName.name("ZPOPMAX"), new ZPopMaxParser());
        addCommandParser(CommandName.name("REPLCONF"), new ReplConfParser());
        addCommandParser(CommandName.name("XACK"), new XAckParser());
        addCommandParser(CommandName.name("XADD"), new XAddParser());
        addCommandParser(CommandName.name("XCLAIM"), new XClaimParser());
        addCommandParser(CommandName.name("XDEL"), new XDelParser());
        addCommandParser(CommandName.name("XGROUP"), new XGroupParser());
        addCommandParser(CommandName.name("XTRIM"), new XTrimParser());
        addCommandParser(CommandName.name("XSETID"), new XSetIdParser());
        addCommandParser(CommandName.name("COPY"), new CopyParser());
        addCommandParser(CommandName.name("LMOVE"), new LMoveParser());
        addCommandParser(CommandName.name("BLMOVE"), new BLMoveParser());
        addCommandParser(CommandName.name("ZDIFFSTORE"), new ZDiffStoreParser());
        addCommandParser(CommandName.name("GEOSEARCHSTORE"), new GeoSearchStoreParser());
        addCommandParser(CommandName.name("SPUBLISH"), new SPublishParser());
        addCommandParser(CommandName.name("FUNCTION"), new FunctionParser());
    }
    @Override
    public void open() throws IOException {
        if (!compareAndSet(DISCONNECTED, CONNECTED)) return;
        try {
            doOpen();
        } catch (UncheckedIOException e) {
            if (!(e.getCause() instanceof EOFException)) throw e.getCause();
        } finally {
            doClose();
            doCloseListener(this);
        }
    }
    @Override
    public void close() throws IOException {
        compareAndSet(CONNECTED, DISCONNECTING);
    }
    protected void doOpen() throws IOException {
    }
    protected void doClose() throws IOException {
    }
}
package com.moilioncircle.redis.replicator.cmd;
import static com.moilioncircle.redis.replicator.Constants.COLON;
import static com.moilioncircle.redis.replicator.Constants.DOLLAR;
import static com.moilioncircle.redis.replicator.Constants.HASHTAG;
import static com.moilioncircle.redis.replicator.Constants.MINUS;
import static com.moilioncircle.redis.replicator.Constants.PLUS;
import static com.moilioncircle.redis.replicator.Constants.STAR;
import java.io.IOException;
import java.util.Arrays;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.util.ByteBuilder;
import com.moilioncircle.redis.replicator.util.Strings;
public class ReplyParser {
    private final RedisCodec codec;
    private final RedisInputStream in;
    public ReplyParser(RedisInputStream in) {
        this(in, null);
    }
    public ReplyParser(RedisInputStream in, RedisCodec codec) {
        this.in = in;
        this.codec = codec;
    }
    public Object parse() throws IOException {
        return parse(new BulkReplyHandler.SimpleBulkReplyHandler(), null);
    }
    public Object parse(OffsetHandler offsetHandler) throws IOException {
        return parse(new BulkReplyHandler.SimpleBulkReplyHandler(), offsetHandler);
    }
    public Object parse(BulkReplyHandler handler, OffsetHandler offsetHandler) throws IOException {
        in.mark();
        Object rs = parse(handler);
        long len = in.unmark();
        if (offsetHandler != null) offsetHandler.handle(len);
        return rs;
    }
    public Object parse(BulkReplyHandler handler) throws IOException {
        while (true) {
            int c = in.read();
            switch (c) {
                case DOLLAR:
                    ByteBuilder builder = ByteBuilder.allocate(32);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            break;
                        } else {
                            builder.put((byte) c);
                        }
                    }
                    String payload = builder.toString();
                    long len = -1;
                    if (!payload.startsWith("EOF:")) {
                        len = Long.parseLong(builder.toString());
                        if (len == -1) return null;
                    } else {
                        if (handler instanceof BulkReplyHandler.SimpleBulkReplyHandler) {
                            throw new AssertionError("Parse reply for disk-less replication can not use BulkReplyHandler.SimpleBulkReplyHandler.");
                        }
                    }
                    if (handler != null) return handler.handle(len, in);
                    throw new AssertionError("Callback is null");
                case COLON:
                    builder = ByteBuilder.allocate(32);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            break;
                        } else {
                            builder.put((byte) c);
                        }
                    }
                    return Long.parseLong(builder.toString());
                case STAR:
                    builder = ByteBuilder.allocate(32);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            break;
                        } else {
                            builder.put((byte) c);
                        }
                    }
                    len = Long.parseLong(builder.toString());
                    if (len == -1) return null;
                    Object[] ary = new Object[(int) len];
                    for (int i = 0; i < len; i++) {
                        Object obj = parse(new BulkReplyHandler.SimpleBulkReplyHandler());
                        ary[i] = obj;
                    }
                    return ary;
                case PLUS:
                    builder = ByteBuilder.allocate(64);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            return builder.array();
                        } else {
                            builder.put((byte) c);
                        }
                    }
                case MINUS:
                    builder = ByteBuilder.allocate(64);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            return builder.array();
                        } else {
                            builder.put((byte) c);
                        }
                    }
                case HASHTAG:
                    builder = ByteBuilder.allocate(32);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            byte[] bytes = builder.array();
                            bytes = Arrays.copyOfRange(bytes, 3, bytes.length); 
                            return new TimestampEvent(Long.parseLong(Strings.toString(bytes)) * 1000); 
                        } else {
                            builder.put((byte) c);
                        }
                    }
                case '\n':
                    if (in.isMarked()) {
                        in.mark(Math.max(in.unmark() - 1, 0)); 
                    }
                    break;
                default:
                    throw new AssertionError("expect [$,:,*,+,-,#] but: " + (char) c);
            }
        }
    }
}
package com.moilioncircle.redis.replicator.cmd;
import java.math.BigDecimal;
import com.moilioncircle.redis.replicator.util.Strings;
public class CommandParsers {
    public static byte[] toBytes(Object object) {
        return (byte[]) object;
    }
    public static String toRune(Object object) {
        return Strings.toString(object);
    }
    public static double toDouble(Object object) {
        return Double.parseDouble(toRune(object));
    }
    public static int toInt(Object object) {
        return new BigDecimal(toRune(object)).intValueExact();
    }
    public static long toLong(Object object) {
        return new BigDecimal(toRune(object)).longValueExact();
    }
    public static CommandSpec commandSpec(Command command) {
        if (command == null) return null;
        return commandSpec(command.getClass());
    }
    public static CommandSpec commandSpec(Class<? extends Command> clazz) {
        if (clazz == null) return null;
        if (!clazz.isAnnotationPresent(CommandSpec.class)) return null;
        return clazz.getAnnotation(CommandSpec.class);
    }
}
package com.moilioncircle.redis.replicator.cmd;
import com.moilioncircle.redis.replicator.util.ByteBuilder;
import static java.lang.Integer.parseInt;
public class RedisCodec {
    private static final byte[] NUMERALS = new byte[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    public byte[] encode(byte[] bytes) {
        ByteBuilder s = ByteBuilder.allocate(bytes.length);
        for (int i = 0; i < bytes.length; i++) {
            int b = bytes[i] & 0xFF;
            if (b == '\n') {
                s.put((byte) '\\');
                s.put((byte) 'n');
            } else if (b == '\r') {
                s.put((byte) '\\');
                s.put((byte) 'r');
            } else if (b == '\t') {
                s.put((byte) '\\');
                s.put((byte) 't');
            } else if (b == '\b') {
                s.put((byte) '\\');
                s.put((byte) 'b');
            } else if (b == 7) {
                s.put((byte) '\\');
                s.put((byte) 'a');
            } else if (b == '\\') {
                s.put((byte) '\\');
                s.put((byte) '\\');
            } else if (b == '"') {
                s.put((byte) '\\');
                s.put((byte) '"');
            } else if (b > 32 && b < 127) {
                s.put((byte) b); 
            } else {
                s.put((byte) '\\');
                s.put((byte) 'x');
                int ma = b >>> 4;
                int mi = b & 0xF;
                s.put(NUMERALS[ma]);
                s.put(NUMERALS[mi]);
            }
        }
        return s.array();
    }
    public byte[] decode(byte[] bytes) {
        ByteBuilder s = ByteBuilder.allocate(bytes.length);
        for (int i = 0; i < bytes.length; i++) {
            switch (bytes[i]) {
                case '\\':
                    i++;
                    if (i < bytes.length) {
                        switch (bytes[i]) {
                            case 'n':
                                s.put((byte) '\n');
                                break;
                            case 'r':
                                s.put((byte) '\r');
                                break;
                            case 't':
                                s.put((byte) '\t');
                                break;
                            case 'b':
                                s.put((byte) '\b');
                                break;
                            case 'a':
                                s.put((byte) 7);
                                break;
                            case 'x':
                                if (i + 2 >= bytes.length) {
                                    s.put((byte) '\\');
                                    s.put((byte) 'x');
                                } else {
                                    char hig = (char) bytes[++i];
                                    char low = (char) bytes[++i];
                                    try {
                                        s.put((byte) parseInt(new String(new char[]{hig, low}), 16));
                                    } catch (Exception e) {
                                        s.put((byte) '\\');
                                        s.put((byte) 'x');
                                        s.put((byte) hig);
                                        s.put((byte) low);
                                    }
                                }
                                break;
                            default:
                                s.put(bytes[i]);
                                break;
                        }
                    } else {
                    }
                    break;
                default:
                    s.put(bytes[i]);
                    break;
            }
        }
        return s.array();
    }
}
package com.moilioncircle.redis.replicator.cmd;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import java.io.IOException;
@FunctionalInterface
public interface BulkReplyHandler {
    byte[] handle(long len, RedisInputStream in) throws IOException;
    class SimpleBulkReplyHandler implements BulkReplyHandler {
        private final RedisCodec codec;
        public SimpleBulkReplyHandler() {
            this.codec = null;
        }
        public SimpleBulkReplyHandler(RedisCodec codec) {
            this.codec = codec;
        }
        @Override
        public byte[] handle(long len, RedisInputStream in) throws IOException {
            byte[] reply = len == 0 ? new byte[]{} : in.readBytes(len).first();
            int c;
            if ((c = in.read()) != '\r') throw new AssertionError("expect '\\r' but :" + (char) c);
            if ((c = in.read()) != '\n') throw new AssertionError("expect '\\n' but :" + (char) c);
            return reply;
        }
    }
}
package com.moilioncircle.redis.replicator.cmd;
import java.util.function.Predicate;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.event.Event;
import com.moilioncircle.redis.replicator.event.EventListener;
public class TimestampEventListener implements EventListener {
    private boolean guard;
    private final EventListener listener;
    private final Predicate<Long> condition;
    public TimestampEventListener(Predicate<Long> condition, EventListener listener) {
        this.condition = condition;
        this.listener = listener;
    }
    @Override
    public void onEvent(Replicator replicator, Event event) {
        if (event instanceof TimestampEvent) {
            TimestampEvent te = (TimestampEvent) event;
            guard = condition.test(te.getTimestamp());
        } else {
            if (guard) listener.onEvent(replicator, event);
        }
    }
}
package com.moilioncircle.redis.replicator.cmd;
import com.moilioncircle.redis.replicator.event.Event;
public interface Command extends Event {
}
package com.moilioncircle.redis.replicator.cmd;
import com.moilioncircle.redis.replicator.event.AbstractEvent;
public class TimestampEvent extends AbstractEvent {
    private static final long serialVersionUID = 1L;
    private long timestamp;
    public TimestampEvent() {
    }
    public TimestampEvent(long timestamp) {
        this.timestamp = timestamp;
    }
    public long getTimestamp() {
        return timestamp;
    }
    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toRune;
import static com.moilioncircle.redis.replicator.util.Strings.isEquals;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.ExistType;
import com.moilioncircle.redis.replicator.cmd.impl.SetCommand;
import com.moilioncircle.redis.replicator.cmd.impl.XATType;
import com.moilioncircle.redis.replicator.rdb.datatype.ExpiredType;
public class SetParser implements CommandParser<SetCommand> {
    @Override
    public SetCommand parse(Object[] command) {
        byte[] key = toBytes(command[1]);
        byte[] value = toBytes(command[2]);
        int idx = 3;
        ExistType existType = ExistType.NONE;
        Long expiredValue = null;
        XATType xatType = XATType.NONE;
        Long xatValue = null;
        boolean et = false, st = false;
        boolean keepTtl = false;
        boolean get = false;
        ExpiredType expiredType = ExpiredType.NONE;
        while (idx < command.length) {
            String param = toRune(command[idx++]);
            if (!et && isEquals(param, "NX")) {
                existType = ExistType.NX;
                et = true;
            } else if (!et && isEquals(param, "XX")) {
                existType = ExistType.XX;
                et = true;
            } else if (!keepTtl && isEquals(param, "KEEPTTL")) {
                keepTtl = true;
            } else if (!keepTtl && isEquals(param, "GET")) {
                get = true;
            }
            if (!st && isEquals(param, "EX")) {
                expiredType = ExpiredType.SECOND;
                expiredValue = Long.valueOf(toRune(command[idx++]));
                st = true;
            } else if (!st && isEquals(param, "PX")) {
                expiredType = ExpiredType.MS;
                expiredValue = Long.valueOf(toRune(command[idx++]));
                st = true;
            } else if (!st && isEquals(param, "EXAT")) {
                xatType = XATType.EXAT;
                xatValue = Long.valueOf(toRune(command[idx++]));
                st = true;
            } else if (!st && isEquals(param, "PXAT")) {
                xatType = XATType.PXAT;
                xatValue = Long.valueOf(toRune(command[idx++]));
                st = true;
            }
        }
        return new SetCommand(key, value, keepTtl, expiredType, expiredValue, xatType, xatValue, existType, get);
    }
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
import com.moilioncircle.redis.replicator.rdb.datatype.ExpiredType;
@CommandSpec(command = "SET")
public class SetCommand extends GenericKeyValueCommand {
    private static final long serialVersionUID = 1L;
    private boolean keepTtl;
    private ExpiredType expiredType;
    private Long expiredValue;
    private XATType xatType;
    private Long xatValue;
    private ExistType existType;
    private boolean get = false;
    public SetCommand() {
    }
    public SetCommand(byte[] key, byte[] value, boolean keepTtl, ExpiredType expiredType, Long expiredValue, ExistType existType) {
        this(key, value, keepTtl, expiredType, expiredValue, existType, false);
    }
    public SetCommand(byte[] key, byte[] value, boolean keepTtl, ExpiredType expiredType, Long expiredValue, ExistType existType, boolean get) {
        this(key, value, keepTtl, expiredType, expiredValue, XATType.NONE, null, existType, get);
    }
    public SetCommand(byte[] key, byte[] value, boolean keepTtl, ExpiredType expiredType, Long expiredValue, XATType xatType, Long xatValue, ExistType existType, boolean get) {
        super(key, value);
        this.keepTtl = keepTtl;
        this.expiredType = expiredType;
        this.expiredValue = expiredValue;
        this.xatType = xatType;
        this.xatValue = xatValue;
        this.existType = existType;
        this.get = get;
    }
    public boolean getKeepTtl() {
        return keepTtl;
    }
    public void setKeepTtl(boolean keepTtl) {
        this.keepTtl = keepTtl;
    }
    public ExpiredType getExpiredType() {
        return expiredType;
    }
    public void setExpiredType(ExpiredType expiredType) {
        this.expiredType = expiredType;
    }
    public Long getExpiredValue() {
        return expiredValue;
    }
    public void setExpiredValue(Long expiredValue) {
        this.expiredValue = expiredValue;
    }
    public ExistType getExistType() {
        return existType;
    }
    public void setExistType(ExistType existType) {
        this.existType = existType;
    }
    public boolean isGet() {
        return get;
    }
    public void setGet(boolean get) {
        this.get = get;
    }
    public XATType getXatType() {
        return xatType;
    }
    public void setXatType(XATType xatType) {
        this.xatType = xatType;
    }
    public Long getXatValue() {
        return xatValue;
    }
    public void setXatValue(Long xatValue) {
        this.xatValue = xatValue;
    }
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
import com.moilioncircle.redis.replicator.rdb.datatype.EvictType;
@CommandSpec(command = "RESTORE")
public class RestoreCommand extends GenericKeyCommand {
    private static final long serialVersionUID = 1L;
    private long ttl;
    private byte[] serializedValue;
    private boolean replace;
    private boolean absTtl;
    protected EvictType evictType = EvictType.NONE;
    protected Long evictValue;
    public RestoreCommand() {
    }
    public RestoreCommand(byte[] key, long ttl, byte[] serializedValue, boolean replace, boolean absTtl, EvictType evictType, Long evictValue) {
        super(key);
        this.ttl = ttl;
        this.serializedValue = serializedValue;
        this.replace = replace;
        this.absTtl = absTtl;
        this.evictType = evictType;
        this.evictValue = evictValue;
    }
    public long getTtl() {
        return ttl;
    }
    public void setTtl(long ttl) {
        this.ttl = ttl;
    }
    public byte[] getSerializedValue() {
        return serializedValue;
    }
    public void setSerializedValue(byte[] serializedValue) {
        this.serializedValue = serializedValue;
    }
    public boolean isReplace() {
        return replace;
    }
    public void setReplace(boolean replace) {
        this.replace = replace;
    }
    public boolean isAbsTtl() {
        return absTtl;
    }
    public void setAbsTtl(boolean absTtl) {
        this.absTtl = absTtl;
    }
    public EvictType getEvictType() {
        return evictType;
    }
    public void setEvictType(EvictType evictType) {
        this.evictType = evictType;
    }
    public Long getEvictValue() {
        return evictValue;
    }
    public void setEvictValue(Long evictValue) {
        this.evictValue = evictValue;
    }
}
package com.moilioncircle.redis.replicator.client;
import static java.util.Arrays.stream;
import java.io.Closeable;
import java.io.IOException;
import java.net.Socket;
import java.util.LinkedList;
import java.util.Queue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.moilioncircle.redis.replicator.Configuration;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.io.RedisOutputStream;
import com.moilioncircle.redis.replicator.net.RedisSocketFactory;
import com.moilioncircle.redis.replicator.util.Strings;
import com.moilioncircle.redis.replicator.util.Tuples;
import com.moilioncircle.redis.replicator.util.type.Tuple2;
public class RESP2Client implements Closeable {
    private static final Logger logger = LoggerFactory.getLogger(RESP2Client.class);
    private final RESP2 resp2;
    private final String host;
    private final int port;
    private final Socket socket;
    private final RedisInputStream is;
    private final RedisOutputStream os;
    private final Configuration configuration;
    public RESP2Client(String host, int port, Configuration configuration) throws IOException {
        this.host = host;
        this.port = port;
        this.configuration = configuration;
        RedisSocketFactory socketFactory = new RedisSocketFactory(configuration);
        this.socket = socketFactory.createSocket(host, port, configuration.getConnectionTimeout());
        this.os = new RedisOutputStream(socket.getOutputStream());
        this.is = new RedisInputStream(socket.getInputStream(), configuration.getBufferSize());
        this.resp2 = new RESP2(is, os);
        final String user = configuration.getAuthUser();
        final String pswd = configuration.getAuthPassword();
        if (pswd != null) {
            RESP2.Node auth = null;
            if (user != null) {
                auth = newCommand().invoke("auth", user, pswd);
            } else {
                auth = newCommand().invoke("auth", pswd);
            }
            if (auth.type == RESP2.Type.ERROR) {
                String reply = auth.getError();
                String mask = "#" + Strings.mask(pswd);
                if (reply.contains("no password") || reply.contains("without any password")) {
                    if (user == null) {
                        logger.warn("[AUTH {}] failed. {}", mask, reply);
                    } else {
                        logger.warn("[AUTH {} {}] failed. {}", user, mask, reply);
                    }
                } else if (user == null) {
                    throw new AssertionError("[AUTH " + mask + "] failed. " + reply);
                } else {
                    throw new AssertionError("[AUTH " + user + " " + mask + "] failed. " + reply);
                }
            }
        } else {
            RESP2.Node ping = newCommand().invoke("ping");
            if (ping.type == RESP2.Type.ERROR) {
                String reply = ping.getError();
                if (reply.contains("NOAUTH")) throw new AssertionError(reply);
                if (reply.contains("NOPERM")) throw new AssertionError(reply);
                if (reply.contains("operation not permitted")) throw new AssertionError("-NOAUTH Authentication required.");
                throw new IOException(reply);
            }
        }
        logger.info("connected to redis-server[{}:{}]", host, port);
    }
    public Command newCommand() {
        return new Command(this.resp2);
    }
    @Override
    public void close() throws IOException {
        try {
            if (is != null) {
                is.close();
            }
        } catch (IOException e) {
        }
        try {
            if (os != null) {
                os.close();
            }
        } catch (IOException e) {
        }
        try {
            if (socket != null && !socket.isClosed()) {
                socket.close();
            }
        } catch (IOException e) {
        }
        logger.info("socket closed. redis-server[{}:{}]", host, port);
    }
    public static RESP2Client valueOf(RESP2Client prev, int db, IOException reason, int attempts) throws IOException {
        if (reason != null) {
            logger.error("[redis-replicator] socket error. redis-server[{}:{}]", prev.host, prev.port, reason);
        }
        prev.close();
        if (reason != null) {
            logger.info("reconnecting to redis-server[{}:{}]. retry times:{}", prev.host, prev.port, attempts);
        }
        RESP2Client next = new RESP2Client(prev.host, prev.port, prev.configuration);
        RESP2.Node select = next.newCommand().invoke("select", String.valueOf(db));
        if (select.type == RESP2.Type.ERROR) {
            throw new IOException(select.getError());
        }
        return next;
    }
    public static interface Function<T, R> {
        R apply(T t) throws IOException;
    }
    public static interface NodeConsumer {
        void accept(RESP2.Node node) throws IOException;
    }
    public static class Command {
        private RESP2 resp2;
        private Queue<Tuple2<NodeConsumer, byte[][]>> commands;
        private Command(RESP2 resp2) {
            this.resp2 = resp2;
            this.commands = new LinkedList<>();
        }
        public Queue<Tuple2<NodeConsumer, byte[][]>> getCommands() {
            return new LinkedList<>(this.commands);
        }
        public void get() throws IOException {
            while (!this.commands.isEmpty()) {
                NodeConsumer consumer = this.commands.peek().getV1();
                consumer.accept(this.resp2.parse());
                this.commands.poll();
            }
        }
        public RESP2.Node invoke(byte[]... command) throws IOException {
            this.resp2.emit(command);
            return this.resp2.parse();
        }
        public RESP2.Node invoke(String... command) throws IOException {
            return invoke(stream(command).map(e -> e.getBytes()).toArray(byte[][]::new));
        }
        public Command post(NodeConsumer handler, byte[]... command) throws IOException {
            this.resp2.emit(command);
            this.commands.offer(Tuples.of(handler, command));
            return this;
        }
        public Command post(NodeConsumer handler, String... command) throws IOException {
            return post(handler, stream(command).map(e -> e.getBytes()).toArray(byte[][]::new));
        }
    }
}
package com.moilioncircle.redis.replicator.client;
import static com.moilioncircle.redis.replicator.Constants.COLON;
import static com.moilioncircle.redis.replicator.Constants.DOLLAR;
import static com.moilioncircle.redis.replicator.Constants.MINUS;
import static com.moilioncircle.redis.replicator.Constants.PLUS;
import static com.moilioncircle.redis.replicator.Constants.STAR;
import java.io.IOException;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.io.RedisOutputStream;
import com.moilioncircle.redis.replicator.util.ByteArray;
import com.moilioncircle.redis.replicator.util.ByteBuilder;
import com.moilioncircle.redis.replicator.util.Strings;
public class RESP2 {
    private final RedisInputStream in;
    private final RedisOutputStream out;
    RESP2(RedisInputStream in, RedisOutputStream out) {
        this.in = in;
        this.out = out;
    }
    void emit(byte[]... command) throws IOException {
        out.write(STAR);
        out.write(String.valueOf(command.length).getBytes());
        out.writeCrLf();
        for (final byte[] element : command) {
            out.write(DOLLAR);
            out.write(String.valueOf(element.length).getBytes());
            out.writeCrLf();
            out.write(element);
            out.writeCrLf();
        }
        out.flush();
    }
    Node parse() throws IOException {
        while (true) {
            int c = in.read();
            switch (c) {
                case DOLLAR:
                    ByteBuilder builder = ByteBuilder.allocate(32);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            break;
                        } else {
                            builder.put((byte) c);
                        }
                    }
                    long len = Long.parseLong(builder.toString());
                    if (len == -1) return new Node(RESP2.Type.NULL, null);
                    Node r = new Node(RESP2.Type.STRING, in.readBytes(len));
                    if ((c = in.read()) != '\r') throw new AssertionError("expect '\\r' but :" + (char) c);
                    if ((c = in.read()) != '\n') throw new AssertionError("expect '\\n' but :" + (char) c);
                    return r;
                case COLON:
                    builder = ByteBuilder.allocate(128);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            break;
                        } else {
                            builder.put((byte) c);
                        }
                    }
                    return new Node(RESP2.Type.NUMBER, Long.parseLong(builder.toString()));
                case STAR:
                    builder = ByteBuilder.allocate(128);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            break;
                        } else {
                            builder.put((byte) c);
                        }
                    }
                    len = Long.parseLong(builder.toString());
                    if (len == -1) return new Node(RESP2.Type.NULL, null);
                    Node[] ary = new Node[(int) len];
                    for (int i = 0; i < len; i++) {
                        Node obj = parse();
                        ary[i] = obj;
                    }
                    return new Node(RESP2.Type.ARRAY, ary);
                case PLUS:
                    builder = ByteBuilder.allocate(128);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            return new Node(RESP2.Type.STRING, new ByteArray(builder.array()));
                        } else {
                            builder.put((byte) c);
                        }
                    }
                case MINUS:
                    builder = ByteBuilder.allocate(32);
                    while (true) {
                        while ((c = in.read()) != '\r') {
                            builder.put((byte) c);
                        }
                        if ((c = in.read()) == '\n') {
                            return new Node(RESP2.Type.ERROR, new ByteArray(builder.array()));
                        } else {
                            builder.put((byte) c);
                        }
                    }
                default:
                    throw new AssertionError("expect [$,:,*,+,-] but: " + (char) c);
            }
        }
    }
    public static enum Type {
        ARRAY, NUMBER, STRING, ERROR, NULL;
    }
    public static class Node {
        public final RESP2.Type type;
        public final Object value;
        private Node(RESP2.Type type, Object value) {
            this.type = type;
            this.value = value;
        }
        public Long getNumber() {
            return type == Type.NUMBER ? (Long) value : null;
        }
        public Node[] getArray() {
            return type == Type.ARRAY ? (Node[]) value : null;
        }
        public ByteArray getBytes() {
            return type == Type.STRING ? (ByteArray) value : null;
        }
        public String getError() {
            return type == Type.ERROR ? Strings.toString(((ByteArray) value).first()) : null;
        }
        public String getString() {
            return type == Type.STRING ? Strings.toString(((ByteArray) value).first()) : null;
        }
    }
}
package com.moilioncircle.redis.replicator.io;
import com.moilioncircle.redis.replicator.util.ByteArray;
import java.io.IOException;
import java.io.InputStream;
public class ByteArrayInputStream extends InputStream {
    protected long pos;
    protected long count;
    protected long mark = 0;
    protected ByteArray buf;
    public ByteArrayInputStream(ByteArray buf) {
        this.pos = 0;
        this.buf = buf;
        this.count = buf.length();
    }
    @Override
    public int read() {
        return (pos < count) ? (buf.get(pos++) & 0xff) : -1;
    }
    @Override
    public int read(byte[] b, int off, int len) {
        if (b == null) {
            throw new NullPointerException();
        } else if (off < 0 || len < 0 || len > b.length - off) {
            throw new IndexOutOfBoundsException();
        }
        if (pos >= count) return -1;
        int avail = (int) (count - pos);
        if (len > avail) len = avail;
        if (len <= 0) return 0;
        ByteArray.arraycopy(buf, pos, new ByteArray(b), off, len);
        pos += len;
        return len;
    }
    @Override
    public long skip(long n) {
        long k = count - pos;
        if (n < k) k = n < 0 ? 0 : n;
        pos += k;
        return k;
    }
    @Override
    public int available() {
        return (int) (this.count - this.pos);
    }
    @Override
    public boolean markSupported() {
        return true;
    }
    @Override
    public void mark(int readAheadLimit) {
        mark = pos;
    }
    @Override
    public void reset() {
        pos = mark;
    }
    @Override
    public void close() throws IOException {
    }
}
package com.moilioncircle.redis.replicator.io;
import com.moilioncircle.redis.replicator.util.ByteArray;
import com.moilioncircle.redis.replicator.util.Strings;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.List;
public class RedisInputStream extends InputStream {
    protected int head = 0;
    protected int tail = 0;
    protected long total = 0;
    protected long markLen = 0;
    protected final byte[] buf;
    protected boolean mark = false;
    protected final InputStream in;
    protected List<RawByteListener> rawByteListeners;
    public RedisInputStream(ByteArray array) {
        this(new ByteArrayInputStream(array));
    }
    public RedisInputStream(final InputStream in) {
        this(in, 8192);
    }
    public RedisInputStream(final InputStream in, int len) {
        this.in = in;
        this.buf = new byte[len];
    }
    public synchronized void setRawByteListeners(List<RawByteListener> rawByteListeners) {
        this.rawByteListeners = rawByteListeners;
    }
    protected void notify(byte... bytes) {
        if (rawByteListeners == null || rawByteListeners.isEmpty()) return;
        for (RawByteListener listener : rawByteListeners) {
            listener.handle(bytes);
        }
    }
    public int head() {
        return head;
    }
    public int tail() {
        return tail;
    }
    public int bufSize() {
        return buf.length;
    }
    public boolean isMarked() {
        return mark;
    }
    public void mark(long len) {
        mark();
        markLen = len;
    }
    public void mark() {
        if (!mark) {
            mark = true;
            return;
        }
        throw new AssertionError("already marked");
    }
    public long unmark() {
        if (mark) {
            long rs = markLen;
            markLen = 0;
            mark = false;
            return rs;
        }
        throw new AssertionError("must mark first");
    }
    public long total() {
        return total;
    }
    public ByteArray readBytes(long len) throws IOException {
        ByteArray bytes = new ByteArray(len);
        this.read(bytes, 0, len);
        if (mark) markLen += len;
        return bytes;
    }
    public int readInt(int len) throws IOException {
        return readInt(len, true);
    }
    public long readLong(int len) throws IOException {
        return readLong(len, true);
    }
    public int readInt(int length, boolean littleEndian) throws IOException {
        int r = 0;
        for (int i = 0; i < length; ++i) {
            final int v = this.read();
            if (littleEndian) {
                r |= (v << (i << 3));
            } else {
                r = (r << 8) | v;
            }
        }
        int c;
        return r << (c = (4 - length << 3)) >> c;
    }
    public long readUInt(int length) throws IOException {
        return readUInt(length, true);
    }
    public long readUInt(int length, boolean littleEndian) throws IOException {
        return readInt(length, littleEndian) & 0xFFFFFFFFL;
    }
    public int readInt(byte[] bytes) {
        return readInt(bytes, true);
    }
    public int readInt(byte[] bytes, boolean littleEndian) {
        int r = 0;
        int length = bytes.length;
        for (int i = 0; i < length; ++i) {
            final int v = bytes[i] & 0xFF;
            if (littleEndian) {
                r |= (v << (i << 3));
            } else {
                r = (r << 8) | v;
            }
        }
        int c;
        return r << (c = (4 - length << 3)) >> c;
    }
    public long readLong(int length, boolean littleEndian) throws IOException {
        long r = 0;
        for (int i = 0; i < length; ++i) {
            final long v = this.read();
            if (littleEndian) {
                r |= (v << (i << 3));
            } else {
                r = (r << 8) | v;
            }
        }
        return r;
    }
    public String readString(int len) throws IOException {
        return Strings.toString(readBytes(len).first());
    }
    public String readString(int len, Charset charset) throws IOException {
        return Strings.toString(readBytes(len).first(), charset);
    }
    @Override
    public int read() throws IOException {
        if (head >= tail) fill();
        if (mark) markLen += 1;
        byte b = buf[head++];
        notify(b);
        return b & 0xff;
    }
    public long read(ByteArray bytes, long offset, long len) throws IOException {
        long total = len;
        long index = offset;
        while (total > 0) {
            int available = tail - head;
            if (available >= total) {
                ByteArray.arraycopy(new ByteArray(buf), head, bytes, index, total);
                head += total;
                break;
            } else {
                ByteArray.arraycopy(new ByteArray(buf), head, bytes, index, available);
                index += available;
                total -= available;
                fill();
            }
        }
        for (byte[] b : bytes) {
            notify(b);
        }
        return len;
    }
    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }
    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        return (int) read(new ByteArray(b), off, len);
    }
    @Override
    public int available() throws IOException {
        return tail - head + in.available();
    }
    public long skip(long len, boolean notify) throws IOException {
        long total = len;
        while (total > 0) {
            int available = tail - head;
            if (available >= total) {
                if (notify) notify(Arrays.copyOfRange(buf, head, head + (int) total));
                head += total;
                break;
            } else {
                if (notify) notify(Arrays.copyOfRange(buf, head, tail));
                total -= available;
                fill();
            }
        }
        return len;
    }
    @Override
    public long skip(long len) throws IOException {
        return skip(len, true);
    }
    @Override
    public void close() throws IOException {
        in.close();
    }
    protected void fill() throws IOException {
        tail = in.read(buf, 0, buf.length);
        if (tail == -1) throw new EOFException("end of file or end of stream.");
        total += tail;
        head = 0;
    }
}
package com.moilioncircle.redis.replicator.rdb.skip;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FREQ;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_IDLE;
import java.io.IOException;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.event.Event;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.DefaultRdbVisitor;
import com.moilioncircle.redis.replicator.rdb.RdbValueVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.ContextKeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.DB;
import com.moilioncircle.redis.replicator.rdb.datatype.Function;
public class SkipRdbVisitor extends DefaultRdbVisitor {
    public SkipRdbVisitor(Replicator replicator) {
        super(replicator);
    }
    public SkipRdbVisitor(Replicator replicator, RdbValueVisitor valueVisitor) {
        super(replicator, valueVisitor);
    }
    @Override
    public Function applyFunction(RedisInputStream in, int version) throws IOException {
        valueVisitor.applyFunction(in, version);
        return null;
    }
    @Override
    public Function applyFunction2(RedisInputStream in, int version) throws IOException {
        valueVisitor.applyFunction2(in, version);
        return null;
    }
    @Override
    public DB applySelectDB(RedisInputStream in, int version) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadLen();
        return null;
    }
    @Override
    public DB applyResizeDB(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadLen();
        parser.rdbLoadLen();
        return null;
    }
    @Override
    public Event applyExpireTime(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadTime();
        int type = applyType(in);
        context.setValueRdbType(type);
        if (type == RDB_OPCODE_FREQ) {
            applyFreq(in, version, context);
        } else if (type == RDB_OPCODE_IDLE) {
            applyIdle(in, version, context);
        } else {
            rdbLoadObject(in, version, context);
        }
        return null;
    }
    @Override
    public Event applyExpireTimeMs(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadMillisecondTime();
        int type = applyType(in);
        context.setValueRdbType(type);
        if (type == RDB_OPCODE_FREQ) {
            applyFreq(in, version, context);
        } else if (type == RDB_OPCODE_IDLE) {
            applyIdle(in, version, context);
        } else {
            rdbLoadObject(in, version, context);
        }
        return null;
    }
    @Override
    public Event applyFreq(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        in.read();
        int valueType = applyType(in);
        context.setValueRdbType(valueType);
        rdbLoadObject(in, version, context);
        return null;
    }
    @Override
    public Event applyIdle(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadLen();
        int valueType = applyType(in);
        context.setValueRdbType(valueType);
        rdbLoadObject(in, version, context);
        return null;
    }
    @Override
    public Event applyAux(RedisInputStream in, int version) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        parser.rdbLoadEncodedStringObject();
        return null;
    }
    @Override
    public Event applyModuleAux(RedisInputStream in, int version) throws IOException {
        return super.applyModuleAux(in, version);
    }
    @Override
    public Event applyString(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyString(in, version);
        return null;
    }
    @Override
    public Event applyList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyList(in, version);
        return null;
    }
    @Override
    public Event applySet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applySet(in, version);
        return null;
    }
    @Override
    public Event applySetListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applySetListPack(in, version);
        return null;
    }
    @Override
    public Event applyZSet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyZSet(in, version);
        return null;
    }
    @Override
    public Event applyZSet2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyZSet2(in, version);
        return null;
    }
    @Override
    public Event applyHash(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyHash(in, version);
        return null;
    }
    @Override
    public Event applyHashZipMap(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyHashZipMap(in, version);
        return null;
    }
    @Override
    public Event applyListZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyListZipList(in, version);
        return null;
    }
    @Override
    public Event applySetIntSet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applySetIntSet(in, version);
        return null;
    }
    @Override
    public Event applyZSetZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyZSetZipList(in, version);
        return null;
    }
    @Override
    public Event applyZSetListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyZSetListPack(in, version);
        return null;
    }
    @Override
    public Event applyHashZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyHashZipList(in, version);
        return null;
    }
    @Override
    public Event applyHashListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyHashListPack(in, version);
        return null;
    }
    @Override
    public Event applyListQuickList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyListQuickList(in, version);
        return null;
    }
    @Override
    public Event applyListQuickList2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyListQuickList2(in, version);
        return null;
    }
    @Override
    public Event applyModule(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyModule(in, version);
        return null;
    }
    @Override
    public Event applyModule2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyModule2(in, version);
        return null;
    }
    @Override
    public Event applyStreamListPacks(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyStreamListPacks(in, version);
        return null;
    }
    @Override
    public Event applyStreamListPacks2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyStreamListPacks2(in, version);
        return null;
    }
    @Override
    public Event applyStreamListPacks3(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        valueVisitor.applyStreamListPacks3(in, version);
        return null;
    }
}
package com.moilioncircle.redis.replicator.rdb.skip;
import static com.moilioncircle.redis.replicator.Constants.MODULE_SET;
import java.io.IOException;
import java.util.NoSuchElementException;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.DefaultRdbValueVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.Module;
import com.moilioncircle.redis.replicator.rdb.module.ModuleParser;
public class SkipRdbValueVisitor extends DefaultRdbValueVisitor {
    public SkipRdbValueVisitor(Replicator replicator) {
        super(replicator);
    }
    @Override
    public <T> T applyFunction(RedisInputStream in, int version) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbGenericLoadStringObject(); 
        parser.rdbGenericLoadStringObject(); 
        long hasDesc = parser.rdbLoadLen().len;
        if (hasDesc == 1) {
            parser.rdbGenericLoadStringObject(); 
        }
        parser.rdbGenericLoadStringObject(); 
        return null;
    }
    @Override
    public <T> T applyFunction2(RedisInputStream in, int version) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbGenericLoadStringObject(); 
        return null;
    }
    @Override
    public <T> T applyString(RedisInputStream in, int version) throws IOException {
        SkipRdbParser parser = new SkipRdbParser(in);
        parser.rdbLoadEncodedStringObject();
        return null;
    }
    @Override
    public <T> T applyList(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        long len = skip.rdbLoadLen().len;
        while (len > 0) {
            skip.rdbLoadEncodedStringObject();
            len--;
        }
        return null;
    }
    @Override
    public <T> T applySet(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        long len = skip.rdbLoadLen().len;
        while (len > 0) {
            skip.rdbLoadEncodedStringObject();
            len--;
        }
        return null;
    }
    @Override
    public <T> T applySetListPack(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        skip.rdbLoadPlainStringObject();
        return null;
    }
    @Override
    public <T> T applyZSet(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        long len = skip.rdbLoadLen().len;
        while (len > 0) {
            skip.rdbLoadEncodedStringObject();
            skip.rdbLoadDoubleValue();
            len--;
        }
        return null;
    }
    @Override
    public <T> T applyZSet2(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        long len = skip.rdbLoadLen().len;
        while (len > 0) {
            skip.rdbLoadEncodedStringObject();
            skip.rdbLoadBinaryDoubleValue();
            len--;
        }
        return null;
    }
    @Override
    public <T> T applyHash(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        long len = skip.rdbLoadLen().len;
        while (len > 0) {
            skip.rdbLoadEncodedStringObject();
            skip.rdbLoadEncodedStringObject();
            len--;
        }
        return null;
    }
    @Override
    public <T> T applyHashZipMap(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        skip.rdbLoadPlainStringObject();
        return null;
    }
    @Override
    public <T> T applyListZipList(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        skip.rdbLoadPlainStringObject();
        return null;
    }
    @Override
    public <T> T applySetIntSet(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        skip.rdbLoadPlainStringObject();
        return null;
    }
    @Override
    public <T> T applyZSetZipList(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        skip.rdbLoadPlainStringObject();
        return null;
    }
    @Override
    public <T> T applyZSetListPack(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        skip.rdbLoadPlainStringObject();
        return null;
    }
    @Override
    public <T> T applyHashZipList(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        skip.rdbLoadPlainStringObject();
        return null;
    }
    @Override
    public <T> T applyHashListPack(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        skip.rdbLoadPlainStringObject();
        return null;
    }
    @Override
    public <T> T applyListQuickList(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        long len = skip.rdbLoadLen().len;
        for (long i = 0; i < len; i++) {
            skip.rdbGenericLoadStringObject();
        }
        return null;
    }
    @Override
    public <T> T applyListQuickList2(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        long len = skip.rdbLoadLen().len;
        for (long i = 0; i < len; i++) {
            skip.rdbLoadLen();
            skip.rdbGenericLoadStringObject();
        }
        return null;
    }
    @Override
    public <T> T applyModule(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        char[] c = new char[9];
        long moduleid = skip.rdbLoadLen().len;
        for (int i = 0; i < c.length; i++) {
            c[i] = MODULE_SET[(int) (moduleid >>> (10 + (c.length - 1 - i) * 6) & 63)];
        }
        String moduleName = new String(c);
        int moduleVersion = (int) (moduleid & 1023);
        ModuleParser<? extends Module> moduleParser = replicator.getModuleParser(moduleName, moduleVersion);
        if (moduleParser == null) {
            throw new NoSuchElementException("module parser[" + moduleName + ", " + moduleVersion + "] not register. rdb type: [RDB_TYPE_MODULE]");
        }
        moduleParser.parse(in, 1);
        return null;
    }
    @Override
    public <T> T applyModule2(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        skip.rdbLoadLen();
        SkipRdbParser skipRdbParser = new SkipRdbParser(in);
        skipRdbParser.rdbLoadCheckModuleValue();
        return null;
    }
    @Override
    public <T> T applyStreamListPacks(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        long listPacks = skip.rdbLoadLen().len;
        while (listPacks-- > 0) {
            skip.rdbLoadPlainStringObject();
            skip.rdbLoadPlainStringObject();
        }
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        long groupCount = skip.rdbLoadLen().len;
        while (groupCount-- > 0) {
            skip.rdbLoadPlainStringObject();
            skip.rdbLoadLen();
            skip.rdbLoadLen();
            long groupPel = skip.rdbLoadLen().len;
            while (groupPel-- > 0) {
                in.skip(16);
                skip.rdbLoadMillisecondTime();
                skip.rdbLoadLen();
            }
            long consumerCount = skip.rdbLoadLen().len;
            while (consumerCount-- > 0) {
                skip.rdbLoadPlainStringObject();
                skip.rdbLoadMillisecondTime();
                long consumerPel = skip.rdbLoadLen().len;
                while (consumerPel-- > 0) {
                    in.skip(16);
                }
            }
        }
        return null;
    }
    @Override
    public <T> T applyStreamListPacks2(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        long listPacks = skip.rdbLoadLen().len;
        while (listPacks-- > 0) {
            skip.rdbLoadPlainStringObject();
            skip.rdbLoadPlainStringObject();
        }
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        long groupCount = skip.rdbLoadLen().len;
        while (groupCount-- > 0) {
            skip.rdbLoadPlainStringObject();
            skip.rdbLoadLen();
            skip.rdbLoadLen();
            skip.rdbLoadLen();
            long groupPel = skip.rdbLoadLen().len;
            while (groupPel-- > 0) {
                in.skip(16);
                skip.rdbLoadMillisecondTime();
                skip.rdbLoadLen();
            }
            long consumerCount = skip.rdbLoadLen().len;
            while (consumerCount-- > 0) {
                skip.rdbLoadPlainStringObject();
                skip.rdbLoadMillisecondTime();
                long consumerPel = skip.rdbLoadLen().len;
                while (consumerPel-- > 0) {
                    in.skip(16);
                }
            }
        }
        return null;
    }
    @Override
    public <T> T applyStreamListPacks3(RedisInputStream in, int version) throws IOException {
        SkipRdbParser skip = new SkipRdbParser(in);
        long listPacks = skip.rdbLoadLen().len;
        while (listPacks-- > 0) {
            skip.rdbLoadPlainStringObject();
            skip.rdbLoadPlainStringObject();
        }
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        skip.rdbLoadLen();
        long groupCount = skip.rdbLoadLen().len;
        while (groupCount-- > 0) {
            skip.rdbLoadPlainStringObject();
            skip.rdbLoadLen();
            skip.rdbLoadLen();
            skip.rdbLoadLen();
            long groupPel = skip.rdbLoadLen().len;
            while (groupPel-- > 0) {
                in.skip(16);
                skip.rdbLoadMillisecondTime();
                skip.rdbLoadLen();
            }
            long consumerCount = skip.rdbLoadLen().len;
            while (consumerCount-- > 0) {
                skip.rdbLoadPlainStringObject();
                skip.rdbLoadMillisecondTime();
                skip.rdbLoadMillisecondTime();
                long consumerPel = skip.rdbLoadLen().len;
                while (consumerPel-- > 0) {
                    in.skip(16);
                }
            }
        }
        return null;
    }
}
package com.moilioncircle.redis.replicator.rdb.skip;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.BaseRdbParser;
import java.io.IOException;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENC_INT16;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENC_INT32;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENC_INT8;
import static com.moilioncircle.redis.replicator.Constants.RDB_ENC_LZF;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_DOUBLE;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_EOF;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_FLOAT;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_SINT;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_STRING;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_UINT;
public class SkipRdbParser {
    protected final RedisInputStream in;
    public SkipRdbParser(RedisInputStream in) {
        this.in = in;
    }
    public void rdbLoadTime() throws IOException {
        in.skip(4);
    }
    public void rdbLoadMillisecondTime() throws IOException {
        in.skip(8);
    }
    public BaseRdbParser.Len rdbLoadLen() throws IOException {
        return new BaseRdbParser(in).rdbLoadLen();
    }
    public void rdbLoadIntegerObject(int enctype) throws IOException {
        switch (enctype) {
            case RDB_ENC_INT8:
                in.skip(1);
                break;
            case RDB_ENC_INT16:
                in.skip(2);
                break;
            case RDB_ENC_INT32:
                in.skip(4);
                break;
            default:
                break;
        }
    }
    public void rdbLoadLzfStringObject() throws IOException {
        long clen = rdbLoadLen().len;
        rdbLoadLen();
        in.skip(clen);
    }
    public void rdbGenericLoadStringObject() throws IOException {
        BaseRdbParser.Len lenObj = rdbLoadLen();
        long len = (int) lenObj.len;
        boolean isencoded = lenObj.encoded;
        if (isencoded) {
            switch ((int) len) {
                case RDB_ENC_INT8:
                case RDB_ENC_INT16:
                case RDB_ENC_INT32:
                    rdbLoadIntegerObject((int) len);
                    return;
                case RDB_ENC_LZF:
                    rdbLoadLzfStringObject();
                    return;
                default:
                    throw new AssertionError("unknown RdbParser encoding type:" + len);
            }
        }
        in.skip(len);
    }
    public void rdbLoadPlainStringObject() throws IOException {
        rdbGenericLoadStringObject();
    }
    public void rdbLoadEncodedStringObject() throws IOException {
        rdbGenericLoadStringObject();
    }
    public void rdbLoadDoubleValue() throws IOException {
        int len = in.read();
        switch (len) {
            case 255:
            case 254:
            case 253:
                return;
            default:
                in.skip(len);
        }
    }
    public void rdbLoadBinaryDoubleValue() throws IOException {
        in.skip(8);
    }
    public float rdbLoadBinaryFloatValue() throws IOException {
        return in.skip(4);
    }
    public void rdbLoadCheckModuleValue() throws IOException {
        int opcode;
        while ((opcode = (int) rdbLoadLen().len) != RDB_MODULE_OPCODE_EOF) {
            if (opcode == RDB_MODULE_OPCODE_SINT || opcode == RDB_MODULE_OPCODE_UINT) {
                rdbLoadLen();
            } else if (opcode == RDB_MODULE_OPCODE_STRING) {
                rdbGenericLoadStringObject();
            } else if (opcode == RDB_MODULE_OPCODE_FLOAT) {
                rdbLoadBinaryFloatValue();
            } else if (opcode == RDB_MODULE_OPCODE_DOUBLE) {
                rdbLoadBinaryDoubleValue();
            }
        }
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toRune;
import static com.moilioncircle.redis.replicator.util.Strings.isEquals;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.BLMoveCommand;
import com.moilioncircle.redis.replicator.cmd.impl.DirectionType;
public class BLMoveParser implements CommandParser<BLMoveCommand> {
    @Override
    public BLMoveCommand parse(Object[] command) {
        int idx = 1;
        byte[] source = toBytes(command[idx++]);
        byte[] destination = toBytes(command[idx++]);
        DirectionType from = parseDirection(toRune(command[idx++]));
        DirectionType to = parseDirection(toRune(command[idx++]));
        return new BLMoveCommand(source, destination, from, to);
    }
    private DirectionType parseDirection(String direction) {
        if (isEquals(direction, "LEFT")) {
            return DirectionType.LEFT;
        } else if (isEquals(direction, "RIGHT")) {
            return DirectionType.RIGHT;
        } else {
            throw new AssertionError("parse [BLMOVE] command error." + direction);
        }
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.HSetNxCommand;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
public class HSetNxParser implements CommandParser<HSetNxCommand> {
    @Override
    public HSetNxCommand parse(Object[] command) {
        int idx = 1;
        byte[] key = toBytes(command[idx]);
        idx++;
        byte[] field = toBytes(command[idx]);
        idx++;
        byte[] value = toBytes(command[idx]);
        idx++;
        return new HSetNxCommand(key, field, value);
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.AggregateType;
import com.moilioncircle.redis.replicator.cmd.impl.ZInterStoreCommand;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toDouble;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toInt;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toRune;
import static com.moilioncircle.redis.replicator.util.Strings.isEquals;
public class ZInterStoreParser implements CommandParser<ZInterStoreCommand> {
    @Override
    public ZInterStoreCommand parse(Object[] command) {
        int idx = 1;
        AggregateType aggregateType = null;
        byte[] destination = toBytes(command[idx]);
        idx++;
        int numkeys = toInt(command[idx++]);
        byte[][] keys = new byte[numkeys][];
        for (int i = 0; i < numkeys; i++) {
            keys[i] = toBytes(command[idx]);
            idx++;
        }
        double[] weights = null;
        while (idx < command.length) {
            String param = toRune(command[idx]);
            if (isEquals(param, "WEIGHTS")) {
                idx++;
                weights = new double[numkeys];
                for (int i = 0; i < numkeys; i++) {
                    weights[i] = toDouble(command[idx++]);
                }
            }
            if (isEquals(param, "AGGREGATE")) {
                idx++;
                String next = toRune(command[idx++]);
                if (isEquals(next, "SUM")) {
                    aggregateType = AggregateType.SUM;
                } else if (isEquals(next, "MIN")) {
                    aggregateType = AggregateType.MIN;
                } else if (isEquals(next, "MAX")) {
                    aggregateType = AggregateType.MAX;
                }
            }
        }
        return new ZInterStoreCommand(destination, numkeys, keys, weights, aggregateType);
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.ScriptCommand;
import com.moilioncircle.redis.replicator.cmd.impl.ScriptFlushCommand;
import com.moilioncircle.redis.replicator.cmd.impl.ScriptLoadCommand;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toRune;
import static com.moilioncircle.redis.replicator.util.Strings.isEquals;
public class ScriptParser implements CommandParser<ScriptCommand> {
    @Override
    public ScriptCommand parse(Object[] command) {
        int idx = 1;
        String keyword = toRune(command[idx++]);
        boolean isAsync = false;
        boolean isSync = false;
        if (isEquals(keyword, "LOAD")) {
            byte[] script = toBytes(command[idx]);
            idx++;
            return new ScriptLoadCommand(script);
        } else if (isEquals(keyword, "FLUSH")) {
            if (idx >= command.length) {
                return new ScriptFlushCommand(false, false);
            } else {
                String value = toRune(command[idx]);
                if (isEquals(value, "ASYNC")) {
                    isAsync = true;
                } else if (isEquals(value, "SYNC")) {
                    isSync = true;
                }
                return new ScriptFlushCommand(isAsync, isSync);
            }
        }
        throw new AssertionError("SCRIPT " + keyword);
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.BRPopLPushCommand;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toInt;
public class BRPopLPushParser implements CommandParser<BRPopLPushCommand> {
    @Override
    public BRPopLPushCommand parse(Object[] command) {
        int idx = 1;
        byte[] source = toBytes(command[idx]);
        idx++;
        byte[] destination = toBytes(command[idx]);
        idx++;
        int timeout = toInt(command[idx++]);
        return new BRPopLPushCommand(source, destination, timeout);
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.BitOpCommand;
import com.moilioncircle.redis.replicator.cmd.impl.Op;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toRune;
public class BitOpParser implements CommandParser<BitOpCommand> {
    @Override
    public BitOpCommand parse(Object[] command) {
        int idx = 1;
        String strOp = toRune(command[idx++]);
        Op op = Op.valueOf(strOp.toUpperCase());
        byte[] destKey = toBytes(command[idx]);
        idx++;
        byte[][] keys = new byte[command.length - 3][];
        for (int i = idx, j = 0; i < command.length; i++, j++) {
            keys[j] = toBytes(command[i]);
        }
        return new BitOpCommand(op, destKey, keys);
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toDouble;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toInt;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toRune;
import static com.moilioncircle.redis.replicator.util.Strings.isEquals;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.ByBox;
import com.moilioncircle.redis.replicator.cmd.impl.ByRadius;
import com.moilioncircle.redis.replicator.cmd.impl.Count;
import com.moilioncircle.redis.replicator.cmd.impl.FromLonLat;
import com.moilioncircle.redis.replicator.cmd.impl.FromMember;
import com.moilioncircle.redis.replicator.cmd.impl.GeoSearchStoreCommand;
import com.moilioncircle.redis.replicator.cmd.impl.OrderType;
import com.moilioncircle.redis.replicator.cmd.impl.UnitType;
public class GeoSearchStoreParser implements CommandParser<GeoSearchStoreCommand> {
    @Override
    public GeoSearchStoreCommand parse(Object[] command) {
        int idx = 1;
        byte[] destination = toBytes(command[idx++]);
        byte[] source = toBytes(command[idx++]);
        boolean withCoord = false;
        boolean withDist = false;
        boolean withHash = false;
        boolean storeDist = false;
        FromMember fromMember = null;
        FromLonLat fromLonLat = null;
        ByRadius byRadius = null;
        ByBox byBox = null;
        OrderType orderType = OrderType.NONE;
        Count count = null;
        for (int i = idx; i < command.length; i++) {
            String token = toRune(command[i]);
            if (isEquals(token, "FROMMEMBER")) {
                i++;
                fromMember = new FromMember(toBytes(command[i]));
            } else if (isEquals(token, "FROMLONLAT")) {
                i++;
                double longitude = toDouble(command[i]);
                i++;
                double latitude = toDouble(command[i]);
                fromLonLat = new FromLonLat(longitude, latitude);
            } else if (isEquals(token, "BYRADIUS")) {
                i++;
                double radius = toDouble(command[i]);
                i++;
                UnitType unit = parseUnit(toRune(command[i]));
                byRadius = new ByRadius(radius, unit);
            } else if (isEquals(token, "BYBOX")) {
                i++;
                double width = toDouble(command[i]);
                i++;
                double height = toDouble(command[i]);
                i++;
                UnitType unit = parseUnit(toRune(command[i]));
                byBox = new ByBox(width, height, unit);
            } else if (isEquals(token, "ASC")) {
                orderType = OrderType.ASC;
            } else if (isEquals(token, "DESC")) {
                orderType = OrderType.DESC;
            } else if (isEquals(token, "COUNT")) {
                i++;
                count = new Count(toInt(command[i]));
            } else if (isEquals(token, "WITHCOORD")) {
                withCoord = true;
            } else if (isEquals(token, "WITHDIST")) {
                withDist = true;
            } else if (isEquals(token, "WITHHASH")) {
                withHash = true;
            } else if (isEquals(token, "STOREDIST")) {
                storeDist = true;
            } else {
                throw new AssertionError("parse [GEOSEARCHSTORE] command error." + token);
            }
        }
        return new GeoSearchStoreCommand(destination, source, fromMember, fromLonLat, byRadius, byBox, count, orderType, withCoord, withDist, withHash, storeDist);
    }
    private UnitType parseUnit(String token) {
        if (isEquals(token, "M")) {
            return UnitType.M;
        } else if (isEquals(token, "KM")) {
            return UnitType.KM;
        } else if (isEquals(token, "FT")) {
            return UnitType.FT;
        } else if (isEquals(token, "MI")) {
            return UnitType.MI;
        } else {
            throw new AssertionError("parse [GEOSEARCHSTORE] command error." + token);
        }
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toLong;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toRune;
import static com.moilioncircle.redis.replicator.util.Strings.isEquals;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.XGroupCommand;
import com.moilioncircle.redis.replicator.cmd.impl.XGroupCreateCommand;
import com.moilioncircle.redis.replicator.cmd.impl.XGroupCreateConsumerCommand;
import com.moilioncircle.redis.replicator.cmd.impl.XGroupDelConsumerCommand;
import com.moilioncircle.redis.replicator.cmd.impl.XGroupDestroyCommand;
import com.moilioncircle.redis.replicator.cmd.impl.XGroupSetIdCommand;
public class XGroupParser implements CommandParser<XGroupCommand> {
    @Override
    public XGroupCommand parse(Object[] command) {
        int idx = 1;
        String next = toRune(command[idx++]);
        if (isEquals(next, "CREATE")) {
            byte[] key = toBytes(command[idx]);
            idx++;
            byte[] group = toBytes(command[idx]);
            idx++;
            byte[] id = toBytes(command[idx]);
            idx++;
            boolean mkStream = false;
            Long entriesRead = null;
            while (idx < command.length) {
                next = toRune(command[idx++]);
                if (isEquals(next, "MKSTREAM")) {
                    mkStream = true;
                } else if (isEquals(next, "ENTRIESREAD")) {
                    entriesRead = toLong(command[idx++]);
                } else {
                    throw new UnsupportedOperationException(next);
                }
            }
            return new XGroupCreateCommand(key, group, id, mkStream, entriesRead);
        } else if (isEquals(next, "SETID")) {
            byte[] key = toBytes(command[idx]);
            idx++;
            byte[] group = toBytes(command[idx]);
            idx++;
            byte[] id = toBytes(command[idx]);
            idx++;
            Long entriesRead = null;
            while (idx < command.length) {
                next = toRune(command[idx++]);
                if (isEquals(next, "ENTRIESREAD")) {
                    entriesRead = toLong(command[idx++]);
                } else {
                    throw new UnsupportedOperationException(next);
                }
            }
            return new XGroupSetIdCommand(key, group, id, entriesRead);
        } else if (isEquals(next, "DESTROY")) {
            byte[] key = toBytes(command[idx]);
            idx++;
            byte[] group = toBytes(command[idx]);
            idx++;
            return new XGroupDestroyCommand(key, group);
        } else if (isEquals(next, "CREATECONSUMER")) {
            byte[] key = toBytes(command[idx]);
            idx++;
            byte[] group = toBytes(command[idx]);
            idx++;
            byte[] consumer = toBytes(command[idx]);
            idx++;
            return new XGroupCreateConsumerCommand(key, group, consumer);
        } else if (isEquals(next, "DELCONSUMER")) {
            byte[] key = toBytes(command[idx]);
            idx++;
            byte[] group = toBytes(command[idx]);
            idx++;
            byte[] consumer = toBytes(command[idx]);
            idx++;
            return new XGroupDelConsumerCommand(key, group, consumer);
        } else {
            throw new UnsupportedOperationException(next);
        }
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.Limit;
import com.moilioncircle.redis.replicator.cmd.impl.MaxLen;
import com.moilioncircle.redis.replicator.cmd.impl.MinId;
import com.moilioncircle.redis.replicator.cmd.impl.XTrimCommand;
import java.util.Objects;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toLong;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toRune;
import static com.moilioncircle.redis.replicator.util.Strings.isEquals;
public class XTrimParser implements CommandParser<XTrimCommand> {
    @Override
    public XTrimCommand parse(Object[] command) {
        int idx = 1;
        byte[] key = toBytes(command[idx]);
        idx++;
        MaxLen maxLen = null;
        MinId minId = null;
        Limit limit = null;
        for (; idx < command.length; idx++) {
            String token = toRune(command[idx]);
            if (isEquals(token, "MAXLEN")) {
                idx++;
                boolean approximation = false;
                if (Objects.equals(toRune(command[idx]), "~")) {
                    approximation = true;
                    idx++;
                } else if (Objects.equals(toRune(command[idx]), "=")) {
                    idx++;
                }
                long count = toLong(command[idx]);
                maxLen = new MaxLen(approximation, count);
            } else if (isEquals(token, "MINID")) {
                idx++;
                boolean approximation = false;
                if (Objects.equals(toRune(command[idx]), "~")) {
                    approximation = true;
                    idx++;
                } else if (Objects.equals(toRune(command[idx]), "=")) {
                    idx++;
                }
                byte[] mid = toBytes(command[idx]);
                minId = new MinId(approximation, mid);
            } else if (isEquals(token, "LIMIT")) {
                idx++;
                long count = toLong(command[idx]);
                limit = new Limit(0, count);
            }
        }
        return new XTrimCommand(key, maxLen, minId, limit);
    }
}
package com.moilioncircle.redis.replicator.cmd.parser;
import com.moilioncircle.redis.replicator.cmd.CommandParser;
import com.moilioncircle.redis.replicator.cmd.impl.RPopLPushCommand;
import static com.moilioncircle.redis.replicator.cmd.CommandParsers.toBytes;
public class RPopLPushParser implements CommandParser<RPopLPushCommand> {
    @Override
    public RPopLPushCommand parse(Object[] command) {
        int idx = 1;
        byte[] source = toBytes(command[idx]);
        idx++;
        byte[] destination = toBytes(command[idx]);
        idx++;
        return new RPopLPushCommand(source, destination);
    }
}
package com.moilioncircle.redis.replicator.rdb.dump;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPMAP;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_INTSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_3;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STRING;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_ZIPLIST;
import java.io.IOException;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.event.Event;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.BaseRdbParser;
import com.moilioncircle.redis.replicator.rdb.DefaultRdbVisitor;
import com.moilioncircle.redis.replicator.rdb.RdbValueVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.ContextKeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePair;
import com.moilioncircle.redis.replicator.rdb.dump.datatype.DumpKeyValuePair;
public class DumpRdbVisitor extends DefaultRdbVisitor {
    protected int version = -1;
    public DumpRdbVisitor(Replicator replicator) {
        this(replicator, -1);
    }
    public DumpRdbVisitor(Replicator replicator, int version) {
        this(replicator, version, 8192);
    }
    public DumpRdbVisitor(Replicator replicator, int version, int size) {
        super(replicator, new DumpRdbValueVisitor(replicator, version, size));
        this.version = version;
    }
    public DumpRdbVisitor(Replicator replicator, RdbValueVisitor valueVisitor) {
        super(replicator, valueVisitor);
    }
    @Override
    public Event applyString(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o0 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o0.setValueRdbType(RDB_TYPE_STRING);
        o0.setKey(key);
        o0.setValue(valueVisitor.applyString(in, version));
        return context.valueOf(o0);
    }
    @Override
    public Event applyList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o1 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o1.setValueRdbType(RDB_TYPE_LIST);
        o1.setKey(key);
        o1.setValue(valueVisitor.applyList(in, version));
        return context.valueOf(o1);
    }
    @Override
    public Event applySet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o2 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o2.setValueRdbType(RDB_TYPE_SET);
        o2.setKey(key);
        o2.setValue(valueVisitor.applySet(in, version));
        return context.valueOf(o2);
    }
    @Override
    public Event applySetListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o20 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        if (this.version != -1 && this.version < 11 ) {
            o20.setValueRdbType(RDB_TYPE_SET);
        } else {
            o20.setValueRdbType(RDB_TYPE_SET_LISTPACK);
        }
        o20.setKey(key);
        o20.setValue(valueVisitor.applySetListPack(in, version));
        return context.valueOf(o20);
    }
    @Override
    public Event applyZSet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o3 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o3.setValueRdbType(RDB_TYPE_ZSET);
        o3.setKey(key);
        o3.setValue(valueVisitor.applyZSet(in, version));
        return context.valueOf(o3);
    }
    @Override
    public Event applyZSet2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o5 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        if (this.version != -1 && this.version < 8 ) {
            o5.setValueRdbType(RDB_TYPE_ZSET);
        } else {
            o5.setValueRdbType(RDB_TYPE_ZSET_2);
        }
        o5.setKey(key);
        o5.setValue(valueVisitor.applyZSet2(in, version));
        return context.valueOf(o5);
    }
    @Override
    public Event applyHash(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o4 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o4.setValueRdbType(RDB_TYPE_HASH);
        o4.setKey(key);
        o4.setValue(valueVisitor.applyHash(in, version));
        return context.valueOf(o4);
    }
    @Override
    public Event applyHashZipMap(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o9 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o9.setValueRdbType(RDB_TYPE_HASH_ZIPMAP);
        o9.setKey(key);
        o9.setValue(valueVisitor.applyHashZipMap(in, version));
        return context.valueOf(o9);
    }
    @Override
    public Event applyListZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o10 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o10.setValueRdbType(RDB_TYPE_LIST_ZIPLIST);
        o10.setKey(key);
        o10.setValue(valueVisitor.applyListZipList(in, version));
        return context.valueOf(o10);
    }
    @Override
    public Event applySetIntSet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o11 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o11.setValueRdbType(RDB_TYPE_SET_INTSET);
        o11.setKey(key);
        o11.setValue(valueVisitor.applySetIntSet(in, version));
        return context.valueOf(o11);
    }
    @Override
    public Event applyZSetZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o12 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o12.setValueRdbType(RDB_TYPE_ZSET_ZIPLIST);
        o12.setKey(key);
        o12.setValue(valueVisitor.applyZSetZipList(in, version));
        return context.valueOf(o12);
    }
    @Override
    public Event applyZSetListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o17 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        if (this.version != -1 && this.version < 10 ) {
            o17.setValueRdbType(RDB_TYPE_ZSET);
        } else {
            o17.setValueRdbType(RDB_TYPE_ZSET_LISTPACK);
        }
        o17.setKey(key);
        o17.setValue(valueVisitor.applyZSetListPack(in, version));
        return context.valueOf(o17);
    }
    @Override
    public Event applyHashZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o13 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o13.setValueRdbType(RDB_TYPE_HASH_ZIPLIST);
        o13.setKey(key);
        o13.setValue(valueVisitor.applyHashZipList(in, version));
        return context.valueOf(o13);
    }
    @Override
    public Event applyHashListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o16 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        if (this.version != -1 && this.version < 10 ) {
            o16.setValueRdbType(RDB_TYPE_HASH);
        } else {
            o16.setValueRdbType(RDB_TYPE_HASH_LISTPACK);
        }
        o16.setKey(key);
        o16.setValue(valueVisitor.applyHashListPack(in, version));
        return context.valueOf(o16);
    }
    @Override
    public Event applyListQuickList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o14 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        if (this.version != -1 && this.version < 7 ) {
            o14.setValueRdbType(RDB_TYPE_LIST);
        } else {
            o14.setValueRdbType(RDB_TYPE_LIST_QUICKLIST);
        }
        o14.setKey(key);
        o14.setValue(valueVisitor.applyListQuickList(in, version));
        return context.valueOf(o14);
    }
    @Override
    public Event applyListQuickList2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o18 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        if (this.version != -1 && this.version < 10 ) {
            o18.setValueRdbType(RDB_TYPE_LIST);
        } else {
            o18.setValueRdbType(RDB_TYPE_LIST_QUICKLIST_2);
        }
        o18.setKey(key);
        o18.setValue(valueVisitor.applyListQuickList2(in, version));
        return context.valueOf(o18);
    }
    @Override
    public Event applyModule(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o6 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o6.setValueRdbType(RDB_TYPE_MODULE);
        o6.setKey(key);
        o6.setValue(valueVisitor.applyModule(in, version));
        return context.valueOf(o6);
    }
    @Override
    public Event applyModule2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o7 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o7.setValueRdbType(RDB_TYPE_MODULE_2);
        o7.setKey(key);
        o7.setValue(valueVisitor.applyModule2(in, version));
        return context.valueOf(o7);
    }
    @Override
    public Event applyStreamListPacks(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o15 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o15.setValueRdbType(RDB_TYPE_STREAM_LISTPACKS);
        o15.setKey(key);
        o15.setValue(valueVisitor.applyStreamListPacks(in, version));
        return context.valueOf(o15);
    }
    @Override
    public Event applyStreamListPacks2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o19 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        if (this.version != -1 && this.version < 10 ) {
            o19.setValueRdbType(RDB_TYPE_STREAM_LISTPACKS);
        } else {
            o19.setValueRdbType(RDB_TYPE_STREAM_LISTPACKS_2);
        }
        o19.setKey(key);
        o19.setValue(valueVisitor.applyStreamListPacks2(in, version));
        return context.valueOf(o19);
    }
    @Override
    public Event applyStreamListPacks3(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], byte[]> o21 = new DumpKeyValuePair();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        if (this.version != -1 && this.version < 11 ) {
            o21.setValueRdbType(RDB_TYPE_STREAM_LISTPACKS);
        } else {
            o21.setValueRdbType(RDB_TYPE_STREAM_LISTPACKS_3);
        }
        o21.setKey(key);
        o21.setValue(valueVisitor.applyStreamListPacks3(in, version));
        return context.valueOf(o21);
    }
}
package com.moilioncircle.redis.replicator.rdb.dump;
import static com.moilioncircle.redis.replicator.Constants.MODULE_SET;
import static com.moilioncircle.redis.replicator.Constants.QUICKLIST_NODE_CONTAINER_PACKED;
import static com.moilioncircle.redis.replicator.Constants.QUICKLIST_NODE_CONTAINER_PLAIN;
import static com.moilioncircle.redis.replicator.Constants.RDB_LOAD_NONE;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_EOF;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FUNCTION;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FUNCTION2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPMAP;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_INTSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_3;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STRING;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_ZIPLIST;
import static com.moilioncircle.redis.replicator.rdb.BaseRdbParser.StringHelper.listPackEntry;
import static com.moilioncircle.redis.replicator.util.CRC64.crc64;
import static com.moilioncircle.redis.replicator.util.CRC64.longToByteArray;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.NoSuchElementException;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.io.ByteBufferOutputStream;
import com.moilioncircle.redis.replicator.io.RawByteListener;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.BaseRdbEncoder;
import com.moilioncircle.redis.replicator.rdb.BaseRdbParser;
import com.moilioncircle.redis.replicator.rdb.DefaultRdbValueVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.Module;
import com.moilioncircle.redis.replicator.rdb.dump.datatype.DumpFunction;
import com.moilioncircle.redis.replicator.rdb.module.ModuleParser;
import com.moilioncircle.redis.replicator.rdb.skip.SkipRdbParser;
import com.moilioncircle.redis.replicator.util.ByteArray;
import com.moilioncircle.redis.replicator.util.ByteBuilder;
import com.moilioncircle.redis.replicator.util.Strings;
@SuppressWarnings("unchecked")
public class DumpRdbValueVisitor extends DefaultRdbValueVisitor {
    private class DefaultRawByteListener implements RawByteListener {
        private final int version;
        private final ByteBuilder builder;
        private DefaultRawByteListener(byte type, int version) {
            this.builder = ByteBuilder.allocate(DumpRdbValueVisitor.this.size);
            this.builder.put(type);
            int ver = DumpRdbValueVisitor.this.version;
            this.version = ver == -1 ? version : ver;
        }
        @Override
        public void handle(byte... rawBytes) {
            this.builder.put(rawBytes);
        }
        public void handle(ByteBuffer buffer) {
            this.builder.put(buffer);
        }
        public byte[] getBytes() {
            this.builder.put((byte) version);
            this.builder.put((byte) 0x00);
            List<ByteBuffer> buffers = this.builder.buffers();
            byte[] crc = longToByteArray(crc64(buffers));
            for (byte b : crc) {
                this.builder.put(b);
            }
            return this.builder.array();
        }
    }
    private final int size;
    private final int version;
    public DumpRdbValueVisitor(Replicator replicator) {
        this(replicator, -1);
    }
    public DumpRdbValueVisitor(Replicator replicator, int version) {
        this(replicator, version, 8192);
    }
    public DumpRdbValueVisitor(Replicator replicator, int version, int size) {
        super(replicator);
        this.version = version;
        this.size = size;
    }
    @Override
    public <T> T applyFunction(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_OPCODE_FUNCTION, version);
        replicator.addRawByteListener(listener);
        try {
            SkipRdbParser parser = new SkipRdbParser(in);
            parser.rdbGenericLoadStringObject(); 
            parser.rdbGenericLoadStringObject(); 
            long hasDesc = parser.rdbLoadLen().len;
            if (hasDesc == 1) {
                parser.rdbGenericLoadStringObject(); 
            }
            parser.rdbGenericLoadStringObject(); 
        } finally {
            replicator.removeRawByteListener(listener);
        }
        DumpFunction function = new DumpFunction();
        function.setSerialized(listener.getBytes());
        return (T) function;
    }
    @Override
    public <T> T applyFunction2(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_OPCODE_FUNCTION2, version);
        replicator.addRawByteListener(listener);
        try {
            SkipRdbParser parser = new SkipRdbParser(in);
            parser.rdbGenericLoadStringObject(); 
        } finally {
            replicator.removeRawByteListener(listener);
        }
        DumpFunction function = new DumpFunction();
        function.setSerialized(listener.getBytes());
        return (T) function;
    }
    @Override
    public <T> T applyString(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_STRING, version);
        replicator.addRawByteListener(listener);
        try {
            new SkipRdbParser(in).rdbLoadEncodedStringObject();
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applyList(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_LIST, version);
        replicator.addRawByteListener(listener);
        try {
            SkipRdbParser skipParser = new SkipRdbParser(in);
            long len = skipParser.rdbLoadLen().len;
            while (len > 0) {
                skipParser.rdbLoadEncodedStringObject();
                len--;
            }
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applySet(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_SET, version);
        replicator.addRawByteListener(listener);
        try {
            SkipRdbParser skipParser = new SkipRdbParser(in);
            long len = skipParser.rdbLoadLen().len;
            while (len > 0) {
                skipParser.rdbLoadEncodedStringObject();
                len--;
            }
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applySetListPack(RedisInputStream in, int version) throws IOException {
        if (this.version != -1 && this.version < 11 ) {
            BaseRdbParser parser = new BaseRdbParser(in);
            BaseRdbEncoder encoder = new BaseRdbEncoder();
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_SET, version);
            try (ByteBufferOutputStream out = new ByteBufferOutputStream(size)) {
                RedisInputStream listPack = new RedisInputStream(parser.rdbLoadPlainStringObject());
                listPack.skip(4); 
                int len = listPack.readInt(2);
                listener.handle(encoder.rdbSaveLen(len));
                while (len > 0) {
                    byte[] element = listPackEntry(listPack);
                    encoder.rdbGenericSaveStringObject(new ByteArray(element), out);
                    len--;
                }
                int lpend = listPack.read(); 
                if (lpend != 255) {
                    throw new AssertionError("listpack expect 255 but " + lpend);
                }
                listener.handle(out.toByteBuffer());
                return (T) listener.getBytes();
            }
        } else {
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_SET_LISTPACK, version);
            replicator.addRawByteListener(listener);
            try {
                SkipRdbParser skipParser = new SkipRdbParser(in);
                skipParser.rdbLoadPlainStringObject();
            } finally {
                replicator.removeRawByteListener(listener);
            }
            return (T) listener.getBytes();
        }
    }
    @Override
    public <T> T applyZSet(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_ZSET, version);
        replicator.addRawByteListener(listener);
        try {
            SkipRdbParser skipParser = new SkipRdbParser(in);
            long len = skipParser.rdbLoadLen().len;
            while (len > 0) {
                skipParser.rdbLoadEncodedStringObject();
                skipParser.rdbLoadDoubleValue();
                len--;
            }
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applyZSet2(RedisInputStream in, int version) throws IOException {
        if (this.version != -1 && this.version < 8 ) {
            BaseRdbParser parser = new BaseRdbParser(in);
            BaseRdbEncoder encoder = new BaseRdbEncoder();
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_ZSET, version);
            try (ByteBufferOutputStream out = new ByteBufferOutputStream(size)) {
                long len = parser.rdbLoadLen().len;
                listener.handle(encoder.rdbSaveLen(len));
                while (len > 0) {
                    ByteArray element = parser.rdbLoadEncodedStringObject();
                    encoder.rdbGenericSaveStringObject(element, out);
                    double score = parser.rdbLoadBinaryDoubleValue();
                    encoder.rdbSaveDoubleValue(score, out);
                    len--;
                }
                listener.handle(out.toByteBuffer());
                return (T) listener.getBytes();
            }
        } else {
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_ZSET_2, version);
            replicator.addRawByteListener(listener);
            try {
                SkipRdbParser skipParser = new SkipRdbParser(in);
                long len = skipParser.rdbLoadLen().len;
                while (len > 0) {
                    skipParser.rdbLoadEncodedStringObject();
                    skipParser.rdbLoadBinaryDoubleValue();
                    len--;
                }
            } finally {
                replicator.removeRawByteListener(listener);
            }
            return (T) listener.getBytes();
        }
    }
    @Override
    public <T> T applyHash(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_HASH, version);
        replicator.addRawByteListener(listener);
        try {
            SkipRdbParser skipParser = new SkipRdbParser(in);
            long len = skipParser.rdbLoadLen().len;
            while (len > 0) {
                skipParser.rdbLoadEncodedStringObject();
                skipParser.rdbLoadEncodedStringObject();
                len--;
            }
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applyHashZipMap(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_HASH_ZIPMAP, version);
        replicator.addRawByteListener(listener);
        try {
            new SkipRdbParser(in).rdbLoadPlainStringObject();
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applyListZipList(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_LIST_ZIPLIST, version);
        replicator.addRawByteListener(listener);
        try {
            new SkipRdbParser(in).rdbLoadPlainStringObject();
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applySetIntSet(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_SET_INTSET, version);
        replicator.addRawByteListener(listener);
        try {
            new SkipRdbParser(in).rdbLoadPlainStringObject();
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applyZSetZipList(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_ZSET_ZIPLIST, version);
        replicator.addRawByteListener(listener);
        try {
            new SkipRdbParser(in).rdbLoadPlainStringObject();
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applyZSetListPack(RedisInputStream in, int version) throws IOException {
        if (this.version != -1 && this.version < 10 ) {
            BaseRdbParser parser = new BaseRdbParser(in);
            BaseRdbEncoder encoder = new BaseRdbEncoder();
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_ZSET, version);
            try (ByteBufferOutputStream out = new ByteBufferOutputStream(size)) {
                RedisInputStream listPack = new RedisInputStream(parser.rdbLoadPlainStringObject());
                listPack.skip(4); 
                int len = listPack.readInt(2);
                listener.handle(encoder.rdbSaveLen(len / 2));
                while (len > 0) {
                    byte[] element = listPackEntry(listPack);
                    encoder.rdbGenericSaveStringObject(new ByteArray(element), out);
                    len--;
                    double score = Double.valueOf(Strings.toString(listPackEntry(listPack)));
                    encoder.rdbSaveDoubleValue(score, out);
                    len--;
                }
                int lpend = listPack.read(); 
                if (lpend != 255) {
                    throw new AssertionError("listpack expect 255 but " + lpend);
                }
                listener.handle(out.toByteBuffer());
                return (T) listener.getBytes();
            }
        } else {
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_ZSET_LISTPACK, version);
            replicator.addRawByteListener(listener);
            try {
                SkipRdbParser skipParser = new SkipRdbParser(in);
                skipParser.rdbLoadPlainStringObject();
            } finally {
                replicator.removeRawByteListener(listener);
            }
            return (T) listener.getBytes();
        }
    }
    @Override
    public <T> T applyHashZipList(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_HASH_ZIPLIST, version);
        replicator.addRawByteListener(listener);
        try {
            new SkipRdbParser(in).rdbLoadPlainStringObject();
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applyHashListPack(RedisInputStream in, int version) throws IOException {
        if (this.version != -1 && this.version < 10 ) {
            BaseRdbParser parser = new BaseRdbParser(in);
            BaseRdbEncoder encoder = new BaseRdbEncoder();
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_HASH, version);
            try (ByteBufferOutputStream out = new ByteBufferOutputStream(size)) {
                RedisInputStream listPack = new RedisInputStream(parser.rdbLoadPlainStringObject());
                listPack.skip(4); 
                int len = listPack.readInt(2);
                listener.handle(encoder.rdbSaveLen(len / 2));
                while (len > 0) {
                    byte[] field = listPackEntry(listPack);
                    encoder.rdbGenericSaveStringObject(new ByteArray(field), out);
                    len--;
                    byte[] value = listPackEntry(listPack);
                    encoder.rdbGenericSaveStringObject(new ByteArray(value), out);
                    len--;
                }
                int lpend = listPack.read(); 
                if (lpend != 255) {
                    throw new AssertionError("listpack expect 255 but " + lpend);
                }
                listener.handle(out.toByteBuffer());
                return (T) listener.getBytes();
            }
        } else {
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_HASH_LISTPACK, version);
            replicator.addRawByteListener(listener);
            try {
                SkipRdbParser skipParser = new SkipRdbParser(in);
                skipParser.rdbLoadPlainStringObject();
            } finally {
                replicator.removeRawByteListener(listener);
            }
            return (T) listener.getBytes();
        }
    }
    @Override
    public <T> T applyListQuickList(RedisInputStream in, int version) throws IOException {
        if (this.version != -1 && this.version < 7 ) {
            BaseRdbParser parser = new BaseRdbParser(in);
            BaseRdbEncoder encoder = new BaseRdbEncoder();
            try (ByteBufferOutputStream out = new ByteBufferOutputStream(size)) {
                int total = 0;
                long len = parser.rdbLoadLen().len;
                for (long i = 0; i < len; i++) {
                    RedisInputStream stream = new RedisInputStream(parser.rdbGenericLoadStringObject(RDB_LOAD_NONE));
                    BaseRdbParser.LenHelper.zlbytes(stream); 
                    BaseRdbParser.LenHelper.zltail(stream); 
                    int zllen = BaseRdbParser.LenHelper.zllen(stream);
                    for (int j = 0; j < zllen; j++) {
                        byte[] e = BaseRdbParser.StringHelper.zipListEntry(stream);
                        encoder.rdbGenericSaveStringObject(new ByteArray(e), out);
                        total++;
                    }
                    int zlend = BaseRdbParser.LenHelper.zlend(stream);
                    if (zlend != 255) {
                        throw new AssertionError("zlend expect 255 but " + zlend);
                    }
                }
                DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_LIST, version);
                listener.handle(encoder.rdbSaveLen(total));
                listener.handle(out.toByteBuffer());
                return (T) listener.getBytes();
            }
        } else {
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_LIST_QUICKLIST, version);
            replicator.addRawByteListener(listener);
            try {
                SkipRdbParser skipParser = new SkipRdbParser(in);
                long len = skipParser.rdbLoadLen().len;
                for (long i = 0; i < len; i++) {
                    skipParser.rdbGenericLoadStringObject();
                }
            } finally {
                replicator.removeRawByteListener(listener);
            }
            return (T) listener.getBytes();
        }
    }
    @Override
    public <T> T applyListQuickList2(RedisInputStream in, int version) throws IOException {
        if (this.version != -1 && this.version < 10 ) {
            BaseRdbParser parser = new BaseRdbParser(in);
            BaseRdbEncoder encoder = new BaseRdbEncoder();
            try (ByteBufferOutputStream out = new ByteBufferOutputStream(size)) {
                int total = 0;
                long len = parser.rdbLoadLen().len;
                for (long i = 0; i < len; i++) {
                    long container = parser.rdbLoadLen().len;
                    ByteArray bytes = parser.rdbLoadPlainStringObject();
                    if (container == QUICKLIST_NODE_CONTAINER_PLAIN) {
                        encoder.rdbGenericSaveStringObject(new ByteArray(bytes.first()), out);
                        total++;
                    } else if (container == QUICKLIST_NODE_CONTAINER_PACKED) {
                        RedisInputStream listPack = new RedisInputStream(bytes);
                        listPack.skip(4); 
                        int innerLen = listPack.readInt(2);
                        for (int j = 0; j < innerLen; j++) {
                            byte[] e = listPackEntry(listPack);
                            encoder.rdbGenericSaveStringObject(new ByteArray(e), out);
                            total++;
                        }
                        int lpend = listPack.read(); 
                        if (lpend != 255) {
                            throw new AssertionError("listpack expect 255 but " + lpend);
                        }
                    } else {
                        throw new UnsupportedOperationException(String.valueOf(container));
                    }
                }
                DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_LIST, version);
                listener.handle(encoder.rdbSaveLen(total));
                listener.handle(out.toByteBuffer());
                return (T) listener.getBytes();
            }
        } else {
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_LIST_QUICKLIST_2, version);
            replicator.addRawByteListener(listener);
            try {
                SkipRdbParser skipParser = new SkipRdbParser(in);
                long len = skipParser.rdbLoadLen().len;
                for (long i = 0; i < len; i++) {
                    skipParser.rdbLoadLen();
                    skipParser.rdbLoadPlainStringObject();
                }
            } finally {
                replicator.removeRawByteListener(listener);
            }
            return (T) listener.getBytes();
        }
    }
    @Override
    public <T> T applyModule(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_MODULE, version);
        replicator.addRawByteListener(listener);
        try {
            SkipRdbParser skipParser = new SkipRdbParser(in);
            char[] c = new char[9];
            long moduleid = skipParser.rdbLoadLen().len;
            for (int i = 0; i < c.length; i++) {
                c[i] = MODULE_SET[(int) (moduleid >>> (10 + (c.length - 1 - i) * 6) & 63)];
            }
            String moduleName = new String(c);
            int moduleVersion = (int) (moduleid & 1023);
            ModuleParser<? extends Module> moduleParser = lookupModuleParser(moduleName, moduleVersion);
            if (moduleParser == null) {
                throw new NoSuchElementException("module parser[" + moduleName + ", " + moduleVersion + "] not register. rdb type: [RDB_TYPE_MODULE]");
            }
            moduleParser.parse(in, 1);
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    public <T> T applyModule2(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_MODULE_2, version);
        replicator.addRawByteListener(listener);
        try {
            BaseRdbParser parser = new BaseRdbParser(in);
            SkipRdbParser skipParser = new SkipRdbParser(in);
            char[] c = new char[9];
            long moduleid = skipParser.rdbLoadLen().len;
            for (int i = 0; i < c.length; i++) {
                c[i] = MODULE_SET[(int) (moduleid >>> (10 + (c.length - 1 - i) * 6) & 63)];
            }
            String moduleName = new String(c);
            int moduleVersion = (int) (moduleid & 1023);
            ModuleParser<? extends Module> moduleParser = lookupModuleParser(moduleName, moduleVersion);
            if (moduleParser == null) {
                SkipRdbParser skipRdbParser = new SkipRdbParser(in);
                skipRdbParser.rdbLoadCheckModuleValue();
            } else {
                moduleParser.parse(in, 2);
                long eof = parser.rdbLoadLen().len;
                if (eof != RDB_MODULE_OPCODE_EOF) {
                    throw new UnsupportedOperationException("The RDB file contains module data for the module '" + moduleName + "' that is not terminated by the proper module value EOF marker");
                }
            }
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    @SuppressWarnings("resource")
    public <T> T applyStreamListPacks(RedisInputStream in, int version) throws IOException {
        DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_STREAM_LISTPACKS, version);
        replicator.addRawByteListener(listener);
        try {
            SkipRdbParser skipParser = new SkipRdbParser(in);
            long listPacks = skipParser.rdbLoadLen().len;
            while (listPacks-- > 0) {
                skipParser.rdbLoadPlainStringObject();
                skipParser.rdbLoadPlainStringObject();
            }
            skipParser.rdbLoadLen();
            skipParser.rdbLoadLen();
            skipParser.rdbLoadLen();
            long groupCount = skipParser.rdbLoadLen().len;
            while (groupCount-- > 0) {
                skipParser.rdbLoadPlainStringObject();
                skipParser.rdbLoadLen();
                skipParser.rdbLoadLen();
                long groupPel = skipParser.rdbLoadLen().len;
                while (groupPel-- > 0) {
                    in.skip(16);
                    skipParser.rdbLoadMillisecondTime();
                    skipParser.rdbLoadLen();
                }
                long consumerCount = skipParser.rdbLoadLen().len;
                while (consumerCount-- > 0) {
                    skipParser.rdbLoadPlainStringObject();
                    skipParser.rdbLoadMillisecondTime();
                    long consumerPel = skipParser.rdbLoadLen().len;
                    while (consumerPel-- > 0) {
                        in.skip(16);
                    }
                }
            }
        } finally {
            replicator.removeRawByteListener(listener);
        }
        return (T) listener.getBytes();
    }
    @Override
    @SuppressWarnings("resource")
    public <T> T applyStreamListPacks2(RedisInputStream in, int version) throws IOException {
        if (this.version != -1 && this.version < 10 ) {
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_STREAM_LISTPACKS, version);
            replicator.addRawByteListener(listener);
            try {
                SkipRdbParser skipParser = new SkipRdbParser(in);
                long listPacks = skipParser.rdbLoadLen().len;
                while (listPacks-- > 0) {
                    skipParser.rdbLoadPlainStringObject();
                    skipParser.rdbLoadPlainStringObject();
                }
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                replicator.removeRawByteListener(listener);
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                replicator.addRawByteListener(listener);
                long groupCount = skipParser.rdbLoadLen().len;
                while (groupCount-- > 0) {
                    skipParser.rdbLoadPlainStringObject();
                    skipParser.rdbLoadLen();
                    skipParser.rdbLoadLen();
                    replicator.removeRawByteListener(listener);
                    skipParser.rdbLoadLen(); 
                    replicator.addRawByteListener(listener);
                    long groupPel = skipParser.rdbLoadLen().len;
                    while (groupPel-- > 0) {
                        in.skip(16);
                        skipParser.rdbLoadMillisecondTime();
                        skipParser.rdbLoadLen();
                    }
                    long consumerCount = skipParser.rdbLoadLen().len;
                    while (consumerCount-- > 0) {
                        skipParser.rdbLoadPlainStringObject();
                        skipParser.rdbLoadMillisecondTime();
                        long consumerPel = skipParser.rdbLoadLen().len;
                        while (consumerPel-- > 0) {
                            in.skip(16);
                        }
                    }
                }
            } finally {
                replicator.removeRawByteListener(listener);
            }
            return (T) listener.getBytes();
        } else {
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_STREAM_LISTPACKS_2, version);
            replicator.addRawByteListener(listener);
            try {
                SkipRdbParser skipParser = new SkipRdbParser(in);
                long listPacks = skipParser.rdbLoadLen().len;
                while (listPacks-- > 0) {
                    skipParser.rdbLoadPlainStringObject();
                    skipParser.rdbLoadPlainStringObject();
                }
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                long groupCount = skipParser.rdbLoadLen().len;
                while (groupCount-- > 0) {
                    skipParser.rdbLoadPlainStringObject();
                    skipParser.rdbLoadLen();
                    skipParser.rdbLoadLen();
                    skipParser.rdbLoadLen(); 
                    long groupPel = skipParser.rdbLoadLen().len;
                    while (groupPel-- > 0) {
                        in.skip(16);
                        skipParser.rdbLoadMillisecondTime();
                        skipParser.rdbLoadLen();
                    }
                    long consumerCount = skipParser.rdbLoadLen().len;
                    while (consumerCount-- > 0) {
                        skipParser.rdbLoadPlainStringObject();
                        skipParser.rdbLoadMillisecondTime();
                        long consumerPel = skipParser.rdbLoadLen().len;
                        while (consumerPel-- > 0) {
                            in.skip(16);
                        }
                    }
                }
            } finally {
                replicator.removeRawByteListener(listener);
            }
            return (T) listener.getBytes();
        }
    }
    @Override
    @SuppressWarnings("resource")
    public <T> T applyStreamListPacks3(RedisInputStream in, int version) throws IOException {
        if (this.version != -1 && this.version < 11 ) {
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_STREAM_LISTPACKS, version);
            replicator.addRawByteListener(listener);
            try {
                SkipRdbParser skipParser = new SkipRdbParser(in);
                long listPacks = skipParser.rdbLoadLen().len;
                while (listPacks-- > 0) {
                    skipParser.rdbLoadPlainStringObject();
                    skipParser.rdbLoadPlainStringObject();
                }
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                replicator.removeRawByteListener(listener);
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                replicator.addRawByteListener(listener);
                long groupCount = skipParser.rdbLoadLen().len;
                while (groupCount-- > 0) {
                    skipParser.rdbLoadPlainStringObject();
                    skipParser.rdbLoadLen();
                    skipParser.rdbLoadLen();
                    replicator.removeRawByteListener(listener);
                    skipParser.rdbLoadLen(); 
                    replicator.addRawByteListener(listener);
                    long groupPel = skipParser.rdbLoadLen().len;
                    while (groupPel-- > 0) {
                        in.skip(16);
                        skipParser.rdbLoadMillisecondTime();
                        skipParser.rdbLoadLen();
                    }
                    long consumerCount = skipParser.rdbLoadLen().len;
                    while (consumerCount-- > 0) {
                        skipParser.rdbLoadPlainStringObject();
                        skipParser.rdbLoadMillisecondTime(); 
                        replicator.removeRawByteListener(listener);
                        skipParser.rdbLoadMillisecondTime(); 
                        replicator.addRawByteListener(listener);
                        long consumerPel = skipParser.rdbLoadLen().len;
                        while (consumerPel-- > 0) {
                            in.skip(16);
                        }
                    }
                }
            } finally {
                replicator.removeRawByteListener(listener);
            }
            return (T) listener.getBytes();
        } else {
            DefaultRawByteListener listener = new DefaultRawByteListener((byte) RDB_TYPE_STREAM_LISTPACKS_3, version);
            replicator.addRawByteListener(listener);
            try {
                SkipRdbParser skipParser = new SkipRdbParser(in);
                long listPacks = skipParser.rdbLoadLen().len;
                while (listPacks-- > 0) {
                    skipParser.rdbLoadPlainStringObject();
                    skipParser.rdbLoadPlainStringObject();
                }
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                skipParser.rdbLoadLen(); 
                long groupCount = skipParser.rdbLoadLen().len;
                while (groupCount-- > 0) {
                    skipParser.rdbLoadPlainStringObject();
                    skipParser.rdbLoadLen();
                    skipParser.rdbLoadLen();
                    skipParser.rdbLoadLen(); 
                    long groupPel = skipParser.rdbLoadLen().len;
                    while (groupPel-- > 0) {
                        in.skip(16);
                        skipParser.rdbLoadMillisecondTime();
                        skipParser.rdbLoadLen();
                    }
                    long consumerCount = skipParser.rdbLoadLen().len;
                    while (consumerCount-- > 0) {
                        skipParser.rdbLoadPlainStringObject();
                        skipParser.rdbLoadMillisecondTime(); 
                        skipParser.rdbLoadMillisecondTime(); 
                        long consumerPel = skipParser.rdbLoadLen().len;
                        while (consumerPel-- > 0) {
                            in.skip(16);
                        }
                    }
                }
            } finally {
                replicator.removeRawByteListener(listener);
            }
            return (T) listener.getBytes();
        }
    }
}
package com.moilioncircle.redis.replicator.event;
import com.moilioncircle.redis.replicator.Replicator;
@FunctionalInterface
public interface EventListener {
    void onEvent(Replicator replicator, Event event);
}
package com.moilioncircle.redis.replicator.event;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import com.moilioncircle.redis.replicator.util.type.Tuple2;
public abstract class AbstractEvent implements Event {
    protected Context context = new ContextImpl();
    public Context getContext() {
        return context;
    }
    public void setContext(Context context) {
        this.context = context;
    }
    private static class ContextImpl implements Context {
        private static final long serialVersionUID = 1L;
        private Tuple2<Long, Long> offsets;
        private ConcurrentMap<Object, Object> cookies = new ConcurrentHashMap<>(4);
        @Override
        public Tuple2<Long, Long> getOffsets() {
            return offsets;
        }
        @Override
        public void setOffsets(Tuple2<Long, Long> offset) {
            this.offsets = offset;
        }
        @Override
        public Object getCookie(Object key) {
            return cookies.get(key);
        }
        @Override
        public Object setCookie(Object key, Object value) {
            return cookies.put(key, value);
        }
    }
}
package com.moilioncircle.redis.replicator.event;
import java.io.Serializable;
import com.moilioncircle.redis.replicator.util.type.Tuple2;
public interface Event extends Serializable {
    interface Context extends Serializable {
        Tuple2<Long, Long> getOffsets();
        void setOffsets(Tuple2<Long, Long> offset);
        default Object getCookie(Object key) {
            throw new UnsupportedOperationException();
        }
        default Object setCookie(Object key, Object value) {
            throw new UnsupportedOperationException();
        }
    }
}
package com.moilioncircle.redis.replicator.rdb.dump.parser;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FUNCTION;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FUNCTION2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPMAP;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_INTSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_3;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STRING;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_ZIPLIST;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.Objects;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.event.EventListener;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.RdbValueVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.Function;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePairs;
import com.moilioncircle.redis.replicator.rdb.dump.datatype.DumpFunction;
import com.moilioncircle.redis.replicator.rdb.dump.datatype.DumpKeyValuePair;
import com.moilioncircle.redis.replicator.rdb.iterable.ValueIterableEventListener;
import com.moilioncircle.redis.replicator.rdb.iterable.ValueIterableRdbValueVisitor;
import com.moilioncircle.redis.replicator.util.ByteArray;
public class IterableDumpValueParser implements DumpValueParser {
    protected final int batchSize;
    protected final boolean order;
    protected final Replicator replicator;
    protected final RdbValueVisitor valueVisitor;
    public IterableDumpValueParser(Replicator replicator) {
        this(64, replicator);
    }
    public IterableDumpValueParser(int batchSize, Replicator replicator) {
        this(true, batchSize, replicator);
    }
    public IterableDumpValueParser(boolean order, int batchSize, Replicator replicator) {
        Objects.requireNonNull(replicator);
        this.order = order;
        this.batchSize = batchSize;
        this.replicator = replicator;
        this.valueVisitor = new ValueIterableRdbValueVisitor(replicator);
    }
    @Override
    public void parse(DumpKeyValuePair kv, EventListener listener) {
        Objects.requireNonNull(listener);
        new ValueIterableEventListener(order, batchSize, listener).onEvent(replicator, parse(kv));
    }
    @Override
    public void parse(DumpFunction function, EventListener listener) {
        Objects.requireNonNull(listener);
        new ValueIterableEventListener(order, batchSize, listener).onEvent(replicator, parse(function));
    }
    @Override
    public Function parse(DumpFunction function) {
        Objects.requireNonNull(function);
        try (RedisInputStream in = new RedisInputStream(new ByteArray(function.getSerialized()))) {
            int valueType = in.read();
            if (valueType == RDB_OPCODE_FUNCTION) {
                return valueVisitor.applyFunction(in, 0);
            } else if (valueType == RDB_OPCODE_FUNCTION2) {
                return valueVisitor.applyFunction2(in, 0);
            } else {
                throw new AssertionError("unexpected value type:" + valueType);
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
    @Override
    public KeyValuePair<?, ?> parse(DumpKeyValuePair kv) {
        Objects.requireNonNull(kv);
        try (RedisInputStream in = new RedisInputStream(new ByteArray(kv.getValue()))) {
            int valueType = in.read();
            switch (valueType) {
                case RDB_TYPE_STRING:
                    return KeyValuePairs.string(kv, valueVisitor.applyString(in, 0));
                case RDB_TYPE_LIST:
                    return KeyValuePairs.iterList(kv, valueVisitor.applyList(in, 0));
                case RDB_TYPE_SET:
                    return KeyValuePairs.iterSet(kv, valueVisitor.applySet(in, 0));
                case RDB_TYPE_SET_LISTPACK:
                    return KeyValuePairs.iterSet(kv, valueVisitor.applySetListPack(in, 0));
                case RDB_TYPE_ZSET:
                    return KeyValuePairs.iterZset(kv, valueVisitor.applyZSet(in, 0));
                case RDB_TYPE_ZSET_2:
                    return KeyValuePairs.iterZset(kv, valueVisitor.applyZSet2(in, 0));
                case RDB_TYPE_HASH:
                    return KeyValuePairs.iterHash(kv, valueVisitor.applyHash(in, 0));
                case RDB_TYPE_HASH_ZIPMAP:
                    return KeyValuePairs.iterHash(kv, valueVisitor.applyHashZipMap(in, 0));
                case RDB_TYPE_LIST_ZIPLIST:
                    return KeyValuePairs.iterList(kv, valueVisitor.applyListZipList(in, 0));
                case RDB_TYPE_SET_INTSET:
                    return KeyValuePairs.iterSet(kv, valueVisitor.applySetIntSet(in, 0));
                case RDB_TYPE_ZSET_ZIPLIST:
                    return KeyValuePairs.iterZset(kv, valueVisitor.applyZSetZipList(in, 0));
                case RDB_TYPE_ZSET_LISTPACK:
                    return KeyValuePairs.iterZset(kv, valueVisitor.applyZSetListPack(in, 0));
                case RDB_TYPE_HASH_ZIPLIST:
                    return KeyValuePairs.iterHash(kv, valueVisitor.applyHashZipList(in, 0));
                case RDB_TYPE_HASH_LISTPACK:
                    return KeyValuePairs.iterHash(kv, valueVisitor.applyHashListPack(in, 0));
                case RDB_TYPE_LIST_QUICKLIST:
                    return KeyValuePairs.iterList(kv, valueVisitor.applyListQuickList(in, 0));
                case RDB_TYPE_LIST_QUICKLIST_2:
                    return KeyValuePairs.iterList(kv, valueVisitor.applyListQuickList2(in, 0));
                case RDB_TYPE_MODULE:
                    return KeyValuePairs.module(kv, valueVisitor.applyModule(in, 0));
                case RDB_TYPE_MODULE_2:
                    return KeyValuePairs.module(kv, valueVisitor.applyModule2(in, 0));
                case RDB_TYPE_STREAM_LISTPACKS:
                    return KeyValuePairs.stream(kv, valueVisitor.applyStreamListPacks(in, 0));
                case RDB_TYPE_STREAM_LISTPACKS_2:
                    return KeyValuePairs.stream(kv, valueVisitor.applyStreamListPacks2(in, 0));
                case RDB_TYPE_STREAM_LISTPACKS_3:
                    return KeyValuePairs.stream(kv, valueVisitor.applyStreamListPacks3(in, 0));
                default:
                    throw new AssertionError("unexpected value type:" + valueType);
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
}
package com.moilioncircle.redis.replicator.rdb.dump.parser;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FUNCTION;
import static com.moilioncircle.redis.replicator.Constants.RDB_OPCODE_FUNCTION2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPMAP;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_MODULE_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_INTSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STREAM_LISTPACKS_3;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_STRING;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_ZIPLIST;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.Objects;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.event.EventListener;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.DefaultRdbValueVisitor;
import com.moilioncircle.redis.replicator.rdb.RdbValueVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.Function;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePairs;
import com.moilioncircle.redis.replicator.rdb.dump.datatype.DumpFunction;
import com.moilioncircle.redis.replicator.rdb.dump.datatype.DumpKeyValuePair;
import com.moilioncircle.redis.replicator.util.ByteArray;
public class DefaultDumpValueParser implements DumpValueParser {
    protected final Replicator replicator;
    protected final RdbValueVisitor valueVisitor;
    public DefaultDumpValueParser(Replicator replicator) {
        Objects.requireNonNull(replicator);
        this.replicator = replicator;
        this.valueVisitor = new DefaultRdbValueVisitor(replicator);
    }
    @Override
    public void parse(DumpKeyValuePair kv, EventListener listener) {
        Objects.requireNonNull(listener).onEvent(replicator, parse(kv));
    }
    @Override
    public void parse(DumpFunction function, EventListener listener) {
        Objects.requireNonNull(listener).onEvent(replicator, parse(function));
    }
    @Override
    public Function parse(DumpFunction function) {
        Objects.requireNonNull(function);
        try (RedisInputStream in = new RedisInputStream(new ByteArray(function.getSerialized()))) {
            int valueType = in.read();
            if (valueType == RDB_OPCODE_FUNCTION) {
                return valueVisitor.applyFunction(in, 0);
            } else if (valueType == RDB_OPCODE_FUNCTION2) {
                return valueVisitor.applyFunction2(in, 0);
            } else {
                throw new AssertionError("unexpected value type:" + valueType);
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
    @Override
    public KeyValuePair<?, ?> parse(DumpKeyValuePair kv) {
        Objects.requireNonNull(kv);
        try (RedisInputStream in = new RedisInputStream(new ByteArray(kv.getValue()))) {
            int valueType = in.read();
            switch (valueType) {
                case RDB_TYPE_STRING:
                    return KeyValuePairs.string(kv, valueVisitor.applyString(in, 0));
                case RDB_TYPE_LIST:
                    return KeyValuePairs.list(kv, valueVisitor.applyList(in, 0));
                case RDB_TYPE_SET:
                    return KeyValuePairs.set(kv, valueVisitor.applySet(in, 0));
                case RDB_TYPE_SET_LISTPACK:
                    return KeyValuePairs.set(kv, valueVisitor.applySetListPack(in, 0));
                case RDB_TYPE_ZSET:
                    return KeyValuePairs.zset(kv, valueVisitor.applyZSet(in, 0));
                case RDB_TYPE_ZSET_2:
                    return KeyValuePairs.zset(kv, valueVisitor.applyZSet2(in, 0));
                case RDB_TYPE_HASH:
                    return KeyValuePairs.hash(kv, valueVisitor.applyHash(in, 0));
                case RDB_TYPE_HASH_ZIPMAP:
                    return KeyValuePairs.hash(kv, valueVisitor.applyHashZipMap(in, 0));
                case RDB_TYPE_LIST_ZIPLIST:
                    return KeyValuePairs.list(kv, valueVisitor.applyListZipList(in, 0));
                case RDB_TYPE_SET_INTSET:
                    return KeyValuePairs.set(kv, valueVisitor.applySetIntSet(in, 0));
                case RDB_TYPE_ZSET_ZIPLIST:
                    return KeyValuePairs.zset(kv, valueVisitor.applyZSetZipList(in, 0));
                case RDB_TYPE_ZSET_LISTPACK:
                    return KeyValuePairs.zset(kv, valueVisitor.applyZSetListPack(in, 0));
                case RDB_TYPE_HASH_ZIPLIST:
                    return KeyValuePairs.hash(kv, valueVisitor.applyHashZipList(in, 0));
                case RDB_TYPE_HASH_LISTPACK:
                    return KeyValuePairs.hash(kv, valueVisitor.applyHashListPack(in, 0));
                case RDB_TYPE_LIST_QUICKLIST:
                    return KeyValuePairs.list(kv, valueVisitor.applyListQuickList(in, 0));
                case RDB_TYPE_LIST_QUICKLIST_2:
                    return KeyValuePairs.list(kv, valueVisitor.applyListQuickList2(in, 0));
                case RDB_TYPE_MODULE:
                    return KeyValuePairs.module(kv, valueVisitor.applyModule(in, 0));
                case RDB_TYPE_MODULE_2:
                    return KeyValuePairs.module(kv, valueVisitor.applyModule2(in, 0));
                case RDB_TYPE_STREAM_LISTPACKS:
                    return KeyValuePairs.stream(kv, valueVisitor.applyStreamListPacks(in, 0));
                case RDB_TYPE_STREAM_LISTPACKS_2:
                    return KeyValuePairs.stream(kv, valueVisitor.applyStreamListPacks2(in, 0));
                case RDB_TYPE_STREAM_LISTPACKS_3:
                    return KeyValuePairs.stream(kv, valueVisitor.applyStreamListPacks3(in, 0));
                default:
                    throw new AssertionError("unexpected value type:" + valueType);
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
}
package com.moilioncircle.redis.replicator.rdb.dump.parser;
import com.moilioncircle.redis.replicator.event.EventListener;
import com.moilioncircle.redis.replicator.rdb.datatype.Function;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePair;
import com.moilioncircle.redis.replicator.rdb.dump.datatype.DumpFunction;
import com.moilioncircle.redis.replicator.rdb.dump.datatype.DumpKeyValuePair;
public interface DumpValueParser {
    Function parse(DumpFunction function);
    KeyValuePair<?, ?> parse(DumpKeyValuePair kv);
    void parse(DumpKeyValuePair kv, EventListener listener);
    void parse(DumpFunction function, EventListener listener);
}
package com.moilioncircle.redis.replicator.rdb.iterable;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_INTSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_LISTPACK;
import static com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePairs.hash;
import static com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePairs.list;
import static com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePairs.module;
import static com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePairs.set;
import static com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePairs.stream;
import static com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePairs.string;
import static com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePairs.zset;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.event.Event;
import com.moilioncircle.redis.replicator.event.EventListener;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyStringValueModule;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyStringValueStream;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyStringValueString;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.Module;
import com.moilioncircle.redis.replicator.rdb.datatype.Stream;
import com.moilioncircle.redis.replicator.rdb.datatype.ZSetEntry;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.KeyStringValueByteArrayIterator;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.KeyStringValueMapEntryIterator;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.KeyStringValueZSetEntryIterator;
import com.moilioncircle.redis.replicator.util.ByteArrayList;
import com.moilioncircle.redis.replicator.util.ByteArrayMap;
import com.moilioncircle.redis.replicator.util.ByteArraySet;
public class ValueIterableEventListener implements EventListener {
    private final int batchSize;
    private final boolean order;
    private final EventListener listener;
    public ValueIterableEventListener(EventListener listener) {
        this(64, listener);
    }
    public ValueIterableEventListener(int batchSize, EventListener listener) {
        this(true, batchSize, listener);
    }
    public ValueIterableEventListener(boolean order, int batchSize, EventListener listener) {
        if (batchSize <= 0) throw new IllegalArgumentException(String.valueOf(batchSize));
        this.order = order;
        this.batchSize = batchSize;
        this.listener = listener;
    }
    @Override
    public void onEvent(Replicator replicator, Event event) {
        if (!(event instanceof KeyValuePair<?, ?>)) {
            listener.onEvent(replicator, event);
            return;
        }
        KeyValuePair<?, ?> kv = (KeyValuePair<?, ?>) event;
        int batch = 0;
        final int type = kv.getValueRdbType();
        if (kv instanceof KeyStringValueString) {
            KeyStringValueString ksvs = (KeyStringValueString) kv;
            listener.onEvent(replicator, string(ksvs, ksvs.getValue(), batch, true));
        } else if (kv instanceof KeyStringValueByteArrayIterator) {
            if (type == RDB_TYPE_SET || type == RDB_TYPE_SET_INTSET || type == RDB_TYPE_SET_LISTPACK) {
                KeyStringValueByteArrayIterator skv = (KeyStringValueByteArrayIterator) kv;
                Iterator<byte[]> it = skv.getValue();
                Set<byte[]> prev = null, next = new ByteArraySet(order, batchSize);
                while (it.hasNext()) {
                    next.add(it.next());
                    if (next.size() == batchSize) {
                        if (prev != null)
                            listener.onEvent(replicator, set(skv, prev, batch++, false));
                        prev = next;
                        next = create(order, batchSize);
                    }
                }
                final boolean last = next.isEmpty();
                if (prev != null) listener.onEvent(replicator, set(skv, prev, batch++, last));
                if (!last) listener.onEvent(replicator, set(skv, next, batch++, true));
            } else {
                KeyStringValueByteArrayIterator lkv = (KeyStringValueByteArrayIterator) kv;
                Iterator<byte[]> it = lkv.getValue();
                List<byte[]> prev = null, next = new ByteArrayList(batchSize);
                while (it.hasNext()) {
                    try {
                        next.add(it.next());
                        if (next.size() == batchSize) {
                            if (prev != null)
                                listener.onEvent(replicator, list(lkv, prev, batch++, false));
                            prev = next;
                            next = new ByteArrayList(batchSize);
                        }
                    } catch (IllegalStateException ignore) {
                    }
                }
                final boolean last = next.isEmpty();
                if (prev != null) listener.onEvent(replicator, list(lkv, prev, batch++, last));
                if (!last) listener.onEvent(replicator, list(lkv, next, batch++, true));
            }
        } else if (kv instanceof KeyStringValueMapEntryIterator) {
            KeyStringValueMapEntryIterator mkv = (KeyStringValueMapEntryIterator) kv;
            Iterator<Map.Entry<byte[], byte[]>> it = mkv.getValue();
            Map<byte[], byte[]> prev = null, next = new ByteArrayMap(order, batchSize);
            while (it.hasNext()) {
                Map.Entry<byte[], byte[]> entry = it.next();
                next.put(entry.getKey(), entry.getValue());
                if (next.size() == batchSize) {
                    if (prev != null)
                        listener.onEvent(replicator, hash(mkv, prev, batch++, false));
                    prev = next;
                    next = new ByteArrayMap(order, batchSize);
                }
            }
            final boolean last = next.isEmpty();
            if (prev != null) listener.onEvent(replicator, hash(mkv, prev, batch++, last));
            if (!last) listener.onEvent(replicator, hash(mkv, next, batch++, true));
        } else if (kv instanceof KeyStringValueZSetEntryIterator) {
            KeyStringValueZSetEntryIterator zkv = (KeyStringValueZSetEntryIterator) kv;
            Iterator<ZSetEntry> it = zkv.getValue();
            Set<ZSetEntry> prev = null, next = create(order, batchSize);
            while (it.hasNext()) {
                next.add(it.next());
                if (next.size() == batchSize) {
                    if (prev != null)
                        listener.onEvent(replicator, zset(zkv, prev, batch++, false));
                    prev = next;
                    next = create(order, batchSize);
                }
            }
            final boolean last = next.isEmpty();
            if (prev != null) listener.onEvent(replicator, zset(zkv, prev, batch++, last));
            if (!last) listener.onEvent(replicator, zset(zkv, next, batch++, true));
        } else if (kv instanceof KeyStringValueModule) {
            listener.onEvent(replicator, module((KeyStringValueModule) kv, (Module) kv.getValue(), batch, true));
        } else if (kv instanceof KeyStringValueStream) {
            listener.onEvent(replicator, stream((KeyStringValueStream) kv, (Stream) kv.getValue(), batch, true));
        }
    }
    private <T> Set<T> create(boolean order, int batchSize) {
        return order ? new LinkedHashSet<T>(batchSize) : new HashSet<T>(batchSize);
    }
}
package com.moilioncircle.redis.replicator.rdb.iterable;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_HASH_ZIPMAP;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_QUICKLIST_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_LIST_ZIPLIST;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_INTSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_SET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_2;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_LISTPACK;
import static com.moilioncircle.redis.replicator.Constants.RDB_TYPE_ZSET_ZIPLIST;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.event.Event;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.BaseRdbParser;
import com.moilioncircle.redis.replicator.rdb.DefaultRdbVisitor;
import com.moilioncircle.redis.replicator.rdb.RdbValueVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.ContextKeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.KeyValuePair;
import com.moilioncircle.redis.replicator.rdb.datatype.ZSetEntry;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.KeyStringValueByteArrayIterator;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.KeyStringValueMapEntryIterator;
import com.moilioncircle.redis.replicator.rdb.iterable.datatype.KeyStringValueZSetEntryIterator;
public class ValueIterableRdbVisitor extends DefaultRdbVisitor {
    public ValueIterableRdbVisitor(Replicator replicator) {
        this(replicator, new ValueIterableRdbValueVisitor(replicator));
    }
    public ValueIterableRdbVisitor(Replicator replicator, RdbValueVisitor valueParser) {
        super(replicator, valueParser);
    }
    @Override
    public Event applyList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<byte[]>> o1 = new KeyStringValueByteArrayIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o1.setValueRdbType(RDB_TYPE_LIST);
        o1.setKey(key);
        o1.setValue(valueVisitor.applyList(in, version));
        return context.valueOf(o1);
    }
    @Override
    public Event applySet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<byte[]>> o2 = new KeyStringValueByteArrayIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o2.setValueRdbType(RDB_TYPE_SET);
        o2.setKey(key);
        o2.setValue(valueVisitor.applySet(in, version));
        return context.valueOf(o2);
    }
    @Override
    public Event applySetListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<byte[]>> o20 = new KeyStringValueByteArrayIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o20.setValueRdbType(RDB_TYPE_SET_LISTPACK);
        o20.setKey(key);
        o20.setValue(valueVisitor.applySetListPack(in, version));
        return context.valueOf(o20);
    }
    @Override
    public Event applyZSet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<ZSetEntry>> o3 = new KeyStringValueZSetEntryIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o3.setValueRdbType(RDB_TYPE_ZSET);
        o3.setKey(key);
        o3.setValue(valueVisitor.applyZSet(in, version));
        return context.valueOf(o3);
    }
    @Override
    public Event applyZSet2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<ZSetEntry>> o5 = new KeyStringValueZSetEntryIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o5.setValueRdbType(RDB_TYPE_ZSET_2);
        o5.setKey(key);
        o5.setValue(valueVisitor.applyZSet2(in, version));
        return context.valueOf(o5);
    }
    @Override
    public Event applyHash(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<Map.Entry<byte[], byte[]>>> o4 = new KeyStringValueMapEntryIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o4.setValueRdbType(RDB_TYPE_HASH);
        o4.setKey(key);
        o4.setValue(valueVisitor.applyHash(in, version));
        return context.valueOf(o4);
    }
    @Override
    public Event applyHashZipMap(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<Map.Entry<byte[], byte[]>>> o9 = new KeyStringValueMapEntryIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o9.setValueRdbType(RDB_TYPE_HASH_ZIPMAP);
        o9.setKey(key);
        o9.setValue(valueVisitor.applyHashZipMap(in, version));
        return context.valueOf(o9);
    }
    @Override
    public Event applyListZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<byte[]>> o10 = new KeyStringValueByteArrayIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o10.setValueRdbType(RDB_TYPE_LIST_ZIPLIST);
        o10.setKey(key);
        o10.setValue(valueVisitor.applyListZipList(in, version));
        return context.valueOf(o10);
    }
    @Override
    public Event applySetIntSet(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<byte[]>> o11 = new KeyStringValueByteArrayIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o11.setValueRdbType(RDB_TYPE_SET_INTSET);
        o11.setKey(key);
        o11.setValue(valueVisitor.applySetIntSet(in, version));
        return context.valueOf(o11);
    }
    @Override
    public Event applyZSetZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<ZSetEntry>> o12 = new KeyStringValueZSetEntryIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o12.setValueRdbType(RDB_TYPE_ZSET_ZIPLIST);
        o12.setKey(key);
        o12.setValue(valueVisitor.applyZSetZipList(in, version));
        return context.valueOf(o12);
    }
    @Override
    public Event applyZSetListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<ZSetEntry>> o17 = new KeyStringValueZSetEntryIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o17.setValueRdbType(RDB_TYPE_ZSET_LISTPACK);
        o17.setKey(key);
        o17.setValue(valueVisitor.applyZSetListPack(in, version));
        return context.valueOf(o17);
    }
    @Override
    public Event applyHashZipList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<Map.Entry<byte[], byte[]>>> o13 = new KeyStringValueMapEntryIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o13.setValueRdbType(RDB_TYPE_HASH_ZIPLIST);
        o13.setKey(key);
        o13.setValue(valueVisitor.applyHashZipList(in, version));
        return context.valueOf(o13);
    }
    @Override
    public Event applyHashListPack(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<Map.Entry<byte[], byte[]>>> o16 = new KeyStringValueMapEntryIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o16.setValueRdbType(RDB_TYPE_HASH_LISTPACK);
        o16.setKey(key);
        o16.setValue(valueVisitor.applyHashListPack(in, version));
        return context.valueOf(o16);
    }
    @Override
    public Event applyListQuickList(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<byte[]>> o14 = new KeyStringValueByteArrayIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o14.setValueRdbType(RDB_TYPE_LIST_QUICKLIST);
        o14.setKey(key);
        o14.setValue(valueVisitor.applyListQuickList(in, version));
        return context.valueOf(o14);
    }
    @Override
    public Event applyListQuickList2(RedisInputStream in, int version, ContextKeyValuePair context) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        KeyValuePair<byte[], Iterator<byte[]>> o18 = new KeyStringValueByteArrayIterator();
        byte[] key = parser.rdbLoadEncodedStringObject().first();
        o18.setValueRdbType(RDB_TYPE_LIST_QUICKLIST_2);
        o18.setKey(key);
        o18.setValue(valueVisitor.applyListQuickList2(in, version));
        return context.valueOf(o18);
    }
}
package com.moilioncircle.redis.replicator.rdb.iterable;
import static com.moilioncircle.redis.replicator.Constants.QUICKLIST_NODE_CONTAINER_PACKED;
import static com.moilioncircle.redis.replicator.Constants.QUICKLIST_NODE_CONTAINER_PLAIN;
import static com.moilioncircle.redis.replicator.Constants.RDB_LOAD_NONE;
import static com.moilioncircle.redis.replicator.rdb.BaseRdbParser.StringHelper.listPackEntry;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.AbstractMap;
import java.util.Iterator;
import java.util.Map;
import com.moilioncircle.redis.replicator.Replicator;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.BaseRdbParser;
import com.moilioncircle.redis.replicator.rdb.DefaultRdbValueVisitor;
import com.moilioncircle.redis.replicator.rdb.datatype.ZSetEntry;
import com.moilioncircle.redis.replicator.util.ByteArray;
import com.moilioncircle.redis.replicator.util.Strings;
@SuppressWarnings("unchecked")
public class ValueIterableRdbValueVisitor extends DefaultRdbValueVisitor {
    public ValueIterableRdbValueVisitor(Replicator replicator) {
        super(replicator);
    }
    @Override
    public <T> T applyList(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        Iterator<byte[]> val = new Iter<byte[]>(len, parser) {
            @Override
            public boolean hasNext() {
                return condition > 0;
            }
            @Override
            public byte[] next() {
                try {
                    byte[] element = parser.rdbLoadEncodedStringObject().first();
                    condition--;
                    return element;
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applySet(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        Iterator<byte[]> val = new Iter<byte[]>(len, parser) {
            @Override
            public boolean hasNext() {
                return condition > 0;
            }
            @Override
            public byte[] next() {
                try {
                    byte[] element = parser.rdbLoadEncodedStringObject().first();
                    condition--;
                    return element;
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applySetListPack(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream listPack = new RedisInputStream(parser.rdbLoadPlainStringObject());
        listPack.skip(4); 
        int len = listPack.readInt(2);
        Iterator<byte[]> val = new Iter<byte[]>(len, null) {
            @Override
            public boolean hasNext() {
                if (condition > 0) return true;
                try {
                    int lpend = listPack.read();
                    if (lpend != 255) {
                        throw new AssertionError("listpack expect 255 but " + lpend);
                    }
                    return false;
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
            @Override
            public byte[] next() {
                try {
                    byte[] element = listPackEntry(listPack);
                    condition--;
                    return element;
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applyZSet(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        Iterator<ZSetEntry> val = new Iter<ZSetEntry>(len, parser) {
            @Override
            public boolean hasNext() {
                return condition > 0;
            }
            @Override
            public ZSetEntry next() {
                try {
                    byte[] element = parser.rdbLoadEncodedStringObject().first();
                    double score = parser.rdbLoadDoubleValue();
                    condition--;
                    return new ZSetEntry(element, score);
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applyZSet2(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        Iterator<ZSetEntry> val = new Iter<ZSetEntry>(len, parser) {
            @Override
            public boolean hasNext() {
                return condition > 0;
            }
            @Override
            public ZSetEntry next() {
                try {
                    byte[] element = parser.rdbLoadEncodedStringObject().first();
                    double score = parser.rdbLoadBinaryDoubleValue();
                    condition--;
                    return new ZSetEntry(element, score);
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applyHash(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        Iterator<Map.Entry<byte[], byte[]>> val = new Iter<Map.Entry<byte[], byte[]>>(len, parser) {
            @Override
            public boolean hasNext() {
                return condition > 0;
            }
            @Override
            public Map.Entry<byte[], byte[]> next() {
                try {
                    byte[] field = parser.rdbLoadEncodedStringObject().first();
                    byte[] value = parser.rdbLoadEncodedStringObject().first();
                    condition--;
                    return new AbstractMap.SimpleEntry<>(field, value);
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applyHashZipMap(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream stream = new RedisInputStream(parser.rdbLoadPlainStringObject());
        BaseRdbParser.LenHelper.zmlen(stream); 
        Iterator<Map.Entry<byte[], byte[]>> val = new HashZipMapIter(stream);
        return (T) val;
    }
    @Override
    public <T> T applyListZipList(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        final RedisInputStream stream = new RedisInputStream(parser.rdbLoadPlainStringObject());
        BaseRdbParser.LenHelper.zlbytes(stream); 
        BaseRdbParser.LenHelper.zltail(stream); 
        int zllen = BaseRdbParser.LenHelper.zllen(stream);
        Iterator<byte[]> val = new Iter<byte[]>(zllen, null) {
            @Override
            public boolean hasNext() {
                if (condition > 0) return true;
                try {
                    int zlend = BaseRdbParser.LenHelper.zlend(stream);
                    if (zlend != 255) {
                        throw new AssertionError("zlend expect 255 but " + zlend);
                    }
                    return false;
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
            @Override
            public byte[] next() {
                try {
                    byte[] e = BaseRdbParser.StringHelper.zipListEntry(stream);
                    condition--;
                    return e;
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applySetIntSet(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        final RedisInputStream stream = new RedisInputStream(parser.rdbLoadPlainStringObject());
        final int encoding = BaseRdbParser.LenHelper.encoding(stream);
        long lenOfContent = BaseRdbParser.LenHelper.lenOfContent(stream);
        Iterator<byte[]> val = new Iter<byte[]>(lenOfContent, null) {
            @Override
            public boolean hasNext() {
                return condition > 0;
            }
            @Override
            public byte[] next() {
                try {
                    switch (encoding) {
                        case 2:
                            String element = String.valueOf(stream.readInt(2));
                            condition--;
                            return element.getBytes();
                        case 4:
                            element = String.valueOf(stream.readInt(4));
                            condition--;
                            return element.getBytes();
                        case 8:
                            element = String.valueOf(stream.readLong(8));
                            condition--;
                            return element.getBytes();
                        default:
                            throw new AssertionError("expect encoding [2,4,8] but:" + encoding);
                    }
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applyZSetZipList(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        final RedisInputStream stream = new RedisInputStream(parser.rdbLoadPlainStringObject());
        BaseRdbParser.LenHelper.zlbytes(stream); 
        BaseRdbParser.LenHelper.zltail(stream); 
        int zllen = BaseRdbParser.LenHelper.zllen(stream);
        Iterator<ZSetEntry> val = new Iter<ZSetEntry>(zllen, null) {
            @Override
            public boolean hasNext() {
                if (condition > 0) return true;
                try {
                    int zlend = BaseRdbParser.LenHelper.zlend(stream);
                    if (zlend != 255) {
                        throw new AssertionError("zlend expect 255 but " + zlend);
                    }
                    return false;
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
            @Override
            public ZSetEntry next() {
                try {
                    byte[] element = BaseRdbParser.StringHelper.zipListEntry(stream);
                    condition--;
                    double score = Double.valueOf(Strings.toString(BaseRdbParser.StringHelper.zipListEntry(stream)));
                    condition--;
                    return new ZSetEntry(element, score);
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applyZSetListPack(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream listPack = new RedisInputStream(parser.rdbLoadPlainStringObject());
        listPack.skip(4); 
        int len = listPack.readInt(2);
        Iterator<ZSetEntry> val = new Iter<ZSetEntry>(len, null) {
            @Override
            public boolean hasNext() {
                if (condition > 0) return true;
                try {
                    int lpend = listPack.read();
                    if (lpend != 255) {
                        throw new AssertionError("listpack expect 255 but " + lpend);
                    }
                    return false;
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
            @Override
            public ZSetEntry next() {
                try {
                    byte[] element = listPackEntry(listPack);
                    condition--;
                    double score = Double.valueOf(Strings.toString(listPackEntry(listPack)));
                    condition--;
                    return new ZSetEntry(element, score);
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applyHashZipList(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        final RedisInputStream stream = new RedisInputStream(parser.rdbLoadPlainStringObject());
        BaseRdbParser.LenHelper.zlbytes(stream); 
        BaseRdbParser.LenHelper.zltail(stream); 
        int zllen = BaseRdbParser.LenHelper.zllen(stream);
        Iterator<Map.Entry<byte[], byte[]>> val = new Iter<Map.Entry<byte[], byte[]>>(zllen, null) {
            @Override
            public boolean hasNext() {
                if (condition > 0) return true;
                try {
                    int zlend = BaseRdbParser.LenHelper.zlend(stream);
                    if (zlend != 255) {
                        throw new AssertionError("zlend expect 255 but " + zlend);
                    }
                    return false;
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
            @Override
            public Map.Entry<byte[], byte[]> next() {
                try {
                    byte[] field = BaseRdbParser.StringHelper.zipListEntry(stream);
                    condition--;
                    byte[] value = BaseRdbParser.StringHelper.zipListEntry(stream);
                    condition--;
                    return new AbstractMap.SimpleEntry<>(field, value);
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applyHashListPack(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        RedisInputStream listPack = new RedisInputStream(parser.rdbLoadPlainStringObject());
        listPack.skip(4); 
        int len = listPack.readInt(2);
        Iterator<Map.Entry<byte[], byte[]>> val = new Iter<Map.Entry<byte[], byte[]>>(len, null) {
            @Override
            public boolean hasNext() {
                if (condition > 0) return true;
                try {
                    int lpend = listPack.read();
                    if (lpend != 255) {
                        throw new AssertionError("listpack expect 255 but " + lpend);
                    }
                    return false;
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
            @Override
            public Map.Entry<byte[], byte[]> next() {
                try {
                    byte[] field = listPackEntry(listPack);
                    condition--;
                    byte[] value = listPackEntry(listPack);
                    condition--;
                    return new AbstractMap.SimpleEntry<>(field, value);
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            }
        };
        return (T) val;
    }
    @Override
    public <T> T applyListQuickList(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        Iterator<byte[]> val = new QuickListIter(len, parser);
        return (T) val;
    }
    @Override
    public <T> T applyListQuickList2(RedisInputStream in, int version) throws IOException {
        BaseRdbParser parser = new BaseRdbParser(in);
        long len = parser.rdbLoadLen().len;
        Iterator<byte[]> val = new QuickList2Iter(len, parser);
        return (T) val;
    }
    private static abstract class Iter<T> implements Iterator<T> {
        protected long condition;
        protected final BaseRdbParser parser;
        private Iter(long condition, BaseRdbParser parser) {
            this.condition = condition;
            this.parser = parser;
        }
        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }
    private static class HashZipMapIter extends Iter<Map.Entry<byte[], byte[]>> {
        protected int zmEleLen;
        protected final RedisInputStream stream;
        private HashZipMapIter(RedisInputStream stream) {
            super(0, null);
            this.stream = stream;
        }
        @Override
        public boolean hasNext() {
            try {
                return (this.zmEleLen = BaseRdbParser.LenHelper.zmElementLen(stream)) != 255;
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
        @Override
        public Map.Entry<byte[], byte[]> next() {
            try {
                byte[] field = BaseRdbParser.StringHelper.bytes(stream, zmEleLen);
                this.zmEleLen = BaseRdbParser.LenHelper.zmElementLen(stream);
                if (this.zmEleLen == 255) {
                    return new AbstractMap.SimpleEntry<>(field, null);
                }
                int free = BaseRdbParser.LenHelper.free(stream);
                byte[] value = BaseRdbParser.StringHelper.bytes(stream, zmEleLen);
                BaseRdbParser.StringHelper.skip(stream, free);
                return new AbstractMap.SimpleEntry<>(field, value);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
    }
    private static class QuickListIter extends Iter<byte[]> {
        protected int zllen = -1;
        protected RedisInputStream stream;
        private QuickListIter(long condition, BaseRdbParser parser) {
            super(condition, parser);
        }
        @Override
        public boolean hasNext() {
            return zllen > 0 || condition > 0;
        }
        @Override
        public byte[] next() {
            try {
                if (zllen == -1 && condition > 0) {
                    this.stream = new RedisInputStream(parser.rdbGenericLoadStringObject(RDB_LOAD_NONE));
                    BaseRdbParser.LenHelper.zlbytes(stream); 
                    BaseRdbParser.LenHelper.zltail(stream); 
                    this.zllen = BaseRdbParser.LenHelper.zllen(stream);
                    if (zllen == 0) {
                        int zlend = BaseRdbParser.LenHelper.zlend(stream);
                        if (zlend != 255) {
                            throw new AssertionError("zlend expect 255 but " + zlend);
                        }
                        zllen = -1;
                        condition--;
                    }
                    if (hasNext()) return next();
                    throw new IllegalStateException("end of iterator");
                } else {
                    byte[] e = BaseRdbParser.StringHelper.zipListEntry(stream);
                    zllen--;
                    if (zllen == 0) {
                        int zlend = BaseRdbParser.LenHelper.zlend(stream);
                        if (zlend != 255) {
                            throw new AssertionError("zlend expect 255 but " + zlend);
                        }
                        zllen = -1;
                        condition--;
                    }
                    return e;
                }
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
    }
    private static class QuickList2Iter extends Iter<byte[]> {
        protected int innerLen = -1;
        protected RedisInputStream listPack;
        private QuickList2Iter(long condition, BaseRdbParser parser) {
            super(condition, parser);
        }
        @Override
        public boolean hasNext() {
            return innerLen > 0 || condition > 0;
        }
        @Override
        public byte[] next() {
            try {
                if (innerLen == -1 && condition > 0) {
                    long container = parser.rdbLoadLen().len;
                    ByteArray bytes = parser.rdbLoadPlainStringObject();
                    if (container == QUICKLIST_NODE_CONTAINER_PLAIN) {
                        innerLen = -1;
                        condition--;
                        return bytes.first();
                    } else if (container == QUICKLIST_NODE_CONTAINER_PACKED) {
                        this.listPack = new RedisInputStream(bytes);
                        listPack.skip(4);
                        this.innerLen = listPack.readInt(2);
                        if (innerLen == 0) {
                            int lpend = listPack.read();
                            if (lpend != 255) {
                                throw new AssertionError("listpack expect 255 but " + lpend);
                            }
                            innerLen = -1;
                            condition--;
                        }
                        if (hasNext()) return next();
                        throw new IllegalStateException("end of iterator");
                    } else {
                        throw new UnsupportedOperationException(String.valueOf(container));
                    }
                } else {
                    byte[] e = listPackEntry(listPack);
                    innerLen--;
                    if (innerLen == 0) {
                        int lpend = listPack.read();
                        if (lpend != 255) {
                            throw new AssertionError("listpack expect 255 but " + lpend);
                        }
                        innerLen = -1;
                        condition--;
                    }
                    return e;
                }
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
    }
}
package com.moilioncircle.redis.replicator.rdb.module;
import com.moilioncircle.redis.replicator.Constants;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.BaseRdbParser;
import com.moilioncircle.redis.replicator.util.ByteArray;
import com.moilioncircle.redis.replicator.util.Strings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_DOUBLE;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_FLOAT;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_STRING;
import static com.moilioncircle.redis.replicator.Constants.RDB_MODULE_OPCODE_UINT;
public class DefaultRdbModuleParser {
    protected static final Logger logger = LoggerFactory.getLogger(DefaultRdbModuleParser.class);
    private final RedisInputStream in;
    private final BaseRdbParser parser;
    public DefaultRdbModuleParser(RedisInputStream in) {
        this.in = in;
        this.parser = new BaseRdbParser(in);
    }
    public RedisInputStream inputStream() {
        return this.in;
    }
    public long loadSigned(int version) throws IOException {
        if (version == 2) {
            long opcode = parser.rdbLoadLen().len;
            if (opcode != RDB_MODULE_OPCODE_UINT)
                throw new UnsupportedOperationException("Error loading signed or unsigned long from RDB.");
        }
        return parser.rdbLoadLen().len;
    }
    public BigInteger loadUnsigned(int version) throws IOException {
        byte[] ary = new byte[8];
        long value = loadSigned(version);
        for (int i = 0; i < 8; i++) {
            ary[7 - i] = (byte) ((value >>> (i << 3)) & 0xFF);
        }
        return new BigInteger(1, ary);
    }
    public String loadString(int version) throws IOException {
        if (version == 2) {
            long opcode = parser.rdbLoadLen().len;
            if (opcode != RDB_MODULE_OPCODE_STRING)
                throw new UnsupportedOperationException("Error loading string from RDB.");
        }
        ByteArray bytes = parser.rdbGenericLoadStringObject(Constants.RDB_LOAD_NONE);
        return Strings.toString(bytes.first());
    }
    public byte[] loadStringBuffer(int version) throws IOException {
        if (version == 2) {
            long opcode = parser.rdbLoadLen().len;
            if (opcode != RDB_MODULE_OPCODE_STRING)
                throw new UnsupportedOperationException("Error loading string from RDB.");
        }
        ByteArray bytes = parser.rdbGenericLoadStringObject(Constants.RDB_LOAD_PLAIN);
        return bytes.first();
    }
    public double loadDouble(int version) throws IOException {
        if (version == 2) {
            long opcode = parser.rdbLoadLen().len;
            if (opcode != RDB_MODULE_OPCODE_DOUBLE)
                throw new UnsupportedOperationException("Error loading double from RDB.");
        }
        return parser.rdbLoadBinaryDoubleValue();
    }
    public float loadFloat(int version) throws IOException {
        if (version == 2) {
            long opcode = parser.rdbLoadLen().len;
            if (opcode != RDB_MODULE_OPCODE_FLOAT)
                throw new UnsupportedOperationException("Error loading float from RDB.");
        }
        return parser.rdbLoadBinaryFloatValue();
    }
    public BigDecimal loadLongDouble(int version) throws IOException {
        return new BigDecimal(loadString(version));
    }
}
package com.moilioncircle.redis.replicator.rdb.module;
import com.moilioncircle.redis.replicator.io.RedisInputStream;
import com.moilioncircle.redis.replicator.rdb.datatype.Module;
import java.io.IOException;
public interface ModuleParser<T extends Module> {
    T parse(RedisInputStream in, int version) throws IOException;
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
import com.moilioncircle.redis.replicator.rdb.datatype.ExpiredType;
@CommandSpec(command = "SET")
public class SetCommand extends GenericKeyValueCommand {
    private static final long serialVersionUID = 1L;
    private boolean keepTtl;
    private ExpiredType expiredType;
    private Long expiredValue;
    private XATType xatType;
    private Long xatValue;
    private ExistType existType;
    private boolean get = false;
    public SetCommand() {
    }
    public SetCommand(byte[] key, byte[] value, boolean keepTtl, ExpiredType expiredType, Long expiredValue, ExistType existType) {
        this(key, value, keepTtl, expiredType, expiredValue, existType, false);
    }
    public SetCommand(byte[] key, byte[] value, boolean keepTtl, ExpiredType expiredType, Long expiredValue, ExistType existType, boolean get) {
        this(key, value, keepTtl, expiredType, expiredValue, XATType.NONE, null, existType, get);
    }
    public SetCommand(byte[] key, byte[] value, boolean keepTtl, ExpiredType expiredType, Long expiredValue, XATType xatType, Long xatValue, ExistType existType, boolean get) {
        super(key, value);
        this.keepTtl = keepTtl;
        this.expiredType = expiredType;
        this.expiredValue = expiredValue;
        this.xatType = xatType;
        this.xatValue = xatValue;
        this.existType = existType;
        this.get = get;
    }
    public boolean getKeepTtl() {
        return keepTtl;
    }
    public void setKeepTtl(boolean keepTtl) {
        this.keepTtl = keepTtl;
    }
    public ExpiredType getExpiredType() {
        return expiredType;
    }
    public void setExpiredType(ExpiredType expiredType) {
        this.expiredType = expiredType;
    }
    public Long getExpiredValue() {
        return expiredValue;
    }
    public void setExpiredValue(Long expiredValue) {
        this.expiredValue = expiredValue;
    }
    public ExistType getExistType() {
        return existType;
    }
    public void setExistType(ExistType existType) {
        this.existType = existType;
    }
    public boolean isGet() {
        return get;
    }
    public void setGet(boolean get) {
        this.get = get;
    }
    public XATType getXatType() {
        return xatType;
    }
    public void setXatType(XATType xatType) {
        this.xatType = xatType;
    }
    public Long getXatValue() {
        return xatValue;
    }
    public void setXatValue(Long xatValue) {
        this.xatValue = xatValue;
    }
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
import com.moilioncircle.redis.replicator.rdb.datatype.ZSetEntry;
@CommandSpec(command = "ZADD")
public class ZAddCommand extends GenericKeyCommand {
    private static final long serialVersionUID = 1L;
    private ExistType existType;
    private CompareType compareType;
    private boolean ch;
    private boolean incr;
    private ZSetEntry[] zSetEntries;
    public ZAddCommand() {
    }
    public ZAddCommand(byte[] key, ExistType existType, boolean ch, boolean incr, ZSetEntry[] zSetEntries) {
        this(key, existType, CompareType.NONE, ch, incr, zSetEntries);
    }
    public ZAddCommand(byte[] key, ExistType existType, CompareType compareType, boolean ch, boolean incr, ZSetEntry[] zSetEntries) {
        super(key);
        this.existType = existType;
        this.compareType = compareType;
        this.ch = ch;
        this.incr = incr;
        this.zSetEntries = zSetEntries;
    }
    public ExistType getExistType() {
        return existType;
    }
    public void setExistType(ExistType existType) {
        this.existType = existType;
    }
    public boolean isCh() {
        return ch;
    }
    public void setCh(boolean ch) {
        this.ch = ch;
    }
    public boolean isIncr() {
        return incr;
    }
    public void setIncr(boolean incr) {
        this.incr = incr;
    }
    public ZSetEntry[] getZSetEntries() {
        return zSetEntries;
    }
    public ZSetEntry[] getzSetEntries() {
        return zSetEntries;
    }
    public void setzSetEntries(ZSetEntry[] zSetEntries) {
        this.zSetEntries = zSetEntries;
    }
    public CompareType getCompareType() {
        return compareType;
    }
    public void setCompareType(CompareType compareType) {
        this.compareType = compareType;
    }
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
import com.moilioncircle.redis.replicator.rdb.datatype.EvictType;
@CommandSpec(command = "RESTORE")
public class RestoreCommand extends GenericKeyCommand {
    private static final long serialVersionUID = 1L;
    private long ttl;
    private byte[] serializedValue;
    private boolean replace;
    private boolean absTtl;
    protected EvictType evictType = EvictType.NONE;
    protected Long evictValue;
    public RestoreCommand() {
    }
    public RestoreCommand(byte[] key, long ttl, byte[] serializedValue, boolean replace, boolean absTtl, EvictType evictType, Long evictValue) {
        super(key);
        this.ttl = ttl;
        this.serializedValue = serializedValue;
        this.replace = replace;
        this.absTtl = absTtl;
        this.evictType = evictType;
        this.evictValue = evictValue;
    }
    public long getTtl() {
        return ttl;
    }
    public void setTtl(long ttl) {
        this.ttl = ttl;
    }
    public byte[] getSerializedValue() {
        return serializedValue;
    }
    public void setSerializedValue(byte[] serializedValue) {
        this.serializedValue = serializedValue;
    }
    public boolean isReplace() {
        return replace;
    }
    public void setReplace(boolean replace) {
        this.replace = replace;
    }
    public boolean isAbsTtl() {
        return absTtl;
    }
    public void setAbsTtl(boolean absTtl) {
        this.absTtl = absTtl;
    }
    public EvictType getEvictType() {
        return evictType;
    }
    public void setEvictType(EvictType evictType) {
        this.evictType = evictType;
    }
    public Long getEvictValue() {
        return evictValue;
    }
    public void setEvictValue(Long evictValue) {
        this.evictValue = evictValue;
    }
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.Command;
import com.moilioncircle.redis.replicator.event.AbstractEvent;
public abstract class AbstractCommand extends AbstractEvent implements Command {
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
@CommandSpec(command = "DECR")
public class DecrCommand extends GenericKeyCommand {
    private static final long serialVersionUID = 1L;
    public DecrCommand() {
    }
    public DecrCommand(byte[] key) {
        super(key);
    }
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
@CommandSpec(command = "SELECT")
public class SelectCommand extends AbstractCommand {
    private static final long serialVersionUID = 1L;
    private int index;
    public SelectCommand() {
    }
    public SelectCommand(int index) {
        this.index = index;
    }
    public int getIndex() {
        return index;
    }
    public void setIndex(int index) {
        this.index = index;
    }
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
@CommandSpec(command = "ZINTERSTORE")
public class ZInterStoreCommand extends AbstractCommand {
    private static final long serialVersionUID = 1L;
    private byte[] destination;
    private int numkeys;
    private byte[][] keys;
    private double[] weights;
    private AggregateType aggregateType;
    public ZInterStoreCommand() {
    }
    public ZInterStoreCommand(byte[] destination, int numkeys, byte[][] keys, double[] weights, AggregateType aggregateType) {
        this.destination = destination;
        this.numkeys = numkeys;
        this.keys = keys;
        this.weights = weights;
        this.aggregateType = aggregateType;
    }
    public byte[] getDestination() {
        return destination;
    }
    public void setDestination(byte[] destination) {
        this.destination = destination;
    }
    public int getNumkeys() {
        return numkeys;
    }
    public void setNumkeys(int numkeys) {
        this.numkeys = numkeys;
    }
    public byte[][] getKeys() {
        return keys;
    }
    public void setKeys(byte[][] keys) {
        this.keys = keys;
    }
    public double[] getWeights() {
        return weights;
    }
    public void setWeights(double[] weights) {
        this.weights = weights;
    }
    public AggregateType getAggregateType() {
        return aggregateType;
    }
    public void setAggregateType(AggregateType aggregateType) {
        this.aggregateType = aggregateType;
    }
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
@CommandSpec(command = "PFMERGE")
public class PFMergeCommand extends AbstractCommand {
    private static final long serialVersionUID = 1L;
    private byte[] destkey;
    private byte[][] sourcekeys;
    public PFMergeCommand() {
    }
    public PFMergeCommand(byte[] destkey, byte[][] sourcekeys) {
        this.destkey = destkey;
        this.sourcekeys = sourcekeys;
    }
    public byte[] getDestkey() {
        return destkey;
    }
    public void setDestkey(byte[] destkey) {
        this.destkey = destkey;
    }
    public byte[][] getSourcekeys() {
        return sourcekeys;
    }
    public void setSourcekeys(byte[][] sourcekeys) {
        this.sourcekeys = sourcekeys;
    }
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
@CommandSpec(command = "RPUSH")
public class RPushCommand extends GenericKeyCommand {
    private static final long serialVersionUID = 1L;
    private byte[][] values;
    public RPushCommand() {
    }
    public RPushCommand(byte[] key, byte[][] values) {
        super(key);
        this.values = values;
    }
    public byte[][] getValues() {
        return values;
    }
    public void setValues(byte[][] values) {
        this.values = values;
    }
}
package com.moilioncircle.redis.replicator.cmd.impl;
import com.moilioncircle.redis.replicator.cmd.CommandSpec;
@CommandSpec(command = "ZPOPMIN")
public class ZPopMinCommand extends GenericKeyCommand {
    private static final long serialVersionUID = 1L;
    private int count = 1;
    public ZPopMinCommand() {
    }
    public ZPopMinCommand(byte[] key, int count) {
        super(key);
        this.count = count;
    }
    public int getCount() {
        return count;
    }
    public void setCount(int count) {
        this.count = count;
    }
}
package com.moilioncircle.redis.replicator.util.type;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import com.moilioncircle.redis.replicator.util.Iterators;
@SuppressWarnings("unchecked")
public class Tuple1<T1> implements Iterable<T1>, Serializable {
    private static final long serialVersionUID = 1L;
    private T1 v1;
    public Tuple1() {
    }
    public Tuple1(T1 v1) {
        this.v1 = v1;
    }
    public Tuple1(Tuple1<T1> rhs) {
        this.v1 = rhs.getV1();
    }
    public T1 getV1() {
        return v1;
    }
    public void setV1(T1 v1) {
        this.v1 = v1;
    }
    public <V1> Tuple1<V1> map(Function<Tuple1<T1>, Tuple1<V1>> function) {
        return function.apply(this);
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Tuple1<?> tuple1 = (Tuple1<?>) o;
        return v1 != null ? v1.equals(tuple1.v1) : tuple1.v1 == null;
    }
    @Override
    public int hashCode() {
        return v1 != null ? v1.hashCode() : 0;
    }
    @Override
    public Iterator<T1> iterator() {
        return Iterators.iterator(getV1());
    }
    @Override
    public String toString() {
        return "[" + v1 + "]";
    }
    public static <V> Tuple1<V> from(V... ary) {
        if (ary == null || ary.length != 1) throw new IllegalArgumentException();
        return new Tuple1<>(ary[0]);
    }
    public static <V> Tuple1<V> from(Iterator<V> iterator) {
        List<V> list = new ArrayList<>();
        while (iterator.hasNext()) {
            list.add(iterator.next());
        }
        return from(list.toArray((V[]) new Object[list.size()]));
    }
    public static <V> Tuple1<V> from(Iterable<V> iterable) {
        return from(iterable.iterator());
    }
    public static <V> Tuple1<V> from(Collection<V> collection) {
        return from((Iterable<V>) collection);
    }
    public Object[] toArray() {
        return new Object[]{getV1()};
    }
    public <T> T[] toArray(Class<T> clazz) {
        T[] ary = (T[]) Array.newInstance(clazz, 5);
        if (!clazz.isInstance(getV1())) throw new UnsupportedOperationException();
        ary[0] = (T) getV1();
        return ary;
    }
    public <T> T toObject(Function<Tuple1<T1>, T> func) {
        return func.apply(this);
    }
}
package com.moilioncircle.redis.replicator.util.type;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import com.moilioncircle.redis.replicator.util.Iterators;
@SuppressWarnings("unchecked")
public class Tuple5<T1, T2, T3, T4, T5> implements Iterable<Object>, Serializable {
    private static final long serialVersionUID = 1L;
    private T1 v1;
    private T2 v2;
    private T3 v3;
    private T4 v4;
    private T5 v5;
    public Tuple5() {
    }
    public Tuple5(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5) {
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
        this.v4 = v4;
        this.v5 = v5;
    }
    public Tuple5(Tuple5<T1, T2, T3, T4, T5> rhs) {
        this.v1 = rhs.getV1();
        this.v2 = rhs.getV2();
        this.v3 = rhs.getV3();
        this.v4 = rhs.getV4();
        this.v5 = rhs.getV5();
    }
    public T1 getV1() {
        return v1;
    }
    public T2 getV2() {
        return v2;
    }
    public T3 getV3() {
        return v3;
    }
    public T4 getV4() {
        return v4;
    }
    public T5 getV5() {
        return v5;
    }
    public void setV1(T1 v1) {
        this.v1 = v1;
    }
    public void setV2(T2 v2) {
        this.v2 = v2;
    }
    public void setV3(T3 v3) {
        this.v3 = v3;
    }
    public void setV4(T4 v4) {
        this.v4 = v4;
    }
    public void setV5(T5 v5) {
        this.v5 = v5;
    }
    public <V1, V2, V3, V4, V5> Tuple5<V1, V2, V3, V4, V5> map(Function<Tuple5<T1, T2, T3, T4, T5>, Tuple5<V1, V2, V3, V4, V5>> function) {
        return function.apply(this);
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Tuple5<?, ?, ?, ?, ?> tuple5 = (Tuple5<?, ?, ?, ?, ?>) o;
        if (v1 != null ? !v1.equals(tuple5.v1) : tuple5.v1 != null) return false;
        if (v2 != null ? !v2.equals(tuple5.v2) : tuple5.v2 != null) return false;
        if (v3 != null ? !v3.equals(tuple5.v3) : tuple5.v3 != null) return false;
        if (v4 != null ? !v4.equals(tuple5.v4) : tuple5.v4 != null) return false;
        return v5 != null ? v5.equals(tuple5.v5) : tuple5.v5 == null;
    }
    @Override
    public int hashCode() {
        int result = v1 != null ? v1.hashCode() : 0;
        result = 31 * result + (v2 != null ? v2.hashCode() : 0);
        result = 31 * result + (v3 != null ? v3.hashCode() : 0);
        result = 31 * result + (v4 != null ? v4.hashCode() : 0);
        result = 31 * result + (v5 != null ? v5.hashCode() : 0);
        return result;
    }
    @Override
    public Iterator<Object> iterator() {
        return Iterators.iterator(getV1(), getV2(), getV3(), getV4(), getV5());
    }
    @Override
    public String toString() {
        return "[" + v1 + ", " + v2 + ", " + v3 + ", " + v4 + ", " + v5 + "]";
    }
    public static <V> Tuple5<V, V, V, V, V> from(V... ary) {
        if (ary == null || ary.length != 5) throw new IllegalArgumentException();
        return new Tuple5<>(ary[0], ary[1], ary[2], ary[3], ary[4]);
    }
    public static <V> Tuple5<V, V, V, V, V> from(Iterator<V> iterator) {
        List<V> list = new ArrayList<>();
        while (iterator.hasNext()) {
            list.add(iterator.next());
        }
        return from(list.toArray((V[]) new Object[list.size()]));
    }
    public static <V> Tuple5<V, V, V, V, V> from(Iterable<V> iterable) {
        return from(iterable.iterator());
    }
    public static <V> Tuple5<V, V, V, V, V> from(Collection<V> collection) {
        return from((Iterable<V>) collection);
    }
    public Object[] toArray() {
        return new Object[]{getV1(), getV2(), getV3(), getV4(), getV5()};
    }
    public <T> T[] toArray(Class<T> clazz) {
        T[] ary = (T[]) Array.newInstance(clazz, 5);
        if (!clazz.isInstance(getV1())) throw new UnsupportedOperationException();
        ary[0] = (T) getV1();
        if (!clazz.isInstance(getV2())) throw new UnsupportedOperationException();
        ary[1] = (T) getV2();
        if (!clazz.isInstance(getV3())) throw new UnsupportedOperationException();
        ary[2] = (T) getV3();
        if (!clazz.isInstance(getV4())) throw new UnsupportedOperationException();
        ary[3] = (T) getV4();
        if (!clazz.isInstance(getV5())) throw new UnsupportedOperationException();
        ary[4] = (T) getV5();
        return ary;
    }
    public <T> T toObject(Function<Tuple5<T1, T2, T3, T4, T5>, T> func) {
        return func.apply(this);
    }
}
package com.moilioncircle.redis.replicator.util.type;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import com.moilioncircle.redis.replicator.util.Iterators;
@SuppressWarnings("unchecked")
public class Tuple3<T1, T2, T3> implements Iterable<Object>, Serializable {
    private static final long serialVersionUID = 1L;
    private T1 v1;
    private T2 v2;
    private T3 v3;
    public Tuple3() {
    }
    public Tuple3(T1 v1, T2 v2, T3 v3) {
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    public Tuple3(Tuple3<T1, T2, T3> rhs) {
        this.v1 = rhs.getV1();
        this.v2 = rhs.getV2();
        this.v3 = rhs.getV3();
    }
    public T1 getV1() {
        return v1;
    }
    public T2 getV2() {
        return v2;
    }
    public T3 getV3() {
        return v3;
    }
    public void setV1(T1 v1) {
        this.v1 = v1;
    }
    public void setV2(T2 v2) {
        this.v2 = v2;
    }
    public void setV3(T3 v3) {
        this.v3 = v3;
    }
    public <V1, V2, V3> Tuple3<V1, V2, V3> map(Function<Tuple3<T1, T2, T3>, Tuple3<V1, V2, V3>> function) {
        return function.apply(this);
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Tuple3<?, ?, ?> tuple3 = (Tuple3<?, ?, ?>) o;
        if (v1 != null ? !v1.equals(tuple3.v1) : tuple3.v1 != null) return false;
        if (v2 != null ? !v2.equals(tuple3.v2) : tuple3.v2 != null) return false;
        return v3 != null ? v3.equals(tuple3.v3) : tuple3.v3 == null;
    }
    @Override
    public int hashCode() {
        int result = v1 != null ? v1.hashCode() : 0;
        result = 31 * result + (v2 != null ? v2.hashCode() : 0);
        result = 31 * result + (v3 != null ? v3.hashCode() : 0);
        return result;
    }
    @Override
    public Iterator<Object> iterator() {
        return Iterators.iterator(getV1(), getV2(), getV3());
    }
    @Override
    public String toString() {
        return "[" + v1 + ", " + v2 + ", " + v3 + "]";
    }
    public static <V> Tuple3<V, V, V> from(V... ary) {
        if (ary == null || ary.length != 3) throw new IllegalArgumentException();
        return new Tuple3<>(ary[0], ary[1], ary[2]);
    }
    public static <V> Tuple3<V, V, V> from(Iterator<V> iterator) {
        List<V> list = new ArrayList<>();
        while (iterator.hasNext()) {
            list.add(iterator.next());
        }
        return from(list.toArray((V[]) new Object[list.size()]));
    }
    public static <V> Tuple3<V, V, V> from(Iterable<V> iterable) {
        return from(iterable.iterator());
    }
    public static <V> Tuple3<V, V, V> from(Collection<V> collection) {
        return from((Iterable<V>) collection);
    }
    public Object[] toArray() {
        return new Object[]{getV1(), getV2(), getV3()};
    }
    public <T> T[] toArray(Class<T> clazz) {
        T[] ary = (T[]) Array.newInstance(clazz, 3);
        if (!clazz.isInstance(getV1())) throw new UnsupportedOperationException();
        ary[0] = (T) getV1();
        if (!clazz.isInstance(getV2())) throw new UnsupportedOperationException();
        ary[1] = (T) getV2();
        if (!clazz.isInstance(getV3())) throw new UnsupportedOperationException();
        ary[2] = (T) getV3();
        return ary;
    }
    public <T> T toObject(Function<Tuple3<T1, T2, T3>, T> func) {
        return func.apply(this);
    }
}
package com.moilioncircle.redis.replicator.util.type;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import com.moilioncircle.redis.replicator.util.Iterators;
@SuppressWarnings("unchecked")
public class Tuple2<T1, T2> implements Iterable<Object>, Serializable {
    private static final long serialVersionUID = 1L;
    private T1 v1;
    private T2 v2;
    public Tuple2() {
    }
    public Tuple2(T1 v1, T2 v2) {
        this.v1 = v1;
        this.v2 = v2;
    }
    public Tuple2(Tuple2<T1, T2> rhs) {
        this.v1 = rhs.getV1();
        this.v2 = rhs.getV2();
    }
    public T1 getV1() {
        return v1;
    }
    public T2 getV2() {
        return v2;
    }
    public void setV1(T1 v1) {
        this.v1 = v1;
    }
    public void setV2(T2 v2) {
        this.v2 = v2;
    }
    public <V1, V2> Tuple2<V1, V2> map(Function<Tuple2<T1, T2>, Tuple2<V1, V2>> function) {
        return function.apply(this);
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Tuple2<?, ?> tuple2 = (Tuple2<?, ?>) o;
        if (v1 != null ? !v1.equals(tuple2.v1) : tuple2.v1 != null) return false;
        return v2 != null ? v2.equals(tuple2.v2) : tuple2.v2 == null;
    }
    @Override
    public int hashCode() {
        int result = v1 != null ? v1.hashCode() : 0;
        result = 31 * result + (v2 != null ? v2.hashCode() : 0);
        return result;
    }
    @Override
    public Iterator<Object> iterator() {
        return Iterators.iterator(getV1(), getV2());
    }
    @Override
    public String toString() {
        return "[" + v1 + ", " + v2 + "]";
    }
    public static <V> Tuple2<V, V> from(V... ary) {
        if (ary == null || ary.length != 2) throw new IllegalArgumentException();
        return new Tuple2<>(ary[0], ary[1]);
    }
    public static <V> Tuple2<V, V> from(Iterator<V> iterator) {
        List<V> list = new ArrayList<>();
        while (iterator.hasNext()) {
            list.add(iterator.next());
        }
        return from(list.toArray((V[]) new Object[list.size()]));
    }
    public static <V> Tuple2<V, V> from(Iterable<V> iterable) {
        return from(iterable.iterator());
    }
    public static <V> Tuple2<V, V> from(Collection<V> collection) {
        return from((Iterable<V>) collection);
    }
    public Object[] toArray() {
        return new Object[]{getV1(), getV2()};
    }
    public <T> T[] toArray(Class<T> clazz) {
        T[] ary = (T[]) Array.newInstance(clazz, 5);
        if (!clazz.isInstance(getV1())) throw new UnsupportedOperationException();
        ary[0] = (T) getV1();
        if (!clazz.isInstance(getV2())) throw new UnsupportedOperationException();
        ary[1] = (T) getV2();
        return ary;
    }
    public <T> T toObject(Function<Tuple2<T1, T2>, T> func) {
        return func.apply(this);
    }
}
package com.moilioncircle.redis.replicator.util.type;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import com.moilioncircle.redis.replicator.util.Iterators;
@SuppressWarnings("unchecked")
public class Tuple4<T1, T2, T3, T4> implements Iterable<Object>, Serializable {
    private static final long serialVersionUID = 1L;
    private T1 v1;
    private T2 v2;
    private T3 v3;
    private T4 v4;
    public Tuple4() {
    }
    public Tuple4(T1 v1, T2 v2, T3 v3, T4 v4) {
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
        this.v4 = v4;
    }
    public Tuple4(Tuple4<T1, T2, T3, T4> rhs) {
        this.v1 = rhs.getV1();
        this.v2 = rhs.getV2();
        this.v3 = rhs.getV3();
        this.v4 = rhs.getV4();
    }
    public T1 getV1() {
        return v1;
    }
    public T2 getV2() {
        return v2;
    }
    public T3 getV3() {
        return v3;
    }
    public T4 getV4() {
        return v4;
    }
    public void setV1(T1 v1) {
        this.v1 = v1;
    }
    public void setV2(T2 v2) {
        this.v2 = v2;
    }
    public void setV3(T3 v3) {
        this.v3 = v3;
    }
    public void setV4(T4 v4) {
        this.v4 = v4;
    }
    public <V1, V2, V3, V4> Tuple4<V1, V2, V3, V4> map(Function<Tuple4<T1, T2, T3, T4>, Tuple4<V1, V2, V3, V4>> function) {
        return function.apply(this);
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Tuple4<?, ?, ?, ?> tuple4 = (Tuple4<?, ?, ?, ?>) o;
        if (v1 != null ? !v1.equals(tuple4.v1) : tuple4.v1 != null) return false;
        if (v2 != null ? !v2.equals(tuple4.v2) : tuple4.v2 != null) return false;
        if (v3 != null ? !v3.equals(tuple4.v3) : tuple4.v3 != null) return false;
        return v4 != null ? v4.equals(tuple4.v4) : tuple4.v4 == null;
    }
    @Override
    public int hashCode() {
        int result = v1 != null ? v1.hashCode() : 0;
        result = 31 * result + (v2 != null ? v2.hashCode() : 0);
        result = 31 * result + (v3 != null ? v3.hashCode() : 0);
        result = 31 * result + (v4 != null ? v4.hashCode() : 0);
        return result;
    }
    @Override
    public Iterator<Object> iterator() {
        return Iterators.iterator(getV1(), getV2(), getV3(), getV4());
    }
    @Override
    public String toString() {
        return "[" + v1 + ", " + v2 + ", " + v3 + ", " + v4 + "]";
    }
    public static <V> Tuple4<V, V, V, V> from(V... ary) {
        if (ary == null || ary.length != 4) throw new IllegalArgumentException();
        return new Tuple4<>(ary[0], ary[1], ary[2], ary[3]);
    }
    public static <V> Tuple4<V, V, V, V> from(Iterator<V> iterator) {
        List<V> list = new ArrayList<>();
        while (iterator.hasNext()) {
            list.add(iterator.next());
        }
        return from(list.toArray((V[]) new Object[list.size()]));
    }
    public static <V> Tuple4<V, V, V, V> from(Iterable<V> iterable) {
        return from(iterable.iterator());
    }
    public static <V> Tuple4<V, V, V, V> from(Collection<V> collection) {
        return from((Iterable<V>) collection);
    }
    public Object[] toArray() {
        return new Object[]{getV1(), getV2(), getV3(), getV4()};
    }
    public <T> T[] toArray(Class<T> clazz) {
        T[] ary = (T[]) Array.newInstance(clazz, 4);
        if (!clazz.isInstance(getV1())) throw new UnsupportedOperationException();
        ary[0] = (T) getV1();
        if (!clazz.isInstance(getV2())) throw new UnsupportedOperationException();
        ary[1] = (T) getV2();
        if (!clazz.isInstance(getV3())) throw new UnsupportedOperationException();
        ary[2] = (T) getV3();
        if (!clazz.isInstance(getV4())) throw new UnsupportedOperationException();
        ary[3] = (T) getV4();
        return ary;
    }
    public <T> T toObject(Function<Tuple4<T1, T2, T3, T4>, T> func) {
        return func.apply(this);
    }
}
package com.moilioncircle.redis.replicator.net;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketException;
import javax.net.SocketFactory;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import com.moilioncircle.redis.replicator.Configuration;
public class RedisSocketFactory extends SocketFactory {
    protected final Configuration configuration;
    public RedisSocketFactory(Configuration configuration) {
        this.configuration = configuration;
    }
    @Override
    public Socket createSocket(String host, int port) throws IOException {
        if (configuration.isSsl()) {
            return buildSsl(build(buildSslSocketFactory().createSocket(host, port)), host);
        } else {
            return build(new Socket(host, port));
        }
    }
    @Override
    public Socket createSocket(String host, int port, InetAddress localAddr, int localPort) throws IOException {
        if (configuration.isSsl()) {
            return buildSsl(build(buildSslSocketFactory().createSocket(host, port, localAddr, localPort)), host);
        } else {
            return build(new Socket(host, port, localAddr, localPort));
        }
    }
    @Override
    public Socket createSocket(InetAddress address, int port) throws IOException {
        if (configuration.isSsl()) {
            return buildSsl(build(buildSslSocketFactory().createSocket(address, port)), address.getHostAddress());
        } else {
            return build(new Socket(address, port));
        }
    }
    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException {
        if (configuration.isSsl()) {
            return buildSsl(build(buildSslSocketFactory().createSocket(address, port, localAddr, localPort)), address.getHostAddress());
        } else {
            return build(new Socket(address, port, localAddr, localPort));
        }
    }
    public Socket createSocket(String host, int port, int timeout) throws IOException {
        Socket socket = new Socket();
        build(socket);
        socket.connect(new InetSocketAddress(host, port), timeout);
        if (configuration.isSsl()) {
            socket = buildSslSocketFactory().createSocket(socket, host, port, true);
            return buildSsl(socket, host);
        } else {
            return socket;
        }
    }
    private Socket build(Socket socket) throws SocketException {
        socket.setReuseAddress(true);
        socket.setKeepAlive(true);
        socket.setTcpNoDelay(true);
        socket.setSoLinger(true, 0);
        if (configuration.getReadTimeout() > 0) {
            socket.setSoTimeout(configuration.getReadTimeout());
        }
        if (configuration.getReceiveBufferSize() > 0) {
            socket.setReceiveBufferSize(configuration.getReceiveBufferSize());
        }
        if (configuration.getSendBufferSize() > 0) {
            socket.setSendBufferSize(configuration.getSendBufferSize());
        }
        return socket;
    }
    private Socket buildSsl(Socket socket, String host) throws SocketException {
        if (configuration.getSslParameters() != null) {
            ((SSLSocket) socket).setSSLParameters(configuration.getSslParameters());
        }
        if (configuration.getHostnameVerifier() != null && !configuration.getHostnameVerifier().verify(host, ((SSLSocket) socket).getSession())) {
            throw new SocketException("the connection to " + host + " failed ssl/tls hostname verification.");
        }
        return socket;
    }
    private SSLSocketFactory buildSslSocketFactory() {
        SSLSocketFactory factory;
        if (configuration.getSslContextFactory() != null) {
            factory = configuration.getSslContextFactory().create().getSocketFactory();
        } else {
            factory = configuration.getSslSocketFactory();
        }
        return factory;
    }
}