/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.utils;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD_ANSWER;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD_QUESTION;
import android.app.Activity;
import android.os.Handler;
import android.view.LayoutInflater;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.widget.EditText;
import com.afollestad.materialdialogs.DialogAction;
import com.afollestad.materialdialogs.MaterialDialog;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.async.bus.PasswordRemovedEvent;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.models.PasswordValidator;
import lombok.experimental.UtilityClass;
@UtilityClass
public class PasswordHelper {
  public static void requestPassword(final Activity mActivity,
      final PasswordValidator mPasswordValidator) {
    LayoutInflater inflater = mActivity.getLayoutInflater();
    final View v = inflater.inflate(R.layout.password_request_dialog_layout, null);
    final EditText passwordEditText = v.findViewById(R.id.password_request);
    MaterialDialog dialog = new MaterialDialog.Builder(mActivity)
        .autoDismiss(false)
        .title(R.string.insert_security_password)
        .customView(v, false)
        .positiveText(R.string.ok)
        .positiveColorRes(R.color.colorPrimary)
        .onPositive((dialog12, which) -> {
          String storedPassword = Prefs.getString(PREF_PASSWORD, "");
          String password = passwordEditText.getText().toString();
          boolean result = Security.md5(password).equals(storedPassword);
          // In case password is ok dialog is dismissed and result sent to callback
          if (result) {
            KeyboardUtils.hideKeyboard(passwordEditText);
            dialog12.dismiss();
            mPasswordValidator.onPasswordValidated(PasswordValidator.Result.SUCCEED);
            // If password is wrong the auth flow is not interrupted and simply a message is shown
          } else {
            passwordEditText.setError(mActivity.getString(R.string.wrong_password));
          }
        })
        .neutralText(mActivity.getResources().getString(R.string.password_forgot))
        .onNeutral((dialog13, which) -> {
          PasswordHelper.resetPassword(mActivity);
          mPasswordValidator.onPasswordValidated(PasswordValidator.Result.RESTORE);
          dialog13.dismiss();
        })
        .build();
    dialog.setOnCancelListener(dialog1 -> {
      KeyboardUtils.hideKeyboard(passwordEditText);
      dialog1.dismiss();
      mPasswordValidator.onPasswordValidated(PasswordValidator.Result.FAIL);
    });
    passwordEditText.setOnEditorActionListener((textView, actionId, keyEvent) -> {
      if (actionId == EditorInfo.IME_ACTION_DONE) {
        dialog.getActionButton(DialogAction.POSITIVE).callOnClick();
        return true;
      }
      return false;
    });
    dialog.show();
    new Handler().postDelayed(() -> KeyboardUtils.showKeyboard(passwordEditText), 100);
  }
  public static void resetPassword(final Activity mActivity) {
    View layout = mActivity.getLayoutInflater()
        .inflate(R.layout.password_reset_dialog_layout, null);
    final EditText answerEditText = layout.findViewById(R.id.reset_password_answer);
    MaterialDialog dialog = new MaterialDialog.Builder(mActivity)
        .title(Prefs.getString(PREF_PASSWORD_QUESTION, ""))
        .customView(layout, false)
        .autoDismiss(false)
        .contentColorRes(R.color.text_color)
        .positiveText(R.string.ok)
        .onPositive((dialogElement, which) -> {
          // When positive button is pressed answer correctness is checked
          String oldAnswer = Prefs.getString(PREF_PASSWORD_ANSWER, "");
          String answer1 = answerEditText.getText().toString();
          // The check is done on password's hash stored in preferences
          boolean result = Security.md5(answer1).equals(oldAnswer);
          if (result) {
            dialogElement.dismiss();
            removePassword();
          } else {
            answerEditText.setError(mActivity.getString(R.string.wrong_answer));
          }
        }).build();
    dialog.show();
    answerEditText.setOnEditorActionListener((textView, actionId, keyEvent) -> {
      if (actionId == EditorInfo.IME_ACTION_DONE) {
        dialog.getActionButton(DialogAction.POSITIVE).callOnClick();
        return true;
      }
      return false;
    });
    new Handler().postDelayed(() -> KeyboardUtils.showKeyboard(answerEditText), 100);
  }
  public static void removePassword() {
    DbHelper.getInstance().getNotesWithLock(true).forEach(note -> {
      note.setLocked(false);
      DbHelper.getInstance().updateNote(note, false);
    });
    Prefs.edit()
        .remove(PREF_PASSWORD)
        .remove(PREF_PASSWORD_QUESTION)
        .remove(PREF_PASSWORD_ANSWER)
        .remove("settings_password_access")
        .apply();
    EventBus.getDefault().post(new PasswordRemovedEvent());
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.models;
import android.os.Parcel;
import android.os.Parcelable;
import it.feio.android.omninotes.commons.models.BaseAttachment;
import it.feio.android.omninotes.commons.models.BaseCategory;
import it.feio.android.omninotes.commons.models.BaseNote;
import java.util.ArrayList;
import java.util.List;
public class Note extends BaseNote implements Parcelable {
  /*
   * Parcelable interface must also have a static field called CREATOR, which is an object implementing the
   * Parcelable.Creator interface. Used to un-marshal or de-serialize object from Parcel.
   */
  public static final Parcelable.Creator<Note> CREATOR = new Parcelable.Creator<>() {
    public Note createFromParcel(Parcel in) {
      return new Note(in);
    }
    public Note[] newArray(int size) {
      return new Note[size];
    }
  };
  // Not saved in DB
  private boolean passwordChecked = false;
  public Note() {
    super();
  }
  public Note(Long creation, Long lastModification, String title, String content, Integer archived,
      Integer trashed, String alarm, String recurrenceRule, Integer reminderFired, String latitude,
      String longitude,
      Category
          category, Integer locked, Integer checklist) {
    super(creation, lastModification, title, content, archived, trashed, alarm, reminderFired,
        recurrenceRule,
        latitude,
        longitude, category, locked, checklist);
  }
  public Note(Note note) {
    super(note);
    setPasswordChecked(note.isPasswordChecked());
  }
  private Note(Parcel in) {
    setCreation(in.readString());
    setLastModification(in.readString());
    setTitle(in.readString());
    setContent(in.readString());
    setArchived(in.readInt());
    setTrashed(in.readInt());
    setAlarm(in.readString());
    setReminderFired(in.readInt());
    setRecurrenceRule(in.readString());
    setLatitude(in.readString());
    setLongitude(in.readString());
    setAddress(in.readString());
    super.setCategory(in.readParcelable(Category.class.getClassLoader()));
    setLocked(in.readInt());
    setChecklist(in.readInt());
    in.readList(getAttachmentsList(), Attachment.class.getClassLoader());
  }
  public List<Attachment> getAttachmentsList() {
//		List<Attachment> list = new ArrayList<>();
//		for (it.feio.android.omninotes.commons.models.Attachment attachment : super.getAttachmentsList()) {
//			if (attachment.getClass().equals(Attachment.class)) {
//				list.add((Attachment) attachment);
//			} else {
//				list.add(new Attachment(attachment));
//			}
//		}
//		return list;
    // FIXME This fixes https://github.com/federicoiosue/Omni-Notes/issues/199 but could introduce other issues
    return (List<Attachment>) super.getAttachmentsList();
  }
  public void setAttachmentsList(ArrayList<Attachment> attachmentsList) {
    super.setAttachmentsList(attachmentsList);
  }
  public void addAttachment(Attachment attachment) {
    List<Attachment> attachmentsList = ((List<Attachment>) super.getAttachmentsList());
    attachmentsList.add(attachment);
    setAttachmentsList(attachmentsList);
  }
  public void removeAttachment(Attachment attachment) {
    List<Attachment> attachmentsList = ((List<Attachment>) super.getAttachmentsList());
    attachmentsList.remove(attachment);
    setAttachmentsList(attachmentsList);
  }
  public List<Attachment> getAttachmentsListOld() {
    return (List<Attachment>) super.getAttachmentsListOld();
  }
  public void setAttachmentsListOld(ArrayList<Attachment> attachmentsListOld) {
    super.setAttachmentsListOld(attachmentsListOld);
  }
  public boolean isPasswordChecked() {
    return passwordChecked;
  }
  public void setPasswordChecked(boolean passwordChecked) {
    this.passwordChecked = passwordChecked;
  }
  @Override
  public Category getCategory() {
    try {
      return (Category) super.getCategory();
    } catch (ClassCastException e) {
      return new Category(super.getCategory());
    }
  }
  public void setCategory(Category category) {
    if (category != null && category.getClass().equals(BaseCategory.class)) {
      setCategory(new Category(category));
    }
    super.setCategory(category);
  }
  @Override
  public void buildFromJson(String jsonNote) {
    super.buildFromJson(jsonNote);
    List<Attachment> attachments = new ArrayList<>();
    for (BaseAttachment attachment : getAttachmentsList()) {
      attachments.add(new Attachment(attachment));
    }
    setAttachmentsList(attachments);
  }
  @Override
  public int describeContents() {
    return 0;
  }
  @Override
  public void writeToParcel(Parcel parcel, int flags) {
    parcel.writeString(String.valueOf(getCreation()));
    parcel.writeString(String.valueOf(getLastModification()));
    parcel.writeString(getTitle());
    parcel.writeString(getContent());
    parcel.writeInt(isArchived() ? 1 : 0);
    parcel.writeInt(isTrashed() ? 1 : 0);
    parcel.writeString(getAlarm());
    parcel.writeInt(isReminderFired() ? 1 : 0);
    parcel.writeString(getRecurrenceRule());
    parcel.writeString(String.valueOf(getLatitude()));
    parcel.writeString(String.valueOf(getLongitude()));
    parcel.writeString(getAddress());
    parcel.writeParcelable(getCategory(), 0);
    parcel.writeInt(isLocked() ? 1 : 0);
    parcel.writeInt(isChecklist() ? 1 : 0);
    parcel.writeList(getAttachmentsList());
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import static it.feio.android.omninotes.helpers.AppVersionHelper.isAppUpdated;
import static it.feio.android.omninotes.helpers.AppVersionHelper.updateAppVersionInPreferences;
import static it.feio.android.omninotes.helpers.BuildHelper.isDebugBuild;
import static it.feio.android.omninotes.helpers.ChangelogHelper.showChangelog;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_NOTIFICATION_CLICK;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_RESTART_APP;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SEND_AND_EXIT;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_START_APP;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_GOOGLE_NOW;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_KEY;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;
import androidx.annotation.Nullable;
import androidx.appcompat.app.ActionBarDrawerToggle;
import androidx.appcompat.widget.Toolbar;
import androidx.core.view.GravityCompat;
import androidx.drawerlayout.widget.DrawerLayout;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentManager;
import androidx.fragment.app.FragmentTransaction;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import de.keyboardsurfer.android.widget.crouton.Crouton;
import de.keyboardsurfer.android.widget.crouton.Style;
import it.feio.android.omninotes.async.UpdateWidgetsTask;
import it.feio.android.omninotes.async.bus.NotificationsGrantedEvent;
import it.feio.android.omninotes.async.bus.PasswordRemovedEvent;
import it.feio.android.omninotes.async.bus.SwitchFragmentEvent;
import it.feio.android.omninotes.async.notes.NoteProcessorDelete;
import it.feio.android.omninotes.databinding.ActivityMainBinding;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.NotesHelper;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import it.feio.android.omninotes.intro.IntroActivity;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.utils.FileProviderHelper;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.utils.SystemHelper;
import it.feio.android.pixlui.links.UrlCompleter;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import lombok.Getter;
import lombok.Setter;
public class MainActivity extends BaseActivity implements
    SharedPreferences.OnSharedPreferenceChangeListener {
  private boolean isPasswordAccepted = false;
  public static final String FRAGMENT_DRAWER_TAG = "fragment_drawer";
  public static final String FRAGMENT_LIST_TAG = "fragment_list";
  public static final String FRAGMENT_DETAIL_TAG = "fragment_detail";
  public static final String FRAGMENT_SKETCH_TAG = "fragment_sketch";
  @Getter @Setter
  private Uri sketchUri;
  boolean prefsChanged = false;
  private FragmentManager mFragmentManager;
  ActivityMainBinding binding;
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setTheme(R.style.OmniNotesTheme_ApiSpec);
    binding = ActivityMainBinding.inflate(getLayoutInflater());
    View view = binding.getRoot();
    setContentView(view);
    EventBus.getDefault().register(this);
    Prefs.getPreferences().registerOnSharedPreferenceChangeListener(this);
    new NotificationsHelper(this).askToEnableNotifications(this);
    initUI();
  }
  @Override
  protected void onPostCreate(@Nullable Bundle savedInstanceState) {
    super.onPostCreate(savedInstanceState);
    if (!launchIntroIfRequired() && isAppUpdated(getApplicationContext()) && !isDebugBuild()) {
      showChangelogAndUpdateCurrentVersion();
    }
  }
  private void showChangelogAndUpdateCurrentVersion() {
    showChangelog(this);
    updateAppVersionInPreferences(getApplicationContext());
  }
  private boolean launchIntroIfRequired() {
    if (IntroActivity.mustRun()) {
      startActivity(new Intent(getApplicationContext(), IntroActivity.class));
      return true;
    }
    return false;
  }
  @Override
  protected void onResume() {
    super.onResume();
    if (isPasswordAccepted) {
      init();
    } else {
      checkPassword();
    }
  }
  @Override
  protected void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
  }
  private void initUI() {
    setSupportActionBar(binding.toolbar.toolbar);
    getSupportActionBar().setDisplayHomeAsUpEnabled(true);
    getSupportActionBar().setHomeButtonEnabled(true);
  }
  /**
   * This method starts the bootstrap chain.
   */
  private void checkPassword() {
    if (Prefs.getString(PREF_PASSWORD, null) != null
        && Prefs.getBoolean("settings_password_access", false)) {
      PasswordHelper.requestPassword(this, passwordConfirmed -> {
        switch (passwordConfirmed) {
          case SUCCEED:
            init();
            break;
          case FAIL:
            finish();
            break;
          case RESTORE:
            PasswordHelper.resetPassword(this);
        }
      });
    } else {
      init();
    }
  }
  public void onEvent(PasswordRemovedEvent passwordRemovedEvent) {
    showMessage(R.string.password_successfully_removed, ONStyle.ALERT);
    init();
  }
  public void onEvent(NotificationsGrantedEvent notificationsGrantedEvent) {
    if (!notificationsGrantedEvent.granted) {
      showToast(getString(R.string.denied_notifications_permission), Toast.LENGTH_LONG);
    }
  }
  private void init() {
    isPasswordAccepted = true;
    getFragmentManagerInstance();
    NavigationDrawerFragment mNavigationDrawerFragment = (NavigationDrawerFragment) getFragmentManagerInstance()
        .findFragmentById(R.id.navigation_drawer);
    if (mNavigationDrawerFragment == null) {
      FragmentTransaction fragmentTransaction = getFragmentManagerInstance().beginTransaction();
      fragmentTransaction.replace(R.id.navigation_drawer, new NavigationDrawerFragment(),
          FRAGMENT_DRAWER_TAG).commit();
    }
    if (getFragmentManagerInstance().findFragmentByTag(FRAGMENT_LIST_TAG) == null) {
      FragmentTransaction fragmentTransaction = getFragmentManagerInstance().beginTransaction();
      fragmentTransaction.add(R.id.fragment_container, new ListFragment(), FRAGMENT_LIST_TAG)
          .commit();
    }
    handleIntents();
  }
  private FragmentManager getFragmentManagerInstance() {
    if (mFragmentManager == null) {
      mFragmentManager = getSupportFragmentManager();
    }
    return mFragmentManager;
  }
  @Override
  protected void onNewIntent(Intent intent) {
    if (intent.getAction() == null) {
      intent.setAction(ACTION_START_APP);
    }
    super.onNewIntent(intent);
    setIntent(intent);
    handleIntents();
    LogDelegate.d("onNewIntent");
  }
  public MenuItem getSearchMenuItem() {
    Fragment f = checkFragmentInstance(R.id.fragment_container, ListFragment.class);
    if (f != null) {
      return ((ListFragment) f).getSearchMenuItem();
    } else {
      return null;
    }
  }
  public void editTag(Category tag) {
    Fragment f = checkFragmentInstance(R.id.fragment_container, ListFragment.class);
    if (f != null) {
      ((ListFragment) f).editCategory(tag);
    }
  }
  public void initNotesList(Intent intent) {
    if (intent != null) {
      Fragment searchTagFragment = startSearchView();
      new Handler(getMainLooper()).post(() -> ((ListFragment) searchTagFragment).initNotesList(intent));
    }
  }
  public Fragment startSearchView() {
    FragmentTransaction transaction = getFragmentManagerInstance().beginTransaction();
    animateTransition(transaction, TRANSITION_HORIZONTAL);
    ListFragment mListFragment = new ListFragment();
    transaction.replace(R.id.fragment_container, mListFragment, FRAGMENT_LIST_TAG).addToBackStack
        (FRAGMENT_DETAIL_TAG).commit();
    Bundle args = new Bundle();
    args.putBoolean("setSearchFocus", true);
    mListFragment.setArguments(args);
    return mListFragment;
  }
  public void commitPending() {
    Fragment f = checkFragmentInstance(R.id.fragment_container, ListFragment.class);
    if (f != null) {
      ((ListFragment) f).commitPending();
    }
  }
  /**
   * Checks if allocated fragment is of the required type and then returns it or returns null
   */
  private Fragment checkFragmentInstance(int id, Object instanceClass) {
    Fragment result = null;
    Fragment fragment = getFragmentManagerInstance().findFragmentById(id);
    if (fragment != null && instanceClass.equals(fragment.getClass())) {
      result = fragment;
    }
    return result;
  }
  @Override
  public void onBackPressed() {
    // SketchFragment
    Fragment f = checkFragmentInstance(R.id.fragment_container, SketchFragment.class);
    if (f != null) {
      ((SketchFragment) f).save();
      // Removes forced portrait orientation for this fragment
      setRequestedOrientation(
          ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
      getFragmentManagerInstance().popBackStack();
      return;
    }
    // DetailFragment
    f = checkFragmentInstance(R.id.fragment_container, DetailFragment.class);
    if (f != null) {
      var detailDragment = (DetailFragment) f;
      detailDragment.goBack = true;
      detailDragment.saveAndExit();
      return;
    }
    // ListFragment
    f = checkFragmentInstance(R.id.fragment_container, ListFragment.class);
    if (f != null) {
      // Before exiting from app the navigation drawer is opened
      if (Prefs.getBoolean("settings_navdrawer_on_exit", false) && getDrawerLayout() != null &&
          !getDrawerLayout().isDrawerOpen(GravityCompat.START)) {
        getDrawerLayout().openDrawer(GravityCompat.START);
      } else if (!Prefs.getBoolean("settings_navdrawer_on_exit", false) && getDrawerLayout() != null
          &&
          getDrawerLayout().isDrawerOpen(GravityCompat.START)) {
        getDrawerLayout().closeDrawer(GravityCompat.START);
      } else {
        if (!((ListFragment) f).closeFab()) {
          isPasswordAccepted = false;
          super.onBackPressed();
        }
      }
      return;
    }
    super.onBackPressed();
  }
  @Override
  public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putString("navigationTmp", navigationTmp);
  }
  @Override
  protected void onPause() {
    super.onPause();
    Crouton.cancelAllCroutons();
  }
  public DrawerLayout getDrawerLayout() {
    return binding.drawerLayout;
  }
  public ActionBarDrawerToggle getDrawerToggle() {
    if (getFragmentManagerInstance().findFragmentById(R.id.navigation_drawer) != null) {
      return ((NavigationDrawerFragment) getFragmentManagerInstance().findFragmentById(
          R.id.navigation_drawer)).mDrawerToggle;
    } else {
      return null;
    }
  }
  /**
   * Finishes multiselection mode started by ListFragment
   */
  public void finishActionMode() {
    ListFragment fragment = (ListFragment) getFragmentManagerInstance()
        .findFragmentByTag(FRAGMENT_LIST_TAG);
    if (fragment != null) {
      fragment.finishActionMode();
    }
  }
  Toolbar getToolbar() {
    return binding.toolbar.toolbar;
  }
  private void handleIntents() {
    Intent i = getIntent();
    if (i.getAction() == null) {
      return;
    }
    if (ACTION_RESTART_APP.equals(i.getAction())) {
      SystemHelper.restartApp();
    }
    if (receivedIntent(i)) {
      Note note = i.getParcelableExtra(INTENT_NOTE);
      if (note == null) {
        note = DbHelper.getInstance().getNote(i.getIntExtra(INTENT_KEY, 0));
      }
      // Checks if the same note is already opened to avoid to open again
      if (note != null && noteAlreadyOpened(note)) {
        return;
      }
      // Empty note instantiation
      if (note == null) {
        note = new Note();
      }
      switchToDetail(note);
      return;
    }
    if (ACTION_SEND_AND_EXIT.equals(i.getAction())) {
      saveAndExit(i);
      return;
    }
    // Tag search
    if (Intent.ACTION_VIEW.equals(i.getAction()) && i.getDataString()
        .startsWith(UrlCompleter.HASHTAG_SCHEME)) {
      switchToList();
      return;
    }
    // Home launcher shortcut widget
    if (Intent.ACTION_VIEW.equals(i.getAction()) && i.getData() != null) {
      Long id = Long.valueOf(Uri.parse(i.getDataString()).getQueryParameter("id"));
      Note note = DbHelper.getInstance().getNote(id);
      if (note == null) {
        showMessage(R.string.note_doesnt_exist, ONStyle.ALERT);
        return;
      }
      switchToDetail(note);
      return;
    }
    // Home launcher "new note" shortcut widget
    if (ACTION_SHORTCUT_WIDGET.equals(i.getAction())) {
      switchToDetail(new Note());
      return;
    }
  }
  /**
   * Used to perform a quick text-only note saving (eg. Tasker+Pushbullet)
   */
  private void saveAndExit(Intent i) {
    Note note = new Note();
    note.setTitle(i.getStringExtra(Intent.EXTRA_SUBJECT));
    note.setContent(i.getStringExtra(Intent.EXTRA_TEXT));
    DbHelper.getInstance().updateNote(note, true);
    showToast(getString(R.string.note_updated), Toast.LENGTH_SHORT);
    finish();
  }
  private boolean receivedIntent(Intent i) {
    return ACTION_SHORTCUT.equals(i.getAction())
        || ACTION_NOTIFICATION_CLICK.equals(i.getAction())
        || ACTION_WIDGET.equals(i.getAction())
        || ACTION_WIDGET_TAKE_PHOTO.equals(i.getAction())
        || ((Intent.ACTION_SEND.equals(i.getAction())
        || Intent.ACTION_SEND_MULTIPLE.equals(i.getAction())
        || INTENT_GOOGLE_NOW.equals(i.getAction())
        || Intent.ACTION_PROCESS_TEXT.equals(i.getAction()))
        && i.getType() != null)
        || i.getAction().contains(ACTION_NOTIFICATION_CLICK);
  }
  private boolean noteAlreadyOpened(Note note) {
    DetailFragment detailFragment = (DetailFragment) getFragmentManagerInstance().findFragmentByTag(
        FRAGMENT_DETAIL_TAG);
    return detailFragment != null && NotesHelper.haveSameId(note, detailFragment.getCurrentNote());
  }
  public void switchToList() {
    FragmentTransaction transaction = getFragmentManagerInstance().beginTransaction();
    animateTransition(transaction, TRANSITION_HORIZONTAL);
    ListFragment mListFragment = new ListFragment();
    transaction.replace(R.id.fragment_container, mListFragment, FRAGMENT_LIST_TAG).addToBackStack
        (FRAGMENT_DETAIL_TAG).commitAllowingStateLoss();
    if (getDrawerToggle() != null) {
      getDrawerToggle().setDrawerIndicatorEnabled(false);
    }
    getFragmentManagerInstance().getFragments();
    EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.PARENT));
  }
  public void switchToDetail(Note note) {
    FragmentTransaction transaction = getFragmentManagerInstance().beginTransaction();
    animateTransition(transaction, TRANSITION_HORIZONTAL);
    DetailFragment mDetailFragment = new DetailFragment();
    Bundle b = new Bundle();
    b.putParcelable(INTENT_NOTE, note);
    mDetailFragment.setArguments(b);
    if (getFragmentManagerInstance().findFragmentByTag(FRAGMENT_DETAIL_TAG) == null) {
      transaction.replace(R.id.fragment_container, mDetailFragment, FRAGMENT_DETAIL_TAG)
          .addToBackStack(FRAGMENT_LIST_TAG)
          .commitAllowingStateLoss();
    } else {
      getFragmentManagerInstance().popBackStackImmediate();
      transaction.replace(R.id.fragment_container, mDetailFragment, FRAGMENT_DETAIL_TAG)
          .addToBackStack(FRAGMENT_DETAIL_TAG)
          .commitAllowingStateLoss();
    }
  }
  public void shareNote(Note note) {
    Intent shareIntent = new Intent();
    // Prepare sharing intent with only text
    if (note.getAttachmentsList().isEmpty()) {
      shareIntent.setAction(Intent.ACTION_SEND);
      shareIntent.setType("text/plain");
      // Intent with single image attachment
    } else if (note.getAttachmentsList().size() == 1) {
      Attachment attachment = note.getAttachmentsList().get(0);
      Uri shareableAttachmentUri = getShareableAttachmentUri(attachment);
      if (shareableAttachmentUri != null) {
        shareIntent.setAction(Intent.ACTION_SEND);
        shareIntent.setType(attachment.getMime_type());
        shareIntent.putExtra(Intent.EXTRA_STREAM, shareableAttachmentUri);
      }
      // Intent with multiple images
    } else if (note.getAttachmentsList().size() > 1) {
      shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);
      ArrayList<Uri> uris = new ArrayList<>();
      // A check to decide the mime type of attachments to share is done here
      HashMap<String, Boolean> mimeTypes = new HashMap<>();
      for (Attachment attachment : note.getAttachmentsList()) {
        Uri shareableAttachmentUri = getShareableAttachmentUri(attachment);
        if (shareableAttachmentUri != null) {
          uris.add(shareableAttachmentUri);
          mimeTypes.put(attachment.getMime_type(), true);
        }
      }
      // If many mime types are present a general type is assigned to intent
      if (mimeTypes.size() > 1) {
        shareIntent.setType("*/*");
      } else {
        shareIntent.setType((String) mimeTypes.keySet().toArray()[0]);
      }
      shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris);
    }
    shareIntent.putExtra(Intent.EXTRA_SUBJECT, note.getTitle());
    shareIntent.putExtra(Intent.EXTRA_TEXT, note.getContent());
    startActivity(Intent.createChooser(shareIntent, getResources().getString(R.string.share_message_chooser)));
  }
  public @Nullable Uri getShareableAttachmentUri(Attachment attachment) {
    try {
      return FileProviderHelper.getShareableUri(attachment);
    } catch (FileNotFoundException e) {
      LogDelegate.e(e.getMessage());
      Toast.makeText(this, R.string.attachment_not_found, Toast.LENGTH_SHORT).show();
      return null;
    }
  }
  /**
   * Single note permanent deletion
   *
   * @param note Note to be deleted
   */
  public void deleteNote(Note note) {
    new NoteProcessorDelete(Collections.singletonList(note)).process();
    BaseActivity.notifyAppWidgets(this);
    LogDelegate.d("Deleted permanently note with ID '" + note.get_id() + "'");
  }
  public void updateWidgets() {
    new UpdateWidgetsTask(getApplicationContext())
        .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  }
  public void showMessage(int messageId, Style style) {
    showMessage(getString(messageId), style);
  }
  public void showMessage(String message, Style style) {
    // ViewGroup used to show Crouton keeping compatibility with the new Toolbar
    runOnUiThread(
        () -> Crouton.makeText(this, message, style, binding.croutonHandle.croutonHandle).show());
  }
  @Override
  public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
    prefsChanged = true;
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_UPDATE_DASHCLOCK;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.appwidget.AppWidgetManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.Typeface;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuInflater;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;
import androidx.fragment.app.FragmentTransaction;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.helpers.LanguageHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.PasswordValidator;
import it.feio.android.omninotes.utils.Navigation;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.widget.ListWidgetProvider;
import java.util.Arrays;
import java.util.List;
@SuppressLint("Registered")
public class BaseActivity extends AppCompatActivity {
  protected static final int TRANSITION_VERTICAL = 0;
  protected static final int TRANSITION_HORIZONTAL = 1;
  protected String navigation;
  protected String navigationTmp; // used for widget navigation
  @Override
  public boolean onCreateOptionsMenu(Menu menu) {
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.menu_list, menu);
    return super.onCreateOptionsMenu(menu);
  }
  @Override
  protected void attachBaseContext(Context newBase) {
    Context context = LanguageHelper.updateLanguage(newBase, null);
    super.attachBaseContext(context);
  }
  @Override
  protected void onResume() {
    super.onResume();
    String navNotes = getResources().getStringArray(R.array.navigation_list_codes)[0];
    navigation = Prefs.getString(PREF_NAVIGATION, navNotes);
    LogDelegate.d(Prefs.getAll().toString());
  }
  protected void showToast(int resourceId, int duration) {
    showToast(getResources().getString(resourceId), duration);
  }
  protected void showToast(CharSequence text, int duration) {
    if (Prefs.getBoolean("settings_enable_info", true)) {
      Toast.makeText(getApplicationContext(), text, duration).show();
    }
  }
  /**
   * Method to validate security password to protect a list of notes. When "Request password on
   * access" in switched on this check not required all the times. It uses an interface callback.
   */
  public void requestPassword(final Activity mActivity, List<Note> notes,
      final PasswordValidator mPasswordValidator) {
    if (Prefs.getBoolean("settings_password_access", false)) {
      mPasswordValidator.onPasswordValidated(PasswordValidator.Result.SUCCEED);
      return;
    }
    boolean askForPassword = false;
    for (Note note : notes) {
      if (Boolean.TRUE.equals(note.isLocked())) {
        askForPassword = true;
        break;
      }
    }
    if (askForPassword) {
      PasswordHelper.requestPassword(mActivity, mPasswordValidator);
    } else {
      mPasswordValidator.onPasswordValidated(PasswordValidator.Result.SUCCEED);
    }
  }
  public boolean updateNavigation(String nav) {
    if (nav.equals(navigationTmp) || (navigationTmp == null && Navigation.getNavigationText()
        .equals(nav))) {
      return false;
    }
    Prefs.edit().putString(PREF_NAVIGATION, nav).apply();
    navigation = nav;
    navigationTmp = null;
    return true;
  }
  /**
   * Notifies App Widgets about data changes so they can update theirselves
   */
  public static void notifyAppWidgets(Context context) {
    // Home widgets
    AppWidgetManager mgr = AppWidgetManager.getInstance(context);
    int[] ids = mgr.getAppWidgetIds(new ComponentName(context, ListWidgetProvider.class));
    LogDelegate.d("Notifies AppWidget data changed for widgets " + Arrays.toString(ids));
    mgr.notifyAppWidgetViewDataChanged(ids, R.id.widget_list);
    // Dashclock
    LocalBroadcastManager.getInstance(context).sendBroadcast(new Intent(INTENT_UPDATE_DASHCLOCK));
  }
  @SuppressLint("InlinedApi")
  protected void animateTransition(FragmentTransaction transaction, int direction) {
    if (direction == TRANSITION_HORIZONTAL) {
      transaction.setCustomAnimations(R.anim.fade_in_support, R.anim.fade_out_support,
          R.anim.fade_in_support, R.anim.fade_out_support);
    }
    if (direction == TRANSITION_VERTICAL) {
      transaction.setCustomAnimations(
          R.anim.anim_in, R.anim.anim_out, R.anim.anim_in_pop, R.anim.anim_out_pop);
    }
  }
  protected void setActionBarTitle(String title) {
    // Creating a spannable to support custom fonts on ActionBar
    int actionBarTitle = Resources.getSystem().getIdentifier("action_bar_title", "ID", "android");
    android.widget.TextView actionBarTitleView = getWindow().findViewById(actionBarTitle);
    Typeface font = Typeface.createFromAsset(getAssets(), "fonts/Roboto-Regular.ttf");
    if (actionBarTitleView != null) {
      actionBarTitleView.setTypeface(font);
    }
    if (getSupportActionBar() != null) {
      getSupportActionBar().setTitle(title);
    }
  }
  public String getNavigationTmp() {
    return navigationTmp;
  }
  @Override
  public boolean onKeyDown(int keyCode, KeyEvent event) {
    return keyCode == KeyEvent.KEYCODE_MENU || super.onKeyDown(keyCode, event);
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import static android.Manifest.permission.CAMERA;
import static android.content.Context.CLIPBOARD_SERVICE;
import static android.content.Context.LAYOUT_INFLATER_SERVICE;
import static android.content.pm.PackageManager.FEATURE_CAMERA;
import static android.content.pm.PackageManager.PERMISSION_GRANTED;
import static android.widget.Toast.LENGTH_SHORT;
import static androidx.core.view.ViewCompat.animate;
import static it.feio.android.omninotes.BaseActivity.TRANSITION_HORIZONTAL;
import static it.feio.android.omninotes.BaseActivity.TRANSITION_VERTICAL;
import static it.feio.android.omninotes.MainActivity.FRAGMENT_DETAIL_TAG;
import static it.feio.android.omninotes.MainActivity.FRAGMENT_SKETCH_TAG;
import static it.feio.android.omninotes.OmniNotes.getAppContext;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_DISMISS;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_FAB_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_MERGE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_NOTIFICATION_CLICK;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_PINNED;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_SHOW_LIST;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.GALLERY_CLICKED_IMAGE;
import static it.feio.android.omninotes.utils.ConstantsBase.GALLERY_IMAGES;
import static it.feio.android.omninotes.utils.ConstantsBase.GALLERY_TITLE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_GOOGLE_NOW;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_KEY;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_AUDIO;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_AUDIO_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_FILES;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_IMAGE;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_IMAGE_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_SKETCH;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_SKETCH_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_VIDEO;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_VIDEO_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_ATTACHMENTS_ON_BOTTOM;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_AUTO_LOCATION;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_COLORS_APP_DEFAULT;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_KEEP_CHECKED;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_KEEP_CHECKMARKS;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PRETTIFIED_DATES;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_WIDGET_PREFIX;
import static it.feio.android.omninotes.utils.ConstantsBase.SWIPE_MARGIN;
import static it.feio.android.omninotes.utils.ConstantsBase.SWIPE_OFFSET;
import static it.feio.android.omninotes.utils.ConstantsBase.THUMBNAIL_SIZE;
import static java.lang.Integer.parseInt;
import static java.lang.Long.parseLong;
import android.Manifest;
import android.Manifest.permission;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.graphics.Point;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.location.Location;
import android.media.MediaPlayer;
import android.media.MediaRecorder;
import android.media.ThumbnailUtils;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.provider.MediaStore;
import android.text.Editable;
import android.text.Selection;
import android.text.Spanned;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnTouchListener;
import android.view.ViewGroup;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.AnimationUtils;
import android.widget.AutoCompleteTextView;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.Toast;
import androidx.activity.result.ActivityResultCallback;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.core.content.ContextCompat;
import androidx.core.util.Pair;
import androidx.drawerlayout.widget.DrawerLayout;
import androidx.fragment.app.FragmentTransaction;
import com.afollestad.materialdialogs.DialogAction;
import com.afollestad.materialdialogs.MaterialDialog;
import com.neopixl.pixlui.components.edittext.EditText;
import com.pixplicity.easyprefs.library.Prefs;
import com.pushbullet.android.extension.MessagingExtension;
import de.greenrobot.event.EventBus;
import de.keyboardsurfer.android.widget.crouton.Style;
import it.feio.android.checklistview.exceptions.ViewNotSupportedException;
import it.feio.android.checklistview.interfaces.CheckListChangedListener;
import it.feio.android.checklistview.models.CheckListView;
import it.feio.android.checklistview.models.CheckListViewItem;
import it.feio.android.checklistview.models.ChecklistManager;
import it.feio.android.omninotes.async.AttachmentTask;
import it.feio.android.omninotes.async.bus.NotesUpdatedEvent;
import it.feio.android.omninotes.async.bus.PushbulletReplyEvent;
import it.feio.android.omninotes.async.bus.SwitchFragmentEvent;
import it.feio.android.omninotes.async.notes.NoteProcessorDelete;
import it.feio.android.omninotes.async.notes.SaveNoteTask;
import it.feio.android.omninotes.databinding.FragmentDetailBinding;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.exceptions.checked.ContentSecurityException;
import it.feio.android.omninotes.exceptions.checked.UnhandledIntentException;
import it.feio.android.omninotes.helpers.AttachmentsHelper;
import it.feio.android.omninotes.helpers.BuildHelper;
import it.feio.android.omninotes.helpers.IntentHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.PermissionsHelper;
import it.feio.android.omninotes.helpers.TagOpenerHelper;
import it.feio.android.omninotes.helpers.date.DateHelper;
import it.feio.android.omninotes.helpers.date.RecurrenceHelper;
import it.feio.android.omninotes.helpers.notifications.NotificationChannels.NotificationChannelNames;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.models.PasswordValidator.Result;
import it.feio.android.omninotes.models.Tag;
import it.feio.android.omninotes.models.adapters.AttachmentAdapter;
import it.feio.android.omninotes.models.adapters.CategoryRecyclerViewAdapter;
import it.feio.android.omninotes.models.adapters.PlacesAutoCompleteAdapter;
import it.feio.android.omninotes.models.listeners.OnAttachingFileListener;
import it.feio.android.omninotes.models.listeners.OnGeoUtilResultListener;
import it.feio.android.omninotes.models.listeners.OnReminderPickedListener;
import it.feio.android.omninotes.models.listeners.RecyclerViewItemClickSupport;
import it.feio.android.omninotes.models.views.ExpandableHeightGridView;
import it.feio.android.omninotes.utils.AlphaManager;
import it.feio.android.omninotes.utils.BitmapHelper;
import it.feio.android.omninotes.utils.Display;
import it.feio.android.omninotes.utils.FileHelper;
import it.feio.android.omninotes.utils.FileProviderHelper;
import it.feio.android.omninotes.utils.GeocodeHelper;
import it.feio.android.omninotes.utils.IntentChecker;
import it.feio.android.omninotes.utils.KeyboardUtils;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.Security;
import it.feio.android.omninotes.utils.ShortcutHelper;
import it.feio.android.omninotes.utils.StorageHelper;
import it.feio.android.omninotes.utils.TagsHelper;
import it.feio.android.omninotes.utils.TextHelper;
import it.feio.android.omninotes.utils.date.DateUtils;
import it.feio.android.omninotes.utils.date.ReminderPickers;
import it.feio.android.pixlui.links.TextLinkClickListener;
import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;
import org.apache.commons.collections4.CollectionUtils;
public class DetailFragment extends BaseFragment implements OnReminderPickedListener,
    OnTouchListener,
    OnAttachingFileListener, TextWatcher, CheckListChangedListener,
    OnGeoUtilResultListener {
  private static final int TAKE_PHOTO = 1;
  private static final int TAKE_VIDEO = 2;
  private static final int SET_PASSWORD = 3;
  private static final int SKETCH = 4;
  private static final int CATEGORY = 5;
  private static final int DETAIL = 6;
  private static final int FILES = 7;
  private FragmentDetailBinding binding;
  boolean goBack = false;
  private ExpandableHeightGridView mGridView;
  private View toggleChecklistView;
  private Uri attachmentUri;
  private AttachmentAdapter mAttachmentAdapter;
  private MaterialDialog attachmentDialog;
  private Note note;
  private Note noteTmp;
  private Note noteOriginal;
  // Audio recording
  private String recordName;
  private MediaRecorder mRecorder = null;
  private MediaPlayer mPlayer = null;
  private boolean isRecording = false;
  private View isPlayingView = null;
  private Bitmap recordingBitmap;
  private ChecklistManager mChecklistManager;
  // Values to print result
  private String exitMessage;
  private Style exitCroutonStyle = ONStyle.CONFIRM;
  // Flag to check if after editing it will return to ListActivity or not
  // and in the last case a Toast will be shown instead than Crouton
  private boolean afterSavedReturnsToList = true;
  private boolean showKeyboard = false;
  private boolean swiping;
  private int startSwipeX;
  private boolean orientationChanged;
  private long audioRecordingTimeStart;
  private long audioRecordingTime;
  private DetailFragment mFragment;
  private Attachment sketchEdited;
  private int contentLineCounter = 1;
  private int contentCursorPosition;
  private ArrayList<String> mergedNotesIds;
  private MainActivity mainActivity;
  private boolean activityPausing;
  TextLinkClickListener textLinkClickListener = (view, clickedString, url) -> {
      new MaterialDialog.Builder(mainActivity)
          .content(clickedString)
          .negativeColorRes(R.color.colorPrimary)
          .positiveText(R.string.open)
          .negativeText(R.string.copy)
          .onPositive((dialog, which) -> {
            try {
              Intent intent = TagOpenerHelper.openOrGetIntent(getContext(), url);
              if (intent != null) {
                mainActivity.initNotesList(intent);
              }
            } catch (UnhandledIntentException e) {
              mainActivity.showMessage(R.string.no_application_can_perform_this_action,
                  ONStyle.ALERT);
            }
          })
          .onNegative((dialog, which) -> {
            android.content.ClipboardManager clipboard = (android.content.ClipboardManager)
                mainActivity.getSystemService(CLIPBOARD_SERVICE);
            android.content.ClipData clip = android.content.ClipData.newPlainText("text label",
                clickedString);
            clipboard.setPrimaryClip(clip);
          }).build().show();
      View clickedView =
          Boolean.TRUE.equals(noteTmp.isChecklist()) ? toggleChecklistView : binding.contentWrapper;
      clickedView.clearFocus();
      KeyboardUtils.hideKeyboard(clickedView);
      new Handler().post(() -> {
        View clickedView1 = Boolean.TRUE.equals(noteTmp.isChecklist()) ? toggleChecklistView : binding.contentWrapper;
        KeyboardUtils.hideKeyboard(clickedView1);
      });
  };
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mFragment = this;
  }
  @Override
  public void onAttach(Context context) {
    super.onAttach(context);
    EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.CHILDREN));
  }
  @Override
  public void onStop() {
    super.onStop();
    GeocodeHelper.stop();
  }
  @Override
  public void onResume() {
    super.onResume();
    activityPausing = false;
    EventBus.getDefault().register(this);
  }
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    binding = FragmentDetailBinding.inflate(inflater, container, false);
    return binding.getRoot();
  }
  @Override
  public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    mainActivity = (MainActivity) getActivity();
    mainActivity.getSupportActionBar().setDisplayShowTitleEnabled(false);
    mainActivity.getToolbar().setNavigationOnClickListener(v -> navigateUp());
    // Force the navigation drawer to stay opened if tablet mode is on, otherwise has to stay closed
    if (NavigationDrawerFragment.isDoublePanelActive()) {
      mainActivity.getDrawerLayout().setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_OPEN);
    } else {
      mainActivity.getDrawerLayout().setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED);
    }
    restoreTempNoteAfterOrientationChange(savedInstanceState);
    addSketchedImageIfPresent();
    // Ensures that Detail Fragment always have the back Arrow when it's created
    EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.CHILDREN));
    init();
    setHasOptionsMenu(true);
    setRetainInstance(false);
  }
  private void addSketchedImageIfPresent() {
    if (mainActivity.getSketchUri() != null) {
      Attachment mAttachment = new Attachment(mainActivity.getSketchUri(), MIME_TYPE_SKETCH);
      addAttachment(mAttachment);
      mainActivity.setSketchUri(null);
      // Removes previous version of edited image
      if (sketchEdited != null) {
        noteTmp.getAttachmentsList().remove(sketchEdited);
        sketchEdited = null;
      }
    }
  }
  private void restoreTempNoteAfterOrientationChange(Bundle savedInstanceState) {
    if (savedInstanceState != null) {
      noteTmp = savedInstanceState.getParcelable("noteTmp");
      note = savedInstanceState.getParcelable("note");
      noteOriginal = savedInstanceState.getParcelable("noteOriginal");
      attachmentUri = savedInstanceState.getParcelable("attachmentUri");
      orientationChanged = savedInstanceState.getBoolean("orientationChanged");
    }
  }
  @Override
  public void onSaveInstanceState(Bundle outState) {
    if (noteTmp != null) {
      noteTmp.setTitle(getNoteTitle());
      noteTmp.setContent(getNoteContent());
      outState.putParcelable("noteTmp", noteTmp);
      outState.putParcelable("note", note);
      outState.putParcelable("noteOriginal", noteOriginal);
      outState.putParcelable("attachmentUri", attachmentUri);
      outState.putBoolean("orientationChanged", orientationChanged);
    }
    super.onSaveInstanceState(outState);
  }
  @Override
  public void onPause() {
    super.onPause();
    //to prevent memory leak fragment keep refernce of event but until deregister
    EventBus.getDefault().unregister(this);
    activityPausing = true;
    // Checks "goBack" value to avoid performing a double saving
    if (!goBack) {
      saveNote();
    }
    if (toggleChecklistView != null) {
      KeyboardUtils.hideKeyboard(toggleChecklistView);
      binding.contentWrapper.clearFocus();
    }
  }
  @Override
  public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    if (getResources().getConfiguration().orientation != newConfig.orientation) {
      orientationChanged = true;
    }
  }
  private void init() {
    // Handling of Intent actions
    handleIntents();
    if (noteOriginal == null) {
      noteOriginal = getArguments().getParcelable(INTENT_NOTE);
    }
    if (note == null) {
      note = new Note(noteOriginal);
    }
    if (noteTmp == null) {
      noteTmp = new Note(note);
    }
    if (Boolean.TRUE.equals(noteTmp.isLocked()) && !noteTmp.isPasswordChecked()) {
      checkNoteLock(noteTmp);
      return;
    }
    initViews();
  }
  /**
   * Checks note lock and password before showing note content
   */
  private void checkNoteLock(Note note) {
    // If note is locked security password will be requested
    if (Boolean.TRUE.equals(note.isLocked()
        && Prefs.getString(PREF_PASSWORD, null) != null)
        && !Prefs.getBoolean("settings_password_access", false)) {
      PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
        switch (passwordConfirmed) {
          case SUCCEED:
            noteTmp.setPasswordChecked(true);
            init();
            break;
          case FAIL:
            goBack = true;
            goHome();
            break;
          case RESTORE:
            goBack = true;
            goHome();
            PasswordHelper.resetPassword(mainActivity);
            break;
        }
      });
    } else {
      noteTmp.setPasswordChecked(true);
      init();
    }
  }
  private void handleIntents() {
    Intent i = mainActivity.getIntent();
    if (IntentChecker.checkAction(i, ACTION_MERGE)) {
      noteOriginal = new Note();
      note = new Note(noteOriginal);
      noteTmp = getArguments().getParcelable(INTENT_NOTE);
      if (i.getStringArrayListExtra("merged_notes") != null) {
        mergedNotesIds = i.getStringArrayListExtra("merged_notes");
      }
    }
    // Action called from home shortcut
    if (IntentChecker.checkAction(i, ACTION_SHORTCUT, ACTION_NOTIFICATION_CLICK)) {
      afterSavedReturnsToList = false;
      noteOriginal = DbHelper.getInstance().getNote(i.getLongExtra(INTENT_KEY, 0));
      // Checks if the note pointed from the shortcut has been deleted
      try {
        note = new Note(noteOriginal);
        noteTmp = new Note(noteOriginal);
      } catch (NullPointerException e) {
        mainActivity.showToast(getText(R.string.shortcut_note_deleted), Toast.LENGTH_LONG);
        mainActivity.finish();
      }
    }
    // Check if is launched from a widget
    if (IntentChecker.checkAction(i, ACTION_WIDGET, ACTION_WIDGET_TAKE_PHOTO)) {
      afterSavedReturnsToList = false;
      showKeyboard = true;
      //  with tags to set tag
      if (i.hasExtra(INTENT_WIDGET)) {
        String widgetId = i.getExtras().get(INTENT_WIDGET).toString();
        String sqlCondition = Prefs.getString(PREF_WIDGET_PREFIX + widgetId, "");
        String categoryId = TextHelper.checkIntentCategory(sqlCondition);
        if (categoryId != null) {
          Category category;
          try {
            category = DbHelper.getInstance().getCategory(parseLong(categoryId));
            noteTmp = new Note();
            noteTmp.setCategory(category);
          } catch (NumberFormatException e) {
            LogDelegate.e("Category with not-numeric value!", e);
          }
        }
      }
      // Sub-action is to take a photo
      if (IntentChecker.checkAction(i, ACTION_WIDGET_TAKE_PHOTO)) {
        takePhoto();
      }
    }
    if (IntentChecker.checkAction(i, ACTION_FAB_TAKE_PHOTO)) {
      takePhoto();
    }
    // Handles third party apps requests of sharing
    if (IntentChecker
        .checkAction(i, Intent.ACTION_SEND, Intent.ACTION_SEND_MULTIPLE, Intent.ACTION_PROCESS_TEXT, INTENT_GOOGLE_NOW)
        && i.getType() != null) {
      afterSavedReturnsToList = false;
      if (noteTmp == null) {
        noteTmp = new Note();
      }
      // Text title
      String title = i.getStringExtra(Intent.EXTRA_SUBJECT);
      if (title != null) {
        noteTmp.setTitle(title);
      }
      // Text content
      String content = null;
      if (Intent.ACTION_PROCESS_TEXT.equals(i.getAction())){
        content = i.getStringExtra(Intent.EXTRA_PROCESS_TEXT).toString();
      } else {
        content = i.getStringExtra(Intent.EXTRA_TEXT);
      }
      if (content != null) {
        noteTmp.setContent(content);
      }
      importAttachments(i);
    }
    if (IntentChecker
        .checkAction(i, Intent.ACTION_MAIN, ACTION_WIDGET_SHOW_LIST, ACTION_SHORTCUT_WIDGET,
            ACTION_WIDGET)) {
      showKeyboard = true;
    }
    i.setAction(null);
  }
  private void importAttachments(Intent i) {
    if (!i.hasExtra(Intent.EXTRA_STREAM)) {
      return;
    }
    if (i.getExtras().get(Intent.EXTRA_STREAM) instanceof Uri) {
      Uri uri = i.getParcelableExtra(Intent.EXTRA_STREAM);
      // Google Now passes Intent as text but with audio recording attached the case must be handled like this
      if (validatePath(uri.getPath()) && !INTENT_GOOGLE_NOW.equals(i.getAction())) {
        String name = FileHelper.getNameFromUri(mainActivity, uri);
        new AttachmentTask(this, uri, name, this).execute();
      }
    } else {
      ArrayList<Uri> uris = i.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
      for (Uri uriSingle : uris) {
        if (validatePath(uriSingle.getPath())) {
          String name = FileHelper.getNameFromUri(mainActivity, uriSingle);
          new AttachmentTask(this, uriSingle, name, this).execute();
        }
      }
    }
  }
  private boolean validatePath(String path) {
    try {
      Security.validatePath(path);
      return true;
    } catch (ContentSecurityException e) {
      mainActivity.showMessage(R.string.insecure_content_found, ONStyle.WARN);
      return false;
    }
  }
  @SuppressLint("NewApi")
  private void initViews() {
    // Sets onTouchListener to the whole activity to swipe notes
    binding.detailRoot.setOnTouchListener(this);
    // Color of tag marker if note is tagged a function is active in preferences
    setTagMarkerColor(noteTmp.getCategory());
    initViewTitle();
    initViewContent();
    initViewLocation();
    initViewAttachments();
    initViewReminder();
    initViewFooter();
  }
  private void initViewFooter() {
    String creation = DateHelper
        .getFormattedDate(noteTmp.getCreation(), Prefs.getBoolean(PREF_PRETTIFIED_DATES, true));
    binding.creation
        .append(creation.length() > 0 ? getString(R.string.creation) + " " + creation : "");
    if (binding.creation.getText().length() == 0) {
      binding.creation.setVisibility(View.GONE);
    }
    String lastModification = DateHelper
        .getFormattedDate(noteTmp.getLastModification(), Prefs.getBoolean(
            PREF_PRETTIFIED_DATES, true));
    binding.lastModification
        .append(lastModification.length() > 0 ? getString(R.string.last_update) + " " +
            lastModification : "");
    if (binding.lastModification.getText().length() == 0) {
      binding.lastModification.setVisibility(View.GONE);
    }
  }
  private void initViewReminder() {
    binding.fragmentDetailContent.reminderLayout.setOnClickListener(v -> {
      ReminderPickers reminderPicker = new ReminderPickers(mainActivity, mFragment);
      reminderPicker.pick(DateUtils.getPresetReminder(noteTmp.getAlarm()), noteTmp
          .getRecurrenceRule());
    });
    binding.fragmentDetailContent.reminderLayout.setOnLongClickListener(v -> {
      MaterialDialog dialog = new MaterialDialog.Builder(mainActivity)
          .content(R.string.remove_reminder)
          .positiveText(R.string.ok)
          .onPositive((dialog1, which) -> {
            ReminderHelper.removeReminder(getAppContext(), noteTmp);
            noteTmp.setAlarm(null);
            binding.fragmentDetailContent.reminderIcon
                .setImageResource(R.drawable.ic_alarm_black_18dp);
            binding.fragmentDetailContent.datetime.setText("");
          }).build();
      dialog.show();
      return true;
    });
    // Reminder
    String reminderString = initReminder(noteTmp);
    if (!TextUtils.isEmpty(reminderString)) {
      binding.fragmentDetailContent.reminderIcon
          .setImageResource(R.drawable.ic_alarm_add_black_18dp);
      binding.fragmentDetailContent.datetime.setText(reminderString);
    }
  }
  private void initViewLocation() {
    DetailFragment detailFragment = this;
    if (isNoteLocationValid()) {
      if (TextUtils.isEmpty(noteTmp.getAddress())) {
        //FIXME: What's this "sasd"?
        GeocodeHelper.getAddressFromCoordinates(new Location("sasd"), detailFragment);
      } else {
        binding.fragmentDetailContent.location.setText(noteTmp.getAddress());
        binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
      }
    }
    // Automatic location insertion
    if (Prefs.getBoolean(PREF_AUTO_LOCATION, false) && noteTmp.get_id() == null) {
      getLocation(detailFragment);
    }
    binding.fragmentDetailContent.location.setOnClickListener(v -> {
      String uriString = "geo:" + noteTmp.getLatitude() + ',' + noteTmp.getLongitude()
          + "?q=" + noteTmp.getLatitude() + ',' + noteTmp.getLongitude();
      Intent locationIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(uriString));
      if (!IntentChecker.isAvailable(mainActivity, locationIntent, null)) {
        uriString = "http://maps.google.com/maps?q=" + noteTmp.getLatitude() + ',' + noteTmp
            .getLongitude();
        locationIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(uriString));
      }
      startActivity(locationIntent);
    });
    binding.fragmentDetailContent.location.setOnLongClickListener(v -> {
      MaterialDialog.Builder builder = new MaterialDialog.Builder(mainActivity);
      builder.content(R.string.remove_location);
      builder.positiveText(R.string.ok);
      builder.onPositive((dialog, which) -> {
        noteTmp.setLatitude("");
        noteTmp.setLongitude("");
        fade(binding.fragmentDetailContent.location, false);
      });
      MaterialDialog dialog = builder.build();
      dialog.show();
      return true;
    });
  }
  private void getLocation(OnGeoUtilResultListener onGeoUtilResultListener) {
    PermissionsHelper
        .requestPermission(this, Manifest.permission.ACCESS_FINE_LOCATION, R.string
                .permission_coarse_location, binding.snackbarPlaceholder,
            () -> GeocodeHelper.getLocation(onGeoUtilResultListener));
  }
  private void initViewAttachments() {
    // Attachments position based on preferences
    if (Prefs.getBoolean(PREF_ATTACHMENTS_ON_BOTTOM, false)) {
      binding.detailAttachmentsBelow.inflate();
    } else {
      binding.detailAttachmentsAbove.inflate();
    }
    mGridView = binding.detailRoot.findViewById(R.id.gridview);
    // Some fields can be filled by third party application and are always shown
    mAttachmentAdapter = new AttachmentAdapter(mainActivity, noteTmp.getAttachmentsList());
    // Initialzation of gridview for images
    mGridView.setAdapter(mAttachmentAdapter);
    mGridView.autoresize();
    // Click events for images in gridview (zooms image)
    mGridView.setOnItemClickListener((parent, v, position, id) -> {
      Attachment attachment = (Attachment) parent.getAdapter().getItem(position);
      Uri shareableAttachmentUri = mainActivity.getShareableAttachmentUri(attachment);
      if (shareableAttachmentUri == null) {
        return;
      }
      Intent attachmentIntent;
      if (MIME_TYPE_FILES.equals(attachment.getMime_type())) {
        attachmentIntent = new Intent(Intent.ACTION_VIEW);
        attachmentIntent.setDataAndType(shareableAttachmentUri, StorageHelper.getMimeType(mainActivity,
            shareableAttachmentUri));
        attachmentIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent
            .FLAG_GRANT_WRITE_URI_PERMISSION);
        if (IntentChecker
            .isAvailable(mainActivity.getApplicationContext(), attachmentIntent, null)) {
          startActivity(attachmentIntent);
        } else {
          mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.WARN);
        }
        // Media files will be opened in internal gallery
      } else if (MIME_TYPE_IMAGE.equals(attachment.getMime_type())
          || MIME_TYPE_SKETCH.equals(attachment.getMime_type())
          || MIME_TYPE_VIDEO.equals(attachment.getMime_type())) {
        // Title
        noteTmp.setTitle(getNoteTitle());
        noteTmp.setContent(getNoteContent());
        String title1 = TextHelper.parseTitleAndContent(mainActivity,
            noteTmp)[0].toString();
        // Images
        int clickedImage = 0;
        ArrayList<Attachment> images = new ArrayList<>();
        for (Attachment mAttachment : noteTmp.getAttachmentsList()) {
          if (MIME_TYPE_IMAGE.equals(mAttachment.getMime_type())
              || MIME_TYPE_SKETCH.equals(mAttachment.getMime_type())
              || MIME_TYPE_VIDEO.equals(mAttachment.getMime_type())) {
            images.add(mAttachment);
            if (mAttachment.equals(attachment)) {
              clickedImage = images.size() - 1;
            }
          }
        }
        // Intent
        attachmentIntent = new Intent(mainActivity, GalleryActivity.class);
        attachmentIntent.putExtra(GALLERY_TITLE, title1);
        attachmentIntent.putParcelableArrayListExtra(GALLERY_IMAGES, images);
        attachmentIntent.putExtra(GALLERY_CLICKED_IMAGE, clickedImage);
        startActivity(attachmentIntent);
      } else if (MIME_TYPE_AUDIO.equals(attachment.getMime_type())) {
        playback(v, attachment.getUri());
      }
    });
    mGridView.setOnItemLongClickListener((parent, v, position, id) -> {
      // To avoid deleting audio attachment during playback
      if (mPlayer != null) {
        return false;
      }
      List<String> items = Arrays
          .asList(getResources().getStringArray(R.array.attachments_actions));
      if (!MIME_TYPE_SKETCH.equals(mAttachmentAdapter.getItem(position).getMime_type())) {
        items = items.subList(0, items.size() - 1);
      }
      Attachment attachment = mAttachmentAdapter.getItem(position);
      new MaterialDialog.Builder(mainActivity)
          .title(attachment.getName() + " (" + AttachmentsHelper.getSize(attachment) + ")")
          .items(items.toArray(new String[items.size()]))
          .itemsCallback((materialDialog, view, i, charSequence) ->
              performAttachmentAction(position, i))
          .build()
          .show();
      return true;
    });
  }
  /**
   * Performs an action when long-click option is selected
   *
   * @param i item index
   */
  private void performAttachmentAction(int attachmentPosition, int i) {
    switch (getResources().getStringArray(R.array.attachments_actions_values)[i]) {
      case "share":
        Intent shareIntent = new Intent(Intent.ACTION_SEND);
        Attachment attachment = mAttachmentAdapter.getItem(attachmentPosition);
        Uri shareableAttachmentUri = mainActivity.getShareableAttachmentUri(attachment);
        if (shareableAttachmentUri == null) {
          Toast.makeText(getActivity(), R.string.error_saving_attachments, LENGTH_SHORT).show();
          break;
        }
        shareIntent.setType(StorageHelper.getMimeType(getAppContext(), attachment.getUri()));
        shareIntent.putExtra(Intent.EXTRA_STREAM, shareableAttachmentUri);
        if (IntentChecker.isAvailable(getAppContext(), shareIntent, null)) {
          startActivity(shareIntent);
        } else {
          mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.WARN);
        }
        break;
      case "delete":
        removeAttachment(attachmentPosition);
        mAttachmentAdapter.notifyDataSetChanged();
        mGridView.autoresize();
        break;
      case "delete all":
        new MaterialDialog.Builder(mainActivity)
            .title(R.string.delete_all_attachments)
            .positiveText(R.string.confirm)
            .onPositive((materialDialog, dialogAction) -> removeAllAttachments())
            .build()
            .show();
        break;
      case "edit":
        takeSketch(mAttachmentAdapter.getItem(attachmentPosition));
        break;
      default:
        LogDelegate.w("No action available");
    }
  }
  private void initViewTitle() {
    binding.detailTitle.setText(noteTmp.getTitle());
    binding.detailTitle.gatherLinksForText();
    binding.detailTitle.setOnTextLinkClickListener(textLinkClickListener);
    // To avoid dropping here the  dragged checklist items
    binding.detailTitle.setOnDragListener((v, event) -> true);
    //When editor action is pressed focus is moved to last character in content field
    binding.detailTitle.setOnEditorActionListener((v, actionId, event) -> {
      binding.fragmentDetailContent.detailContent.requestFocus();
      binding.fragmentDetailContent.detailContent
          .setSelection(binding.fragmentDetailContent.detailContent.getText().length());
      return false;
    });
    requestFocus(binding.detailTitle);
  }
  private void initViewContent() {
    binding.fragmentDetailContent.detailContent.setText(noteTmp.getContent());
    binding.fragmentDetailContent.detailContent.gatherLinksForText();
    binding.fragmentDetailContent.detailContent.setOnTextLinkClickListener(textLinkClickListener);
    // Avoids focused line goes under the keyboard
    binding.fragmentDetailContent.detailContent.addTextChangedListener(this);
    // Restore checklist
    toggleChecklistView = binding.fragmentDetailContent.detailContent;
    if (noteTmp.isChecklist()) {
      noteTmp.setChecklist(false);
      AlphaManager.setAlpha(toggleChecklistView, 0);
      toggleChecklist2();
    }
  }
  /**
   * Force focus and shows soft keyboard. Only happens if it's a new note, without shared content.
   * {@link showKeyboard} is used to check if the note is created from shared content.
   */
  @SuppressWarnings("JavadocReference")
  private void requestFocus(final EditText view) {
    if (note.get_id() == null && !noteTmp.isChanged(note) && showKeyboard) {
      KeyboardUtils.showKeyboard(view);
    }
  }
  /**
   * Colors tag marker in note's title and content elements
   */
  private void setTagMarkerColor(Category tag) {
    String colorsPref = Prefs.getString("settings_colors_app", PREF_COLORS_APP_DEFAULT);
    // Checking preference
    if (!"disabled".equals(colorsPref)) {
      // Choosing target view depending on another preference
      ArrayList<View> target = new ArrayList<>();
      if ("complete".equals(colorsPref)) {
        target.add(binding.titleWrapper);
        target.add(binding.contentWrapper);
      } else {
        target.add(binding.tagMarker);
      }
      // Coloring the target
      if (tag != null && tag.getColor() != null) {
        for (View view : target) {
          view.setBackgroundColor(parseInt(tag.getColor()));
        }
      } else {
        for (View view : target) {
          view.setBackgroundColor(Color.parseColor("#00000000"));
        }
      }
    }
  }
  private void displayLocationDialog() {
    getLocation(new OnGeoUtilResultListenerImpl(mainActivity, mFragment, noteTmp));
  }
  @Override
  public void onLocationRetrieved(Location location) {
    if (location == null) {
      mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
    }
    if (location != null) {
      noteTmp.setLatitude(location.getLatitude());
      noteTmp.setLongitude(location.getLongitude());
      if (!TextUtils.isEmpty(noteTmp.getAddress())) {
        binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
        binding.fragmentDetailContent.location.setText(noteTmp.getAddress());
      } else {
        GeocodeHelper.getAddressFromCoordinates(location, mFragment);
      }
    }
  }
  @Override
  public void onLocationUnavailable() {
    mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
  }
  public void onLocationNotEnabled(){
    mainActivity.showMessage(R.string.location_not_enabled, ONStyle.ALERT);
  }
  @Override
  public void onAddressResolved(String address) {
    if (TextUtils.isEmpty(address)) {
      if (!isNoteLocationValid()) {
        mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
        return;
      }
      address = noteTmp.getLatitude() + ", " + noteTmp.getLongitude();
    }
    if (!GeocodeHelper.areCoordinates(address)) {
      noteTmp.setAddress(address);
    }
    binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
    binding.fragmentDetailContent.location.setText(address);
    fade(binding.fragmentDetailContent.location, true);
  }
  @Override
  public void onCoordinatesResolved(Location location, String address) {
    if (location != null) {
      noteTmp.setLatitude(location.getLatitude());
      noteTmp.setLongitude(location.getLongitude());
      noteTmp.setAddress(address);
      binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
      binding.fragmentDetailContent.location.setText(address);
      fade(binding.fragmentDetailContent.location, true);
    } else {
      mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
    }
  }
  @Override
  public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
    inflater.inflate(R.menu.menu_detail, menu);
    super.onCreateOptionsMenu(menu, inflater);
  }
  @Override
  public void onPrepareOptionsMenu(Menu menu) {
    // Closes search view if left open in List fragment
    MenuItem searchMenuItem = menu.findItem(R.id.menu_search);
    if (searchMenuItem != null) {
      searchMenuItem.collapseActionView();
    }
    boolean newNote = noteTmp.get_id() == null;
    menu.findItem(R.id.menu_checklist_on).setVisible(!noteTmp.isChecklist());
    menu.findItem(R.id.menu_checklist_off).setVisible(noteTmp.isChecklist());
    menu.findItem(R.id.menu_checklist_moveToBottom)
        .setVisible(noteTmp.isChecklist() && mChecklistManager.getCheckedCount() > 0);
    menu.findItem(R.id.menu_lock).setVisible(!noteTmp.isLocked());
    menu.findItem(R.id.menu_unlock).setVisible(noteTmp.isLocked());
    // If note is trashed only this options will be available from menu
    if (noteTmp.isTrashed()) {
      menu.findItem(R.id.menu_untrash).setVisible(true);
      menu.findItem(R.id.menu_delete).setVisible(true);
      // Otherwise all other actions will be available
    } else {
      // Temporary removed until fixed on Oreo and following
      menu.findItem(R.id.menu_add_shortcut).setVisible(!newNote);
      menu.findItem(R.id.menu_pin_note).setVisible(!newNote);
      menu.findItem(R.id.menu_archive).setVisible(!newNote && !noteTmp.isArchived());
      menu.findItem(R.id.menu_unarchive).setVisible(!newNote && noteTmp.isArchived());
      menu.findItem(R.id.menu_trash).setVisible(!newNote);
    }
  }
  @SuppressLint("NewApi")
  private boolean goHome() {
    stopPlaying();
    // The activity has managed a shared intent from third party app and
    // performs a normal onBackPressed instead of returning back to ListActivity
    if (!afterSavedReturnsToList) {
      if (!TextUtils.isEmpty(exitMessage)) {
        mainActivity.showToast(exitMessage, LENGTH_SHORT);
      }
      mainActivity.finish();
    } else {
      if (!TextUtils.isEmpty(exitMessage) && exitCroutonStyle != null) {
        mainActivity.showMessage(exitMessage, exitCroutonStyle);
      }
      // Otherwise the result is passed to ListActivity
      if (mainActivity != null) {
        mainActivity.getSupportFragmentManager();
        mainActivity.getSupportFragmentManager().popBackStack();
        if (mainActivity.getSupportFragmentManager().getBackStackEntryCount() == 1) {
          mainActivity.getSupportActionBar().setDisplayShowTitleEnabled(true);
          if (mainActivity.getDrawerToggle() != null) {
            mainActivity.getDrawerToggle().setDrawerIndicatorEnabled(true);
          }
          EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.PARENT));
        }
      }
    }
    return true;
  }
  @Override
  public boolean onOptionsItemSelected(MenuItem item) {
    if (isOptionsItemFastClick()) {
      return true;
    }
    switch (item.getItemId()) {
      case R.id.menu_attachment:
        showAttachmentsPopup();
        break;
      case R.id.menu_tag:
        addTags();
        break;
      case R.id.menu_category:
        categorizeNote();
        break;
      case R.id.menu_share:
        shareNote();
        break;
      case R.id.menu_checklist_on:
      case R.id.menu_checklist_off:
        toggleChecklist();
        break;
      case R.id.menu_checklist_moveToBottom:
        moveCheckedItemsToBottom();
        break;
      case R.id.menu_lock:
      case R.id.menu_unlock:
        lockNote();
        break;
      case R.id.menu_pin_note:
        pinNote();
        break;
      case R.id.menu_add_shortcut:
        addShortcut();
        break;
      case R.id.menu_archive:
        archiveNote(true);
        break;
      case R.id.menu_unarchive:
        archiveNote(false);
        break;
      case R.id.menu_trash:
        trashNote(true);
        break;
      case R.id.menu_untrash:
        trashNote(false);
        break;
      case R.id.menu_discard_changes:
        discard();
        break;
      case R.id.menu_delete:
        deleteNote();
        break;
      case R.id.menu_note_info:
        showNoteInfo();
        break;
      default:
        LogDelegate.w("Invalid menu option selected");
    }
    return super.onOptionsItemSelected(item);
  }
  private void showNoteInfo() {
    noteTmp.setTitle(getNoteTitle());
    noteTmp.setContent(getNoteContent());
    Intent intent = new Intent(getContext(), NoteInfosActivity.class);
    intent.putExtra(INTENT_NOTE, (android.os.Parcelable) noteTmp);
    startActivity(intent);
  }
  private void navigateUp() {
    afterSavedReturnsToList = true;
    saveAndExit();
  }
  private void toggleChecklist() {
    // In case checklist is active a prompt will ask about many options
    // to decide hot to convert back to simple text
    if (Boolean.FALSE.equals(noteTmp.isChecklist())) {
      toggleChecklist2();
      return;
    }
    // If checklist is active but no items are checked the conversion in done automatically
    // without prompting user
    if (mChecklistManager.getCheckedCount() == 0) {
      toggleChecklist2(true, false);
      return;
    }
    // Inflate the popup_layout.XML
    LayoutInflater inflater = (LayoutInflater) mainActivity
        .getSystemService(LAYOUT_INFLATER_SERVICE);
    final View layout = inflater.inflate(R.layout.dialog_remove_checklist_layout,
        getView().findViewById(R.id.layout_root));
    // Retrieves options checkboxes and initialize their values
    final CheckBox keepChecked = layout.findViewById(R.id.checklist_keep_checked);
    final CheckBox keepCheckmarks = layout.findViewById(R.id.checklist_keep_checkmarks);
    keepChecked.setChecked(Prefs.getBoolean(PREF_KEEP_CHECKED, true));
    keepCheckmarks.setChecked(Prefs.getBoolean(PREF_KEEP_CHECKMARKS, true));
    new MaterialDialog.Builder(mainActivity)
        .customView(layout, false)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          Prefs.edit()
              .putBoolean(PREF_KEEP_CHECKED, keepChecked.isChecked())
              .putBoolean(PREF_KEEP_CHECKMARKS, keepCheckmarks.isChecked())
              .apply();
          toggleChecklist2();
        }).build().show();
  }
  private void toggleChecklist2() {
    boolean keepChecked = Prefs.getBoolean(PREF_KEEP_CHECKED, true);
    boolean showChecks = Prefs.getBoolean(PREF_KEEP_CHECKMARKS, true);
    toggleChecklist2(keepChecked, showChecks);
  }
  private void toggleChecklist2(final boolean keepChecked, final boolean showChecks) {
    mChecklistManager = mChecklistManager == null ? new ChecklistManager(mainActivity) : mChecklistManager;
    int checkedItemsBehavior = Integer
        .parseInt(Prefs.getString("settings_checked_items_behavior", String.valueOf
            (it.feio.android.checklistview.Settings.CHECKED_HOLD)));
    mChecklistManager
        .showCheckMarks(showChecks)
        .newEntryHint(getString(R.string.checklist_item_hint))
        .keepChecked(keepChecked)
        .undoBarContainerView(binding.contentWrapper)
        .moveCheckedOnBottom(checkedItemsBehavior);
    // Links parsing options
    mChecklistManager.setOnTextLinkClickListener(textLinkClickListener);
    mChecklistManager.addTextChangedListener(mFragment);
    mChecklistManager.setCheckListChangedListener(mFragment);
    // Switches the views
    View newView = null;
    try {
      newView = mChecklistManager.convert(toggleChecklistView);
    } catch (ViewNotSupportedException e) {
      LogDelegate.e("Error switching checklist view", e);
    }
    // Switches the views
    if (newView != null) {
      mChecklistManager.replaceViews(toggleChecklistView, newView);
      toggleChecklistView = newView;
      animate(toggleChecklistView).alpha(1).scaleXBy(0).scaleX(1).scaleYBy(0).scaleY(1);
      noteTmp.setChecklist(!noteTmp.isChecklist());
    }
  }
  private void moveCheckedItemsToBottom() {
    if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
      mChecklistManager.moveCheckedToBottom();
    }
  }
  private void categorizeNote() {
    var currentCategory = noteTmp.getCategory() != null ? String.valueOf(noteTmp.getCategory().getId()) : null;
    var  originalCategory = noteOriginal.getCategory() != null ? String.valueOf(noteOriginal.getCategory().getId()) : null;
    final var categories = DbHelper.getInstance().getCategories().stream()
        .map(category -> {
          if (String.valueOf(category.getId()).equals(currentCategory) && currentCategory != originalCategory) {
            category.setCount(category.getCount() + 1);
          }
          if (String.valueOf(category.getId()).equals(originalCategory) && currentCategory != originalCategory) {
            category.setCount(category.getCount() - 1);
          }
          return category;
        }).collect(Collectors.toList());
    var dialogBuilder = new MaterialDialog.Builder(mainActivity)
        .title(R.string.categorize_as)
        .positiveText(R.string.add_category)
        .positiveColorRes(R.color.colorPrimary)
        .negativeText(R.string.remove_category)
        .negativeColorRes(R.color.colorAccent)
        .onPositive((dialog1, which) -> {
          Intent intent = new Intent(mainActivity, CategoryActivity.class);
          intent.putExtra("noHome", true);
          startActivityForResult(intent, CATEGORY);
        })
        .onNegative((dialog12, which) -> {
          noteTmp.setCategory(null);
          setTagMarkerColor(null);
        });
    if (CollectionUtils.isNotEmpty(categories)) {
      dialogBuilder.adapter(new CategoryRecyclerViewAdapter(mainActivity, categories), null);
    }
    final var dialog = dialogBuilder.build();
    if (CollectionUtils.isNotEmpty(categories)) {
      RecyclerViewItemClickSupport.addTo(dialog.getRecyclerView())
          .setOnItemClickListener((recyclerView, position, v) -> {
            noteTmp.setCategory(categories.get(position));
            setTagMarkerColor(categories.get(position));
            dialog.dismiss();
          });
    }
    dialog.show();
  }
  private void showAttachmentsPopup() {
    LayoutInflater inflater = mainActivity.getLayoutInflater();
    final View layout = inflater.inflate(R.layout.attachment_dialog, null);
    attachmentDialog = new MaterialDialog.Builder(mainActivity)
        .autoDismiss(false)
        .customView(layout, false)
        .build();
    attachmentDialog.show();
    // Camera
    android.widget.TextView cameraSelection = layout.findViewById(R.id.camera);
    cameraSelection.setOnClickListener(new AttachmentOnClickListener());
    // Audio recording
    android.widget.TextView recordingSelection = layout.findViewById(R.id.recording);
    toggleAudioRecordingStop(recordingSelection);
    recordingSelection.setOnClickListener(new AttachmentOnClickListener());
    // Video recording
    android.widget.TextView videoSelection = layout.findViewById(R.id.video);
    videoSelection.setOnClickListener(new AttachmentOnClickListener());
    // Files
    android.widget.TextView filesSelection = layout.findViewById(R.id.files);
    filesSelection.setOnClickListener(new AttachmentOnClickListener());
    // Sketch
    android.widget.TextView sketchSelection = layout.findViewById(R.id.sketch);
    sketchSelection.setOnClickListener(new AttachmentOnClickListener());
    // Location
    android.widget.TextView locationSelection = layout.findViewById(R.id.location);
    locationSelection.setOnClickListener(new AttachmentOnClickListener());
    // Time
    android.widget.TextView timeStampSelection = layout.findViewById(R.id.timestamp);
    timeStampSelection.setOnClickListener(new AttachmentOnClickListener());
    // Desktop note with PushBullet
    android.widget.TextView pushbulletSelection = layout.findViewById(R.id.pushbullet);
    pushbulletSelection.setVisibility(View.VISIBLE);
    pushbulletSelection.setOnClickListener(new AttachmentOnClickListener());
  }
  private void takePhoto() {
    Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    if (!IntentChecker.isAvailable(mainActivity, intent, new String[]{FEATURE_CAMERA})) {
      mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.ALERT);
      return;
    }
    PermissionsHelper.requestPermission(this, CAMERA,
        R.string.permission_camera, binding.snackbarPlaceholder, () -> {
          // Checks for created file validity
          File f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_IMAGE_EXT);
          if (f == null) {
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
            return;
          }
          attachmentUri = Uri.fromFile(f);
          intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
          intent.putExtra(MediaStore.EXTRA_OUTPUT, FileProviderHelper.getFileProvider(f));
          startActivityForResult(intent, TAKE_PHOTO);
        });
  }
  private void takeVideo() {
    var takeVideoIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
    if (!IntentChecker.isAvailable(mainActivity, takeVideoIntent,
        new String[]{FEATURE_CAMERA})) {
      mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.ALERT);
      return;
    }
    PermissionsHelper.requestPermission(this, CAMERA,
        R.string.permission_camera, binding.snackbarPlaceholder, () -> {
          // File is stored in custom ON folder to speedup the attachment
          var f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_VIDEO_EXT);
          if (f == null) {
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
            return;
          }
          attachmentUri = Uri.fromFile(f);
          takeVideoIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
          takeVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, FileProviderHelper.getFileProvider(f));
          var maxVideoSizeStr = "".equals(Prefs.getString("settings_max_video_size", ""))
              ? "0" : Prefs.getString("settings_max_video_size", "");
          long maxVideoSize = parseLong(maxVideoSizeStr) * 1024L * 1024L;
          takeVideoIntent.putExtra(MediaStore.EXTRA_SIZE_LIMIT, maxVideoSize);
          startActivityForResult(takeVideoIntent, TAKE_VIDEO);
        });
  }
  private void takeSketch(Attachment attachment) {
    File f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_SKETCH_EXT);
    if (f == null) {
      mainActivity.showMessage(R.string.error, ONStyle.ALERT);
      return;
    }
    attachmentUri = Uri.fromFile(f);
    // Forces portrait orientation to this fragment only
    mainActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
    // Fragments replacing
    FragmentTransaction transaction = mainActivity.getSupportFragmentManager().beginTransaction();
    mainActivity.animateTransition(transaction, TRANSITION_HORIZONTAL);
    SketchFragment mSketchFragment = new SketchFragment();
    Bundle b = new Bundle();
    b.putParcelable(MediaStore.EXTRA_OUTPUT, attachmentUri);
    if (attachment != null) {
      b.putParcelable("base", attachment.getUri());
    }
    mSketchFragment.setArguments(b);
    transaction.replace(R.id.fragment_container, mSketchFragment, FRAGMENT_SKETCH_TAG)
        .addToBackStack(FRAGMENT_DETAIL_TAG).commit();
  }
  private void addTimestamp() {
    Editable editable = binding.fragmentDetailContent.detailContent.getText();
    int position = binding.fragmentDetailContent.detailContent.getSelectionStart();
    DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);
    String dateStamp = dateFormat.format(new Date().getTime()) + " ";
    if (noteTmp.isChecklist()) {
      if (mChecklistManager.getFocusedItemView() != null) {
        editable = mChecklistManager.getFocusedItemView().getEditText().getEditableText();
        position = mChecklistManager.getFocusedItemView().getEditText().getSelectionStart();
      } else {
        ((CheckListView) toggleChecklistView)
            .addItem(dateStamp, false, mChecklistManager.getCount());
      }
    }
    String leadSpace = position == 0 ? "" : " ";
    dateStamp = leadSpace + dateStamp;
    editable.insert(position, dateStamp);
    Selection.setSelection(editable, position + dateStamp.length());
  }
  @SuppressLint("NewApi")
  @Override
  public void onActivityResult(int requestCode, int resultCode, Intent intent) {
    // Fetch uri from activities, store into adapter and refresh adapter
    Attachment attachment;
    if (resultCode == Activity.RESULT_OK) {
      switch (requestCode) {
        case TAKE_PHOTO:
          attachment = new Attachment(attachmentUri, MIME_TYPE_IMAGE);
          addAttachment(attachment);
          mAttachmentAdapter.notifyDataSetChanged();
          mGridView.autoresize();
          break;
        case TAKE_VIDEO:
          attachment = new Attachment(attachmentUri, MIME_TYPE_VIDEO);
          addAttachment(attachment);
          mAttachmentAdapter.notifyDataSetChanged();
          mGridView.autoresize();
          break;
        case FILES:
          onActivityResultManageReceivedFiles(intent);
          break;
        case SET_PASSWORD:
          noteTmp.setPasswordChecked(true);
          lockUnlock();
          break;
        case SKETCH:
          attachment = new Attachment(attachmentUri, MIME_TYPE_SKETCH);
          addAttachment(attachment);
          mAttachmentAdapter.notifyDataSetChanged();
          mGridView.autoresize();
          break;
        case CATEGORY:
          mainActivity.showMessage(R.string.category_saved, ONStyle.CONFIRM);
          Category category = intent.getParcelableExtra("category");
          noteTmp.setCategory(category);
          setTagMarkerColor(category);
          break;
        case DETAIL:
          mainActivity.showMessage(R.string.note_updated, ONStyle.CONFIRM);
          break;
        default:
          LogDelegate.e("Wrong element choosen: " + requestCode);
      }
    }
  }
  private void onActivityResultManageReceivedFiles(Intent intent) {
    List<Uri> uris = new ArrayList<>();
    if (intent.getClipData() != null) {
      for (int i = 0; i < intent.getClipData().getItemCount(); i++) {
        uris.add(intent.getClipData().getItemAt(i).getUri());
      }
    } else {
      uris.add(intent.getData());
    }
    for (Uri uri : uris) {
      String name = FileHelper.getNameFromUri(mainActivity, uri);
      new AttachmentTask(this, uri, name, this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }
  }
  /**
   * Discards changes done to the note and eventually delete new attachments
   */
  private void discard() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.undo_changes_note_confirmation)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          if (!noteTmp.getAttachmentsList().equals(note.getAttachmentsList())) {
            for (Attachment newAttachment : noteTmp.getAttachmentsList()) {
              if (!note.getAttachmentsList().contains(newAttachment)) {
                StorageHelper.delete(mainActivity, newAttachment.getUri().getPath());
              }
            }
          }
          goBack = true;
          if (noteTmp.equals(noteOriginal)) {
            goHome();
          }
          if (noteOriginal.get_id() != null) {
            new SaveNoteTask(false).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteOriginal);
            BaseActivity.notifyAppWidgets(mainActivity);
          } else {
            goHome();
          }
        }).build().show();
  }
  @SuppressLint("NewApi")
  private void archiveNote(boolean archive) {
    // Simply go back if is a new note
    if (noteTmp.get_id() == null) {
      goHome();
      return;
    }
    noteTmp.setArchived(archive);
    goBack = true;
    exitMessage = archive ? getString(R.string.note_archived) : getString(R.string.note_unarchived);
    exitCroutonStyle = archive ? ONStyle.WARN : ONStyle.INFO;
    saveNote();
  }
  @SuppressLint("NewApi")
  private void trashNote(boolean trash) {
    // Simply go back if is a new note
    if (noteTmp.get_id() == null) {
      goHome();
      return;
    }
    noteTmp.setTrashed(trash);
    goBack = true;
    exitMessage = trash ? getString(R.string.note_trashed) : getString(R.string.note_untrashed);
    exitCroutonStyle = trash ? ONStyle.WARN : ONStyle.INFO;
    if (trash) {
      ShortcutHelper.removeShortcut(getAppContext(), noteTmp);
      ReminderHelper.removeReminder(getAppContext(), noteTmp);
    } else {
      ReminderHelper.addReminder(getAppContext(), note);
    }
    saveNote();
  }
  private void deleteNote() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.delete_note_confirmation)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          mainActivity.deleteNote(noteTmp);
          LogDelegate.d("Deleted note with ID '" + noteTmp.get_id() + "'");
          mainActivity.showMessage(R.string.note_deleted, ONStyle.ALERT);
          goHome();
        }).build().show();
  }
  public void saveAndExit() {
    if (isAdded()) {
      exitMessage = getString(R.string.note_updated);
      exitCroutonStyle = ONStyle.CONFIRM;
      goBack = true;
      saveNote();
    }
  }
  /**
   * Save new notes, modify them or archive
   */
  void saveNote() {
    noteTmp.setTitle(getNoteTitle());
    noteTmp.setContent(getNoteContent());
    // Check if some text or attachments of any type have been inserted or is an empty note
    if (goBack && TextUtils.isEmpty(noteTmp.getTitle()) && TextUtils.isEmpty(noteTmp.getContent())
        && noteTmp.getAttachmentsList().isEmpty()) {
      LogDelegate.d("Empty note not saved");
      exitMessage = getString(R.string.empty_note_not_saved);
      exitCroutonStyle = ONStyle.INFO;
      goHome();
      return;
    }
    if (saveNotNeeded()) {
      exitMessage = "";
      if (goBack) {
        goHome();
      }
      return;
    }
    noteTmp.setAttachmentsListOld(note.getAttachmentsList());
    new SaveNoteTask(lastModificationUpdatedNeeded()).executeOnExecutor(AsyncTask
        .THREAD_POOL_EXECUTOR, noteTmp);
  }
  /**
   * Checks if nothing is changed to avoid committing if possible (check)
   */
  private boolean saveNotNeeded() {
    if (noteTmp.get_id() == null && Prefs.getBoolean(PREF_AUTO_LOCATION, false)) {
      note.setLatitude(noteTmp.getLatitude());
      note.setLongitude(noteTmp.getLongitude());
    }
    return !noteTmp.isChanged(note) || (noteTmp.isLocked() && !noteTmp.isPasswordChecked());
  }
  /**
   * Checks if only tag, archive or trash status have been changed and then force to not update last
   * modification date*
   */
  private boolean lastModificationUpdatedNeeded() {
    note.setCategory(noteTmp.getCategory());
    note.setArchived(noteTmp.isArchived());
    note.setTrashed(noteTmp.isTrashed());
    note.setLocked(noteTmp.isLocked());
    return noteTmp.isChanged(note);
  }
  private void deleteMergedNotes(List<String> mergedNotesIds) {
    ArrayList<Note> notesToDelete = new ArrayList<>();
    if (mergedNotesIds != null) {
      for (String mergedNoteId : mergedNotesIds) {
        Note noteToDelete = new Note();
        noteToDelete.set_id(Long.valueOf(mergedNoteId));
        notesToDelete.add(noteToDelete);
      }
      new NoteProcessorDelete(notesToDelete).process();
    }
  }
  private String getNoteTitle() {
    if (!TextUtils.isEmpty(binding.detailTitle.getText())) {
      return binding.detailTitle.getText().toString();
    } else {
      return "";
    }
  }
  private String getNoteContent() {
    String contentText = "";
    if (Boolean.FALSE.equals(noteTmp.isChecklist())) {
      // Due to checklist library introduction the returned EditText class is no more a
      // com.neopixl.pixlui.components.edittext.EditText but a standard android.widget.EditText
      View contentView = binding.detailRoot.findViewById(R.id.detail_content);
      if (contentView instanceof EditText) {
        contentText = ((EditText) contentView).getText().toString();
      } else if (contentView instanceof android.widget.EditText) {
        contentText = ((android.widget.EditText) contentView).getText().toString();
      }
    } else {
      if (mChecklistManager != null) {
        mChecklistManager.keepChecked(true).showCheckMarks(true);
        contentText = mChecklistManager.getText();
      }
    }
    return contentText;
  }
  /**
   * Updates share intent
   */
  private void shareNote() {
    Note sharedNote = new Note(noteTmp);
    sharedNote.setTitle(getNoteTitle());
    sharedNote.setContent(getNoteContent());
    mainActivity.shareNote(sharedNote);
  }
  /**
   * Notes locking with security password to avoid viewing, editing or deleting from unauthorized
   */
  private void lockNote() {
    LogDelegate.d("Locking or unlocking note " + note.get_id());
    // If security password is not set yes will be set right now
    if (Prefs.getString(PREF_PASSWORD, null) == null) {
      Intent passwordIntent = new Intent(mainActivity, PasswordActivity.class);
      startActivityForResult(passwordIntent, SET_PASSWORD);
      return;
    }
    // If password has already been inserted will not be asked again
    if (noteTmp.isPasswordChecked() || Prefs.getBoolean("settings_password_access", false)) {
      lockUnlock();
      return;
    }
    // Password will be requested here
    PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
      if (passwordConfirmed == Result.SUCCEED) {
        lockUnlock();
      }
    });
  }
  private void lockUnlock() {
    // Empty password has been set
    if (Prefs.getString(PREF_PASSWORD, null) == null) {
      mainActivity.showMessage(R.string.password_not_set, ONStyle.WARN);
      return;
    }
    mainActivity.showMessage(R.string.save_note_to_lock_it, ONStyle.INFO);
    mainActivity.supportInvalidateOptionsMenu();
    noteTmp.setLocked(!noteTmp.isLocked());
    noteTmp.setPasswordChecked(true);
  }
  /**
   * Used to set actual reminder state when initializing a note to be edited
   */
  private String initReminder(Note note) {
    if (noteTmp.getAlarm() == null) {
      return "";
    }
    long reminder = parseLong(note.getAlarm());
    String rrule = note.getRecurrenceRule();
    if (!TextUtils.isEmpty(rrule)) {
      return RecurrenceHelper.getNoteRecurrentReminderText(reminder, rrule);
    } else {
      return RecurrenceHelper.getNoteReminderText(reminder);
    }
  }
  /**
   * Audio recordings playback
   */
  private void playback(View v, Uri uri) {
    // Some recording is playing right now
    if (mPlayer != null && mPlayer.isPlaying()) {
      if (isPlayingView != v) {
        // If the audio actually played is NOT the one from the click view the last one is played
        stopPlaying();
        isPlayingView = v;
        startPlaying(uri);
        replacePlayingAudioBitmap(v);
      } else {
        // Otherwise just stops playing
        stopPlaying();
      }
    } else {
      // If nothing is playing audio just plays
      isPlayingView = v;
      startPlaying(uri);
      replacePlayingAudioBitmap(v);
    }
  }
  private void replacePlayingAudioBitmap(View v) {
    Drawable d = ((ImageView) v.findViewById(R.id.gridview_item_picture)).getDrawable();
    if (BitmapDrawable.class.isAssignableFrom(d.getClass())) {
      recordingBitmap = ((BitmapDrawable) d).getBitmap();
    } else {
      recordingBitmap = ((BitmapDrawable) d.getCurrent()).getBitmap();
    }
    ((ImageView) v.findViewById(R.id.gridview_item_picture)).setImageBitmap(ThumbnailUtils
        .extractThumbnail(BitmapFactory.decodeResource(mainActivity.getResources(),
            R.drawable.stop), THUMBNAIL_SIZE, THUMBNAIL_SIZE));
  }
  private void startPlaying(Uri uri) {
    if (mPlayer == null) {
      mPlayer = new MediaPlayer();
    }
    try {
      mPlayer.setDataSource(mainActivity, uri);
      mPlayer.prepare();
      mPlayer.start();
      mPlayer.setOnCompletionListener(mp -> {
        mPlayer = null;
        if (isPlayingView != null) {
          ((ImageView) isPlayingView.findViewById(R.id.gridview_item_picture)).setImageBitmap
              (recordingBitmap);
          recordingBitmap = null;
          isPlayingView = null;
        }
      });
    } catch (IOException e) {
      LogDelegate.e("prepare() failed", e);
      mainActivity.showMessage(R.string.error, ONStyle.ALERT);
    }
  }
  private void stopPlaying() {
    if (mPlayer != null) {
      if (isPlayingView != null) {
        ((ImageView) isPlayingView.findViewById(R.id.gridview_item_picture))
            .setImageBitmap(recordingBitmap);
      }
      isPlayingView = null;
      recordingBitmap = null;
      mPlayer.release();
      mPlayer = null;
    }
  }
  private void startRecording(View v) {
    PermissionsHelper.requestPermission(this, Manifest.permission.RECORD_AUDIO,
        R.string.permission_audio_recording, binding.snackbarPlaceholder, () -> {
          isRecording = true;
          toggleAudioRecordingStop(v);
          File f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_AUDIO_EXT);
          if (f == null) {
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
            return;
          }
          if (mRecorder == null) {
            mRecorder = new MediaRecorder();
            mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
            mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);
            mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);
            mRecorder.setAudioEncodingBitRate(96000);
            mRecorder.setAudioSamplingRate(44100);
          }
          recordName = f.getAbsolutePath();
          mRecorder.setOutputFile(recordName);
          try {
            audioRecordingTimeStart = Calendar.getInstance().getTimeInMillis();
            mRecorder.prepare();
            mRecorder.start();
          } catch (IOException | IllegalStateException e) {
            LogDelegate.e("prepare() failed", e);
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
          }
        });
  }
  private void toggleAudioRecordingStop(View v) {
    if (isRecording) {
      ((android.widget.TextView) v).setText(getString(R.string.stop));
      ((android.widget.TextView) v).setTextColor(Color.parseColor("#ff0000"));
    }
  }
  private void stopRecording() {
    isRecording = false;
    if (mRecorder != null) {
      mRecorder.stop();
      audioRecordingTime = Calendar.getInstance().getTimeInMillis() - audioRecordingTimeStart;
      mRecorder.release();
      mRecorder = null;
    }
  }
  private void fade(final View v, boolean fadeIn) {
    int anim = R.animator.fade_out_support;
    int visibilityTemp = View.GONE;
    if (fadeIn) {
      anim = R.animator.fade_in_support;
      visibilityTemp = View.VISIBLE;
    }
    final int visibility = visibilityTemp;
    // Checks if user has left the app
    if (mainActivity != null) {
      Animation mAnimation = AnimationUtils.loadAnimation(mainActivity, anim);
      mAnimation.setAnimationListener(new AnimationListener() {
        @Override
        public void onAnimationStart(Animation animation) {
          // Nothing to do
        }
        @Override
        public void onAnimationRepeat(Animation animation) {
          // Nothing to do
        }
        @Override
        public void onAnimationEnd(Animation animation) {
          v.setVisibility(visibility);
        }
      });
      v.startAnimation(mAnimation);
    }
  }
  /**
   * Pin note as ongoing notifications
   */
  private void pinNote() {
    if (!new NotificationsHelper(getAppContext()).checkNotificationsEnabled(getAppContext())) {
      mainActivity.showToast(getText(R.string.denied_notifications_permission), Toast.LENGTH_LONG);
      return;
    }
    
    PendingIntent notifyIntent = IntentHelper
        .getNotePendingIntent(getContext(), SnoozeActivity.class, ACTION_PINNED, note);
    Spanned[] titleAndContent = TextHelper.parseTitleAndContent(getContext(), note);
    String pinnedTitle = titleAndContent[0].toString();
    String pinnedContent = titleAndContent[1].toString();
    NotificationsHelper notificationsHelper = new NotificationsHelper(getContext());
    notificationsHelper
        .createOngoingNotification(NotificationChannelNames.PINNED, R.drawable.ic_stat_notification,
            pinnedTitle, notifyIntent).setMessage(pinnedContent);
    List<Attachment> attachments = note.getAttachmentsList();
    if (!attachments.isEmpty() && !attachments.get(0).getMime_type().equals(MIME_TYPE_FILES)) {
      Bitmap notificationIcon = BitmapHelper
          .getBitmapFromAttachment(getContext(), note.getAttachmentsList().get(0), 128,
              128);
      notificationsHelper.setLargeIcon(notificationIcon);
    }
    PendingIntent unpinIntent = IntentHelper
        .getNotePendingIntent(getContext(), SnoozeActivity.class, ACTION_DISMISS, note);
    notificationsHelper.getBuilder()
        .addAction(R.drawable.ic_material_reminder_time_light, getContext().getString(R.string.done), unpinIntent);
    notificationsHelper.show(note.get_id());
  }
  /**
   * Adding shortcut on Home screen
   */
  private void addShortcut() {
    ShortcutHelper.addShortcut(getAppContext(), noteTmp);
    mainActivity.showMessage(R.string.shortcut_added, ONStyle.INFO);
  }
  @SuppressLint("NewApi")
  @Override
  public boolean onTouch(View v, MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();
    switch (event.getAction()) {
      case MotionEvent.ACTION_DOWN:
        LogDelegate.v("MotionEvent.ACTION_DOWN");
        int w;
        Point displaySize = Display.getUsableSize(mainActivity);
        w = displaySize.x;
        if (x < SWIPE_MARGIN || x > w - SWIPE_MARGIN) {
          swiping = true;
          startSwipeX = x;
        }
        break;
      case MotionEvent.ACTION_UP:
        LogDelegate.v("MotionEvent.ACTION_UP");
        if (swiping) {
          swiping = false;
        }
        break;
      case MotionEvent.ACTION_MOVE:
        if (swiping) {
          LogDelegate.v("MotionEvent.ACTION_MOVE at position " + x + ", " + y);
          if (Math.abs(x - startSwipeX) > SWIPE_OFFSET) {
            swiping = false;
            FragmentTransaction transaction = mainActivity.getSupportFragmentManager()
                .beginTransaction();
            mainActivity.animateTransition(transaction, TRANSITION_VERTICAL);
            DetailFragment mDetailFragment = new DetailFragment();
            Bundle b = new Bundle();
            b.putParcelable(INTENT_NOTE, new Note());
            mDetailFragment.setArguments(b);
            transaction.replace(R.id.fragment_container, mDetailFragment, FRAGMENT_DETAIL_TAG)
                .addToBackStack(
                    FRAGMENT_DETAIL_TAG).commit();
          }
        }
        break;
      default:
        LogDelegate.e("Wrong element choosen: " + event.getAction());
    }
    return true;
  }
  @Override
  public void onAttachingFileErrorOccurred(Attachment mAttachment) {
    mainActivity.showMessage(R.string.error_saving_attachments, ONStyle.ALERT);
    if (noteTmp.getAttachmentsList().contains(mAttachment)) {
      removeAttachment(mAttachment);
      mAttachmentAdapter.notifyDataSetChanged();
      mGridView.autoresize();
    }
  }
  private void addAttachment(Attachment attachment) {
    noteTmp.addAttachment(attachment);
  }
  private void removeAttachment(Attachment mAttachment) {
    noteTmp.removeAttachment(mAttachment);
  }
  private void removeAttachment(int position) {
    noteTmp.removeAttachment(noteTmp.getAttachmentsList().get(position));
  }
  private void removeAllAttachments() {
    noteTmp.setAttachmentsList(new ArrayList<>());
    mAttachmentAdapter = new AttachmentAdapter(mainActivity, new ArrayList<>());
    mGridView.invalidateViews();
    mGridView.setAdapter(mAttachmentAdapter);
  }
  @Override
  public void onAttachingFileFinished(Attachment mAttachment) {
    addAttachment(mAttachment);
    mAttachmentAdapter.notifyDataSetChanged();
    mGridView.autoresize();
  }
  @Override
  public void onReminderPicked(long reminder) {
    noteTmp.setAlarm(reminder);
    if (mFragment.isAdded()) {
      binding.fragmentDetailContent.reminderIcon.setImageResource(R.drawable.ic_alarm_black_18dp);
      binding.fragmentDetailContent.datetime
          .setText(RecurrenceHelper.getNoteReminderText(reminder));
    }
  }
  @Override
  public void onRecurrenceReminderPicked(String recurrenceRule) {
    noteTmp.setRecurrenceRule(recurrenceRule);
    if (!TextUtils.isEmpty(recurrenceRule)) {
      LogDelegate.d("Recurrent reminder set: " + recurrenceRule);
      binding.fragmentDetailContent.datetime.setText(RecurrenceHelper
          .getNoteRecurrentReminderText(Long.parseLong(noteTmp.getAlarm()), recurrenceRule));
    }
  }
  @Override
  public void onTextChanged(CharSequence s, int start, int before, int count) {
    scrollContent();
  }
  @Override
  public void beforeTextChanged(CharSequence s, int start, int count, int after) {
    // Nothing to do
  }
  @Override
  public void afterTextChanged(Editable s) {
    // Nothing to do
  }
  @Override
  public void onCheckListChanged() {
    scrollContent();
  }
  private void scrollContent() {
    if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
      if (mChecklistManager.getCount() > contentLineCounter) {
        binding.contentWrapper.scrollBy(0, 60);
      }
      contentLineCounter = mChecklistManager.getCount();
    } else {
      if (binding.fragmentDetailContent.detailContent.getLineCount() > contentLineCounter) {
        binding.contentWrapper.scrollBy(0, 60);
      }
      contentLineCounter = binding.fragmentDetailContent.detailContent.getLineCount();
    }
  }
  /**
   * Add previously created tags to content
   */
  private void addTags() {
    contentCursorPosition = getCursorIndex();
    final List<Tag> tags = TagsHelper.getAllTags();
    if (tags.isEmpty()) {
      mainActivity.showMessage(R.string.no_tags_created, ONStyle.WARN);
      return;
    }
    final Note currentNote = new Note();
    currentNote.setTitle(getNoteTitle());
    currentNote.setContent(getNoteContent());
    Integer[] preselectedTags = TagsHelper.getPreselectedTagsArray(currentNote, tags);
    // Dialog and events creation
    MaterialDialog dialog = new MaterialDialog.Builder(mainActivity)
        .title(R.string.select_tags)
        .positiveText(R.string.ok)
        .items(TagsHelper.getTagsArray(tags))
        .itemsCallbackMultiChoice(preselectedTags, (dialog1, which, text) -> {
          dialog1.dismiss();
          tagNote(tags, which, currentNote);
          return false;
        }).build();
    dialog.show();
  }
  private void tagNote(List<Tag> tags, Integer[] selectedTags, Note note) {
    var taggingResult = TagsHelper.addTagToNote(tags, selectedTags, note);
    if (!taggingResult.first.isEmpty()) {
      if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
        tagChecklistNote(taggingResult);
      } else {
        tagTextNote(taggingResult);
      }
    }
    eventuallyRemoveDeselectedTags(taggingResult.second);
  }
  private void tagTextNote(Pair<String, List<Tag>> taggingResult) {
    var sb = new StringBuilder(getNoteContent());
    var detailContent = binding.fragmentDetailContent.detailContent;
    if (detailContent.hasFocus()) {
      if (!taggingResult.first.isEmpty()) {
        sb.insert(contentCursorPosition, " " + taggingResult.first + " ");
      }
      detailContent.setText(sb.toString());
      detailContent.setSelection(contentCursorPosition + taggingResult.first.length() + 1);
    } else {
      if (!getNoteContent().trim().isEmpty()) {
        sb.append(System.getProperty("line.separator")).append(System.getProperty("line.separator"));
      }
      sb.append(taggingResult.first);
      detailContent.setText(sb.toString());
    }
  }
  private void tagChecklistNote(Pair<String, List<Tag>> taggingResult) {
    StringBuilder sb;
    var checkListItem = mChecklistManager.getFocusedItemView();
    if (checkListItem != null) {
      sb = new StringBuilder(checkListItem.getText());
      if (!taggingResult.first.isEmpty()) {
        sb.insert(contentCursorPosition, " " + taggingResult.first + " ");
      }
      checkListItem.setText(sb.toString());
      checkListItem.getEditText().setSelection(contentCursorPosition + taggingResult.first.length() + 1);
    } else {
      binding.detailTitle.append(" " + taggingResult.first);
    }
  }
  private void eventuallyRemoveDeselectedTags(List<Tag> tagsToRemove) {
    if (CollectionUtils.isEmpty(tagsToRemove)) {
      return;
    }
    boolean currentlyChecklist = Boolean.TRUE.equals(noteTmp.isChecklist());
    if (currentlyChecklist) {
      toggleChecklist2(true, true);
    }
    String titleWithoutTags = TagsHelper.removeTags(getNoteTitle(), tagsToRemove);
    binding.detailTitle.setText(titleWithoutTags);
    String contentWithoutTags = TagsHelper.removeTags(getNoteContent(), tagsToRemove);
    binding.fragmentDetailContent.detailContent.setText(contentWithoutTags);
    if (currentlyChecklist) {
      toggleChecklist2();
    }
  }
  private int getCursorIndex() {
    if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
      CheckListViewItem mCheckListViewItem = mChecklistManager.getFocusedItemView();
      return mCheckListViewItem != null ? mCheckListViewItem.getEditText().getSelectionStart() : 0;
    } else {
      return binding.fragmentDetailContent.detailContent.getSelectionStart();
    }
  }
  /**
   * Used to check currently opened note from activity to avoid opening multiple times the same one
   */
  public Note getCurrentNote() {
    return note;
  }
  private boolean isNoteLocationValid() {
    return noteTmp.getLatitude() != null
        && noteTmp.getLatitude() != 0
        && noteTmp.getLongitude() != null
        && noteTmp.getLongitude() != 0;
  }
  public void startGetContentAction() {
    Intent filesIntent;
    filesIntent = new Intent(Intent.ACTION_GET_CONTENT);
    filesIntent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);
    filesIntent.addCategory(Intent.CATEGORY_OPENABLE);
    filesIntent.setType("*/*");
    startActivityForResult(filesIntent, FILES);
  }
  public void onEventMainThread(PushbulletReplyEvent pushbulletReplyEvent) {
    String text =
        getNoteContent() + System.getProperty("line.separator") + pushbulletReplyEvent.getMessage();
    binding.fragmentDetailContent.detailContent.setText(text);
  }
  public void onEvent(NotesUpdatedEvent event) {
    if (!activityPausing) {
      deleteMergedNotes(mergedNotesIds);
      if (noteTmp.getAlarm() != null && !noteTmp.getAlarm().equals(note.getAlarm())) {
        ReminderHelper.showReminderMessage(String.valueOf(noteTmp.getAlarm()));
      }
    }
    note = new Note(event.getNotes().get(0));
    if (goBack) {
      goHome();
    }
  }
  private static class OnGeoUtilResultListenerImpl implements OnGeoUtilResultListener {
    private final WeakReference<MainActivity> mainActivityWeakReference;
    private final WeakReference<DetailFragment> detailFragmentWeakReference;
    private final WeakReference<Note> noteTmpWeakReference;
    OnGeoUtilResultListenerImpl(MainActivity activity, DetailFragment mFragment, Note noteTmp) {
      mainActivityWeakReference = new WeakReference<>(activity);
      detailFragmentWeakReference = new WeakReference<>(mFragment);
      noteTmpWeakReference = new WeakReference<>(noteTmp);
    }
    @Override
    public void onAddressResolved(String address) {
      // Nothing to do
    }
    @Override
    public void onCoordinatesResolved(Location location, String address) {
      // Nothing to do
    }
    @Override
    public void onLocationUnavailable() {
      mainActivityWeakReference.get().showMessage(R.string.location_not_found, ONStyle.ALERT);
    }
    @Override
    public void onLocationNotEnabled(){
      mainActivityWeakReference.get().showMessage(R.string.location_not_enabled,ONStyle.ALERT);
    }
    @Override
    public void onLocationRetrieved(Location location) {
      if (!checkWeakReferences()) {
        return;
      }
      if (location == null) {
        return;
      }
      LayoutInflater inflater = mainActivityWeakReference.get().getLayoutInflater();
      View v = inflater.inflate(R.layout.dialog_location, null);
      final AutoCompleteTextView autoCompView = v.findViewById(R.id
          .auto_complete_location);
      autoCompView.setHint(mainActivityWeakReference.get().getString(R.string.search_location));
      autoCompView
          .setAdapter(new PlacesAutoCompleteAdapter(mainActivityWeakReference.get(), R.layout
              .simple_text_layout));
      final MaterialDialog dialog = new MaterialDialog.Builder(mainActivityWeakReference.get())
          .customView(autoCompView, false)
          .positiveText(R.string.use_current_location)
          .onPositive((dialog1, which) -> {
            if (TextUtils.isEmpty(autoCompView.getText().toString())) {
              noteTmpWeakReference.get().setLatitude(location.getLatitude());
              noteTmpWeakReference.get().setLongitude(location.getLongitude());
              GeocodeHelper.getAddressFromCoordinates(location, detailFragmentWeakReference.get());
            } else {
              GeocodeHelper.getCoordinatesFromAddress(autoCompView.getText().toString(),
                  detailFragmentWeakReference.get());
            }
          })
          .build();
      autoCompView.addTextChangedListener(new TextWatcher() {
        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
          // Nothing to do
        }
        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
          if (s.length() != 0) {
            dialog
                .setActionButton(DialogAction.POSITIVE, mainActivityWeakReference.get().getString(R
                    .string.confirm));
          } else {
            dialog
                .setActionButton(DialogAction.POSITIVE, mainActivityWeakReference.get().getString(R
                    .string
                    .use_current_location));
          }
        }
        @Override
        public void afterTextChanged(Editable s) {
          // Nothing to do
        }
      });
      dialog.show();
    }
    private boolean checkWeakReferences() {
      return mainActivityWeakReference.get() != null && !mainActivityWeakReference.get()
          .isFinishing()
          && detailFragmentWeakReference.get() != null && noteTmpWeakReference.get() != null;
    }
  }
  /**
   * Manages clicks on attachment dialog
   */
  @SuppressLint("InlinedApi")
  private class AttachmentOnClickListener implements OnClickListener {
    @Override
    public void onClick(View v) {
      switch (v.getId()) {
        case R.id.camera:
//          requestCameraPermission(TAKE_PHOTO);
          takePhoto();
          break;
        case R.id.recording:
          if (!isRecording) {
            startRecording(v);
          } else {
            stopRecording();
            Attachment attachment = new Attachment(Uri.fromFile(new File(recordName)),
                MIME_TYPE_AUDIO);
            attachment.setLength(audioRecordingTime);
            addAttachment(attachment);
            mAttachmentAdapter.notifyDataSetChanged();
            mGridView.autoresize();
          }
          break;
        case R.id.video:
          takeVideo();
          break;
        case R.id.files:
          startGetContentAction();
          break;
        case R.id.sketch:
          takeSketch(null);
          break;
        case R.id.location:
          displayLocationDialog();
          break;
        case R.id.timestamp:
          addTimestamp();
          break;
        case R.id.pushbullet:
          MessagingExtension.mirrorMessage(mainActivity, getString(R.string.app_name),
              getString(R.string.pushbullet),
              getNoteContent(), BitmapFactory.decodeResource(getResources(),
                  R.drawable.ic_stat_literal_icon),
              null, 0);
          break;
        default:
          LogDelegate.e("Wrong element choosen: " + v.getId());
      }
      if (!isRecording) {
        attachmentDialog.dismiss();
      }
    }
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_CATEGORY;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import static java.lang.Integer.parseInt;
import android.graphics.Point;
import android.graphics.PorterDuff;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.View;
import android.view.ViewGroup.LayoutParams;
import android.view.Window;
import android.view.WindowManager;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import com.afollestad.materialdialogs.MaterialDialog;
import com.afollestad.materialdialogs.color.ColorChooserDialog;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.async.bus.CategoriesUpdatedEvent;
import it.feio.android.omninotes.databinding.ActivityCategoryBinding;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.utils.Display;
import it.feio.android.omninotes.utils.RandomUtils;
import it.feio.android.simplegallery.util.BitmapUtils;
import java.util.Calendar;
public class CategoryActivity extends AppCompatActivity implements
    ColorChooserDialog.ColorCallback {
  private ActivityCategoryBinding binding;
  private Category category;
  private int selectedColor;
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    binding = ActivityCategoryBinding.inflate(getLayoutInflater());
    View view = binding.getRoot();
    setContentView(view);
    category = savedInstanceState != null
        ? savedInstanceState.getParcelable("category")
        : getIntent().getParcelableExtra(INTENT_CATEGORY);
    if (category == null) {
      LogDelegate.d("Adding new category");
      category = new Category();
      category.setColor(String.valueOf(getRandomPaletteColor()));
    } else {
      LogDelegate.d("Editing category " + category.getName());
    }
    selectedColor = parseInt(category.getColor());
    populateViews();
    resetWindowSize();
  }
  @Override
  public void onSaveInstanceState(Bundle outState) {
    outState.putParcelable("category", category);
    super.onSaveInstanceState(outState);
  }
  private void resetWindowSize() {
    Point screen = Display.getScreenDimensions(this);
    Window window = getWindow();
    WindowManager.LayoutParams params = window.getAttributes();
    params.width = (int) (screen.x * 0.6);
    params.height = LayoutParams.WRAP_CONTENT;
    window.setAttributes(params);
  }
  private int getRandomPaletteColor() {
    int[] paletteArray = getResources().getIntArray(R.array.material_colors);
    return paletteArray[RandomUtils.getRandomInt(paletteArray.length)];
  }
  public void showColorChooserCustomColors() {
    new ColorChooserDialog.Builder(this, R.string.colors)
        .dynamicButtonColor(false)
        .preselect(selectedColor)
        .show(this);
  }
  @Override
  public void onColorSelection(@NonNull ColorChooserDialog colorChooserDialog, int color) {
    BitmapUtils.changeImageViewDrawableColor(binding.colorChooser, color);
    selectedColor = color;
  }
  @Override
  public void onColorChooserDismissed(@NonNull ColorChooserDialog dialog) {
    // Nothing to do
  }
  @Override
  public void onPointerCaptureChanged(boolean hasCapture) {
    // Nothing to do
  }
  private void populateViews() {
    binding.categoryTitle.setText(category.getName());
    binding.categoryDescription.setText(category.getDescription());
    // Reset picker to saved color
    String color = category.getColor();
    if (color != null && color.length() > 0) {
      binding.colorChooser.getDrawable().mutate()
          .setColorFilter(parseInt(color), PorterDuff.Mode.SRC_ATOP);
    }
    binding.delete
        .setVisibility(TextUtils.isEmpty(category.getName()) ? View.INVISIBLE : View.VISIBLE);
    binding.save.setOnClickListener(v -> saveCategory());
    binding.delete.setOnClickListener(v -> deleteCategory());
    binding.colorChooser.setOnClickListener(v -> showColorChooserCustomColors());
  }
  public void saveCategory() {
    if (binding.categoryTitle.getText().toString().length() == 0) {
      binding.categoryTitle.setError(getString(R.string.category_missing_title));
      return;
    }
    Long id =
        category.getId() != null ? category.getId() : Calendar.getInstance().getTimeInMillis();
    category.setId(id);
    category.setName(binding.categoryTitle.getText().toString());
    category.setDescription(binding.categoryDescription.getText().toString());
    if (selectedColor != 0 || category.getColor() == null) {
      category.setColor(String.valueOf(selectedColor));
    }
    // Saved to DB and new ID or update result catched
    DbHelper db = DbHelper.getInstance();
    category = db.updateCategory(category);
    // Sets result to show proper message
    getIntent().putExtra(INTENT_CATEGORY, category);
    setResult(RESULT_OK, getIntent());
    finish();
  }
  public void deleteCategory() {
    var dialogBuilder = new MaterialDialog.Builder(this)
        .title(R.string.delete_unused_category_confirmation)
        .positiveText(R.string.confirm)
        .positiveColorRes(R.color.colorAccent)
        .onPositive((dialog, which) -> {
          // Changes navigation if actually are shown notes associated with this category
          String navNotes = getResources().getStringArray(R.array.navigation_list_codes)[0];
          String navigation = Prefs.getString(PREF_NAVIGATION, navNotes);
          if (String.valueOf(category.getId()).equals(navigation)) {
            Prefs.edit().putString(PREF_NAVIGATION, navNotes).apply();
          }
          DbHelper.getInstance().deleteCategory(category);
          EventBus.getDefault().post(new CategoriesUpdatedEvent());
          BaseActivity.notifyAppWidgets(OmniNotes.getAppContext());
          setResult(RESULT_FIRST_USER);
          finish();
        });
    if (category.getCount() > 0) {
      dialogBuilder.content(R.string.delete_category_confirmation);
    }
    dialogBuilder.build().show();
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.helpers;
import static it.feio.android.checklistview.interfaces.Constants.TAG;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_ENABLE_FILE_LOGGING;
import android.content.Context;
import android.util.Log;
import com.bosphere.filelogger.FL;
import com.bosphere.filelogger.FLConfig;
import com.bosphere.filelogger.FLConst;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.exceptions.GenericException;
import it.feio.android.omninotes.utils.StorageHelper;
import java.io.File;
import lombok.experimental.UtilityClass;
@UtilityClass
public class LogDelegate {
  private static Boolean fileLoggingEnabled;
  public static void v(String message) {
    if (isFileLoggingEnabled()) {
      FL.v(message);
    } else {
      Log.v(TAG, message);
    }
  }
  public static void d(String message) {
    if (isFileLoggingEnabled()) {
      FL.d(message);
    } else {
      Log.d(TAG, message);
    }
  }
  public static void i(String message) {
    if (isFileLoggingEnabled()) {
      FL.i(message);
    } else {
      Log.i(TAG, message);
    }
  }
  public static void w(String message, Throwable e) {
    if (isFileLoggingEnabled()) {
      FL.w(message, e);
    } else {
      Log.w(TAG, message, e);
    }
  }
  public static void w(String message) {
    if (isFileLoggingEnabled()) {
      FL.w(message);
    } else {
      Log.w(TAG, message);
    }
  }
  public static void e(String message, Throwable e) {
    if (isFileLoggingEnabled()) {
      FL.e(message, e);
    } else {
      Log.e(TAG, message, e);
    }
  }
  public static void e(String message) {
    e(message, new GenericException(message));
  }
  private static boolean isFileLoggingEnabled() {
    if (fileLoggingEnabled == null) {
      fileLoggingEnabled = Prefs.getBoolean(PREF_ENABLE_FILE_LOGGING, false);
      if (Boolean.TRUE.equals(fileLoggingEnabled)) {
        Context context = OmniNotes.getAppContext();
        FL.init(new FLConfig.Builder(context)
            .minLevel(FLConst.Level.V)
            .logToFile(true)
            .dir(new File(StorageHelper.getOrCreateExternalStoragePublicDir(), "logs"))
            .retentionPolicy(FLConst.RetentionPolicy.FILE_COUNT)
            .build());
        FL.setEnabled(true);
      }
    }
    return fileLoggingEnabled;
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import static android.content.DialogInterface.BUTTON_POSITIVE;
import static android.text.Html.fromHtml;
import static android.text.TextUtils.isEmpty;
import static androidx.core.view.ViewCompat.animate;
import static it.feio.android.omninotes.helpers.BuildHelper.isDebugBuild;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_FAB_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_MERGE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_POSTPONE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SEARCH_UNCOMPLETE_CHECKLISTS;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_SHOW_LIST;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_CATEGORY;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.MENU_SORT_GROUP_ID;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_ENABLE_SWIPE;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_EXPANDED_VIEW;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FAB_EXPANSION_BEHAVIOR;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FILTER_ARCHIVED_IN_CATEGORIES;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FILTER_PAST_REMINDERS;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_SORTING_COLUMN;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_WIDGET_PREFIX;
import static it.feio.android.omninotes.utils.Navigation.checkNavigation;
import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.drawable.AnimationDrawable;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Parcelable;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MenuItem.OnActionExpandListener;
import android.view.MotionEvent;
import android.view.SubMenu;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.EditorInfo;
import android.widget.ImageView;
import android.widget.LinearLayout;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.view.ActionMode;
import androidx.appcompat.widget.SearchView;
import androidx.appcompat.widget.SearchView.OnQueryTextListener;
import androidx.core.util.Pair;
import androidx.core.view.GravityCompat;
import androidx.recyclerview.widget.DefaultItemAnimator;
import androidx.recyclerview.widget.DividerItemDecoration;
import androidx.recyclerview.widget.ItemTouchHelper;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import com.afollestad.materialdialogs.MaterialDialog;
import com.google.android.material.dialog.MaterialAlertDialogBuilder;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import de.keyboardsurfer.android.widget.crouton.Crouton;
import de.keyboardsurfer.android.widget.crouton.Style;
import it.feio.android.omninotes.async.bus.CategoriesUpdatedEvent;
import it.feio.android.omninotes.async.bus.NavigationUpdatedNavDrawerClosedEvent;
import it.feio.android.omninotes.async.bus.NotesLoadedEvent;
import it.feio.android.omninotes.async.bus.NotesMergeEvent;
import it.feio.android.omninotes.async.bus.NotesUpdatedEvent;
import it.feio.android.omninotes.async.bus.PasswordRemovedEvent;
import it.feio.android.omninotes.async.notes.NoteLoaderTask;
import it.feio.android.omninotes.async.notes.NoteProcessorArchive;
import it.feio.android.omninotes.async.notes.NoteProcessorCategorize;
import it.feio.android.omninotes.async.notes.NoteProcessorDelete;
import it.feio.android.omninotes.async.notes.NoteProcessorTrash;
import it.feio.android.omninotes.databinding.FragmentListBinding;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.NotesHelper;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.models.PasswordValidator;
import it.feio.android.omninotes.models.Tag;
import it.feio.android.omninotes.models.UndoBarController;
import it.feio.android.omninotes.models.adapters.CategoryRecyclerViewAdapter;
import it.feio.android.omninotes.models.adapters.NoteAdapter;
import it.feio.android.omninotes.models.listeners.OnViewTouchedListener;
import it.feio.android.omninotes.models.listeners.RecyclerViewItemClickSupport;
import it.feio.android.omninotes.models.views.Fab;
import it.feio.android.omninotes.utils.AnimationsHelper;
import it.feio.android.omninotes.utils.IntentChecker;
import it.feio.android.omninotes.utils.KeyboardUtils;
import it.feio.android.omninotes.utils.Navigation;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.TagsHelper;
import it.feio.android.omninotes.utils.TextHelper;
import it.feio.android.pixlui.links.UrlCompleter;
import it.feio.android.simplegallery.util.BitmapUtils;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.stream.IntStream;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.ObjectUtils;
public class ListFragment extends BaseFragment implements OnViewTouchedListener,
    UndoBarController.UndoListener {
  private static final int REQUEST_CODE_CATEGORY = 1;
  private static final int REQUEST_CODE_CATEGORY_NOTES = 2;
  private static final int REQUEST_CODE_ADD_ALARMS = 3;
  public static final String LIST_VIEW_POSITION = "listViewPosition";
  public static final String LIST_VIEW_POSITION_OFFSET = "listViewPositionOffset";
  private FragmentListBinding binding;
  private final List<Note> selectedNotes = new ArrayList<>();
  private SearchView searchView;
  private MenuItem searchMenuItem;
  private Menu menu;
  private AnimationDrawable jinglesAnimation;
  private int listViewPosition;
  private int listViewPositionOffset = 16;
  private boolean sendToArchive;
  private ListFragment mFragment;
  private ActionMode actionMode;
  private boolean keepActionMode = false;
  // Undo archive/trash
  private boolean undoTrash = false;
  private boolean undoArchive = false;
  private boolean undoCategorize = false;
  private Category undoCategorizeCategory = null;
  private final SortedMap<Integer, Note> undoNotesMap = new TreeMap<>();
  // Used to remember removed categories from notes
  private final Map<Note, Category> undoCategoryMap = new HashMap<>();
  // Used to remember archived state from notes
  private final Map<Note, Boolean> undoArchivedMap = new HashMap<>();
  // Search variables
  private String searchQuery;
  private String searchQueryInstant;
  private String searchTags;
  private boolean searchUncompleteChecklists;
  private boolean goBackOnToggleSearchLabel = false;
  private boolean searchLabelActive = false;
  private NoteAdapter listAdapter;
  private UndoBarController ubc;
  private Fab fab;
  private MainActivity mainActivity;
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mFragment = this;
    setHasOptionsMenu(true);
    setRetainInstance(true);
    EventBus.getDefault().register(this, 1);
  }
  @Override
  public void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
  }
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container,
      Bundle savedInstanceState) {
    if (savedInstanceState != null) {
      if (savedInstanceState.containsKey(LIST_VIEW_POSITION)) {
        listViewPosition = savedInstanceState.getInt(LIST_VIEW_POSITION);
        listViewPositionOffset = savedInstanceState.getInt(LIST_VIEW_POSITION_OFFSET);
        searchQuery = savedInstanceState.getString("searchQuery");
        searchTags = savedInstanceState.getString("searchTags");
      }
      keepActionMode = false;
    }
    binding = FragmentListBinding.inflate(inflater, container, false);
    View view = binding.getRoot();
    binding.list.setHasFixedSize(true);
    LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getContext());
    binding.list.setLayoutManager(linearLayoutManager);
    DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(
        binding.list.getContext(),
        linearLayoutManager.getOrientation());
    dividerItemDecoration
        .setDrawable(getResources().getDrawable(R.drawable.fragment_list_item_divider));
    binding.list.addItemDecoration(dividerItemDecoration);
    RecyclerView.ItemAnimator itemAnimator = new DefaultItemAnimator();
    itemAnimator.setAddDuration(1000);
    itemAnimator.setRemoveDuration(1000);
    binding.list.setItemAnimator(itemAnimator);
    // Replace listview with Mr. Jingles if it is empty
    binding.list.setEmptyView(binding.emptyList);
    return view;
  }
  @Override
  public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    mainActivity = (MainActivity) getActivity();
    if (mainActivity!= null && savedInstanceState != null) {
      mainActivity.navigationTmp = savedInstanceState.getString("navigationTmp");
    }
    init();
  }
  private void init() {
    initEasterEgg();
    initListView();
    ubc = new UndoBarController(binding.undobar.getRoot(), this);
    initNotesList(mainActivity.getIntent());
    initFab();
    initTitle();
  }
  private void initFab() {
    fab = new Fab(binding.fab.getRoot(), binding.list,
        Prefs.getBoolean(PREF_FAB_EXPANSION_BEHAVIOR, false));
    fab.setOnFabItemClickedListener(id -> {
      View v = mainActivity.findViewById(id);
      switch (id) {
        case R.id.fab_camera:
          Intent i = mainActivity.getIntent();
          i.setAction(ACTION_FAB_TAKE_PHOTO);
          mainActivity.setIntent(i);
          editNote(new Note(), v);
          break;
        case R.id.fab_checklist:
          Note note = new Note();
          note.setChecklist(true);
          editNote(note, v);
          break;
        default:
          editNote(new Note(), v);
      }
    });
  }
  boolean closeFab() {
    if (fab != null && fab.isExpanded()) {
      fab.performToggle();
      return true;
    }
    return false;
  }
  /**
   * Activity title initialization based on navigation
   */
  private void initTitle() {
    String[] navigationList = getResources().getStringArray(R.array.navigation_list);
    String[] navigationListCodes = getResources().getStringArray(R.array.navigation_list_codes);
    String navigation = mainActivity.navigationTmp != null
        ? mainActivity.navigationTmp
        : Prefs.getString (PREF_NAVIGATION, navigationListCodes[0]);
    int index = Arrays.asList(navigationListCodes).indexOf(navigation);
    String title;
    // If is a traditional navigation item
    if (index >= 0 && index < navigationListCodes.length) {
      title = navigationList[index];
    } else {
      Category category = DbHelper.getInstance().getCategory(Long.parseLong(navigation));
      title = category != null ? category.getName() : "";
    }
    title = title == null ? getString(R.string.title_activity_list) : title;
    mainActivity.setActionBarTitle(title);
  }
  /**
   * Starts a little animation on Mr.Jingles!
   */
  private void initEasterEgg() {
    binding.emptyList.setOnClickListener(v -> {
      if (jinglesAnimation == null) {
        jinglesAnimation = (AnimationDrawable) binding.emptyList.getCompoundDrawables()[1];
        binding.emptyList.post(() -> {
          if (jinglesAnimation != null) {
            jinglesAnimation.start();
          }
        });
      } else {
        stopJingles();
      }
    });
  }
  private void stopJingles() {
    if (jinglesAnimation != null) {
      jinglesAnimation.stop();
      jinglesAnimation = null;
      binding.emptyList
          .setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.jingles_animation, 0, 0);
    }
  }
  @Override
  public void onPause() {
    super.onPause();
    searchQueryInstant = searchQuery;
    stopJingles();
    Crouton.cancelAllCroutons();
    closeFab();
    if (!keepActionMode) {
      commitPending();
      if (getActionMode() != null) {
        getActionMode().finish();
      }
    }
  }
  @Override
  public void onSaveInstanceState(@NonNull Bundle outState) {
    super.onSaveInstanceState(outState);
    refreshListScrollPosition();
    outState.putInt("listViewPosition", listViewPosition);
    outState.putInt(LIST_VIEW_POSITION_OFFSET, listViewPositionOffset);
    outState.putString("searchQuery", searchQuery);
    outState.putString("searchTags", searchTags);
  }
  private void refreshListScrollPosition() {
    if(binding != null) {
      listViewPosition = ((LinearLayoutManager) binding.list.getLayoutManager())
          .findFirstVisibleItemPosition();
      View v = binding.list.getChildAt(0);
      listViewPositionOffset =
          (v == null) ? (int) getResources().getDimension(R.dimen.vertical_margin) : v.getTop();
    }
  }
  @Override
  public void onResume() {
    super.onResume();
    if (mainActivity.prefsChanged) {
      mainActivity.prefsChanged = false;
      init();
    } else if (Intent.ACTION_SEARCH.equals(mainActivity.getIntent().getAction())) {
      initNotesList(mainActivity.getIntent());
    }
  }
  private final class ModeCallback implements ActionMode.Callback {
    @Override
    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
      // Inflate the menu for the CAB
      MenuInflater inflater = mode.getMenuInflater();
      inflater.inflate(R.menu.menu_list, menu);
      actionMode = mode;
      fab.setAllowed(isFabAllowed());
      fab.hideFab();
      return true;
    }
    @Override
    public void onDestroyActionMode(ActionMode mode) {
      // Here you can make any necessary updates to the activity when
      // the CAB is removed. By default, selected items are
      // deselected/unchecked.
      for (int i = 0; i < listAdapter.getSelectedItems().size(); i++) {
        int key = listAdapter.getSelectedItems().keyAt(i);
      }
      selectedNotes.clear();
      listAdapter.clearSelectedItems();
      listAdapter.notifyDataSetChanged();
      fab.setAllowed(isFabAllowed(true));
      if (undoNotesMap.size() == 0) {
        fab.showFab();
      }
      actionMode = null;
      LogDelegate.d("Closed multiselection contextual menu");
    }
    @Override
    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
      prepareActionModeMenu();
      return true;
    }
    @Override
    public boolean onActionItemClicked(final ActionMode mode, final MenuItem item) {
      Integer[] protectedActions = {R.id.menu_select_all, R.id.menu_merge};
      if (!Arrays.asList(protectedActions).contains(item.getItemId())) {
        mainActivity.requestPassword(mainActivity, getSelectedNotes(),
            passwordConfirmed -> {
              if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
                performAction(item, mode);
              }
            });
      } else {
        performAction(item, mode);
      }
      return true;
    }
  }
  public void finishActionMode() {
    if (getActionMode() != null) {
      getActionMode().finish();
    }
  }
  /**
   * Manage check/uncheck of notes in list during multiple selection phase
   */
  private void toggleListViewItem(View view, int position) {
    Note note = listAdapter.getItem(position);
    LinearLayout cardLayout = view.findViewById(R.id.card_layout);
    if (!getSelectedNotes().contains(note)) {
      getSelectedNotes().add(note);
      listAdapter.addSelectedItem(position);
      cardLayout.setBackgroundColor(getResources().getColor(R.color.list_bg_selected));
    } else {
      getSelectedNotes().remove(note);
      listAdapter.removeSelectedItem(position);
      listAdapter.restoreDrawable(note, cardLayout);
    }
    prepareActionModeMenu();
    if (getSelectedNotes().isEmpty()) {
      finishActionMode();
    }
  }
  /**
   * Notes list initialization. Data, actions and callback are defined here.
   */
  private void initListView() {
    // Note long click to start CAB mode
    RecyclerViewItemClickSupport.addTo(binding.list)
        // Note single click listener managed by the activity itself
        .setOnItemClickListener((recyclerView, position, view) -> {
          if (getActionMode() == null) {
            editNote(listAdapter.getItem(position), view);
            return;
          }
          // If in CAB mode
          toggleListViewItem(view, position);
          setCabTitle();
        }).setOnItemLongClickListener((recyclerView, position, view) -> {
      if (getActionMode() != null) {
        return false;
      }
      // Start the CAB using the ActionMode.Callback defined above
      mainActivity.startSupportActionMode(new ModeCallback());
      toggleListViewItem(view, position);
      setCabTitle();
      return true;
    });
    binding.listRoot.setOnViewTouchedListener(this);
  }
  /**
   * Retrieves from the single listview note item the element to be zoomed when opening a note
   */
  private ImageView getZoomListItemView(View view, Note note) {
    View targetView = null;
    if (!note.getAttachmentsList().isEmpty()) {
      targetView = view.findViewById(R.id.attachmentThumbnail);
    }
    if (targetView == null && note.getCategory() != null) {
      targetView = view.findViewById(R.id.category_marker);
    }
    if (targetView == null) {
      targetView = new ImageView(mainActivity);
      targetView.setBackgroundColor(Color.WHITE);
    }
    targetView.setDrawingCacheEnabled(true);
    targetView.buildDrawingCache();
    Bitmap bmp = targetView.getDrawingCache();
    binding.expandedImage.setBackgroundColor(BitmapUtils.getDominantColor(bmp));
    return binding.expandedImage;
  }
  /**
   * Listener that fires note opening once the zooming animation is finished
   */
  private AnimatorListenerAdapter buildAnimatorListenerAdapter(final Note note) {
    return new AnimatorListenerAdapter() {
      @Override
      public void onAnimationEnd(Animator animation) {
        editNote2(note);
      }
    };
  }
  @Override
  public void onViewTouchOccurred(MotionEvent ev) {
    LogDelegate.v("Notes list: onViewTouchOccurred " + ev.getAction());
    commitPending();
  }
  @Override
  public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
    inflater.inflate(R.menu.menu_list, menu);
    super.onCreateOptionsMenu(menu, inflater);
    this.menu = menu;
    initSearchView(menu);
  }
  private void initSortingSubmenu() {
    final String[] arrayDb = getResources().getStringArray(R.array.sortable_columns);
    final String[] arrayDialog = getResources()
        .getStringArray(R.array.sortable_columns_human_readable);
    int selected = Arrays.asList(arrayDb).indexOf(Prefs.getString(PREF_SORTING_COLUMN, arrayDb[0]));
    SubMenu sortMenu = this.menu.findItem(R.id.menu_sort).getSubMenu();
    for (int i = 0; i < arrayDialog.length; i++) {
      if (sortMenu.findItem(i) == null) {
        sortMenu.add(MENU_SORT_GROUP_ID, i, i, arrayDialog[i]);
      }
      if (i == selected) {
        sortMenu.getItem(i).setChecked(true);
      }
    }
    sortMenu.setGroupCheckable(MENU_SORT_GROUP_ID, true, true);
  }
  @Override
  public void onPrepareOptionsMenu(Menu menu) {
    setActionItemsVisibility(menu, false);
  }
  private void prepareActionModeMenu() {
    Menu menu = getActionMode().getMenu();
    int navigation = Navigation.getNavigation();
    boolean showArchive =
        navigation == Navigation.NOTES || navigation == Navigation.REMINDERS || navigation ==
            Navigation.UNCATEGORIZED || navigation == Navigation.CATEGORY;
    boolean showUnarchive =
        navigation == Navigation.ARCHIVE || navigation == Navigation.UNCATEGORIZED ||
            navigation == Navigation.CATEGORY;
    if (navigation == Navigation.TRASH) {
      menu.findItem(R.id.menu_untrash).setVisible(true);
      menu.findItem(R.id.menu_delete).setVisible(true);
    } else {
      if (getSelectedCount() == 1) {
        menu.findItem(R.id.menu_share).setVisible(true);
        menu.findItem(R.id.menu_merge).setVisible(false);
        menu.findItem(R.id.menu_archive)
            .setVisible(showArchive && !getSelectedNotes().get(0).isArchived
                ());
        menu.findItem(R.id.menu_unarchive)
            .setVisible(showUnarchive && getSelectedNotes().get(0).isArchived
                ());
      } else {
        menu.findItem(R.id.menu_share).setVisible(false);
        menu.findItem(R.id.menu_merge).setVisible(true);
        menu.findItem(R.id.menu_archive).setVisible(showArchive);
        menu.findItem(R.id.menu_unarchive).setVisible(showUnarchive);
      }
      menu.findItem(R.id.menu_add_reminder).setVisible(true);
      menu.findItem(R.id.menu_category).setVisible(true);
      menu.findItem(R.id.menu_uncomplete_checklists).setVisible(false);
      menu.findItem(R.id.menu_tags).setVisible(true);
      menu.findItem(R.id.menu_trash).setVisible(true);
    }
    menu.findItem(R.id.menu_select_all).setVisible(true);
    setCabTitle();
  }
  private int getSelectedCount() {
    return getSelectedNotes().size();
  }
  private void setCabTitle() {
    if (getActionMode() != null) {
      int title = getSelectedCount();
      getActionMode().setTitle(String.valueOf(title));
    }
  }
  /**
   * SearchView initialization. It's a little complex because it's not using SearchManager but is
   * implementing on its own.
   */
  @SuppressLint("NewApi")
  private void initSearchView(final Menu menu) {
    // Prevents some mysterious NullPointer on app fast-switching
    if (mainActivity == null) {
      return;
    }
    // Save item as class attribute to make it collapse on drawer opening
    searchMenuItem = menu.findItem(R.id.menu_search);
    Bundle args = getArguments();
    if (args != null && args.getBoolean("setSearchFocus")) {
      searchMenuItem.expandActionView();
      KeyboardUtils.hideKeyboard(this.getView());
    }
    // Associate searchable configuration with the SearchView
    SearchManager searchManager = (SearchManager) mainActivity
        .getSystemService(Context.SEARCH_SERVICE);
    searchView = (SearchView) menu.findItem(R.id.menu_search).getActionView();
    searchView.setSearchableInfo(searchManager.getSearchableInfo(mainActivity.getComponentName()));
    searchView.setImeOptions(EditorInfo.IME_ACTION_SEARCH);
    // Expands the widget hiding other actionbar icons
    searchView.setOnQueryTextFocusChangeListener(
        (v, hasFocus) -> setActionItemsVisibility(menu, hasFocus));
    searchMenuItem.setOnActionExpandListener(new OnActionExpandListener() {
          boolean searchPerformed = false;
          @Override
          public boolean onMenuItemActionCollapse(MenuItem item) {
            // Reinitialize notes list to all notes when search is collapsed
            searchQuery = null;
            if (binding.searchLayout.getVisibility() == View.VISIBLE) {
              toggleSearchLabel(false);
            }
            mainActivity.getIntent().setAction(Intent.ACTION_MAIN);
            initNotesList(mainActivity.getIntent());
            mainActivity.supportInvalidateOptionsMenu();
            return true;
          }
          @Override
          public boolean onMenuItemActionExpand(MenuItem item) {
            commitPending();
            searchView.setOnQueryTextListener(new OnQueryTextListener() {
              @Override
              public boolean onQueryTextSubmit(String arg0) {
                return Prefs.getBoolean("settings_instant_search", false);
              }
              @Override
              public boolean onQueryTextChange(String pattern) {
                if (Prefs.getBoolean("settings_instant_search", false)
                    && searchPerformed && mFragment.isAdded()) {
                  searchTags = null;
                  searchQuery = pattern;
                  NoteLoaderTask.getInstance().execute("getNotesByPattern", pattern);
                  return true;
                } else {
                  searchPerformed = true;
                  return false;
                }
              }
            });
            return true;
          }
        });
  }
  private void setActionItemsVisibility(Menu menu, boolean searchViewHasFocus) {
    boolean drawerOpen = mainActivity.getDrawerLayout() != null
        && mainActivity.getDrawerLayout().isDrawerOpen(GravityCompat.START);
    boolean expandedView = Prefs.getBoolean(PREF_EXPANDED_VIEW, true);
    int navigation = Navigation.getNavigation();
    boolean navigationReminders = navigation == Navigation.REMINDERS;
    boolean navigationTrash = navigation == Navigation.TRASH;
    boolean navigationCategory = navigation == Navigation.CATEGORY;
    boolean filterPastReminders = Prefs.getBoolean(PREF_FILTER_PAST_REMINDERS, true);
    boolean filterArchivedInCategory = navigationCategory && Prefs
        .getBoolean(PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory(), false);
    if (isFabAllowed()) {
      fab.setAllowed(true);
      fab.showFab();
    } else {
      fab.setAllowed(false);
      fab.hideFab();
    }
    menu.findItem(R.id.menu_search).setVisible(!drawerOpen);
    menu.findItem(R.id.menu_filter)
        .setVisible(!drawerOpen && !filterPastReminders && navigationReminders &&
            !searchViewHasFocus);
    menu.findItem(R.id.menu_filter_remove)
        .setVisible(!drawerOpen && filterPastReminders && navigationReminders
            && !searchViewHasFocus);
    menu.findItem(R.id.menu_filter_category).setVisible(!drawerOpen && !filterArchivedInCategory &&
        navigationCategory && !searchViewHasFocus);
    menu.findItem(R.id.menu_filter_category_remove)
        .setVisible(!drawerOpen && filterArchivedInCategory && navigationCategory && !searchViewHasFocus);
    menu.findItem(R.id.menu_sort)
        .setVisible(!drawerOpen && !navigationReminders && !searchViewHasFocus);
    menu.findItem(R.id.menu_expanded_view)
        .setVisible(!drawerOpen && !expandedView && !searchViewHasFocus);
    menu.findItem(R.id.menu_contracted_view)
        .setVisible(!drawerOpen && expandedView && !searchViewHasFocus);
    menu.findItem(R.id.menu_empty_trash).setVisible(!drawerOpen && navigationTrash);
    menu.findItem(R.id.menu_uncomplete_checklists).setVisible(searchViewHasFocus);
    menu.findItem(R.id.menu_tags).setVisible(searchViewHasFocus);
  }
  @Override
  public boolean onOptionsItemSelected(final MenuItem item) {
    Integer[] protectedActions = {R.id.menu_empty_trash};
    if (Arrays.asList(protectedActions).contains(item.getItemId())) {
      mainActivity.requestPassword(mainActivity, getSelectedNotes(), passwordConfirmed -> {
        if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
          performAction(item, null);
        }
      });
    } else {
      performAction(item, null);
    }
    return super.onOptionsItemSelected(item);
  }
  /**
   * Performs one of the ActionBar button's actions after checked notes protection
   */
  public void performAction(MenuItem item, ActionMode actionMode) {
    if (isOptionsItemFastClick()) {
      return;
    }
    if (actionMode == null) {
      switch (item.getItemId()) {
        case android.R.id.home:
          if (mainActivity.getDrawerLayout().isDrawerOpen(GravityCompat.START)) {
            mainActivity.getDrawerLayout().closeDrawer(GravityCompat.START);
          } else {
            mainActivity.getDrawerLayout().openDrawer(GravityCompat.START);
          }
          break;
        case R.id.menu_filter:
          filterReminders(true);
          break;
        case R.id.menu_filter_remove:
          filterReminders(false);
          break;
        case R.id.menu_filter_category:
          filterCategoryArchived(true);
          break;
        case R.id.menu_filter_category_remove:
          filterCategoryArchived(false);
          break;
        case R.id.menu_uncomplete_checklists:
          item.setVisible(false);
          filterByUncompleteChecklists();
          break;
        case R.id.menu_tags:
          filterByTags();
          break;
        case R.id.menu_sort:
          initSortingSubmenu();
          break;
        case R.id.menu_expanded_view:
          switchNotesView();
          break;
        case R.id.menu_contracted_view:
          switchNotesView();
          break;
        case R.id.menu_empty_trash:
          emptyTrash();
          break;
        case R.id.menu_search:
          // Nothing to do, it's all managed by SearchView component
          break;
        default:
          LogDelegate.e("Wrong element choosen: " + item.getItemId());
      }
    } else {
      switch (item.getItemId()) {
        case R.id.menu_category:
          categorizeNotes();
          break;
        case R.id.menu_tags:
          tagNotes();
          break;
        case R.id.menu_share:
          share();
          break;
        case R.id.menu_merge:
          merge();
          break;
        case R.id.menu_archive:
          archiveNotes(true);
          break;
        case R.id.menu_unarchive:
          archiveNotes(false);
          break;
        case R.id.menu_trash:
          trashNotes(true);
          break;
        case R.id.menu_untrash:
          trashNotes(false);
          break;
        case R.id.menu_delete:
          deleteNotes();
          break;
        case R.id.menu_select_all:
          selectAllNotes();
          break;
        case R.id.menu_add_reminder:
          addReminders();
          break;
//                case R.ID.menu_synchronize:
//                    synchronizeSelectedNotes();
//                    break;
        default:
          LogDelegate.e("Wrong element choosen: " + item.getItemId());
      }
    }
    checkSortActionPerformed(item);
  }
  private void addReminders() {
    Intent intent = new Intent(OmniNotes.getAppContext(), SnoozeActivity.class);
    intent.setAction(ACTION_POSTPONE);
    intent.putExtra(INTENT_NOTE, selectedNotes.toArray(new Note[selectedNotes.size()]));
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivityForResult(intent, REQUEST_CODE_ADD_ALARMS);
  }
  private void switchNotesView() {
    boolean expandedView = Prefs.getBoolean(PREF_EXPANDED_VIEW, true);
    Prefs.edit().putBoolean(PREF_EXPANDED_VIEW, !expandedView).apply();
    searchQueryInstant = searchQuery;
    // Change list view
    initNotesList(mainActivity.getIntent());
    // Called to switch menu voices
    mainActivity.supportInvalidateOptionsMenu();
  }
  void editNote(final Note note, final View view) {
    if (note.isLocked() && !Prefs.getBoolean("settings_password_access", false)) {
      PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
        if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
          note.setPasswordChecked(true);
          AnimationsHelper.zoomListItem(mainActivity, view, getZoomListItemView(view, note),
              binding.listRoot, buildAnimatorListenerAdapter(note));
        }
      });
    } else {
      AnimationsHelper.zoomListItem(mainActivity, view, getZoomListItemView(view, note),
          binding.listRoot, buildAnimatorListenerAdapter(note));
    }
  }
  void editNote2(Note note) {
    if (note.get_id() == null) {
      LogDelegate.d("Adding new note");
      // if navigation is a category it will be set into note
      try {
        if (checkNavigation(Navigation.CATEGORY) || !isEmpty(mainActivity.navigationTmp)) {
          String categoryId = ObjectUtils.defaultIfNull(mainActivity.navigationTmp,
              Navigation.getCategory().toString());
          note.setCategory(DbHelper.getInstance().getCategory(Long.parseLong(categoryId)));
        }
      } catch (NumberFormatException e) {
        LogDelegate.v("Maybe was not a category!");
      }
    } else {
      LogDelegate.d("Editing note with ID: " + note.get_id());
    }
    // Current list scrolling position is saved to be restored later
    refreshListScrollPosition();
    // Fragments replacing
    mainActivity.switchToDetail(note);
  }
  @Override
  public// Used to show a Crouton dialog after saved (or tried to) a note
  void onActivityResult(int requestCode, final int resultCode, Intent intent) {
    super.onActivityResult(requestCode, resultCode, intent);
    switch (requestCode) {
      case REQUEST_CODE_CATEGORY:
        // Dialog retarded to give time to activity's views of being completely initialized
        // The dialog style is choosen depending on result code
        switch (resultCode) {
          case Activity.RESULT_OK:
            mainActivity.showMessage(R.string.category_saved, ONStyle.CONFIRM);
            EventBus.getDefault().post(new CategoriesUpdatedEvent());
            break;
          case Activity.RESULT_FIRST_USER:
            mainActivity.showMessage(R.string.category_deleted, ONStyle.ALERT);
            break;
          default:
            break;
        }
        break;
      case REQUEST_CODE_CATEGORY_NOTES:
        if (intent != null) {
          Category tag = intent.getParcelableExtra(INTENT_CATEGORY);
          categorizeNotesExecute(tag);
        }
        break;
      case REQUEST_CODE_ADD_ALARMS:
        selectedNotes.clear();
        finishActionMode();
        break;
      default:
        break;
    }
  }
  private void checkSortActionPerformed(MenuItem item) {
    if (item.getGroupId() == MENU_SORT_GROUP_ID) {
      final String[] arrayDb = getResources().getStringArray(R.array.sortable_columns);
      Prefs.edit().putString(PREF_SORTING_COLUMN, arrayDb[item.getOrder()]).apply();
      initNotesList(mainActivity.getIntent());
      // Resets list scrolling position
      listViewPositionOffset = 16;
      listViewPosition = 0;
      restoreListScrollPosition();
      toggleSearchLabel(false);
      // Updates app widgets
      mainActivity.updateWidgets();
    }
  }
  /**
   * Empties trash deleting all the notes
   */
  private void emptyTrash() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.empty_trash_confirmation)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          boolean mustDeleteLockedNotes = false;
          for (int i = 0; i < listAdapter.getItemCount(); i++) {
            selectedNotes.add(listAdapter.getItem(i));
            mustDeleteLockedNotes = mustDeleteLockedNotes || listAdapter.getItem(i).isLocked();
          }
          if (mustDeleteLockedNotes) {
            mainActivity.requestPassword(mainActivity, getSelectedNotes(),
                passwordConfirmed -> {
                  if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
                    deleteNotesExecute();
                  }
                });
          } else {
            deleteNotesExecute();
          }
        }).build().show();
  }
  /**
   * Notes list adapter initialization and association to view
   *
   * @FIXME: This method is a divine disgrace and MUST be refactored. I'm ashamed by myself.
   */
  void initNotesList(Intent intent) {
    LogDelegate.d("initNotesList intent: " + intent.getAction());
    binding.progressWheel.setAlpha(1);
    binding.list.setAlpha(0);
    // Search for a tag
    // A workaround to simplify it's to simulate normal search
    if (Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getCategories() != null
        && intent.getCategories().contains(Intent.CATEGORY_BROWSABLE)) {
      searchTags = intent.getDataString().replace(UrlCompleter.HASHTAG_SCHEME, "");
      goBackOnToggleSearchLabel = true;
    }
    if (ACTION_SHORTCUT_WIDGET.equals(intent.getAction())) {
      return;
    }
    // Searching
    searchQuery = searchQueryInstant;
    searchQueryInstant = null;
    if (searchTags != null || searchQuery != null || searchUncompleteChecklists
        || IntentChecker
        .checkAction(intent, Intent.ACTION_SEARCH, ACTION_SEARCH_UNCOMPLETE_CHECKLISTS)) {
      // Using tags
      if (searchTags != null && intent.getStringExtra(SearchManager.QUERY) == null) {
        searchQuery = searchTags;
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getNotesByTag",
                searchQuery);
      } else if (searchUncompleteChecklists || ACTION_SEARCH_UNCOMPLETE_CHECKLISTS.equals(
          intent.getAction())) {
        searchQuery = getContext().getResources().getString(R.string.uncompleted_checklists);
        searchUncompleteChecklists = true;
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getNotesByUncompleteChecklist");
      } else {
        // Get the intent, verify the action and get the query
        if (intent.getStringExtra(SearchManager.QUERY) != null) {
          searchQuery = intent.getStringExtra(SearchManager.QUERY);
          searchTags = null;
        }
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getNotesByPattern",
                searchQuery);
      }
      toggleSearchLabel(true);
    } else {
      // Check if is launched from a widget with categories
      if ((ACTION_WIDGET_SHOW_LIST.equals(intent.getAction()) && intent.hasExtra(INTENT_WIDGET))
          || !isEmpty(mainActivity.navigationTmp)) {
        String widgetId =
            intent.hasExtra(INTENT_WIDGET) ? intent.getExtras().get(INTENT_WIDGET).toString()
                : null;
        if (widgetId != null) {
          String sqlCondition = Prefs.getString(PREF_WIDGET_PREFIX + widgetId, "");
          String categoryId = TextHelper.checkIntentCategory(sqlCondition);
          mainActivity.navigationTmp = !isEmpty(categoryId) ? categoryId : null;
        }
        intent.removeExtra(INTENT_WIDGET);
        if (mainActivity.navigationTmp != null) {
          Long categoryId = Long.parseLong(mainActivity.navigationTmp);
          NoteLoaderTask.getInstance().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,
              "getNotesByCategory", categoryId);
        } else {
          NoteLoaderTask.getInstance()
              .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getAllNotes", true);
        }
      } else {
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getAllNotes", true);
      }
    }
  }
  public void toggleSearchLabel(boolean activate) {
    if (activate) {
      binding.searchQuery.setText(fromHtml(getString(R.string.search) + ":<b> " + searchQuery + "</b>"));
      binding.searchLayout.setVisibility(View.VISIBLE);
      binding.searchCancel.setOnClickListener(v -> toggleSearchLabel(false));
      searchLabelActive = true;
    } else {
      if (searchLabelActive) {
        searchLabelActive = false;
        AnimationsHelper.expandOrCollapse(binding.searchLayout, false);
        searchTags = null;
        searchQuery = null;
        searchUncompleteChecklists = false;
        if (!goBackOnToggleSearchLabel) {
          mainActivity.getIntent().setAction(Intent.ACTION_MAIN);
          if (searchView != null) {
            searchMenuItem.collapseActionView();
          }
          initNotesList(mainActivity.getIntent());
        } else {
          mainActivity.onBackPressed();
        }
        goBackOnToggleSearchLabel = false;
        if (Intent.ACTION_VIEW.equals(mainActivity.getIntent().getAction())) {
          mainActivity.getIntent().setAction(null);
        }
      }
    }
  }
  public void onEvent(NavigationUpdatedNavDrawerClosedEvent navigationUpdatedNavDrawerClosedEvent) {
    listViewPosition = 0;
    listViewPositionOffset = 16;
    initNotesList(mainActivity.getIntent());
    setActionItemsVisibility(menu, false);
  }
  public void onEvent(CategoriesUpdatedEvent categoriesUpdatedEvent) {
    initNotesList(mainActivity.getIntent());
  }
  public void onEvent(NotesLoadedEvent notesLoadedEvent) {
    listAdapter = new NoteAdapter(mainActivity, Prefs.getBoolean(PREF_EXPANDED_VIEW, true),
        notesLoadedEvent.getNotes());
    initSwipeGesture();
    binding.list.setAdapter(listAdapter);
    // Restores listview position when turning back to list or when navigating reminders
    if (!notesLoadedEvent.getNotes().isEmpty()) {
      if (checkNavigation(Navigation.REMINDERS)) {
        listViewPosition = listAdapter.getClosestNotePosition();
      }
      restoreListScrollPosition();
    }
    animateListView();
    closeFab();
  }
  public void onEvent(NotesUpdatedEvent notesUpdatedEvent) {
    notesUpdatedEvent.getNotes().stream().forEach(updatedNote ->
        IntStream.range(0, listAdapter.getNotes().size() - 1)
            .filter(i -> listAdapter.getItem(i).get_id().equals(updatedNote.get_id()))
            .forEach(i -> {
              listAdapter.getNotes().set(i, updatedNote);
              listAdapter.notifyItemChanged(i);
            }));
  }
  private void initSwipeGesture() {
    ItemTouchHelper.SimpleCallback simpleItemTouchCallback = new ItemTouchHelper.SimpleCallback(0,
        ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT) {
      @Override
      public boolean onMove(@NonNull RecyclerView recyclerView,
          @NonNull RecyclerView.ViewHolder viewHolder,
          @NonNull RecyclerView.ViewHolder target) {
        return false;
      }
      @Override
      public void onSwiped(RecyclerView.ViewHolder viewHolder, int swipeDir) {
        int swipedPosition = viewHolder.getAdapterPosition();
        finishActionMode();
        swipeNote(swipedPosition);
      }
    };
    ItemTouchHelper itemTouchHelper = new ItemTouchHelper(simpleItemTouchCallback);
    if (Navigation.getNavigation() != Navigation.UNCATEGORIZED && Prefs
        .getBoolean(PREF_ENABLE_SWIPE, true)) {
      itemTouchHelper.attachToRecyclerView(binding.list);
    } else {
      itemTouchHelper.attachToRecyclerView(null);
    }
  }
  private void swipeNote(int swipedPosition) {
    try {
      Note note = listAdapter.getItem(swipedPosition);
      if (note.isLocked()) {
        PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
          if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
            onNoteSwipedPerformAction(note);
          } else {
            onUndo(null);
          }
        });
      } else {
        onNoteSwipedPerformAction(note);
      }
    } catch (IndexOutOfBoundsException e) {
      LogDelegate.d("Please stop swiping in the zone beneath the last card");
    }
  }
  private void onNoteSwipedPerformAction(Note note) {
    getSelectedNotes().add(note);
    // Depending on settings and note status this action will...
    // ...restore
    if (checkNavigation(Navigation.TRASH)) {
      trashNotes(false);
    }
    // ...removes category
    else if (checkNavigation(Navigation.CATEGORY)) {
      categorizeNotesExecute(null);
    } else {
      // ...trash
      if (Prefs.getBoolean("settings_swipe_to_trash", false)
          || checkNavigation(Navigation.ARCHIVE)) {
        trashNotes(true);
        // ...archive
      } else {
        archiveNotes(true);
      }
    }
  }
  public void onEvent(PasswordRemovedEvent passwordRemovedEvent) {
    initNotesList(mainActivity.getIntent());
  }
  private void animateListView() {
    if (!isDebugBuild()) {
      animate(binding.progressWheel)
          .setDuration(getResources().getInteger(R.integer.list_view_fade_anim)).alpha(0);
      animate(binding.list).setDuration(getResources().getInteger(R.integer.list_view_fade_anim))
          .alpha(1);
    } else {
      binding.progressWheel.setVisibility(View.INVISIBLE);
      binding.list.setAlpha(1);
    }
  }
  private void restoreListScrollPosition() {
    if (listAdapter.getItemCount() > listViewPosition) {
      binding.list.getLayoutManager().scrollToPosition(listViewPosition);
      new Handler().postDelayed(fab::showFab, 150);
    } else {
      binding.list.getLayoutManager().scrollToPosition(0);
    }
  }
  /**
   * Batch note trashing
   */
  public void trashNotes(boolean trash) {
    int selectedNotesSize = getSelectedNotes().size();
    // Restore is performed immediately, otherwise undo bar is shown
    if (trash) {
      trackModifiedNotes(getSelectedNotes());
      for (Note note : getSelectedNotes()) {
        listAdapter.remove(note);
        ReminderHelper.removeReminder(OmniNotes.getAppContext(), note);
      }
    } else {
      trashNote(getSelectedNotes(), false);
    }
    listAdapter.notifyDataSetChanged();
    finishActionMode();
    // Advice to user
    if (trash) {
      mainActivity.showMessage(R.string.note_trashed, ONStyle.WARN);
    } else {
      mainActivity.showMessage(R.string.note_untrashed, ONStyle.INFO);
    }
    // Creation of undo bar
    if (trash) {
      ubc.showUndoBar(false, selectedNotesSize + " " + getString(R.string.trashed), null);
      fab.hideFab();
      undoTrash = true;
    } else {
      getSelectedNotes().clear();
    }
  }
  private ActionMode getActionMode() {
    return actionMode;
  }
  private List<Note> getSelectedNotes() {
    return selectedNotes;
  }
  /**
   * Single note logical deletion
   */
  @SuppressLint("NewApi")
  protected void trashNote(List<Note> notes, boolean trash) {
    listAdapter.remove(notes);
    new NoteProcessorTrash(notes, trash).process();
  }
  /**
   * Selects all notes in list
   */
  private void selectAllNotes() {
    for (int i = 0; i < binding.list.getChildCount(); i++) {
      LinearLayout v = binding.list.getChildAt(i).findViewById(R.id.card_layout);
      v.setBackgroundColor(getResources().getColor(R.color.list_bg_selected));
    }
    selectedNotes.clear();
    for (int i = 0; i < listAdapter.getItemCount(); i++) {
      selectedNotes.add(listAdapter.getItem(i));
      listAdapter.addSelectedItem(i);
    }
    prepareActionModeMenu();
    setCabTitle();
  }
  /**
   * Batch note permanent deletion
   */
  private void deleteNotes() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.delete_note_confirmation)
        .positiveText(R.string.ok)
        .onPositive(
            (dialog, which) -> mainActivity.requestPassword(mainActivity, getSelectedNotes(),
                passwordConfirmed -> {
                  if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
                    deleteNotesExecute();
                  }
                }))
        .build()
        .show();
  }
  /**
   * Performs notes permanent deletion after confirmation by the user
   */
  private void deleteNotesExecute() {
    listAdapter.remove(getSelectedNotes());
    new NoteProcessorDelete(getSelectedNotes()).process();
    selectedNotes.clear();
    finishActionMode();
    mainActivity.showMessage(R.string.note_deleted, ONStyle.ALERT);
  }
  /**
   * Batch note archiviation
   */
  public void archiveNotes(boolean archive) {
    int selectedNotesSize = getSelectedNotes().size();
    // Used in undo bar commit
    sendToArchive = archive;
    if (!archive) {
      archiveNote(getSelectedNotes(), false);
    } else {
      trackModifiedNotes(getSelectedNotes());
    }
    for (Note note : getSelectedNotes()) {
      // If is restore it will be done immediately, otherwise the undo bar will be shown
      if (archive) {
        // Saves archived state to eventually undo
        undoArchivedMap.put(note, note.isArchived());
      }
      // If actual navigation is not "Notes" the item will not be removed but replaced to fit the new state
      if (checkNavigation(Navigation.NOTES)
          || (checkNavigation(Navigation.ARCHIVE) && !archive)
          || (checkNavigation(Navigation.CATEGORY) && Prefs.getBoolean(
          PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory(), false))) {
        listAdapter.remove(note);
      } else {
        note.setArchived(archive);
        listAdapter.replace(note, listAdapter.getPosition(note));
      }
    }
    listAdapter.notifyDataSetChanged();
    finishActionMode();
    // Advice to user
    int msg = archive ? R.string.note_archived : R.string.note_unarchived;
    Style style = archive ? ONStyle.WARN : ONStyle.INFO;
    mainActivity.showMessage(msg, style);
    // Creation of undo bar
    if (archive) {
      ubc.showUndoBar(false, selectedNotesSize + " " + getString(R.string.archived), null);
      fab.hideFab();
      undoArchive = true;
    } else {
      getSelectedNotes().clear();
    }
  }
  /**
   * Saves notes to be eventually restored at right position
   */
  private void trackModifiedNotes(List<Note> modifiedNotesToTrack) {
    for (Note note : modifiedNotesToTrack) {
      undoNotesMap.put(listAdapter.getPosition(note), note);
    }
  }
  private void archiveNote(List<Note> notes, boolean archive) {
    new NoteProcessorArchive(notes, archive).process();
    if (!checkNavigation(Navigation.CATEGORY)) {
      listAdapter.remove(notes);
    }
    LogDelegate.d("Notes" + (archive ? "archived" : "restored from archive"));
  }
  /**
   * Categories addition and editing
   */
  void editCategory(Category category) {
    Intent categoryIntent = new Intent(mainActivity, CategoryActivity.class);
    categoryIntent.putExtra(INTENT_CATEGORY, category);
    startActivityForResult(categoryIntent, REQUEST_CODE_CATEGORY);
  }
  /**
   * Associates to or removes categories
   */
  private void categorizeNotes() {
    var categories = DbHelper.getInstance().getCategories();
    var dialogBuilder = new MaterialDialog.Builder(mainActivity)
        .title(R.string.categorize_as)
        .positiveText(R.string.add_category)
        .positiveColorRes(R.color.colorPrimary)
        .negativeText(R.string.remove_category)
        .negativeColorRes(R.color.colorAccent)
        .onPositive((dialog1, which) -> {
          keepActionMode = true;
          Intent intent = new Intent(mainActivity, CategoryActivity.class);
          intent.putExtra("noHome", true);
          startActivityForResult(intent, REQUEST_CODE_CATEGORY_NOTES);
        }).onNegative((dialog12, which) -> categorizeNotesExecute(null));
    if (CollectionUtils.isNotEmpty(categories)) {
      dialogBuilder.adapter(new CategoryRecyclerViewAdapter(mainActivity, categories), null);
    }
    final var dialog = dialogBuilder.build();
    if (CollectionUtils.isNotEmpty(categories)) {
      RecyclerViewItemClickSupport.addTo(dialog.getRecyclerView())
          .setOnItemClickListener((recyclerView, position, v) -> {
            dialog.dismiss();
            categorizeNotesExecute(categories.get(position));
          });
    }
    dialog.show();
  }
  private void categorizeNotesExecute(Category category) {
    if (category != null) {
      categorizeNote(getSelectedNotes(), category);
    } else {
      trackModifiedNotes(getSelectedNotes());
    }
    for (Note note : getSelectedNotes()) {
      // If is restore it will be done immediately, otherwise the undo bar
      // will be shown
      if (category == null) {
        // Saves categories associated to eventually undo
        undoCategoryMap.put(note, note.getCategory());
      }
      // Update adapter content if actual navigation is the category
      // associated with actually cycled note
      if ((checkNavigation(Navigation.CATEGORY) && !Navigation
          .checkNavigationCategory(category)) ||
          checkNavigation(Navigation.UNCATEGORIZED)) {
        listAdapter.remove(note);
      } else {
        note.setCategory(category);
        listAdapter.replace(note, listAdapter.getPosition(note));
      }
    }
    finishActionMode();
    // Advice to user
    String msg;
    if (category != null) {
      msg = getResources().getText(R.string.notes_categorized_as) + " '" + category.getName() + "'";
    } else {
      msg = getResources().getText(R.string.notes_category_removed).toString();
    }
    mainActivity.showMessage(msg, ONStyle.INFO);
    // Creation of undo bar
    if (category == null) {
      ubc.showUndoBar(false, getString(R.string.notes_category_removed), null);
      fab.hideFab();
      undoCategorize = true;
      undoCategorizeCategory = null;
    } else {
      getSelectedNotes().clear();
    }
  }
  private void categorizeNote(List<Note> notes, Category category) {
    new NoteProcessorCategorize(notes, category).process();
  }
  /**
   * Bulk tag selected notes
   */
  private void tagNotes() {
    // Retrieves all available tags
    final List<Tag> tags = DbHelper.getInstance().getTags();
    // If there is no tag a message will be shown
    if (tags.isEmpty()) {
      finishActionMode();
      mainActivity.showMessage(R.string.no_tags_created, ONStyle.WARN);
      return;
    }
    final Integer[] preSelectedTags = TagsHelper.getPreselectedTagsArray(selectedNotes, tags);
    new MaterialDialog.Builder(mainActivity)
        .title(R.string.select_tags)
        .items(TagsHelper.getTagsArray(tags))
        .positiveText(R.string.ok)
        .itemsCallbackMultiChoice(preSelectedTags, (dialog, which, text) -> {
          dialog.dismiss();
          tagNotesExecute(tags, which, preSelectedTags);
          return false;
        }).build().show();
  }
  private void tagNotesExecute(List<Tag> tags, Integer[] selectedTags, Integer[] preSelectedTags) {
    for (Note note : getSelectedNotes()) {
      tagNote(tags, selectedTags, note);
    }
    if (getActionMode() != null) {
      getActionMode().finish();
    }
    mainActivity.showMessage(R.string.tags_added, ONStyle.INFO);
  }
  private void tagNote(List<Tag> tags, Integer[] selectedTags, Note note) {
    Pair<String, List<Tag>> taggingResult = TagsHelper.addTagToNote(tags, selectedTags, note);
    if (note.isChecklist()) {
      note.setTitle(note.getTitle() + System.getProperty("line.separator") + taggingResult.first);
    } else {
      StringBuilder sb = new StringBuilder(note.getContent());
      if (sb.length() > 0) {
        sb.append(System.getProperty("line.separator"))
            .append(System.getProperty("line.separator"));
      }
      sb.append(taggingResult.first);
      note.setContent(sb.toString());
    }
    eventuallyRemoveDeselectedTags(note, taggingResult.second);
    DbHelper.getInstance().updateNote(note, false);
  }
  private void eventuallyRemoveDeselectedTags(Note note, List<Tag> tagsToRemove) {
    if (CollectionUtils.isNotEmpty(tagsToRemove)) {
      String titleWithoutTags = TagsHelper.removeTags(note.getTitle(), tagsToRemove);
      note.setTitle(titleWithoutTags);
      String contentWithoutTags = TagsHelper.removeTags(note.getContent(), tagsToRemove);
      note.setContent(contentWithoutTags);
    }
  }
//	private void synchronizeSelectedNotes() {
//		new DriveSyncTask(mainActivity).execute(new ArrayList<Note>(getSelectedNotes()));
//		// Clears data structures
//		listAdapter.clearSelectedItems();
//		list.clearChoices();
//		finishActionMode();
//	}
  @Override
  public void onUndo(Parcelable undoToken) {
    // Cycles removed items to re-insert into adapter
    for (Integer notePosition : undoNotesMap.keySet()) {
      Note currentNote = undoNotesMap.get(notePosition);
      //   Manages uncategorize or archive  undo
      if ((undoCategorize && !Navigation.checkNavigationCategory(undoCategoryMap.get(currentNote)))
          || undoArchive && !checkNavigation(Navigation.NOTES)) {
        if (undoCategorize) {
          currentNote.setCategory(undoCategoryMap.get(currentNote));
        } else if (undoArchive) {
          currentNote.setArchived(undoArchivedMap.get(currentNote));
        }
        listAdapter.replace(currentNote, listAdapter.getPosition(currentNote));
        // Manages trash undo
      } else {
        listAdapter.add(notePosition, currentNote);
      }
    }
    listAdapter.notifyDataSetChanged();
    selectedNotes.clear();
    undoNotesMap.clear();
    undoTrash = false;
    undoArchive = false;
    undoCategorize = false;
    undoNotesMap.clear();
    undoCategoryMap.clear();
    undoArchivedMap.clear();
    undoCategorizeCategory = null;
    Crouton.cancelAllCroutons();
    if (getActionMode() != null) {
      getActionMode().finish();
    }
    ubc.hideUndoBar(false);
    fab.showFab();
  }
  void commitPending() {
    if (undoTrash || undoArchive || undoCategorize) {
      List<Note> notesList = new ArrayList<>(undoNotesMap.values());
      if (undoTrash) {
        trashNote(notesList, true);
      } else if (undoArchive) {
        archiveNote(notesList, sendToArchive);
      } else if (undoCategorize) {
        categorizeNote(notesList, undoCategorizeCategory);
      }
      undoTrash = false;
      undoArchive = false;
      undoCategorize = false;
      undoCategorizeCategory = null;
      // Clears data structures
      selectedNotes.clear();
      undoNotesMap.clear();
      undoCategoryMap.clear();
      undoArchivedMap.clear();
      ubc.hideUndoBar(false);
      fab.showFab();
      LogDelegate.d("Changes committed");
    }
    mainActivity.updateWidgets();
  }
  /**
   * Shares the selected note from the list
   */
  private void share() {
    // Only one note should be selected to perform sharing but they'll be cycled anyhow
    for (final Note note : getSelectedNotes()) {
      mainActivity.shareNote(note);
    }
    getSelectedNotes().clear();
    if (getActionMode() != null) {
      getActionMode().finish();
    }
  }
  public void merge() {
    EventBus.getDefault().post(new NotesMergeEvent(false));
  }
  /**
   * Merges all the selected notes
   */
  public void onEventAsync(NotesMergeEvent notesMergeEvent) {
    final Note finalMergedNote = NotesHelper
        .mergeNotes(getSelectedNotes(), notesMergeEvent.keepMergedNotes);
    new Handler(Looper.getMainLooper()).post(() -> {
      if (!notesMergeEvent.keepMergedNotes) {
        ArrayList<String> notesIds = new ArrayList<>();
        for (Note selectedNote : getSelectedNotes()) {
          notesIds.add(String.valueOf(selectedNote.get_id()));
        }
        mainActivity.getIntent().putExtra("merged_notes", notesIds);
      }
      getSelectedNotes().clear();
      if (getActionMode() != null) {
        getActionMode().finish();
      }
      mainActivity.getIntent().setAction(ACTION_MERGE);
      mainActivity.switchToDetail(finalMergedNote);
    });
  }
  /**
   * Excludes past reminders
   */
  private void filterReminders(boolean filter) {
    Prefs.edit().putBoolean(PREF_FILTER_PAST_REMINDERS, filter).apply();
    // Change list view
    initNotesList(mainActivity.getIntent());
    // Called to switch menu voices
    mainActivity.supportInvalidateOptionsMenu();
  }
  /**
   * Excludes archived notes in categories navigation
   */
  private void filterCategoryArchived(boolean filter) {
    if (filter) {
      Prefs.edit().putBoolean(PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory(), true)
          .apply();
    } else {
      Prefs.edit().remove(PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory()).apply();
    }
    // Change list view
    initNotesList(mainActivity.getIntent());
    // Called to switch menu voices
    mainActivity.supportInvalidateOptionsMenu();
  }
  private void filterByUncompleteChecklists() {
    initNotesList(new Intent(ACTION_SEARCH_UNCOMPLETE_CHECKLISTS));
  }
  private void filterByTags() {
    final List<Tag> tags = TagsHelper.getAllTags();
    if (tags.isEmpty()) {
      mainActivity.showMessage(R.string.no_tags_created, ONStyle.WARN);
      return;
    }
    var tagsDialog = new MaterialAlertDialogBuilder(mainActivity)
        .setTitle(R.string.select_tags)
        .setPositiveButton(R.string.ok, (dialog, which) -> {
          var items = ((AlertDialog) dialog).getListView().getCheckedItemPositions();
          var selectedTags = new ArrayList<String>();
          for(int i = 0; i < tags.size(); i++) {
            if (items.get(i)) {
              selectedTags.add(tags.get(i).getText());
            }
          }
          // Saved here to allow persisting search
          searchTags = selectedTags.toString().substring(1, selectedTags.toString().length() - 1)
              .replace(" ", "");
          // Hides keyboard
          searchView.clearFocus();
          KeyboardUtils.hideKeyboard(searchView);
          var intent = mainActivity.getIntent();
          intent.removeExtra(SearchManager.QUERY);
          initNotesList(intent);
        })
        .setMultiChoiceItems(TagsHelper.getTagsArray(tags), null, (dialog, which, isChecked) ->
            ((AlertDialog) dialog).getButton(BUTTON_POSITIVE)
            .setEnabled(((AlertDialog) dialog).getListView().getCheckedItemCount() > 0)
        ).create();
    tagsDialog.show();
    tagsDialog.getButton(BUTTON_POSITIVE).setEnabled(false);
  }
  public MenuItem getSearchMenuItem() {
    return searchMenuItem;
  }
  private boolean isFabAllowed() {
    return isFabAllowed(false);
  }
  private boolean isFabAllowed(boolean actionModeFinishing) {
    boolean isAllowed = true;
    // Actionmode check
    isAllowed = isAllowed && (getActionMode() == null || actionModeFinishing);
    // Navigation check
    int navigation = Navigation.getNavigation();
    isAllowed = isAllowed && navigation != Navigation.ARCHIVE && navigation != Navigation.REMINDERS
        && navigation
        != Navigation.TRASH;
    // Navigation drawer check
    isAllowed =
        isAllowed && mainActivity.getDrawerLayout() != null && !mainActivity.getDrawerLayout()
            .isDrawerOpen
                (GravityCompat.START);
    return isAllowed;
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.helpers;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_LANG;
import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.Configuration;
import android.os.Build;
import android.os.Build.VERSION_CODES;
import android.text.TextUtils;
import androidx.annotation.NonNull;
import com.pixplicity.easyprefs.library.Prefs;
import java.util.Locale;
import lombok.experimental.UtilityClass;
@UtilityClass
public class LanguageHelper {
  /**
   * Updates default language with forced one
   */
  @SuppressLint("ApplySharedPref")
  public static Context updateLanguage(Context ctx, String lang) {
    String language = Prefs.getString(PREF_LANG, "");
    Locale locale = null;
    if (TextUtils.isEmpty(language) && lang == null) {
      locale = Locale.getDefault();
    } else if (lang != null) {
      locale = getLocale(lang);
      Prefs.edit().putString(PREF_LANG, lang).commit();
    } else if (!TextUtils.isEmpty(language)) {
      locale = getLocale(language);
    }
    return setLocale(ctx, locale);
  }
  public static Context resetSystemLanguage(Context ctx) {
    Prefs.edit().remove(PREF_LANG).apply();
    return setLocale(ctx, Locale.getDefault());
  }
  private static Context setLocale(Context context, Locale locale) {
    Configuration configuration = context.getResources().getConfiguration();
    configuration.locale = locale;
    context.getResources().updateConfiguration(configuration, null);
    return context;
  }
  /**
   * Checks country AND region
   */
  private static Locale getLocale(String lang) {
    if (lang.contains("_")) {
      return new Locale(lang.split("_")[0], lang.split("_")[1]);
    } else {
      return new Locale(lang);
    }
  }
  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
  @NonNull
  static String getLocalizedString(Context context, String desiredLocale, int resourceId) {
    if (desiredLocale.equals(getCurrentLocaleAsString(context))) {
      return context.getResources().getString(resourceId);
    }
    Configuration conf = context.getResources().getConfiguration();
    conf = new Configuration(conf);
    conf.setLocale(getLocale(desiredLocale));
    Context localizedContext = context.createConfigurationContext(conf);
    return localizedContext.getResources().getString(resourceId);
  }
  public static String getCurrentLocaleAsString(Context context) {
    return getCurrentLocale(context).toString();
  }
  public static Locale getCurrentLocale(Context context) {
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.N)) {
      return context.getResources().getConfiguration().getLocales().get(0);
    } else {
      return context.getResources().getConfiguration().locale;
    }
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import android.os.Bundle;
import android.webkit.WebView;
import androidx.appcompat.widget.Toolbar;
public class AboutActivity extends BaseActivity {
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_about);
    WebView webview = findViewById(R.id.webview);
    webview.loadUrl("file:///android_asset/html/about.html");
    initUI();
  }
  @Override
  public boolean onNavigateUp() {
    onBackPressed();
    return true;
  }
  private void initUI() {
    Toolbar toolbar = findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);
    getSupportActionBar().setDisplayHomeAsUpEnabled(true);
    getSupportActionBar().setHomeButtonEnabled(true);
    toolbar.setNavigationOnClickListener(v -> onNavigateUp());
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.async;
import android.content.Context;
import android.os.AsyncTask;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.BaseActivity;
import it.feio.android.omninotes.async.bus.NotesUpdatedEvent;
import java.lang.ref.WeakReference;
public class UpdateWidgetsTask extends AsyncTask<Void, Void, Void> {
  private WeakReference<Context> context;
  public UpdateWidgetsTask(Context context) {
    this.context = new WeakReference<>(context);
  }
  @Override
  protected Void doInBackground(Void... params) {
    WidgetUpdateSubscriber widgetUpdateSubscriber = new WidgetUpdateSubscriber();
    return null;
  }
  class WidgetUpdateSubscriber {
    WidgetUpdateSubscriber() {
      EventBus.getDefault().register(this);
    }
    public void onEvent(NotesUpdatedEvent event) {
      BaseActivity.notifyAppWidgets(context.get());
      EventBus.getDefault().unregister(this);
    }
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.widget;
import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
import static it.feio.android.omninotes.helpers.IntentHelper.mutablePendingIntentFlag;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET;
import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.util.SparseArray;
import android.widget.RemoteViews;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
public class ListWidgetProvider extends WidgetProvider {
  @Override
  protected RemoteViews getRemoteViews(Context mContext, int widgetId,
      boolean isSmall, boolean isSingleLine,
      SparseArray<PendingIntent> pendingIntentsMap) {
    RemoteViews views;
    if (isSmall) {
      views = new RemoteViews(mContext.getPackageName(),
          R.layout.widget_layout_small);
      views.setOnClickPendingIntent(R.id.list,
          pendingIntentsMap.get(R.id.list));
    } else if (isSingleLine) {
      views = new RemoteViews(mContext.getPackageName(),
          R.layout.widget_layout);
      views.setOnClickPendingIntent(R.id.add,
          pendingIntentsMap.get(R.id.add));
      views.setOnClickPendingIntent(R.id.list,
          pendingIntentsMap.get(R.id.list));
      views.setOnClickPendingIntent(R.id.camera,
          pendingIntentsMap.get(R.id.camera));
    } else {
      views = new RemoteViews(mContext.getPackageName(),
          R.layout.widget_layout_list);
      views.setOnClickPendingIntent(R.id.add,
          pendingIntentsMap.get(R.id.add));
      views.setOnClickPendingIntent(R.id.list,
          pendingIntentsMap.get(R.id.list));
      views.setOnClickPendingIntent(R.id.camera,
          pendingIntentsMap.get(R.id.camera));
      // Set up the intent that starts the ListViewService, which will
      // provide the views for this collection.
      Intent intent = new Intent(mContext, ListWidgetService.class);
      // Add the app widget ID to the intent extras.
      intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widgetId);
      intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));
      views.setRemoteAdapter(R.id.widget_list, intent);
      Intent clickIntent = new Intent(mContext, MainActivity.class);
      clickIntent.setAction(ACTION_WIDGET);
      PendingIntent clickPI = PendingIntent.getActivity(mContext, 0,
          clickIntent, mutablePendingIntentFlag(FLAG_UPDATE_CURRENT));
      views.setPendingIntentTemplate(R.id.widget_list, clickPI);
    }
    return views;
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.async;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.view.LayoutInflater;
import android.view.View;
import androidx.fragment.app.Fragment;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.SettingsActivity;
import it.feio.android.omninotes.async.bus.NavigationUpdatedEvent;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.models.adapters.CategoryBaseAdapter;
import it.feio.android.omninotes.models.views.NonScrollableListView;
import java.lang.ref.WeakReference;
import java.util.Collections;
import java.util.List;
public class CategoryMenuTask extends AsyncTask<Void, Void, List<Category>> {
  private final WeakReference<Fragment> mFragmentWeakReference;
  private final MainActivity mainActivity;
  private NonScrollableListView mDrawerCategoriesList;
  private View settingsView;
  private View settingsViewCat;
  private NonScrollableListView mDrawerList;
  public CategoryMenuTask(Fragment mFragment) {
    mFragmentWeakReference = new WeakReference<>(mFragment);
    this.mainActivity = (MainActivity) mFragment.getActivity();
  }
  @Override
  protected void onPreExecute() {
    super.onPreExecute();
    mDrawerList = mainActivity.findViewById(R.id.drawer_nav_list);
    LayoutInflater inflater = (LayoutInflater) mainActivity
        .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    settingsView = mainActivity.findViewById(R.id.settings_view);
    // Settings view when categories are available
    mDrawerCategoriesList = mainActivity.findViewById(R.id.drawer_tag_list);
    if (mDrawerCategoriesList.getAdapter() == null
        && mDrawerCategoriesList.getFooterViewsCount() == 0) {
      settingsViewCat = inflater.inflate(R.layout.drawer_category_list_footer, null);
      mDrawerCategoriesList.addFooterView(settingsViewCat);
    } else {
      settingsViewCat = mDrawerCategoriesList.getChildAt(mDrawerCategoriesList.getChildCount() - 1);
    }
  }
  @Override
  protected List<Category> doInBackground(Void... params) {
    if (isAlive()) {
      return buildCategoryMenu();
    } else {
      cancel(true);
      return Collections.emptyList();
    }
  }
  @Override
  @Deprecated
  protected void onPostExecute(final List<Category> categories) {
    if (isAlive()) {
      mDrawerCategoriesList.setAdapter(new CategoryBaseAdapter(mainActivity, categories,
          mainActivity.getNavigationTmp()));
      if (categories.isEmpty()) {
        setWidgetVisibility(settingsViewCat, false);
        setWidgetVisibility(settingsView, true);
      } else {
        setWidgetVisibility(settingsViewCat, true);
        setWidgetVisibility(settingsView, false);
      }
      mDrawerCategoriesList.justifyListViewHeightBasedOnChildren();
    }
  }
  private void setWidgetVisibility(View view, boolean visible) {
    if (view != null) {
      view.setVisibility(visible ? View.VISIBLE : View.GONE);
    }
  }
  private boolean isAlive() {
    return mFragmentWeakReference.get() != null
        && mFragmentWeakReference.get().isAdded()
        && mFragmentWeakReference.get().getActivity() != null
        && !mFragmentWeakReference.get().getActivity().isFinishing();
  }
  private List<Category> buildCategoryMenu() {
    List<Category> categories = DbHelper.getInstance().getCategories();
    View settings = categories.isEmpty() ? settingsView : settingsViewCat;
    if (settings == null) {
      return categories;
    }
    mainActivity.runOnUiThread(() -> {
      settings.setOnClickListener(v -> {
        Intent settingsIntent = new Intent(mainActivity, SettingsActivity.class);
        mainActivity.startActivity(settingsIntent);
      });
      buildCategoryMenuClickEvent();
      buildCategoryMenuLongClickEvent();
    });
    return categories;
  }
  private void buildCategoryMenuLongClickEvent() {
    mDrawerCategoriesList.setOnItemLongClickListener((arg0, view, position, arg3) -> {
      if (mDrawerCategoriesList.getAdapter() != null) {
        Object item = mDrawerCategoriesList.getAdapter().getItem(position);
        // Ensuring that clicked item is not the ListView header
        if (item != null) {
          mainActivity.editTag((Category) item);
        }
      } else {
        mainActivity.showMessage(R.string.category_deleted, ONStyle.ALERT);
      }
      return true;
    });
  }
  private void buildCategoryMenuClickEvent() {
    mDrawerCategoriesList.setOnItemClickListener((arg0, arg1, position, arg3) -> {
      Object item = mDrawerCategoriesList.getAdapter().getItem(position);
      if (mainActivity.updateNavigation(String.valueOf(((Category) item).getId()))) {
        mDrawerCategoriesList.setItemChecked(position, true);
        // Forces redraw
        if (mDrawerList != null) {
          mDrawerList.setItemChecked(0, false);
          EventBus.getDefault()
              .post(new NavigationUpdatedEvent(mDrawerCategoriesList.getItemAtPosition
                  (position)));
        }
      }
    });
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.models.adapters;
import static android.graphics.Color.parseColor;
import static android.view.LayoutInflater.from;
import static it.feio.android.omninotes.databinding.DrawerListItemBinding.inflate;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import static java.lang.Integer.parseInt;
import android.app.Activity;
import android.graphics.LightingColorFilter;
import android.graphics.Typeface;
import android.view.View;
import android.view.ViewGroup;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.adapters.category.CategoryViewHolder;
import java.util.List;
public class CategoryRecyclerViewAdapter extends RecyclerView.Adapter<CategoryViewHolder> {
  private final Activity mActivity;
  private final List<Category> categories;
  private final String navigationTmp;
  public CategoryRecyclerViewAdapter(Activity mActivity, List<Category> categories) {
    this(mActivity, categories, null);
  }
  public CategoryRecyclerViewAdapter(Activity mActivity, List<Category> categories,
      String navigationTmp) {
    this.mActivity = mActivity;
    this.categories = categories;
    this.navigationTmp = navigationTmp;
  }
  @Override
  public int getItemCount() {
    return categories.size();
  }
  @NonNull
  @Override
  public CategoryViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
    return new CategoryViewHolder(inflate(from(parent.getContext()), parent, false));
  }
  @Override
  public void onBindViewHolder(@NonNull CategoryViewHolder holder, int position) {
    var category = categories.get(position);
    holder.txtTitle.setText(category.getName());
    if (isSelected(position)) {
      holder.txtTitle.setTypeface(null, Typeface.BOLD);
      holder.txtTitle.setTextColor(parseInt(category.getColor()));
    } else {
      holder.txtTitle.setTypeface(null, Typeface.NORMAL);
      holder.txtTitle.setTextColor(mActivity.getResources().getColor(R.color.drawer_text));
    }
    // Set the results into ImageView checking if an icon is present before
    if (category.getColor() != null && category.getColor().length() > 0) {
      var img = mActivity.getResources().getDrawable(R.drawable.ic_folder_special_black_24dp);
      var cf = new LightingColorFilter(parseColor("#000000"), parseInt(category.getColor()));
      img.mutate().setColorFilter(cf);
      holder.imgIcon.setImageDrawable(img);
      holder.imgIcon.setPadding(4, 4, 4, 4);
    }
    showCategoryCounter(holder, category);
  }
  private void showCategoryCounter(@NonNull CategoryViewHolder holder, Category category) {
    if (Prefs.getBoolean("settings_show_category_count", true)) {
      holder.count.setText(String.valueOf(category.getCount()));
      holder.count.setVisibility(View.VISIBLE);
    }
  }
  @Override
  public long getItemId(int position) {
    return position;
  }
  private boolean isSelected(int position) {
    var navigationListCodes = mActivity.getResources()
        .getStringArray(R.array.navigation_list_codes);
    // Managing temporary navigation indicator when coming from a widget
    var navigationTmpLocal = MainActivity.class.isAssignableFrom(mActivity.getClass())
        ? ((MainActivity) mActivity).getNavigationTmp()
        : null;
    navigationTmpLocal = this.navigationTmp != null ? this.navigationTmp : navigationTmpLocal;
    var navigation = navigationTmp != null
        ? navigationTmpLocal
        : Prefs.getString(PREF_NAVIGATION, navigationListCodes[0]);
    return navigation.equals(String.valueOf(categories.get(position).getId()));
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.models.adapters;
import static it.feio.android.omninotes.databinding.DrawerListItemBinding.inflate;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import android.app.Activity;
import android.content.Context;
import android.graphics.Color;
import android.graphics.LightingColorFilter;
import android.graphics.Typeface;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.adapters.category.CategoryViewHolder;
import java.util.List;
public class CategoryBaseAdapter extends BaseAdapter {
  private final Activity mActivity;
  private final int layout;
  private final List<Category> categories;
  private final LayoutInflater inflater;
  private final String navigationTmp;
  public CategoryBaseAdapter(Activity mActivity, List<Category> categories) {
    this(mActivity, categories, null);
  }
  public CategoryBaseAdapter(Activity mActivity, List<Category> categories, String navigationTmp) {
    this.mActivity = mActivity;
    this.layout = R.layout.drawer_list_item;
    this.categories = categories;
    this.navigationTmp = navigationTmp;
    inflater = (LayoutInflater) mActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  }
  @Override
  public int getCount() {
    return categories.size();
  }
  @Override
  public Object getItem(int position) {
    return categories.get(position);
  }
  @Override
  public long getItemId(int position) {
    return position;
  }
  public View getView(int position, View convertView, ViewGroup parent) {
    var category = categories.get(position);
    CategoryViewHolder holder;
    if (convertView == null) {
      convertView = inflater.inflate(layout, parent, false);
      holder = new CategoryViewHolder(
          inflate(LayoutInflater.from(parent.getContext()), parent, false));
      holder.imgIcon = convertView.findViewById(R.id.icon);
      holder.txtTitle = convertView.findViewById(R.id.title);
      holder.count = convertView.findViewById(R.id.count);
      convertView.setTag(holder);
    } else {
      holder = (CategoryViewHolder) convertView.getTag();
    }
    // Set the results into TextViews
    holder.txtTitle.setText(category.getName());
    if (isSelected(position)) {
      holder.txtTitle.setTypeface(null, Typeface.BOLD);
      holder.txtTitle.setTextColor(Integer.parseInt(category.getColor()));
    } else {
      holder.txtTitle.setTypeface(null, Typeface.NORMAL);
      holder.txtTitle.setTextColor(mActivity.getResources().getColor(R.color.drawer_text));
    }
    // Set the results into ImageView checking if an icon is present before
    if (category.getColor() != null && category.getColor().length() > 0) {
      var img = mActivity.getResources().getDrawable(R.drawable.ic_folder_special_black_24dp);
      var cf = new LightingColorFilter(Color.parseColor("#000000"),
          Integer.parseInt(category.getColor()));
      img.mutate().setColorFilter(cf);
      holder.imgIcon.setImageDrawable(img);
      int padding = 4;
      holder.imgIcon.setPadding(padding, padding, padding, padding);
    }
    // Sets category count if set in preferences
    if (Prefs.getBoolean("settings_show_category_count", true)) {
      holder.count.setText(String.valueOf(category.getCount()));
      holder.count.setVisibility(View.VISIBLE);
    }
    return convertView;
  }
  private boolean isSelected(int position) {
    // Getting actual navigation selection
    var navigationListCodes = mActivity.getResources()
        .getStringArray(R.array.navigation_list_codes);
    // Managing temporary navigation indicator when coming from a widget
    var navigationTmpLocal = MainActivity.class.isAssignableFrom(mActivity.getClass())
        ? ((MainActivity) mActivity).getNavigationTmp()
        : null;
    navigationTmpLocal = this.navigationTmp != null ? this.navigationTmp : navigationTmpLocal;
    var navigation = navigationTmp != null
        ? navigationTmpLocal
        : Prefs.getString(PREF_NAVIGATION, navigationListCodes[0]);
    return navigation.equals(String.valueOf(categories.get(position).getId()));
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.async;
import android.content.Context;
import android.content.Intent;
import android.os.Build.VERSION_CODES;
import androidx.annotation.NonNull;
import androidx.core.app.JobIntentService;
import it.feio.android.omninotes.BaseActivity;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.BuildHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.utils.ReminderHelper;
import java.util.List;
/**
 * Verify version code and add wake lock in manifest is important to avoid crash
 */
public class AlarmRestoreOnRebootService extends JobIntentService {
  public static final int JOB_ID = 0x01;
  public static void enqueueWork(Context context, Intent work) {
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.O)) {
      enqueueWork(context, AlarmRestoreOnRebootService.class, JOB_ID, work);
    } else {
      Intent jobIntent = new Intent(context, AlarmRestoreOnRebootService.class);
      context.startService(jobIntent);
    }
  }
  @Override
  protected void onHandleWork(@NonNull Intent intent) {
    LogDelegate.i("System rebooted: service refreshing reminders");
    Context mContext = getApplicationContext();
    BaseActivity.notifyAppWidgets(mContext);
    List<Note> notes = DbHelper.getInstance().getNotesWithReminderNotFired();
    LogDelegate.d("Found " + notes.size() + " reminders");
    for (Note note : notes) {
      ReminderHelper.addReminder(OmniNotes.getAppContext(), note);
    }
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD_ANSWER;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD_QUESTION;
import android.annotation.SuppressLint;
import android.os.Bundle;
import android.util.DisplayMetrics;
import android.view.ViewGroup;
import android.widget.EditText;
import com.afollestad.materialdialogs.MaterialDialog;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import de.keyboardsurfer.android.widget.crouton.Crouton;
import de.keyboardsurfer.android.widget.crouton.LifecycleCallback;
import it.feio.android.omninotes.async.bus.PasswordRemovedEvent;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.models.PasswordValidator;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.utils.Security;
public class PasswordActivity extends BaseActivity {
  private ViewGroup croutonHandle;
  private EditText passwordCheck;
  private EditText password;
  private EditText question;
  private EditText answer;
  private EditText answerCheck;
  private PasswordActivity mActivity;
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    DisplayMetrics metrics = getResources().getDisplayMetrics();
    int screenWidth = (int) (metrics.widthPixels * 0.80);
    int screenHeight = (int) (metrics.heightPixels * 0.80);
    setContentView(R.layout.activity_password);
    getWindow().setLayout(screenWidth, screenHeight);
    mActivity = this;
    setActionBarTitle(getString(R.string.title_activity_password));
    initViews();
  }
  @Override
  protected void onStart() {
    super.onStart();
    EventBus.getDefault().register(this, 1);
  }
  @Override
  public void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
  }
  private void initViews() {
    croutonHandle = findViewById(R.id.crouton_handle);
    password = findViewById(R.id.password);
    passwordCheck = findViewById(R.id.password_check);
    question = findViewById(R.id.question);
    answer = findViewById(R.id.answer);
    answerCheck = findViewById(R.id.answer_check);
    findViewById(R.id.password_remove).setOnClickListener(v -> {
      if (Prefs.getString(PREF_PASSWORD, null) != null) {
        PasswordHelper.requestPassword(mActivity, passwordConfirmed -> {
          if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
            updatePassword(null, null, null);
          }
        });
      } else {
        Crouton.makeText(mActivity, R.string.password_not_set, ONStyle.WARN, croutonHandle).show();
      }
    });
    findViewById(R.id.password_confirm).setOnClickListener(v -> {
      if (checkData()) {
        final String passwordText = password.getText().toString();
        final String questionText = question.getText().toString();
        final String answerText = answer.getText().toString();
        if (Prefs.getString(PREF_PASSWORD, null) != null) {
          PasswordHelper.requestPassword(mActivity, passwordConfirmed -> {
            if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
              updatePassword(passwordText, questionText, answerText);
            }
          });
        } else {
          updatePassword(passwordText, questionText, answerText);
        }
      }
    });
    findViewById(R.id.password_forgotten).setOnClickListener(v -> {
      if (Prefs.getString(PREF_PASSWORD, "").length() == 0) {
        Crouton.makeText(mActivity, R.string.password_not_set, ONStyle.WARN, croutonHandle).show();
        return;
      }
      PasswordHelper.resetPassword(this);
    });
  }
  public void onEvent(PasswordRemovedEvent passwordRemovedEvent) {
    passwordCheck.setText("");
    password.setText("");
    question.setText("");
    answer.setText("");
    answerCheck.setText("");
    Crouton crouton = Crouton.makeText(mActivity, R.string.password_successfully_removed,
        ONStyle.ALERT, croutonHandle);
    crouton.setLifecycleCallback(new LifecycleCallback() {
      @Override
      public void onDisplayed() {
        // Does nothing!
      }
      @Override
      public void onRemoved() {
        onBackPressed();
      }
    });
    crouton.show();
  }
  @SuppressLint("CommitPrefEdits")
  private void updatePassword(String passwordText, String questionText, String answerText) {
    if (passwordText == null) {
      if (Prefs.getString(PREF_PASSWORD, "").length() == 0) {
        Crouton.makeText(mActivity, R.string.password_not_set, ONStyle.WARN, croutonHandle).show();
        return;
      }
      new MaterialDialog.Builder(mActivity)
          .content(R.string.agree_unlocking_all_notes)
          .positiveText(R.string.ok)
          .onPositive((dialog, which) -> PasswordHelper.removePassword()).build().show();
    } else if (passwordText.isEmpty()) {
      Crouton.makeText(mActivity, R.string.empty_password, ONStyle.WARN, croutonHandle).show();
    } else {
      Prefs.edit()
          .putString(PREF_PASSWORD, Security.md5(passwordText))
          .putString(PREF_PASSWORD_QUESTION, questionText)
          .putString(PREF_PASSWORD_ANSWER, Security.md5(answerText))
          .apply();
      DbHelper.getInstance().getNotesWithLock(true)
          .forEach(note -> DbHelper.getInstance().updateNote(note, false));
      var crouton = Crouton.makeText(mActivity, R.string.password_successfully_changed,
          ONStyle.CONFIRM, croutonHandle);
      crouton.setLifecycleCallback(new LifecycleCallback() {
        @Override
        public void onDisplayed() {
          // Does nothing!
        }
        @Override
        public void onRemoved() {
          onBackPressed();
        }
      });
      crouton.show();
    }
  }
  /**
   * Checks correctness of form data
   */
  private boolean checkData() {
    boolean res = true;
    if (password.getText().length() == passwordCheck.getText().length()
        && passwordCheck.getText().length() == 0) {
      return true;
    }
    boolean passwordOk = !password.getText().toString().isEmpty();
    boolean passwordCheckOk =
        !passwordCheck.getText().toString().isEmpty() && password.getText().toString()
            .equals(
                passwordCheck.getText().toString());
    boolean questionOk = !question.getText().toString().isEmpty();
    boolean answerOk = !answer.getText().toString().isEmpty();
    boolean answerCheckOk =
        !answerCheck.getText().toString().isEmpty() && answer.getText().toString().equals
            (answerCheck.getText().toString());
    if (!passwordOk || !passwordCheckOk || !questionOk || !answerOk || !answerCheckOk) {
      res = false;
      if (!passwordOk) {
        password.setError(getString(R.string.settings_password_not_matching));
      }
      if (!passwordCheckOk) {
        passwordCheck.setError(getString(R.string.settings_password_not_matching));
      }
      if (!questionOk) {
        question.setError(getString(R.string.settings_password_question));
      }
      if (!answerOk) {
        answer.setError(getString(R.string.settings_answer_not_matching));
      }
      if (!answerCheckOk) {
        answerCheck.setError(getString(R.string.settings_answer_not_matching));
      }
    }
    return res;
  }
  @Override
  public void onBackPressed() {
    setResult(RESULT_OK);
    finish();
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.models.adapters;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import android.app.Activity;
import android.content.Context;
import android.graphics.PorterDuff;
import android.graphics.Typeface;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import com.neopixl.pixlui.components.textview.TextView;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.models.NavigationItem;
import java.util.Arrays;
import java.util.List;
public class NavDrawerAdapter extends BaseAdapter {
  private Activity mActivity;
  private List<NavigationItem> items;
  private LayoutInflater inflater;
  public NavDrawerAdapter(Activity mActivity, List<NavigationItem> items) {
    this.mActivity = mActivity;
    this.items = items;
    inflater = (LayoutInflater) mActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  }
  @Override
  public int getCount() {
    return items.size();
  }
  @Override
  public Object getItem(int position) {
    return items.get(position);
  }
  @Override
  public long getItemId(int position) {
    return position;
  }
  public View getView(int position, View convertView, ViewGroup parent) {
    NoteDrawerAdapterViewHolder holder;
    if (convertView == null) {
      convertView = inflater.inflate(R.layout.drawer_list_item, parent, false);
      holder = new NoteDrawerAdapterViewHolder();
      holder.imgIcon = convertView.findViewById(R.id.icon);
      holder.txtTitle = convertView.findViewById(R.id.title);
      convertView.setTag(holder);
    } else {
      holder = (NoteDrawerAdapterViewHolder) convertView.getTag();
    }
    // Set the results into TextViews
    holder.txtTitle.setText(items.get(position).getText());
    if (isSelected(position)) {
      holder.imgIcon.setImageResource(items.get(position).getIconSelected());
      holder.txtTitle.setTypeface(null, Typeface.BOLD);
      int color = mActivity.getResources().getColor(R.color.colorPrimaryDark);
      holder.txtTitle.setTextColor(color);
      holder.imgIcon.getDrawable().mutate().setColorFilter(color, PorterDuff.Mode.SRC_ATOP);
    } else {
      holder.imgIcon.setImageResource(items.get(position).getIcon());
      holder.txtTitle.setTypeface(null, Typeface.NORMAL);
      holder.txtTitle.setTextColor(mActivity.getResources().getColor(R.color.drawer_text));
    }
    return convertView;
  }
  private boolean isSelected(int position) {
    // Getting actual navigation selection
    String[] navigationListCodes = mActivity.getResources()
        .getStringArray(R.array.navigation_list_codes);
    // Managing temporary navigation indicator when coming from a widget
    String navigationTmp =
        MainActivity.class.isAssignableFrom(mActivity.getClass()) ? ((MainActivity) mActivity)
            .getNavigationTmp() : null;
    String navigation = navigationTmp != null ? navigationTmp
        : Prefs.getString(PREF_NAVIGATION, navigationListCodes[0]);
    // Finding selected item from standard navigation items or tags
    int index = Arrays.asList(navigationListCodes).indexOf(navigation);
    if (index == -1) {
      return false;
    }
    String navigationLocalized = mActivity.getResources()
        .getStringArray(R.array.navigation_list)[index];
    return navigationLocalized.equals(items.get(position).getText());
  }
}
/**
 * Holder object
 *
 * @author fede
 */
class NoteDrawerAdapterViewHolder {
  ImageView imgIcon;
  TextView txtTitle;
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.utils;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import android.content.Context;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.models.Category;
import java.util.ArrayList;
import java.util.Arrays;
public class Navigation {
  private Navigation() {
    // hides public constructor
  }
  public static final int NOTES = 0;
  public static final int ARCHIVE = 1;
  public static final int REMINDERS = 2;
  public static final int TRASH = 3;
  public static final int UNCATEGORIZED = 4;
  public static final int CATEGORY = 5;
  /**
   * Returns actual navigation status
   */
  public static int getNavigation() {
    String[] navigationListCodes = OmniNotes.getAppContext().getResources().getStringArray(
        R.array.navigation_list_codes);
    String navigation = getNavigationText();
    if (navigationListCodes[NOTES].equals(navigation)) {
      return NOTES;
    } else if (navigationListCodes[ARCHIVE].equals(navigation)) {
      return ARCHIVE;
    } else if (navigationListCodes[REMINDERS].equals(navigation)) {
      return REMINDERS;
    } else if (navigationListCodes[TRASH].equals(navigation)) {
      return TRASH;
    } else if (navigationListCodes[UNCATEGORIZED].equals(navigation)) {
      return UNCATEGORIZED;
    } else {
      return CATEGORY;
    }
  }
  public static String getNavigationText() {
    Context mContext = OmniNotes.getAppContext();
    String[] navigationListCodes = mContext.getResources()
        .getStringArray(R.array.navigation_list_codes);
    return Prefs.getString(PREF_NAVIGATION, navigationListCodes[0]);
  }
  /**
   * Retrieves category currently shown
   *
   * @return ID of category or null if current navigation is not a category
   */
  public static Long getCategory() {
    return CATEGORY == getNavigation() ? Long.valueOf(Prefs.getString(PREF_NAVIGATION, "")) : null;
  }
  /**
   * Checks if passed parameters is the actual navigation status
   */
  public static boolean checkNavigation(int navigationToCheck) {
    return checkNavigation(new Integer[]{navigationToCheck});
  }
  public static boolean checkNavigation(Integer[] navigationsToCheck) {
    boolean res = false;
    int navigation = getNavigation();
    for (int navigationToCheck : new ArrayList<>(Arrays.asList(navigationsToCheck))) {
      if (navigation == navigationToCheck) {
        res = true;
        break;
      }
    }
    return res;
  }
  /**
   * Checks if passed parameters is the category user is actually navigating in
   */
  public static boolean checkNavigationCategory(Category categoryToCheck) {
    Context mContext = OmniNotes.getAppContext();
    String[] navigationListCodes = mContext.getResources()
        .getStringArray(R.array.navigation_list_codes);
    String navigation = Prefs.getString(PREF_NAVIGATION, navigationListCodes[0]);
    return (categoryToCheck != null && navigation.equals(String.valueOf(categoryToCheck.getId())));
  }
}